<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Effective Java 3rd 2018 - Переклад українською</title>
  </head>
  <body>
    <p> </p>
    <address>%Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Київ 2018</address>
    <h1 class="h2f" style=" font-size: 26px; margin-top: 30px; margin-bottom: 30px; font-family: sans-serif; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Joshua
      Bloch - Effective Java (3rd) - 2018</h1>
    <h2 class="h2f" style="font-size: 26px; margin-top: 30px; margin-bottom: 30px; font-family: sans-serif; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Передмова</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      колега скаже тобі “Моя половина сьогодні ввечері вдома якусь незвичну їжу
      готуватиме. Ти міг приєднатися?” три речі можуть прийти на думку: третя -
      що ви були запрошені на вечерю; друга - що англійська не є рідною мовою
      вашого колеги; та перша це чимале здивування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви колись вивчали другу мову самотужки, та потім намагались
      використовувати її за межами класної кімнати, ви знаєте, що є три речі,
      які маєте засвоїти: як структурована мова (граматика), як називаються речі
      (словники), та особливі та ефективні шляхи розповідати про щоденні речі
      (ідіоматика). Часто в класній кімнаті вивчають тільки першу частину, та ви
      побачите, що природні носії мови весь час стримують посмішки, по мірі
      того, як ви намагаєтесь дати себе зрозуміти.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      загалом те саме з мовами програмування. Вам треба розуміти базову мову: чи
      вона алгоритмічна, функціональна, об'єктно-орієнтовна? Вам треба знати
      словник: як виглядають структури даних, операндів, та можливості, які
      провадять стандартні бібліотеки? Та вам треба бути знайомим зі звичними та
      ефектіврними шляхами структурувати код. Книги щодо програмних мов часто
      покривають тільки перші дві теми, або дискутують використання дуже
      вибірково. Може це через те, що перші дещо простіші для описання.
      Граматика та словник є властивостями самої мови, але використання є
      характеристикою спільноти щодо використання.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мова
      програмування Java, наприклад, є об'єктно-орієнтованою з поодиноким
      наслідуванням, та підтримує імперативний (твердження-орієнтовний) стиль
      кодування в кожному методі. Бібліотеки адресують підтримку графіки, мереж,
      розподіленого виконання та безпеку. Але як найкраще використовувати цю
      мову на практиці?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      інше міркування. Програми, на відміну від речень мовлення, та на відміну
      від більшості книг та журналів, з часом напевне будуть зазнавати змін.
      Звичайно не достатньо спродукувати код, що ефективно оперує та легко може
      бути зрозумілий іншими; ви також маєте гарно оргнізувати код, щоб його
      було легко модифікувати. Можуть існувати якісь десять способів написати
      код для деякого завдання <span class="Apple-converted-space"></span><em>T</em>.
      З ціх десяти методів сім будуть незручні, неефективні, або приголомшиві. З
      інших трох, який є найбіш вірогідим до коду, який буде вирішувати завдання
      <span class="Apple-converted-space"></span><em>T'</em><span class="Apple-converted-space">
        в наступному релізі через рік</span>?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існують
      числені книги, з яких ви можете навчитись граматики мови програмування
      Java, включаючи <span class="Apple-converted-space"></span><em>The Java</em><sup>™</sup><span
        class="Apple-converted-space">&nbsp;</span><em>Programming Language</em><span
        class="Apple-converted-space"> від</span> Arnold, Gosling, and Holmes,
      або<span class="Apple-converted-space"> </span><em>The Java</em><sup>™</sup><span
        class="Apple-converted-space">&nbsp;</span><em>Language Specification</em><span
        class="Apple-converted-space"> від</span> Gosling, Joy, щиро ваші, та
      Bracha. Так само є купа книг по бібліотекам та API, асоційованих з мовою
      програмування Java.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга адресує вашу третю потребу: звичне та ефективне використання. Joshua
      Bloch витратив роки розширюючи, реалізуючи,&nbsp; та використовуючи мову
      програмування Java в Sun Microsystems; він також читав багато кода інших
      людей, включаючий мій. Тут ми надаємо гарні поради, систематично
      організовані, по тому, як структурувати ваш код, так щоб він гарно
      працював, так щоб інші люди могли зрозуіти його, та щоб майбутні
      модифікацї та покращення малоймовірно викликали головний біль — можливо,
      навіть так, щоб ваші програми були приємні, елегантні та витончені.</p>
    <p class="right" style="margin-top: 15px; margin-bottom: 15px; text-align: right; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.3; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Guy
      L. Steele Jr.<br>
      <em>Burlington, Massachusetts<br>
        April 2001</em></p>
    <p> </p>
    <h2 class="h2f" id="preface" style="font-size: 26px; margin-top: 30px; margin-bottom: 30px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Передмова</strong></h2>
    <h3 class="h3a" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 20px; page-break-after: avoid; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Передмова
        до третього видання</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        class="Apple-converted-space"></span>В 1997-му році, коли Java була
      новою, James Gosling (батько Java), описував її як “мову синіх комірців”
      що була “досить простою” [<a href="ref.xhtml#rGosling97" style="text-decoration: none;">Gosling97</a>].
      Приблизно в той же час, Bjarne Stroustrup (батько C++) описував C++ як
      “багато-парадигмову мову”, що “навмисне відрізняється від мов, призначених
      підтримувати один спосіб написання програм” [<a href="ref.xhtml#rStroustrup95"
        style="text-decoration: none;">Stroustrup95</a>]. Stroustrup попереджав:</p>
    <p class="bq" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 19.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Більшість
      з відносної простоти Java — як і більшості нових мов — частково є
      іллюзією, і частково є функцією їх неповноти. Як спливатиме час, Java буде
      значно зростати в розмірі та складності. Вона зросте вдвічі або втричі за
      розміром та наростить залежні від реалізації розширення або бібліотеки. [<a
        href="ref.xhtml#rStroustrup" style="text-decoration: none;">Stroustrup</a>]</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зараз,
      на двадцять років пізніше, буде часним сказати, що обоє, Gosling та
      Stroustrup, були праві. Java тепер велика та складна, з багатьма
      абстракціями для багатьох речей, від паралельного виконання, до ітерації,
      до представлення дати та часу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Я
      все ще люблю Java, хоча мій запал трохи охолов, по мірі зростання
      платформи. Маючи це зростання розміру та складності, потреба в нагальних
      практиках застосування стає все більш критичною. Це третя редакція <span
        class="Apple-converted-space"></span><em>Effective Java</em>, та я
      доклав найкращих зусиль до цього видання. Я маю надію що ця редакція
      продовжує задовільняти вашим потребам, залишаючись вірною духу перших
      двох.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мале
      прекрасне, але просте не є простим.</p>
    <p class="right" style="margin-top: 15px; margin-bottom: 15px; text-align: right; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>San
        Jose, California<br>
        November 2017</em></p>
    <p class="noindentt" style="margin-top: 15px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">P.S.
Я
      буду нечесним, якщо не згадаю кращі практики (<em>софтверної</em>)
      індустрії, якій я присвячував більшість свого часу в минулому. З початку
      народження нашої справи в 1950-х, ми вільно реалізовували API одне одного.
      Ця практика була критичною для стрімкого успіху комп'ютерної технології. Я
      виявляв активність для збереження цієї волі (to preserve this freedom) [<a
        href="ref.xhtml#rCompSci17" style="text-decoration: none;">CompSci17</a>],
      та заохочую вас приєднатись до мене. Є критичним для здоров'я нашої
      професії, якщо ми збережемо право переписувати API один одного.</p>
    <h3 class="h3a" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 20px; page-break-after: avoid; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Передмова
        до другого видання</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      чого відбулося з платформою Java з тих пір, коли я писав першу редакцію
      цієї книги в 2001-му році, та прийщов гарний час для другої редакції.
      Найбільш важливий набір змін було додавання дженериків, типів переліку,
      анотацій, автобоксінгу, та циклів for-each в Java 5. Близько до цого було
      додання нової конкурентної бібліотеки,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">java.util.concurrent</code>,
      що також вийшла в Java 5. Разом з Gilad Bracha, я мав гарну нагоду
      очолювати команди, що розробляли ці можливості мови. Також я мав щастя
      прислужитись команді, що розробляла бібліотеку конкурентності, та якою
      керував Doug Lea.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інша
      велика зміна в платформі є широке поширення сучасних редакторів коду,
      Integrated Development Environments (IDEs), таких як Eclipse, IntelliJ
      IDEA, та NetBeans, та інструментів статичного аналізу, таких як FindBugs.
      Хоча я не був задіяний в ціх спробах, я безпосередньо мав вигоди від них,
      та спостерігав, як вони впливали на досвід розробки Java.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      2004 я перейшов з Sun до Google, але я продовжував мій розвиток в розробці
      на Java протягом останніх чотирьох років, докладаючи код до API
      конкуренції та колекції через гарні офіси Google та Java Community
      Process. Я мав насолоду використовувати Java платформу для розробки
      бібліотек для використання в Google. Тепер я знаю, що значить відчувати
      себе користувачем.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      і в випадку року 2001, коли я писав першу редакцію, моя первинна ціль була
      поширити мій досвід серед вас, так, щоб ви могли імітувати мої вдачі,
      уникаючи моїх помилок. Новий матеріал продовжує (<em>практику</em>)
      вільного використання прикладів з реального світу від бібліотек платформи
      Java.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Перша
      редакція була успішною далеко краще моїх сподівань, і я доклав кращих
      зусиль, щоб зберігти дух (<em>першого видання</em>), при цьому втручаючи
      новий матеріал, що мав підтримувати книгу на сучасному рівні. Було
      безсумнівно, що книга буде розростатись, і вона розрослась з сорокасеми до
      семидесятивосьми пунктів. Я не тільки додав двадцятьтри пункти, але я
      також щільно передивився оригінальний матеріал, та відправив декілька
      пунктів у відставку, кращі дні яких спливли. В Додатку ви можете побачити,
      як матеріал цього видання пов'язаний з матеріалом першої редакції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      передмові до першого видання я писав, що мова програмування Java та її
      бібліотеки значно додали в якості та продуктивності, та з ними стало
      приємніше працювати. Зміни в релізах 5 та 6 отримали гарну річ, та зробили
      її краще. Платформа стала значно більшою, ніж вона була в 2001-му році, та
      стала складнішою, але якщо ви вивчили шаблони та ідіоми для використання
      нових можливостей, ви зробите ваші програми кращими, та ваше життя
      простішим. Я маю надію, що це редакція захопила мій постійний інтузіазм
      щодо платформи, та допомагає зробити використання цієї платформи та її
      нових можливостей більш ефективним та приємним.</p>
    <p class="right" style="margin-top: 15px; margin-bottom: 15px; text-align: right; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>San
        Jose, California<br>
        April 2008</em></p>
    <h3 class="h3a" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 20px; page-break-after: avoid; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Передмова
        до першої редакції</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      1996 я підвищив ставки, та подався на Захід для роботи в компанії
      JavaSoft, як вона тоді була відома, оскільки мені було ясно, що це місце
      де відбуваються справи. Протягом наступних п'яти років я служив справі як
      архитектор бібліотек Java. Я розробляв, реалізував та підтримував багато
      бібліотек, та консультував багато кого. Робота з ціма бібліотеками по мірі
      зрослішання&nbsp; Java платформи була подією, що відбувається раз в житті.
      Не буде перебільшенням сказати, що я мав привелегію робити з деякими з
      найвеличніших софтверних інженерів нашого покоління. В процесі цього я
      навчився багато чого щодо мови програмування Java — що робить, що ні, та
      як використовувати її бібліотеки для кращого ефекту.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга є моєю спробою поділити мій досвід з вами, так що ви можете
      імітувати мій успіх, та уникнути моїх помилок. Я позичив формат з Scott
      Meyers’s<span class="Apple-converted-space">&nbsp;</span><em>Effective C++</em>,
      що складається з п'ятидесяти елементів, кожний складає особливе правило
      для покращення ваших програм та їх дизайну. Я винайшов цей формат
      остаточно ефективним, та маю надію ви також.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      багатьох випадках я обирав вільно ілюструвати теми прикладами з реального
      світу з бібліотек платформи Java. Коли я описую дещо, що можна зробити
      краще, я намагаюсь надати код, що я писав сам, але часом я обираю код,
      написаний моїм колегою. Я щиро перепрошую, якщо, попри мої кращі
      намагання, я образив когось. Негативні приклади наведені не для розпалення
      образ, але в дусі кооперації, так що всі ми можемо отримати вигоду від
      досвіду того, що робилось до цього.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      ця книжка не націлена винятково на розробників повторно використовуваних
      компонентів, вона неодмінно розфарбована моїм досвідом в написанні ціх
      компонент на протязі останніх двох десятисіть. Я природно думаю в термінах
      експортованих&nbsp; API (Application Programming Interfaces), та я раджу
      робити так само. Навіть якщо ви не розробляєте повторно використовувані
      компоненти, мислення в ціх термінах призводить до покращення якості
      софтверу, що ви пишете. Більше того, не є загальним писати компоненти без
      того, щоб знати їх: ви пишете дещо корисне, поділяючи це з товаришом по
      цеху, та з часом ви маєте з пів дюжини користувачів. На цей час ви не
      маєте досить гнучкості змінити API за власним бажанням, та досить вдячні
      собі за весь той труд, що ви поклали в розробку API, коли перший час
      писали ваш софт.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мій
      фокус на розробці API може виглядати трохи неприродним в світі новітніх
      методологій облегченого програмного забезпечення, як <span class="Apple-converted-space"></span><em>Екстремальне
        програмування</em>. Ці методології наполягають на написанні найпростіших
      програм, що взагалі здатні працювати. Якщо ви використовуєте одну з ціх
      методологій, ви винайдете, що фокусування на розробці API гарно
      прислужиться вам в процесі <em>рефакторінгу</em>. Фундаментальні цілі
      рефакторингу є покращення структури системи, та відсутність дублікації
      коду. Ці цілі неможливі досягти за відсутності гарно розробленого API для
      компонентів системи.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Немає
      ідеальної мови, але деякі чудові. Я знаходжу мову програмування Java та її
      бібліотеки надзвичайно сприятливі для якості та продуктивності, та також
      радості робити з нею. Я маю надію, що ця книга захопить мій інтузіазм, та
      допомагає вашому використанні мови більш ефективно та з насолодою.</p>
    <p class="right" style="margin-top: 15px; margin-bottom: 15px; text-align: right; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>Cupertino,
        California<br>
        April 2001</em></p>
    <p> </p>
    <h2 class="h2" id="ch1" style="font-size: 29px; margin-top: 30px; margin-bottom: 30px; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Глава
      1. Вступ</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        class="Apple-converted-space"></span>Ця книга розроблена допомогти вам
      зробити використання мови програмування Java ефективним, так само, як її
      фундаментальні бібліотеки:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">java.lang</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">java.util</code>, та <code
        style="font-family: 'Courier New', monospace;">java.io</code>, та
      суб-пакунки, як<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">java.util.concurrent</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">java.util.function</code>.
      Інші бібліотеки дискутуються час від часу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга складається з дев'яноста пунктів, кожний з яких доводить одне
      правило. Правила охоплюють практичні ідеї, що визнані кращими з найбільш
      досвідчених програмістів. Правила довільно поділені на одинадцять глав,
      кожна покриває один з широких аспектів розробки програмного забезпечення.
      Книга на призначена для читання від корки до корки: кожний пункт стоїть
      окремо, більш або менш. Елементи щільно посилаються один на одне, так що
      ви можете просто прокласти свій шлях по цій книзі.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      з нових можливостей були додані до платформи з часу останньої редакції
      друку цієї книги. Більшість&nbsp; з тем цієї книги використовують ці
      можливості в деякий спосіб. Ця таблиця показує, де вам шукати первинні
      описи ціх можливостей:</p>
    <table class="tablewidth" style="border-collapse: collapse; width: 1179px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; word-spacing: 0px; -webkit-text-stroke-width: 0px; height: 319px;">
      <tbody>
        <tr>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Можливість</strong></p>
          </td>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Пункти</strong></p>
          </td>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Реліз</strong></p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Лямбди</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch7.xhtml#lev42" style="text-decoration: none;">Пункти 42</a>–<a
                href="ch7.xhtml#lev44" style="text-decoration: none;">44</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              8</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Потоки</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch7.xhtml#lev45" style="text-decoration: none;">Пункти 45</a>–<a
                href="ch7.xhtml#lev48" style="text-decoration: none;">48</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              8</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Опції</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch8.xhtml#lev55" style="text-decoration: none;">Пункт 55</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              8</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Методи
              по замовчанню інтерфейсів</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch4.xhtml#lev21" style="text-decoration: none;">Пункт 21</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              8</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">try</code>-with-resources</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch2.xhtml#lev9" style="text-decoration: none;">Пункт 9</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              7</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">@SafeVarargs</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch5.xhtml#lev32" style="text-decoration: none;">Пункт 32</a></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              7</p>
          </td>
        </tr>
        <tr>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Модулі</p>
          </td>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><a
                href="ch4.xhtml#lev15" style="text-decoration: none;">Пункт 15</a></p>
          </td>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              9</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="indentt" style="margin-top: 13.333334px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_2"></span>Більшість пунктів ілюстровані
      прикладами програм. Ключова властивість цієї книги в тому, що вона містить
      приклади коду, що ілюструють багато з шаблонів розробки та ідіом. Коли це
      доцільно, вони перекресно посилаються на стандартні роботи в цій галузі [<a
        href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      пунктів містять один або більше прикладів програм, що ілюструють деякі
      практики, яких треба уникати, Такі прклади, іноді відомі як <em>антишаблони,
        </em>ясно відмічені відповідними коментарями, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>// Не робіть так!</strong></code>.
      В цьому випадку пунт пояснює, чому приклад поганий, та підказує
      альтернативний підхід.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга не розрахована на початківців: вважається, що ви добре знайомі з
      Java. Якщо це не так, погляньте на один або більше вступних текстів, як
      Sestoft<span class="Apple-converted-space"> </span><em>Java Precisely</em><span
        class="Apple-converted-space">&nbsp;</span>[<a href="ref.xhtml#rSestoft16"
        style="text-decoration: none;">Sestoft16</a>]. Тоді як <span class="Apple-converted-space"></span><em>Effective
        Java</em><span class="Apple-converted-space"> </span>розроблена бути
      доступною для будь-кого з робочим досвідом роботи з мовою, вона дає їжу
      для роздумів навіть для досвідчених програмістів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Більшість
      з правил в цій книзі походять від декількох фундаментальних принципів.
      Ясність та простота є наріжним каменем. Користувач компонента ніколи не
      має дивуватись його поведінкою. Компоненти можуть бути такі малі, як це
      можливо, але не менше. (Як використовується в цій книзі, термін <em>компонент</em><span
        class="Apple-converted-space"> посилається на любий повторно
        використовуваний програмний компонент, від окремого методу до складного
        фреймворку, що скаладається з декількох пакунків</span>). Код має бути
      викорстаний повторно, ніж скопійований. Залежність між компонентами має
      бути зведеною до мінімуму. Помилки треба виявляти так рано, як можливо,
      після того, як вони відбулись, в ідеалі під час компіляції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      правила в цій книзі не застосовуються в ста відсотках випадків, вони
      характерізують кращі практикі програмування в великій більшості випадків.
      Вам не треба рабськи слідувати цім правилам, але порушувати їх треба
      тільки часом, та з гарних причин. Навчання мистецтву програмування, як і
      більшості інших дисциплін, полягає в вивченні правил, та потім як
      порушувати їх.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      більшості випадків ця книга не стосується продуктивності. Вона про
      написання програм, що ясні, коректні, корисні, надійні, гнучкі та гарно
      підтримуються. Якщо ви можете досягти цього, зазвичай відносно просто
      також досягти гарної продуктивності (Елемент 67). Деякі пункти торкаються
      питань продуктивності, та декілька наводять показники продуктивності. Ці
      числа, що розпочинаються фразою “На моїй машині” треба сприймати,
      щонайбільше, як приблизні.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      дещо уточнити, моя машина є саморобна 3.5GHz quad-core Intel Core
      i7-4770K, з 16Гб DDR3-1866 CL9 RAM, що виконує реліз Azul Zulu 9.0.0.15
      OpenJDK, на Microsoft Windows 7 Professional SP1 (64-bit).</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_3"></span>Коли іде мова про можливості
      мови програмування Java та її бібліотеки, іноді потрібно посилатись на
      певні релізи. Для зручності ця книга використовує псевдоніми замість
      офіційних назв. Ця таблиця показує відображення між іменами релізів та
      псевдонімами:</p>
    <table class="tablewidth" style="border-collapse: collapse; width: 1179px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
      <tbody>
        <tr>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Офіційна
                назва релізу</strong></p>
          </td>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Нікнейм</strong></p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">JDK
              1.0.<em>x</em></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              1.0</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">JDK
              1.1.<em>x</em></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              1.1</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              2 Platform, Standard Edition, v1.2</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              2</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              2 Platform, Standard Edition, v1.3</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              3</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              2 Platform, Standard Edition, v1.4</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              4</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              2 Platform, Standard Edition, v5.0</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              5</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              Platform, Standard Edition 6</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              6</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              Platform, Standard Edition 7</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              7</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              Platform, Standard Edition 8</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              8</p>
          </td>
        </tr>
        <tr>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              Platform, Standard Edition 9</p>
          </td>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Java
              9</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="indentt" style="margin-top: 13.333334px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Приклади
      є досить повними, але більше націлені на просте читання, ніж на повноту.
      Вони вільно використовують класи з пакунків <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">java.util</code><span class="Apple-converted-space">
        та </span><code style="font-family: 'Courier New', monospace;">java.io</code>.
      Щоб скомпілювати приклади вам треба додати одну або декілька декларацій
      імпорту, або ще якість загальні речі. Сайт цієї книги, <code style="font-family: 'Courier New', monospace;"><a
          href="http://joshbloch.com/effectivejava" style="text-decoration: none;">http://joshbloch.com/effectivejava</a></code>,
      містить розширену версію кожного криклада, що може бути скомпільований та
      виконаний.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      більшості місць ця книга використовує технічні терміни, як вони визачені в
      <span class="Apple-converted-space"></span><em>The Java Language
        Specification, Java SE 8 Edition</em><span class="Apple-converted-space">&nbsp;</span>[<a
        href="ref.xhtml#rJLS" style="text-decoration: none;">JLS</a>]. Деякі
      терміни мають власне значення. Мова підтримує чотири різновиди типів:<span
        class="Apple-converted-space"> </span><em>інтерфейси</em><span class="Apple-converted-space">
      </span>(включаючи<span class="Apple-converted-space"> </span><em>анотації</em>),<span
        class="Apple-converted-space"> </span><em>класи</em><span class="Apple-converted-space">
      </span>(включаючи<span class="Apple-converted-space"> </span><em>enum</em>),<span
        class="Apple-converted-space"> </span><em>масиви</em>, та<em> примітиви</em>.
      Перші три відомі як <em>типи посилання</em>. Примірники класів та масиви
      є об'єктами; примітивні типи ні. Члени класів складаються з <em>полів</em>,
      <em>методів, членів-класів </em>та <em>членів-інтерфейсів</em><em>.</em><span
        class="Apple-converted-space"> <em>Сигнатура метода </em>складається з
        імені та типів формальних параметрів</span>; сигнатура <em>не включає
        тип повернення метода</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга використовує деякі терміни відмінно від <span class="Apple-converted-space"></span><em>The
        Java Language Specification</em>. На відміну від <em>Java Language
        Specification</em>, ця книга використовує <span class="Apple-converted-space"></span><em>inheritance</em>as
      (наслідування) як синонім для<span class="Apple-converted-space"> </span><em>subclassing
        </em>(утворення субкласів). Замість використовувати термін наслідування
      для інтерфейсів, ця книга просто стверджує, що клас <em>реалізує </em>інтерфейс,
      або що один інтерфейс <em>розширює </em>інший. Щоб описати рівень
      доступу, що застосовується коли нічого не вказано, ця книга використовує
      тридиційне <em>пакунок-приватне, </em>замість технічно коректного <em>пакетного
        доступу</em><span class="Apple-converted-space"> </span>[JLS, 6.6.1].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      книга використовує декілька технічніх термінів, що не визначені в <span class="Apple-converted-space"></span><em>The
        Java Language Specification</em>. Термін<span class="Apple-converted-space"></span><em>
        експортовані API</em>, або просто<span class="Apple-converted-space"> </span><em>API</em>,
      посилаючись на класи, інтерфейси, конструктори, члени, та серіалізовані
      форми, через які програміст отримує доступ до класів, інтерфейсів, або
      пакунку. (Термін <em>API</em>, що є скороченням до <span class="Apple-converted-space"></span><em>application
        programming interface</em>, використовується переважно до терміну <em>інтерфейс,
        </em>щоб уникнути напорозуміння з мовним конструктивом з такою ж
      назвою). Програміст, який пише програму, що використовує це API, виступає
      як <em>користувач </em>цього API. Клас, чия реалізація використовує API,
      <em>клієнтом </em>цього API.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Класи,
      інтерфейси, конструктори, члени, та серіалізовані форми загалом відомі як
      <em>елементи </em><span class="Apple-converted-space"></span><em>API</em>.
      Експортований API складається з елементів API, доступних за межами
      пакунка, в якому визначений цей API. Це елементи API, що може
      використовувати кожен клієнт, і які автор цього API обіцяє підтримувати.
      Не випадково, це також елеенти, для яких утіліта Javadoc генерує
      документацію в перебігу подій за замовчанням. Просто кажучи, експортований
      API пакунку скаладається з публічних та захищених членів та конструкторів
      кожного публічного класу або інтерфейсу в пакунку.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      Java 9 до платформи була додана<span class="Apple-converted-space"> </span><em>система
        модулів</em>. Якщо бібліотека використовує систему модулів, її
      експортований API буде об'єднаням експортованих API всіх пакунків,
      експортованих декларацією модуля бібліотеки.</p>
    <p> </p>
    <p> </p>
    <p> </p>
    <p> </p>
    <h2 class="h2" id="ch2" style="font-size: 29px; margin-top: 30px; margin-bottom: 30px; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Глава
      2. Створення та руйнування об'єктів</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      глава займається створенням та руйнуванням об'єктів: коли та як їх
      створювати, коли та як уникати їх створення, як переконатись, що вони
      своєчасно зруйновані, та як керувати діями з очищення, що мають передувати
      їх знищенню.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Елемент
        1: Розгляньте статичні методи-фабрики замість конструкторів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Традиційний
      шлях для класу дозволити клієнту отримати примірник - це запровадити
      публічний конструктор. Існує також інший прийом, що повинен стати частиною
      інструментарію кожного програміста. Клас може провадити публічний <span class="Apple-converted-space"></span><em>статичний
        метод-фабрику</em>, що є просто статичним методом, що повертає примірник
      класу. Ось простий приклад від <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Boolean</code><span class="Apple-converted-space">&nbsp;</span>(<span
        class="Apple-converted-space"></span><em>боксованого примітивного класу
      </em><span class="Apple-converted-space"></span>для<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">boolean</code>).
      Цей метод транслює примітивне значення <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">boolean</code><span class="Apple-converted-space">
      </span>на об'єктне посилання на об'єкт <code style="font-family: 'Courier New', monospace;">Boolean</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static Boolean valueOf(boolean b) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return b ? Boolean.TRUE : Boolean.FALSE;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що метод статичної фабрики не та саме, що і Шаблон Розробки<span class="Apple-converted-space">
      </span><em>Factory Method</em><span class="Apple-converted-space"> </span>[<a
        href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
      Метод статичної фабрики, описаний в цьому елементі, не має прямого
      еквіваленту в <span class="Apple-converted-space"></span><em>Design
        Patterns</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас
      може провадити своїм клієнтам методи статичної фабрики, замість, або на
      додаток до, публічних конструкторів. Провадженя статичного метода-фабрики,
      замість публічного конструктора, має також принади та недоліки.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Одна
        перевага статичних методів-фабрик в тому, що вони мають імена.</strong><span
        class="Apple-converted-space"> Якщо параметри конструктора не роблять
        цього, і самі по собі не описують об'єкт що буде повертатись, статична
        фабрика з гарно обраною назвою простіше використовувати, та отриманий
        код клієнта простіше читати</span>. Наприклад, конструктор <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger(int, int,
        Random)</code>, що повертає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code><span class="Apple-converted-space">,
        що можливо є простим, може бути краще виражений як метод статичної
        фабрики на ім'я</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">BigInteger.probablePrime</code>.
      (Цей метод був доданий в Java 4.)</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас
      може мати єдиний конструктор з певною сигнатурою. Програмісти раніше
      шукали обхідні шляхи коло цього обмеження, провадячи два конструктора, циї
      списки параметрів відрізняються тільки в порядку їх типів параметрів.
      Насправді це погана ідея. Користувач такого API ніколи не буде в змозі
      запам'ятати, який конструктор є який, та скінчить тим, що буде помилково
      викликати не той. Люди, які читають код, що використовує такі
      конструктори, не будуть знати що робить код без посилання на документацію
      класу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскльки
      всі воні мають імена, статичні методи фабрики не поділяють обмеження,
      описані в попередньому параграфі. В випадках, коли здається, що класи
      потребують декількох конструкторів з тою самою сигнатурою, замініть
      конструктори на статичні методи фабрик, та уважно оберіть імена, щоб
      наголосити на їх відмінності.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Друга
        перевага статичних методів фабрик в тому, що, на відміну від
        конструкторів, вони не мають створювати новий примірник кожного разу,
        коли їх викликають.</strong><span class="Apple-converted-space"> Це
        дозволяє незмінні класи </span>(<span style="text-decoration: none;">Елемент
        17</span>), та використання наперед створених примірників, або кешування
      примірників по мірі створення, та повторно розподіляти їх, для уникання
      небажаної дублікації об'єктів. Метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Boolean.valueOf(boolean)</code><span
        class="Apple-converted-space"> ілюструє цей прийом</span>: він<span class="Apple-converted-space">
      </span><em>ніколи не створює</em> об'єкти. Цей прийом подібний до
      шаблону&nbsp; <span class="Apple-converted-space"></span><em>Flyweight</em>
      [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
      Він може покращити продуктивність, якщо часто запитуються еквівалентні
      об'єкти, особливо якщо їх створення коштовне.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Здатність
      статичних методів фабрик повертати той саммий об'єкт від повторних
      викликів дозволяє класам підтримувати прямий контроль щодо того, які
      примірники існують в кожний момент часу. Класи, що роблятьт це, називають
      <span class="Apple-converted-space"></span><em>онтрольованими-примірниками.</em><span
        class="Apple-converted-space"> Існує декілька причин писати такі класи.
        Контоль за примірниками дозволяє класу гарантувати, що він&nbsp; є
        синглтоном </span>(<a href="ch2.xhtml#lev3" style="text-decoration: none;">Елемнт
        3</a>) або його примірників взагалі немає (<a href="ch2.xhtml#lev4" style="text-decoration: none;">Елемент
        4</a>). Також це дозволяє класи з незмінним значенням (<a href="ch4.xhtml#lev17"
        style="text-decoration: none;">Елемент 17</a>), що дає гарантію, що
      немає двох еквівалентних примірників:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">a.equals(b)</code><span class="Apple-converted-space">
        тоді і тільки тоді, коли</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">a == b</code>. Це основа
      шаблону <em>Легковажності</em><span class="Apple-converted-space"> (</span><em>Flyweight</em><span
        class="Apple-converted-space">)</span> [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
      Типи перелічень (<a href="ch6.xhtml#lev34" style="text-decoration: none;">Елемент
        34</a>) надають цю гарантію.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Третя
        перевага статичних методів фабрик в тому, що, на відміну від
        конструкторів, вони можуть повертати об'єт любого субтипу їх типу
        повернення.</strong><span class="Apple-converted-space"> Це дає вам
        велику гнучкість в виборі класу повернутого об'єкту</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Одне
      з застосувань цієї гнучості в тому, що API може повертати об'єкти без
      того, щоб робити їх класи публічними. Приховуючи реалізацію класів в цей
      спосіб призводить до дуже компактного API. Цей прийом сам по собі
      приводить до <em>базованих-на-інтерфейсах фреймворках</em><span class="Apple-converted-space">
      </span>(<a href="ch4.xhtml#lev20" style="text-decoration: none;">Елемент
        20</a>), де інтерфейси дають природні повертаємі типи для статичних
      методів-фабрик.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_7"></span>До появи Java 8 інтерфейси не
      могли мати ститичних методів. За домовленістю статичні методи фабрик для
      інтерфейсу на ім'я <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><em>Type</em></code><span
        class="Apple-converted-space">, покладались в <em>нестворюваний
          клас-компанйон</em></span><span class="Apple-converted-space"> </span>(<a
        href="ch2.xhtml#lev4" style="text-decoration: none;">Елемент 4</a>) на
      ім'я<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><em>Types</em></code>.
      Наприклад, Java Collections Framework мав сорок-п'ять допоміжних
      реалізацій власних інтерфейсів, провадячи немодифіковані колекції,
      синхронізовані колекції, і так далі. Майже всі з цїх реалізацій
      експортувались через статичні методи фабрики в одному нестворюваному класі
      (<code style="font-family: 'Courier New', monospace;">java.util.Collections</code>).
Класи
      повертаємих об'єктів всі були непублічними.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Collections
      Framework API є меншим, чив він мав би бути, якщо б експортував
      сорок-п'ять окремих публічних класів, по одному для кожної відомої
      реалізації. Це не тільки <em>купа </em>API, яку вдалось зменшити, але і
      <em>концептульна вага</em><em>:</em><span class="Apple-converted-space"> </span>число
      та складність концепцій, що мають засвоїти програмісти, щоб
      використовувати API. Програміст знає, що потрібний об'єкт має то саме API,
      яке вказане в інтерфейсі, так що немає потреби читати додаткові
      документації класів для класу реалізації. Більше того, маючи такий
      статичний метод фабрики потребує від клієнта посилання на повернутий
      об'єкт згідно інтерфейса, скоріше ніж класа реалізації, що загалом є
      гарною практикою (<a href="ch9.xhtml#lev64" style="text-decoration: none;">Елемент
        64</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В&nbsp;
      Java 8 обмеження, що інтерфейси не можуть містити статичні методи, було
      видалено, так що тепер є мало причин провадити нестворюваний
      клас-компанйон для інтерфейсу. Багато публічних статичних членів, що були
      б на своєму місці в такому класі, повинні замість цього бути розташовані в
      самому інтерфейсі. Зауважте, однак, що все ще може бути потрібним покласти
      багато з коду реалізації за межами ціх статичних методів в окремий,
      пакунок-приватний клас. Це тому, що Java 8 потребує, щоб статичні члени
      інтерфейса були публічними. Java 9 дозволяє приватні статичні методи, але
      статичні поля та статичні члени-класи все ще потребують бути публічними.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Четверта
        перевага статичних фабрик в тому, що клас повернутого об'єкту може
        варіюватись виклик від виклику, як функція вхідних параметрів.</strong><span
        class="Apple-converted-space"> Любий субтип задекларованого результату
        буде дозволеним. Клас повернутого об'єкту може також варіювати від
        релізу до релізу</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">EnumSet</code><span
        class="Apple-converted-space"> </span>(<a href="ch6.xhtml#lev36" style="text-decoration: none;">Елемент
        36</a>) не має публічних конструкторів, тільки статичні фабрики. В
      реалізації OpenJDK вони повертають примірник одного з двох субкласів, в
      залежності від розміру підлеглого типу enum: якщо він має
      шістьдесят-чотири або меньше елементів, як відбувається з більшістю
      переліків, статичні фабрикі повертають примірник<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">RegularEnumSet</code>,
      що підтримується поодиноким<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">long</code>; якщо тип
      enum має 65 або більше елементів, фабрики повертають примірник<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">JumboEnumSet</code>,
      представлений як масив<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">long</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наявність
      ціх двох класів-реалізацій невидиме для клієнтів. Якщо<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">RegularEnumSet</code><span
        class="Apple-converted-space"> припинить надавати переваги
        продуктивності для малих типів переліку, він може зникнути з наступних
        релізів без болісних ефектів. Подібно до цього, наступний реліз може
        додати третю або четверту реалізацію </span><code style="font-family: 'Courier New', monospace;">EnumSet</code><span
        class="Apple-converted-space">, якщо це буде вигідним для продуктивності</span>.
      Клієнти ніколи не знають, або не мають турбуватись щодо класу об'єкта, що
      буде повертатись з фабрики; вони турбуються тільки про те, що це якісь з
      субкласів <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">EnumSet</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>П'ята
        перевага статичних фабрик в тому, що класи повертаємих об'єктів не мають
        існувати, коли створюється клас, що містить створюваний метод. </strong><span
        class="Apple-converted-space"></span>Така гнучка статича форма метода
      фабрики є основою для <em>фреймворків провайдерів сервісіів, </em>як
      Java Database Connectivity API (JDBC). Фреймворк провайдера сервісу є
      системою, в якій провайдери реалізують сервіс, та система робить
      реалізацію доступною для кілєнтів, відділяючи клієнтів від реалізацій.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      три основних компонентів в фремворці провайдера сервісу: <em>інтерфейс
        сервісу, </em>що представляє реалізацію; <em>API реєстрації провайдера</em>,
      яке провайдери використовують для реєстрації реалізацій; <em>API доступу
        до сервісів</em>, який використоує клієт для отримання примірників
      сервісу. API доступу до сервісу можуть дозволити клієнтам вказувати
      критерії для обрання реалізації. За відсутності такої критерії, API
      повертає примірник реалізації по замовчанню, або дозволяє клієнтові
      проходити по можливим реалізаціям. API доступу до сервісу є гнучкою
      статичною фабрикою, що формує базис фреймворку провайдера сервісу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Опціональний
      четвертий компонент фреймворку провайдера сервісу є <em>інтерфейс
        провайдера сервісу</em>, що описує об'єкт фабрики, що продукує
      примірники інтерфейсу сервісу. За відсутності інтерфейсу провайдерів
      сервісу, реалізації мають бути утворювати примірники рефлективно (<a href="ch9.xhtml#lev65"
        style="text-decoration: none;">Елемент 65</a>). В випадку JDBC<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Connection</code><span
        class="Apple-converted-space"> </span>відіграє роль інтерфейсу сеpвісу,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">DriverManager.registerDriver</code><span
        class="Apple-converted-space"> є </span><span class="Apple-converted-space">
        API реєстрації провайдерів</span>, <code style="font-family: 'Courier New', monospace;">DriverManager.getConnection</code><span
        class="Apple-converted-space"> </span>є API доступа до сервіса, та <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Driver</code><span
        class="Apple-converted-space"> є інтерфейсом провайдера сервісу</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      багато шаблонів для фреймворку провайдера сервісів. Наприклад, API доступу
      до сервіса може повертати багатший інтерфейс сервісу до клієнтів, ніж той,
      що надають провайдери. Це шаблон Моста<span class="Apple-converted-space">.
      </span><em>Bridge</em><span class="Apple-converted-space">&nbsp;</span>pattern
      [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
      Фреймворки ін'єкції залежностей (<a href="ch2.xhtml#lev5" style="text-decoration: none;">Елемент
        5</a>) можа розглядати як потужний провайдер сервісів. Починаючи з Java
      6, платформа включає фреймворк провайдера сервісів загального призначеня,
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.util.ServiceLoader</code>,
      так що вам немає потреби, та загалом не повинні, писати ваші власні (<a href="ch9.xhtml#lev59"
        style="text-decoration: none;">Елемент 59</a>). JDBC не використовує<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">ServiceLoader</code>,
      бо той з'явився пізніше.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Головне
        обмеження на провадження тільки статичних методів фабрик в тому, що
        класи без публічних або захищених конструкторів не можуть мати
        субкласів. </strong><span class="Apple-converted-space"></span>Наприклад,
      неможливо створити субклас любого зі звичних класів реалізації в
      Collections Framework. Напевне, цьому можна тільки радіти, оскільки це
      заохочує програмістів використовувати композицію замість наслідування (<a
        href="ch4.xhtml#lev18" style="text-decoration: none;">Елемент 18</a>),
      та є вимогою для незмінних типів (<a href="ch4.xhtml#lev17" style="text-decoration: none;">Елемент
        17</a>).</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Другє
        обмеження статичних методів фабрик в тому, що програмістам складно їх
        знайти.</strong><span class="Apple-converted-space"> Вони не виділяються
        з документації </span>API в спосіб, як це роблять конструктори, так що
      може бути складним винайти, як можна створити примірник класу, що
      провадить статичні методи фабрик замість конструкторів. Інструмент Javadoc
      може з часом звернути увагу не статичні методи фабрики. В найближчий час
      ви можете зменшити цю проблему, через увагу до статичних методів фабрик в
      класі, або в документації, та приставши до загальних домовленостей по
      іменуванню. Ось деякі загальні імена для статичних методів фабрик. Список
      далекий від повноти:</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>from</strong></code>
      — Метод <em>перетворення типів, </em>що приймає єдиний параметр, та
      повертає відповідний примірник цього типу, наприклад:</p>
    <p class="codepb" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 10.666667px; margin-bottom: 10.666667px; margin-left: 36px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Date
      d = Date.from(instant);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>of</strong></code>
      — <em>Метод агрегації, </em>що приймає декілька параметрів, та повертає
      тип, що поєднує їх всі, наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Set&lt;Rank&gt;
      faceCards = EnumSet.of(JACK, QUEEN, KING);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>valueOf</strong></code>
      — Більш гучна альтернатива до <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">from</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">of</code>,
      наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">BigInteger
      prime = BigInteger.valueOf(Integer.MAX_VALUE);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>instance</strong></code><span
        class="Apple-converted-space"> </span>або<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>getInstance
          </strong></code>— Повертає примірник, що описаний параметром (якщо є),
      але не можна сказати, чи це буде мати те саме значення, наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">StackWalker
      luke = StackWalker.getInstance(options);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>create</strong></code><span
        class="Apple-converted-space">&nbsp;</span>oбо<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>newInstance</strong></code>
      — Як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">instance</code><span
        class="Apple-converted-space"> </span>або<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">getInstance</code>,
      за винятком того, що метод гарантує, що кожний виклик повертає новий
      примірник, наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Object
      newArray = Array.newInstance(classObject, arrayLen);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>get</strong></code><em><strong>Type</strong></em>
      — Як<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">getInstance</code>,
      але використовується, якщо метод фабрики знаходиться в іншому класі.<span
        class="Apple-converted-space">&nbsp;</span><em>Type</em><span class="Apple-converted-space">
        є типом об'єкта. що треба повернути методом файбрикою, наприклад</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">FileStore
      fs = Files.getFileStore(path);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>new</strong></code><em><strong>Type
          </strong></em>— Як<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">newInstance</code>,
      але використовується, якщо метод фабрики є іншого класу.<span class="Apple-converted-space">&nbsp;</span><em>Type</em><span
        class="Apple-converted-space"> </span>є типом, що повертає метод
      фабрика, наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">BufferedReader
      br = Files.newBufferedReader(path);</p>
    <p class="bull" style="margin-top: 0px; margin-bottom: 0px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><em><strong>type</strong></em>
      — Скорочена альтернатива до <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">get</code><em>Type</em><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">new</code><em>Type</em>,
      наприклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">List&lt;Complaint&gt;
      litany = Collections.list(legacyLitany);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, статичні методи фабрики та публічні конструктори, обоє мають
      своє застосування, і має сенс розібратись в їх відносних достоїнствах.
      Часто статичні фабрики є переважними, так що уникайте рефлекторного
      запровадження публічних конструкторів, зпочатку не розглянувши статичні
      фабрики.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_10"></span><strong>Елемент 2: Розгляньте
        білдер, коли стикнетесь з багатьма параметрами конструктора</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Статичні
      функції та конструктори поділяють одне обмеження: вони не маштабуються
      добре до великих чисел опціональних параметрів. Розглянемо випадок, коли
      клас представляє диєтичні факти, що клеяться на упаковках продуктів. Ці
      мітки можуть мати декілька обов'язкових полів — кількість на одну порцію,
      кількість порцій в пакунку, та калорії в одній порції — та більше ніж
      дванадцять опціональних полів — загальний вмст жирів, кількість насичених
      жирів, штучний жир, холестерол, вуглеводи і так далі. Більшість продуктів
      мають ненулеві значення тільки для деяких з ціх опціональних полів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Який
      різновид конструкторів або статичних фабрик повинні ви написати для такого
      класу? Традиційно програмісти використовують шаблон <em>телескопічні
        конструкції</em>, в якій ви провадите конструктор тільки з потрібними
      полями, інший з одним додатковим полем, третій з двома додатковими, і так
      далі, остаточно задавши конструктор з усіма функціональними параметрами.
      Ось як це виглядає на практиці. Для цілей краткості показані тільки чотири
      опціональні поля:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Шаблон телескопічного конструктора - негарно маштабується!</strong><br>
      public class NutritionFacts {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int servingSize;&nbsp;&nbsp;//
      (mL)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;
      потрібне<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int
      servings;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (порцій в пачці) потрібне<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int
      calories;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (на порцію)&nbsp;&nbsp;&nbsp;
      опціональне<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int
      fat;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
      (g/порцію)&nbsp;&nbsp;&nbsp;&nbsp; опціональне<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int
      sodium;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
      (mg/порцію)&nbsp;&nbsp;&nbsp; опціональне<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int carbohydrate; //
      (g/порцію)&nbsp;&nbsp;&nbsp;&nbsp; опціональне<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts(int servingSize, int
      servings) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(servingSize,
      servings, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts(int servingSize, int
      servings,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
      calories) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(servingSize,
      servings, calories, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts(int servingSize, int
      servings,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
      calories, int fat) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(servingSize,
      servings, calories, fat, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts(int servingSize, int
      servings,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
      calories, int fat, int sodium) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this(servingSize,
      servings, calories, fat, sodium, 0);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <span epub:type="pagebreak" id="page_11"></span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts(int servingSize, int
      servings,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int calories,
      int fat, int sodium, int carbohydrate) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.servingSize&nbsp;&nbsp;=
      servingSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.servings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
      servings;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.calories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
      calories;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.fat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
      fat;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.sodium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      = sodium;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.carbohydrate =
      carbohydrate;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви бажаєте створити примірник, ви використовуєте конструктор з найменшим
      списком параметрів, що містить всі параметри, які ви бажаєте встановити:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">NutritionFacts
      cocaCola =<br>
      &nbsp;&nbsp;&nbsp;&nbsp;new NutritionFacts(240, 8, 100, 0, 35, 27);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Типово
      виклик цього конструктора буде потребувати багато параметрів, що ви не
      бажаєте встановити, але ви змушені передавати значення для них в жодному
      разі. В цьому випадку ми передаємо значення 0 для вмісту жиру. "Тільки" з
      шістьома параметрами це може виглядати не так вже і погано, але це швидко
      вийде з-під контролю по мірі зростання числа параметрів. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      коротко, <span class="Apple-converted-space"></span><strong>шаблон
        телескопічного конструктора працює, але для нього складно писати
        клієнтський код, коли є багато параметрів, та ще складніше </strong><strong>це
        </strong><strong>читати.</strong><span class="Apple-converted-space">
        Читач залишається здивованим, що всі ці значення значать, та має уважно
        рахувати параметри, щоб розібратись в цьому</span>. Довгі послідовності
      ідентично типізованих параметрів можуть викликати непомітні помилки. Якщо
      клієнт випадково поміняє два такі параметри, компілятор не буде сваритись,
      але програма буде невірно поводитись під час виконання (<a href="ch8.xhtml#lev51"
        style="text-decoration: none;">Елемент 51</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Друга
      альтернатива, коли ви стикаєтесь з багатьма опціональними параметрами в
      конструкторі, є шаблон<span class="Apple-converted-space"> </span><em>JavaBeans</em>,
      коли ви викликаєте конструктор без параметрів для створення об'єкту, та
      потім викликати методи сеттери для встановлення кожного цікавого
      опціонального параметра:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Шаблон JavaBeans - дозволяє неузгодженість, нав'язує змінність</strong><br>
      public class NutritionFacts {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Parameters initialized to default values (if
      any)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int servingSize&nbsp;&nbsp;= -1; //
      Потрібне, немає значення по замовчанню;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int servings&nbsp;&nbsp;&nbsp;&nbsp; = -1;
      // Потрібне, немає значення по замовчанню;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int calories&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int
      fat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int
      sodium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int carbohydrate = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts() { }<br>
      <span epub:type="pagebreak" id="page_12"></span>&nbsp;&nbsp;&nbsp;&nbsp;//
      Setters<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setServingSize(int val)&nbsp;&nbsp;{
      servingSize = val; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setServings(int val)&nbsp;&nbsp;&nbsp;
      { servings = val; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setCalories(int val)&nbsp;&nbsp;&nbsp;
      { calories = val; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setFat(int
      val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ fat = val; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setSodium(int
      val)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ sodium = val; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void setCarbohydrate(int val) {
      carbohydrate = val; }<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      шаблон не має жодних недоліків шаблона телескопічного конструктора. Він
      простий, трохи балакучий при створенні примірників, та отриманний код
      просто читати:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">NutritionFacts
      cocaCola = new NutritionFacts();<br>
      cocaCola.setServingSize(240);<br>
      cocaCola.setServings(8);<br>
      cocaCola.setCalories(100);<br>
      cocaCola.setSodium(35);<br>
      cocaCola.setCarbohydrate(27);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">На
      жаль, шаблон JavaBeans сам по собі має серйозні недоліки. Оскільки
      конструювання розбите на декілька викликів,&nbsp;<strong> JavaBean може
        бути в неузгодженому стані на протязі свого створення.</strong><span class="Apple-converted-space">
        Клас не має опцій для примусу узгодженості, просто через перевірку
        валідності параметрів конструктора. Спроба використовувати об'єкт коли
        він в неузгодженому стані може привести до відмов, що далеко відстоять
        від кода, що містить баг, і, таким чином, складно відстежується.
        Пов'язаний недолік полягає в тому, що </span><strong>шаблон JavaBeans
        заважає можливості створити незмінний клас</strong><span class="Apple-converted-space">
      </span>(<a href="ch4.xhtml#lev17" style="text-decoration: none;">Елемент
        17</a>), та потребує додаткових зусиль з боку програміста, щоб
      забезпечити поточну безпеку.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Можливо
      зменшити ці негаразди, вручну "заморозивши" об'єкт на час створення до
      завершення побудови, та заборонити його використання на час заморожування,
      але цей варіант рідко використовується на практиці. Більше того, він може
      спричинити помилки часу виконання, оскільки компілятор не може
      переконатись, що програміст викликає метод заморожування на об'єкті до
      того, як використовувати його.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">На
      щастя, існує третя альтернатива, що комбінує безпеку шаблону
      телескопічного конструктора з читаємістю шаблону JavaBeans. Це форма
      шаблону Білдера, <span class="Apple-converted-space"></span><em>Builder</em><span
        class="Apple-converted-space">&nbsp;</span>pattern [<a href="ref.xhtml#rGamma95"
        style="text-decoration: none;">Gamma95</a>]. Замість робити бажаний
      об'єкт напряму, клієнт викликає конструктор (або статичну фабрику) з усіма
      потрібними полями, та отримує об'єкт <em>білдера</em>. Поітм клієнт
      викликає сеттер-подібні методи на об'єкті білдера для встановлювання всіх
      опціональних параметрів. Нарешті, клієнт викликає метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">build</code><span class="Apple-converted-space">
        без параметрів, що генерує об'єкт, що типово є незмінним. Білдер типово
        є статичним класом членом </span>(<a href="ch4.xhtml#lev24" style="text-decoration: none;">Елемент
        24</a>) класу, який він будує. Ось як це виглядає на практиці:</p>
    <span epub:type="pagebreak" id="page_13" style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"></span><span
      style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Builder Pattern</strong><br>
      public class NutritionFacts {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int servingSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int servings;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int calories;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int fat;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int sodium;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int carbohydrate;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static class Builder {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Обов'язкові параметри<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final int
      servingSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final int
      servings;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Опціональні параметри<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int
      calories&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int
      fat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int
      sodium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int
      carbohydrate&nbsp;&nbsp;= 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder(int
      servingSize, int servings) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.servingSize
      = servingSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.servings&nbsp;&nbsp;&nbsp;&nbsp;=
      servings;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder
      calories(int val)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      calories = val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder fat(int
      val)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      fat = val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      return this; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder sodium(int
      val)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      sodium = val;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this;
      }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder
      carbohydrate(int val)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      carbohydrate = val;&nbsp;&nbsp;return this; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public NutritionFacts
      build() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      new NutritionFacts(this);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private NutritionFacts(Builder builder) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servingSize&nbsp;&nbsp;=
      builder.servingSize;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;servings&nbsp;&nbsp;&nbsp;&nbsp;
      = builder.servings;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;calories&nbsp;&nbsp;&nbsp;&nbsp;
      = builder.calories;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;=
      builder.fat;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sodium&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      = builder.sodium;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carbohydrate =
      builder.carbohydrate;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_14"></span>Клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">NutritionFacts</code><span
        class="Apple-converted-space"> є незмінним, та всі значення параметрів
        знаходяться в одному місці</span>. Метод сеттера повертає сам білдер,
      так що виклики можна сціпити в ланцюжок, що дає <span class="Apple-converted-space"></span><em>побіжний
        API</em>. Ось як виглядає код клієнта:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">NutritionFacts
      cocaCola = new NutritionFacts.Builder(240, 8)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.calories(100).sodium(35).carbohydrate(27).build();</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      клієнтський код просто писати, та, що більш важливо, просто читати. <strong>Шаблон
        білдера симулює іменовані опціональні параметри</strong><span class="Apple-converted-space">,
        які існують в </span>Python та Scala.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Перевірки
      валідності випущені для скорочення. Щоб виявити невалідні параметри так
      скоро, як це можливо, перевіряйте валідність в конструкторі та методах
      білдерів. Перевіряйте інваріанти, включаючи декілька параметрів в
      конструкторі, що викликаєтсья в методі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">build</code>. Щоб
      перевірити ці інваріанти проти атак, робіть перевірки полів об'єкта після
      копіювання параметрів з білдера (<a href="ch8.xhtml#lev50" style="text-decoration: none;">Елемент
        50</a>). Якщо перевірка схибить, викликайте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">IllegalArgumentException</code>
      (<a href="ch10.xhtml#lev72" style="text-decoration: none;">Елемент 72</a>),
      чиє детальне повідомлення вказує, які параметри є невалідними (<a href="ch10.xhtml#lev75"
        style="text-decoration: none;">Елемент 75</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Шаблон
        білдера гарно пристосований до ієрархій класів.</strong><span class="Apple-converted-space">
      </span>Використовуйте паралельну ієрархію білдерів, кожний вкладений в
      відповідний клас. Абстрактні класи мають абстрактні білдери; суцільні
      класи мають суцільні білдери. Наприклад, розглянемо абстрактний клас в
      корені ієрархії, що представляє різні сорти піцци:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Шаблон білдерів для ієрархії класів</strong><br>
      public abstract class Pizza {<br>
      &nbsp;&nbsp;&nbsp;public enum Topping { HAM, MUSHROOM, ONION, PEPPER,
      SAUSAGE }<br>
      &nbsp;&nbsp;&nbsp;final Set&lt;Topping&gt; toppings;<br>
      <br>
      &nbsp;&nbsp;&nbsp;abstract static class<span class="Apple-converted-space">&nbsp;</span><strong>Builder&lt;T
        extends Builder&lt;T&gt;&gt;</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EnumSet&lt;Topping&gt; toppings =
      EnumSet.noneOf(Topping.class);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public T addTopping(Topping topping) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      toppings.add(Objects.requireNonNull(topping));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="Apple-converted-space">&nbsp;</span><strong>return
        self();</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;abstract Pizza build();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>// Субкласи мають перекривати
        цей метод, щоб повертати "this"</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>protected abstract T self();</strong><br>
      &nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;Pizza(Builder&lt;?&gt; builder) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;toppings = builder.toppings.clone();
      // See Елемент&nbsp; 50<br>
      &nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Pizza.Builder</code><span
        class="Apple-converted-space"> є</span><span class="Apple-converted-space">
        <em>дженерік типом з рекурсивним параметром типу </em></span>(<a href="ch5.xhtml#lev30"
        style="text-decoration: none;">Елемент 30</a>). Це, разом з абстрактним
      методом <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">self</code>,
      дозволяє зціплення методів, для відповідної роботи в субкласах без потреби
      в кастингу. Це обхідний маневр для факту, що в Java бракує типу self, що
      відоме як <em>ідіома симульованого self-типу</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_15"></span>Ось два суцільних субкласи <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Pizza</code>,
      один з яких представляє стандартну пицу в стилі New-York, та інший
      кальцоне. Перший має обов'язковий параметр розміру, та другий дозволяє вам
      задати, чи соус має бути зсередини чи зовні:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class NyPizza extends Pizza {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public enum Size { SMALL, MEDIUM, LARGE }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Size size;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static class Builder extends
      Pizza.Builder&lt;Builder&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private final Size size;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder(Size size)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.size
      = Objects.requireNonNull(size);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public NyPizza
      build() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      new NyPizza(this);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override protected
      Builder self() { return this; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private NyPizza(Builder builder) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(builder);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size = builder.size;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }<br>
      <br>
      public class Calzone extends Pizza {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final boolean sauceInside;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static class Builder extends
      Pizza.Builder&lt;Builder&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private boolean
      sauceInside = false; // Default<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public Builder
      sauceInside() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sauceInside
      = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      this;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public Calzone
      build() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      new Calzone(this);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override protected
      Builder self() { return this; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Calzone(Builder builder) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(builder);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sauceInside =
      builder.sauceInside;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_16"></span>Зауважте, що метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">build</code><span class="Apple-converted-space">
        в білдері кожного субкласу декларований щоб повертати коректний субклас</span>:
      метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">build</code><span
        class="Apple-converted-space"> </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">NyPizza.Builder</code>
      повертає<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">NyPizza</code>,
      тоді як той самий в <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Calzone.Builder</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Calzone</code>.
      Цей прийом, коли метод субкласа декларований повертати субтип типу,
      повертаємого в супер-класі, відомий як <em>коваріантна типізація
        повернення</em>. Це дозволяє клієнтам використовувати ці білдери без
      потреби кастингу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клієнтський
      код для ціх “ієрархічних білдерів” в основному іденичний до коду для
      простого білдера <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">NutritionFacts</code>.
      Приклад кода клієнта, показаний далі, вважає існування статичних enum
      констант:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">NyPizza
      pizza = new NyPizza.Builder(SMALL)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.addTopping(SAUSAGE).addTopping(ONION).build();<br>
      Calzone calzone = new Calzone.Builder()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.addTopping(HAM).sauceInside().build();</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мінорна
      перевага білдерів над конструкторами в тому, що білдери можуть мати багато
      множинних параметрів, оскільки кожний параметр вказаний у власному методі.
      Альтернативно, білдери можуть агрегувати параметри, передані в багатьох
      викликах в одне поле, як демонструється в методі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">addTopping</code><span class="Apple-converted-space">
        раніше</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Шаблон
      Builder є досить гнучким. Єдиний білдер може використовуватись повторно
      для будування декількох об'єктів. Параметри білдера можуть бути
      налаштовані між викликами метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">build</code><span class="Apple-converted-space">,
        щоб варіювати створювані об'єкти</span>. Білдер може заповнювати деякі
      поля автоматично перед створенням об'єкту, такі як серійні номери, що
      збільшуються кожного разу, коли створюється об'єкт.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Шаблон
      Builder також має і недоліки. Щоб створити об'єкт ви маєте зпочатку
      створити білдер. Хоча ціна створення цього білдера навряд чи буде помітною
      на практиці, це може бути проблемою в критичних ситуаціях. Також шаблон
      Builder більш галасливий, ніж шаблон телескопічного конструктора, так що
      він має використовуватись тільки якщо досить параметрів, щоб воно було
      того варте - скажімо, чотири або більше. Але майте на увазі, що ви можете
      побажати додати параметрів в майбутньому. Але якщо ви починаєте з
      конструкторів або статичних фабрик, та перемикаєтесь на білдер, тоді клас
      розвівається до точки, де число параметрів виходить з під контролю, та
      застарілі конструктори або статичні фабрики будуть стирчати, як великий
      палець. Таким чином, часто краще почати з білдера в першу чергу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Підсумовуючи,
      <strong>шаблон білдера є гарним вибором при розробці класів, чиї
        конструктори або статичні фабрики можуть мати велику кількість
        параметрів</strong>, особливо якщо багато параметрів є опціональними або
      ідентичного типу. Код клієнта з білдерами стає значно простішим для
      читання та написання, ніж з телескопічними конструкторами, та білдери
      значно простіші, ніж JavaBeans.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_17"></span><strong>Елемент 3: Вимушений
        синглтон через приватний конструктор або тип enum</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        class="Apple-converted-space"></span><em>Синглтон є простий клас</em>,
      що має рівно один примірник [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
      Синглтони типово представляють або об'єкт без стану, такий як функція (<a
        href="ch4.xhtml#lev24" style="text-decoration: none;">Елемент 24</a>),
      або системний компонент, що внутрішньо унікальний.<span class="Apple-converted-space">
      </span><strong>Перетворення класу на синглтон робить складним тестування
        тестування клієнтів</strong><span class="Apple-converted-space">,
        оскільки неможливо замінити мок-реалізацію для синглтона, тільки якщо
        він не реалізує інтерфейс, що служить як його тип</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      два загальні шляхи реалізувати синглтони. Обоє базуються на утримання
      конструктора приватним, та експортування публічного статичного члена для
      доступа до єдиного примірника. В одному підході член є фінальним полем:</p>
    <br>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
      public class Elvis {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public static final Elvis INSTANCE = new
        Elvis();</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Elvis() { ... }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void leaveTheBuilding() { ... }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Приватний
      конструктор викликається тільки один раз, щоб ініціалізувати публічне
      статичне поле <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Elvis.INSTANCE</code>.
      Нестача публічного або захищеного конструктора <em>гарантує </em>“моноелвістичний”
      всесвіт: буде існувати рівно один примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Elvis</code><span class="Apple-converted-space">
      </span>після ініціалізації класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Elvis</code><span class="Apple-converted-space">
      </span>— не більше, не менше. Немає нічого, як клієнт може змінити це, з
      маленькою зачипкою: привілійований клієнт може викликати приватний
      конструктор через рефлексію (<a href="ch9.xhtml#lev65" style="text-decoration: none;">Елемент
        65</a>) за допомогою метода <code style="font-family: 'Courier New', monospace;">AccessibleObject.setAccessible</code>.
      Якщо ви потребуєте захисту від цієї атаки, модифікуйте консруктор, щоб він
      викликав виключення, якщо його просят викнати інший примірник.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      другому підході для релізації синглтонів публічний член є статичним
      методом-фабрикою:</p>
    <strong></strong><br>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
      public class Elvis {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>private</strong><span class="Apple-converted-space">&nbsp;</span>static
      final Elvis INSTANCE = new Elvis();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Elvis() { ... }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public static Elvis getInstance()</strong><span
        class="Apple-converted-space">&nbsp;</span>{ return INSTANCE; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void leaveTheBuilding() { ... }<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Всі
      виклики до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Elvis.getInstance</code><span
        class="Apple-converted-space"> повертають те саме посилання на об'єкт,
        та ніколи не буде створене іншого примірника </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Elvis</code><span class="Apple-converted-space">
      </span>(з тим самим виключенням, наведеним вище).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Головна
      перевага підходу публічного поля в тому, що API робить зрозумілим, що клас
      є синглтоном: поле є статичне та фінальне, так що воно буде завжди містити
      те саме об'єктне посилання. Друга перевага в тому, що це простіше.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Одна
      перевага підходу статичної фабрики в тому, що це дає вам гнучкість змінити
      вашу думку щодо того, чи клас є синглтоном, без зміни його API.
      Метод-фабрика повертає єдиний примірник, але він може бути модифікований
      для повертання, скажімо, окремого примірника для кожного потоку, що
      викликає його. Друа перевага в тому, що ви можете написати <em>дженерік-фабрику
        синглтонів</em>, якщо ваше застосування потрубує цього (<a href="ch5.xhtml#lev30"
        style="text-decoration: none;">Елемент 30</a>). Остаточна перевага від
      використання статичної фабрики в тому, що <em>в якості поставника може
        виступати посилання на метод</em>, наприклад<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Elvis::instance</code><span
        class="Apple-converted-space"> є</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Supplier&lt;Elvis&gt;</code>.
      За винятком коли одна з ціх переваг має місце, підхід публічного поля має
      перевагу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      зробити клас синглона, що використовує кожний з ціх підходів <span class="Apple-converted-space"></span><em>серіалізуємим</em><span
        class="Apple-converted-space"> </span>(<a href="ch12.xhtml#ch12" style="text-decoration: none;">Глава
        12</a>), недостатньо просто додати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">implements Serializable</code><span
        class="Apple-converted-space"> до його декларації</span>. Щоб
      обслуговувати гарантованість синглтона, декларуйте всі поля примірника <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">transient</code><span
        class="Apple-converted-space">, та провадьте метод</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">readResolve</code><span
        class="Apple-converted-space"> </span>(<a href="ch12.xhtml#lev89" style="text-decoration: none;">Елемент
        89</a>). Інакше кожного разу, коли ви десеріалізуєте прмірник буде
      створюватись новий приірник, приводячи, в разі нашого випадку, до
      виникнення підробних <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Elvis</code>.
      Щоб запобігти цьому, додайте метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">readResolve</code><span class="Apple-converted-space">
        до класу</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Elvis</code>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
    </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
метод
        readResolve для збереження властивості синглтону</strong><br>
      private Object readResolve() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp; // Повернути одного справжнього Elvis, та
      дозволити збирачу сміття<br>
      &nbsp;&nbsp;&nbsp;&nbsp; // потурбуватись про копіювача Elvis.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return INSTANCE;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Третій
      шлях реалізувати синглтон є декларувати одно-елементний enum:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
    </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Enum синглтон - переважний підхід</strong><br>
      public enum Elvis {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;INSTANCE;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void leaveTheBuilding() { ... }<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      підхід подібний до підхід публічного поля, але він більш стислий,
      безкоштовно провадить механізм серіалізації, та провадить залізну гарантію
      проти множинних примірників, навіть під тиском вишуканих атак серіалізації
      або рефлексії. Цей підхід може виглядати дещо неприродним, але <span class="Apple-converted-space"></span><strong>одноелементний
        тип enum часто є кращим шляхом реалізувати синглтон</strong>. Зауважте,
      що ви не можете використовувати цей підхід, якщо ваш синглтом має
      розширяти суперклас, інший, ніж<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Enum</code><span class="Apple-converted-space">&nbsp;</span>(хоча
      ви <em>можете </em>декларувати enum для реалізації інтерфейсів).</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_19"></span><strong>Елемент 4: Заборона
        створення примірників за допомогою приватного конструктора<br>
      </strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Часом
      ви бажаєте написати клас, що є тільки угрупуванням статичних методів та
      статичних полів. Такі класи отримали погану репутацію, оскільки деякі люди
      шкодять їм уникнути мислення в термінах об'єктів, але вони мають валідні
      застосування. Вони можуть використовуватись для групування пов'язаних
      методів, в стилі <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.lang.Math</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">java.util.Arrays</code>.
      Вони також можуть бути використані для групування статичних методів,
      включаючи фабрики (<a href="ch2.xhtml#lev1" style="text-decoration: none;">Елемент
        1</a>), для об'єктів, що реалізують деякий інтерфейс, в манері <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">java.util.Collections</code>.
      З Java 8 ви також можете покласти такі методи <em>в </em>інтерфейс,
      вважаючи, що він ваш для роблення змін. Нарешті такі класи можуть
      використовуватись для групування методів на фінальному класі, оскільки ви
      не можете покласти їх в субклас.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Такі
      <em>допоміжні класи </em>не були розроблені для створення примірників:
      примірник не мав би сенсу. Однак за відсутності явних конструкторів,
      компілятор провадить власний, публічний <em>конструктор по замовчанню без
        параметрів</em>. Для користувача цей конструктор не відрізняється від
      кожного іншого. Не є рідкістю побачити ненавмисне відкриті через це класи
      в публічних API.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Спроба
        примусити до заборони створення примірників, через об'явлення класу
        абстрактним, не працює.</strong><span class="Apple-converted-space"> Цей
        клас може мати субкласи, та субкласи можуть мати примірники</span>.
      Більше того, це заплутує користувача, і він починає думати, що клас був
      створений для наслідування (<a href="ch4.xhtml#lev19" style="text-decoration: none;">Елемент
        19</a>). Існує, однак, проста ідіома, щоб гарантувати нестворення
      примірників.&nbsp; Конструктор по замовчанню генерується тільки якщо клас
      не має явних конструкторів, так що <span class="Apple-converted-space"></span><strong>клас
        можна зробити напридатним до створення примірників, якщо створити
        приватний конструктор</strong>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Клас,
        що не матиме екземплярів</strong><br>
      public class UtilityClass {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// Подавляємо констрктор по замовчанню</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;private UtilityClass() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      AssertionError();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок випущено<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскількі
      явний конструктор є приватним, він недоступний за межами класу. <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">AssertionError</code><span
        class="Apple-converted-space"> не є суто необхідним</span>, але це
      провадить гарантію в випадку, коли конструктор випадково викликається
      зсередини самого класу. Це гарантує, що клас не буде створювати примірники
      ні за яких умов. Ця ідіома дещо контр-інтуітивна, оскільки конструктор
      провадиться таким чином, що він не може бути викликаний. Так що буде
      розумним додати коментар, як показано раніше.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      побічний ефект, як ідіома також запобігає від створення субкласі цього
      класу. Всі конструктори мають викликати конструктор суперкласа, явно або
      неявно, але субклас не матиме доступного конструктора суперкласу, який
      можна визвати.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_20"></span><strong>Елемент 5: Схиляйтесь
        до ін'єкції замість жорсткого зв'язку ресурсів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      класів залежать від одного або більше підлеглих ресурсів. Наприклад,
      перевірка правопису залежить від словника. Не є загальним бачити такі
      класи реалізованими як статичні класи-утіліти (<a href="ch2.xhtml#lev4" style="text-decoration: none;">Елемент
        4</a>):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Невідповідне
        використання статичних утіліт - негнучко &amp; нетестовно!</strong><br>
      public class SpellChecker {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final Lexicon dictionary = ...;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private SpellChecker() {} // Noninstantiable<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static boolean isValid(String word) { ... }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static List&lt;String&gt;
      suggestions(String typo) { ... }<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Подібним
      чином, не рідкість побачити їх реалізованими як синглтони (<a href="ch2.xhtml#lev3"
        style="text-decoration: none;">Елемент 3</a>):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Невідповідне застосування синглтона - негнучко &amp; нетестовно!</strong><br>
      public class SpellChecker {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Lexicon dictionary = ...;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private SpellChecker(...) {}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static INSTANCE = new SpellChecker(...);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean isValid(String word) { ... }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public List&lt;String&gt; suggestions(String typo)
      { ... }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Жодний
      з ціх підходів не є задовільним, оскільки вони передбачають, що існує
      тільки один словник, гідний використання. На практиці кожна мова має свій
      власний словник, та для спеціальних вокабулярів використовуються різні
      словники. Також може бути бажаним використовувати спеціальний словник для
      тестування. Це дуже сміливе припущення, що одного словника буде достатньо
      на всі часи.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете спробувати змусити<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">SpellChecker</code><span
        class="Apple-converted-space"> підтримувати декілька словників, що
        робить поле </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">dictionary</code><span
        class="Apple-converted-space"> не-фінальним, та потребує додавання
        метода для зміни словника в існуючій перевірці, але це може бути
        резграбним, схильним до помилок, </span>та нездатне робити в
      конкурентному середовищі.<span class="Apple-converted-space"> </span><strong>Статичні
        класи-утіліти та синглтони невідоповідні для класів, чия поведінка
        параметризована підлеглим ресурсом.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Що
      потрібне - це можливість підтримувати декілька примірників класу (в нашому
      прикладі <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">SpellChecker</code>),
кожний
      з яких використовує використовує ресурс, який обирає клієнт (в нашому
      випадку - словник). Простий шаблон, що задовільняє цій вимозі, є <span class="Apple-converted-space"></span><strong>передання
        ресурсів в конструктор при ствренні нового примірника</strong>. Це одна
      з форм <em>ін'єкції залежностей</em>: словник є <em>залежністю </em>для
      перевірки правопису, та <em>ін'єктується (вставляється) </em>в правопис,
      коли той створюється.</p>
    <span epub:type="pagebreak" id="page_21" style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"></span><span
      style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Ін'єкція залежностей провадить гнучкість та тестованість</strong><br>
      public class SpellChecker {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Lexicon dictionary;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public SpellChecker(Lexicon dictionary)</strong><span
        class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.dictionary =
      Objects.requireNonNull(dictionary);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean isValid(String word) { ... }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public List&lt;String&gt; suggestions(String typo)
      { ... }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
    </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Шаблон
      ін'єкції залежностей такий простий, що багато програмістів використовує
      його протягом років, не знаючи, що він має ім'я. Доки наша перевірка
      правопису має тільки одни русурс (словник), ін'єкція залежностей робить з
      довільним числом ресурсів, та довільними графами залежностей. Він зберігає
      незмінність (<a href="ch4.xhtml#lev17" style="text-decoration: none;">Елемент
        17</a>), так що декілька клієнтів можуть поділяти залежні&nbsp; об'єкти
      (вважаючи, що клієнти запрошують ті самі ресурси). Ін'єкція залежнсотей
      рівно застосовується для конструкторів, статичних фабрик (<a href="ch2.xhtml#lev1"
        style="text-decoration: none;">Елемент 1</a>), та білдерів (<a href="ch2.xhtml#lev2"
        style="text-decoration: none;">Елемент 2</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Корисний
      варіант шаблону є передати конструктору <em>фабрику </em>ресурсів.
      Фабрика є об'єкт, що може використовуватись неодноразово для створення
      примірників певного типу. Такі фабрики втілюють шаблон <em>Метода фабрики
      </em>[<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].
Інтерфейс
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Supplier&lt;T&gt;</code><span
        class="Apple-converted-space">, введений в </span>Java 8, є ідеальним
      для створення фабрик. Методи, що приймають<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Supplier&lt;T&gt;</code><span
        class="Apple-converted-space"> на вході повинен типово обмежити параметр
        типу фабрики, використовуючи <em>обмежений тип з зірочкою</em></span><span
        class="Apple-converted-space"> </span>(<a href="ch5.xhtml#lev31" style="text-decoration: none;">Елемент
        31</a>), щоб озволити клієнту передати в фабрику, що створює любий
      субтип певного типу. Наприклад, ось метод, що створює мозайку,
      використовуючи проваджену клієнтом фабрику для створення кожної плитки:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Mosaic
      create(Supplier&lt;? extends Tile&gt; tileFactory) { ... }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      ін'єкція залежностей гарно покращує гнучкість та тестованість, буде
      ускладнювати великі проекти, що типово містять тисячі залежностей. Цей
      безлад можна усунути, використовуючи <em>фреймворк ін'єкуції залежностей</em>,
      такого, як Dagger [<a href="ref.xhtml#rDagger" style="text-decoration: none;">Dagger</a>],
      Guice [<a href="ref.xhtml#rGuice" style="text-decoration: none;">Guice</a>],
      або Spring [<a href="ref.xhtml#rSpring" style="text-decoration: none;">Spring</a>].
      Використання ціх фреймворків за межами розгляду цієї книги, але зауважте,
      що API, розроблені для ручної ін'єкції тривіально адаптовані для
      використання в ціх фреймворках.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, не використовуйте синглтон або статичний клас-утиліту для
      реалізації класу, що залежить від одного або більше ресурсів, чия
      поведінка впливає на клас, та не змушувати клас створювати ці ресурси
      самотуж. Замість цього передайте ресурси, або фабрики для їх створення, в
      конструктор (або статичну фабрику, або білдер). Ця практика, відома як
      ін'єкція залежностей, буде гарно розширювати гнучкість, повторне
      використання та тестованість класу.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_22"></span><strong>Елемент 6: Уникайте
        створення непотрібних об'єктів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Часто
      краще повторно використати єдиний об'єкт, замість створення нового,
      фукнціонально еквіалентного об'єкта, кожного разу, коли це треба. Повторне
      викоирстання може бути обоє, більш швидке та додавати стилю. Об'єкт завжди
      може бути повторно використаний, якщо він незмінний (<a href="ch4.xhtml#lev17"
        style="text-decoration: none;">Елемент 17</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      якості екстремального приклада того, що не треба робити, розглянемо таке
      твердження:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">String
      s = new String("bikini");&nbsp;&nbsp;<strong>// НЕ РОБІТЬ ЦЬОГО!</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      твердження створює новий примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
      </span>кожного разу, коли виконується, та жодне з ціх створень не є
      необхідним. Аргумент конструктора <code style="font-family: 'Courier New', monospace;">String</code><span
        class="Apple-converted-space"> </span>(<code style="font-family: 'Courier New', monospace;">"bikini"</code>)
      є сам по собі примірником <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code>,
      функціонально ідентичним до всіх об'єктів, створених конструктором. Якщо
      це використання трапляється в циклі, або в часто використованому методі,
      мільйони примірників <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">String</code><span
        class="Apple-converted-space"> можуть бути створені без жодних потреб</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Покращена
      версія виглядає просто:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">String
      s = "bikini";</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      версія використовує один примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code>, ніж
      створювати новий примірник кожного разу при виконанні. Більше того, це
      гарантує, що об'єт буде використовуватись повторно, коли будь-який код
      буде виконуватись на тій самій віртуальній машині, що буде задіяти той
      самий літерал рядка [JLS, 3.10.5].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Часто
      ви можете уникнути створення небажених об'єктів, через використання <span
        class="Apple-converted-space"></span><em>статичних методів-фабрик</em><span
        class="Apple-converted-space"> </span>(<a href="ch2.xhtml#lev1" style="text-decoration: none;">Елемент
        1</a>) замість конструкторів або незмінних класів, що провадять обоє.
      Наприклад, метод-фабрика <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Boolean.valueOf(String)</code><span
        class="Apple-converted-space"> більш бажаний, ніж конструктор </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Boolean(String)</code>,
      що був відмінений в Java 9. Констуктор <em>має </em>створювати новий
      об'єкт кожного разу, коли він викликається, тоді як метод-фабрика ніколи
      не змушений робити це, і не робить це на практиці. На додаток до повторно
      використання назмінних об'єктів, ви також можете повторно використовувати
      змінні об'єкти, якщо ви знаєте, що вони не були модифіковані.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Деякі
      створення об'єктів значно більш коштовні, ніж інші. Якщо ви маєте намір
      постійно створювати такі “коштовні об'єкти”, можна порадити кешувти їх для
      подальшого використання. Нажаль, не завжди очевидно, коли ви створюєте
      такий об'єкт. Уявімо, ви бажаєте написати метод для визначення, чи є рядок
      валідним числом в римській нотацїі. Найпростіше зробити це за допомогою
      регулярного виразу:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Продуктивність
        можна гарно покращити!</strong><br>
      static boolean isRomanNumeral(String s) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+
      "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_23"></span>Проблема з цією реалізацією в
      тому, що вона покладається на метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">String.matches</code>.<span
        class="Apple-converted-space"> </span><strong>Хоча</strong><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>String.matches</strong></code><span
        class="Apple-converted-space"> </span><strong>є найпростішим шляхом
        перевірити, чи рядок співпадає з регулярним виразом, це не підходить до
        частого використання в критичних по швидкості ситуаціях.</strong><span class="Apple-converted-space">
        Проблема в тому, що це зпочатку створює примірник </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Pattern</code><span class="Apple-converted-space">
        для регулярного виразу, та використовує його тільки один раз, після чого
        він стає матеріалом для збірника сміття. Створення примірника </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Pattern</code><span
        class="Apple-converted-space"> коштовне, бо воно потребує компіляції
        регулярного виразу в машину кінечних станів</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      покращити продуктивність явно компілюйте регулярний вираз в
      примірник&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Pattern</code>
      (що буде незмінним) як частина ініціалізації класу, кешуйте його, та
      повторно використовуйте той самий примірник для кожного виклику методу<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">isRomanNumeral</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Повторне використання коштовного об'єкту для покращення ефективності</strong><br>
      public class RomanNumerals {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final Pattern ROMAN =
      Pattern.compile(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"^(?=.)M*(C[MD]|D?C{0,3})"<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+
      "(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;static boolean isRomanNumeral(String s) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      ROMAN.matcher(s).matches();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Покращена
      версія <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">isRomanNumeral</code><span
        class="Apple-converted-space"> провадить значний додаток ефективності,
        якщо викликаєтсья часто</span>. На моїй машині оригінальна версія триває
      1.1 µs на 8-симольному рядку, тоді як покращена версія триває 0.17 µs, що
      в 6.5 разів швидше. Це впливає не тільки на швидкість, але також і на
      ясність. Роблячи статичне фінальне поле для інакше невидимого&nbsp;
      примірника <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Pattern</code><span
        class="Apple-converted-space"> </span>дозволяє нам надать йому ім'я, що
      більш зрозуміло, ніж самий регулярний вираз.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      клас, що містить покращену версію методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">isRomanNumeral</code><span
        class="Apple-converted-space"> ініціалізований, але метод ніколи не
        викликається, поле </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ROMAN</code><span class="Apple-converted-space">
        буде ініціалізоване без потреби</span>. Можливо уникнути ініціалізації
      через <em>ліниву ініціалізацію </em>поля (<a href="ch11.xhtml#lev83" style="text-decoration: none;">Елемент
        83</a>), коли <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">isRomanNumeral</code>m
      викликається перший раз, але це <em>не </em>рекомендовано. Як це часто
      буває з лінивою ініціалізацією, це може ускладнити ініціалізацію з
      невимирним покращенням продуктивності (<a href="ch9.xhtml#lev67" style="text-decoration: none;">Елемент
        67</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      об'єкт незмінний, є очевидним, що його можна безпечно використовувати
      повторно, але є ситуації, коли не все таке очевидно, та навіть
      контр-інтуітивно. Розглянемо випадок <em>адаптерів</em><span class="Apple-converted-space">
      </span>[<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>]<em>,</em><span
        class="Apple-converted-space"> також відомі як </span><span class="Apple-converted-space"></span><em>перегляди
        (вью)</em>. Адаптер є об'єктом, що делегує підлеглий об'єкт підтримки,
      провадячи альтернативний інтерфейс. Оскільки адаптер не має стану за
      межами свого зворотнього об'єкту, немає потреби створювати більше ніж один
      примірник даного адаптера до даного об'єкта.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_24"></span>Наприклад, метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">keySet</code><span class="Apple-converted-space">
        інтерфейсу</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map</code><span
        class="Apple-converted-space"> повертає перегляд </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code><span class="Apple-converted-space">
        об'єкту</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map</code>,
      що складається з усіх ключів мапи. Мислячі наївно, може здатись, що кожний
      виклик до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">keySet</code><span
        class="Apple-converted-space"> має створювати новий примірник </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set</code>,
      але кожний виклик до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">keySet</code><span
        class="Apple-converted-space"> на певному об'єкті </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map</code><span class="Apple-converted-space">
        може повертати той самий примірник </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code>. Хоча
      отриманий примірник <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set</code><span
        class="Apple-converted-space"> типово є змінним</span>, всі повернуті
      об'єкти функціонально ідентичні: коли один з повернутих об'єктів
      змінюється, те саме відбувається з іншими, бо всі вони базуються на тому
      самому примірнику <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Map</code>.
      Доки це досить безболічне створювати декілька примірників об'єкта <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">keySet</code>, це не є
      нобхідним, та не надає переваг.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інший
      шлях створити непотрібрі об'єкти є <em>автобоксинг</em>, що дозволяє
      програмісту міксувати примітивні типи, атоматично боксуючи та розбоксуючи
      по мірі необхідності.<span class="Apple-converted-space"> </span><strong>Автобоксування
        розмиває, але не зтирає різницю між примітивними та боксованими
        примітвними типами. </strong>Існує тонке симантичне розбіжжя, та
      не-таке-незначне розбіжжя в продуктивності (<a href="ch9.xhtml#lev61" style="text-decoration: none;">Елемент
        61</a>). Розглянемо наступний метод, що обчислює суму всіх позитивних
      значень <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code>.
      Щоб зробити це, програма має використовувати арифметику <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">long</code><span class="Apple-converted-space"></span>,
      оскільки <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space"> </span>не достатньо великий, щоб
      підсумувати всі додатні значення <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">int</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Приховано повільно! Чи ви помітили створення об'єктів?</strong><br>
      private static long sum() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Long sum = 0L;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (long i = 0; i &lt;= Integer.MAX_VALUE; i++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum += i;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;return sum;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      програма дає вірний результат, але він <em>значно </em>повільніший, ніж
      повинен бути, через помилку в один символ. Змінна <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">sum</code><span class="Apple-converted-space">
      </span>декларована як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Long</code><span
        class="Apple-converted-space"> замість</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">long</code>,
      що означає, що програма спожиє до 2<sup>31</sup><span class="Apple-converted-space">
        непотрібних примірників</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Long</code> (рівно один
      раз, коли <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">long
        i</code><span class="Apple-converted-space"> додається до </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Long
        sum</code>). Зміна декларації <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">sum</code><span class="Apple-converted-space">
        з</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Long</code><span
        class="Apple-converted-space"> на</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">long</code><span
        class="Apple-converted-space"> зменшує час виконання з</span> 6.3 секунд
      до 0.59 секунд на моїй машині. Урок ясний:<span class="Apple-converted-space">
      </span><strong>схиляйтесь до примітивів замість боксованих примітивів, та
        начувайтесь щодо ненамисного аутобоксигу.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      не має бути невірно розтлумачене, що створення об'єктів коштовне, та його
      треба уникати. Навпаки, створення та повернення малих об'єктів, чиї
      конструктори роблять небагато зайвої роботи, є дешевим, особливо на
      сучасних реалізаціях JVM. Створення додаткових об'єктів поширює ясність,
      спрощення або потужність програми, і загалом є гарною річчю.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Навпаки,
      уникнення стовення об'єктів та підтримка власного <em>пулу об'єктів </em>є
      поганою ідеєю, за виключенням випадку, коли об'єкти в пулі є виключно
      важковаговими. Класичний приклад об'єкту, що <em>не задовільняє вимогам </em>пулу
      об'єктів,&nbsp; є з'єднання з базою даних. Вартість встановлення з'єднання
      досить висока, що робить нагальним сенс повторного використання таких
      об'єктів. Однак, кажучи взагалі, підтримка власного пулу об'єктів
      захаращує ваш код, збільшує використання пам'яті, та впливає на
      продуктивність. Сучасні реалізації JVM мають вкрай оптимізований збирач
      сміття, що легко перевершить такі пули для легковажних об'єктів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Контраргумент
      цього є <span class="Apple-converted-space"></span><a href="ch8.xhtml#lev50"
        style="text-decoration: none;">Елемент 50</a><span class="Apple-converted-space">
        щодо</span><span class="Apple-converted-space"> </span><em>захисного
        копіювання</em>. Цей елемент каже “Не створюйте новий елемент, коли вам
      слідує повторно використати існуючий”, тоді як<span class="Apple-converted-space">
      </span><a href="ch8.xhtml#lev50" style="text-decoration: none;">Елемент 50</a><span
        class="Apple-converted-space"> каже</span>, “Не використовуйте існуючий
      об'єкт, коли вам треба створити новий”. Зауважте, що коштовність
      використання об'єкта при використанні захисного копіювання значно більша,
      ніж вартість непотрібного створення дублікуючого об'єкта. Невміле
      створення захисних копій в разі потреби може призвести до невичерпних
      багів та дірок безпеки, коли створення об'єктів без потреби лише впливає
      на стиль та продуктивність.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_26"></span><strong>Елемент 7: Уникайте
        застарілих посиланть на об'єкти</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви перемикнулись з мови з ручним керуванням пам'яттю, як C або C++, на
      мову зі збором сміття, як Java, ваша робота як програміста стала значно
      простішою через факт, що ваші об'єкти автоматично видаляються, коли ви
      покінчили робити з ними. Це виглядає як магія, коли ви вперше маєте цей
      досвід. Це може просто призвести до думки, що вам не треба думати про
      керування пам'яттю, але це не зовсім так.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Розглянемо
      наступну просту реалізацію стека:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Чи ви помітили витік пам'яті?</strong><br>
      public class Stack {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Object[] elements;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int size = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int DEFAULT_INITIAL_CAPACITY
      = 16;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Stack() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements = new
      Object[DEFAULT_INITIAL_CAPACITY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void push(Object e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacity();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size++] = e;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Object pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new EmptyStackException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;/**<br>
      &nbsp;&nbsp;&nbsp;&nbsp; * Впевняємось в місці щонайменш до одного
      елементу<br>
      &nbsp;&nbsp;&nbsp;&nbsp; * Подвоюємо розмір масиву в разі необхіднсоті.<br>
      &nbsp;&nbsp;&nbsp;&nbsp; */<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private void ensureCapacity() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elements.length ==
      size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements
      = Arrays.copyOf(elements, 2 * size + 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Немає
      нічого очевидно помилкового в цій програмі (але дивіться<span class="Apple-converted-space">
      </span><a href="ch5.xhtml#lev29" style="text-decoration: none;">Елемент 29</a><span
        class="Apple-converted-space"> </span>для узагальненої версії). Ви
      можете всебічно протестувати її, та вона пройде всі тести під переможними
      кольорами, але проблема причаїлась всередині. Просто кажучи, програма має
      витік пам'яті, що може тихо проявити себе через знижену продуктивність,
      через підвищення активності збирача сміття, або через надлишкове
      використання пам'яті. В екстремальних випадках, такі витоки пам'яті можуть
      викликати підкачку сторінок з диску, та навіть збій програми з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">OutOfMemoryError</code>,
      але такі відмови вкрай рідкі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      де тут витік пам'яті? Якщо стек зростає, та потіс зменшуєтсья, об'єкти, що
      були виштовнені зі стеку не будуть зібрані колектором, навіть якщо
      програма, що використовує стек, не матиме більше посилань на них. Це тому,
      що стек утримує <em>застарілі посиланя </em>на ці об'єкти. Застарілі
      посилання це просто такі посилання, що більше ніколи не будуть
      розіменовані. В цьому випадку, всі посилання за межами "активного
      фрагменту" масива елементів є втраченими. Активна частина складається з
      елементів, чий індекс менший за розмір<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">size</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Витоки
      пам'яті в мовах зі збіркою сміття (більш точно відомі як <span class="Apple-converted-space"></span><em>ненавмисне
        збереження об'єктів</em>) дуже підступні. Якщо посилання на об'єкт
      випадково зберігається, не тільки цей об'єкт виключається зі збору сміття,
      але також і всі об'єкти, що посилаються на цей об'єкт, і так далі. Навіть
      якщо ненавмисне зберігаються тільки декілька посилань, багато, багато
      об'єктів можуть виключитись з процесу збору сміття, з потенційним великим
      впливом на продуктивність.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Полагодження
      цього різновиду пробелм просте: зануляйте посилання, коли вони вже не
      використовуються. В випадку нашого класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code>, посилання
      на елемент стає непотрібнм як тільки цей об'єкт видаляється зі стеку.
      Скорегована версія метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">pop</code><span class="Apple-converted-space">
        виглядає таким чином</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      Object pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      EmptyStackException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Object result = elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>elements[size] = null; // Видаляємо
        застарілі посилання</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Додаткова
      вигода від занулювання посилань в тому, що якщо вони помилково будуть
      використані, програма терміново завершиться з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">NullPointerException</code>,
      замість того, щоб тихо робити погані речі. Завжди краще визначати помилки
      програми так швидко, як це можливо.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      програмісти перший раз обпіклися на цій проблемі, вони почали старанно
      компенсувати недоліки, зануляючи кожне об'єктне посилання, як тільки
      програма переставала використовувати його. Це ані потрібно, ані бажано; це
      захаращує програму без потреби.<span class="Apple-converted-space"> </span><strong>Занулення
        об'єктних посилань має бути виключенням, скоріше, ніж нормою.</strong><span
        class="Apple-converted-space"> </span>Кращий шлях уникнути зайвих
      посилань, це дозволити змінній, що містить посилання, вийти з області
      огляду. Це відбувається природно, якщо ви визначаєте кожну змінну в самому
      обмеженому колі (<a href="ch9.xhtml#lev57" style="text-decoration: none;">Елемент
        57</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_28"></span>Так коли ви маєте зануляти
      посилання? Який аспект класу<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">
      </span>дає підозру щодо витоку пам'яті? Просто кажучі, він <span class="Apple-converted-space"></span><em>керує
        своєю власною памят'ю</em>. <em>Пул сховища </em>складається з
      елементів масиву <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">elements</code><span
        class="Apple-converted-space"> </span>(клітини об'єктних посилань, не
      самі об'єкти). Елементи в активній частині масиву (як визначено вище) <span
        class="Apple-converted-space"></span><em>розміщені</em>, та інші в
      залишку масива <em>вільні</em>. Збирач сміття не може знати цього; для
      збирача сміття всі об'єктні посилання в масиві<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">elements</code><span
        class="Apple-converted-space"> однаково гарні</span>. Тільки програміст
      знає, що нактивна частина масиву не має значення. Програміст ефективно
      комунікує цей факт збирачу сміття, обнуляючи елементи масиву, як тільки
      вони стають частиною неактивної частини.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Кажучи
      загалом, <span class="Apple-converted-space"></span><strong>коли клас
        керує своєю власною пам'ятю, програміст має начуватись щодо витоку
        пам'яті</strong>. Коли елемент вивільнюється, об'єктні посилання, що
      зберігається в елементі, повинні бути занульовані.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Інше
        загальне джерело витоків пам'яті є кеші.</strong><span class="Apple-converted-space">
        Коли ви покладаєте об'єктне посилання в кеш, легко забути що воно там,
        та залишити його в кеші довше, ніж воно залишатиметься релевантним.
        Існує декілька рішень цієї проблеми. Якщо ви досить щасливі реалізувати
        кеш, для якого входження релевантні рівно стільки, доки існують
        посилання на ключ за межами кешу, представляйте кеш як </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">WeakHashMap</code>;
      входження будуть видалені після того, як вони вийдуть з ужитку.
      Пам'ятайте, що <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">WeakHashMap</code><span
        class="Apple-converted-space"> корисний тільки якщо бажаний час життя
        елементів кешу визначається зовнішніми посиланями на ключ, не на
        значення</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Більш
      загально, корисний час життя входження кешу менш гарно визначений, коли
      входження стають менш значущими з часом. За таких умов кеш повинен часом
      очищуватись від входжень, що вийшли з ужитку. Це можна зробити в фоновому
      потоці&nbsp; (можливо в<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">ScheduledThreadPoolExecutor</code>),
      або як побічний ефект додавання нових елементів в кеш. Клас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">LinkedHashMap</code><span
        class="Apple-converted-space"> спрощує останній підхід за допомогою
        методу </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">removeEldestEntry</code>.
      Для більш складних кешів вам може знадобитись використовувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">java.lang.ref</code><span
        class="Apple-converted-space"> напряму</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Третє
        загальне джерело витоків пам'яті є слухачі та інші зворотні виклики.</strong><span
        class="Apple-converted-space"> Якщо ви реалізуєте </span>API, де
      клієнти реєструють зворотні вклики, але не відреєстроюють їх в явній
      формі, вони будуть накопичуватись, якщо ви не приймете певних дій. Один
      шлях переконатись, що зворотні виклики збираються в смітник, є зберігання
      тільки <em>слабких посилань </em>на них, наприклад, зберігати їх як
      ключі в <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">WeakHashMap</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскільки
      витоки пам'яті не заявляють про себе як очевидні збої, вони можуть
      залишатись присутніми в системі на протязі років. Вони типово знаходяться
      тільки як результат прискіпливої інспекції коду, або за допомогою
      інструменту налаштування, відомому як <em>профайлер кіпи. </em>Таким
      чином дуже бажано навчатись протистояти проблемам, як ці, перед тим, як
      вони з'являться, та запобігати їх траплянню.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Елемент
        8: Уникайте фіналайзерів та очищувачів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong><span
          style="color: #0000ee;"></span>Фіналайзери непередбачувані, часто
        небезпечні, та загалом непотрібні.</strong><span class="Apple-converted-space">
      </span>Їх використання може спричинити помилкову поведінку, погану
      продуктивність та проблеми портабельності. Фіналайзери мають декілька
      валідних використань, які ми покажемо пізніше, але як правило ви повинні
      уникати їх. В Java 9 фіналайзери були відкинуті, але вони все ще
      використовуються в Java бібліотеках. На заміну фіналайзерів в Java 9
      з'явились <em>очищувачі</em>.<span class="Apple-converted-space"> </span><strong>Очищувачі
        менш небезпечні, ніж фіналайзери, але все ще непередбачувані, повільні,
        та загалом непотрібні.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Програмісти
      C++ попереджаються, що про фіналайзери або очищувачі не слід думати, як
      про Java аналог деструкторів C++. В C++ деструктори є звичайним шляхом
      повернути ресурси, асоційовані&nbsp; з об'єктом, необхідне доповнення до
      конструкторів. В Java збирач сміття повертає місце, асоційоване з
      об'єктом, коли він стає недосяжним, не потребуючи додаткових зусиль з боку
      програміста. Деструктори C++ також використовуються для повернення інших
      ресурсів, крім пам'яті. В Java для ціх цілей використовуються блоки<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">try</code>-with-resources
      або<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">try</code>-<code
        style="font-family: 'Courier New', monospace;">finally</code> (<a href="ch2.xhtml#lev9"
        style="text-decoration: none;">Елемент 9</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Одна
      з вад фіналайзерів та очищувачів полягає в тому, що немає гарантії, що
      вони будуть виконані в передбачуваній перспективі [JLS, 12.6]. Може пройти
      довільнй час між моментом, коли об'єкт стає недосяжним, та часом, коли
      буде виконано фіналайзер або очищувач. Це означає, що вам <span class="Apple-converted-space"></span><strong>ніколи
        не слід робити нічого час-критичного в фіналайзері та очищувачах.</strong><span
        class="Apple-converted-space"> Наприклад, це смертельна помилка -
        розраховувати </span>на фіналайзер або очищувач для закриття файлів,
      оскільки дескриптори відкритих файлів є обмеженим ресурсом. Якщо багато
      файлів залишити відкритими, як результат системної затримки виконання
      фіналайзерів та очищувачів, програма може схибити, оскільки вона не зможе
      відкривати нові файли.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Передбачуваність,
      з якою виконуються фіналайзери та очищувачі, в основному є функцією
      алгоритму збирача сміття, що варіює в широких межах між реалізаціями.
      Поведінка програми, що залежить від передбачуваності фіналайзера або
      очищувача, також може варіюватись. Цілком можливо, що така програма буде
      робити чудово на JVM, на якій ви тестували, та потім жалюгідно схибити на
      тій, яку вподобав ваш найбільш важливий клієнт.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Затримка
      фіналізації не є тільки теоретичною проблемою. Провадження фіналайзера для
      класа може довільно затримати прибирання ресурсів. Колега налаштовував
      довготривале GUI застосування, що містично гинуло з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">OutOfMemoryError</code>.
      Аналіз виявив, що під час краху застосування мало тисячі графічних
      об'єктів в черзі фіналізації, що просто чекали фіналізації та прибирання.
      Нажаль, потік фіналізатора робив з низьким преоритетом, порівняно з іншим
      потоком застосування, так що об'єкти не були фіналізованими зі швидкістю,
      з якою вони надходили до фіналізації. Специфікація мови не дає гарантій
      щодо того, який потік буде виконувати фіналізацію, так що немає
      портабельного шляху запобігти цьому різновиду проблем, крім того, щоб
      взагалі утриматись від використання фіналізаторів. Очищувачі трохи кращі,
      ніж фіналізатори, в тому сенсі, оскільки автори класу мають контроль над
      власними потоками очищувачів, але очищувачі все ще роблять в фоні, під
      керівництвом збирача сміття, так що не може бути гарантії щодо
      передбачуваної очистки.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      тільки специфікація не дає гарантій, що фіналізатори та очистка буде
      виконуватись передбачувано; вона не провадить гарантії, що вони взагалі
      будуть виконуватись. Повністю можливо, навіть вірогідно, що програма
      завершиться без їх виконання для деякого об'єкта, що більше недоступний.
      Як слідоцтво, ви ніколи <span class="Apple-converted-space"></span><strong>не
        повинні залежати від фіналізатора або очистки, щоб оновити збережений
        стан.</strong><span class="Apple-converted-space"> Наприклад,
        покладатись на фіналайзер або очищувач для вивільнення постійного
        блокування на розділеному ресурсі, такому, як база даних, є гарним
        способом поставити всю вашу розподілену систему на мертвий прикол</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      спокушайтесь методвами <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">System.gc</code><span
        class="Apple-converted-space"> </span>та<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">System.runFinalization</code>.
      Вони можуть збільшити шанси фіналізаторів або очищувачів бути виконаними,
      але вони не гарантують цього. Два метода колись обіцяли дати цю гарантію:<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">System.runFinalizersOnExit</code><span
        class="Apple-converted-space">, </span>та його злий близнюк, <code style="font-family: 'Courier New', monospace;">Runtime.runFinalizersOnExit</code>.
      Ці методи фатально недосконалі, та були ігноровані протягом десятиріч [<a
        href="ref.xhtml#rThreadStop" style="text-decoration: none;">ThreadStop</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
      &nbsp; Інша проблема з фіналізаторами в тому, що неперехоплене виключення
      під час фіналізації ігнорується, та фіналізація цього об'єкта припиняється
      [JLS, 12.6]. Неперехоплені виключення можуть залишити інші об'єкти в
      пошкодженому стані. Якщо інший потік намагається використати такий
      пошкоджений об'єкт, результатом буде довільна невизначена поведінка.
      Звичайно неперехоплене виключення буде припиняти потік, та друкувати трасу
      стеку, але тільки не в фіналізаторі — навіть не буде надруковане
      попередження. Очищувачі не мають цієї проблеми, оскільки бібліотека,
      використовуючи очищувач, має контроль над його потоком.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Існує
        <em>суттєве </em>пенальті продуктивності для використання фіналайзерів
        та очищувачів</strong><strong>.</strong><span class="Apple-converted-space">
        На моїй машині час створення простого </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">AutoCloseable</code>object,
та
      його закриття з використанням <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-with-resources,
      та час, коли збирач сміття прибере ресурси, складає близько 12 ns.
      Використання замість цього фіналайзера збільшує час до 550 ns. Іншими
      словами, це близько&nbsp; 50 разів повільніше, коли ви створюєте та
      руйнуєте об'єкти за допомогою фіналайзерів. В основі це відбувається через
      те, що фіналайзери заважають ефективному збиранню сміття. Очищувачі можна
      порівняти в швидкості з фіналайзерами, якщо ви використовуєте їх для
      очищення всіх примірників класу (близько 500 ns на примірник на моїй
      машині), але очищувачі значно швидші, якщо ви використовуєте тільки як
      страховку, як показано нижче. За таких умов створення, очищення та
      руйнування о'бєкту займає близько 66 ns на моїй машині, що означає, що ви
      платите п'ятикратну ціну (не п'ядесят) за страховку, <em>якщо ви не
        користуєтесь єю</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Фіналайзери
        мають серйозну проблему безпеки: вони відчиняють ваш клас для <em>фіналайзрної
          атаки</em></strong><strong>.</strong><span class="Apple-converted-space">
      </span>Ідея фіналайзерної атаки проста: якщо викликати виключення в
      конструкторі або його серіалізованих евівалентах — методах <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">readObject</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">readResolve</code>
      (<a href="ch12.xhtml#ch12" style="text-decoration: none;">Глава 12</a>) —
      фіналайзер зловмисного субкласу меже отримати керування на частково
      сконструйованому об'єкті, що мав би “загинути на корню”. Цей фіналайзер
      може записати посилання на об'єкт в статичному полі, заважаючи його
      прибиранню збирачем сміття. Коли спотворений об'єкт вже записаний, стає
      простою річчю виклик довільних методів на цьому об'єкті, що не було б
      дозволеним за звичайних умов. <span class="Apple-converted-space"></span><strong>Виклик
        виключення в конструкторі мав бути достатнім для того, щоб запобігти
        створенню об'єкта як такого; в присутності фіналайзера це вже не так.</strong><span
        class="Apple-converted-space"> Такі атаки можуть мати важкі наслідки</span>.
      Фінальні класи мають імунітет до фіналайзерних атак, оскільки ніхто не
      може написати зловмисний субклас фінального класу.<span class="Apple-converted-space">
      </span><strong>Щоб захистити нефінальні класи від фіналайзерних атак,
        напишіть фінальний метод </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>finalize</strong></code><span
        class="Apple-converted-space">, </span><strong>що нічого не робить.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      що робити замість написання фіналайзерів та очищувачів для класа, чиї
      об'єкти інкапсулюють ресурси, що потребують завершення, такі, як файли або
      потоки? Просто<span class="Apple-converted-space"> </span><strong>зробіть,
        щоб ваш клас реалізував</strong><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;"><strong>AutoCloseable</strong></code><strong>,</strong><span
        class="Apple-converted-space"> </span>та вимагати від клієнтів
      викликати метод&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">close</code><span
        class="Apple-converted-space"> на кожному примірнику, коли він більше не
        потрібен</span>, типово використовуючи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-with-resources,
      щоб впевнитись в завершенні, навіть перед лицем виключення (<a href="ch2.xhtml#lev9"
        style="text-decoration: none;">Елемент 9</a>). Одна деталь, яку варто
      згадати, це те, що примірник має відстежувати, чи не був він часом
      зачинений: метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">close</code><span
        class="Apple-converted-space"> </span>має записувати в поле, що цей
      об'єкт більше невалідний, та інші методи мають перевіряти це поле, та
      підіймати <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">IllegalStateException</code><span
        class="Apple-converted-space">, якщо вони викликаються після того, як
        об'єкт був зачинений</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Та
      що, яи є щось, для чого фіналайзери та очищувачі гарні? Можливо, вони
      мають два легітимних використання. Одне - діяти як старховка в випадку,
      коли власник ресурсів зневажає викликати метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">close</code>.
      Хоча немає гарантії, що очищувач або фіналайзер будуть виконуватись
      негайно (або взагалі будуть), краще звільнити ресурси пізніше, ніж ніколи,
      якщо клієнт не зробить це сам. Якщо ви вирішите написати такий
      страховочний фіналайзер, думайте довго і наполегливо, чи цей захист вартий
      ціни. Деякі класи бібліотеки Java, як<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">FileInputStream</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">FileOutputStream</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">ThreadPoolExecutor</code>,
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">java.sql.Connection</code>,
      мають фіналайзери, що служать такою страховкою.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Друге
      лігитимне використання очищувачів торкаються об'єктів з <em>природним
        напарником</em>. Природний напарник є природним (не-Java) о'бєктом, до
      якого нормальний об'єкт делегує через природні методи. Оскільки природні
      частини не є звичайними об'єктами, збирач сміття не знає щодо його, та не
      може повернути ресурси під час утілізації його Java напарника. Очищувач
      або фіналайзер може бути потрібним механізмом для цього завдання,
      вважаючи, що продуктивність прийнятна, та природна частина не утримує
      критичних ресурсів. Якщо продуктивність неприпустима, або природний код
      утримує ресурси, що мають бути безпосередньо повернуті, клас повинен мати
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">close</code>,
      як описано вище.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Очищувачі
      трохи складно використовувати. Нижче простий клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Room</code><span class="Apple-converted-space">,
        що демонструє цей механізм</span>. Будемо вважати, що кімнати мають бути
      очищені до того, як вони будуть відновлені. Клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Room</code><span class="Apple-converted-space">
        реалізує</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">AutoCloseable</code>;
      факт, що його страховочна сітка автоматичного очищення використовує
      очищувач, є тільки деталлю реалізації. На відміну від фіналайзерів,
      очищувачі не вкидають до публічного API класу:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Самоочищуваний клас використовує очищувач як страховочну сітку</strong><br>
      public class Room implements AutoCloseable {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final Cleaner cleaner =
      Cleaner.create();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Ресурс, що потребує очищення.<span class="Apple-converted-space">
      </span><strong>Не має посилатись на Room!</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static class State implements Runnable {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int numJunkPiles; // Число
      сміття в кімнаті<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;State(int numJunkPiles) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.numJunkPiles
      = numJunkPiles;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Викликається з метода
      close <em>або</em><span class="Apple-converted-space"> </span>очищувача<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public void
      run() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Cleaning
      room");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numJunkPiles
      = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Стан цієї кімати, поділяється з нашим cleanable<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final State state;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Наше cleanable. Очищує кімнату, коли та стає
      жертвою gc<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Cleaner.Cleanable cleanable;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Room(int numJunkPiles) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state = new
      State(numJunkPiles);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanable =
      cleaner.register(this, state);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public void close() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cleanable.clean();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Вкладений
      статичний клас<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">State</code><span
        class="Apple-converted-space"> містить ресурси, що потрібні очищувачу
        для виконання своєї роботи.</span> В цьому випадку, це просто <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">numJunkPiles</code>field,
      що представляє число безладу в кімнаті. Більш реалістично, це може бути
      final<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">long</code><span
        class="Apple-converted-space">, що містить вказівник на природний об'єкт</span>.<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">State
        </code>реалізує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Runnable</code>,
      та його метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">run</code><span
        class="Apple-converted-space"> викликається в основному один раз</span>,
      з боку <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cleanable</code><span
        class="Apple-converted-space">, що ми отримуємо, коли ми реєструємо наш
        примірник </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">State</code><span
        class="Apple-converted-space"> з нашим очисником в конструкторі </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Room</code>.
      Виклик до методу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">run</code><span
        class="Apple-converted-space"> буде спрацьовувати по одній з двох речей</span>:
      звичайно, він викликатиметься через виклик методу <span class="Apple-converted-space"></span><span
        epub:type="pagebreak" id="page_33"></span><code style="font-family: 'Courier New', monospace;">Room</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">close</code>,
      що викличе метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Cleanable</code>
      clean. Якщо клієнт забуде викликати метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">close</code><span class="Apple-converted-space">
        під час того, як примірник</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Room</code><span class="Apple-converted-space">
        буде на шляху до збирача сміття</span>, очищувач буде (нащастя)
      викликати метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">State</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">run</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Є
      критичним, щоб примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">State</code><span class="Apple-converted-space">
        не посилався на свій примірник </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Room</code>. Якщо зробити
      це, це створить цикл, що заважатиме примірнику <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Room</code><span class="Apple-converted-space">
      </span>стати предметом збирача сміття (та від автоматичної очистки). Таким
      чином, <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">State</code><span
        class="Apple-converted-space"> має бути вкладеним</span><span class="Apple-converted-space">
      </span><em>static</em><span class="Apple-converted-space"> класом,
        оскільки нестатичні вкладені класи містять посилання на свої оточуючі
        примірники </span>(<a href="ch4.xhtml#lev24" style="text-decoration: none;">Елемент
        24</a>). Також подібним чином нерекомендоване використовувати лямбду, бо
      вони легко можуть захопити посилання на оточуючі об'єкти.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      ми казали раніше, очищувач <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Room</code>
      використовується тільлки як страховка. Якщо клієнти оточать всі примірники
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Room</code><span
        class="Apple-converted-space"> в блоки</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">try</code>-with-resource,
      автоматичне очищення ніколи не знадобиться. Цей гарно-поведінковий клієнт
      демонструє цю поведінку:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Adult {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try (Room myRoom = new
      Room(7)) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Goodbye");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      ви очікували, виконання програми<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Adult</code><span class="Apple-converted-space">
        друкує</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Goodbye</code>,
      за чим слідує<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Cleaning
        room</code>. Але що до ціх хворобливо-поведінкових програм, що ніколи не
      очищають кімнати?</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Teenager {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Room(99);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println("Peace
      out");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
      Ви можете очікувати, що воно надрукує<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Peace out</code>,
      за чим послідує<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Cleaning
        room</code>, але на моїй машині воно ніколи не друкує<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Cleaning room</code>;
      воно просто виходить. Це та непередбачуваність, про яку ми казали раніше.
      Специфікація<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Cleaner</code><span
        class="Apple-converted-space"> каже:</span> “Поведінка очищувачів під
      час <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">System.exit</code><span
        class="Apple-converted-space"> залежить від реалізації</span>. Немає
      гарантій відносно того, будуть виконані дії з очистки, або ні”. Хоча
      специфікація не каже цього, те саме вірно для нормального виходу з
      програми. На моїй машині додавання рядка <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">System.gc()</code><span class="Apple-converted-space">
        до методу</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Teenager</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">main</code><span
        class="Apple-converted-space"> досить, щоб воно почало друкувати </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cleaning
        room</code><span class="Apple-converted-space"> перед виходом</span>,
      але немає гарантії, що ви побачите таку ж поведінку на вашій машині.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      результаті - не використовуйте очищувачі, або в версії до Java 9
      фіналізоатори, за винятком страхуючої сітки, або щоб завершити некритичні
      зовнішні ресурси. Та навіть і тоді ачувайтесь щодо невизначеності та
      наслідках для продуктивності.</p>
    <h3 class="h3b" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 72px; text-indent: -72px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_34"></span><strong>Елемент 9: Обирайте</strong><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>try</strong></code><strong>-with-resources
        замість</strong><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>try</strong></code><strong>-</strong><code
        style="font-family: 'Courier New', monospace;"><strong>finally</strong></code></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Бібліотеки
      Java включають багато ресурсів, що мають бути зачинені вручну, через
      виклик методу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">close</code>.
      Приклади включають <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">InputStream</code>,<code
        style="font-family: 'Courier New', monospace;"> OutputStream</code>, та<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">java.sql.Connection</code>.
      Зачинення ресурсів часто недоглядається з боку клієнтів, з передбачувано
      тяжкими наслідками для продуктивності. Хоча багато з ціх ресурсів
      використовують фіналайзери як страховку, ці фіналайзери не роблять дуже
      гарно (<a href="ch2.xhtml#lev8" style="text-decoration: none;">Елемент 8</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Історично,
      твердження <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">try</code>-<code
        style="font-family: 'Courier New', monospace;">finally</code><span class="Apple-converted-space">
        було кращим шляхом гарантувати, що ресурс буде зачинено вірно, навіть
        перед лицем виключення або </span>return:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        try-finally - Більше не кращий спосіб закрити ресурси!</strong><br>
      static String firstLineOfFile(String path) throws IOException {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;BufferedReader br = new BufferedReader(new
      FileReader(path));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return br.readLine();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;br.close();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      може виглядати непогано, але все піде гірше, коли ви додасте другий
      ресурс:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        try-finally непривабливе, коли використовується більше ніж з одним
        ресурсом!</strong><br>
      static void copy(String src, String dst) throws IOException {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;InputStream in = new FileInputStream(src);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OutputStream out = new
      FileOutputStream(dst);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[]
      buf = new byte[BUFFER_SIZE];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
      n;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while
      ((n = in.read(buf)) &gt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.write(buf,
      0, n);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.close();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} finally {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in.close();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Можливо,
      в це складно повірити, але навіть гарні програмісти невірно все це
      розуміють в більшості випадків. Для початківців, я не зрозумів цього на
      сторінці 88 в<span class="Apple-converted-space"> </span><em>Java
        Puzzlers</em>[<a href="ref.xhtml#rBloch05" style="text-decoration: none;">Bloch05</a>],
      і ніхто не зрообив зауваження на протязі років. Фактично, дві треті
      використань метода&nbsp;<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">close</code><span class="Apple-converted-space">
        в бібліотеках </span>Java були помилковими в 2007-му році.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_35"></span>Навіть коректний код для
      замикання ресурсів в виразах<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">try</code>-<code style="font-family: 'Courier New', monospace;">finally</code>,
      як ілюстровано в попередніх двох прикладах, мають невеликий недолік. Код в
      обох блоках <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">try</code><span
        class="Apple-converted-space"> </span>та<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">finally</code><span
        class="Apple-converted-space"> </span>може в викликати виключення.
      Наприклад, в <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">firstLineOfFile</code>method,
виклик
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">readLine</code><span
        class="Apple-converted-space"> може викликати виключення через відмову в
        фізичному пристрої, та виклик до</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">close</code><span
        class="Apple-converted-space"> може також потім схибити з тієї ж причини</span>.
      За таких обставин друге виключення повністю знищить перше. Немає запису
      щодо першоно виключення в стеку виключень, що може значно ускладнити
      налагодження в реальних системах — зазвичай ви бажаєте бачити перше
      виключеня, щоб диагностувати проблему. Хоча можливо написати код для
      придушення другого виключеня на користь першого, буквально ніхто не робить
      це через велику складність.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Всі
      з ціх проблем були вирішені в один крок, коли Java 7 ввела твердження<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">try</code>-with-resources
      [JLS, 14.20.3]. Щоб бути корисним з цією конструкцією, ресурс має
      реалізувати інтерфейс <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">AutoCloseable</code>,
      що складається з одного метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">close</code>. Зараз
      багато класів та інтерфейсів в бібліотеках Java та сторонніх бібліотеках
      реалізують або розширюють <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">AutoCloseable</code>.
      Якщо ви пишете клас, що представляє ресурс, який має зачинятись, ваш клас
      має також реалізувати <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">AutoCloseable</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ось
      як наш перший приклад виглядає з використанням <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-with-resources:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        try-with-resources - кращий спосіб зачиняти ресурси!</strong><br>
      static String firstLineOfFile(String path) throws IOException {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try (BufferedReader br = new BufferedReader(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
      FileReader(path))) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return br.readLine();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Та
      ось як виглядає наш другий приклад з використанням<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">try</code>-with-resources:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        try-with-resources на багатьох ресурсах - влучно та мило</strong><br>
      static void copy(String src, String dst) throws IOException {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try (InputStream&nbsp;&nbsp;&nbsp;in = new
      FileInputStream(src);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; OutputStream out = new
      FileOutputStream(dst)) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte[] buf = new
      byte[BUFFER_SIZE];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int n;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while ((n = in.read(buf))
      &gt;= 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;out.write(buf,
      0, n);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Версія
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">try</code>-with-resources
не
      тільки коротша та більш читабельна, ніж оригінальна, але вона також
      провадить кращу діагностику. Розглянемо метод the<code style="font-family: 'Courier New', monospace;">firstLineOfFile</code>.
      Якщо виключення виникають в обох викликах, <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">readLine</code><span class="Apple-converted-space">
        та</span> (прихованому)<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">close</code>, останє
      виключеня <em>придушується </em>на користь першого. Фактично, декілька
      виключень можуть бути придушені, щоб зберігти виключення, що ми насправді
      бажаємо бачити. Ці придушені виключення не просто відкидаються; вони
      друкуються в стеку з повідомленням, що вони були придушені. Ви також
      можете отримати доступ до них програмно, за допомогою метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">getSuppressed</code>, що
      було додане до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Throwable</code><span
        class="Apple-converted-space"> в</span> Java 7.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете додати вирази catch до тверджень<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">try</code>-with-resources,
      так само, як ви можете зробити це для звичайного <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-<code style="font-family: 'Courier New', monospace;">finally</code>.
      Це дозволяє вам обробляти виключення без забруднення вашого коду
      додатковим рівнями вкладання. Як трохи надуманий приклад, ось версія
      нашого <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">firstLineOfFile</code>method,
      що не підіймає виключень, але приймає значення по замовчанню, що
      повертається, якщо файл неможливо відкрити або прочитати з нього:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        try-with-resources з твердженням catch</strong><br>
      static String firstLineOfFile(String path, String defaultVal) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try (BufferedReader br = new BufferedReader(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
      FileReader(path))) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return br.readLine();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} catch (IOException e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return defaultVal;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Урок
      простий: заджди використовуйте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-with-reso
      переважно до&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">try-finally</code><span
        class="Apple-converted-space">, коли робите з ресурсами, що мають
        зачинятись</span>. Отриманий код коротший та ясніший, та згенеровані
      виключення більш корисні. Твердження <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try-</code>with-resources
      робить простим написання коректного коду з використанням ресурсів, що має
      зачинятись, що було практично неможливо за допомогою <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">try</code>-<code style="font-family: 'Courier New', monospace;">finally</code>.</p>
    <p> </p>
    <h2 class="h2" id="ch3" style="font-size: 29px; margin-top: 30px; margin-bottom: 30px; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Глава
      3. Методи, загальні для всіх об'єктів</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><span
          style="font-family: sans-serif;">Хоча </span>Object</code><span class="Apple-converted-space">
        є суцільним класом, він розроблений в основному для розширення. Всі його
        нефінальні методи </span>(<code style="font-family: 'Courier New', monospace;">equals</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">hashCode</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">toString</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">clone</code>,
      <code style="font-family: 'Courier New', monospace;">finalize</code>)
      мають явні<span class="Apple-converted-space"> <em>загальні контракти</em>,
        оскільки вони розроблені бути перекритими. Відповідальністю кожного
        класу є перекриття ціх методів, що підкорятимуться їх загальним
        контрактам</span>; неспроможність зробити це заважить іншим класам, що
      залежать від ціх контрактів (таких, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashMap</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">HashSet</code>)
      від відповідного функціонування разом з класом.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      глава каже вам, коли та як перекривати нефінальні методи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>. Метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">finalize</code><span
        class="Apple-converted-space"> видалений з цієї глави, оскільки він
        обговорений&nbsp; в</span><span class="Apple-converted-space"> </span><a
        href="ch2.xhtml#lev8" style="text-decoration: none;">Елементі 8</a>.
      Хоча він і не є методом, <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Comparable.compareTo</code><span
        class="Apple-converted-space"> обговорюється в цій главі, оскільки він
        має подібний характер</span>.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Елемент
        10: підкоряйтесь загальному контракту, коли перекриваєте </strong><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>equals</strong></code></h3>
    <p class="noindentb" style="margin-top: 0px; margin-bottom: 15px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Перекриття
      методу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> виглядає простим, але багато шляхів
        зробити це невірно, та наслідки будуть значними. Найпростіший спосіб
        уникнути проблем - це не перекривати метод&nbsp;</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>,
      в якому випадку кожний примірник класу еквівалентний тільки сам собі. Це
      правильна річ, яку треба робити, якщо виникає одна з наступних умов:</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><strong>Кожний примірник класу
        природно унікальнийй.</strong><span class="Apple-converted-space"> Це
        вірно для класів, таких як </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Thread</code><span class="Apple-converted-space">,
        що презентують активні сутності, скоріше, ніж значення. Реалізація</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, запроваджена </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        має виключно правильну поведінку для цього випадку.</span></p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><strong>Для класу немає потреби
        провадити перевірку “логічної еквівалентності”.</strong><span class="Apple-converted-space">
        Наприклад, </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.util.regex.Pattern</code><span
        class="Apple-converted-space"> може мати перекритий </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> </span>для перевірки, коли примірники <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Pattern</code><span
        class="Apple-converted-space"> представляють той самий регулярний вираз,
        але розробники не вважають, що клієнти мають потребувати або бажати </span>цієї
      функціональності. За таких умов, реалізація<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, наслідувана від </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        є ідеальною</span>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_38"></span>•<span class="Apple-converted-space">
      </span><strong>Суперклас вже перекриває </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code>,<span
        class="Apple-converted-space"> </span><strong>і поведінка реалізації
        суперкласу підходить до цього класу.</strong><span class="Apple-converted-space">
        Наприклад, більшість реалзацій </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code> наслідують
      свої реалізації<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> від</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">AbstractSet</code>,<span
        class="Apple-converted-space"> реалізації </span><code style="font-family: 'Courier New', monospace;">List</code><span
        class="Apple-converted-space"> від</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">AbstractList</code>,
      та<span class="Apple-converted-space"> реалізації </span><code style="font-family: 'Courier New', monospace;">Map
        від</code><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">AbstractMap</code>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><strong>Клас є приватним або
        пакунок-приватним, та ви впевнені, що його метод</strong><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><span
        class="Apple-converted-space"> </span><strong>ніколи не буде
        викликатись.</strong><span class="Apple-converted-space"> Якщо ви
        екстремально не схильні до ризику, ви можете перекрити метод </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, щоб переконатись, що він не викликається
        випадково</span>:</p>
    <p class="preb" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">@Override
      public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError(); // Метод ніколи не
      викликається<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      коли має сенс викликати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>? Це тоді,
      коли клас має логику <span class="Apple-converted-space"></span><em>логічної
        еквівалентності, </em>що відрізяється від простої ідентичносі об'єктів,
      та суперклас не має вже перекритого <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>. Це,
      загалом, випадок для <em>класів значень</em><em>.</em><span class="Apple-converted-space">
        Клас-значення є класом, що просто представляє значення</span>, таке, як
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Integer</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">String</code>.
      Програміст, що порівнює посилання на о'бєкти-значення з використанням
      методу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, очікує з'ясувати, чи вони логічно
        еквівалентні, не те, чи вони посилаються на один об'єкт. Перекриття
        методу </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>
      потрібне не тільки для задоволення потреб програміста. Це також служить
      для ключів мапи або множини,&nbsp; з передбачуваною поведінкою.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Один
      тип з класів-значень, що <em>не </em>потребує перекриття методу<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, є клас, що використовує контроль за
        екземпляром</span> (<a href="ch2.xhtml#lev1" style="text-decoration: none;">Елемент
        1</a>), щоб переконатись, що щонайбільше існує один об'єкт з кожним
      значенням. Тип енумерацій (<a href="ch6.xhtml#lev34" style="text-decoration: none;">Елемент
        34</a>) підпадає в цю категорію. Для ціх класів логічна еквівалентність
      це те саме, що і ідентичність о'бєктів, так що метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> функціонує як метод логічної
        еквівалнтності </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви перекриваєте метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>,
      ви маєте притримуватись його загальному контракту. Ось контракт зі
      специфікації <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space">&nbsp;</span>:</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Метод
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> </span>реалізує&nbsp; <span class="Apple-converted-space"></span><em>відношення
        еквівалентності.</em><span class="Apple-converted-space"> </span>Він
      має такі властивості:</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><em>Рефлексивність</em>: для
      любого&nbsp; non-null посилання значення<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">x</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">x.equals(x)</code><span
        class="Apple-converted-space"> повинне повертати</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><em>Симетричність</em>: для
      любого non-null посилання на<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">x</code><span class="Apple-converted-space">
        на</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">y</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">x.equals(y)</code><span
        class="Apple-converted-space"> має повертати</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code><span
        class="Apple-converted-space">, тоді і тільки тоді, коли</span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"> y.equals(x)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      <span class="Apple-converted-space"></span><em>Транзитивність</em>: для
      любого&nbsp; non-null посилання на значення<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">x</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">y</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">z</code>,
      якщо <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">x.equals(y)</code><span
        class="Apple-converted-space"> </span>повертає<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">y.equals(z)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>, <code
        style="font-family: 'Courier New', monospace;"></code>тоді&nbsp;<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">x.equals(z)</code><span
        class="Apple-converted-space"> має повертати</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><em>Узгодженість</em>: для любого
      non-null посилання на значення<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">x</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">y</code>,
      множинні виклики&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">x.equals(y)</code><span
        class="Apple-converted-space"> мають узгоджено повертати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code><span class="Apple-converted-space">
        або узгоджено повертати</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">false</code>, якщо
      інформація, використана в<span class="Apple-converted-space"> порівняннях
      </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, не модифікована</span>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Для любого non-null посилання на значення<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">x</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">x.equals(null)</code><span
        class="Apple-converted-space"> має повертати</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">false</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_39"></span>Якщо ви не схильні до
      математики, все це може виглядати трохи лячно, але не ігноруйте це! Якщо
      ви порушите це, ви можете виявити, що ваша програма поводиться помилково
      або падає, та може бути дуже складно пришпилити джерело помилки.
      Перефразуючи John Donne, жодний клас не є островом. Примірники одного
      класу часто передаються до іншого. Багато класів, включаючі всі класи
      колекцій, залежать від того, що передані їм об'єкти дотримуються контракту
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер,
      коли ви попереджені про небезпеку порушення контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>, давайте
      пройдемось по контракту в деталях. Гарні новини полягають в тому, що всі
      вони не такі складні. Як тільки ви їх зрозумієте, стане просто слідувати
      їм.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      що таке відношення еквівалентності? Кажучи просто, це оператор, що поділяє
      набір елементів на підмножини, чиї елементи виглядають еквівалентними один
      одному. Ці підмножини відомі як <span class="Apple-converted-space"></span><em>класи
        еквівалентності</em>. Щоб метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        був користний</span>, всі з елементів кожного класу еквівалентності
      мають бути взаємозамінні з точки зору користувача. Тепер давайте
      перевіримио п'ять вимог, одне за одним:</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Рефлективність
        </strong>— Перша вимога каже лише те, що об'єкт має бути еквівалентний
      самий собі. Складно уявити, що ви порушите це правило випадково. Якщо ви
      порушите його, та потім додасте клас до колекції, метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">contains</code><span class="Apple-converted-space">
        може сказати, що колекція не містить цього примірника, хоча він був
        доданий</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Симетрія
        </strong>— Друга вимога каже, що любі два об'єкти мають домовитись, чи
      вони є еквівалентними. На відміну від першої вимоги, нескладно уявити
      ненавмисне порушення цього правила. Наприклад, розглянемо клас, що
      реалізує рядки без розрізняння реєстру. Реєстр рядка зберігається<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space">, але ігнорується порівнянням </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Поламане
        - порушує симетрію!</strong><br>
      public final class CaseInsensitiveString {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final String s;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public CaseInsensitiveString(String s) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.s =
      Objects.requireNonNull(s);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// П</strong><strong>оламане - порушує
        симетрію!</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o instanceof
      CaseInsensitiveString)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      s.equalsIgnoreCase(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((CaseInsensitiveString)
      o).s);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>if (o instanceof
        String)&nbsp;&nbsp;// Взаємодіє в одну сторону!</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return
        s.equalsIgnoreCase((String) o);</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;// Закінчення не показане<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Гарно
      налаштований метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> в цьому класі наївно намагається
        взаємодіяти зі звичайними рядками. Давайте уявимо, що ми маємо один
        нечутливий до реєстру рядок, та один звичайний</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">CaseInsensitiveString
      cis = new CaseInsensitiveString("Polish");<br>
      String s = "polish";</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      і очікувалось, <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">cis.equals(s)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>.
      Проблема в тому, що хоча метод<span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"> equals</code><span class="Apple-converted-space">
        в</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code><span
        class="Apple-converted-space"> знає про звичайні рядки, метод </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> в</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">String</code><span
        class="Apple-converted-space"> байдужий до нечутливих рядків. Таким
        чином</span>,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">s.equals(cis)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">false</code>,
      що явно порушує симетрію. Уявімо, що ми поклали нечутливий рядок до
      колекції:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">List&lt;CaseInsensitiveString&gt;
      list = new ArrayList&lt;&gt;();<br>
      list.add(cis);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Що<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">list.contains(s)</code><span
        class="Apple-converted-space"> </span>повертатиме в цьому місці? Хто
      знає? В поточній версії OpenJDK воно повертає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">false</code>, але це
      тільки атрифакт реалізації. В іншій реалізації воно може так само просто
      повернути <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">true</code><span
        class="Apple-converted-space">, або підняти виключення часу виконання</span>.<span
        class="Apple-converted-space"> </span><strong>Одного разу, коли ви
        порушили контракт </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><strong>,
        ви вже не знаєте, як буде діяти інший об'єкт в протистоянні з вашим
        об'єктом.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      уникнути проблеми, просто видаліть хворобливе намагання взаємодіяти зі <code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        з метода</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Як тільки ви зробите це, ви можете зробити рефакторинг метода в єдиний
      рядок return:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">@Override
      public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return o instanceof CaseInsensitiveString
      &amp;&amp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((CaseInsensitiveString)
      o).s.equalsIgnoreCase(s);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Транзитивність
        </strong>— Третя вимога контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        каже, що якщо один об'єкт еквівалентний до іншого, а той до третього, то
        перший має бути еквівалентним до третього</span>. Знову, нескладно
      уявити ненавмистне порушення цієї вимови. Розглянемо випадок субкласу, що
      додає до свого суперкласу новий <span class="Apple-converted-space"></span><em>компонент
        значення</em>. Іншими словами, субклас додає частину інформації, що
      впливає на порівняння <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Давайте почнемо з простого незмінного класу двовимірної точки:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Point {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final int y;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Point(int x, int y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof Point))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Point p = (Point)o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return p.x == x &amp;&amp;
      p.y == y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;// Залишок не показаний<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Уявімо,
      що ви бажаєте розширити цей клас, додаючи до точки значення кольору:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class ColorPoint extends Point {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Color color;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public ColorPoint(int x, int y, Color color) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color = color;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;//&nbsp;Залишок не показаний<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      має виглядати метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code>?
      Якщо ми повністю полишимо його, реалізація буде наслідувана з<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space">, та інформація про колір буде
        ігноруватись при порівнянні</span>. Хоча це не порушує контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>, зрозуміло,
      що це неприйнятно. Уявімо, що ви написали метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">,
        що повертає </span><code style="font-family: 'Courier New', monospace;">true</code><span
        class="Apple-converted-space"> тільки якщо його аргумент є точкою з
        кольором, та має той самий колір та координати</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломане - порушує симетрію!</strong><br>
      @Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof ColorPoint))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>return super.equals(o) &amp;&amp;
        ((ColorPoint) o).color == color;</strong><br>
      }</p>
    <span style="font-family: sans-serif;">Проблема з цім методом в тому, що ви
      можете отримати різні результати, коли порівнюєте точку з кольоровою
      точкою, та навпаки. Перше порівняння ігнорує колір, тоді як друге завжди
      повертатиме</span><code style="font-family: 'Courier New', monospace;">
      false, оскільки тип аргумента некоректний. Щоб надати цьому конкретики,
      давайте створимо одну точку, та одну кольорову точку</code>:
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Point
      p = new Point(1, 2);<br>
      ColorPoint cp = new ColorPoint(1, 2, Color.RED);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тоді<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">p.equals(cp)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>, в
      той час, як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">cp.equals(p)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">false</code>.
      Ви можете спробувати полагодити цю проблему, зробивши, щоб <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ColorPoint.equals</code><span
        class="Apple-converted-space"> ігнорував колір, коли виконуються </span>“змішані
      порівняння”:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломане - порушує транзитивність!</strong><br>
      @Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof Point))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// Якщо o є звичайна Point, закрити очі на
        колір при порівнянні</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>if (!(o instanceof ColorPoint))</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return
        o.equals(this);</strong><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// o є ColorPoint; зробити повне порівняння<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return super.equals(o) &amp;&amp; ((ColorPoint)
      o).color == color;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      підхід надає симетрію, але ціною транзитивності:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ColorPoint
      p1 = new ColorPoint(1, 2, Color.RED);<br>
      Point p2 = new Point(1, 2);<br>
      ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">p1.equals(p2)</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">p2.equals(p3)</code><span
        class="Apple-converted-space"> повертають</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>,
      але<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">p1.equals(p3)</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">false</code>,
      чисте порушення транзитивності. Перші два порівняння ігнорують колір, але
      третє приймає його до уваги.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Також,
      цей підхід може викликати безкінечну рекурсію: уявіть, що є два субкласи<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Point</code>,
      скажімо, <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">ColorPoint</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">SmellPoint</code>,
      і кожний має такий різновид методу<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">equals</code>. Тоді
      виклик до<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">myColorPoint.equals(mySmellPoint)</code><span
        class="Apple-converted-space"> буде викликати</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">StackOverflowError</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">То
      яке може бути рішення? Виявляється, що це фундаментальна проблема
      відношення еквівалентності в об'єктно-орієнтованих мовах.<span class="Apple-converted-space">
      </span><strong>Немає способу розширити клас з примірниками, та додати
        компонент значення, зберігши контракт </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code>,
      за винятком, коли ви не бажаєте забути про переваги об'єктно-орієнтовної
      абстракції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Можливо,
      ви чули як кажуть, що ви можете <span epub:type="pagebreak" id="page_43"></span>клас,
      та додати компонент значення, і при цьому зберігти контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">,
        через перевірку </span><code style="font-family: 'Courier New', monospace;">getClass</code><span
        class="Apple-converted-space">, замість перевірки</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">instanceof</code><span
        class="Apple-converted-space"> в методі </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломане - порушує принцип підстановки Ліскова</strong><br>
      @Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>if (o == null || o.getClass() !=
        getClass())</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return false;</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;Point p = (Point) o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return p.x == x &amp;&amp; p.y == y;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      матиме ефект еквівалентності об'єктів, тільки якщо вони мають той самий
      клас реалізації. Це може виглядати непогано, але наслідки неприйнятні:
      примірник субкласу<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space"> все ще є </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Point</code>, та він все
      ще має функціонувати як такий, але він не зможе цього робити, якщо
      використати цей підхід! Давайте уявімо, що ми бажаємо написати метод, що
      казатиме, чи точка лежить на одиничному колі. Ось один зі способів, як це
      можна зробити:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Ініціалізуємо
        unitCircle що містить всі Point на одиничному колі</strong><br>
      private static final Set&lt;Point&gt; unitCircle = Set.of(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new Point(
      1,&nbsp;&nbsp;0), new Point( 0,&nbsp;&nbsp;1),<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new
      Point(-1,&nbsp;&nbsp;0), new Point( 0, -1));<br>
      <br>
      public static boolean onUnitCircle(Point p) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return unitCircle.contains(p);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      це, можливо, не найшвидший спосіб реалізувати цю функціональність, але це
      робить гарно. Уявімо, що ви розширили <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Point</code><span class="Apple-converted-space">
        в деякий тривіальний спосіб, що не додає компонент значення, скажімо,
        щоб конструктор відстежував, скільки примірників було створено</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class CounterPoint extends Point {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final AtomicInteger counter =<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new
      AtomicInteger();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public CounterPoint(int x, int y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(x, y);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;counter.incrementAndGet();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static int numberCreated() { return
      counter.get(); }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>Принцип
        підстановки Ліскова </em><span class="Apple-converted-space"></span>каже,
      що люба важлива властивість типу має також зберігатись для всіх підтипів,
      так що любий метод, написаний для типу, повинен так само робити на його
      підтипах [<a href="ref.xhtml#rLiskov87" style="text-decoration: none;">Liskov87</a>].
      Це формальне твердження нашого попереднього зауваження, що субклас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space">&nbsp;</span>( такий як <code style="font-family: 'Courier New', monospace;">CounterPoint</code>)
      все ще є <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space">, та має діяти як такий</span>. Але
      уявімо, що ми передали <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">CounterPoint</code><span
        class="Apple-converted-space"> в метод</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">onUnitCircle</code>.
      Якщо клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space"> використовує базований на </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">getClass</code> метод<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code>,
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">onUnitCircle</code><span
        class="Apple-converted-space"> буде повертати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">false</code><span class="Apple-converted-space">,
        н незалежно від координат x та y примірника </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">CounterPoint</code>. Це
      так, бо більшість колекцій, включаючи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">,
        використаний в методі</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">onUnitCircle</code>,
      використовують метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> для перевірки приналежності, та ніякий
        примірник</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">CounterPoint</code><span
        class="Apple-converted-space"> не еквівалентний до жодного</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Point</code>.
      Якщо, однак, ми використовуємо відповідний метод<span class="Apple-converted-space"></span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> на основі </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">instanceof</code> для<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Point</code>,
      метод same<code style="font-family: 'Courier New', monospace;">onUnitCircle</code><span
        class="Apple-converted-space"> робить гарно, коли представлений
        примірником </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">CounterPoint</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      немає задовільного способу розширити клас та додати компонент значення, є
      гарний кружний шлях: слідуйте пораді <a href="ch4.xhtml#lev18" style="text-decoration: none;">Елементу
        18</a>, “<a href="ch4.xhtml#lev18" style="text-decoration: none;">Обирайте
        композицію замість наслідування</a>”. Замість того, щоб <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ColorPoint</code><span class="Apple-converted-space">
        розширював</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Point</code>,
      надайте<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">ColorPoint</code><span
        class="Apple-converted-space"> приватне поле</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Point</code><span
        class="Apple-converted-space">, та публічний метод </span><em>view</em>
      (<a href="ch2.xhtml#lev6" style="text-decoration: none;">Елемент 6</a>),
      що повертає точку в тій же позиції, що і ця кольорова точка:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Додає компонент значення без порушення контракту еквівалентності</strong><br>
      public class ColorPoint {<br>
      &nbsp;&nbsp; private final Point point;<br>
      &nbsp;&nbsp; private final Color color;<br>
      <br>
      &nbsp;&nbsp; public ColorPoint(int x, int y, Color color) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;point = new Point(x, y);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.color =
      Objects.requireNonNull(color);<br>
      &nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; /**<br>
      &nbsp;&nbsp;&nbsp;&nbsp;* Повертає точку для цієї кольорової точки.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;*/<br>
      &nbsp;&nbsp;<span class="Apple-converted-space">&nbsp;</span><strong>public
        Point asPoint()</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return point;<br>
      &nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; @Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof ColorPoint))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ColorPoint cp = (ColorPoint) o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return cp.point.equals(point)
      &amp;&amp; cp.color.equals(color);<br>
      &nbsp;&nbsp; }<br>
      <br>
      &nbsp;&nbsp; ...&nbsp;&nbsp;&nbsp;&nbsp;// Залишок опущений<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існують
      деякі класи в бібліотеках на платформі Java, що розширюють клас та додають
      компонент значення. Наприклад, <code style="font-family: 'Courier New', monospace;">java.sql.Timestamp</code><span
        class="Apple-converted-space">&nbsp;</span><span epub:type="pagebreak" id="page_45"></span>розширює<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">java.util.Date</code><span
        class="Apple-converted-space">, та додає поле </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">nanoseconds</code>.
      Реалізація <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> для </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Timestamp</code><span class="Apple-converted-space">
        порушує симетрію, та може викликати помилкову поведінку, якщо
        об'єкти&nbsp;</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Timestamp</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Date</code><span
        class="Apple-converted-space"> використовуються в тій же колекції, або
        змішуються в інший спосіб</span>. Клас <code style="font-family: 'Courier New', monospace;">Timestamp</code><span
        class="Apple-converted-space"> має дисклаймер, що попереджає
        програмістів не змішувати дати та відтиски часу. Хоча ви не потрапите в
        халепу, доки ви утримуватимете їх окремо, нічого не заважає вам змішати
        їх, та отриману помилку буде важко викрити</span>. Ця поведінка класу <code
        style="font-family: 'Courier New', monospace;">Timestamp</code><span class="Apple-converted-space">
        була помилкою, яку не варто відтворювати</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що ви <em>можете </em>додати компонент значення до субкласу <em>абстрактного
        </em>класу, без порушення контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>. Це важливо
      для сортування ієрархій класу, до яких ми дійдемо, слідуя порадам в <span
        class="Apple-converted-space"></span><a href="ch4.xhtml#lev23" style="text-decoration: none;">Елементі
        23</a>, “Надавайте перевагу ієрархіям класів перед поміченими класами”.
      Наприклад, ви можете мати абстрактний клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Shape</code><span class="Apple-converted-space">
        без компонент значеннь</span>, субклас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Circle</code><span
        class="Apple-converted-space">, що додає поле</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">radius</code>,
      ту субклас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Rectangle</code><span
        class="Apple-converted-space">, що додає поля </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">length</code><span class="Apple-converted-space">
        та </span><code style="font-family: 'Courier New', monospace;">width</code>.
      Проблеми показаного вище сорту не виникатимуть, доки неможливо створити
      примірник суперкласу напряму.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Узгодженість
        </strong>— Четверта вимога контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        каже, що якщо два об'єкти еквівалентні, вони мають лишатись еквівалентні
        весь час, за винятком, коли один (або обидва) не будуть модифіковані</span>.
      Іншими словами, змінні об'єкти можуть бути еквівалентні до різних об'єктів
      в різний час, але незмінні об'єкти не можуть. Коли ви пишете клас, гарно
      поміркуйте, чи має він бути незмінним (<a href="ch4.xhtml#lev17" style="text-decoration: none;">Елемент
        17</a>). Якщо ви дійдете висновку, що це так, переконайтесь, що ваш
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals
        </code>накладає обмеження, що еквівалентні методи залишаються
      еквівалентними, а нееквівалентні нееквівалентними, весь час.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Незалежно,
      чи є клас незмінним, або ні, <span class="Apple-converted-space"></span><strong>не
        пишіть метод </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><span
        class="Apple-converted-space">, </span><strong>що покладається на
        ненадійні ресурси.</strong><span class="Apple-converted-space"> Вкрай
        складно задовільнити вимозі узгодженості, якщо ви порушуєте цю заборону.
        Наприклад, метод </span><span class="Apple-converted-space"><span class="Apple-converted-space"></span><code
          style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space"></span>
      </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.net.URL</code><span
        class="Apple-converted-space"> покладається на порівняння </span><span
        class="Apple-converted-space"><span class="Apple-converted-space"></span>IP
        адрес </span>вузлів, асоційованих з URL. Переклад імені вузла на IP
      адресу потребує доступу до мережі, та не дає гарантовано тих самих
      результатів з часом. Це може призветси до того, що метод <code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">URL</code><span
        class="Apple-converted-space"> </span>порушить контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        , та може викликати проблеми на практиці</span>. Ця поведінка методу <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">URL</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> була великою помилкою, яку не треба
        повторювати</span>. Нажаль, це не можна змінити через вимоги сумісності.
      Щоб уникати цього сорту проблем, методи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
      </span>повинні виконувати тільки детермініські обчислення на резидентних в
      пам'яті об'єктах.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Не-null
        —</strong> Заключна вимога не має офіційного ім'я, так що довільно
      назвемо її не-null-овість”. Вона каже, що всі об'єкти мають бути нерівними
      з <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">null</code>.
      Хоча складно уявити випадкове повернення <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code><span class="Apple-converted-space">
        у відповідь на&nbsp;</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">o.equals(null)</code>,
      нескладно уявити випадкое виключення <code style="font-family: 'Courier New', monospace;">NullPointerException</code>.
      Головний контракт забороняє це. Багато класів мають методи<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, що чатують проти цього, явно перевіряючи
        на </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">null</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">@Override
      public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (o == null)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      перевірка не потрібна. Щоб перевірити аргумент на рівність, метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        має спершу привести свій аргумент до відповідного типу, так що його
        ассесори зможуть бути викликані, або буде доступ до його полів</span>.
      Перед виконання приведення метод має виконати оператор <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">instanceof</code><span class="Apple-converted-space">
        для перевірки, що аргумент коректного типу</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">@Override
      public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof MyType))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;MyType mt = (MyType) o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      перевірка типу відсутня, і методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        переданий аргумент невірного типу, метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        буде викликати </span><code style="font-family: 'Courier New', monospace;">ClassCastException</code>,
      що порушує контракт <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Але оператор <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">instanceof</code><span
        class="Apple-converted-space"> налаштований повертати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">false</code><span class="Apple-converted-space">,
        якщо його операнд </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>, безвідносно,
      який тип з'являється в другому операнді [JLS, 15.20.2]. Таким чином,
      перевірка типу поверне <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">false</code><span
        class="Apple-converted-space">, якщо їй переданий</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">null</code>,
      так що вам не треба явно перевіряти на <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Складаючи
      все докупи, ось рецепт для високоякісного методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>:</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">1.<span
        class="Apple-converted-space"> </span><strong>Використовуйте оператор</strong><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>==</strong></code><span
        class="Apple-converted-space"> </span><strong>для перевірки, чи
        аргумент є посиланням на сам об'єкт.</strong><span class="Apple-converted-space">
        Якщо це так, повертайте </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code>. Це лише
      оптимізація продуктивності, але її варто робити, якщо перевірка потенційно
      коштовна.</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">2.<span
        class="Apple-converted-space"> </span><strong>Використовуйте оператор</strong><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>instanceof</strong></code><span
        class="Apple-converted-space"> </span><strong>для перевірки, чи
        аргумент має коректний тип.</strong><span class="Apple-converted-space">
        Якщо ні, повертайте </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">false</code>. Зазвичай,
      коректний тип є класом, в якому трапляється цей метод. Іноді це деякий
      інтерфейс, реализований в цьому класі. Використовуйте інтерфейс, якщо клас
      реалізує інтерфейс, що визначає контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">,
        щоб дозволити порівняння між класами, що реалізують інтерфейс</span>.
      Інтерфейси колекцій, такі як <code style="font-family: 'Courier New', monospace;">Set</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Map</code>
      та&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map.Entry</code><span
        class="Apple-converted-space"> </span>мають цю властивість.</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">3.<span
        class="Apple-converted-space"> </span><strong>Приведіть аргумент до
        коректного типу.</strong><span class="Apple-converted-space"> </span>Оскільки
      цьому приведенню передувала перевірка <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">instanceof</code>, воно
      буде гарантовано успішним.</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_47"></span>4.<span class="Apple-converted-space">
      </span><strong>Для кожного “значущого” поля в класі, перевірте, чи це поле
        в аргументі співпадає з відповідним полем цього об'єкта.</strong><span class="Apple-converted-space">
        Якщо це буде успішним</span>, повертайте<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">true</code>;
      інакше повертайте<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">false</code>.
      Якшр тип еа кроці 2 є інтерфейсом, ви маєте отримати доступ до полів
      аргумента через методи інтерфейса; якщо типом є клас, ви можете бути в
      змозі отримати доступ до полів напряму, в залежнсоті від їх доступності.</p>
    <p class="numberp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">For
      primitive fields whose type is not<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">float</code><span class="Apple-converted-space">&nbsp;</span>or<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">double</code>,
      use the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">==</code><span
        class="Apple-converted-space">&nbsp;</span>operator for comparisons; for
      object reference fields, call the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">&nbsp;</span>method
      recursively; for<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">float</code><span
        class="Apple-converted-space">&nbsp;</span>fields, use the static<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Float.compare(float,
        float)</code><span class="Apple-converted-space">&nbsp;</span>method;
      and for<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">double</code><span
        class="Apple-converted-space">&nbsp;</span>fields, use<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Double.compare(double,
        double)</code>. The special treatment of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">float</code><span class="Apple-converted-space">&nbsp;</span>and<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">double</code><span
        class="Apple-converted-space">&nbsp;</span>fields is made necessary by
      the existence of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Float.NaN</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">-0.0f</code><span
        class="Apple-converted-space">&nbsp;</span>and the analogous<code style="font-family: 'Courier New', monospace;">double</code><span
        class="Apple-converted-space">&nbsp;</span>values; see JLS 15.21.1 or
      the documentation of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Float.equals</code><span
        class="Apple-converted-space">&nbsp;</span>for details. While you could
      compare<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">float</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">double</code><span class="Apple-converted-space">&nbsp;</span>fields
      with the static methods<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Float.equals</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Double.equals</code>,
      this would entail autoboxing on every comparison, which would have poor
      performance. For array fields, apply these guidelines to each element. If
      every element in an array field is significant, use one of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Arrays.equals</code>methods.</p>
    <p class="numberp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Some
      object reference fields may legitimately contain<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">null</code>. To avoid the
      possibility of a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">NullPointerException</code>,
      check such fields for equality using the static method<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Objects.equals(Object,
        Object)</code>.</p>
    <p class="numberp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">For
      some classes, such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code><span
        class="Apple-converted-space">&nbsp;</span>above, field comparisons are
      more complex than simple equality tests. If this is the case, you may want
      to store a<span class="Apple-converted-space">&nbsp;</span><em>canonical
        form</em><span class="Apple-converted-space">&nbsp;</span>of the field
      so the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">&nbsp;</span>method can do a cheap exact
      comparison on canonical forms rather than a more costly nonstandard
      comparison. This technique is most appropriate for immutable classes (<a href="ch4.xhtml#lev17"
        style="text-decoration: none;">Елемент 17</a>); if the object can
      change, you must keep the canonical form up to date.</p>
    <p class="numberp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      performance of the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">&nbsp;</span>method may be affected by the
      order in which fields are compared. For best performance, you should first
      compare fields that are more likely to differ, less expensive to compare,
      or, ideally, both. You must not compare fields that are not part of an
      object’s logical state, such as lock fields used to synchronize
      operations. You need not compare<span class="Apple-converted-space">&nbsp;</span><em>derived
        fields</em>, which can be calculated from “significant fields,” but
      doing so may improve the performance of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">&nbsp;</span>method.
      If a derived field amounts to a summary description of the entire object,
      comparing this field will save you the expense of comparing the actual
      data if the comparison fails. For example, suppose you have a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Polygon</code><span class="Apple-converted-space">&nbsp;</span>class,
      and you cache the area. If two polygons have unequal areas, you needn’t
      bother comparing their edges and vertices.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_48"></span><strong>Коли ви закінчили
        писати метод </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><strong>,
        запитайте себе три питання: Чи він симетричний? Чи він транзитивний? Чи
        він узгоджений?</strong><span class="Apple-converted-space"> І не тільки
        запитайте це в себе</span>; напишіть тести для перевірки, тільки якщо ви
      не використовували AutoValue для генерації вашого метода<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      В цьому випадку ви можете просто оминути ці тести. Якщо ці властивості не
      дотримуються, зрозумійте чому, та відповідно модифікуйте<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Звичайно, ваш метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals
        </code>має також задовільняти іншим двом принципам (рефлексивності та
      не-null-овості), але ці двоє звичайно потурбуються про себе самі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Метод
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, побудований згідно попередньому рецепту,
        показаний в цьому спрощеному класі </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Клас з типовим методом equals</strong><br>
      public final class PhoneNumber {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final short areaCode, prefix, lineNum;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public PhoneNumber(int areaCode, int prefix, int
      lineNum) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.areaCode =
      rangeCheck(areaCode,&nbsp;&nbsp;999, "area code");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.prefix&nbsp;&nbsp; =
      rangeCheck(prefix,&nbsp;&nbsp;&nbsp;&nbsp;999, "prefix");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.lineNum&nbsp;&nbsp;=
      rangeCheck(lineNum,&nbsp;&nbsp;9999, "line num");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static short rangeCheck(int val, int max,
      String arg) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (val &lt; 0 || val &gt;
      max)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new
      IllegalArgumentException(arg + ": " + val);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (short) val;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>@Override public boolean equals(Object o)</strong><span
        class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o == this)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof
      PhoneNumber))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PhoneNumber pn =
      (PhoneNumber)o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return pn.lineNum ==
      lineNum &amp;&amp; pn.prefix == prefix<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;
      pn.areaCode == areaCode;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок опущений<br>
      }</p>
    <p class="noindentb" style="margin-top: 0px; margin-bottom: 15px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ось
      декілька заключних тонкощів:</p>
    <p class="bullb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><strong>Завжди перекривайте</strong><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>hashCode</strong></code><span
        class="Apple-converted-space"> </span><strong>коли перекриваєте </strong><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><span
        class="Apple-converted-space">&nbsp;</span>(<a href="ch3.xhtml#lev11" style="text-decoration: none;">Елемент
        11</a>).</p>
    <p class="bullb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space"> </span><strong>Не намагайтесь бути дуже
        розумним.</strong><span class="Apple-converted-space"> Якщо ви просто
        перевірите поля на рівність, нескладно дотримуватись контракту</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Якщо ви будете надто агресивні в пошуку еквівалентності, легко натрапити
      на складнощі. Загалом є поганою ідеєю приймати до уваги любі форми
      псевдонимів. Наприклад, клас<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">File <span style="font-family: sans-serif;">не
          повинен намагатись порівнювати символічні посилання, що посилаються на
          той самий файл</span></code>. Дякуємо, що він цього і не робить.</p>
    <p class="bullb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_49"></span>•<span class="Apple-converted-space">
      </span><strong>Не підставляйте інший тип замість</strong><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>Object</strong></code><span
        class="Apple-converted-space"> </span><strong>в декларації</strong><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><strong>.</strong><span
        class="Apple-converted-space"> </span>Не є винятком, коли програміст
      пише метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, що виглядає як цей, та потім витрачає
        години, здогадуючись, чомі він не робить вірно</span>:</p>
    <p class="prebb" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 0px; margin-bottom: 6.666667px; margin-left: 57.333336px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломане - параметр має бути Object!</strong><br>
      public boolean equals(MyClass o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      }</p>
    <p class="bullp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 42.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Проблема
      в тому, що цей метод <em>не перекриває </em><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object.equals</code>, чий
      аргумент має тип<span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code>,
      але замість цього <em>перевантажує </em>його (<a href="ch8.xhtml#lev52"
        style="text-decoration: none;">Елемент 52</a>). Неприпустимо провадити
      такий “сувого типізований” метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        на додаток до звичайного, оскільки це може призвести до того, що
        анотації&nbsp;</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Override</code> в
      субкласах будуть давати фальшивий позитивний результат, та провадити хибне
      уявлення про безпеку.</p>
    <p class="bullp" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 42.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Узгоджене
      використання анотацій <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Override</code>,
      як показане на протязі цього елементу, буде зопобігати від утворення
      помилок (<a href="ch6.xhtml#lev40" style="text-decoration: none;">Елемент
        40</a>). Метод <code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> не буде компілюватись, та повідомлення
        помилки буде казати вам, що саме пішло не так</span>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch3_images.xhtml#pch3ex20a" id="pch3ex20" style="text-decoration: none;">&nbsp;</a></p>
    <p class="prebb" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 0px; margin-bottom: 6.666667px; margin-left: 57.333336px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Все
        ще поламане, але не буде компілюватись</strong><br>
      <strong>@Override</strong><span class="Apple-converted-space">&nbsp;</span>public
      boolean equals(MyClass o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Написання
      та тестування методів <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">&nbsp;</span>(та<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">hashCode</code>)
      тонке, але отриманий код є необхідним. Чудовою альтернативою написанню та
      тестуванню ціх методів вручну є використання відкритого фреймворку
      Google&nbsp; AutoValue, що автоматично генерує ці методи для вас, що
      вмикається одною анотацією на класі. В більшості випадків методи,
      згенеровані AutoValue, будуть ідентичні до тих, що ви напишете руками.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">IDE,
також,
      мають можливості генерувати методи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      але отриманий початковий код більш балакучий та складніший до читання, нуж
      код, що використовує&nbsp; AutoValue, не відстежує зміни в класі
      автоматично, і, таким чином, вимагає тестування. Тим не менш, генерація
      IDE <span class="Apple-converted-space">методів </span><code style="font-family: 'Courier New', monospace;">equals</code>(та<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>)
      загалом краща, ніж реалізація їх вручну, оскільки IDE не роблять неуважних
      помилок, які роблять люди.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Підсумовуючи,
      не перекривайте метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> без потреби</span>: в багатьох випадках
      реалізація, наслідувана від <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        робить саме те, що вам потрібно</span>. Якщо ви перекриваєте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>,
      переконайтесь, що порівняли всі важливі поля класу, та порівняли їх в
      спосіб, що зберігає всі п'ять властивостей контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_50"></span><strong>Елемент 11: Завжди
        перекривайте </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>hashCode</strong></code><span
        class="Apple-converted-space">, коли перекриваєте </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>equals</strong></code></h3>
    <p class="noindentb" style="margin-top: 0px; margin-bottom: 15px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Ви
        маєте перекрити </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>hashCode</strong></code><span
        class="Apple-converted-space"> </span><strong>в кожному класі, який
        перекриває </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>equals</strong></code><strong>.</strong><span
        class="Apple-converted-space"> Якщо ви схибите зробити це, ваш клас буде
        порушувати головний контракт </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      що буде запобігати потрібному функціонуванню в колекціях, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashMap</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">HashSet</code>.
      Ось контракт, адаптований зі специфікації <code style="font-family: 'Courier New', monospace;">Object</code>:</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Коли метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> постійно викликається на об'єкті під час
        виконання застосування, він має постійно повертати те саме значення,
        вважаючи, що інформація, використана в порівнянні не змінилась. Це
        значення не має бути тим самим від одного виконання застосування до
        іншого</span>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Якщо два об'єкти рівні згідно метода<span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"> equals(Object)</code>,
      тоді виклик <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> на двох об'єктах має продукувати той
        самий цілий результат</span>.</p>
    <p class="bull1" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 40px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Якщо два методи нерівні згідно метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals(Object)</code>, <em>не
        обов'язково </em>виклик <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code><span class="Apple-converted-space">
        на кожному об'єкті має продукувати інший результат</span>. Однак
      програміст має бути попереджений, що продукування різних результатів для
      нерівних об'єктів може покращити продуктивність хеш таблиць.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Ключова
        засада, що порушується при відсутності перекриття </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>hashCode</strong></code><span
        class="Apple-converted-space"> </span><strong>є друга: рівні об'єкти
        мають рівні хеш коди.</strong><span class="Apple-converted-space"> Два
        різні примірники можуть бути логічно рівними, відповідно до методу </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> класу</span>, але щодо методу<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      вони лише два об'єкти, що не мають нічого спільного. Таким чином, метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> повертає два вочевидь випадкові числа,
        замість двох рівних чисел, як виммагається в контракті</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наприклад,
      уявімо, що ви намагаєтесь використовувати примірники класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        з Елементу 10, в якості ключів в </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashMap</code>:</p>
    <p class="preba" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 50.666668px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Map&lt;PhoneNumber,
      String&gt; m = new HashMap&lt;&gt;();<br>
      m.put(new PhoneNumber(707, 867, 5309), "Jenny");</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      цій точці ви можете очікувати, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">m.get(new PhoneNumber(707</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">867</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">5309))</code><span
        class="Apple-converted-space"> поверне</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">"Jenny"</code>,
      але замість цього він повертає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>. Зауважте, що
      задіяні два примірники <code style="font-family: 'Courier New', monospace;">PhoneNumber</code>:
      один використано для вставки в <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashMap</code>, та
      другий, еквівалентний примірник, використаний для (спроби) отримання.
      Відмова класу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> перекрити </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code><span class="Apple-converted-space">
        призводить до того, що два рівні примірника мають нерівні хеш коди, </span>в
      порушення контракту <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode</code>.
      Таким чином, метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">get</code><span
        class="Apple-converted-space"> вірогідно шукатиме номер телефону в
        іншому бакеті хешу, відмінним від того, </span>в якому він був
      збережений методом <code style="font-family: 'Courier New', monospace;">put</code>.
      Навіть якщо два примірника випадково захешуються в один бакет, метод <code
        style="font-family: 'Courier New', monospace;">get</code><span class="Apple-converted-space">
        майже напевне поверне </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>, завдяки
      оптимізації<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">HashMap</code>has,
      що кешує хеш коди, асоційовані з кожним входженням, та не буде вовтузитись
      з рівністю об'єктів, якщо хеш коди не співпадають.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_51"></span>Вирішення цієї проблеми так
      само просте, як написати відповідний метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code><span class="Apple-converted-space">
        для</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>.
      Так на що має бтуи схожий метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code>?
      Тривіально написати поганий метод. Наприклад, настуний завжди легальний,
      але ніколи не буде використаний:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Найгірша з легальних реалізацій hashCode - ніколи не використовуйте!</strong><br>
      @Override public int hashCode() { return 42; }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      легально, бо це гарантує, що рівні об'єкти матимуть той самий хеш код. Це
      нелюдяно, бо дає гарантію, що <em>кожний </em>об'єкт матиме той самий
      хеш код. Таким чином, кожний об'єкт хешується в той самий бакет, і хеш
      таблиця дегенерує до пов'язаного списку. Програми, що мали б виконуватись
      за лінійний час, будуть виконуватись за квадратичний. Для великих хеш
      таблиць це різниця між робити та не робити.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Гарна
      хеш функція схильна продукувати нерівні хеш коди для нерівних примірників.
      Це саме те, що мається на увазі в третій частині контракту <code style="font-family: 'Courier New', monospace;">hashCode</code>.
      В ідеалі хеш функція має роподіляти любу доцільну колекцію на нерівні
      відстані одноманітно по всіх <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">int</code> значеннях.
      Досягнення цього ідеалу може бути складним. На щастя не дуже складно
      досягти чесної апроксимації. Ось простий рецепт:</p>
    <p class="number" style="margin-top: 0px; margin-bottom: 4px; margin-left: 20px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">1.
      Декларуйте змінну <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space"> </span>на ім'я <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">result</code>, та
      ініціалізуйте її хеш кодом <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">c</code><span class="Apple-converted-space">
      </span>для першого значущого поля вашого об'єкта, як обчислено на кроці
      2.a. (Нагадайте собі з Елементу 10, що значуще поле є те, що впливає на
      порівняння рівності).</p>
    <p class="number" style="margin-top: 0px; margin-bottom: 4px; margin-left: 20px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">2.
      Для кожного іншого значущого поля <code style="font-family: 'Courier New', monospace;">f</code><span
        class="Apple-converted-space"> вашого об'єкта зробіть наступне</span>:</p>
    <p class="alpha" style="margin-top: 0px; margin-bottom: 4px; margin-left: 41.333336px; text-indent: -17.333334px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">a.
      Обчіслять <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space"> хеш код</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">c</code><span
        class="Apple-converted-space"> для поля</span>:</p>
    <p class="roman" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 56px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">i.
Якщо
      поле примітивного типу, обчисліть <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><em>Type</em>.hashCode(f)</code>,
      де&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><em>Type</em></code><span
        class="Apple-converted-space"> є боксованим примітивним класом,
        відповідним до типу </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">f</code>.</p>
    <p class="roman1" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 56px; text-indent: -14.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ii.
Якщо
      поле є об'єктним посиланням, та метод <code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space"> цього класу порівнює поле через
        рекурсивні виклики </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>, рекурсивно
      викличте <code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> для поля</span>. Якщо потрібне більш
      вкладне порівняння, обчисліть “канонічне представлення” для цього поля, та
      викличте <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode
        </code>на канонічній репрезентації. Якщо значення поля <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>,
      використовуйте<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">0</code><span
        class="Apple-converted-space">&nbsp;</span>(або любу іншу константу, але
      традиційно це <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">0</code>).</p>
    <p class="roman2" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 54.666668px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">iii.
      Якщо поле є масив, розглядайте його, якби кожний елемент був окремим
      полем. Тобто, обчисліть хеш код для кожного важливого елементу, через
      рекурсивне застосування ціх правил, та скомбінуйте значення згідно крока
      2.b. Якщо масив не має значущих елементів, використовуйте константу,
      бажано не <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">0</code>.
      Якщо всі елементи значущі, використовуйте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Arrays.hashCode</code>.</p>
    <p class="alpha" style="margin-top: 0px; margin-bottom: 4px; margin-left: 41.333336px; text-indent: -17.333334px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">b.
Скомбінуйте
      хеш код <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">c,
        обчислений на кроці </code>2.a з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">result</code><span class="Apple-converted-space">
        наступним чином</span>:</p>
    <p class="codep1" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 92px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">result
      = 31 * result + c;</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">3.
      Поверніть<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">result</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_52"></span>Коли ви закінчите написання
      метода <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      запитайте себе, чи будуть однакові примірники мати однаковий хеш код.
      Напишіть юніт тести для перевірки вашої інтуіції (за винятком коли ви
      використовуєте AutoValue для генерації ваших методів <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      в якому випадку ви можете безпечно пропустити ці тести). Якщо рівні
      примірники мають неоднакові хеш коди, з'ясуйте в чому проблема, та
      вирішіть її.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете виключити <em>похідні поля </em>з обчислень хеш коду. Іншими
      словами, ви можете ігнорувати любі поля, чиї значення можуть бути
      обчислені з полів, які включені в обчислення. Ви <em>маєте </em>виключити
      любі поля, що не приймають участі в обчисленні <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>, або ви
      ризикуєте порушити другу засаду контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Множення
      на кроці 2.b робить результат залежним від порядку полів, даючи значно
      кращу хеш функцію, якщо клас має декілька подібних полів. Наприклад, якщо
      оминути множення для хеш функції<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">String</code>, всі
      анаграми матимуть ідентичні хеш коди. Значення 31 було обране, оскільки це
      непарне просте. Якщо це було б парне, та множення дало переповнення,
      інформація була б втрачена, оскільки множення на 2 еквівалентне до зсуву.
      Перевага використання простого менш зрозуміла, але це вже традиція. Гарна
      властивість&nbsp; числа 31 в тому, що множення можна замінити на зсув та
      відіймання для кращої продуктивності на деяких архитектурах:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">31 * i == (i &lt;&lt; 5)
        - i</code>. Сучасні VM роблять такий різновид оптимізації автоматично.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Давайте
      застосуємо попередній рецепт до класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Типовий метод hashCode</strong><br>
      @Override public int hashCode() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int result = Short.hashCode(areaCode);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;result = 31 * result + Short.hashCode(prefix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;result = 31 * result + Short.hashCode(lineNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскільки
      цей метод повертає результат простого детермінованого обчислення, на вхід
      якого надходять лише три значущі поля примірника <code style="font-family: 'Courier New', monospace;">PhoneNumber</code>,
      ясно, що еквівалентні примірники <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        мають однакові хеш коди</span>. Цей метод, фактично, є ідеально гарною
      реалізацією <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hashCode</code>
      для примірників <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>,
      порівнянно з такими в бібліотеках Java платформи. Він простий, достатньо
      швидкий, та робить досить роботи по розпорошенню неоднакових номерів по
      різних хеш бакетах.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      рецепт в цьому елементі дає досить хороші хеш функції, вони не є витвором
      мистецтва. По якості їх можна порівняти&nbsp; з хеш функціями, що можна
      знайти на Java платформі в бібліотеці типів, та адекватні в більшості
      випадків. Якщо ви переконані, що вам потрібіні хеш функції, що з меншою
      вірогідністю продукують колізії, дивіться&nbsp; Guava’s<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">com.google.common.hash.Hashing</code><span
        class="Apple-converted-space">&nbsp;</span>[<a href="ref.xhtml#rGuava" style="text-decoration: none;">Guava</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_53"></span>Клас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Objects</code><span
        class="Apple-converted-space"> має статичний метод, що приймає довільне
        число об'єктів, та повертає хеш код для них</span>. Цей метод з назвою <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">hash</code>
      дозволяє вам писати однорядкові методи<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space">, чия якість порівняна з тою, яку можна
        отримати завдяки застосуванню наданого вище рецепту. Нажаль, вони
        виконуються більш повільно, оскільки вони призводять до створення
        массиву, щоб передати змінне число аргументів, так само, як боксування
        та розбоксування, якщо деякі аргументи є примітивного типу. Цей стиль
        хеш функції рекомендований для використання тільки в ситуаціях, коли
        продуктивність некритична.</span> Ось хеш функція для <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space"></span>,
      написана з застосуванням цієї техніки:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Однорядковий метод hashCode - поміркована продуктивність</strong><br>
      @Override public int hashCode() {<br>
      &nbsp;&nbsp;&nbsp;return Objects.hash(lineNum, prefix, areaCode);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      клас незмінний, та вартість обчислення хеш коду є значною, ви можете
      розглянути кешування хеш коду в об'єкті, скоріше, ніж переобчислення його
      кожного разу, коли він потрібен. Якщо ви вважаєте, що більшість об'єктів
      цього типу будуть використані як хеш ключі, тоді вам потрібно обчислювати
      хеш код при створенні примірника. Інакше ви можете обрати <em>ліниву
        ініціалізацію</em><span class="Apple-converted-space"> </span>хеш коду
      при першому запиті хеш коду. Потрібно докласти певної уваги, щоб
      переконатись, що клас залишається потіко-безпечним в присутності ліниво
      ініціалізованого поля (Елемент 83). Наш клас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> не підпадає під таку класифікацію</span>,
      але щоб просто показати, як це робиться, ось результат. Зауважте, що
      початкове значення поля<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">hashCode</code> (в цьому
      випадку 0) не повинне бути хеш кодом загально створюваного примірника:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        метод hashCode з ліниво ініціалізованим хеш кодом</strong><br>
      private int hashCode; // Автоматично ініціалізоване як 0<br>
      <br>
      @Override public int hashCode() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int result = hashCode;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (result == 0) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result =
      Short.hashCode(areaCode);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = 31 * result +
      Short.hashCode(prefix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = 31 * result +
      Short.hashCode(lineNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hashCode = result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Не
        впадайте в спокусу виключити важливі поля з хеш коду для підвищення
        продуктивності.</strong><span class="Apple-converted-space"> Хоча
        отримана хеш функція може бути скорішою, </span>її низька якість може
      деградувати продуктивність хеш таблиць до межі, коли вони стануть
      непридатні для використання. Зокрема, хеш функція може зтикнутись з
      великою колекцією примірників, які відрізняються в основному в регіонах,
      які ви зібрались ігнорувати. Якщо це станеться, хеш функція буде
      відзеркалювати всі ці примірники на декілька хеш кодів, та програми, що
      мали б робити за лінійний час, будуть робити за квадратичний.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      не тільки теоретична проблема. До Java 2 хеш функція <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        застосовувалась до щонайбільше шістнадцятьох символів, рівномірно
        розподілених по рядку, починаючи з першого символа. Для великих колекцій
        ієрархічних імен, як </span>URL, ця функція показувала саме ту
      патологічну поведінку, що описана вище.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Не
        провадьте детальну специфікацію для значення, що повертає </strong><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>hashCode</strong></code><strong>,
        так що клієнт не зможе досить залежати на нього; це дає вам гнучкість
        змінити її.</strong><span class="Apple-converted-space"> Багато класів в
        бібліотеках</span> Java, такі, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Integer</code>,
      вказують точне значення, що повертає їх метод<span style="font-family: &quot;Courier New&quot;,monospace;">
      </span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> як функцію від значення примірника</span>.
      Це <em>негарна </em>ідея, а помилка, з якою ми змушені жити: це виключає
      здатність покращити хеш функцію в наступних релізах. Якщо ви залишите
      деталі невизначеними, та буде знайдено слабкість в хеш функції, або її
      кращий варіант, ви можете змінити її в наступному релізі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Підсумовуючи,
      ви <em>маєте </em>перекривати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code><span class="Apple-converted-space">
        кожного разу, коли перекриваєте </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>, або ваша
      програма не буде робити коректно. Ваш метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> має підкорюватись головному контракту,
        вказаному в </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"></span>, та має виконувати доцільну
      роботу, присвоюючи нерівні хеш коди нарівним примірникам. Цього просто
      досягти, хоча і дещо тендітно, використовуючи рецепт, наведений вище. Як
      зазначалось в Елементі 10, фреймворк AutoValue провадить гарну
      альтернативу написанню методів <code style="font-family: 'Courier New', monospace;">quals</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">hashCode</code><span
        class="Apple-converted-space"> вручну</span>, та IDE також провадять
      деяку з цієї функціональності.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_55"></span><strong>Елемент 12: Завжди
        перекривайте</strong><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;"><strong>toString</strong></code></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> провадить реалізацію методу </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code>,
      рядок, що він повертає, загалом не є тим, що бажає бачити користувач. Він
      складається з імені класу, за яким слідує знак “at” (<code style="font-family: 'Courier New', monospace;">@</code>),
      та беззнакове шістнадцятеричне представлення хеш коду, наприклад, <code style="font-family: 'Courier New', monospace;">PhoneNumber@163b91</code>.
      Загальний контракт до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> каже, що повернутий рядок повинен бути</span>
      “скороченим, але інформативним представленням, що може легко читатись
      людиною”. Хоча можна погодитись, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber@163b91</code><span
        class="Apple-converted-space"> стисле та просте для читання</span>, воно
      не дуже інформативне, коли порівняти з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">707-867-5309</code>.
      Контракт <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space">, продовжуючи, каже: </span>“Рекомендовано,
      щоб всі субкласи перекривали цей метод”. Безумовно, гарна порада!</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      це не так критично, як підкорення контрактам <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>
      (Елементи 10 та 11),<span class="Apple-converted-space"> </span><strong>провадження
        реалізації </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>toString</strong></code><strong>
        робить ваш клас значно приємнішим для використання, та робить системи,
        що використовують його, простішими в налаштуванні</strong>. Метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> викликається автоматично, коли об'єкт
        передається до</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">println</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">printf</code>, оператора
      конкатенації, або до<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">assert</code>,
      або друкується дебагером. Навіть якщо ви ніколи не викликаєте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        на об'єкті, інші можуть це робити</span>. Наприклад, компонент, що має
      посилання на ваш об'єкт, може включати рядкове представлення об'єкта до
      повідомлення в журналі про помилку. Якщо ви схибите перекрити<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">toString</code>,
      повідомлення може бути незмістовним.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви провадите гарний метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        для</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>,
      генерація корисного діагностичного повідомлення буде простою:</p>
    <p class="preba" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 50.666668px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">System.out.println("Failed
      to connect to " + phoneNumber);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Програмісти
      будуть генерувати диагностичні повідомлення в цей спосіб, перевизначите
      ви&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">toString</code>,
      або ні, але в останньому випадку повідомлення не будуть корисними.
      Переваги від провадження гарного методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        простягаються за межі примірників класу, до посилань об'єктів на ці
        примірники, особливо колекції</span>. Що ви швидше бажаєте побачити при
      друці мапи, <code style="font-family: 'Courier New', monospace;">{Jenny=PhoneNumber@163b91}</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">{Jenny=707-867-5309}</code>?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Коли
        це практично, метод </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>toString</strong></code><span
        class="Apple-converted-space"> </span><strong>повинен првертати <em>всю
          </em>цікаву інформацію, що міститься в об'єкті</strong>, як показано в
      прикладі з номером телефону. Це непрактично, якщо об'єкт виликий, або якщо
      він містить стан, що не поєднується з рядковим представленням. За ціх умов
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> повинен повертати відсумкові дані, як </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Manhattan
        residential phone directory (1487536 номерів)</code><span class="Apple-converted-space">
        або</span> <code style="font-family: 'Courier New', monospace;">Thread[main,5,main]</code>.
      В ідеалі рядок повинен бути самодостатнім. (Приклад зі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Thread</code><span class="Apple-converted-space">
        провалює цей тест</span>). Особливо докучливе покарання за невключення
      всіх цікавих полів об'єкту в рядкове представлення є повідомлення про
      схиблений тест такого вигляду:</p>
    <p class="preb" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Assertion
      failure: expected {abc, 123}, but was {abc, 123}.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Одне
      важливе рішення, яке ви маєте зробити при реалізації методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">:
        чи вказувати формат значення, що повертається, в документації</span>.
      Рекомендується, щоб ви робили це для класів <em>значень, </em>таких, як
      телефонний номер або матриця. Перевага від вказання формату в тому, що це
      служить як стандартна, однозначна, читаєма людиною репрезентація об'єкту.
      Ця репрезентація може бути використана для вводу та виводу в вигляді
      стійких, читаємих людиною, об'єктів даних, як CSV файли. Якщо ви вкажете
      формат, загалом буде гарною ідеєю запровадити відповідну статичну фабрику
      або конструктор, так що програмісти зможуть легко транслювати в обидві
      боки між об'єктом та рядковим представленням. Цей підхід взятий з багатьох
      класів значень в бібліотеках платформи Java, включаючи<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">BigInteger</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">BigDecimal</code>,
      та більшість з боксованих примітивних класів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Недолік
      вказувати формат результату <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        в тому, що коли ви колись вже вкажете його, ви пристанете до нього на
        все життя, вважаючи, що ваш клас буде широко уживаний. Програмісти
        будуть писати код для розбору вашої репрезентації, генерувати її, та
        вбудовувати в стійкі дані. </span>Якщо ви зміните репрезентацію в
      майбутньому релізі, ви зруйнуєте їх код та дані, і вони заверещать. Якщо
      ви оберете не вказувати формат, ви збережете гнучкість додавати інформацію
      в формат в наступному релізі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Чи
        вирішите ви вказувати формат, чи ні, вам слід ясно документувати свої
        наміри.</strong><span class="Apple-converted-space"> Якщо ви вказали
        формат, вам треба робити це з точністю</span>. Наприклад, ось метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space">, що іде разом з класом</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>
      з Елемента 11:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">/**<br>
      &nbsp;* Повертає рядкову репрезентацію цього телефонного номера.<br>
      &nbsp;* Рядок складається з дванадцятьох символів, в форматі<br>
      &nbsp;* "XXX-YYY-ZZZZ", де XXX є кодом місцевості, YYY є префіксом,<br>
      &nbsp;* та ZZZZ є лінійним номером. Кожна з великих літер представляє<br>
      &nbsp;* одну десяткову цифру.<br>
      &nbsp;*<br>
      &nbsp;* Якщо кожна з трьох частин цього номеру замала для заповнення<br>
      &nbsp;* поля, поле доповнюється нулями зліва.<br>
      &nbsp;* Наприклад, якщо значення лінійного номера є 123, останні<br>
      &nbsp;* чотири цифри рядка репрезентації будуть "0123".<br>
      &nbsp;*/<br>
      @Override public String toString() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return String.format("%03d-%03d-%04d",<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;areaCode,
      prefix, lineNum);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_57"></span>Якщо ви вирішуєте не задавати
      формат, документуючий коментар повинен читатись приблизно наступним чином:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">/**<br>
      &nbsp;* Повертає скорочений опис цього напою. Точні деталі представлення<br>
      &nbsp;* не вказуються, та можуть змінюватись, але наступне може вважатись<br>
      &nbsp;* як типове:<br>
      &nbsp;*<br>
      &nbsp;* "[Potion #9: type=love, smell=turpentine, look=india ink]"<br>
      &nbsp;*/<br>
      @Override public String toString() { ... }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Після
      читання цього коментаря програмісти, що продукують код або зберігають
      дані, що залежить від формату, не зможуть звинувачувати нікого, окрім
      себе, якщо формат зміниться.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Чи
      задаєте ви формат, чи ні, <span class="Apple-converted-space"></span><strong>провадьте
        програмний доступ до інформації, що міститься в значенні, яке повертає </strong><code
        style="font-family: 'Courier New', monospace;"><strong>toString</strong></code><strong>.</strong><span
        class="Apple-converted-space"> Наприклад, клас </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        повинен мати аксессори для коду місцевості, префіксу та лінійного
        номеру. Якщо ви не зробите це, ви <em>примушуєте </em>програмістів,
        якім потрібна ця інформація, розбирати рядок. Крім зменшення
        продуктивоності, та зайвої роботи для програмістів, цей процес схильний
        до помилок, та призведе до крихкої системи, що зламається, якщо формат
        буде змінено</span>. Не надаючи аксессори ви перетворюєте рядковий
      формат на де-факто API, навіть якщо ви зазначили, що він може змінитись.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Має
      сенс написати метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> в статичному допоміжньому класі</span>
      (Елемент 4). Ви не повинні писати метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        для більшості типів </span>enum (Елемент 34), оскільки Java провадить
      довершено гарний варіант. Однак вам слідує написати метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        для любого абстрактного класу, чий субкласи поділяють загальне
        представлення рядка</span>. Наприклад, методи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        для більшості з реалізацій колекцій наслідують від </span>абстрактних
      класів колекцій.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інструмент
      з відкритим кодом Google AutoValue, описаний в Елементі 10, згенерує метод
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space">&nbsp; за вас, так само, як і більшість </span>IDE.
      Ці методи гарні для показу вас вмісту всіх полів, але не націлені на <em>значення
        </em>класу. Так що, наприклад, може бути неприйнятним використовувати
      згенерований метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> для класу </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
      </span>(бо номери телефонів мають стандартну репрезентацію як рядок), але
      досить прийнятним для нашого класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Potion</code>. При всьому
      тому, згенерований метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        значно кращий від наслідуваного від </span><code style="font-family: 'Courier New', monospace;">Object</code>,
      що не каже <em>зовсім нічого </em>про значення об'єкту.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      підсумувати, перевизначайте реалізацію<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">toString</code><span
        class="Apple-converted-space"> в кожному класі, який ви пишете, за
        винятком того, що суерклас вже зробив це. Це робить класи значено більш
        приємними в використанні, та сприяє налаштуванню</span>. Метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        повинен повертати стислий, корисний опис об'єкта, в естетично приємному
        форматі</span>.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_58"></span><strong>Елемент 13: Розсудливо
        перекривайте </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><strong></strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інтерфейс
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code><span
        class="Apple-converted-space"> був задуманий як </span><span class="Apple-converted-space"></span><em>інтерфейс-міксін</em><span
        class="Apple-converted-space"> </span>(Елемент 20) для класів, щоб
      повідомити, що вони можуть клонуватись. Нажаль, він схибив прислужитись
      цій ролі. Його головна хиба полягає в тому, що йому бракує метода <code style="font-family: 'Courier New', monospace;">clone</code>,
      та метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> є захищеним</span>. Ви не можете, не
      вдаючись до <em>рефлексії</em> (Елемент 65), викликати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        на об'єкті, тільки через те, що він реалізує </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code>. Навіть
      рефлективний виклик може схибити, оскільки немає гарантії, що об'єкт має
      доступний метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>.
      Не зважаючи на&nbsp; цю ваду, та багато інших, можливість набула досить
      широкого застосування, так що має сенс зрозуміти її. Цей елемент розкаже
      вам, як реалізувати метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        з гарною поведінкою</span>, обговорює, коли має сенс це робити, та
      представляє альтернативи.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      що ж <em>робить </em><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code>,
      зважаючи, що він не має методів? Він визначає поведінку захищеної
      реалізації<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code>
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>:
      якщо клас реалізує<span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        Cloneable</code>,<span class="Apple-converted-space"> метод </span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> повертає поле-за-полем копію об'єкту</span>;
      інакше це викликає <code style="font-family: 'Courier New', monospace;">CloneNotSupportedException</code>.
      Це вкрай нетипове використання інтерфейсів, і не те, чому треба слідувати.
      Зазвичай, реалізація інтерфейсу каже, що клас може зробити для своїх
      клієнтів. В цьому випадку він модифікує поведінку захищеного методу
      суперкласа. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      специфікація не каже цього, <span class="Apple-converted-space"></span><strong>на
        практиці очікується, що клас, який реалізує </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>Cloneable</strong></code><span
        class="Apple-converted-space"></span><strong>, провадить відповідно
        функціонуючий публічний метод</strong><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><strong>.</strong><span
        class="Apple-converted-space"> Щоб досягти цього, клас, та всі його
        субкласи мають підкорятись складному, непримусовний, тонко
        документованому протоколу</span>. Результуючий механізм крихкий,
      небезпечний, та <em>екстралінгвістичний:</em> він створює об'єкти без
      виклику конструктора.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Головний
      контракт для метода <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> слабкий</span>. Ось він, скопійований зі
      специфікації<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code>:</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Створює
      та повертає копію об'єкта. Точне значення "копії" може залежати від класу
      або об'єкту. Головний намір полягає в тому, щоб для об'єкта <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">x</code>, вираз</p>
    <p class="codepbi" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 9.333334px; margin-bottom: 9.333334px; margin-left: 32px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">x.clone()
      != x</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">був<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">true</code>,
      та вираз</p>
    <p class="codep" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 22.666668px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">x.clone().getClass()
      == x.getClass()</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">був<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">true</code>,
      але це не абсолютна вимога. Хоча в типовому випадку </p>
    <p class="codep" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 22.666668px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">x.clone().equals(x)</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">буде<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">true</code>,
      це не абсолютна вимога.</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_59"></span>За домовленістю, об'єкт, що
      повертає цей метод, має утворитись через виклик <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">super.clone</code>. Якщо
      клас, та всі його суеркласи (виключаючи <code style="font-family: 'Courier New', monospace;">Object</code>)
      притримуються цієї домовленості, буде випадок, що</p>
    <p class="codep2" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 53.333336px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">x.clone().getClass()
      == x.getClass().</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">За
      домовленістю, об'єкт, що повертається, повинен бути незалежним від
      об'єкта, з якого він клонований. Щоб досягти цієї незалежності, може бути
      потрібним можифікувати одне або більше полів в об'єкті, повернутому з <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">super.clone</code><span
        class="Apple-converted-space"> перед його поверненням</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      механізм мляво подібний до сціплення конструкторів, за винятком того, що
      він непримусовний: якщо метод класу <code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> повертає примірник, що <em>не отриманий</em>
        від виклику</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">super.clone</code><span
        class="Apple-converted-space"></span>, але через виклик конструктора,
      компілятор не буде скаржитись, але якщо субклас цього класу викличе <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">super.clone</code>,
      отриманий об'єкт матиме невірний клас, перешкоджаючи субкласу вірно
      виконувати метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>.
      Якщо клас, що перекриває <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        є фінальним, ця домовленість може біти безпечно проігнорована, бо немає
        субкласів, про які треба турбуватись</span>. Але якщо фінальний клас має
      метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space">, що не викликає </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">super.clone</code>, для
      класу немає сенсу реалізувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code>, бо він
      не покладається на поведінку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>&nbsp; в
      реалізації клонування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Уявімо,
      що ви бажаєте реалізувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code><span class="Apple-converted-space">
        в класі, чий суперклас провадить гарно поводячий себе метод </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>.
      Спершу викличте <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">super.clone</code>.
      Об'єкт, що ви отримаєте взамін, буде повністю функціональною реплікою
      оригіналу. Любі поля, декларовані в вашому класі, будуть мати значення,
      ідентичні до таких самих в оригіналі. Якщо кожне поле має примітивне
      значення, або посилання на незмінний об'єкт, повернутий об'єкт може бути
      саме тим, що вам потрібне, і в такому випадку подальша обробка непотрібна.
      Це випадок, наприклад, для класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        з Елементу 11</span>, але зауважте, що <span class="Apple-converted-space"></span><strong>незмінні
        класи не повинні ніколи провадити метод </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><span
        class="Apple-converted-space">, оскільки це буде невідворотно сприяти
        даремному копіюванню</span>. З урахуванням цього нюансу, ось як має
      виглядати метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone
        </code>для<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Метод
        clone для класу без посилань на змінний стан</strong><br>
      @Override public PhoneNumber clone() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (PhoneNumber)
      super.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} catch (CloneNotSupportedException e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      AssertionError();&nbsp;&nbsp;// Не може трапитись<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      того, щоб цей метод робив, декларація класу для <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        має бути модифікованою, щоб вказати, що він реалізує</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Cloneable</code>.
      Хоча метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object</code>,
      цей метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> повертає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>.
      Є легальним та бажаним робити це, оскільки Java підтримує <em>коваріантні
        типи повернення</em>. Іншими словами, перекриваючий метод повертає тип,
      що може бути субкласом типу повернення перекритого метода. Це уникає
      потреби кастингу на стороні клієнта. Ми маємо приводити результат <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">super.clone</code><span class="Apple-converted-space">
        з</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> до</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> перед поверненням</span>, але кастинг
      гарантовано буде успішним.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Виклик
      до <code style="font-family: 'Courier New', monospace;">super.clone</code><span
        class="Apple-converted-space"> зачинений в блок</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">try-catch</code>.
      Це тому що<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> декларує свій метод&nbsp;</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> що викликає </span><code style="font-family: 'Courier New', monospace;">CloneNotSupportedException</code>,
      що є <em>перевіреним виключенням</em>. Оскільки <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        реалізує</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Cloneable</code>,
      ми знаємо, що виклик <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">super.clone
        буде успішним</code>. Потреба для цього шаблонного кода вказує, що
      виключення <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">CloneNotSupportedException</code><span
        class="Apple-converted-space"> ніколи не повинно залишитись
        неперевіреним</span> (Елемент 71).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщ
      об'єкт містить поля, що посилаються на змінні об'єкти, проста реалізація <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>,
      показана вище, може бути руйнівною. Наприклад, розглянемо клас в Елементі
      7:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Stack {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Object[] elements;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int size = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int DEFAULT_INITIAL_CAPACITY
      = 16;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Stack() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.elements = new
      Object[DEFAULT_INITIAL_CAPACITY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void push(Object e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacity();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size++] = e;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Object pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new EmptyStackException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object result =
      elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size] = null; //
      Видаляємо застаріле посилання<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Гарантуємо місце щонайменьше ще для одного
      елементу.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private void ensureCapacity() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elements.length ==
      size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements
      = Arrays.copyOf(elements, 2 * size + 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Уявімо,
      що ми робимо цей клас клонованим. Якщо метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        просто повертає</span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        super.clone()</code>, отриманий примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">
      </span>буде мати коректне значення в полі розміру, але його елементи
      будуть посилатись на тай самий масив, що і оригінальний примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code>. Модифікація
      оригіналу буде руйнувати інваріанти в клоні, і навпаки. Ви швидко
      зрозумієте, що ваша програма продукує нонсенс, або викликає <code style="font-family: 'Courier New', monospace;">NullPointerException</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      ситуація ніколи не може відбутись як результат виклику тільки конструктора
      класу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Stack</code>.<span
        class="Apple-converted-space"> </span><strong>Насправді метод </strong><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><span
        class="Apple-converted-space"> </span><strong>функціонує як
        конструктор; ви маєте переконатись, що він не шкодить оригінальному
        об'єктові, та що він відповідно встановлює інваріанти на клоні</strong>.
      Щоб метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> на</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Stack</code><span
        class="Apple-converted-space"> робив відповідно</span>, він має
      копіювати внутрощі стеку. Простіший шлях зробити це, є викликати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code> рекурсивно
      для елементів масиву:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Метод
        клонування для класу з посиланнями на змінний стан</strong><br>
      @Override public Stack clone() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stack result = (Stack)
      super.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.elements =
      elements.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} catch (CloneNotSupportedException e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      AssertionError();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що не маємо робити кастинг результата<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">elements.clone</code><span
        class="Apple-converted-space"> до</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object[]</code>.
      Виклик <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> на масиві повертає масив, в якого типи
        часу компіляції та виконання ідентичні до того масиву, що був
        клонований. Це переважна ідіома для дублікації масиву. Фактично, масиви
        є єдиним дієздатним використанням можливості клонування</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Також
      зауважте, що попереднє рішення не робить, якщо поле<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">elements</code><span
        class="Apple-converted-space"> буде</span> final, оскільки <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
      </span>буде заборонено присвоєння нового значення цьому полю. Це
      фундаментальна проблема: подібно до серіалізації,<span class="Apple-converted-space">
      </span><strong>архитектура </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>Cloneable</strong></code><span
        class="Apple-converted-space"> </span><strong>несумісна з нормальним
        використанням фінальних полів, що посилаються на змінні об'єкти</strong>,
      за винятком, коли змінні об'єкти можуть бути безпечно розділені між
      об'єктом та клоном. Щоб зробити клас клонованим, можливо знадобиться
      видалити модифікатор <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">final</code><span
        class="Apple-converted-space"> </span>для деякіх полів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      завжди достатньо просто викликати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        рекурсивно</span>. Наприклад, уявімо, що ви пишете метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        для хеш таблиці, чиї внутрощі складаються з масива бакетів, кожний з
        яких посилається на перший елемент в зв'язаному списку пар
        ключ-значення. Для продуктивності клас реалізує свій власний,
        легковажний, зв'язаний список, замість внутрішнього використання </span>using<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">java.util.LinkedList</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class HashTable implements Cloneable {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Entry[] buckets = ...;<br>
      <span epub:type="pagebreak" id="page_62"></span>&nbsp;&nbsp;&nbsp;&nbsp;private
      static class Entry {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Object key;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object value;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entry&nbsp;&nbsp;next;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entry(Object key, Object
      value, Entry next) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.key&nbsp;&nbsp;
      = key;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value
      = value;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;&nbsp;=
      next;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок випущено<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Уявімо,
      ми просто склонували масив бакетів рекурсивно, як ми робили для <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломаний метод clone - призводить до загального змінного стану!</strong><br>
      @Override public HashTable clone() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable result =
      (HashTable) super.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.buckets =
      buckets.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} catch (CloneNotSupportedException e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      AssertionError();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      клон має власний масив бакетів, цей масив повилається на ті самі списки,
      що і оригінал, що легко створить непередбачувану поведінку в обох, клоні
      та оригіналі. Щоб виправити цю проблему, ви маєте скопіювати зв'язані
      списки, що складають кожний бакет. Ось загальний підхід:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Рекурсивний метод клонування для класу зі складним змінним станом</strong><br>
      public class HashTable implements Cloneable {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private Entry[] buckets = ...;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static class Entry {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final Object key;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object value;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entry&nbsp;&nbsp;next;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entry(Object key, Object
      value, Entry next) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.key&nbsp;&nbsp;
      = key;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value
      = value;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.next&nbsp;&nbsp;=
      next;&nbsp;&nbsp;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      <span epub:type="pagebreak" id="page_63"></span><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>// Рекурсивна
        копія зв'язаного списку від цього Entry</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Entry deepCopy() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      new Entry(key, value,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next
      == null ? null : next.deepCopy());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public HashTable clone() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable
      result = (HashTable) super.clone();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.buckets
      = new Entry[buckets.length];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for
      (int i = 0; i &lt; buckets.length; i++)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
      (buckets[i] != null)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.buckets[i]
      = buckets[i].deepCopy();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} catch
      (CloneNotSupportedException e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new AssertionError();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок випущений<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Приватний
      клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashTable.Entry</code><span
        class="Apple-converted-space"> був розширений для підтримки методу </span>“глибокого
      копіювання”. Метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> для</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">HashTable</code><span
        class="Apple-converted-space"> розміщує масив нових бакетів відповідного
        розміру, та ітерує по масиву бакетів оригіналу</span>, глибоко копіюючи
      непусті бакети. Метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">deepCopy</code><span
        class="Apple-converted-space"> на&nbsp;</span> on<code style="font-family: 'Courier New', monospace;">Entry</code><span
        class="Apple-converted-space"> викликає себе, для копіювання цілого
        пов'язаного списку, що іде за цім елементом</span>. Хоча цей прийом
      втішний, і гарно робить, якщо бакети не задовгі, це не дуже гарний спосіб
      клонування зв'язаних списків, оскільки він споживає по одному фрейму стека
      для кожного елементу в списку. Якщо список довгий, ціе може просто
      привести до переповнення стеку. Щоб запобігти цьому, ви можете замінити
      рекурсію в <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">deepCopy</code><span
        class="Apple-converted-space"> на ітерацію</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Ітеративно копіює зв'язаний список, від цього Entry</strong><br>
      Entry deepCopy() {<br>
      &nbsp;&nbsp;&nbsp;Entry result = new Entry(key, value, next);<br>
      &nbsp;&nbsp;&nbsp;for (Entry p = result; p.next != null; p = p.next)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.next = new Entry(p.next.key,
      p.next.value, p.next.next);<br>
      &nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Фінальний
      підхід до клонування складних змінних об'єктів є виклик <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">super.clone</code>,
      встановлення всіх полів в отриманому об'єкті в свій первинний стан, та
      потім виклик методів вищого рівня для відновлення стану оригінального
      об'єкту. В нашому випадку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashTable</code>,
      поле&nbsp; <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">buckets</code><span
        class="Apple-converted-space"> може бути ініціалізоване новим масивом
        бакетів, та метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">put(key, value)</code><span
        class="Apple-converted-space"> </span>(не показаний) може бути
      викликаний для кожної пари ключ-значення в хеш таблиці, що клонується. Цей
      підхід типово дає простий, відносно елегантний метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">,
        що не робить так швидко, як той, що напряму маніпулює внутрощами клону</span>.
      Хоча цей підхід ясний, він протистоїть всій архитектурі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code><span class="Apple-converted-space">,
        оскільки він сліпо переписує копію об'єкта поле-за-полем, що складає
        базис архитектури.</span></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      і конструктор, метод клонування має ніколи не викликати перевантажувані
      методи на клоні, що будується (Елемент 19). Якщо клон викликає метод, що
      перекритий в субкласі, цей метод буде викликатись до того, як субклас
      матиме шанс полагодити власний стан в клоні, що, досить вірогідно,
      призведе до пошкодження клона та оригіналу. Таким чином, метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">put(key,
        value)</code><span class="Apple-converted-space">, обговорений в
        попередньому параграфі, має бути або фінальним, або приватним. </span>(Якщо
      він приватний, він, можливо, є "допомжіний метод" для нефінального
      публічного метода).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code
        style="font-family: 'Courier New', monospace;">Метод Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> декларований викликати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">CloneNotSupportedException</code>,
      але перекриті методи не мають це робити.<span class="Apple-converted-space">
      </span><strong>Публічні методи </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><span
        class="Apple-converted-space"> </span><strong>повинні уникати
        твердження </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>throws</strong></code>,
      бо методи, що не викликають перевірених виключень простіше використовувати
      (Елемент 71).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      маєте два вибори при розробці класу для наслідування (Елемент 19), але
      який ви не оберете, клас має <em>не реалізувати </em><code style="font-family: 'Courier New', monospace;">Cloneable</code>.
      Ви можете обрати копіювати поведінку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        реалізуючи відповідно функціонуючий метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">,
        що декларований для виклику </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">CloneNotSupportedException</code>.
      Це дає субкласу свободу реалізувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code><span class="Apple-converted-space">
        або ні</span>, так, якби він наслідував <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object </code>напряму.
      Альтернативно, ви можете обрати <em>не реалізувати </em>робочий метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>,
      та запобігти субкласи від його реалізації, через провадження наступної
      виродженої реалізації <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clone</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
метод
        клонування для розширюваного класу без підтримки Cloneable</strong><br>
      @Override<br>
      protected final Object clone() throws CloneNotSupportedException {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;throw new CloneNotSupportedException();<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Є
      ще одна деталь, що криється за всім цім. Якщо ви пишете потік-безпечний
      клас, що реалізує <code style="font-family: 'Courier New', monospace;">Cloneable</code>,
      пам'ятайте, що його метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        має бути відповідно синхронізований, так само, як любий інший метод</span>
      (Елемент 78).<span class="Apple-converted-space"> Метод </span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> не є синхронізованим, так що навіть коли
        його реалізація задовільняє вас в іншому, ви маєте писати
        синхронізований метод&nbsp;</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">,
        що повертає</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">super.clone()</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      підсумку, всі класи, що реалізують <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code><span class="Apple-converted-space">,
        повинні перекрити </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        публічним методом, тип повернення якого є самий клас. Цей метод має
        спочатку викликати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">super.clone</code>, та
      потім полагодити всі поля, що мають бути полагоджені. Типово, це означає
      копіювання всіх змінних об'єктів, що складають внутрішню “глибоку
      структуру” об'єкта, та заміну посилань клону на ці об'єкти на посилання на
      копії.<span class="Apple-converted-space"> Хоча ці внутрішні копії можуть
        зазвичай утворитись через рекурсивний виклик </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code>, але це не
      завжди кращий підхід. Якщо клас містить тільки примітивні поля, або
      посилання на незмінні об'єкти, тоді виглядає так, що наче поля не треба
      полагуджувати. Існують виключення з цього правила. Наприклад, поле, що
      представляє серійний номер, або інший унікальний ID, буде треба
      полагоджувати, навіть якщо він примітивний або незмінний.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Чи
      вся ця складність є необхідною? Рідко. Якщо ви розширюєте клас, що вже
      реалізує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code>,
      ви маєте малий вибір, крім реалізації гарно поводячогось метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code>. З іншого
      блоку, вам часто буде краще запровадити альтернатівні шляхи для копіювання
      об'єктів.<span class="Apple-converted-space"> </span><strong>Кращий
        підхід до копіювання об'єктів буде провадження <em>копіюючого
          конструктора або копіюючої фабрики</em></strong><strong>.</strong><span
        class="Apple-converted-space"> </span>Копіюючий конструктор це просто
      конструктор, що приймає єдиний аргумент, чий тип є клас, що містить
      конструктор. Наприклад,</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Копіюючий
        конструктор</strong><br>
      public Yum(Yum yum) { ... };</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Копіююча
      фабрика є статичною фабрикою (Елемент 1), аналогічною до конструктора:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Копіююча
        фабрика</strong><br>
      public static Yum newInstance(Yum yum) { ... };</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Підхід
      копіюючого конструктора та варіант статичної фабрики мають багато переваг
      над <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code>/<code
        style="font-family: 'Courier New', monospace;">clone</code>: вони не
      покладаються на схильний до ризику екстралінгвістичний механізм створення
      об'єкту; вони не вимагають нездійсненного дотримання ретельно
      документованих конвенцій; вони не конфліктують з відповідним використанням
      фінальних полів; вони не викликають непотрібних перевірених виключень; та
      вони не потребують кастингу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Більше
      того, конструктор копіювання або фабрика може приймати аргумент, чий тип є
      інтерфейсом, реалізованим в класі. Наприклад, за домовленостю всі колекції
      загального призначення провадять конструктор, чий аргмент має тип <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Collection</code><span class="Apple-converted-space">
        або</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map</code>.
      Базовані на інтерфейсі копіюючі конструктори або фабрики, більш відомі як
      <em>перетворюючі конструктори </em>або <em>перетворюючі фабрики, </em>дозволяють
      клієнту обирати тип реалізації копії, замість примушувати клієнта приймати
      тип реалізації оригіналу. Наприклад, уявіть, що ви маєте&nbsp; <code style="font-family: 'Courier New', monospace;">HashSet</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">s</code>,
      та бажаєте зробити копію як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">TreeSet</code>. Метод
      клонування не надасть цієї функціональності, але це легко робиться через
      конструктор перетворення:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">new TreeSet&lt;&gt;(s)</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Беручи
      до уваги всі проблеми, асоційовані з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code>, нові
      інтерфейси не повинні розширювати його, та нові розширювані класи не
      повинні реалізувати його. Хоча це менш шкідливо для фінальних класів
      реалізувати <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code>,
      це треба розглядати як оптимізацію продуктивності, резервуючи для рідких
      випадків, коли це виправдано (Елемент 67). Як правило, функціональність
      копіювання краще провадити в конструкторах або фабриках. Варте уваги
      виключення з цього є масиви, що найкраще копіюються за допомогою метода
      clone.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_66"></span><strong>Елемент 14: Розгляньте
        реалізацію </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>Comparable</strong></code></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">На
      відміну від інших методів, обговорених в цій главі, метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">
        не декларований в </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>. Скоріше,
      це єдиний метод в інтерфейсі <code style="font-family: 'Courier New', monospace;">Comparable</code>.
      Він подібний за характром до метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>,
      за тим винятком, що дозволяє також вказувати порівняння за порядком, на
      додаток до простої еквівалентності, та є дженеріком. Реалізуючи<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Comparable</code>,
      клас вказує, що його примірники мають <span class="Apple-converted-space"></span><em>природне
        впорядкування.</em><span class="Apple-converted-space"> Сортування
        масиву об'єктів, що реалізують</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Comparable</code><span
        class="Apple-converted-space">, таке просте, як це</span>:</p>
    <p class="codep" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 22.666668px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Arrays.sort(a);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      само легко шукати, обчислювати екстремуми значень, та підтримувати
      автоматично сортовані колекції об'єктів <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparable</code>.
      Наприклад, наступна програма, що покладається на факт, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        реалізує</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Comparable</code>,
      друкує впорядкований за алфавитом список аргументів командного рядка,
      виключаючи дублікати:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class WordList {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;String&gt; s = new
      TreeSet&lt;&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Collections.addAll(s,
      args);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(s);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Реалізуючи
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparable</code>
      ви дозволяєте вашому класу взаємодіяти з всіма із багатьох дженерік
      алгоритмів та реалізацій колекцій, що покладаються на цей інтерфейс. Ви
      отримуєте нечувану кількість потужності за невелику кількість зусиль.
      Віртуально всі з класів значень в бібліотеках платформи Java, так само, як
      і enum типи (Елемент 34), реалізують<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Comparable</code>. Якщо
      ви пишете класс значення з вочевидь природним впорядкуванням, як алфавітне
      впорядкування, числовий порядок, або хронологічний порядок, вам слідує
      реалізовати інтерфейс<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Comparable</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      interface Comparable&lt;T&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int compareTo(T t);<br>
      }</p>
    <p class="noindentb" style="margin-top: 0px; margin-bottom: 15px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Загальний
      контракт щодо метода <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> подібний до такого в </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>:</p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Порівнює
      цей об'єкт зі вказаним об'єктом щодо впорядкування. Повертає від'ємне,
      нуль або додатнє ціле, коли об'єкт менший за, рівний або більший за
      вказаний об'єкт. Підіймає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space">, якщо </span><span class="Apple-converted-space"><span
          class="Apple-converted-space">тип&nbsp; </span>вказаного об'єкту
        перешкоджає йому бути порівняним з цім об'єктом. <br>
      </span></p>
    <p class="indenti" style="margin-top: 6.666667px; margin-bottom: 6.666667px; margin-left: 18.666668px; text-indent: 0px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      наступному описі нотація <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">sgn</code>(<em>expression</em>)
      позначає математичну функцію <em>сігнум</em>, що визначена повертати<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">-</code>1,
      0, або 1, відповідно до того, чи значення <span class="Apple-converted-space"></span><em>expression</em><span
        class="Apple-converted-space"> негативне (від'ємне)</span>, нуль, або
      позитивне (додатнє).</p>
    <p class="bull1i" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 32px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Реалізатоор має переконатись, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">sgn(x.compareTo(y)) ==
        -sgn(y. compareTo(x))</code><span class="Apple-converted-space"> для
        всіх </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">x</code><span
        class="Apple-converted-space"> </span>та<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">y</code>. (Це
      також передбачає, що<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">x.compareTo(y)
        </code>має викликати виключення, якщо і тільки якщо<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">y.compareTo(x)</code><span
        class="Apple-converted-space"> </span>викликає виключення).</p>
    <p class="bull1i" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 32px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Реалізатор має також переконатись, що відношення є транзитивним:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">(x. compareTo(y) &gt; 0
        &amp;&amp; y.compareTo(z) &gt; 0)</code><span class="Apple-converted-space">
        передбачає, що</span><code style="font-family: 'Courier New', monospace;">
        x.compareTo(z) &gt; 0</code>.</p>
    <p class="bull1i" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 32px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Нарешті, реалізатор має впевнитись, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">x.compareTo(y) == 0</code><span
        class="Apple-converted-space"> передбачає</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">sgn(x.compareTo(z))
        == sgn(y.compareTo(z))</code>, для всіх<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">z</code>.</p>
    <p class="bull1i" style="margin-top: 0px; margin-bottom: 9.333334px; margin-left: 32px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•
      Дуже рекомендовано, але не вимагається, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">(x.compareTo(y) == 0) ==
        (x.equals(y))</code>. Взагалі кажучи, любий клас, що реалізує інтерфейс
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparable</code><span
        class="Apple-converted-space">, та порушує цю умову, має ясно вказувати
        на цей факт</span>. Рекомендовано висловлюватись так: “Зауваження: цей
      клас має природне впорядкування, що неузгоджене з<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>.”</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      лякайтесь математичної природи цього контракту. Як і контракт<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>
      (Елемент 10), цей контракт не такий складний, як виглядає. На відміну від
      метода <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>,
      що вводить глобальне відношення еквівалентності для всіх об'єктів, <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> не має робити між об'єктами різних типів</span>:
      коли стикається з об'єктами різних типів,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">
        дозволяється підіймати </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>.
      Звичайно, це саме те, що він і робить. Контракт <em>дозволяє </em>міжтипові
      порівняння, що зазвичай визначене в інтерфейсі, реалізованому об'єктами,
      що порівнюються.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Так
      само як клас, що порушує контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">hashCode</code><span class="Apple-converted-space">,
        може зруйнувати інші класи, що залежать від хешування, клас, що порівнює
        контракт</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> може зруйнувати інші класи, що залежать
        від порівняння</span>. Класи, що залежать від порівняння, включають
      сортовані колекції<span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        TreeSet</code><span class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">TreeMap</code><span
        class="Apple-converted-space">, та допоміжні класи</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Collections</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Arrays</code>,
      що містять алгоритми пошуку та сортування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Давайте
      пройдемось по засадах контракту <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code>. Перша
      засада каже, що якщо ви зміните напрямок порівняння між двома об'єктними
      посиланнями, має трапитись очікуване: якщо перший об'єкт менший за другий,
      тоді другий має бути більший за перший; якщо перший дорівнює другому, то
      другий має дорівнювати першому; та якщо перший більший за другий, другий
      має бути менший за перший. Друга засада каже, що якщо об'єкт більше за
      другий, та другий більший за третій, тоді перший має бути більший за
      третій. Заключна засада каже, що всі об'єкти, що порівнюються як рівні,
      повинні давати той самий результат при порівнянні з любим іншим об'єктом.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_68"></span>Одне зі слідоцтв з ціх трьох
      засад є те, що тест на рівність, що накладає метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space">, має підкорюватись тим самим обмеженням,
        що і контракт </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>:
      рефлективність, симетричність та транзитивність. Таким чином, виникає та
      сама особливість: немає способу розширити клас новим компонентом значення,
      зберігши при цьому контракт <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code>, за
      винятком, коли ви бажаєте відмовитись від переваг об'єктно-орієнтовної
      абстракції (Елемент 10). Також існує той самий обхідний шлях. Якщо ви
      бажаєте додати компонент значення до класу, що реалізує <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparable</code>, не
      розлирюйте його; напишіть непов'язаний клас, що містить примірник першого
      класу. Потім впровадьте метод “перегляду”, що повертає той примірник. Це
      вивільняє вас реалізувати будь-який метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">,
        що вам сподобається, для класу контейнера, при цьому даючи його клієнтам
        перегляд примірника класу контейнера як примірник прихованого класу, за
        такої потреби</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Фінальний
      параграф контракту <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code>,
      є доброю порадою, скоріше, ніж дійсною вимогою, та просто стверджує, що
      тест на рівність, наданий методом<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">,
        загалом повинен повертати той самий результат, що і метод</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Якщо підкорюватись цій засаді, впорядкування, накладене методом <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">,
        кажуть, буде <em>узгодженим з</em></span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><em>equals</em></code>.
      Якщо це порушити, кажуть, що впорядкування<span class="Apple-converted-space">
        <em>неузгоджене з</em></span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;"><em>equals</em></code>.
      Клас, метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> якого накладає порядок, неузгоджений з </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code><span
        class="Apple-converted-space">, все ще буде робити</span>, але сортовані
      колекції, що містять елементи цього класу, можуть не підкорятись головному
      контракту відповідних інтерфейсів колекцій (<code style="font-family: 'Courier New', monospace;">Collection</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Set</code>,
      або<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map</code>).
      Це через те, що головний контракт ціх інтерфейсів визначений в термінах
      методу<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">equals</code>,
      але сортовані колекції використовують перевірку на рівність, накладену <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space">, замість </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>. Не буде
      катастрофою, якщо таке станеться, але це треба мати на увазі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наприклад,
      розглянемо клас<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code>,
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> якого неузгоджений з</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">equals</code>.
      Якщо ви створите пустий примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">,
        та потім додасте </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">new BigDecimal("1.0")</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">new
        BigDecimal("1.00")</code>, множина буде містити два елементи, оскільки
      обидва примірники&nbsp;<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">BigDecimal</code><span class="Apple-converted-space">,
        додані до множини, нерівні, якщо порівнювати через метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code>. Однак якщо
      ви виконаєте ту ж саму процедуру з використанням <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">TreeSet</code><span class="Apple-converted-space">
        замість</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">HashSet</code>,
      множина буде містити тільки один елемент, оскільки два примірника<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code><span
        class="Apple-converted-space"> рівні, коли порівнюютсья з використанням
        методу </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code>.
      (Дивіться документацію<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code><span
        class="Apple-converted-space"> щодо подробиць</span>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Написання
      метода <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> подібне до написання метода </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>,
      але декілька ключових різниць. Оскільки інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparable</code><span class="Apple-converted-space">
        параметризований</span>, метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">
        статично типизований, так що вам не треба перевіряти тип або приводити
        аргументи через кастинг. Якщо аргумент невірного типу, виклик даже не
        скомпілюється. Якщо аргумент є </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>, виклик
      повинен викликати виключення <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">NullPointer</code>, і він
      так і зробить, як тільки метод спробує отримати доступ до членів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      методі <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> поля порівнюються для впорядкування,
        скоріше, ніж на рівність</span>. Щоб порівняти поля об'єктних посилань
      рекурсивно викликайте метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">compareTo</code>. Якщо
      поле не реалізовує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparable</code><span
        class="Apple-converted-space">, </span>або вам треба нестандартне
      впорядкування, замість цього використовуйте<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Comparator</code>.
      Ви можете написати свій власний компаратор, або використати існуючий, як
      це зроблене в цьому методі<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">
        для</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code><span
        class="Apple-converted-space"> в</span><span class="Apple-converted-space">
        Елементі 10</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Comparable одного поля з об'єктним посиланням</strong><br>
      public final class CaseInsensitiveString<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements
      Comparable&lt;CaseInsensitiveString&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public int compareTo(CaseInsensitiveString cis) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      String.CASE_INSENSITIVE_ORDER.compare(s, cis.s);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок випущено<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code><span
        class="Apple-converted-space"> реалізує</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Comparable&lt;CaseInsensitiveString&gt;</code>.
      Це означає, що <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code>reference
      може бути порівняним тільки з іншим посиланням&nbsp;<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">CaseInsensitiveString</code>.
      Це звичайний шаблон, якому треба слідувати при декларації класу, що
      реалізує<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Comparable</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Попередні
      редакції цієї книги рекомендували, щоб методи<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space">, порівнювали цілі примітивні поля з
        використанням операторів порівняння&nbsp;</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">&lt;</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">&gt;</code>,
      та поля з плаваючою крапкою з використанням методів<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Double.compare</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Float.compare</code>.
      В&nbsp; Java 7 були додані статичні методи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compare</code><span class="Apple-converted-space">
        для всіх боксованих класів примітивів </span>Java.<span class="Apple-converted-space">
        <strong>Використання відносних операторів </strong></span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>&lt;</strong></code><span
        class="Apple-converted-space"> <strong>та</strong></span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>&gt;</strong></code><span
        class="Apple-converted-space"> <strong>в методах </strong></span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>compareTo</strong></code><span
        class="Apple-converted-space"> </span><strong>кашлате та схильне до
        помилок, і більше не рекомендується.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      клас має декілька значущих полів, порядок, в якому ви порівнюєте їх, є
      критичним. Починайте з найбільш важливого поля, та потім ідіть донизу.
      Якщо порівняння закінчується будь-чим, крім нуля (що означає рівність), ви
      скінчуєте порівняння; просто повертайте результат. Якщо найбільш важливе
      поле дає рівність, порівнюйте наступне не-таке-важливе поле. Ось метод <code
        style="font-family: 'Courier New', monospace;">compareTo</code><span class="Apple-converted-space">
        для класу</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> в Елементі 11</span><span class="Apple-converted-space">,
        що демонструє цей прийом</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Comparable
        з багатьма примітивними полями</strong><br>
      public int compareTo(PhoneNumber pn) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int result = Short.compare(areaCode, pn.areaCode);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (result == 0)&nbsp;&nbsp;{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result =
      Short.compare(prefix, pn.prefix);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result
      = Short.compare(lineNum, pn.lineNum);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_70"></span>В Java 8 інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparator</code><span class="Apple-converted-space">
        був витіснений набором <em>методів побудови компаратора</em></span>, що
      дозволяє вільне конструювання компараторів. Ці компаратори потім можуть
      бути використані для реалізації методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code>, як того
      вимагає інтерфейс <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparable</code>.
      Багато програмістів обирають стислість цього підходу, хоче це іде з
      помірною ціною продуктивності: сортування масивів примірників<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>
      близько 10% повільніший на моїй машині. Коли використовувати цей підхід,
      розгляньте можливість використання можливості <em>статичного імпорту </em>Java,
      так що ви зможете посилатись на статичний метод конструктора компаратора
      через їх прості імена, заради ясності та краткості. Ось як <span class="Apple-converted-space">виглядатиме
        </span>метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> для </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        при цьому підході</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Comparable з методами конструкторів компараторів</strong><br>
      private static final Comparator&lt;PhoneNumber&gt; COMPARATOR =<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comparingInt((PhoneNumber
      pn) -&gt; pn.areaCode)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.thenComparingInt(pn
      -&gt; pn.prefix)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.thenComparingInt(pn
      -&gt; pn.lineNum);<br>
      <br>
      public int compareTo(PhoneNumber pn) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return COMPARATOR.compare(this, pn);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      реалізаця будує компаратор під час ініціалізації класа, використовуючи два
      методи конструкції компаратора. Перша це <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">comparingInt</code>. Це
      статичний метод, що приймає <em>функцію екстрактор поля, </em>що
      відображує посилання на об'єкт на ключ типу<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space">, та повертає компаратор, що впорядковує
        примірники згідно цього ключа</span>. В попередньому прикладі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">comparingInt</code><span
        class="Apple-converted-space"> приймає</span><span class="Apple-converted-space">
      </span><em>лямбду</em><span class="Apple-converted-space"> </span>(), що
      виділяє код місцевості з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">,
        та повертає </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparator&lt;PhoneNumber&gt;</code><span
        class="Apple-converted-space">, що впорядковує номери телефонів згідно
        кодам місцевості</span>. Зауважте, що лямбда явно вказує тип свого
      вхідного параметру (<code style="font-family: 'Courier New', monospace;">PhoneNumber
        pn</code>). В цій ситуації, як з'ясувалось, вивід типів Java не досить
      потужний, щоб самотужки вичислити тип, так що ми змушені допомагати йому,
      щоб програма могла скомпілюватись.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      два номери телефонів мають той самий код місцевості, нам треба далі
      уточнити порівняння, і це саме те, що робить другий метод конструктора
      компаратоів,&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">thenComparingInt</code>.
      Це метод примірника на <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Comparator</code><span
        class="Apple-converted-space">, що приймає функцію екстрактора ключ</span><span
        class="Apple-converted-space">а </span><code style="font-family: 'Courier New', monospace;">int</code>,
      та повертає компаратор, що спочатку застосовує оригінальний компаратор, та
      потім застосовує екстрагований ключ для подальшого уточнення. Ви можете
      накопичити стільки викликів <code style="font-family: 'Courier New', monospace;">thenComparingInt</code><span
        class="Apple-converted-space">, скільки побажаєте</span>, отримавши в
      результаті <em>лексографічне впорядкування</em>. В прикладі вище ми
      наклали два виклики<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">thenComparingInt</code>,
      де другий ключ є префікс, а третій ключ є лінійний номер. Зауважте, що ми
      <em>не мали вказувати </em>тип параметру ключа для функцій, переданих до
      викликів<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">thenComparingInt</code>:
      вивід типів&nbsp; Java був досить розумним, щоб з'ясувати це самостійно.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_71"></span>Клас<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Comparator</code><span
        class="Apple-converted-space"> має повний комплект методів конструкції</span>.
      Існують аналоги до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">comparingInt</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">thenComparingInt</code><span
        class="Apple-converted-space"> </span>для примітивних типів <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">long</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">double</code>.
      Версії<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space"> </span>можуть також бути використані для
      вужчих цілих типів, як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">short</code>,
      як в нашому прикладі<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code>.
      Версії<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">double</code><span
        class="Apple-converted-space"> також можуть використовуватись для</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">float</code>.
      Це надає покриття всіх примітивних числових типів Java.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Також
      є методи конструкції компаратоів для типів об'єктних посилань. Статичний
      метод на ім'я <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">comparing</code>,
      що має два перевантаження. Одне приймає екстрактор ключа, та використовує
      природне порівняння за ключем. Другий приймає обоє, екстрактор ключа та
      компаратор, що буде застосований для екстрагованих ключів. Є три
      перевантаження методів примірника з назвою<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">thenComparing</code>.
      Одне перевантаження приймає тільки компаратор, та використовує його для
      провадження вторинного впорядкування. Друге перевантаження приймає тільки
      екстрактор ключа, та використовує природней порівняння в якості вторинного
      впорядкування. Останнє перевантаження приймає обоє, екстрактор ключа та
      компаратор, що буде застосований до ціх ключів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Можливо
      ви могли бачити методи <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">compareTo</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">compare</code><span
        class="Apple-converted-space">, що покладаються на факт, що різниця між
        двома значеннями є негативною, якщо перше значення менше за друге, нулю
        якщо вони рівні, або позитивне, якщо перше значення більше. Ось приклад</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//&nbsp;</strong><strong><strong>ПОЛОМАН</strong>ИЙ
        компаратор на базі різниць - порушує транзитивність!</strong><br>
      static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public int compare(Object o1, Object o2) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return o1.hashCode() -
      o2.hashCode();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      };</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      використовуйте цей прийом. Це пов'язане з загрозою цілого переповнення, та
      арифметичними артифактами плаваючої крапки IEEE 754 [<a href="ref.xhtml#rJLS"
        style="text-decoration: none;">JLS 15.20.1, 15.21.1</a>]. Більше того,
      отримані методи навряд чи будуть значно швидші, ніж ті, що описані в цьому
      елементі. Використовуйте або статичний метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compare</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Компаратор, базований на статичному методі compare</strong><br>
      static Comparator&lt;Object&gt; hashCodeOrder = new Comparator&lt;&gt;() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public int compare(Object o1, Object o2) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      Integer.compare(o1.hashCode(), o2.hashCode());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      };</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">або
      на методі конструкції компаратора:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Компаратор, базований на методі конструкції Comparator</strong><br>
      static Comparator&lt;Object&gt; hashCodeOrder =<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Comparator.comparingInt(o
      -&gt; o.hashCode());</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_72"></span>Підсумовуючи, кожного разу,
      коли ви реалізуєте класс-значення, що має осмислене впорядкування, вам
      слідує реалізовати в класі інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparable</code>, так що
      його примірники&nbsp; можуть бути легко впорядковані, знайдені, та
      використані в базованих на порівнянні колекціях. Коли порівнюєте значення
      полів в реалізаціях методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">compareTo</code>,
      уникайте використання операторів <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">&lt;</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">&gt;</code>.
      Замість цього використовуйте методи порівняння в боксованих класах для
      примітивів, або методи конструювання компараторів в інтерфейсі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Comparator</code>.</p>
    <p></p>
    <p> </p>
    <h2 class="h2" id="ch4" style="font-size: 29px; margin-top: 30px; margin-bottom: 30px; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Глава
      4. Класи та інтерфейси</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Класи
      та інтерфейси лежать в серці мови програмування Java. Вони є базовими
      одиницями абстракції. Мова провадить багато потужних елементів, які ви
      можете використовувати для розробки класів та інтерфейсів. Ця глава
      містить направляючі, щоб допомогти найкраще використовувати ці елементи,
      так щоб ваші класи та інтерфейси були корисними, надійними та гнучкими.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемент<strong>
        15: Мінімізуйте доступність до класів та членів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Єдиний
      найбільш важливий фактор, що відрізняє гарно розроблений компонет від
      погано розробленого, є той ступінь, з яким компонент приховує внутрішні
      дані та інші детали від інших компонент. Гарно розроблений компонент
      приховує всі свої деталі реалізації, ясно розділяючі свій API від
      реалізації. Потім компоненти комунікують тільки через свої API, та байдужі
      до внутрішньої роботи один одного. Ця концепція, відома як <em>приховування
        інформації </em>або <em>інкапсуляція</em>, є фундаментальною мережею
      розробки програмного забезпечення [<a href="ref.xhtml#rParnas72" style="text-decoration: none;">Parnas72</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Приховування
      інформації важливе з багатьох причин, більшість з яких походять з факту,
      що це <em>відокремлює </em>компоненти, що складають систему, дозволяючи
      їм бути розробленими, протестованими, оптимізованими, використаними,
      зрозумілими та модифікованими окремо. Це пришвидшує розробку систем,
      оскільки компоненти можуть розроблятись паралельно. Це спрощує безлад
      підтримки, бо компоннети можуть бути зрозумілі більш швидко та налаштовані
      або замінені з меншим страхом зашкодити іншим компонентам. Хоча
      приховування інформації саме по собі не спричиняє гарної продуктивності,
      воно дозволяє ефективне налаштування продуктивності: як тільки система
      завершена, та профілювання визначило, які компоненти призводять до проблем
      з продуктивністю (<a href="ch9.xhtml#lev67" style="text-decoration: none;">Елемент
        67</a>), ці компоненти можуть бути оптимізовані, не впливаючи на
      коректність інших. Приховування інформації збільшує повторне використання,
      бо компоненти, що не є тісно пов'язані, часто стають в нагоді в інших
      контекстах, за межами того, для якого вони були розроблені. Нарешті,
      приховування інформації зменшує ризик побудови великих систем, оскільки
      індивідуальні компоненти можуть забезпечити успіх, навіть якщо система ні.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Java
      має багато можливостей допомогти в приховуванні інформації. Механізми <em>контролю
        доступу</em> [JLS, 6.6] вказують <em>доступність </em>др класів,
      інтерфейсів та членів. Доступність сутності визначається розташуванням
      декларації, та в разі присутності модифікаторами доступу декларації (<code
        style="font-family: 'Courier New', monospace;">private</code>, <code style="font-family: 'Courier New', monospace;">protected</code>
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">public</code>).
      Відповідне використання ціх модифікаторів є основою для приховування
      інформації.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Правило
      велткого пальця просте:<span class="Apple-converted-space"> </span><strong>робіть
        кожний клас або член таким недоступним, як це можливо.</strong><span class="Apple-converted-space">
        Іншими словами, використовуйте найнижчий можливий рівень доступу,
        сумісний з функціонуванням програми, що ви пишете</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      високорівневих (не вкладених) класів та інтерфейсів є тільки два можливі
      рівня доступу:<span class="Apple-converted-space"> </span><em>приватний-до-пакунку
        </em>та <em>публічний</em>. Якщо ви декларуєте високорівневий клас або
      інтерфейс з модифікатором <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">public</code>, він буде
      публічним; інакше він буде приватний-до-пакунку. Якщо високорівневий клас
      або інтерфейс може бути зроблений приватним-до-пакунку, слід зробити його
      таким. Роблячи його приватним-до-пакунку, ви робите його частиною
      реалізації, скоріше ніж імпортованого API, та ви можете можифікувати його,
      замінити його, або видалити його в наступному релізі, без страху нашкодити
      існуючим клієнтам. Якщо ви зробите його публічним, ви обіцяєте
      підтримувати його навіки, щоб забезпечити сумісність.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      приватний-до-пакунка високорівневий клас або інтерфейс використовується
      тільки одним класом, розгляньте зробити високорівневий клас приватним
      вкладеним класом того класу, що використовує його (Елемент 24). Це зменушє
      доступність з усіх класів в пакунку до одного класу, що використовує його.
      Але набагато більш важливо обмежити доступ до щедрого публічного класу,
      ніж до приватного-до-пакунку високорівневого класу: публічний клас є
      частиною API пакунку, коли приватний-до-пакунку високорівневий клас завжди
      залишиться частиною реалізації.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      членів (полів, методів, вкладених класів та вкладених інтерфейсів), існує
      чотири рівня доступу, перелічених тут в порядку збільшення доступу:</p>
    <p class="bullb1" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><strong>private</strong> —
      член доступний тільки з високорівневого класу, де він декларований.</p>
    <p class="bullb1" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><strong>package-private</strong>
      — член доступний з будь-якого класа в пакунку, де він декларований.
      Технічно відомий як <em>доступ по замовчанню</em>, це рівень доступу,
      який ви отримаєте, якщо модифікатор доступу не вказано (за винятком членів
      інтерфейсу, що є публічними по замовчанню).</p>
    <p class="bullb1" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><strong>protected</strong> —
      член доступний з субкласів класу, де він декларований (привід для
      декількох обмежень [JLS, 6.6.2]), та з любого класу в пакунку, де він
      визначений.</p>
    <p class="bullb1" style="margin-top: 0px; margin-bottom: 6.666667px; margin-left: 20px; text-indent: -10.666667px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">•<span
        class="Apple-converted-space">&nbsp;</span><strong>public</strong> —
      член доступний з відусіль.</p>
    <p class="indentt" style="margin-top: 13.333334px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_75"></span>Після уважної розробки
      публічного API вашого класу, ваш рефлекс має зробити всі інші класи
      приватними. Тільки якщо інший клас в тому самому пакунку дійсно потребує
      доступу, має спонукати модифікатор <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">private</code>, що
      зробить його приватним до пакунку. Якщо ви ви винайдете, що робите це
      зачасто, ви маєте переглянути дизайн вашої системи, щоб побачити, чи інша
      декомпозиція може дати класи, що краще відділені один від одного. При
      цьому всьому, обоє, приватні та приватні до пакунку члени є частиною
      реалізації класу, та зазвичай не впливають на експортований API. Ці поля,
      однак, дати “витік” до експортованого API, якщо клас реалізує <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Serializable</code><span
        class="Apple-converted-space">&nbsp;</span>(Елементи 86 та 87).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      членів публічних класів велике збільшення доступності відбувається, коли
      рівень доступу стає з пакунок-приватного до захищеного. Захищений член є
      експортованого класом API, та має підтримуватись довічно. Також, захищений
      член експортованого класу представляє публічне підтвердження деталей
      реалізації (Елемент 19). Потреба в захищених членах повинна бути відносно
      рідкою.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      ключове правило, що обмежує вашу здатність для зменшеня доступності
      методів. Якщо метод перекриває метод суперкласа, він не може мати більш
      обмеженний рівень доступу в субкласі, ніж в суперкласі [JLS, 8.4.8.3].
      Треба переконатись, що примірник субкласу є корисним будь-де, де корисний
      суперклас (<em>правило підстановки Ліскова</em>, дивіться Елемент 15).
      Якщо ви порушите це привило, компілятор буде генерувати повідомлення про
      помилку при компіляції субкласу. Спеціальний випадок цього правила в тому,
      що якщо клас реалізує інтерфейс, всі методи класу, що є в інтерфейсі,
      мають бути декларовані як публічні в класі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      спростити тестування вашого коду, ви можете піддатись спокусі зробити
      клас, інтерфейс або член більш доступним, ніж було б потрібним в іншому
      випадку. Це добре до певної міри. Допустимо зробити приватний член
      публічного класу приватним-до-пакунку, щоб протестувати його, але не
      допустимо піднести доступність якось вище. Іншими словами, недопустимо
      робити клас, інтерфейс або член частиною експортованого пакунком API, щоб
      спростити тестування. На щастя, це більше непотрібне, оскільки тести можна
      зробити для виконання як частину тестованого пакунку, і, таким чином,
      давши доступ до приватних-до-пакунку елементів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Поля
        примірників публічного класу рідко повинні бути публічними</strong><span
        class="Apple-converted-space"> </span>(Елемент 16). Якщо поле
      примірника не є фінальним, або є посиланням на змінний об'єкт, тоді, якщо
      зробити його публічним, ви втрачаєте можливість обмежити значення, що
      можуть зберігатись в полі. Це означає, що ви втрачаєте можливість
      примусити виконуватись інваріантам, задіяним до поля. Також, ви страчаєте
      можливість зробити будь-яку дію, коли поле буде модифіковане, так що <span
        class="Apple-converted-space"></span><strong>класи з публічними змінними
        полями загалом не безпечні до потоків. </strong><span class="Apple-converted-space"></span>Навіть
      якщо поле є фінальним, та посилається на незмінний об'єкт, роблячи його
      публічним ви втрачаєте гнучкість перейти на нову внутрішню репрезентацію
      даних, де цього поля не існує.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Та
      сама порада стосується і статичних полів, з одним виключенням. Ви можете
      показувати константи через публічні статичні фінальні поля, якщо ці поля
      формують інтегровану частину абстракції, що провадить клас. За
      домовленостю такі поля мають імена, що складаються з великих літер, зі
      словами, розділеними підкресленнями (Елемент 68). Є критичним, щоб ці поля
      містили або примітивні значення, або посилання на незмінні об'єкти
      (Елемент 17). Фінальне поле, що містить посилання на змінний об'єкт, має
      всі недоліки нефінального поля. Хоча посилання не може бути змінене,
      об'єкт, на яке воно посилається, може бути змінений — з руйнівними
      наслідками.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що масив ненульової довжини завжди змінний, так що <strong>буде помилкою
        для класа мати публічний статичний фінальний масив в якості поля, або
        аксессор, що повертатиме таке поле. </strong>Якщо клас має таке поле
      або аксессор, клієнти будуть в змозі модифікувати вміст массива. Це часта
      причина дирок в безпеці:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Потенційна
        дірка в безпеці!</strong><br>
      public static final Thing[] VALUES = { ... };</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Начуівйтесь
      щодо факту, що деякі IDE генерують аксессори, що повертають посилання
      наприватні поля масивів, що призводить саме до цієї проблеми. Є два шляхи
      полагодити цю проблему. Ви можете зробити публічний масив приватним, та
      додати публічний незмінний список:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">private
      static final Thing[] PRIVATE_VALUES = { ... };<br>
      public static final List&lt;Thing&gt; VALUES =<br>
&nbsp;&nbsp;&nbsp;Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      альтернатива, ви можете зробити масив приватним, та додати публічний
      метод, що повертає копію приватного масива:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">private
      static final Thing[] PRIVATE_VALUES = { ... };<br>
      public static final Thing[] values() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return PRIVATE_VALUES.clone();<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      обрати між двома аьтернативами, подумайте про те, що клієнт вірогідніше
      буде робити з результатом. Який повернутий тип буде більш зручним? Якій
      надаватиме більшої продуктивності?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      щодо Java 9, існують два додаткові, неявні рівні доступу, додані як
      частина <em>системи модулів</em>. Система модулів є групування пакунків,
      подібно як пакунки згруповують класи. Модуль може явно експортувати деякі
      з своїх пакунків через <em>декларації експорту </em>в своїй <em>декларації
        модуля</em><span class="Apple-converted-space"> </span>(що за
      домовленостю міститься в файлі на ім'я <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">module-info.java</code>).
      Публічні та захищені члени неімпортованих пакунків в модулі недоступні за
      межами модуля; в модулі на доступність не впливають декларації експорту.
      Використання системи модулів дозволяє вам поділяти класи між пакунками в
      модулі без того, що робити їх видимими для всього світу. Публічні та
      захищені члени публічних класів в неекспортованих пакунках отримують
      підвищення до двох неявних методів доступу, що є нутри-модулярними
      аналогами нормальних публічних та захищених рівнів. Потреба в цьому
      різновиді поділення відносно мала, та її часто можна уникнути через іншу
      аранжировку класів в ваших пакунках.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">На
      відміну від чотирьох головних рівнів доступу, два базованих на модулях
      рівня є здебільшо рекомендаціями. Якщо ви покладете JAR файл модуля на
      classpath вашого застосування, замість його шляху модуля. пакунки в модулі
      повернуться до своєї не-модульної поведінки: всі публічні та захищені
      члени публічних методів класів мають свою звичайну доступність,
      безвідносно, чи пакунок експортований модулем [Reinhold, 1.2]. Одне місце,
      де нововведені рівні доступу дійсно примушені, та сам JDK: неекспортовані
      пакунки в бібліотеках Java насправді недоступні за межами модулів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Модулі
      наклали захист доступу тільки як рекомендацію обмеженого ужитку до
      типового Java програміста, що досить поміркована за натурою; щоб отримати
      вигоди з неї, ви маєте згупувати ваші пакунки в модулі, зробити всі їх
      залежності явними в декларації модулів, перестроїти ваше дерево файлів, та
      виконати певні дії для надання любого доступу для не-модуляризованих
      пакунків всередині ваших модулів [Reinhold, 3]. Ще зарано казати, чи
      модулі отримають широке використання за межами самого JDK. В оглядному
      майбутньому, здається, їх краще уникати, якщо ви не маєте достатніх
      потреб.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      підсумувати, вам треба зменшити доступність елементів програми так сильно,
      як це можливо (в резонних межах). Після уважної розробки мінімального
      публічного API, вам слудє позбавити любі випадкові класи, інтерфейси або
      члени від того, щоб вони ставали частиною&nbsp; API. За винятком публічних
      статичних фінальних полів, що прислуговуються в якості констант, публічні
      класи не повинні мати публічних полів. Переконайтесь, що об'єкти, на які
      посилаються публічні статичні фінальні поля є незмінними.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемнт<span
        epub:type="pagebreak" id="page_78"></span><strong> 16: В публічних
        класах використовуйте методи аксессорів, замість публічних полів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Згодом
      ви буде спокушатись написати написати вироджений клас, що прислуговується
      єдиній цілі, а саме групуванню полів примірника:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Вироджений
        клас, як цей, не повинен бути публічним!</strong><br>
      class Point {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public double x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public double y;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскільки
      поля цього класу доступні напряму, цей клас не надає переваг <em>інкапсуляції</em><span
        class="Apple-converted-space"> </span>(Елемент 15). Ви не можете
      змінити репрезентацію без зміни API, ви не можете змусити виконуватись
      інваріантам, та ви не можете виконати зовнішню дію при доступі до поля.
      Програмісти, що суворо притримуються лінії о'бєктної орієнтації відчувають
      такі класи як анафему, та вони повинні завжди бути замінені класами з
      приватними полями, та публічними <em>методами-аксессорами (геттерами)</em>,
      та для змінних класів <em>мьютейторами (сеттерами)</em>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Енкапсуляція
        даних через методи аксессорів та мьютейторів</strong><br>
      class Point {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private double x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private double y;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Point(double x, double y) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.x = x;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.y = y;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public double getX() { return x; }</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public double getY() { return y; }</strong><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public void setX(double x) { this.x = x; }</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public void setY(double y) { this.y = y; }</strong><br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Звісно,
      ці прихильники дотримання лінії праві, коли йдеться про публічні класи:<span
        class="Apple-converted-space"> </span><strong>якщо клас доступний за
        межами свого пакунку, провадьте методи аксессорів </strong>для
      збереження гнучкості щодо зміни внутрішньої репрезентації класа. Якщо
      публічний клас показує поля даних, всі надії на зміну репрезентації
      втрачені, оскільки код клієнта може розійтись широким колом. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Однак,<span
        class="Apple-converted-space"> </span><strong>якщо клас є
        приватним-до-пакунку або приватним вкладеним класом, немає нічого
        заздалегідь поганого в експортуванні його полів даних</strong>,
      вважаючи, що вони роблять адекватну роботу щодо опису абстракцій в класі.
      Цей підхід генерує менше візуального безладу, ніж методи аксессора, як в
      визначенні класу, так і в клієнтському коді, що використовує його. В той
      час, як код клієнта прив'язаний до внутрішньої репрезентації класу, цей
      код обмежений до пакунку, що містить клас. Якщо зміна в репрезентації є
      бажаною, ви можете зробити зміну без торкання жодного класу за межами
      пакунку. В випадку приватних вкладених класів, область змін також обмежена
      оточуючим класом. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Декілька
      класів в бібліотеках платформи Java порушують цю пораду, що публічні класи
      не повинні показувать поля напряму. Яскраві приклади включають класи<span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        Point</code><span class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Dimension</code><span
        class="Apple-converted-space"> в пакунку</span> <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">java.awt</code>. Скоріше,
      ніж бути прикладом для наслідування, ці класи мають розглядатись як
      байки-застереження. Як описано в Елементі 67, рішення показувати внутрощі
      класу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Dimension</code><span
        class="Apple-converted-space"> призвело до серйозної проблеми
        продуктивності, що ще з нами і дотепер</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      це ніколи не гарна ідея для публічних класів показувати свої поля напряму,
      це менш шкідливо, коли поля незмінні. Ви не можете змінити репрезентацію
      такого класу без зміни його API, та ви не можете зробити зовнішні дії при
      читанні поля, але ви можете встановити інваріанти. Наприклад, цей клас
      гарантує, що кожний примірник представляє валідний час:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Публічний клас з показаними незмінними полями - під питанням</strong><br>
      public final class Time {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int
      HOURS_PER_DAY&nbsp;&nbsp;&nbsp;&nbsp;= 24;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int MINUTES_PER_HOUR = 60;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public final int hour;</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public final int minute;</strong><br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Time(int hour, int minute) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hour &lt; 0 || hour
      &gt;= HOURS_PER_DAY)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new
      IllegalArgumentException("Hour: " + hour);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (minute &lt; 0 ||
      minute &gt;= MINUTES_PER_HOUR)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new
      IllegalArgumentException("Min: " + minute);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.hour = hour;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.minute = minute;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок випущено<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, публічні класи ніколи не мають показувати свої змінні поля. Це
      менш шкідливо, але все ще під питанням, чи слід їм показувати незмінні
      поля. Однак часом бажано для пакунок-приватних або приватних вкладених
      класів показувати свої поля, чи змінні чи незмінні.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_80"></span><strong>Елемент 17:
        Мінімізуйте мінлівість</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Незмінний
      клас це просто такий клас, чиї примірники не можуть бути змінені Вся
      інформація, що міститься в кожному примірнику, фіксована на весь час життя
      об'єкту, так що жодних змін не буде спостерігатись. Бібліотеки платформи
      Java містять багато незмінних класів, включаючи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code>, боксовані
      примітивні класи, та <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> і</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code>.
      Для цього є багато гарних причин: незмінні класи простіше розробляти,
      реалізувати, та використовувати, ніж змінні класи. Вони менше схильні до
      помилок, та більш безпечні.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      зробити клас незмінним, слідуйте п'ятьом правилам:</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">1.<span
        class="Apple-converted-space"> </span><strong>Не провадьте методів, що
        змінюють стан об'єкта</strong><span class="Apple-converted-space"> </span>(відомі
      як <em>мьютейтори</em>).</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">2.<span
        class="Apple-converted-space"> </span><strong>Переконайтесь, що клас не
        може бути розширений.</strong><span class="Apple-converted-space"> </span>Це
      запобігає неуважним або зловмисним субкласам від компромації незмінної
      поведінки класу, через поведінку, якби стан об'єкту змінився. Запобігання
      субкласам загалом досягається через помітку класу як фінального, але є
      альтернатива, що ми дослідимо пізніше.</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">3.<span
        class="Apple-converted-space"> </span><strong>Зробіть всі поля
        фінальними.</strong><span class="Apple-converted-space"> </span>Це ясно
      виражає ваш намір в манері, що примушена системою. Також треба забезпечити
      коректну поведінку, якщо посилання на новостворений примірник передається
      з одного потоку до іншого, без синхронізації, як проговорено в <em>моделі
        пам'яті</em><em></em><span class="Apple-converted-space"> </span>[JLS,
      17.5; Goetz06, 16].</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">4.<span
        class="Apple-converted-space"> </span><strong>Зробіть всі поля
        приватними.</strong><span class="Apple-converted-space"> Це завадить
        клієнтам отримати доступ до змінних об'єктів, на які посилаються поля,
        та від прямої модифікації ціх об'єктів</span>. Хоча це технічно можливо
      для незмінних класів мати публічні фінальні поля з примітивними
      значеннями, або з посиланнями на незмінні об'єкти, це не рекомендовано,
      оскільки заважатиме зміні внутрішньої репрезентації в подальших релізах
      (Елементи 15 та 16).</p>
    <p class="numberb" style="margin-top: 0px; margin-bottom: 13.333334px; margin-left: 33.333336px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">5.<span
        class="Apple-converted-space"> </span><strong>Забезпечте ексклюзивний
        доступ до любих змінних компонент.</strong><span class="Apple-converted-space">
        Якщо ваш клас має любі поля, що посилаються на змінні об'єкти,
        переконайтесь, що клієнти цього класу не можуть отримати посилання на ці
        об'єкти</span>. Ніколи не ініціалізуйте такі поля посиланням на об'єкт,
      запроваджений клієнтом, або не повертайте поле з аксессора. робіть <em>захисні
        копії </em><span class="Apple-converted-space"></span>(<a href="ch8.xhtml#lev50"
        style="text-decoration: none;">Елемент 50</a>) в конструкторах,
      аксесорах та методах <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">readObject</code>
      (<a href="ch12.xhtml#lev88" style="text-decoration: none;">Елемент 88</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      з прикладів об'єктів в попередніх елементах є незмінними. Один з таких
      класів є <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> </span>в<span class="Apple-converted-space">
      </span><a href="ch3.xhtml#lev11" style="text-decoration: none;">Елементі
        11</a>, що має аксесори до кожного атрибуту, але не має відповідних
      мутаторів. Ось дещо більш <em>комплексний</em> приклад:</p>
    <span epub:type="pagebreak" id="page_81" style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"></span><span
      style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        незмінний клас комплексного числа</strong><br>
      public<span class="Apple-converted-space">&nbsp;</span><strong>final</strong>&nbsp;&nbsp;class
      Complex {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>private final</strong>&nbsp;&nbsp;double
      re;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>private final</strong>&nbsp;&nbsp;double
      im;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Complex(double re, double im) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.re = re;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.im = im;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public double
      realPart()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return re; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public double imaginaryPart() { return im; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Complex plus(Complex c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Complex(re +
      c.re, im + c.im);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Complex minus(Complex c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Complex(re -
      c.re, im - c.im);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Complex times(Complex c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Complex(re *
      c.re - im * c.im,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      re * c.im + im * c.re);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Complex dividedBy(Complex c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double tmp = c.re * c.re +
      c.im * c.im;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Complex((re *
      c.re + im * c.im) / tmp,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      (im * c.re - re * c.im) / tmp);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (o == this)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!(o instanceof Complex))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Complex c = (Complex) o;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // шукайте деінде чому ми
      використовуємо compare замість of ==<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Double.compare(c.re, re) == 0<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;&amp;
      Double.compare(c.im, im) == 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public int hashCode() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 31 *
      Double.hashCode(re) + Double.hashCode(im);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public String toString() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "(" + re + " + " +
      im + "i)";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      приклад представляє <span class="Apple-converted-space"></span><em>комплексне
        число</em><span class="Apple-converted-space"> </span>(число, що має
      дійну і уявну частину). На додаток до стандартних методів <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>, він
      провадить аксессори для дійсної і уявної частини, та провадить чотири
      основн арифметичні операції: додавання, віднімання, множення та ділення.
      Зауважте, як арифметичні операції створюють та повертають новий примірник
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Complex,
        замість того, що модифікувати цей примірник. Цей шаблон відомий як </code><em>функціональний
        </em><span class="Apple-converted-space"></span>підхід, бо методи
      повертають результат застосування функції на свої операнди, без їх
      модифікації. На відміну від <span class="Apple-converted-space"></span><em>процедурно-імперативного
        підходу</em>, коли методи застосовують процедуру до своїх операндів, що
      призводить до їх зміни. Зауважте, що метод іменує приписи (такі, як <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">plus</code>),
      замість ніж дієслова (такі, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">add</code>). Це наголошує
      факт, що методи не змінюютсь значення об'єктів. Класи The<code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code><span
        class="Apple-converted-space"> <em>не підкорюються </em>цій
        домовленості іменування, що призводить до багатьох помилок використання</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Функціональний
      підхід може виглядати неприродним, якщо ви не обізнаний з ним, але це
      дозволяє незмінність, що має багато переваг. <strong>Незмінні об'єкти
        прості.</strong><span class="Apple-converted-space"> Незмінні об'єкти
        мають лише один стан, стан, в якому вони створені. Якщо ви гарантуєте,
        що всі конструктори встановлюють інваріанти класу, тоді це гарантує, що
        інваріанти будуть виконуватись весь час, без додаткових зусиль з вашого
        боку, або з боку програміста, що використовує цей клас. Змінні об'єкти,
        з іншого боку, можуть мати довільно складний простір станів. Якщо
        документація не провадить точного опису переходів між станами, що
        виконуютсья методвами мутаторів, може бути складним, або навіть
        неможливим, надійно використвувати змінний клас</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Незмінні
        об'єкти природно потік-безпечні, вони не потребують синхронизації.</strong><span
        class="Apple-converted-space"> Вони не можуть бути пошкоджені багатьма
        потоками, що одночасно отримують доступ до них</span>. Це з великим
      відривом найпростіший спосіб досягти потокової безпеки. Позаяк потік
      навіть не може спостерігати вплив іншого потоку на незмінний об'єкт, <span
        class="Apple-converted-space"></span><strong>незмінні об'єкти можуть
        бути легко поділені. </strong><span class="Apple-converted-space"></span>Незмінні
      класи таким чином повинні заохочувати клієнтів повторно використовувати
      існуючі примірникі, наскільки це можливо. Один простий спосіб зробити це,
      є запровадити публічні фінальні статичні константи для поширених змінних.
      Наприклад, клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Complex</code><span
        class="Apple-converted-space"> може провадити такі константи</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static final Complex ZERO = new Complex(0, 0);<br>
      public static final Complex ONE&nbsp;&nbsp;= new Complex(1, 0);<br>
      public static final Complex I&nbsp;&nbsp;&nbsp;&nbsp;= new Complex(0, 1);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      підхід можна просунути на крок далі. Незмінний клас може провадити
      статичні фабрики (<a href="ch2.xhtml#lev1" style="text-decoration: none;">Елемент
        1</a>), що кешує часто запрошувані примірники, щоб уникнути створення
      нових примірників, коли можна використати існуючий. Всі класи боксування
      примітивів роблять це, так само як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code>.
      Використання таких статичних фабрик призводить до того, що клієнти будуть
      поділяти примірники, замість створювати нові, зменшуючи розмір пам'яті та
      цілу збирання сміття. Вибір статичних фабрик на місці публічних
      конструкторів при розробці нового класу дає вам гнучкість для подальшого
      додавання кешу, без модифікації клієнтів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наслідок
      з факту, що незмінні об'єкти можуть вільно бути поділені, в тому, що ви
      ніколи не маєте робити <em>захисні копії </em>для них (<a href="ch8.xhtml#lev50"
        style="text-decoration: none;">Елемент 50</a>). Фактично, ви ніколи не
      маєте робити жодних копій, оскільки копії завжди будуть еквівалентні до
      оригіналів. Таким чином, вам не треба, та вам не слідує&nbsp; провадити
      метод клонування та <em>копіюючий конструктор </em>(<a href="ch3.xhtml#lev13"
        style="text-decoration: none;">Елемент 13</a>) для незмінних класів. Це
      не було гарно зрозуміло в ранішні дні платформи Java, так що клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        має копіюючий конструктор, але він рідко, якщо взагалі, використовувався</span>
      (<a href="ch2.xhtml#lev6" style="text-decoration: none;">Елемент 6</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Ви
        не тільки можете поділяти незмінні о'єкти, але ви також можете ділитись
        їх внутрощами.</strong><span class="Apple-converted-space"> Наприклад,
        клас </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> використовує прив'язку до знаку всередині
        реалізації</span>. Знак представлений як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">int</code>, та значення
      представлене як масив <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code>.
      Метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">negate</code><span
        class="Apple-converted-space"> продукує новий </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code><span class="Apple-converted-space">
        з тим самим значенням, та протилежним знаком. Не треба копіювати масив,
        навіть якщо він змінний</span>; новостворений <code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> вказує на той самий масив цілих, що і
        оригінал</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Незмінні
        об'єкти складають чудові будівельні блоки для інших об'єктів,</strong><span
        class="Apple-converted-space"> чи змінних, чи незмінних</span>. Значно
      простіше підтримувати інваріанти складних об'єктів, якщо ви знаєте, що
      об'єкти компонентів не зміняться одно разу. Окремий випадок цього принципу
      в тому, що незмінні об'єкти створюють чудові ключі для елементів мап та
      множин: вам не треба хвилюватись щодо зніми іх значень, коли об'єкт вже в
      мапі або множині, що зруйнує інваріанти мапи або множини.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Незмінні
        об'єкти провадять атомарність збою задурно</strong><span class="Apple-converted-space">
      </span>(<a href="ch10.xhtml#lev76" style="text-decoration: none;">Елемент
        76</a>). Їх стан ніколи не змінюється, так що немає можливості
      тимчасовою неузгодженості.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Головний
        недолік незмінних класів в тому, що вони потребують окремого об'єкта для
        кожного окремого значення.</strong><span class="Apple-converted-space">
        Створення цього об'єкту може бути коштовним, особливо, коли воні великі.
        Наприклад, уявімо, що ви маєте міліон-бітний </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger, та ви бажаєте
        змінити молодший біт</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">BigInteger
      moby = ...;<br>
      moby = moby.flipBit(0);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Метод<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">flipBit</code><span
        class="Apple-converted-space"> створює новий примірник </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code>, також
      довжиною мільйон біт, що відрізняється від оригіналу тільки на один біт.
      Операція потребує часу та простору, пропорційно до розміру <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code>. Для
      контраксту існує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.util.BitSet</code>.
      Як і<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigInteger</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">BitSet</code><span
        class="Apple-converted-space"> представляє довільно довні послідовності
        біт, але на відміну від</span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">BitSet</code><span class="Apple-converted-space">
        є змінним</span>. Клас<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">BitSet</code><span class="Apple-converted-space">
        провадить метод, що дозволяє вам змінити вам стан одного біту
        мільйон-бітного примірника за сталий час</span>:</p>
    <p class="codep" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 22.666668px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">BitSet
      moby = ...;<br>
      moby.flip(0);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_84"></span>Проблема продуктивності
      збільшується, якщо ви виконуєте багатокрокову операцію, що генерує новий
      об'єкт на кожному кроку, по ходу відкидаючи всі об'єкти за винятком
      останнього результату. Існує два підходу для подолання цієї проблеми.
      Перший є здогадатись, які з багатокрокових операцій будуть потрібні, та
      запровадити їх як примітиви. Якщо багатокрокові операції проваджені як
      примітиви, незмінний клас не має створювати окремий об'єкт на кожному
      кроці. Зседерини незмінний клас може бути довільно розумним. Наприклад, <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> має пакунок-приватний змінний </span>“клас-компанйон”,
      який він використовує для прискорення багатокрокових операцій, таких, як
      модуляна експонента. Значно складніше використовувати змінний
      клас-компанйон, ніж використовувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code>, за
      всіх причин, що ми перелічили вище. Нащастя, вам не треьба це робити:
      реалізація <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">BigInteger</code>did
      робить складну роботу для вас.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Пакунок-приватний
      змінний клас-компанйон робить гарно, якщо ви можете точно передбачити, які
      складні операції клієнти будуть виконувати з вашим назмінним класом. Якщо
      ні, ваша найкраща ставка запровадити <em>публічний </em>змінний
      клас-компанйон. Головний приклад цього підходу в бібліотеці платформи Java
      є клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">String</code><span
        class="Apple-converted-space">, чий змінний компанйон є&nbsp;</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">StringBuilder</code><span
        class="Apple-converted-space">&nbsp;</span>(та його застарілий
      попередник,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">StringBuffer</code>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер,
      коли ви знаєте, як робити незмінний клас, і ви розумієте вигоди та
      недоліки незмінності, давайте обговоримо деякі альтернативи дизайну.
      Згадайте, що для гарантії незмінності, клас має заборонити створення
      субкласів. Це може бути зроблене через створення класу фінальним, але є
      інша, більш гнучка альтернатива. Замість зробити незмінний клас фінальним,
      ви можете зробити всі його конструктори приватними або пакунок-приватними,
      та додати публічні статичні фабрики замість публічних конструкторів (<a href="ch2.xhtml#lev1"
        style="text-decoration: none;">Елемент 1</a>). Щоб надати конкретики,
      ось як має виглядати&nbsp;<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Complex</code><span class="Apple-converted-space">,
        якщо ви застосуєте цей підхід</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Незмінний клас зі статичними фабриками замість конструкторів</strong><br>
      public class Complex {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final double re;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final double im;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>private</strong><span class="Apple-converted-space">&nbsp;</span>Complex(double
      re, double im) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.re = re;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.im = im;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>public static Complex valueOf(double re,
        double im)</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Complex(re,
      im);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Залишок опущений<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      підхід часто є найкращою альтернативою. Він є найбільш гнучким, оскільки
      дозволяє використання декількох пакунок-приватних класів реалізації. Для
      своїх клієнтів, що залишаються за межами пакунку, незмінний клас є
      ефективно фінальним, оскільки неможливо розширювати клас, що походить з
      іншого пакунку, та який не має публічних або захищених конструкторів.
      Окрім забезпечення гнучкості багатьох класів реалізації, цей підхід робить
      можливим налаштувати продуктивність класу в подальших релізах, через
      покращення об'єктно-кешуючих властивостей статичних фабрик.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Не
      було широкого розуміння, що незмінні класи мають бути ефективно
      фінальними, коли писались <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code><span
        class="Apple-converted-space">, так що всі їх методи можуть бути
        переписані</span>. Нажаль, це не може бути виправлено по факту, і при
      цьому підтримувати зворотню сумісність. Якщо ви пишете клас, чия безпека
      залежить від незмінності аргумента<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code><span class="Apple-converted-space">
        або</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code><span
        class="Apple-converted-space"> від недовіреного клієнта, ви повинні
        перевірити, та подивитись, що аргумент є "реальним" </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">BigInteger</code><span class="Apple-converted-space">
        або</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code>,
      скоріше, ніж примірником недовіреного субкласа. Якщо він є останнім, ви
      повинні зробити його захищену копію, припускаючи, що він може бути змінним
      (<a href="ch8.xhtml#lev50" style="text-decoration: none;">Елемент 50</a>):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static BigInteger safeInstance(BigInteger val) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return val.getClass() == BigInteger.class ?<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val
      : new BigInteger(val.toByteArray());<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Список
      правил для незмінних класів на початку цього елемента каже, що що методи
      не можуть модифікувати об'єкт, та всі поля мають бути фінальними.
      Фактично, ці правила трохи суворіші, ніж потрібно, та можуть бути
      послаблені для підвищення продуктивності. Насправді, жодний метод не може
      виконувати <em>видимі ззовні зміни </em>до стану об'єкта. Однак деякі
      змінні класи мають одне або більше нефінальних полів, в яких вони можуть
      кешувати результати коштовних обчислень, перший раз, коли воні потрібні.
      Якщо те саме значення запитується знову, буде повернуте кешоване значення,
      що зберіже кошт обчислень. Цей трюк робить саме тому, що об'єкт є
      незмінним, що гарантує, що обчислення даватиме той самий результат, якщо
      буде повторене.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наприклад,
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">PhoneNumber</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>
      (Елемент 11) обчислює хеш код першого разу, коли він викликається, та
      кешує його на випадок наступних викликів. Цей прийом є прикладом <em>лінивої
        ініціалізації</em><span class="Apple-converted-space"> </span>(Елемент
      83), що також використовується <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Треба
      додати одну особливість щодо серіалізації. Якщо ви оберете, що ваш
      незмінний клас реалізуватиме <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Serializable</code><span
        class="Apple-converted-space">, та він складається з одного або більше
        полів, що посилаютсья на змінні об'єкти, ви мусите провадити явний метод
      </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">readObject</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">readResolve</code><span
        class="Apple-converted-space">, або використовувати </span><code style="font-family: 'Courier New', monospace;">ObjectOutputStream.writeUnshared</code><span
        class="Apple-converted-space"> </span>та метод <span class="Apple-converted-space"></span><span
        epub:type="pagebreak" id="page_86"></span><code style="font-family: 'Courier New', monospace;">ObjectInputStream.readUnshared</code>,
      навіть якщо серіалізація по замовчанню прийнятна. Інакше атакуючий може
      створити змінний примірник вашого класу. Ця тема розкрита в Елементі 88.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      підсумку, чініть опір ваді писати сеттер для кожного геттера. <span class="Apple-converted-space"></span><strong>Класи
        мають бути незмінними, тільки якщо немає гарного приводу зробити їх
        змінними.</strong><span class="Apple-converted-space"> Незмінні класи
        провадять багато переваг, та їх єдиний недолік це потенціал для проблем
        продуктивності за певних умов. Ви завжди маєте робити малі об'єкти
        значень, такі як </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">PhoneNumber</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Complex</code>,
      незмінними. (Є декілька класів в бібліотеках платформи Java, такі як&nbsp;
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.util.Date</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">java.awt.Point</code>,
      які мали б бути незмінними, але не є такими). Вам слідує серйозно
      розглянути більші об'єкти значень, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        або</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigInteger</code>,
      зробити також незмінними. Вам слідує запровадити публічний змінний
      клас-компанйон для вашого класу, <em>тільки </em>коли ви переконаєтесь,
      що це потрібне для забезпечення задовільної продуктивності (Елемент 67).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існують
      деякі класи, для яких незмінність непрактична. <span class="Apple-converted-space"></span><strong>Якщо
        клас не може бути незмінним, обмежте його мінливість так сильно, як
        зможете.</strong><span class="Apple-converted-space"> Скорочення числа
        станів, в якому може існувати об'єкт, робить простішим міркування щодо
        об'єкту, та зменшує вірогідність помилок. Таким чином, робіть кожне поле
        фінальним, тільки якщо немає поважної причини не робити його фінальним.
        Комбінуючи цю пораду цього елемента з Елементом 15, ваша природна
        схильність має бути </span><span class="Apple-converted-space"></span><strong>декларувати
        кожне поле </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>private
          final</strong></code><span class="Apple-converted-space"></span><strong>,
        якщо немає достатньої причини робити інакше.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Конструктори
        повинні створювати повністю ініціалізовані об'єкти, з усіма
        установленими інваріантами.</strong><span class="Apple-converted-space">
      </span>Не провадьте публічний метод ініціалізації, окремо від
      конструктора, або статичну фабрику, за винятком, коли для цього є <em>поважна
        </em>причина. Так само не провадьте метод “реініціалізації”, що дозволяє
      об'єкту бути повторно використаним, так, якби він був сконструйований з
      іншим початковим станом. Такі методи загалом провадять мало, або взагалі
      жодної вигоди в продуктивності, ціною підвищеної складності.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">CountDownLatch</code><span
        class="Apple-converted-space"> </span>поважає ці принципи. Він змінний,
      але його простір станів навмисне утримується невеликим. Ви створюєте
      примірник, використовуєте його один раз, та і все: коли відлік добіжить
      нуля, ви вже не зможете використовувати його.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Фінальне
      зауваження повинне бути зроблене щодо класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Complex</code><span class="Apple-converted-space">
        в цьому елементі</span>. Цей приклад був призначений тільки для
      ілюстрації незмінності. Це не реалізація комплексних промислової якості.
      Вона використовує стандартні формули для комплексних множення та ділення,
      що не округляються коректно, та провадять слабку семантику для комплексних
      NaNs та безкінечностей [<a href="ref.xhtml#rKahan91" style="text-decoration: none;">Kahan91</a>,<span
        class="Apple-converted-space">&nbsp;</span><a href="ref.xhtml#rSmith62"
        style="text-decoration: none;">Smith62</a>,<span class="Apple-converted-space">&nbsp;</span><a
        href="ref.xhtml#rThomas94" style="text-decoration: none;">Thomas94</a>].</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_87"></span><strong>Елемент 18: Надавайте
        перевагу композиції замість наслідування</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наслідування
      є потужним шляхом досягти повторного використання коду, але воно не завжди
      найкращий спосіб зробити роботу. При невідповідному використанні воно
      призводить до крихкого коду. Безпечно використовувати наслідування в
      пакунку, де реалізації субкласу та суперкласу під контролем тих самих
      прогромістів. Також безпечно використовувати наслідування, коли
      розширюються класи, навмисне розроблені та документовані для розширення (<a
        href="ch4.xhtml#lev19" style="text-decoration: none;">Елемент 19</a>).
      Однак наслідування від звичайного суцілььного класу за межами пакунку є
      небезечним. Як нагадування, ця книга використовує слово "наслідування" в
      якості <em>наслідування реалізації</em><span class="Apple-converted-space">
      </span>(коли один клас розширює інший). Проблема, що обговорюється в цьому
      елементі, не стосується <em>наслідування інтерфейсу</em>, (коли клас
      реалізує інтерфейс, або коли інтерфейс розширює інший).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>На
        відміну від викликуу метода, наслідування порушує енкапсуляцію</strong><span
        class="Apple-converted-space"> </span>[<a href="ref.xhtml#rSnyder86" style="text-decoration: none;">Snyder86</a>].
Іншими
      словами, субклас залежить від деталій реалізації його суеркласа для своє
      функціональності. Реалізація суперкласа може змінитись від релізу до
      релізу, і якщо вона зробить це, субклас може схибити, навіть якщо його код
      не зазнав змін. Як слідоцтво, субклас має розвиватись разом в тандемі с
      суперкласом, за винятком, коли автор суперкласу розробив та документував
      його навмисне для цілей розширення. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      конкретизувати це твердження, давайте уявимо, що в нас є програма, що
      використовує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashSet</code>.
      Щоб налаштувати продуктівність нашой програми, нам треба запитати наш <code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">,
        щодо скільки елементів були додані з того часу, як він був створений</span>
      (не треба плутати з поточним розміром, що зменшується кожного разу, коли
      елемент видаляється). Щоб запровадити цю функціональність, ми пишемо
      варіант<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">HashSet</code><span
        class="Apple-converted-space">, що підраховує число спроб вставок
        елементів, та експортує аксессор до цього лічильника. Клас </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashSet</code><span
        class="Apple-converted-space"> містить два метода, здатних додавати
        елементи, </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">add</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">addAll</code>,
      так що ми перепишемо обоє ці методи:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch4_images.xhtml#pch4ex11a" id="pch4ex11" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Поломане - Невідповідне використання наслідування!</strong><br>
      public class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Лічильник спроб вставити елементи<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int addCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public InstrumentedHashSet() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public InstrumentedHashSet(int initCap, float
      loadFactor) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(initCap,
      loadFactor);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean add(E e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCount++;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.add(e);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean addAll(Collection&lt;?
      extends E&gt; c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCount += c.size();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.addAll(c);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public int getAddCount() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return addCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      клас виглядає прийнятним, але він не працює. Уявімо, що ми створили
      примірник, та додали три елементи, використовуючи метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">addAll</code>. Тепер
      вважатимо, що ми створили список, використовуючи статичний метод-фабрику<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">List.of</code>,
      що був доданий в Java 9; або якщо ви використовуєте ранішній реліз,
      використовуйте замість цього <code style="font-family: 'Courier New', monospace;">Arrays.asList</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">InstrumentedHashSet&lt;String&gt;
      s = new InstrumentedHashSet&lt;&gt;();<br>
      s.addAll(List.of("Snap", "Crackle", "Pop"));</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ми
      можемо очікуівати, що метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">getAddCount</code><span class="Apple-converted-space">
        повертатиме три в цій точці, але він повертає шість</span>. Що пішло
      хибно? Зсередини <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashSet</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">addAll</code>method
      реалізований зверху методва <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">add</code>, хоча<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">HashSet</code>,
      досить природно, не документує ціє деталі реалізації. Метод<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">addAll</code>method
      а<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">InstrumentedHashSet</code><span
        class="Apple-converted-space"> додає три до</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">addCount</code><span
        class="Apple-converted-space">, та потім викликаєтся </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">реалізація HashSet</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">addAll</code><span
        class="Apple-converted-space"> з використанням</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">super.addAll</code>.
      Це, в свобю чергу, викликає метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">add</code>, як перекриту
      в <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">InstrumentedHashSet</code>,
      одного разу ддля кожного елементу. Кожний з ціх трьох викликів додає ще
      одну одиницю до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">addCount</code>,
      що загалом зростає до шести: кожний елемент, доданий за допомогою метода <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">addAll</code><span
        class="Apple-converted-space">, буде порахований двічі.</span></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ми
      можемо "полагодити" субклас, уникнувши перекриття метода<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">addAll</code>.
      Хоча отриманий клас може робити, його відповідна робта буде залежати від
      факту, що метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashSet</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">addAll</code><span
        class="Apple-converted-space"> реалізований зверху метода </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">add</code>.
      Це “самовикористання” є деталлю реалізації, не гарантованою для всіх
      реалізацій платформи Java, та привід для зміни в релізі до реліза. Таким
      чином, отриманий клас <code style="font-family: 'Courier New', monospace;">InstrumentedHashSet</code><span
        class="Apple-converted-space"> буде крихким</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Трохи
      кращим може бути перекриття методу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">addAll</code><span class="Apple-converted-space">,
        щоб ітерувати по вказаній колекції</span>, викликаючи метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">add</code><span class="Apple-converted-space">
        одного разу для кожного елементу</span>. Це буде гарантувати коректний
      результат, чи буде метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">addAll</code><span
        class="Apple-converted-space"> реалізований зверху метода </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">add,
        оскільки реалізація метода </code><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">HashSet</code> <code style="font-family: 'Courier New', monospace;">addAll</code><span
        class="Apple-converted-space"> більше не буде викликатись</span>. Цей
      прийом, однак, н евирішує всіх наших проблем. Це призводить до
      переписування методів суперкласу, що можуть використовувати себе, або ні,
      що складно, витрачає час, схильне до помилок, та може зменшити
      продуктивність. Додатково, це не завжди можливо, оскільки деякі методи не
      можуть бути реалізовані без доступу до приватних полів, недоступних для
      субкласів. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Пов'язаний
      привід крихкості субкласів полягає в тому, що їх суперкласи можуть
      отримати нові методи в наступних релізів. Уявімо, програма залежить щодо
      своєї безпеки від факту, що всі елементи, вставлені в деяку колекцію
      відповідають деякому предикатові. Це можна гарантувати через субкласинг
      колекції, та перекриття кожного методу, здатного додавати елемент, щоб
      переконатись, що предикат задовільняється перед додаванням елементу. Це
      робить добре, доки новий метод, здатний вставляти елементи, не буде
      доданий до суперкласу в наступному релізі. Коли це станеться, стає
      можливим додати "нелегальний" елемент, просто викликаючи новий метод, що
      не перекритий в субкласі. Це не тільки чисто теоретична пролема. Деякі
      дірки в безпеці цієї природи були полагоджені, коли <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Hashtable</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Vector</code><span
        class="Apple-converted-space"> були модернізовані для участі в&nbsp;</span>
      Collections Framework.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Обоє
      з ціх пробелм походять від перекриття методів. Ви можете вважати, що
      безпечно розширювати клас, якщо ви просто додаєте нові методи, та
      утримуєтесь від перекриття існуючих методів. Хоча цей тип розширення
      значно безпечніший, він також не без ризику. Якщо суперклас отримає новий
      метод в наступному релізі, та ви мали лиху вдачу надати субкласу метод з
      тією ж сигнатурою, та іншим типом повернення, тоді тепер ваш субклас
      більше не буде компілюватись [JLS, 8.4.8.3]. Якщо ви надали своєму
      субкласу метод з такою самою сигнатурою, та він повертає тип як новий
      метод суперкласу, то тепер він перекриває його, так що в вас тепер предмет
      проблем, описаних раніше. Більше того, є сумнівним, що ваш метод буде
      задовільняти контракту нового метода суперкласу, оскільки цей контракт ще
      не був написаний, коли ви писали метод субкласу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Нащастя
      існує шлях уникнути всіх з перелічених пробелм. Замість розширювати
      існуючий клас, надайте свому класу приватне поле, що посилається на
      примірник існуючого класу. Цей дизайн називаєтсья <em>композицією, </em>оскільки
      існуючий клас стає компонентом нового класу. Кожний метод примірника
      нового класу викликає відповідний метод включеного примірника існуючого
      класу, та повертає результат. Це відоме як <em>форвардинг, </em>та
      методи нового класу відомі як <em>методи форвардінгу</em>. Результуючий
      клас буде стійкий як скеля, без залежності від деталей реалізації
      існуючого класу. Навіть додавання нового метода до існуючого класу не буде
      мати впливу на новий клас. Щоб надати цьому конкретики, ось заміна для <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">InstrumentedHashSet</code><span
        class="Apple-converted-space">, що використовує підхід
        композиція-та-форвардинг</span>. Зауважте, що реалізація розбита на дві
      частини, самий клас та повторно використований <em>форвардинг клас</em><em>,</em><span
        class="Apple-converted-space"> </span>що містить всі форвардинг методи,
      і більше нічого:</p>
    <span epub:type="pagebreak" id="page_89" style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"></span><span
      style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Клас-огортка, використовує композицію замість наслідування класів</strong><br>
      public class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int addCount = 0;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public InstrumentedSet(Set&lt;E&gt; s) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(s);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean add(E e) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addCount++;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.add(e);<br>
      &nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp; @Override public boolean addAll(Collection&lt;?
      extends E&gt; c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addCount += c.size();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return super.addAll(c);<br>
      &nbsp;&nbsp;&nbsp;&nbsp; }<br>
      &nbsp;&nbsp;&nbsp;&nbsp; public int getAddCount() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return addCount;<br>
      &nbsp;&nbsp;&nbsp;&nbsp; }<br>
      }<br>
      <br>
      <strong>// Повторно використовуваний форвардинг клас</strong><br>
      public class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Set&lt;E&gt; s;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public ForwardingSet(Set&lt;E&gt; s) { this.s = s;
      }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void
      clear()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      {
s.clear();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean contains(Object o) { return
      s.contains(o); }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean
      isEmpty()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      return s.isEmpty();&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public int
      size()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.size();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Iterator&lt;E&gt;
      iterator()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return
      s.iterator();&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean add(E
      e)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { return
      s.add(e);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean remove(Object o)&nbsp;&nbsp; {
      return s.remove(o);&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean containsAll(Collection&lt;?&gt; c)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.containsAll(c); }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean addAll(Collection&lt;? extends
      E&gt; c)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.addAll(c);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean removeAll(Collection&lt;?&gt; c)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.removeAll(c);&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean retainAll(Collection&lt;?&gt; c)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.retainAll(c);&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Object[]
      toArray()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
      return s.toArray();&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; T[] toArray(T[]
      a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ return s.toArray(a); }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean equals(Object o)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      { return s.equals(o);&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public int
      hashCode()&nbsp;&nbsp;&nbsp;&nbsp;{ return s.hashCode(); }<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public String toString() { return
      s.toString(); }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_90"></span>Дизайн класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> доступний через існування інтерфейсу </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set</code>,
      що захоплює функціональність класу <code style="font-family: 'Courier New', monospace;">HashSet</code>.
      Окрім бути надійним, цей дизайн вкрай гнучкий.&nbsp; Клас <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> реалізує інтерфейс </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set, та має єдиний
        конструктор, чий аргумент також типу</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Set</code>. В
      основі, цей клас трансформує один <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code><span class="Apple-converted-space">
        в інший, додаючи функціональність інструментальнсоті. На відміну від
        основаного на наслідуванні підходу, що робить тільки на одному
        суцільному класі, та потребує окремого конструктора для кожного
        підтримуваного конструктора в суперкласі, клас-оболонка може існувати
        для інструменталізації любої реалізації </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code><span class="Apple-converted-space">,
        та буде робити в поєднанні з любим вже існуючим конструктором</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Set&lt;Instant&gt;
      times = new InstrumentedSet&lt;&gt;(new TreeSet&lt;&gt;(cmp));<br>
      Set&lt;E&gt; s = new InstrumentedSet&lt;&gt;(new
      HashSet&lt;&gt;(INIT_CAPACITY));</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> навіть може бути використаний для
        тимчасової інструменталізації примірника множини, що вже
        використовується з інструменталізацією</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">static
      void walk(Set&lt;Dog&gt; dogs) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;InstrumentedSet&lt;Dog&gt; iDogs = new
      InstrumentedSet&lt;&gt;(dogs);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Within this method use iDogs instead of
      dogs<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> відомий як <em>клас-огортка, </em>оскільки
        кожний примірник </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> містить </span>(“огортає”) інший
      примірник <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set</code>.
      Це також відоме як шаблон <span class="Apple-converted-space"></span><em>Decorator</em>
      [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>],
      оскільки клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">InstrumentedSet</code><span
        class="Apple-converted-space"> </span>“декорує” множину через додавання
      інструментації. Іноді комбінація композиції та форвардингу помилково
      посилаєтся як <em>делегація. </em>Технічно це не делегація, тільки якщо
      об'єкт-огортка не посилає себе до огорнутого об'єкта [Lieberman86;
      Gamma95].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Є
      декілька недоліків огортання класів. Одна з зачіпок в тому, що
      класи-огортки не підходять для використання в <em>фреймворках зворотніх
        викликів</em>, де об'єкти передають посилання на себе до інших об'єктів
      для наступних зворотніх викликів (“колбеків”). Оскільки огорнутий об'єкт
      нічого не знає про огортку, він передає посилання на себе (<code style="font-family: 'Courier New', monospace;">this</code>),
      та зворотні виклики оминають огортку. Це відомо як <em>проблема</em><span
        class="Apple-converted-space"> </span><em>SELF</em><span class="Apple-converted-space">
      </span>[<a href="ref.xhtml#rLieberman86" style="text-decoration: none;">Lieberman86</a>].
      Деякі люди турбуються щодо впливу на продуктивність через виклик методів
      форвардингу, або через розмір пам'яті, що потребують об'єкти-огортки.
      Також вони не будуть мати значний вплив на практиці. Писати методи
      форвардингу є надокучливим, але ви маєте писати повторно використовуваний
      клас форвардингу для кожного інтерфейсу тільки один раз, та класи
      форвардингу можуть бути проваджені для вас. Наприклад, Guava провадить
      форвардинг класи для всіх з інтерфейсів колекції [<a href="ref.xhtml#rGuava"
        style="text-decoration: none;">Guava</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наслідування
      прийнятне тільки в випадках, коли субклас дійсно є <em>підтипом </em>для
      суперкласа. Іншими словами, клас <span class="Apple-converted-space"></span><em>B</em><span
        class="Apple-converted-space"> </span>має розширювати клас <span class="Apple-converted-space"></span><em>A,
        </em>тільки якщо існує відношення "є деякім" між ціма двома класами.
      Якщо ви спокушаєтесь зробити клас <span class="Apple-converted-space"></span><em>B</em><span
        class="Apple-converted-space"> розширенням класу</span><span class="Apple-converted-space">
      </span><em>A</em>, запитайте себе запитання: чи <span class="Apple-converted-space"></span><em>B</em><span
        class="Apple-converted-space"> </span>дійсно є<span class="Apple-converted-space">
      </span><em>A</em>? Якщо ви невзмозі достовірно відповісти так на це
      питання,<span class="Apple-converted-space">&nbsp;</span><em>B</em><span class="Apple-converted-space">
      </span>не має розширювати<span class="Apple-converted-space"> </span><em>A</em>.
      Якщо відповідь ні, це часто є випадком, коли <span class="Apple-converted-space"></span><em>B</em><span
        class="Apple-converted-space"> </span>повинен містити приватний
      примірник <span class="Apple-converted-space"></span><em>A</em><span class="Apple-converted-space">,
        та виказувати інший</span> API:<span class="Apple-converted-space">&nbsp;</span><em>A</em><span
        class="Apple-converted-space"> не є дійсною частиною </span><span class="Apple-converted-space"></span><em>B</em>,
      але тільки деталлю його реалізації.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      декілька очевидних порушень цього принципу в бібліотеках платформи Java.
      Наприклад, стек не є вектором, так що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">
        не повинен розширювати</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Vector</code>. Подібно,
      список властивостей не є хеш таблицею, так що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Properties</code><span class="Apple-converted-space">
      </span>не повинен розширювати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Hashtable</code>. В обох
      випадках композиція мала б мати перевагу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви використовуєте наслідування, там, де має бути композиція, ви без
      потреби виказуєте деталі реалізації. Результуючий API прив'язує вас до
      оригінальної реалізації, назавжди обмежуючи представлення вашого класу.
      Більш серйозно, виказуючи внутрінощі, ви дозволяєте клієнтам доступ до них
      напряму. Щонайменьше, це призведе до спантеличливої семантики. Наприклад,
      як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">p</code><span
        class="Apple-converted-space"> посилається на примірник</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Properties</code>,
      тоді <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">p.getProperty(key)</code><span
        class="Apple-converted-space"> може давати інший результат, ніж </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">p.get(key)</code>:
      попередній метод приймає до уваги замовчення, тоді як другий метод, що
      наслідуваний від <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Hashtable</code>,
      ні. Більш серйозно, клієнт буде в змозі порушити інваріанти субкласа,
      через пряму модифікацію суперкласу. В випадку <code style="font-family: 'Courier New', monospace;">Properties</code>,
      розробники мали намір, що в якості ключів та значень можливі тільки рядки,
      але прямий доступ до підлеглого <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Hashtable</code><span class="Apple-converted-space">
        дозволяє порушити цей інваріант</span>. Коли він порушений, надалі
      неможливо використовувати інші частини <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Properties</code><span class="Apple-converted-space">&nbsp;</span>API
      (завантаження та збереження). Коли ця проблема була досліджена, було доже
      пізно випрявляти її, бо клієнти залежали від використання не-рядкових
      ключів та значень.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      один остаточний пул питань, які ви маєте запитати себе, перед вирішенням
      застосування наслідування замість наслідування. Чи класи, що сподівається
      бути розширеним, мають любі слабкості в API? Якщо так, чи ви згодні
      просувати ці прогалини в API вашого класа? Наслідування просуває любі
      слабкості в API суперкласу, в той час, коли композиція дозволяє вам
      розробляти новий API, що приховує ці помилки.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку: наслідування є потужним, але проблематичним, оскільки воно
      порушує інкапсуляцію. Воно придатне тільки в випадку, коли існує чисте
      відношення субтипів між субкласами та суперкласами. Навть і тоді,
      наслідування може призвести до крихкості, якщо субклас знаходиться в
      іншому пакунку, ніж суперклас, та суперклас не розроблений для
      наслідування. Щоб уникнути крихкості, використовуйте композицію та
      форвардинг замість наслідування, особливо якщо потрібний інтерфейс для
      реалізації вже має клас огортки. Класи огортки не тільки більш надійні,
      ніж субкласи. Вони також більш потужні.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемент<strong>
        19: Розробляйте та документуйте для наслідування, або забороняйте його</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемент
      18 застерігає вас щодо створення субкласів “іноземних” класів, що не були
      розроблені та документовані для наслідування. Так що це має означати для
      класу, бути розробленим та документованим для наслідування?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зпершу,
      клас має щільно документувати ефекти від перекриття методів. Іншими
      словами, <strong>клас має документувати само-використання перекриття
        методів. </strong>Для кожного публічного або захищеного метода
      документація має вказувати, які перекривані методи він може викликати, та
      як результати кожного виклику впливають на подальшу обробку. (Під <em>перекриваними
        </em>ми розуміємо нефінальні, та публічні або захищені члени). Більш
      загально, клас має документувати любі умови, за яких він може викликати
      перекриваний метод. Наприклад, виклики можуть походити від фонових потоків
      або статичних ініціалізаторів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Метод,
      що викликає перекривані методи, містить опис ціх викликів в кінці свого
      документуючого коментаря. Опис є окремим розділом специфікації, поміченої
      “Implementation Requirements” (Вимоги до реалізації), що генерується тегом
      Javadoc<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">@implSpec</code>.
      Цей розділ описує внутрішню роботу методу. Ось приклад, скопійований зі
      специфікації для <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">java.util.AbstractCollection</code>:</p>
    <p class="codep" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 22.666668px; page-break-after: avoid; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      boolean remove(Object o)</p>
    <p class="bqa" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 37.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Видаляє
      поодинокий примірник вказаного елементу з колекції, якщо він присутній
      (опціональна операція). Більш формально, видаляє елемент&nbsp;<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">e, такий, що </code><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">відбуваєтсья
        умова Objects.equals(o, e)</code>, якщо колекція містить один або більше
      таких елементів. Повертає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code><span class="Apple-converted-space">,
        якщо ця колекція містила вказаний елемент</span> (або, що еквівалентне,
      якщо колекція змінилась в результаті цього виклику).</p>
    <p class="bqa" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 37.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Вимоги
        до реалізації:</strong><span class="Apple-converted-space"> ця
        реалізація ітерує по колекції, шукаючи вказаний елемент. Якщо вона
        знаходить цей елемент, вона видаляє елемент з колекції, використовуючи
        метод видалення ітератора </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">remove</code>. Зауважте,
      що ця реалізація підіймає <code style="font-family: 'Courier New', monospace;">UnsupportedOperationException</code><span
        class="Apple-converted-space">, якщо ітератор, повернутий методом&nbsp;</span><span
        class="Apple-converted-space"><span class="Apple-converted-space"></span><code
          style="font-family: 'Courier New', monospace;">iterator</code><span class="Apple-converted-space"></span>
        цієї колекції, не реалізує метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">remove</code><span class="Apple-converted-space">,
        та ця колекція містить вказаний об'єкт</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      документація не залишає сумніву, що перекриття метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">iterator</code><span class="Apple-converted-space">
        буде впливати на поведінку метода </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">remove</code>. Вона також
      описує, як саме поведінка <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Iterator</code><span class="Apple-converted-space">,
        повернутого методом </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">iterator, буде впливаит
        на поведінку метода </code><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">remove</code>. До
      контрасту з ситуацією в<span class="Apple-converted-space"> </span><a href="ch4.xhtml#lev18"
        style="text-decoration: none;">Елементі 18</a>, коли програміст,
      створюючи субклас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">HashSet</code><span
        class="Apple-converted-space">, просто не може сказати, чи перекриття
        метода </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">add</code><span
        class="Apple-converted-space"> буде впливати на поведінку метода </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">addAll</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_93"></span>Але чи це не порушує
      настанову, що гарна документація API повинна описувати, <em>що </em>робить
      даний метод, та не <em>як </em>він це робить? Так, порушує! Це
      нещасливий наслідок факту, що наслідування порушує інкапсуляцію. Щоб
      документувати клас, так, щоб він міг бути безпечно наслідуваний, ви мусите
      описати деталі реалізації, які в іншому випадку слідувало б залишити
      невизначеними. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тег<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">@implSpec</code><span
        class="Apple-converted-space"> був доданий в </span>Java 8, і потужно
      використовується в Java 9. Цей тег має бути вімкнений по замовчанню, але в
      Java 9 утіліта Javadoc все ще ігнорує його, якщо ви не надасте перемикач
      командного рядка <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">-tag
        "apiNote:a:API Note:"</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Розробка
      для наслідування включає більше, ніж просто документування шаблонів
      само-використання. Щоб дозволити програмістам писати ефективні субкласи
      без супутнього болю,<span class="Apple-converted-space"> </span><strong>клас
        може потребувати провадження перехоплень внутрішніх робіт, в формі
        прискіпливо обраних захищених методів</strong>, або, в рідких випадках,
      захищений полів. Наприклад, розглянемо метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">removeRange</code><span class="Apple-converted-space">&nbsp;</span>method
      з<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">java.util.AbstractList</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">protected
      void removeRange(int fromIndex, int toIndex)</p>
    <p class="bq" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 19.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Видаляє
      зі списку всі елементи, чий індекс знаходиться між <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">fromIndex</code>,
      включно, та до<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">toIndex</code>,
      <code style="font-family: 'Courier New', monospace;"></code>виключно.
      Зсуває всі послідуючі елементи вліво (зменшуючи їх індекс).&nbsp; Цей
      виклик скорочує list на<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">(toIndex - fromIndex)</code><span
        class="Apple-converted-space"> елементів</span>. (Якщо<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">toIndex ==
        fromIndex</code>операція не має наслідків).</p>
    <p class="bq" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 19.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      метод викликаєтсья операцією <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clear</code><span class="Apple-converted-space">
        для цього списку, та його підсписків</span>. Перекриття цього метода для
      отримання переваг внутрішньої реалізації списку, може значною мірою
      покращити продуктивність операції <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clear</code><span class="Apple-converted-space">
        на цьому списку та його підсписках</span>.</p>
    <p class="bq" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 19.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Вимоги
        до реалізації:</strong><span class="Apple-converted-space"> </span>Ця
      реалізація отримує ітератор списку позиційований перед <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">fromIndex</code><span class="Apple-converted-space">,
        та постійно викликає </span><code style="font-family: 'Courier New', monospace;">ListIterator.next,
        за яким іде </code><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">ListIterator.remove</code>,
      доки весь диапазон не буде видалений. <span class="Apple-converted-space"></span><strong>Зауваження:
        якщо </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>ListIterator.remove</strong></code><span
        class="Apple-converted-space"> <strong>потребує лінійного часу, ця
          реалізація потребує квадратичного часу</strong></span><strong>.</strong></p>
    <p class="bq" style="font-size: medium; margin-top: 7.5px; margin-bottom: 7.5px; margin-left: 19.5px; text-indent: 0px; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Параметри:</p>
    <p class="prem" style="font-size: 0.88em; margin-top: 6.666667px; margin-bottom: 26.666668px; margin-left: 41.333336px; text-align: justify; font-family: sans-serif; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><code
        style="font-family: 'Courier New', monospace;">fromIndex</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      індекс першого елементу, що буде видалений.<br>
      <code style="font-family: 'Courier New', monospace;">toIndex</code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      індекс за останнім видаленим елементом.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      метод не в сфері цікавості кінцевих користувачів реалізації<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List</code>.
      Він провадиться з єдиною метою спростити для субкласів впровадження
      швидкого методу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clear</code>.
      За відсутності метода<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">removeRange</code>,
      субкласи матимуть виконувати роботу з крадратичною продуктивністю, тоді як
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">clear
        був викликаний на субсписках, або переписувати цілий механізм </code><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">subList</code><span
        class="Apple-converted-space"> з самого початку </span>— непросте
      завдання!</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">То
      як ви вирішуєте, які захищені члени показувати, коли ви розробляєте клас
      для наслідування? Нажаль немає чарівної кулі. Краще, що ви можете зробити,
      це гарно доумати, зробити краще припущення, та потім протестувати його,
      написавши субкласи. Вам слідує показати так мало захищених членів, як це
      можливо, тому що кожний з них представляє зобов'язання щодо деталей
      реалізації. З іншого боку, ви не маєте дуже мало, оскільки відсутність
      захищеного члена може зробити клас практично некорисним для наслідування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong><em>Єдиний
          </em>шлях перевірити клас, розроблений для наслідування - написати
        субкласи</strong><strong>.</strong><span class="Apple-converted-space">
        Якщо ви забудете важливий захищений член, тоді спроба написати субклас
        зробить цей недолік болюче явною. І навпаки, якщо декілька написаних
        субкласів не використовують захищений член, вам, вірогідно, треба
        зробити його приватним</span>. Досвід показує, що три субкласа достатньо
      для тестування розширюваного субкласа. Один або більше з ціх субкласів
      повинен бути написаний кімось іншим, ніж автор суперкласа.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви розробляєте для наслідування клас, що, вірогідно, буде в широкому
      ужитку, розумійте, що ви присягаєтесь <em>назавжди</em> виконувати
      шаблони само-використання, які задокументували, та щодо рішень реалізації,
      явних через захищені методи та поля. Ця обіцянка може ускладнити або
      унеможливити покращення продуктивності або функціональності класу в в
      наступних релізах. Таким чином, <strong>ви маєте протестувати ваш клас
        через написання субкласів <em>перед тим, </em>як випустити його</strong><strong>.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Також
      зауважте, що спеціальна документація для наслідування захаращує звичайну
      документацію, що розроблена для програмістів, що створюють примірники
      вашого класу, та викликають його методи. На час написання робиться дуже
      мало для того, що інструменти відділяли звичайну документацію API від
      інформації, цікавої тільки для програмістів, що реалізують субкласи. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      декілька додаткових обмежень, яким маж підкорюватись клас, щоб дозволити
      наслідування. <span class="Apple-converted-space"></span><strong>Конструктори
        не мають викликати перекривані методи</strong>, прямо чи непрямо. Якщо
      ви порушите це правило, результатом буде збій програми. Конструктор
      суперкласу виконується до конструктора субкласа, так що перекриття метода
      в субкласі&nbsp; буде викликатись до того, як буде виконаний конструктор
      субкласу. Якщо перекриваючий метод залежить від любої ініціалізації,
      виконуваної конструктором субкласу, метод не буде поводитись як
      очікується. Щоб надати прикладу конкретики, ось клас, що порушує це
      правило:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Super {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// Поломане - конструктор викликає
        перекриваний метод</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Super() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overrideMe();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void overrideMe() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ось
      субклас, що перекриває перекриваний метод, та який помилково викликається
      в конструкторі&nbsp; <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Super</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      final class Sub extends Super {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Порожній final, що встановлюється в
      конструкторі<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Instant instant;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;Sub() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instant = Instant.now();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// Перекриття методу, який буде викликаний
        конструктором суперкласу</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public void overrideMe() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(instant);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sub sub = new Sub();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sub.overrideMe();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете очікавати, що ця програма буде друкувати instant двічі, але він
      друкує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">null</code><span
        class="Apple-converted-space"> перший раз, оскільки </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">overrideMe</code><span class="Apple-converted-space">
        викликається конструктором</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Super</code> перед тим,
      як конструктор <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Sub</code><span
        class="Apple-converted-space"> матиме шанс ініціалізувати поле</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">instant</code>.
      Зауважте, що&nbsp; ця програма спостерігає фінальне поле в двох станах!
      Також зауважте, що якщо <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">overrideMe</code><span class="Apple-converted-space">
        викличе любий метод на </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">instant</code>, буде
      викликане<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">NullPointerException</code><span
        class="Apple-converted-space">, коли конструктор </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Super викликає</code><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">overrideMe</code>.
      Єдина причина, за якої ця програма не викликає&nbsp;<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">NullPointerException</code><span
        class="Apple-converted-space"> як воно є,&nbsp; полягає в тому, що метод
      </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">println</code><span
        class="Apple-converted-space"> толерантний до параметрів </span>null.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що&nbsp; <em>є безпечним </em>визивати з конструктора приватні методи,
      фіналні методи, та статичні методи, жодний з яких не є перекриваним..</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інтерфейси
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Cloneable</code><span
        class="Apple-converted-space"> та </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Serializable</code><span
        class="Apple-converted-space"> представляють особливі складнощі при
        розробці наслідування. Загалом не є гарною ідеєю для класа, розробленого
        для наслідування, реалізувати жодний з ціх інтерфейсів, оскільки вони
        накладають значний безлад на програмістів, що розширюють клас. Однак
        існують спеціальні дії, які ви можете запровадити, що дозволити
        субкласам реалізувати ці інтерфейси, не заявляючи, що вони роблять це</span>.
      Ці дії описані в <span class="Apple-converted-space"></span><a href="ch3.xhtml#lev13"
        style="text-decoration: none;">Елементі 13</a><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><a href="ch12.xhtml#lev86"
        style="text-decoration: none;">Елементі 86</a>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви вирішите реалізувати або <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Cloneable</code><span class="Apple-converted-space">
        або</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Serializable</code><span
        class="Apple-converted-space"> в класі, що розроблений для наслідування,
        ви маєте бути уважним, бо методи</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">clone</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">readObject</code><span
        class="Apple-converted-space"> поводяться здебільшого як конструктори,
        до яких стосується подібне обмеження</span>:<span class="Apple-converted-space">
      </span><strong>ні</strong><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;"><strong>clone</strong></code><span
        class="Apple-converted-space"> <strong>ні</strong></span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>readObject</strong></code><span
        class="Apple-converted-space"> <strong>не можуть викликаати
          перекриваний метод, прямо або непрямо. </strong></span><span class="Apple-converted-space"></span>В
      випадку&nbsp; <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">readObject</code>,
      перекриваючий метод буде виконуватись перед тим, як стан субкласа буде
      десеріалізований. В випадку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code>,
      перекриваючий метод буде виконуватись перед тим, як метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code><span class="Apple-converted-space">
        матиме шанс полагодити стан клона</span>. В любому випадку скоріше
      всього послідує крах програми.&nbsp; В випадку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">clone</code> збій може
      зламати оригінальний об'єкт, так само, як і клон. Це може стати,
      наприклад, якщо оперекриваючий метод вважає, що він модифікує копію клона
      в глибокій структурі об'єкта, але копія все ще не була створена. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Нарешті,
      якщо ви вирішине реалізувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Serializable</code><span
        class="Apple-converted-space"> в класі, розробленому для наслідування,
        та клас має </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">readResolve</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">writeReplace</code>method,
ви
      маєте зробити <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">методи
        readResolve</code><span class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">writeReplace</code><span
        class="Apple-converted-space"> захищеними, скоріше, ніж приватними. Якщо
        ці методи є приватні, вони будуть тихо проігноровані субкласами</span>.
      Це ще один з випадків, коли деталі реалізації стають частиною API класу,
      щоб дозволити наслідування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер
      стає зрозумілим, що <span class="Apple-converted-space"></span><strong>розробка
        класу для наслідування потребує добрих зусиль, та накладає суттєві
        обмеження на клас.</strong><span class="Apple-converted-space"> Це не те
        рішення, яке можна приймати легковажно. Існуюсть деякі ситуації, коли це
        явно ясна річ, що треба робити, як абстрактні класи, включачи <em>скелетні
          реалізації </em>інтерфейсів </span>(<a href="ch4.xhtml#lev20" style="text-decoration: none;">Елемент
        20</a>). Існують інші ситуації, коли це погана річ щоб зробити, такі, як
      незмінні класи (<a href="ch4.xhtml#lev17" style="text-decoration: none;">Елемент
        17</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Але
      що до звичайних суцільних класів? Традиційно, вони ніколи не бувають
      фінальні, та не розроблені та не документовані для субкласування, але цей
      різновид справ є небезпечним. Кожний раз, коли в такому класі відбуваються
      зміни, існує шанс, що субкласи, що розширюють цей клас, будуть ламатись.
      Це не тільки теоритична проблема. Не є рідкістю отримати повідомлення про
      баг, пов'язаний з субкласами, після модифікації внутрощів нефінального
      суцільного класа, що не був розроблелний та документований для
      наслідування.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Краще
        рішення цієї проблеми, що заборонити створення субкласів класу, що не
        розроблений та документований для безпечного створення субкласів. </strong><span
        class="Apple-converted-space"></span>Існують два методи заборонити
      субкласи. простіший з двох є описати клас як фінальний. Альтернатива є
      зробити всі конструктори приватними або пакунок-приватними, та додати
      публічні статичні фабрики замість конструкторів. Ця альтернатива, що
      провадить гнучкість для внутрішнього використання субкласів, описана в <span
        class="Apple-converted-space"></span><a href="ch4.xhtml#lev17" style="text-decoration: none;">Елементі
        17</a>. Кожний підхід прийнятний.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      порада може бути дещо контраверсійною, оскільки багато програмістів
      зростали зі звичкою створювати субкласи до звичайних суцільних класів, щоб
      додавати такі можливості, як інструментація, нотифікація та синхронізація,
      або, навпаки, обмежити функціональність. Якщо клас реалізує деякий
      інтерфейс, що лежить в його основі, як<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Set</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List</code>,
      або&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Map</code>,
      тоді вам не слідує перейматись щодо заборони наслідування. Шаблон <em>класу-огортки,
        </em>описаний в <a href="ch4.xhtml#lev18" style="text-decoration: none;">Елементі
        18</a>, провадить чудову альтернативу до наслідування, дякуючи
      підкращенню функціональності.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      суцільний клас не реалізує стандартний інтерфейс, тоді ви можете створити
      незручність для деяких програмістів, через заборону наслідування. Якщо ви
      відчуваєте, що маєте дозволити наслідування для таких класів, один з
      розумних підходів є переконатись, що клас ніколи не викликає любий зі
      своїх перекриваних методів, та документуйте цей факт. Іншими словами,
      повністю уникайте само-використання класу в перекриваних методах. Роблячи
      це, ви створите клас, що досить безпечний для створення субкласів.
      Перекриття метода ніколи не впливатиме на поведінку іншого метода. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете уникнути само-використання класу перекриваних методів механічно,
      без зміни поведінки. Перемістить тіло кожного з перекриваних методів до
      приватного&nbsp; “допоміжного метода”, де кожний перекриваний метод
      викликатиме його приватний допоміжний метод. Потім замініть кожне
      само-використання перекриваного метода на прямий виклик приватного
      допоміжного метода. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, розроблення класу для наслідування є важкою роботою. Ви маєте
      документувати всі його шаблони само-використування, та коли ви
      задокументуєте їх, ви маєте підтримувати їх до кінця життя класу. Якщо ви
      не зробитимите це, субкласи можуть стати залежними від деталей реалізації
      суперкласа, та це може все поломати, якщо реалізація суперкласа змінитсья.
      Щоб дозволити іншим писати <em>ефективні </em>субкласи, ви можете також
      експортувати один або більше захищених методів. Якщо ви не певні, що
      насправді знадобляться субкласи, вам, можливо, буде за краще заборонити
      наслідування, через декларацію вашого класу як фінального, або
      переконавшись, що немає доступних конструкторів.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_98"></span><strong>Елемент 20: Надавайте
        перевагу інтерфейсам замість абстрактних класів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Java
      має два механізми визначити тип, що дозволяє декілька реалізацій:
      інтерфейси та абстрактні класи. Оскільки були введені <em>методи по
        замовчанню </em>для інтерфейсів Java 8 [<a href="ref.xhtml#rJLS" style="text-decoration: none;">JLS
        9.4.3</a>], обоє механізми дощзволяють вам провадити реалізації для
      деяких методів примірника. Головна різниця в тому, що коли ви визначаєте
      тип як абстрактний клас, клас має бути субкласом абстрактного класу.
      Оскільки Java дозволяє тільки поодиноке наслідування, це обмеження
      абстрактних класів обмежує їх використання як визначень типів. Любий клас,
      що визначає всі з потрібних методів, та підкорюється загальному контракту,
      може реалізувати інтерфейс, безвідносно до того, де знаходиться клас в
      ієрархії класів. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Розширення
        класу може легко бути перетворене на реалізацію нового інтерфейсу.</strong><span
        class="Apple-converted-space"> Все, що вам треба зробити, це додати
        потрібні методи</span>, якщо вони все ще не існують, та додати
      твердження <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">implements</code><span
        class="Apple-converted-space"> до декларації класу</span>. Наприклад,
      багато існуючих класів були пперероблені для підтримки інтерфейсів&nbsp; <code
        style="font-family: 'Courier New', monospace;">Comparable</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Iterable</code>, та<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Autocloseable</code><span
        class="Apple-converted-space">, коли вони були додані до платформи</span>.
      Існуючі класи не можуть, загалом, бути перетворені для розширення нового
      абстрактного класу.&nbsp; Якщо ви бажаєте мати два класи, що розширюють
      той самий абстрактний клас, вам треба помістити його вище в ієрархії
      класів, щоб він був предком для обох класів. Нажаль, це призведе до
      великого причинного руйнування ієрархії класів, змушуючи всіх наслідників
      нового абстрактного класу наслідувати його, чи є це задовільним, чи ні.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Інтерфайси
        є ідеальними для визначення міксінів.</strong> Кажучи спрощено, <span class="Apple-converted-space"></span><em>міксин
        </em>є типом, що клас може реалізувати на додаток до "первинного типу".
      Наприклад,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable</code><span
        class="Apple-converted-space"> є міксін інтерфейсом, що дозволяє </span>класу
      декларувати, що його примірники впорядковані з точки зору інших, взаємно
      порівнюваних, об'єктів. Такий інтерфес називається міксіном, оскільки він
      дозволяє опціональну функціональність "домішати" до первинної
      функціональності класу. Абстрактні класи не можуть бути використані для
      створенняміксінів, з тих же причин, що вони не можуть бути вбудовані в
      існуючі класи: клас не може мати більше одно батька, та немає прийнятного
      місція в ієрархії класів для вставки міксіну. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Інтерфейси
        дозволяють конструювання неієрархічних фреймворків типів. </strong>Ієрархії
      типів гарні для деяких речей, але інші речі не дуже вкладаються в жорстку
      ієрархію.&nbsp; Наприклад, уявімо, що ми маємо інтерфейс, що представляє
      співака та інший, що представляє автора пісень:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      interface Singer {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;AudioClip sing(Song s);<br>
      }<br>
      <span epub:type="pagebreak" id="page_99"></span>public interface
      Songwriter {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Song compose(int chartPosition);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      реальному житті співаки також бувають і авторами пісень. Оскільки ми
      використовували інтерфейси, ніж абстрактні класи, для визначення ціх
      типів, є повністю допустимим для одного класа реалізувати обоє інтерфейси,
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Singer</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Songwriter</code>.
      Фактично, ми можемо визначити третій інтерфейс, що розширює обоє, <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Singer</code><span class="Apple-converted-space">
        та </span><code style="font-family: 'Courier New', monospace;">Songwriter,
        та додає нові методи, що відповідають комбінації</code>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch4_images.xhtml#pch4ex21a" id="pch4ex21" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      interface SingerSongwriter extends Singer, Songwriter {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;AudioClip strum();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;void actSensitive();<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Вам
      не завжди потрібен цей рівень гнучкості, але коли це так, інтерфейси
      рятують життя. Альтернатива є розгалужена ієрархія класів, що містить
      окремий клас для кожної підтримуваної комбінації атрибутів. Якщо існує
      n&nbsp; атрибутів в типовій системі, тоді&nbsp; є 2<em><sup>n</sup></em><span
        class="Apple-converted-space"> можливих комбінацій, що ви можете
        підтримувати. Це те що називається <em>комбінаторним вибухом. </em>Роздуті
        ієрархії класів </span>призводять до набряку класів, з багатьма
      методвами, що відрізняються тільки в типі їх аргументів, оскльки в
      ієрархії класів немає типів, що захоплюють загальну поведінку.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Інтерфейси
        дозволяють безпечні, потужні функціональні розширення, </strong>через
      ідіому <em>класу-огортки</em> (<a href="ch4.xhtml#lev18" style="text-decoration: none;">Елемент
        18</a>). Якщо ви використовуєте абстрактні класи для визначення типів,
      ви залишаєте програміста, що бажає додати функціональність без вибору,
      крім наслідування. Результуючий клас менш потужний, та більш крихкий, ніж
      класи огортки. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      немає явної реалізації метода інтерфейса в термінах інших методів
      інтерфейса, спробуйте запровадити програмістам допомогу в реалізації в
      формі методу по замовчанню.&nbsp; Для прикладу цього прийому, дивіться
      метод <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">removeIf</code>.
      Якщо ви провадите методи по замовчанню, переконайтесь, що задокументували
      їх для наслідування, використовуючи <span class="Apple-converted-space"></span>Javadoc
      тег <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">@implSpec</code><span
        class="Apple-converted-space"> </span>(<a href="ch4.xhtml#lev19" style="text-decoration: none;">Елемент
        19</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існують
      ліміти, як багато допомоги в реалізації ви можете провадити за допомогою
      методів по замовчанню. Хоча багато інтерфейсів змінюють поведінку методів
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space">, таких як </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      вам не дозволено провадити для них методи по замовчанню. Також інтерфейсам
      не дозволяється мати поля примірника, або непублічні статичні члени (за
      винятком приватних статичних методів). Нарешті, ви не можете додати методи
      по замовчанню до інтерфейсу, який ви не контролюєте.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Однак
      ви можете скомбінувати вигоди інтерфейсів та абстрактних класів, через
      провадження абстрактного <span class="Apple-converted-space"></span><em>класу
        скелетної реалізації</em><span class="Apple-converted-space"> </span>до
      інтерфейсу. Інтерфейс визначає тип, можливо провадячі деякі методи по
      замовчанню, тоді як клас скелетної реалізації реалізує залишок неприватних
      методів інтерфейсу зверху примітивних методів інтерфейсів. Розширення
      скелетної реалізації робить більшість більшість роботи щодо реалізації
      інтерфейсу. Це є шаблоном <em>Метода шаблона (Template Method</em><span class="Apple-converted-space">)</span>
      [<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">За
      домовленістю класи скелетної реалізації називаються <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Abstract</code><em>Interface</em>,
      де<span class="Apple-converted-space"> </span><em>Interface</em><span class="Apple-converted-space">
        є ім'ям інтерфейсу, який вони реалізують</span>. Наприклад, Collections
      Framework провадить скелетну реалізацію, що іде разом з інтерфейсом кожної
      колекції:<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">AbstractCollection</code>,<code
        style="font-family: 'Courier New', monospace;"> AbstractSet</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">AbstractList</code>,
      <span class="Apple-converted-space">та </span><code style="font-family: 'Courier New', monospace;">AbstractMap</code>.
      Можливо мало б сенс назвати їх<span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">SkeletalCollection</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">SkeletalSet</code>,
      <code style="font-family: 'Courier New', monospace;">SkeletalList</code>,
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">SkeletalMap</code>,
      але домовленість щодо<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Abstract</code><span
        class="Apple-converted-space"> тепер вже міцно закріпилась</span>. Коли
      гарно розроблена, скелетна реалізація&nbsp; (чи то окремий абстрактний
      клас, або це складається лише з методів по замовчанню на інтерфейсі) може
      зробити <em>дуже </em>простим для програмістів провадити свої власні
      реалізації інтерфейсу. Наприклад, ось статичний метод-фабрика, що містить
      повний, повністю функціональний реаліз <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code>impl зверху<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">AbstractList</code>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch4_images.xhtml#pch4ex22a" id="pch4ex22" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Суцільна
        реалізація, побудована зверху скелетної реалізації</strong><br>
      static List&lt;Integer&gt; intArrayAsList(int[] a) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Objects.requireNonNull(a);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Оператор діаманта легальний тільки в Java 9 та
      пізніших.<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Якщо ви використовуєте ранішній реліз, вкажіть
      &lt;Integer&gt;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return new AbstractList<strong>&lt;&gt;</strong>()
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public Integer
      get(int i) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      a[i];&nbsp;&nbsp;// Автобоксинг (<a href="ch2.xhtml#lev6" style="text-decoration: none;">Елемент
        6</a>)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public Integer
      set(int i, Integer val) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int
      oldVal = a[i];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[i]
      = val;&nbsp;&nbsp;&nbsp;&nbsp; // Авто-анбоксинг<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      oldVal;&nbsp;&nbsp;// Автобоксинг<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Override public int
      size() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      a.length;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;};<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви зрозумієте все, що реалізація <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code><span class="Apple-converted-space">
        робить для вас</span>, цей приклад стане вражаючою демонстрацією
      потужності скелетної реалізації. Випадково, але цей приклад також є <em>Адаптером</em>
      (<span class="Apple-converted-space"></span><em>Adapter</em><span class="Apple-converted-space">)
      </span>[<a href="ref.xhtml#rGamma95" style="text-decoration: none;">Gamma95</a>],
      що дозволяє масиву <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">int</code><span
        class="Apple-converted-space"> виглядати як список примірників </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Integer</code>.
      Оскільки всі перетворення взад і вперед між значеннями <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">int</code><span class="Apple-converted-space">,
        та примірниками </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Integer</code> (боксинг
      та анбоксинг), його продуктивність не є дуже доброю. Зауважте, що
      реалізація приймає форму <em>анонімного класу</em><span class="Apple-converted-space"></span>
      (<a href="ch4.xhtml#lev24" style="text-decoration: none;">Елемент 24</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_101"></span>Привабливість класів
      скелетної реалізації в тому, що вони провадять всі можливості допомоги від
      абстрактних класів, без накладання багатьох обмежень, які накладають
      абстрактні класи, коли вони виступають як визначення класів. Для більшості
      реалізаторів інтерфейсу з класом скелетної реалізації, розширення цього
      класу є очевидним вибором, але є цілком опціональним. Якщо клас не може
      бути зроблений так, щоб розширювати скелетну реалізацію, клас завжди може
      реалізувати клас напряму. Клас все ще має вигоди від любого методу,
      представленому на самому інтерфейсі. Більше того, скелетна реалізація все
      ще може допомогти в справі реалізатора інтерфейса. Клас, що реалізує
      інтерфейс, може переправити виклики методів інтерфейсу до включеного
      примірника приватного внутрішнього класу, що розширює скелетну реалізацію.
      Цей прийом, відомий як <em>симульоване множинне наслідування, </em>близько
      пов'язане до ідиоми класу-огортки, описаної в <span class="Apple-converted-space"></span><a
        href="ch4.xhtml#lev18" style="text-decoration: none;">Елементі 18</a>.
      Він провадить багато з переваг множинного наслідування, при тому уникаючи
      пасток.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Написання
      скелетних реалізацій є відносно простим, та дещо тонким процесом. Зпершу,
      вивчіть інтерфейс, та з'ясуйте, які методи є примітивами в термінах того,
      які з інших можуть бути реалізовані. Ці примітиви будуть абстрактними
      методми в вашій скелетній реалізації. Далі провадьте методи по замовчанню
      в інтерфейсі для кожного з методів, що можуть бути реалізовані прямо на
      примітивах, але розумійте, що ви но можете провадити методи по замовчанню
      для методів <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code><span
        class="Apple-converted-space">, таких, як </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>.
      Якщо примітиви та методи по замовчанню покривають інтерфейс, ви скінчили,
      та вам не треба клас скелетної реалізації. Інакше напишіть клас,
      декларований для реалізації інтерфейсу, з реалізацією всіх залишених
      методів інтерфейсу. Клас може містити любі непублічні методи, що треба для
      його завдань.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      простий приклад розглянемо інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map.Entry</code>. Явні
      примітиви це <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">getKey</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">getValue</code>,
      та (опціонально)<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">setValue</code>.
      Інтерфейс задає поведінку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">equals</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      та є очевидна реалізація <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toString</code><span class="Apple-converted-space">
        в термінах примітивів</span>. Оскільки вам не дозволяється провадити
      реалізації по замовчанню для методів<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Object</code>, всі
      реалізації розміщуються в класі скелетної реалізації:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Клас
        скелетної реалізації</strong><br>
      public abstract class AbstractMapEntry&lt;K,V&gt;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implements
      Map.Entry&lt;K,V&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Входження в модифікабельній мапі мають
      перекривати цей метод<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public V setValue(V value) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      UnsupportedOperationException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <span epub:type="pagebreak" id="page_102"></span>&nbsp;&nbsp;&nbsp;&nbsp;//
Реалізує
      загальний контракт Map.Entry.equals<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public boolean equals(Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (o == this)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(o instanceof
      Map.Entry))<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Map.Entry&lt;?,?&gt; e =
      (Map.Entry) o;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      Objects.equals(e.getKey(),&nbsp;&nbsp;getKey())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;&amp;
      Objects.equals(e.getValue(), getValue());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Реалізує загальний контракт Map.Entry.hashCode<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public int hashCode() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      Objects.hashCode(getKey())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^
      Objects.hashCode(getValue());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public String toString() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return getKey() + "=" +
      getValue();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що скелетна реалізація не може реалізувати інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map.Entry, або в якості
        субінтерфейсу, оскільки методам по замовчанню не дозволяється
        перекривати методи </code><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        такі, як </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">equals</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">hashCode</code>,
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">toString</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскільки
      скелетні реалізації розроблені для наслідування, вам слід слідувати всім
      настановам щодо розробки та документації в <span class="Apple-converted-space"></span><a
        href="ch4.xhtml#lev19" style="text-decoration: none;">Елементі 19</a>.
      Задля краткості з попереднього прикладу прибрані документуючі коментарі,
      але <span class="Apple-converted-space"></span><strong>гарна документація
        абсолютно потрібна для скелетної реалізації, </strong>чи містить методи
      по замовчанню на інтерфейсі, або це абстрактний клас.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мінорним
      різновидом скелетної реалізації є <em>проста реалізація,&nbsp; </em>з
      прикладом в вигляді <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">AbstractMap.SimpleEntry</code>.
      Проста реалізація подібна до скелетної реалізації, в тій частині, що вона
      реалізує інтерфейс, та розроблена для наслідування, але відрізняється в
      тому, що вона не абстрактна: вона є простіша реалізація з можливих. Ви
      можете використати її як вона є, або створити субклас, як вимагатимуть
      обставини.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      підсумувати, інтерфейс загалом є кращим шляхом для визначення типу, що
      дозволить численні реалізації. Якщо ви експортуєте нетривіальний
      інтерфейс, вам слідує гарно придивитись до провадження скелетної
      реалізації, щоб владнати це. До можливих меж вам слідує провадити скелетні
      реалізації через методи по замовчанню на інтерфейсі, так що всі
      реалізатори інтерфейсу зможуть використавувати його. Але при всьому цьому,
      обмеження інтерфейсів типово змушують, щоб скелетна реалізація приймала
      форму абстрактного класу. </p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_103"></span><strong>Елемент 21:
        Розробляйте інтерфейси для потомків</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">До
      Java 8 було неможливим додати методи до інтерфейсу, щоб при цьому не
      поламати існуючі реалізації. Якщо ви додасте новий метод до інтерфейсу,
      існуючім реалізаціям, загалом, буде бракувати метода, що призведе до
      помилки часу компіляції. В Java 8 булоа додана конструкція <em>метода по
        замовчанню</em> [<a href="ref.xhtml#rJLS" style="text-decoration: none;">JLS
        9.4</a>], з гадкою додавати методів до існуючих інтерфейсів. Але
      додавання нових методів доя існуючих інтерфейсів пов'язане з ризиком.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Декларація
      метода по замовчанню включає <em>реалізацію метода, </em>що
      використовується всіма класами, що реалізують інтерфейс, але не реалізують
      метод по замовчанню. Хоча додавання метода по замовчанню до Java робить
      можливим додавати методи до існуючого інтерфейсу, немає гарантії, що ці
      методи будуть робити з усіма попередніми реалізаціями. Метод по замовчанню
      “вводиться” в існуючі реалізації, без знання або згоди від їхніх
      реалезаторів. До Java 8 ці реалізації були написані з мовчазним
      розумінням, що їх інтерфейси <em>ніколи </em>не отримають жодні нові
      методи.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      нових методів по замовчанню були додані до головних інтерфейсів колекцій в
      Java 8, в основному для спрощення використання лямбд (<a href="ch6.xhtml#ch6"
        style="text-decoration: none;">Глава&nbsp; 6</a>). Методи по замовчанню
      бібліотек Java є високоякісними реалізаціями загального використання, та в
      багатьох випадках гарно роблять. Але <strong>не завжди можливо написати
        метод по замовчанню, що підтримує всі інваріанти кожної мислимої
        реалізації</strong><strong>.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наприклад,
      розглянемо метод<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">removeIf</code>,
      що був доданий до інтерфейсу<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Collection</code><span class="Apple-converted-space">
        в</span> Java 8. Цей метод видаляє всі елементи, для яких надана логічна
      функція (<em>предикат</em>) повертає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code>. Реалізація
      по замовчанню визначена для проходження колекції за допомогою ітерації,
      викликаючи для кожного предикат, та використовуючи метод ітератора <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">remove</code><span
        class="Apple-converted-space"> для видалення елементів, для яких
        предикат повертає </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">true</code>. Можливо,
      декларація виглядає дещо подібно до такого:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
метод
        по замовчанню, доданий до ітерфейсу Collection в Java 8</strong><br>
      default boolean removeIf(Predicate&lt;? super E&gt; filter) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Objects.requireNonNull(filter);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;boolean result = false;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (Iterator&lt;E&gt; it = iterator();
      it.hasNext(); ) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if
      (filter.test(it.next())) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it.remove();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result
      = true;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_104"></span>Це найкраща реалізація
      загального ужитку, що хтось міг би написати для метода <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">removeIf</code>, але
      сумно є те, що вона схиблює на деяких реалізаціях<code style="font-family: 'Courier New', monospace;">
        Collection</code><span class="Apple-converted-space"> з реального світу</span>.
      Наприклад, розглянемо<span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        клас org.apache.commons.collections4.-collection.SynchronizedCollection</code>.
      Цей клас з бібліотеки Apache Commons подібна до такої, що повертається зі
      статичної фабрики <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Collections.-synchronizedCollection</code><span
        class="Apple-converted-space"> </span>в <code style="font-family: 'Courier New', monospace;">java.util</code>.
      Версія від Apache додатково провадить можливість використовувати надані
      клієнтом об'єкти для блокування, замість колекції. Іншими словами, це
      клас-огортка (<a href="ch4.xhtml#lev18" style="text-decoration: none;">Елемент
        18</a>), всі методи якого синхронізуються на блокуючому об'єкті, до
      делегування до огорнутої колекції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Клас
      Apache<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">SynchronizedCollection</code><span
        class="Apple-converted-space"> все ще активно підтримується, але на час
        написання, він не перекриває метод </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">removeIf</code>. Якщо
      клас використовується одночасно з Java 8, він буде наслудвати реалізацію
      по замовчанню <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">removeIf</code>,
      що <em>не підтримує, а дійсно і не може підтримувати</em>, головну
      обіцянку класу: автоматичну синхронізацію для кожного виклику метода.
      Релізація по замовчанню нічого не знає щодо синхронізації, та не має
      доступу до поля, що містить блокуючий об'єкт. Якщо клієнт викликає метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">removeIf</code><span
        class="Apple-converted-space"> не примірнику </span><code style="font-family: 'Courier New', monospace;">SynchronizedCollection</code><span
        class="Apple-converted-space">, в присутності конкурентної модифікації
        колекції іншим потоком, результатом буде </span><code style="font-family: 'Courier New', monospace;">ConcurrentModificationException</code><span
        class="Apple-converted-space"> або інша непередбачувана поведінка</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      це не трапилось в подібних реалізаціях бібліотек платформи Java, таких, як
      пакунок-приватні класи, що повертаються <code style="font-family: 'Courier New', monospace;">Collections.synchronizedCollection</code>,
      підтримка&nbsp; JDK має перекривати реалізацію по замовчанню <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">removeIf</code><span class="Apple-converted-space">,
        та інших методів, як цей, щоб виконати потрібну синхронізацію перед
        викликом реалізації по замовчанню</span>. Існуючі реалізації колекції,
      що не є частиною платформи Java, не мали шансів зробити аналогічні зміни
      разом зі зміною інтерфейсу, та деякі ще не зробили це і досі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>В
        присутності методів по замовчанню, існуючі реалізації інтерфейсу можуть
        компілюватись або видавати попередження, але випадати від час виконання.
      </strong>Хоча не жахливо загально, ця проблема, однак, не є ізольованим
      інцендентом. Досить методів, доданих до інтерфейсів колекцій в Java 8,
      відомі як подозірлі, та декілька існуючих реалізацій відомі, як такі, що
      зазнали впливу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Використання
      методів по замовчанню, щоб додавати нові методи до існуючих інтерфейсів,
      слід уникати, якщо це не вкрай критично, в якому випадку ви повинні довго
      та кріпко подумати щодо того, чи може бути поломана існуюча реалізація
      інтерфейсу через ваш метод по замовчанню. Однак методи по замовчанню вкрай
      корисні для впровадження стандартних реалізацій методів при створенні
      інтерфейсу, щоб спростити завдання реалізації інтерфейсу (<a href="ch4.xhtml#lev20"
        style="text-decoration: none;">Елемент 20</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Також
      зрозуміло, що методи по замовчанню не були розроблені для видалення
      методів з інтерфейсів, або зміни сигнатур існуючих методів. Жодна з ціх
      змін інтерфейсів не можлива без руйнування існуючих клієнтів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Мораль
      ясна. Навіть якщо вважати, що методи по замовчанню тепер є частиною
      платформи Java,<span class="Apple-converted-space"> </span><strong>все ще
        вкрай важливо розробляти інтерфейси з великою обережністю.</strong><span
        class="Apple-converted-space"> Хоча методи по замовчанню роблять <em>можливим
          </em>додавати методи до існуючих інтерфейсів, робити це залишається
        великим ризиком. Якщо інтерфейс має невеликий дефект, це може
        роздратувати користувачів назавжди</span>; якщо інтерфейс значно
      пошкоджений, це може зробити жахливим API, що містить його.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Таким
      чином, є критично важливим протестувати кожний новий інтерфейс перед його
      релізом. Декілька програмістів мають реалізувати кожний інтерфейс в різний
      спосіб. Як мінімум, вам слідує націлитись на три різні реалізації. Так
      само важливо написати три клієнтські програми, що використовують
      примірники кожного нового інтерфейса, що виконують різні завдання. Можна
      пройти довгий шлях переконання, що кожний інтерфейс задовільня всім його
      призначеним використанням. Ці кроки дозволять вам знайти прогалини в
      інтерфейсах, до того, як вони будуть випущені, та ви зможете легко
      випарвити їх. <span class="Apple-converted-space"></span><strong>Хоча
        може бути можливим полагодити деякі прогалини інтерфейса після того, як
        вони будуть випущені, ви не можете розрахувувати на це</strong>.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_106"></span><strong>Елемент 22:
        Використовуйте інтерфейси тільки для визначення типів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      клас реалізує інтерфейс, інтерфейс прислуговується як <em>тип, </em>що
      може бути використаний для посилання на примірники класу. Цей клас, що
      реалізує інтерфейс, таким чином має сказати дещо про те, що клієнт може
      робити з примірниками класу. Є неприйнятним визначати інтерфейс для
      будь-якої іншої цілі.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Один
      з різновидів інтерфейсу, що не проходить цей тест, є так званий <em>інтерфейс
        констант. </em>Такий інтерфейс не має методів, він містить тільки
      статичні фінальні поля, кожне з яких експорує константу. Класи, що
      використовують ці константи, реалізують наслідування, щоб уникнути потреби
      задавати імена констант з іменем класу. Ось приклад:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Інтерфейс
        констант, антішаблон, не використовувати!</strong><br>
      public interface PhysicalConstants {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Число Авокадо (1/mol)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static final double AVOGADROS_NUMBER&nbsp;&nbsp; =
      6.022_140_857e23;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Константа Больцмана (J/K)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static final double BOLTZMANN_CONSTANT =
      1.380_648_52e-23;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Маса електрона (kg)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static final double
      ELECTRON_MASS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 9.109_383_56e-31;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Інтерфейс
        конатант є хибним використанням інтерфейсів.</strong><span class="Apple-converted-space">
        Те, що клас внутрішньо використовує деякі константи є деталлю
        реалізації. Реалізація інтерфейсу констант викликає факт, що ця деталь
        реалізації має витік в експортований </span>API класу. Для користувачів
      класу немає наслідків в тому, що клас реалізує інтерфейс констант.
      Фактично, це може лише засмутити їх. Гірше того, якщо майбутній реліз
      класу модифікується так, що він більше не потребуватиме констант, він все
      ще має реалізувати інтерфейс, щоб забезпечити бінарну сумісність. Якщо
      нефінальний клас реалізує інтерфейс констант, всі його субкласи будуть
      мати власні простори імен забруднені константами з інтерфейсу.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Є
      декілька інтерфейсів констант в бібліотеках платформи Java, такі як<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">java.io.ObjectStreamConstants</code>.
      Ці інтерфейси мають розглядатись як аномалії, та не мають бути взірцем. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви бажаєте експортувати константи, є декілька розумних варіантів. Якщо
      константи сильно прив'язані до існуючого класа, вам слідує додати їх до
      класа або інтерфейса. Наприклад, всі боксовані числові примітивні типи,
      такі як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Integer</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Double,</code><span
        class="Apple-converted-space"> експортують константи </span><code style="font-family: 'Courier New', monospace;">MIN_VALUE</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">MAX_VALUE</code>.
      Якщо константи краще виглядають як числа в типі переліку, вам слідує
      експортувати іх в типі <span class="Apple-converted-space"></span><em>enum
        </em>(<a href="ch6.xhtml#lev34" style="text-decoration: none;">Елемент
        34</a>). Інакше, вам слідує експортувати константи в нестворюваному <em>допоміжному
        класі </em>(<a href="ch2.xhtml#lev4" style="text-decoration: none;">Елемент
        4</a>). Ось версія допоміжного класу прикладу <code style="font-family: 'Courier New', monospace;">PhysicalConstants</code><span
        class="Apple-converted-space">, показаного раніше</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Допоміжний клас констант</strong><br>
      package com.effectivejava.science;<br>
      <br>
      public class PhysicalConstants {<br>
      &nbsp;&nbsp;private PhysicalConstants() { }&nbsp;&nbsp;// Запобігає
      утворенню екземплярів<br>
      <br>
      &nbsp;&nbsp;public static final double AVOGADROS_NUMBER =
      6.022_140_857e23;<br>
      &nbsp;&nbsp;public static final double BOLTZMANN_CONST&nbsp;&nbsp;=
      1.380_648_52e-23;<br>
      &nbsp;&nbsp;public static final double
      ELECTRON_MASS&nbsp;&nbsp;&nbsp;&nbsp;= 9.109_383_56e-31;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">До
      речі зауважте використання символу підкреслення (<code style="font-family: 'Courier New', monospace;">_</code>)
      в числових літералах. Підкреслення, що стало легальним починаючи з Java 7,
      не впливають на значення числових літералів, але роблять їх значно
      простішим для читання, при вірному використанні. Розгляньте додавання
      підкреслень до числових літералів, чи цілих, чи з плаваючою крапкою, якщо
      вони містять п'ять або більше цифр поспіль. Для літералів по базі десять,
      цілих або з плаваючою крапкою, вам треба використовувати підкреслення для
      від'єднання літералів групами по три цифри, що відповідають додатнім та
      від'ємним тисяч.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Звичайно
      допоміжний клас потребує, щоб клієнти кваліфікували імена констант назвою
      класу, наприклад,&nbsp;<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">PhysicalConstants.AVOGADROS_NUMBER</code>.
      Якщо ви дуже викорисовуєте експортовані константи з допоміжного класу, ви
      можете уникнути кваліфікації констант назвою класу, скориставшись
      можливістю <em>статичного імпорта</em>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Використання статичного імпорта для уникнення кваліфікації констант</strong><br>
      import static com.effectivejava.science.PhysicalConstants.*;<br>
      <br>
      public class Test {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;double&nbsp;&nbsp;atoms(double mols) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return AVOGADROS_NUMBER *
      mols;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Значно більше використань PhysicalConstants
      виправдовують static import<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, інтерфейси мають використовуватись лише для визначення типів.
      Вони не мають використовуватись просто для експорту констант.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемент
      <strong>23: Схиляйтесь до ієрархій класів, замість відмічених класів</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">З
      часом ви можете зустріти клас, чиї примірники ідуть в двох варіантах, та
      містять поле <span class="Apple-converted-space"></span><em>tag</em><span
        class="Apple-converted-space">, що вказує на різновид примірника.
        Наприклад, розглянемо клас, що може посилатись на коло або на
        прямокутник</span>:</p>
    <span epub:type="pagebreak" id="page_109" style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"></span><span
      style="font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; display: inline !important; float: none;"></span>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Відмічені
        класи - значно гірше за ієрархію класів!</strong><br>
      class Figure {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;enum Shape { RECTANGLE, CIRCLE };<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Поле тегу - форма цієї фігури<br>
      &nbsp;&nbsp;&nbsp;&nbsp;final Shape shape;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Ці поля використовуються тільки для фігури
      RECTANGLE<br>
      &nbsp;&nbsp;&nbsp;&nbsp;double length;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;double width;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Це поле використовується тільки для фігури
      CIRCLE<br>
      &nbsp;&nbsp;&nbsp;&nbsp;double radius;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Конструктор для кола<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Figure(double radius) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape = Shape.CIRCLE;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.radius = radius;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// Конструктор для прямокутника<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Figure(double length, double width) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shape = Shape.RECTANGLE;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;double area() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(shape) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case
      RECTANGLE:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      length * width;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case CIRCLE:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      Math.PI * (radius * radius);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new AssertionError(shape);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Такі
      <em>помічені класи </em>мають декілька недоліків. Вони захаращені
      загальним кодом, включаючи декларації enum, поля тегів, та твердження
      switch. Також ще більше страждає читабельність, бо декілька реалізацій
      знаходяться разом в одному класі. Збільшуються витрати пам'яті, оскільки
      примірники захаращені не маючими відношення полями, що відносяться до
      інших різновидів. Поля не можуть бути зроблені фінальними, за винятком
      коли конструктори ініціалізують на маючі відношення поля, що ще збільшує
      брудний код. Конструктори мають встановити поле тегу, і ініціалізувати
      відповідні поля, без допомоги компілятора: якщо ви ініціалізуєте навірні
      поля, програма схибить під час виконання. Ви не можете додати різновид
      поміченого класу без модифікації його первинних файлів. Якщо ви додаєте
      різновид, ви маєте пам'ятати додати гілку до кожного твердження switch,
      або клас схибить під час виконання. Нарешті, тип даних примірника не
      отримає допомоги щодо свого походження. Коротко кажучи, <span class="Apple-converted-space"></span><strong>помічені
        класи балакливі, схильні до помилок, та неефіктивні.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Нащастя,
      об'єктно-орієнтовані мови, як Java, надають кращу альтернативу для
      визначення окремого типу даних, здатного представляти об'єкти декількох
      різновидів: створення субтипів.<span class="Apple-converted-space"> </span><strong>Помічені
        класи є лише блідою імітацією ієрархії класів.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      перетворити помічені класи на ієрархію класів, зпочатку визначте
      абстрактний клас, що має абстрактний метод для кожног ометода в поміченому
      класі, чия поведінка залежить від значення тегу. В класі<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Figure</code><span
        class="Apple-converted-space"> існує лише один такий метод, </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">area</code>.
      Цей абстрактний клас є коренем ієрархії класів. Якщо є якісь методи, чия
      поведінка не залежить від значення тегу, покладіть їх в цей клас. Подібно,
      якщо існують любі поля даних, що використовуютсья всіма різновидами,
      покладіть їх в цей клас. Таких різновид-незалежних класів або полів не
      існує в нашому класі <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Figure</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Далі
      визначте суцільний субклас кореневого класу для кожного різновиду
      оригінального поміченого класу. В нашому прикладі таких двоє: коло та
      прямокутник. Включіть в кожний субклас поля даних для даного різновиду. В
      цьому прикладі це <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">radius</code><span
        class="Apple-converted-space"> специфічне для кола</span>, та <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">length</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">width</code><span
        class="Apple-converted-space"> спеціфічні для прямокутника</span>. Також
      включіть в кожний субклас відповідну реалізацію абстрактних методів
      кореневого класа. Ось ієрархія класів, відповідна для до оригінального
      класу<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Figure</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Ієрархія
        класів на заміну поміченого класу</strong><br>
      abstract class Figure {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;abstract double area();<br>
      }<br>
      <br>
      class Circle extends Figure {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;final double radius;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;Circle(double radius) { this.radius = radius; }<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override double area() { return Math.PI * (radius
      * radius); }<br>
      }<br>
      <span epub:type="pagebreak" id="page_111"></span>class Rectangle extends
      Figure {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;final double length;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;final double width;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;Rectangle(double length, double width) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width&nbsp;&nbsp;=
      width;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override double area() { return length * width; }<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      ієрархія класів корегує всі недоліки помічених класів, які ми назвали
      раніше. Код став простіший та ясний, що не містить ніякого зайвого з
      оригіналу. Реалізація кожного різновиду отримала свій власний клас, та
      ніякий з ціх класів не обтяжений не маючими відношення полями.&nbsp; Всі
      поля є фінальними. Компілятор забезпечує, що конструктори класів
      ініціалізують свої поля даних, та що кожна реалізація для кожного
      абстрактного метода&nbsp; декларована для кожного абстрактного метода
      кореневого класу. Це виключає можливість збою під час виконання через
      відсутність гілки switch. Декілька програмістів можуть розширювати
      ієрархію незалежно та взаємодіючи, маючи тільки доступ до кореневого
      класу. З кожним різновидом асоційований власний тип, що дозволяє
      програмістам вказувати різновид змінної, та обмежувати змінні та вхідні
      параметри до певного різновиду.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Інша
      перевага ієрархій класів в тому, що вони можуть відзеркалювати природні
      ієрархічні відношення між типами, дозволяючи додаткову гнучкість та кращу
      перевірку під час компіляції. Уявіть помічений клас в оригінальному
      прикладі, що також дозволяє квадрати. Ієрархія класів може відзеркалювати
      той факт, що квадрат є особливим випадком прямокутника (вважаємо, що обоє
      є незмінні):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">class
      Square extends Rectangle {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Square(double side) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(side, side);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що поля в показаній ієрархії мають прямой доступ, скоріше, ніж через
      методи аксессорів. Це було зроблене для краткості, та може бути слабким
      дизайном, якщо ієрархія була б публічною (<a href="ch4.xhtml#lev16" style="text-decoration: none;">Елемент
        16</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, помічені класи рідко є доречними. Якщо ви впадаєте в спокусу
      написати клас з явним полем тегу, подумайте, як ви можете уникнути цього
      тегу, та замінити клас на ієрархію. Коли ви натрапите на існуючий клас з
      полем тега, подивіться, як можна зробити його рефакторинг.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_112"></span><strong>Елемент 24: Обирайте
        статичні члени класів, замість нестатичних</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>Вкладені
        класи </em>є класами, що визначені в іншому класі. Вкладений клас
      повинен існувати тільки для прислуговання оточующому класові. Якщо
      вкладений клас може бути корисним в деякому іншому контексті, тоді він має
      бути класом верхнього рівня. Існує чотири типи вкладених класів:<span class="Apple-converted-space">
      </span><em>статичні члени класів</em>,<span class="Apple-converted-space">
        <em>нестатичні члені класів, анонімні класи, та локальні класи. </em></span>Всі,
      крім першого типу, відомі як <em>внутрішні класи</em>. Цей елемент
      розкаже вам, коли використовувати кожний тип вкладених класів, і чому.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Статичний
      клас-член є простішим різновидом вкладеного класа. Краще думати про нього
      як про звичайний клас, якому трапилось бути декларованим в іншому класі,
      та мати доступ до членів оточующого класу, навіть якщо воні визначені
      приватними. Статичний клас-член є статичним членом оточующого класу, та
      підкоряється тим же правилам доступності, що і іншу статичні методи. Якщо
      він декларований приватним, він доступний тільки в оточующому класі, і так
      далі. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Одне
      загальне використання статичних членів-класів є публічн класи хелпери,
      корисні тільки в поєднанні з зовнішнім класом. Наприклад, розглянемо enum,
      що описує операції, підтримувані калькулятором (<a href="ch6.xhtml#lev34"
        style="text-decoration: none;">Елемент 34</a>). <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Operation</code><span class="Apple-converted-space">&nbsp;</span>enum
      повинне бути публічним статичним членом класу. Клієнти <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Calculator</code><span class="Apple-converted-space">
        потім можуть посилатись на оерації, використовуючи імена як </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Calculator.Operation.PLUS</code><span
        class="Apple-converted-space">&nbsp;</span>and<code style="font-family: 'Courier New', monospace;">Calculator.Operation.MINUS</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Синтаксично,
      одна різниця між статичними та нестатичними членами класів в тому, що
      статичні члени-класи мають модифікатор <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">static</code><span class="Apple-converted-space">
        в своїй декларації</span>. Не зважаючи на синтаксичну подібність, ці два
      вкладених класи дуже подібні. Кожинй примірник нестатичного члена-класа
      неявно асоційований з <em>оточуючим примірником містячого його класа</em>.
      В методах примірника нестатичного члена-класа ви можете викликати методи
      на оточуючому примірнику, або отримати посилання на оточуючий примірник з
      використанням конструкції <em>кваліфікованого&nbsp;</em><em> this</em><span
        class="Apple-converted-space"> </span>[JLS, 15.8.4]. Якщо примірник
      вкладеного класу може існувати в ізоляції від примірника оточуючого класу,
      тоді вкладений клас <em>мусить </em>бути статичним членом-класом:
      неможливо створити примірник нестатичного члена-класа без оточуючого
      примірника.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Асоціація
      між приірником нестатичного члена-класа, та його оточуючим примірником
      встановлюється, коли примірник член-класа створюється, і після цього це не
      може бути модифіковане. Звичано, асоціація встановлюється автоматично,
      через виклик конструктора нестатичного члена-класа з метода примірника
      оточуючого класа. Можливо, хоча і рідко, встановити асоціацію вручну,
      використовуючи вираз <code style="font-family: 'Courier New', monospace;">enclosingInstance.new
        MemberClass(args)</code>. Як ви могли очікувати, асоціація&nbsp; займає
      місце в нестатичному примірнику члена-класа, та додає час до його
      конструктора. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_113"></span>Одне з використань
      нестатичних членів-класів є визначення адаптера <span class="Apple-converted-space"></span><em>Adapter</em><span
        class="Apple-converted-space">&nbsp;</span>[<a href="ref.xhtml#rGamma95"
        style="text-decoration: none;">Gamma95</a>], що дозволяє примірнику
      зовнішнього класа виглядати як примірник якогось непов'язаного класа.
      Наприклад, реалізації інтерфейса <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map</code><span class="Apple-converted-space">
        типово використовують нестатичні члени-класи для реалізації своїх </span><em>виглядів
        колекцій</em>, що повертається від методами <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map:</code><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">keySet</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">entrySet</code>,
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">values</code>.
      Подібно, реалізації інтерфейсів колекцій, такі як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">List</code>,
      типово використовують нестатичні члени-класи для реалізації своїх
      ітераторів:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Типове використання нестатичних членів-класів</strong><br>
      public class MySet&lt;E&gt; extends AbstractSet&lt;E&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // Bulk of the class omitted<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;@Override public Iterator&lt;E&gt; iterator() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new MyIterator();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>private class MyIterator implements
        Iterator&lt;E&gt;</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Якщо
        ви декларуєте член-класс, що не потребує доступу до оточуючого
        примірника, <em>завжди </em>покладайте модифікатор </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>static</strong></code><span
        class="Apple-converted-space"> </span><strong>до його декларації,</strong><span
        class="Apple-converted-space"> роблячи його статичним, скоріше ніж
        нестатичним членом-класом</span>. Якщо ви уникните цього модифікатора,
      кожний примірник буде мати приховане стороннє посилання на його оточуючий
      клас. Як зазначалось перед цім, зберігання цього посилання витрачає час і
      місце. Що більше серйозно, це може призвести до того, що оточуючий
      примірник буде залишатись тоді, коли інакше він міг би бути прибраний
      збірником сміття (<a href="ch2.xhtml#lev7" style="text-decoration: none;">Елемент
        7</a>). Результуючий витік пам'яті може бути катастрофічним. Це часто є
      складним визначити, оскільки посилання невидиме. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Загальне
      використання приватних статичних членів-класів є представлення компонентів
      об'єкта оточуючого класа. Наприклад, розглянемо примірник <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map</code>, що асоціює
      ключі зі значеннями. Багато реалізацій <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Map</code><span class="Apple-converted-space">
        мають внутрішній об'єкт&nbsp;</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Entry</code><span
        class="Apple-converted-space"> для кожної пари ключ-значення в мапі.
        Хоча кожне входження асоційоване з мапою, методи входжень</span> (<code
        style="font-family: 'Courier New', monospace;">getKey</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">getValue</code>,<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">setValue</code>)
      не потребують доступу до мапи. Таким чином, це буде марнотратством
      використовувати нестатичний член-клас для представлення входжень:
      приватний статичний член-клас є кращим. Якщо ви випадково випустите
      модифікатор<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">static</code><span
        class="Apple-converted-space"> в визначенні входження, </span>мапа все
      ще буде робити, але кожне входження буде містити надлишкове посилання на
      мапу, що розтринькує місце та час.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Вдвічи
      важливо обрати правильно між статичним та нестатичним членом-класом, якщо
      розглядаємий клас є публічним або захищеним членом експортованого класу. В
      цьому випадку член-клас є експортованим елементом API, та не може бути
      змінений від нестатичного до статичного в наступних релізах без порушення
      зворотньої сумісності.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      ви можете очікувати, анонімні класи не мають імені. Вони не є членами
      оточуючого класу. Скоріше, ніж вони були декларовані разом з іншими
      членами, вони одночасно декларуються та створюють примірник в точці
      визначення. Анонімні класи дозволені в кожній точці коду, де допустимий
      вираз. Анонімні класи мають оточуючі примірники, тоді та тільки тоді, якщо
      вони отапляються в нестатичному контектсі. Але навіть якщо вони
      з'являються в статичному контексті, вони не можуть мати жодних статичних
      членів, крім <em>сталих змінних</em>, <em></em>що є фінальними
      примітивами, або рядковими полями, ініціалізованими сталими виразами [JLS,
      4.12.4].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існує
      багато обмежень на застосування анонімних класів. Ви не можете створювати
      їх примірники, за винятком точки де вони визначені. Ви не можете
      виконувати перевірки <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">instanceof</code><span
        class="Apple-converted-space">, або робити щось інше, що вимагає від вас
        назвати клас. Ви не можете декларувати анонімні класи для реалізації
        декількох інтерфейсів, або для розширення класу та розширення інтерфейсу
        одночасно</span>. Клієнти анонімного класу не можуть викликати жодні
      методи, за винятном тих, які він наслідує від супертипу. Оскільки анонімні
      класи трапляються посередині виразів, вони мають утримуватись короткими —
      біля десяти рядків або коротше — або страждатиме читабельність.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Перед
      тим, як були введені лямбда в Java (<a href="ch6.xhtml#ch6" style="text-decoration: none;">Глава
        6</a>), анонімні класи були кращим засобом для створення малих <em>функціональних
        об'єктів </em>та <em>процесс об'єктів </em>на льоту, але лямбди
      наразі є кращими (<a href="ch7.xhtml#lev42" style="text-decoration: none;">Елемент
        42</a>). Інше загальне використання анонімних класів є в реалізації
      статичних методів фабрик (дивіться<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">intArrayAsList</code><span
        class="Apple-converted-space"> в</span><span class="Apple-converted-space">
      </span><a href="ch4.xhtml#lev20" style="text-decoration: none;">Елементі
        20</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Локальні
      класи є найменьш часто використовувані з чотирьох типів вкладених класів.
      Локальні класи можуть бути декларовані практично будь-де, де може бути
      декларована локальна змінна, та дотримуються тих самих правил видимості.
      Локальні класи мають атрибути, загальні з усіма іншими типами вкладених
      класів. Як члени-класи, вони мають імена та можуть використовуватись
      повторно. Як анонімні класи, вони мають оточуючі примірники тільки якщо
      визначені в нестотичному контектсі, в вони не можуть містити статичні
      члени. І як анонімні класи, вони мають утримуватись короткими, так щоб не
      шкодити читабельності..</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      підсумка, існує чотири різні типи вкладених класів, і кожний має своє
      місце. Якщо вкладений клас потребує бути видимий за межами одного метода,
      або дуже довгий щоб комфортно розміститись в методі, використовуйте
      член-клас. Якщо кожний примірник члена-класа потребує посилання на
      оточуючий примірник, зробіть його нестатичним; інакше зробить його
      статичним. Вважаючи, що клас належить методу, якщо вам треба створити
      примірники тільки в одному місці, та є існуючий тип, що характеризує клас,
      зробіть його анонімним класом, інакше це локальний клас.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_115"></span><strong>Елемент 25: Обмежуте
        джерельні файли до єдиного класу вищого рівня</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      компілятор Java дозволяє вам визначати декілька високорівневих класів в
      єдиному файлі, немає вигод, асоційованих з такими вчинками, та існують
      суттєві ризики. Ризики походять від факту, що визначення декількох
      високорівневих класів в одному джерельному файлі робить можливим
      провадження декількох визначень для класа. На те, яке визначення буде
      використане, впливає порядок, в якому файли проходитимуть компілятор.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      зробити це конкретним, розгляньте цей джерельний файл, що містить тільки
      клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Main</code><span
        class="Apple-converted-space">, що посилається на члени двох інших
        високорівневих класів</span> (<code style="font-family: 'Courier New', monospace;">Utensil</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Dessert</code>):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Main {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Utensil.NAME
      + Dessert.NAME);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер
      уявімо, що ви визначити обоє,<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Utensil</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Dessert</code><span
        class="Apple-converted-space">, в одному файлі на ім'я</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Utensil.java</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Два класи, визначені в одному файлі. Ніколи не робіть цього!</strong><br>
      class Utensil {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static final String NAME = "pan";<br>
      }<br>
      <br>
      class Dessert {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;static final String NAME = "cake";<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Звичайно,
      головна програма друкує<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">pancake</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Тепер
      уявімо, що ви випадково зробили <em>інший </em>файл на ім'я <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Dessert.java</code><span
        class="Apple-converted-space">, що визначає ти самі два класа</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//&nbsp;</strong><strong>
        Два класи, визначені в одному файлі. Ніколи не робіть цього!</strong><br>
      class Utensil {<br>
      &nbsp;&nbsp;&nbsp; static final String NAME = "pot";<br>
      }<br>
      <br>
      class Dessert {<br>
      &nbsp;&nbsp;&nbsp; static final String NAME = "pie";<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви досить щасливі щоб скомпілювати програму за допомогою команди <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">javac Main.java
        Dessert.java</code>, компіляція схибить, та компілятор скаже вам, що ви
      повторно декларували класи <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Utensil</code><span class="Apple-converted-space">
        та</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Dessert</code>.
      Це так, бо компілятор спочатку скомпілює<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Main.java</code>,
      та потім він бачить посилання на<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Utensil</code><span class="Apple-converted-space">&nbsp;</span>(що
      іде перед посиланянм на<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Dessert</code>), він
      шукає цей клас в<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Utensil.java</code><span
        class="Apple-converted-space">, та знаходить обоє, </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Utensil</code><span class="Apple-converted-space">
        та </span><code style="font-family: 'Courier New', monospace;">Dessert</code>.
      Потім компілятор натрапляє в командному рядку <span class="Apple-converted-space"></span>на
      <code style="font-family: 'Courier New', monospace;">Dessert.java</code>,
      він підтягує цей файл також, так що бачить обоє визначень <code style="font-family: 'Courier New', monospace;">Utensil</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Dessert</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви скомпілюєте програму командою <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">javac Main.java</code><span
        class="Apple-converted-space"> або</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">javac
        Main.java Utensil.java</code>, вона буде поводитись як раніше, перед тим
      як ви написали файл <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Dessert.java</code>,
      друкуючи <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">pancake</code>.
      Але якщо ви скомпілюєте програму командою <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">javac Dessert.java
        Main.java</code>, вона буде друкувати <code style="font-family: 'Courier New', monospace;">potpie</code>.
      Поведінка програми знаходиться під впливом порядку, в якому файли
      передаються в компілятор, що очевидно неприпустиме.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Полагодження
      проблеми таке просте, як розділення класів вищого рівня&nbsp; (<code style="font-family: 'Courier New', monospace;">Utensil</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Dessert</code>,
      в випадку нашого приклада) в окремі файли. Якщо ви піддаєтесь спокусі
      покласти декілька класів вищого рівня в один джерельний файл, розгляньте
      можливість використання статичних членів-классів (<a href="ch4.xhtml#lev24"
        style="text-decoration: none;">Елемент 24</a>), як альтернативу
      розділення класів в окремі файли. Якщо класи підкорені іншому класу,
      перетворення їх на статичні члени загалом є кращою альтернативою, оскільки
      це розширює читабельність, та дає змогу зменшити доступ до класів, через
      декларування їх як private (<a href="ch4.xhtml#lev15" style="text-decoration: none;">Елемент
        15</a>). Ось як наш приклад виглядає зі статичними членами класів:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Статичні члени-класи замість декількох класів вищого рівня</strong><br>
      public class Test {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(Utensil.NAME
      + Dessert.NAME);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static class Utensil {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static final String NAME =
      "pan";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static class Dessert {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;static final String NAME =
      "cake";<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Урок
      ясний:<span class="Apple-converted-space"> <strong>ніколи не покладайте
          декілька файлів вищого рівня або інтерфейсів в один джерельний файл</strong></span><strong>.</strong><span
        class="Apple-converted-space"> Слідування цьому правилу гарантує, що ви
        не матимете декілька визначень для одного класа під час компіляції</span>.
      В свою чергу це гарантує, що файли класа, згенеровані під час копіляції,
      та поведінка результуючої програми, незалежні від порядку, в якому файли
      проходять компіляцію.</p>
    <p></p>
    <p> </p>
    <h2 class="h2" id="ch5" style="font-size: 29px; margin-top: 30px; margin-bottom: 30px; text-align: justify; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Глава
      5. Дженеріки</h2>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong></strong><span
        class="Apple-converted-space"></span> З Java 5 дженеріки стали частиною
      мови. До дженериків ми мали приводити кожний об'єкт, який ми читали з
      колекції. Якщо хтось випадково вставляв об'єкт невірного типу, приведення
      могло схибити під час виконання. З дженериками ви кажете компілятору, які
      типи об'єктів дозволені для кожної колекції. Компілятор вставляє кастинг
      за вас автоматично, та каже вам <em>під час компіляції, </em>якщо ви
      намагаєтесь вставити об'єкт не того типу. Це призводить до програм, що
      одночасно безпечніші та ясніші, але ці переваги, що не обмежуються
      колекціями, мають свою ціну. Ця глава каже вам, як максимізувати переваги,
      та мінімізувати ускладнення.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Елемент<strong>
        26: не використовуйте сирі типи</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зпочатку
      декілька термінів. Клас або інтерфейс, чия декларація має один або більше
      <em>параметр типу </em>є <em>дженерік класом або інтерфейсом</em> [JLS,
      8.1.2, 9.1.2]. Наприклад, інтерфейс <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code><span class="Apple-converted-space">
        має один параметр типу, </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">E</code>, що предсатвляє
      тип його елементів. Повне ім'я інтерфейсу є<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(читається “список з <code style="font-family: 'Courier New', monospace;">E</code>”),
але
      люди часто для краткості кажуть просто <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code>. Дженерік
      класи та інтерфейси загалом відомі як <em>дженерік типи</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Кожний
      дженерік тип визначає набір <em>параметризованих типів</em>, що
      складається з імені типу або інтерфейсу, за якім слідують кутові дужки зі
      списком <em>дійсних параметрів типу</em><span class="Apple-converted-space">,
        що відповідають до формальних параметрів типів дженерік типу</span>
      [JLS, 4.4, 4.5]. Наприклад, <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(читається “список з рядків”)
      є параметризований тип, що представляє список, чиї елементи мають тип <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">String</code>.
      (<code style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        є справжнім параметром типу, відповідаючий до формального параметру типу
      </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">E</code>.)</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Нарешті,
      кожний дженерік тип визначає <em>сирий тип, </em>який є іменем дженерік
      типу, без супроводжуючих параметрів типів [JLS, 4.8]. Наприклад, сирий тип
      відповідний до <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code><span
        class="Apple-converted-space"> є</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List</code>.
      Сирі типи поводяться так, якби інформація дженерік типів була затертою з
      декларації типу. Вони існують здебільшого для сумісності з
      до-дженеріківським кодом.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Перед
      тим, як дженеріки були додані до Java, це було зразковою декларацією
      колекції. На час Java 9 це все ще легально, але далеко від зразковості:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Сирі
        типи колекції - не робіть це!</strong><br>
      <br>
      // Моя колекція stamp. Містить тільки примірники Stamp.<br>
      private final<span class="Apple-converted-space">&nbsp;</span><strong>Collection</strong><span
        class="Apple-converted-space">&nbsp;</span>stamps = ... ;</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви використовуєте цю декларацію сьогодні, та потім випадково покладете
      coin до вашої колекції, помилкова вставка компілюється, та виконується без
      помилки (хоча компілятор видає розпливчате попередження):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Помилкове
        вставлення coin в колекцію stamp</strong><br>
      stamps.add(new Coin( ... )); // Видає повідомлення "unchecked call"</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      не отримаєте помилку, доки не спробуєте отримати монету з колекції марок:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Сирий
        тип ітератора - не робіть це!</strong><br>
      for (<strong>Iterator</strong><span class="Apple-converted-space">&nbsp;</span>i
      = stamps.iterator(); i.hasNext(); )<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Stamp stamp =<span class="Apple-converted-space">&nbsp;</span><strong>(Stamp)</strong><span
        class="Apple-converted-space">&nbsp;</span>i.next();<span class="Apple-converted-space">&nbsp;</span><strong>//
        Підіймає ClassCastException</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stamp.cancel();</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      зазначається впродовж цієї книги, бажано винаходити помилки по можливості
      так швидко, як це можливо після того, як вони зроблені, ідеально під ча
      компіляції. В цьому випадку ви не знайдете помилку до часу виконання,
      задовго після того, як вона зроблена, та в коді, що може бути віддалений
      від кода, що створив помилку. Як тільки ви бачите помилку <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>,
      ви маєте шукати в коді виклик метода, що кладе coin в колекцію stamp.
      Компілятор не допоможе вам, оскльіки він не може зрозуміти коментар, що
      каже, “Містить тільки примірники <code style="font-family: 'Courier New', monospace;">Stamp</code>”.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">З
      дженеріками декларація типу містить інформацію, а не коментар:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Параетризований
        тип колекції - typesafe</strong><br>
      private final<span class="Apple-converted-space">&nbsp;</span><strong>Collection&lt;Stamp&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>stamps = ... ;</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">З
      цієї декларації компілятор знає, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">stamps</code><span class="Apple-converted-space">
        повинно містити тільки примірники</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Stamp</code><span
        class="Apple-converted-space">, та <em>гарантує те, що так і буде</em></span>,
      вважаючи, що ваш код весь компілюється без видачі (або придушення ;
      дивіться<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev27"
        style="text-decoration: none;">Елемент 27</a>) жодних попереджень. Коли
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">stamps</code><span
        class="Apple-converted-space"> </span>декларовано з параметризованими
      типами, помилкове вставлення генерує помилку часу компіляції, що каже вам
      <em>в точності що не так</em>: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Test.java:9:
      error: incompatible types: Coin cannot be converted<br>
      to Stamp<br>
      &nbsp;&nbsp;&nbsp;&nbsp;c.add(new Coin());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Компілятор
      вставляє невидимі касти за вас при отриманні елементів з колекцій, та
      гарантує, що воно не схибить (вважаючи, знову, що весь ваш код не генерує
      або не придушує жодні попередження компілятора). Хоча перспектива
      випадкового вставлення монети в колекцію марок може видатись
      маловірогідною, проблема є реальною. Наприклад, просто уявити покладання <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">BigInteger</code><span
        class="Apple-converted-space"> в колекцію, що мала би містити примірники</span><span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">BigDecimal</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      зазначалось раніше, є легальним використовувати сирі типи (дженерік типи
      без параметрів типів), але ви не маєте робити це.<span class="Apple-converted-space">
      </span><strong>Якщо ви використовуєте сирі типи, ви втрачаєте всі переваги
        безпеки та виразності дженериків.</strong><span class="Apple-converted-space">
        Вважаючи, що ви не будете їх використовувати, чому розробники мови
        дозволили існування сирих типів</span>?&nbsp; З міркувань сумісності.
      Java входила в друге дисятиріччя, коли були додані дженеріки, та в природі
      існувала величезна кількість коду, що не використовував дженеріків.
      Вважалось вкрай критичним, щоб весь цей код залишався легальним, та
      взаємодіяв з новим кодом, який використовував дженеріки. Було легальним
      передавати примірники параметризованих типів до методів, розроблених для
      використання з сирими типами, та навпаке. Ця вимога, відома як <em>міграційна
        сумісність, </em>рухала рішеннями підтримки сирих типів, та реалізації
      дженериків з використанням<span class="Apple-converted-space"> </span><em>затирання
        </em>(<a href="ch5.xhtml#lev28" style="text-decoration: none;">Елемент
        28</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Хоча
      ви не повинні використовувати сирі типи, такі як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code>, це добре
      використовувати типи, що параметризовані для сприймання довільних
      об'єктів, такі як as<code style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code>.
      Але яка різниця між сирим типом <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List</code><span class="Apple-converted-space">,
        та параметризованим типом </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code>?
      Просто кажучи, перший виключений з системи типів дженериків, тоді як
      другий явно каже компілятору, що він в змозі містити об'єкти любого типу.
      Хоча ви можете передати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space"> до параметра типу</span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"> List</code>, ви не
      можете передати його до параметру типу<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code>.
      Існують правила суб-типізації для дженериків, і<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space"> є сибтипом для сирого типу </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List</code>,
      але не для параметризованого типу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(<a href="ch5.xhtml#lev28" style="text-decoration: none;">Елемент
        28</a>). Як слідоцтво, <strong>ви втрачаєте безпеку типів, якщо ви
        використовуєте сирі типи, такі як </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>List</strong></code><strong>,
        але ні, якщо використовуєте параметризований тип, як </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>List&lt;Object&gt;</strong></code><strong>.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      надати цьому конкретики розглянемо наступну програму: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Схибить
        під час виконання - небезпечний метод unsafeAdd використовує сирий тип
        (List)!</strong><br>
      public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;List&lt;String&gt; strings = new
      ArrayList&lt;&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;unsafeAdd(strings, Integer.valueOf(42));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;String s =<span class="Apple-converted-space">&nbsp;</span><strong>strings.get(0);
        // Має згенерований компілятором кастинг</strong><br>
      }<br>
      <br>
      private static void unsafeAdd(<strong>List</strong><span class="Apple-converted-space">&nbsp;</span>list,
      Object o) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;list.add(o);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      програма компілюється, але оскільки використовується сирий тип <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List ви отримаєте
        попередження</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Test.java:10:
      warning: [unchecked] unchecked call to add(E) as a<br>
      member of the raw type List<br>
      &nbsp;&nbsp;&nbsp;&nbsp;list.add(o);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">І
      дійсно, якщо ви виконаєте програму ви отримаєте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException, коли
        програма спробує перетворити результат виклику </code><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">strings.get(0)</code>, що
      є <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Integer</code>
      до,&nbsp; <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">String</code>.
      Це згенерований компілятором кастинг, так що звичайно це гарантує успіх,
      але в цьому випадку ми проігнорували попередження компілятора, та
      заплатили ціну.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви заміните сирий тип <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List</code><span
        class="Apple-converted-space"> на параметризований тип</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code><span
        class="Apple-converted-space"> в декларації</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">unsafeAdd</code><span
        class="Apple-converted-space">, та спробуєте перекомпілювати програму,
        ви знайдете, що вона більше не компілюється, але видає повідомлення про
        помилку</span>: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Test.java:5:
      error: incompatible types: List&lt;String&gt; cannot be<br>
      converted to List&lt;Object&gt;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;unsafeAdd(strings, Integer.valueOf(42));<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете впасти в спокусу використовувати сирий тип для колекції, тип
      елементів яких невідомий, та не має значення. Наприклад, уявімо, що ви
      бажаєте написати метод, що приймає дві множини, та повертає число
      елементів, що вони мають назагал. Ось як ви можете написати такий метод,
      якщо ви нові до дженериків:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Використовує
        сирий тип для невідомого типу елементів - не робіть так!</strong><br>
      static int numElementsInCommon(<strong>Set s1, Set s2</strong>) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int result = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (Object o1 : s1)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (s2.contains(o1))<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result++;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      метод працює, але використовує сирі типи, що є небезпечним. Безпечною
      альтернативою є використання<span class="Apple-converted-space"> </span><em>неприв'язаних
        замінників типів</em>. Якщо ви бажаєте використовувати дженерік тип, але
      вам байдуже, якій насправді є тип параметру, ви можете використовувати
      знак запитання. Наприклад, неприв'язаний замінник типу для дженерік типу <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set&lt;E&gt;</code><span
        class="Apple-converted-space"> є</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Set&lt;?&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(читається “множина деякого
      типу”). Це найбільш загально параметризований тип <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code>, здатний
      містити <em>любу множину</em>. Ось як виглядає декларація <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">numElementsInCommon</code>
      з неприв'язаним замінником типу<span style="color: #0000ee;">:</span> </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Використовує
        неприв'язаний замінник типу - гнучко та безпечно</strong><br>
      static int numElementsInCommon(<strong>Set&lt;?&gt; s1, Set&lt;?&gt; s2</strong>)
      { ... }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_121"></span>Яка ж різниця між
      наприв'язаними замінниками типів<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">Set&lt;?&gt;</code><span
        class="Apple-converted-space"> та сирим типом </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set</code>? Чи знак
      питання щось дійсно купує для вас? Не заговорюючи це питання, але
      підстаночний тип є безпечний, але сирий тип - ні. Ви можете покласти <em>любий
        </em>елемент в колекцію з сирим типом, легко порушуючи інваріант типу
      колекції (як продемонстровано в методі <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">unsafeAdd</code>);<span class="Apple-converted-space">
      </span><strong>ви не можете покласти любий елемент (крім </strong><code style="font-family: 'Courier New', monospace;"><strong>null</strong></code><strong>)
        в </strong><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;"><strong>Collection&lt;?&gt;</strong></code><strong>.</strong><span
        class="Apple-converted-space"> Спроба зробити це буде генерувати помилку
        часу компіляції</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">WildCard.java:13:
      error: incompatible types: String cannot be<br>
      converted to CAP#1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;c.add("verboten");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^<br>
      &nbsp;&nbsp;where CAP#1 is a fresh type-variable:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;CAP#1 extends Object from capture of ?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Насправді
      це повідомлення залишає бажати кращого, але компілятор зробив свою справу,
      запобігаючи пошкодженню інваріанта типу колекцій, щодо того, яким може
      бути цей тип. Ви не тільки не можете покласти любий елемент (крім <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">null</code>) до<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Collection&lt;?&gt;</code>,
      але ви не можете нічого припускати щодо типів об'єктів, які отримаєте на
      виході, ви можете використовувати <em>дженерік методи</em><span class="Apple-converted-space">
      </span>(<a href="ch5.xhtml#lev30" style="text-decoration: none;">Елемент
        30</a>) або <em>прив'язані шаблонні типів</em><span class="Apple-converted-space">
      </span>(<a href="ch5.xhtml#lev31" style="text-decoration: none;">Елемент
        31</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Існують
      декілька незначних виключень до правила, згідно якому ви не використовуєте
      сирі типи. <span class="Apple-converted-space"></span><strong>Ви маєте
        використовувати сирі типи в літералах класів.</strong><span class="Apple-converted-space">
      </span>Специфікація не дозволяє вам використовувати параметризовані типи
      (але вона дозволяє типи масивів та примітивні типи) [JLS, 15.8.2]. Іншими
      словами, <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List.class</code>,<code
        style="font-family: 'Courier New', monospace;"> String[].class</code>,
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">int.class</code><span
        class="Apple-converted-space"> всі є легальними</span>, але<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;.class</code><span
        class="Apple-converted-space"> та</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;?&gt;.class</code><span
        class="Apple-converted-space"> - ні</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Друге
      виключення з правила стосується оператора <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">instanceof</code>.
      Оскільки інформація типу дженеріка затирається від час виконання, є
      нелегальним використовувати оператор <code style="font-family: 'Courier New', monospace;">instanceof</code><span
        class="Apple-converted-space"> на параметризованих типах, крім
        непри'язаних шаблонних типів</span>. Використання неприв'язаних
      шаблонних типів замість сирих типів жодним чином не впливає на поведінку
      оператора<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">instanceof</code><span
        class="Apple-converted-space"></span>. В цьому випадку кутові дужки та
      знак запитання є лише шумом.<span class="Apple-converted-space"> </span><strong>Це
        є кращим шляхом використовувати оператор </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>instanceof</strong></code><span
        class="Apple-converted-space"> </span><strong>з денерік типами:</strong></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Легалізоване використання сирого типу - оператор instanceof</strong><br>
      if (o instanceof<span class="Apple-converted-space">&nbsp;</span><strong>Set</strong>)
      {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Сирий тип<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>Set&lt;?&gt;</strong><span class="Apple-converted-space">&nbsp;</span>s
      =<span class="Apple-converted-space">&nbsp;</span><strong>(Set&lt;?&gt;)</strong><span
        class="Apple-converted-space">&nbsp;</span>o;&nbsp;&nbsp;&nbsp;&nbsp;//
      Тип-підстановка<br>
      &nbsp;&nbsp;&nbsp;&nbsp;...<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Зауважте,
      що коли ви визначили, що <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">o</code><span class="Apple-converted-space">
        є</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Set</code>,
      ви маєте привести його до підстановочного типу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Set&lt;?&gt;</code>, не
      сирого типу<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Set</code>.
      Це перевірений кастинг, так що він не викликатиме попереджень компілятора.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, використання сирих типів може призвести до виключень під час
      виконання, так що не використовуйте їх. Вони провадяться тільки для
      сумісності та взаємодії з застарілим кодом, що передував створенню
      дженериків. Як швидкий огляд,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Set&lt;Object&gt;</code><span
        class="Apple-converted-space"> </span>є параметризований тип, що
      представляє множину, що може містити об'єкти любого типу<span class="Apple-converted-space">.
      </span><code style="font-family: 'Courier New', monospace;">Set&lt;?&gt;</code><span
        class="Apple-converted-space"> є шаблонним типом, що представляє
        множину, яка може містити тільки об'єкти деякого невідомого типу, та </span><span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Set</code><span
        class="Apple-converted-space"> є сирим типом, що не пристає до системи
        дженерік типів. Перші два безпечні, але останній - ні</span>.</p>
    <p class="indentb" style="margin-top: 0px; margin-bottom: 13.333334px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Для
      швидкого посилання терміни, що введені в цьому елементі (та декільки
      вводяться далі в цій главі) підсомувуються в наступній таблиці:</p>
    <table class="tablewidth" style="border-collapse: collapse; width: 1179px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">
      <tbody>
        <tr>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Термін<br>
              </strong></p>
          </td>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Приклад</strong></p>
          </td>
          <td class="table1" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; padding: 0.3em; border-top-style: solid; border-top-width: 0.2em; border-top-border-bottom-style: solid; border-bottom-width: 0.1em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent-t" style="margin-top: 4.5px; margin-bottom: 4.5px; margin-left: 6px; text-indent: 0px;"><strong>Елемент</strong></p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Параметризований
              тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              26</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Дійсний
              параметр типу</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">String</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              26</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Дженерік
              тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елементs
              26, 29</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Формальний
              параметр типу</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">E</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              26</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Неприв'язаний
              шаблонний тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">List&lt;?&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              26</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Сирий
              тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">List</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              26</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Прив'язаний
              параметр типу</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">&lt;E extends
                Number&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              29</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Рекурсивно
              прив'язаний тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">&lt;T extends
                Comparable&lt;T&gt;&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              30</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Прив'язаний
              шаблонний тип</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">List&lt;? extends
                Number&gt;</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              31</p>
          </td>
        </tr>
        <tr>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Дженерік
              метод</p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">static &lt;E&gt;
                List&lt;E&gt; asList(E[] a)</code></p>
          </td>
          <td style="vertical-align: top;">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              30</p>
          </td>
        </tr>
        <tr>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Токен
              типу</p>
          </td>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;"><code
                style="font-family: 'Courier New', monospace;">String.class</code></p>
          </td>
          <td class="table2" style="vertical-align: top; margin-top: 0px; margin-bottom: 0px; border-bottom-style: solid; border-bottom-width: 0.2em; border-bottom-color: rgb(0, 0, 0);">
            <p class="noindent1" style="margin-top: 3px; margin-bottom: 7.5px; margin-left: 7.5px; text-indent: 0.0026666669px;">Елемент
              33</p>
          </td>
        </tr>
      </tbody>
    </table>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">&nbsp;<strong>Елемент
        27: Уникайте неперевірених попереджень</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви програмуєте з дженеріками, ви побачите багато попереджень компілятора:
      неперевірені попередження кастингу, неперевірені попередження викликку
      методів, неперевірені попередженея параметризованих vararg, та
      неперевірені попередження конверсії. Чим більше досвіду з дженеріками ви
      набуватимире, тим меньше повідомлень ви отримуватиме, але не очікуйте, що
      новий написаний код буде компілюватись чисто.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Багато
      неперевірених попереджень легко уникнути. Наприклад, уявімо, що ви
      випадково написали декларацію:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Set&lt;Lark&gt;
      exaltation = new HashSet();</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Компілятор
      ласкаво нагадає вам, що ви зробили щось не так:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Venery.java:4:
      warning: [unchecked] unchecked conversion<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Lark&gt; exaltation
      = new HashSet();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      &nbsp;&nbsp;required: Set&lt;Lark&gt;<br>
      &nbsp;&nbsp;found:&nbsp;&nbsp;&nbsp;&nbsp;HashSet</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете зробити вказану корекцію, щоб попередження зникло. Зауважте, що ви
      насправді не маєте вказувати параметр типу, просто вказавши, що він
      присутній за допомогою <em>оператора діаманту</em><span class="Apple-converted-space">
      </span>(<code style="font-family: 'Courier New', monospace;">&lt;&gt;</code>),
введеному
      в Java 7. Тепер компілятор <em>виведе</em><span class="Apple-converted-space">
      </span>коректний справжній параметр типу (в цьому випадку<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Lark</code>):</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Set&lt;Lark&gt;
      exaltation = new HashSet<strong>&lt;&gt;</strong>();</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Деякі
      попередження буде <em>значно більш складно </em>уникнути. Ця глава
      заповнена прикладами таких попереджень. Коли ви отримаєте попередження, що
      потребують деякого розмірковування, наполягайте!<span class="Apple-converted-space">
      </span><strong>Уникайте кожного неперевіреного попередження, як тільки
        можливо. </strong><span class="Apple-converted-space"></span>Якщо ви
      уникнете всіх попереджень, ви будете впевнені, що ваш код типо-безпечний,
      що є дуже гарно. Це означає, що ви не отримаєте <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space"> під час виконання</span>, та це збільшує
      вашу впевненість, що ваша програма буде поводитись як задумано.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Якщо
        ви не можете уникнути попередження, але ви можете довести, що код, який
        спровакував попередження, є безпечним, тоді (і тільки тоді) придушуйте
        попередження за допомогою анотації</strong><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;"><strong>@SuppressWarnings("unchecked")</strong></code><strong>.</strong><span
        class="Apple-converted-space"> Якщо ви придушуєте попередження без
        попередньої перевірки, що код типо-безпечний, і ви створюєте для себе
        фальшиве уявлення про безпеку.</span> Код може компілюватись без видачі
      жодних попереджень, або він все ще буде видавати <code style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space"> під час виконання</span>. Однак, якщо ви
      ігноруєте неперевірені попередження, що відомі вам як безпечні (замість
      придушення), ви не зможете зауважити, коли проявиться нове попередження,
      що представлятиме реальну проблему. Нове попередження загубиться серед
      всіх фальшивих сигналів, яких ви не примовчали.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_124"></span>Анотація<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">SuppressWarnings</code><span
        class="Apple-converted-space"> може використовуватись на любій
        декларації</span>, від індивідуальної локальної змінної до цілого класа.<span
        class="Apple-converted-space"> </span><strong>Завжди використовуйте
        анотацію</strong><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;"><strong>SuppressWarnings</strong></code><span
        class="Apple-converted-space"> на <strong>найменьшому можливому обʼєкті</strong></span><strong>.</strong><span
        class="Apple-converted-space"> Типово це буде декларація змінної або
        дуже короткий метод або конструктор</span>. Ніколи не використовуйте <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">SuppressWarnings</code><span
        class="Apple-converted-space"> на цілому класі</span>. Робити це може
      маскувати критичні попередження.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви застигнете себе за використанням анотації <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">SuppressWarnings</code><span
        class="Apple-converted-space"> на методі або конструкторі, що довше за
        один рядок, вам можливо вдасться пересунути її на декларацію локальної
        змінної</span>. Вам може знадобитись декларувати нову локальну змінну,
      але воно того варте. Наприклад, розглянемо метод <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">toArray</code>, що іде з
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">ArrayList</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      &lt;T&gt; T[] toArray(T[] a) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (a.length &lt; size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (T[]) Arrays.copyOf(elements,
      size, a.getClass());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(elements, 0, a, 0, size);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (a.length &gt; size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a[size] = null;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return a;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви компілюєте<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">ArrayList</code>,
      метод згенерує таке повідомлення:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">ArrayList.java:305:
      warning: [unchecked] unchecked cast<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (T[]) Arrays.copyOf(elements,
      size, a.getClass());<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      &nbsp;&nbsp;required: T[]<br>
      &nbsp;&nbsp;found:&nbsp;&nbsp;&nbsp;&nbsp;Object[]</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      нелегально, покладати анотацію <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">SuppressWarnings</code><span
        class="Apple-converted-space"> на твердження</span> return, бо це не
      декларація [JLS, 9.7]. Ви можете впасти в спокусу покласти анотацію на
      цілий метод, але не робіть цього. Замість цього декларуйте локальну
      змінну, що зберігатиме значення результату, та анотуйте її декларацію,
      таким чином:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Додавання
        локальної змінної, щоб зменшити поле дії @SuppressWarnings</strong><br>
      public &lt;T&gt; T[] toArray(T[] a) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (a.length &lt; size) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>// Цей кастинг
        коректний, оскільки масив, що ми створюємо</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>// є того ж типу,
        шр і переданий сюди, T[].</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>@SuppressWarnings("unchecked")
        T[] result =</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(T[])
        Arrays.copyOf(elements, size, a.getClass());</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>return result;</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;System.arraycopy(elements, 0, a, 0, size);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (a.length &gt; size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a[size] = null;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return a;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_125"></span>Отриманий метод компілюється
      чисто, та мінімізує дію, да придушуються неперевірені попередження.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>Кожного
        разу, коли ви використовуєте анотацію </strong><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;"><strong>@SuppressWarnings("unchecked")</strong></code><strong>,
        додавайте коментар, який каже, чому безпечно робити це.</strong><span class="Apple-converted-space">
        Це буде допомогати інишм розуміти код, та більш важливо - він зменшує
        шанси, що хтось буде модифікувати код, так, щоб зробити обчислення
        небезпечними</span>. Якщо ви винайдете складним написати такий коментар,
      продовжуйте думати. Ви можете скінчити роздуми висновком, що неперевірена
      операція не такая вже і безпечна. </p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Підсумовуючи:
      неперевірені попередження є важливими. Не ігноруйте їх. Кожне неперевірене
      попередження представляє потенціал для <code style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space"> </span>під час виконання. Намагайтесь
      знищувати ці попередження. Якщо ви не можете збутись неперевіреного
      попередження, ви можете довести, що провокуючий його код безпечний, та
      придушити попередження анотацією<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">@SuppressWarnings("unchecked")</code><span
        class="Apple-converted-space"> в найвужчому можливому полі. Запишіть
        ваше пояснення для вашого рішення по забороні попередження в коментарі.</span></p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_126"></span><strong>Елемент 28:
        Віддавайте перевагу спискам над масивам</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Масиви
      відрізняються від дженерік типів в два важливі способи. Перше: масиви <em>коваріантні</em>.
      Це жахливо-лунаюче слово просто означає, що якщо <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Sub</code><span class="Apple-converted-space">
        є субтипом</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Super</code>,
      тоді масив типу <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Sub[]</code><span
        class="Apple-converted-space"> є субтипом масива з типом</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Super[]</code>.
      Дженеріки, на відміну від цього, є <em>інваріантними</em>: для любих двох
      типів <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Type1</code>
      та<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Type2</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;Type1&gt;</code><span
        class="Apple-converted-space"> </span>не є ні субтипом, ні супертипом <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;Type2&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>[JLS, 4.10; Naftalin07, 2.5].
      Ви можете подумати, що це означає, що дженеріки недосконалі, але можливо
      масиви є тим, що недосконале. Цей фрагмент коду легальний:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Схибить при виконанні!</strong><br>
      Object[] objectArray = new Long[1];<br>
      objectArray[0] = "I don't fit in";<span class="Apple-converted-space"> </span><strong>//
        буде ArrayStoreException</strong></p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">але
      це ні: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Не
        буде компілюватись!</strong><br>
      List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;();<span class="Apple-converted-space">&nbsp;</span><strong>//
        несумісні типи</strong><br>
      ol.add("I don't fit in");</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      жодному разі ви не покладете <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        в</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Long</code><span
        class="Apple-converted-space"> контейнер</span>, але з масивами ви
      з'ясуєте, що зробили помилку, під час виконання; зі списками це трапиться
      під час компіляції. Звичайно, ви бажали б отримати це під час компіляції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Друга
      головна різниця між масивами та дженеріками в тому, що масиви є <span class="Apple-converted-space"></span><em>втіленими</em><span
        class="Apple-converted-space"> </span>[JLS, 4.7]. Це означає, що масиви
      знають та змушують тип своїх елементів під час виконання. Як казалось
      раніше, якщо ви намагатиметесь покласти <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">
        в масив </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Long</code>,
      ви отримаєте <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">ArrayStoreException</code>.
      Дженеріки, на відміну від цього, реалізовані як <span class="Apple-converted-space"></span><em>затирання</em><span
        class="Apple-converted-space"> </span>[JLS, 4.6]. Це означає, що вони
      примушують тип своїх елементів тільки під час компіляції, та відкидають
      (або<span class="Apple-converted-space"> </span><em>затирають</em>)
      інформацію типу елементів під час виконання. Затирання є те, що дозволяє
      дженерік типам вільлно взаємодіяти зі старим кодом, що не використовує
      дженеріки (<a href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент
        26</a>), гарантуючи м'який перехід до дженериків в Java 5.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Завдяки
      цім фундаментальним відмінностям, масиви та дженеріки не змішуються дуже
      гарно. Наприклад, є нелегальним створювати масив дженерік типів,
      параметризованого типу, або параметру типу. Таким чином, жодне з ціх
      створінь не є легальним:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">new List&lt;E&gt;[]</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">new
        List&lt;String&gt;[]</code>,<code style="font-family: 'Courier New', monospace;">
        new E[]</code>. Всі вони призведуть до помилок <span class="Apple-converted-space"></span><em>створення
        дженерік масиву</em><span class="Apple-converted-space"> під час
        компіляції</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Чому
      нелегально створювати масив з дженериків? Бо це типо-небезпечно. Якщо це
      було б легальним, кастинг, згенерований компілятором, в інакше коректній
      програмі міг би схибити під час виконання з <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>.
      Це може порушити фундаментальну гарантію, що провадиться системою дженерік
      типів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      надати конкретики розглянемо наступний фрагмент коду: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Чому
        масиви дженериків нелегальні - не буде компілюватись!</strong><br>
      List&lt;String&gt;[] stringLists =<span class="Apple-converted-space">&nbsp;</span><strong>new
        List&lt;String&gt;[1]</strong>;&nbsp;&nbsp;// (1)<br>
      List&lt;Integer&gt; intList =
      List.of(42);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      // (2)<br>
      Object[] objects =
      stringLists;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
      (3)<br>
      objects[0] =
      intList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
      (4)<br>
      String s =
      stringLists[0].get(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//
      (5)</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Давайте
      вважатимо, що рядок 1, що створює дженерік масив, є легальним. Рядок 2
      створює та ініціалізує <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code><span
        class="Apple-converted-space">, що містить один елемент</span>. Рядок 3
      зберігає масив <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space"> в змінну масива </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code>, що
      легальне, бо масиви коваріантні. Рядок 4 зберігає <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code><span
        class="Apple-converted-space"> в один елемент масива</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object</code>,
      що буде успішним, бо дженеріки реалізовані через затирання: тип часу
      виконання для примірника<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code>
      є просто<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">List</code>,
      та тип виконання примірника <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;[]</code><span
        class="Apple-converted-space"> є</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List[]</code>,
      так що це присвоєння не генерує <code style="font-family: 'Courier New', monospace;">ArrayStoreException</code>.
      Тепер у нас проблеми. Ми зберігли примірник<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code><span
        class="Apple-converted-space"> в масиві, що декларований як такий, що
        містить тільки примірники</span><span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code>.
      В рядку 5 ми отримуємо єдиний елемент з одного списуку в масиві.
      Компілятор автоматично приводить отриманий елемент до <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">String</code>, але це<span
        class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">Integer</code>,
      так що ми отримуємо<span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">
        ClassCastException</code><span class="Apple-converted-space"> під час
        виконання</span>. Щоб цього не трапилось, рядок 1 (що створює дженерік
      масив), має генерувати помилку часу компіляції.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Типи,
      такі як <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">E</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code>,
      та&nbsp;<span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space"> технічно відомі як </span><span class="Apple-converted-space"></span><em>невтіленні
        типи</em> [JLS, 4.7]. Кажучи інтуітивно, не-втіленні типи це такі, чиє
      представлення під час виконання містить менше інформації, ніж
      репрезентація часу компіляції. Завдяки затиранню, єдиними
      параметризованими типами, що є втіленними є неприв'язані підставні типи,
      як&nbsp; <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;?&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Map&lt;?,?&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(<a href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент
        26</a>). Є легальним, хоча рідко корисним, створювати масиви з
      неприв'язаних підстановочних типів.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Заборона
      на створення дженерік масивів може бути надокучливою. Це значить,
      наприклад, що загалом неможливо для дженерік колекції повертати масив типу
      своїх елементів&nbsp; (але дивіться <span class="Apple-converted-space"></span><a
        href="ch5.xhtml#lev33" style="text-decoration: none;">Елемент 33</a><span
        class="Apple-converted-space"> для часткового рішення</span>). Це також
      означає, що ви отримаєте збентежливе попередження, коли використовуєте
      методи vararg (<a href="ch8.xhtml#lev53" style="text-decoration: none;">Елемент
        53</a>) в комбінації з дженерік типами. Це тому, що кожного разу, коли
      ви викликаєте метод vararg, створюється масив для зберігання змінного
      числа параметрів. Якщо тип елементів цього масива невтіленне, ви отримаєте
      попередження. Анотація <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">SafeVarargs</code><span
        class="Apple-converted-space"> може використовуватись, щоб вірішити це
        питання</span> (<a href="ch5.xhtml#lev32" style="text-decoration: none;">Елемент
        32</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Коли
      ви отримаєте помилку створення дженерік масиву або неперевірене
      попередження кастингу, кращим рішенням часто є використання колекції типу
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code><span
        class="Apple-converted-space"> замість масива типу</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">E[]</code>. Ви
      можете пожертвувати стислістю або продуктивністю, але взаміну ви отримаєте
      кращу безпеку типів та взаємодію.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_128"></span>Наприклад, уявімо, що ви
      бажаєте написати клас <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Chooser</code><span
        class="Apple-converted-space"> з конструктором, що приймаає колекцію, та
        єдиний метод, що повертає випадково обраний елемент колекції</span>. В
      залежності від того, яку колекцію ви передасте в конструктор, ви можете
      використовувати число як кубик в грі, магічний 8-кутник, або джерело даних
      для симуляції Монте-Карло. Ось спрощена реалізація без дженериків:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Chooser - клас тяжко потребує дженериків!</strong><br>
      public class Chooser {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final Object[] choiceArray;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Chooser(Collection choices) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceArray =
      choices.toArray();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Object choose() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random rnd =
      ThreadLocalRandom.current();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return
      choiceArray[rnd.nextInt(choiceArray.length)];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      використати цей клас, ви маєте зробити кастинг значення, що повертає <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">choose</code><span
        class="Apple-converted-space"> з </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
        до бажаного типу, кожний раз, коли ви викликаєте метод</span>, та
      кастинг схиблюватиме під час виконання, якщо ви отримаєте невірний клас.
      Близько приймаючи до серця пораду <span class="Apple-converted-space"></span><a
        href="ch5.xhtml#lev29" style="text-decoration: none;">Елемента 29</a>,
      ми намагаємось модифікувати <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Chooser</code><span class="Apple-converted-space">,
        щоб зробити його дженеріком</span>. Зміни показані жирним шрифтом: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Перша
        спроба зробити Chooser дженеріком - не буде компілюватись</strong><br>
      public class Chooser<strong>&lt;T&gt;</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final<span class="Apple-converted-space">&nbsp;</span><strong>T</strong>[]
      choiceArray;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Chooser(Collection<strong>&lt;T&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>choices) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceArray =
      choices.toArray();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;// метод choose незмінний<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Якщо
      ви намагатимесь компілювати цей клас, ви отримаєте повідомлення про
      помилку: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Chooser.java:9:
      error: incompatible types: Object[] cannot be<br>
      converted to T[]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceArray =
      choices.toArray();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      &nbsp;&nbsp;where T is a type-variable:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;T extends Object declared in class Chooser</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Невелика
      справа, я перетворю масив <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
        на масив</span><span class="Apple-converted-space"> </span><code style="font-family: 'Courier New', monospace;">T</code>:</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
    </p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">choiceArray
      = (T[]) choices.toArray();</p>
    <p class="prec" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; text-align: center; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br>
    </p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Це
      покладає край помилці, але замість цього ви отримаєте попередження:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Chooser.java:9:
      warning: [unchecked] unchecked cast<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceArray = (T[])
      choices.toArray();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      &nbsp;&nbsp;required: T[], found: Object[]<br>
      &nbsp;&nbsp;where T is a type-variable:<br>
      T extends Object declared in class Chooser</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Компілятор
      каже вам, що він не може поручитись за безпеку кастингу від час виконання,
      бо середа виконання не знає, який тип представляє <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">T </code>— пам'ятайте,
      що інформація щодо типів елементі затирається в дженериках під час
      виконання. Чи буде програма робити? так, але компілятор не може це
      перевірити. Ви можете довести це самому собі, покласти докази в коментарі,
      та придушити попередження за допомогою анотації, але краще уникнути
      причини попередження (<a href="ch5.xhtml#lev27" style="text-decoration: none;">Елемент
        27</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Щоб
      уникнути неперевіреного попередження кастингу, використовуйте список
      замість масива. Ось версія класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Chooser</code><span class="Apple-converted-space">,
        що компілюється без помилки або попередження</span>: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Список-базований
        Chooser - типо-безпечно</strong><br>
      public class Chooser&lt;T&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private final<span class="Apple-converted-space">&nbsp;</span><strong>List&lt;T&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>choiceList;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Chooser(Collection&lt;T&gt; choices) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;choiceList =<span class="Apple-converted-space">&nbsp;</span><strong>new
        ArrayList&lt;&gt;(choices)</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public T choose() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Random rnd =
      ThreadLocalRandom.current();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<span class="Apple-converted-space">&nbsp;</span><strong>choiceList.get(rnd.nextInt(choiceList.size()))</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ця
      версія трохи більш балакуча, та можливо трохі повільніша, але це варте
      того, в обмін на спокій, що ви отримаєте не отримаєте <code style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space"> під час виконання</span>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">В
      підсумку, масиви та дженеріки мають дуже різні правила типів. Масиви
      коваріантні та втілені; дженеріки інваріантні та затерті. Як слідоцтво,
      масиви провадять безпеку типів часу виконання, але не часу компіляції, та
      навпаку для дженериків. Як правило, масиви та дженерики погано міксуються.
      Коли ви починаєте їх міксувати, та отримуєте помилки або попередження часу
      компіляції, вашим першим поштовхом має бути замінити масиви на списки.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">&nbsp;Е<strong>лемент
        29: Надавайте перевагу дженерікам</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Загалом
      не дуже складно параметризувати ваші декларації, та задіяти джеренік типи
      та методи, що провадяться JDK. Написання ваших власних дженерік типів
      трохи більш складне, але це варте того, щоб навчитись.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Реалізуємо
      простий (іграшковий) стек з<span class="Apple-converted-space"> </span><a
        href="ch2.xhtml#lev7" style="text-decoration: none;">Елементу 7</a>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Об'єкт-базована
        колекція - a prime candidate for generics</strong><br>
      public class Stack {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private<span class="Apple-converted-space">&nbsp;</span><strong>Object</strong>[]
      elements;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int size = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int DEFAULT_INITIAL_CAPACITY
      = 16;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Stack() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements = new<span class="Apple-converted-space">&nbsp;</span><strong>Object</strong>[DEFAULT_INITIAL_CAPACITY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void push(<strong>Object</strong><span class="Apple-converted-space">&nbsp;</span>e)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacity();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size++] = e;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public<span class="Apple-converted-space">&nbsp;</span><strong>Object</strong><span
        class="Apple-converted-space">&nbsp;</span>pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new EmptyStackException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>Object</strong><span
        class="Apple-converted-space">&nbsp;</span>result = elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size] = null; //
      Eliminate obsolete reference<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean isEmpty() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return size == 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;private void ensureCapacity() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (elements.length ==
      size)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements
      = Arrays.copyOf(elements, 2 * size + 1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Цей
      клас мав би бути параметризований з самого початку, але оскільки він не
      був, ми можемо <em>дженерифікувати його </em><span class="Apple-converted-space"></span>пост-фактум.
      Іншими словами, ми можемо параметризувати його без зашкоджанням клієнтам
      оригінальної, не-параметризованої версії. Як це є, клієнт має зробити
      кастинг об'єкту, що виштовхується зі стеку, і ці кастинги можуть схибити
      під час виконання. Перший крок в дженерифікації класу є додавання одного
      або більше параметрів типу до декларації. В цьому випадку є один параметр
      типу, що представляє тип елемента стеку, та зручне ім'я для цього типу є <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>(<a href="ch9.xhtml#lev68" style="text-decoration: none;">Елемент
        68</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наступний
      крок є замінити всі використання типу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">
        на відповідний параметр типу, та потім спробувати скомпілювати отриману
        програму</span>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Попередня
        спроба дженерифікації Stack - не компілюється!</strong><br>
      public class Stack<strong>&lt;E&gt;</strong><span class="Apple-converted-space">&nbsp;</span>{<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private<span class="Apple-converted-space">&nbsp;</span><strong>E</strong>[]
      elements;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private int size = 0;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private static final int DEFAULT_INITIAL_CAPACITY
      = 16;<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Stack() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements = new<span class="Apple-converted-space">&nbsp;</span><strong>E</strong>[DEFAULT_INITIAL_CAPACITY];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void push(<strong>E</strong><span class="Apple-converted-space">&nbsp;</span>e)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ensureCapacity();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size++] = e;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public<span class="Apple-converted-space">&nbsp;</span><strong>E</strong><span
        class="Apple-converted-space">&nbsp;</span>pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw
      new EmptyStackException();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>E</strong><span class="Apple-converted-space">&nbsp;</span>result
      = elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements[size] = null; //
      Очищуємо непотрібне посилання<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;... // isEmpty та ensureCapacity не змінюються<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      загалом отримаєте щонайменьше одну помилку або повідомлення, і цей клас не
      виняток. На щастя, цей клас генерує тільки одну помилку:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack.java:8:
      generic array creation<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements =<span class="Apple-converted-space">&nbsp;</span><strong>new
        E[DEFAULT_INITIAL_CAPACITY]</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      пояснюється в <span class="Apple-converted-space"></span><a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елементі 28</a>, ви не можете створити
      масив невтіленного типу, як <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">E</code>. Ця проблема
      виникає кожного разу, коли ви пишете дженерік тип, що базується на масиві.
      Є два прийнятних способи віришити цю прооблему. Перше рішення напряму
      обходить створення дженерік масиву: створити масив <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">,
        та зробити кастинг до типу дженерік масива. Тепер замість помилки
        компілятор буде видавати попередження</span>. Це використання легальне,
      але воно (загалом) не типо-безпечне:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack.java:8:
      warning: [unchecked] unchecked cast<br>
      found: Object[], required: E[]<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elements =<span class="Apple-converted-space">&nbsp;</span><strong>(E[])
        new Object[DEFAULT_INITIAL_CAPACITY]</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Компілятор
      не може довести, що ваша програма типо-безпечна, але ви можете. Ви повинні
      переконати себе, що неперевірений кастинг не скомпроментує безпеки типів
      програми. Розглядаємий масив (елементи) зберігаються в приватному полі, та
      ніколи не повертається клієнту, або пересилається до любого іншого метода.
      Едині елементи, що зберігаються в масиві, є ті, що передаються в метод <span
        class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">push</code><span
        class="Apple-converted-space"></span>, що є типу<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">E</code>, так
      що неперевірений кастинг не зашкодить.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Як
      тільки ви переконались, що неперевірений кастинг безпечний, придушіть
      попередження в найтіснішому колі з можливих (<a href="ch5.xhtml#lev27" style="text-decoration: none;">Елемент
        27</a>). В цьому випадку конструктор складається тільки зі створення
      неперевіреного масиву, так що можна придушити попередження в цілому
      конструкторі. З додаванням анотації, що робить це, <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">
        компілюється чисто, та ви можете використовувати його без явних
        кастингів, або страху </span><span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Елементи
        масиву будуть містити тільки примірники E від push(E).</strong><br>
      <strong>// Цього достатньо для забезпечення безпеки типів, але під час
        виконання</strong><br>
      <strong>//&nbsp;</strong><strong><strong>тип масиву</strong> не буде E[];
        він завжди буде Object[]!</strong><br>
      <strong>@SuppressWarnings("unchecked")</strong><br>
      public Stack() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;elements = (E[]) new
      Object[DEFAULT_INITIAL_CAPACITY];<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Другий
      шлях уникнути створення дженерік масиву в <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">
        є змінити тип поля </span><code style="font-family: 'Courier New', monospace;">elements</code><span
        class="Apple-converted-space"> з</span><span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">E[]</code><span
        class="Apple-converted-space"> </span>на<span class="Apple-converted-space">
      </span><code style="font-family: 'Courier New', monospace;">Object[]</code>.
      Якщо ви зробите це, ви отримаєте іншу помилку:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack.java:19:
      incompatible types<br>
      found: Object, required: E<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>E result =
        elements[--size];</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Ви
      можете змінити цю помилку на попередження через кастинг елементу,
      повернутого з масиву <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">E</code>,
      але ви отримаєте попередження: </p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack.java:19:
      warning: [unchecked] unchecked cast<br>
      found: Object, required: E<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E result =<span class="Apple-converted-space">&nbsp;</span><strong>(E)</strong><span
        class="Apple-converted-space">&nbsp;</span>elements[--size];<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Оскікльи
      <span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space"> є невтіленним типом, немає способу, щоб
        компілятор зміг перевірити кастинг під час виконання. Знову, ви можете
        легко переконати себе, що неперевірений кастинг безпечний, та придушити
        попередження</span>. Згідно пораді в <span class="Apple-converted-space"></span><a
        href="ch5.xhtml#lev27" style="text-decoration: none;">Елементі 27</a>,
      ми придушимо попередження тільки на присвоєнні, що містить неперевірений
      кастинг, а не цілий метод<span class="Apple-converted-space"> </span><code
        style="font-family: 'Courier New', monospace;">pop</code>:</p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
Відповідне
        придушення неперевіреного попередження</strong><br>
      public E pop() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (size == 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      EmptyStackException();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>// push потребує елементи типу E,
        так що кастинг коректний</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>@SuppressWarnings("unchecked")</strong><span
        class="Apple-converted-space">&nbsp;</span>E result =<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(E) elements[--size];<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;elements[size] = null; // Видаляємо непотрібну
      посилання<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Обоє
      прийоми для уникнення створення дженерік масиву має свох прихільників.
      Перше більш читаєме: масив декларований з типом <code style="font-family: 'Courier New', monospace;">E[]</code>,
      ясно вказуючи, що він містить тільки примірники <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">E</code>. Він також більш
      стислою: в типовому дженерік класі ви читаєте з масива в багатьох місцях в
      коді; перший прийом потребує тільки одного кастингу (при створенні
      масива), коли другий потребує окремого кастингу кожного разу, коли масив
      читається. Таким чином, перший прийом має перевагу, та більш загально
      використовується на практиці. Однак він призводить до <span class="Apple-converted-space"></span><em>забруднення
        кучі</em><span class="Apple-converted-space"> </span>(<a href="ch5.xhtml#lev32"
        style="text-decoration: none;">Елемент 32</a>): тип часу виконання для
      масиву не співпадає з типом компіляції (тільки якщо <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">E</code><span class="Apple-converted-space">
        не є </span><span class="Apple-converted-space"></span><code style="font-family: 'Courier New', monospace;">Object</code>).
      Це викликає в деяких програмістів нудоту, так що вони пристають на другий
      метод, хоча в даному випадку забруднення стеку є нешкідливим.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Наступна
      програма демонструє використання нашого дженерік класу <span class="Apple-converted-space"></span><code
        style="font-family: 'Courier New', monospace;">Stack</code>. Програма
      друкує аргументи командного рядка в зворотньому порядку, та конвертовані в
      верхній реєстр. No explicit cast is necessary to invoke<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">String</code>’s<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">toUpperCase</code><span class="Apple-converted-space">&nbsp;</span>method
      on the elements popped from the stack, and the automatically generated
      cast is guaranteed to succeed:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex36a" id="pch5ex36" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Little program to exercise our generic Stack</strong><br>
      public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Stack&lt;String&gt; stack = new Stack&lt;&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (String arg : args)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stack.push(arg);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (!stack.isEmpty())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(<strong>stack.pop().toUpperCase()</strong>);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_134"></span>The foregoing example may
      appear to contradict<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елемент 28</a>, which encourages the use
      of lists in preference to arrays. It is not always possible or desirable
      to use lists inside your generic types. Java doesn’t support lists
      natively, so some generic types, such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ArrayList</code>,<span class="Apple-converted-space">&nbsp;</span><em>must</em><span
        class="Apple-converted-space">&nbsp;</span>be implemented atop arrays.
      Other generic types, such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">HashMap</code>, are
      implemented atop arrays for performance.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      great majority of generic types are like our<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">&nbsp;</span>example
      in that their type parameters have no restrictions: you can create a<code
        style="font-family: 'Courier New', monospace;">Stack&lt;Object&gt;</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack&lt;int[]&gt;</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack&lt;List&lt;String&gt;&gt;</code>,
      or<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack</code><span
        class="Apple-converted-space">&nbsp;</span>of any other object reference
      type. Note that you can’t create a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">&nbsp;</span>of
      a primitive type: trying to create a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack&lt;int&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>or<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack&lt;double&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>will result in a compile-time
      error. This is a fundamental limitation of Java’s generic type system. You
      can work around this restriction by using boxed primitive types (<a href="ch9.xhtml#lev61"
        style="text-decoration: none;">Елемент 61</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      are some generic types that restrict the permissible values of their type
      parameters. For example, consider<code style="font-family: 'Courier New', monospace;">java.util.concurrent.DelayQueue</code>,
      whose declaration looks like this:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex37a" id="pch5ex37" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">class
      DelayQueue<strong>&lt;E extends Delayed&gt;</strong><span class="Apple-converted-space">&nbsp;</span>implements
      BlockingQueue&lt;E&gt;</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      type parameter list (<code style="font-family: 'Courier New', monospace;">&lt;E
        extends Delayed&gt;</code>) requires that the actual type parameter<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>be a subtype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">java.util.concurrent.Delayed</code>.
      This allows the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">DelayQueue</code><span
        class="Apple-converted-space">&nbsp;</span>implementation and its
      clients to take advantage of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Delayed</code><span class="Apple-converted-space">&nbsp;</span>methods
      on the elements of a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">DelayQueue</code>,
      without the need for explicit casting or the risk of a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>.
      The type parameter<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>is known as a<span class="Apple-converted-space">&nbsp;</span><em>bounded
        type parameter</em>. Note that the subtype relation is defined so that
      every type is a subtype of itself [JLS, 4.10], so it is legal to create a<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">DelayQueue&lt;Delayed&gt;</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      summary, generic types are safer and easier to use than types that require
      casts in client code. When you design new types, make sure that they can
      be used without such casts. This will often mean making the types generic.
      If you have any existing types that should be generic but aren’t, generify
      them. This will make life easier for new users of these types without
      breaking existing clients (<a href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент
        26</a>).</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        id="lev30" style="text-decoration: none;"></a><span epub:type="pagebreak"
        id="page_135"></span><strong>Елемент 30: Favor generic methods</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Just
      as classes can be generic, so can methods. Static utility methods that
      operate on parameterized types are usually generic. All of the “algorithm”
      methods in<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Collections</code><span
        class="Apple-converted-space">&nbsp;</span>(such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">binarySearch</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">sort</code>) are generic.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Writing
      generic methods is similar to writing generic types. Consider this
      deficient method, which returns the union of two sets:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex38a" id="pch5ex38" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Uses raw types - unacceptable! (<a href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент
          26</a>)</strong><br>
      public static Set union(Set s1, Set s2) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Set result = new HashSet(s1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;result.addAll(s2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      method compiles but with two warnings:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex39a" id="pch5ex39" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Union.java:5:
      warning: [unchecked] unchecked call to<br>
      HashSet(Collection&lt;? extends E&gt;) as a member of raw type HashSet<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set result = new
      HashSet(s1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      Union.java:6: warning: [unchecked] unchecked call to<br>
      addAll(Collection&lt;? extends E&gt;) as a member of raw type Set<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addAll(s2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">To
      fix these warnings and make the method typesafe, modify its declaration to
      declare a<span class="Apple-converted-space">&nbsp;</span><em>type
        parameter</em><span class="Apple-converted-space">&nbsp;</span>representing
      the element type for the three sets (the two arguments and the return
      value) and use this type parameter throughout the method.<span class="Apple-converted-space">&nbsp;</span><strong>The
        type parameter list, which declares the type parameters, goes between a
        method’s modifiers and its return type.</strong><span class="Apple-converted-space">&nbsp;</span>In
      this example, the type parameter list is<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">&lt;E&gt;</code>, and the
      return type is<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Set&lt;E&gt;</code>.
      The naming conventions for type parameters are the same for generic
      methods and generic types (<a href="ch5.xhtml#lev29" style="text-decoration: none;">Елементs
        29</a>,<span class="Apple-converted-space">&nbsp;</span><a href="ch9.xhtml#lev68"
        style="text-decoration: none;">68</a>):</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex40a" id="pch5ex40" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Generic method</strong><br>
      public static<span class="Apple-converted-space">&nbsp;</span><strong>&lt;E&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>Set<strong>&lt;E&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>union(Set<strong>&lt;E&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>s1, Set<strong>&lt;E&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>s2) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Set<strong>&lt;E&gt;</strong><span class="Apple-converted-space">&nbsp;</span>result
      = new HashSet<strong>&lt;&gt;</strong>(s1);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;result.addAll(s2);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">At
      least for simple generic methods, that’s all there is to it. This method
      compiles without generating any warnings and provides type safety as well
      as ease of<span class="Apple-converted-space">&nbsp;</span><span epub:type="pagebreak"
        id="page_136"></span>use. Here’s a simple program to exercise the
      method. This program contains no casts and compiles without errors or
      warnings:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex41a" id="pch5ex41" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Simple program to exercise generic method</strong><br>
      public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Set&lt;String&gt; guys = Set.of("Tom", "Dick",
      "Harry");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Set&lt;String&gt; stooges = Set.of("Larry", "Moe",
      "Curly");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Set&lt;String&gt; aflCio = union(guys, stooges);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(aflCio);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">When
      you run the program, it prints<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">[Moe, Tom, Harry, Larry,
        Curly, Dick]</code>. (The order of the elements in the output is
      implementation-dependent.)</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">A
      limitation of the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">union</code><span
        class="Apple-converted-space">&nbsp;</span>method is that the types of
      all three sets (both input parameters and the return value) have to be
      exactly the same. You can make the method more flexible by using<span class="Apple-converted-space">&nbsp;</span><em>bounded
        wildcard types</em><span class="Apple-converted-space">&nbsp;</span>(<a
        href="ch5.xhtml#lev31" style="text-decoration: none;">Елемент 31</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">On
      occasion, you will need to create an object that is immutable but
      applicable to many different types. Because generics are implemented by
      erasure (<a href="ch5.xhtml#lev28" style="text-decoration: none;">Елемент
        28</a>), you can use a single object for all required type
      parameterizations, but you need to write a static factory method to
      repeatedly dole out the object for each requested type parameterization.
      This pattern, called the<span class="Apple-converted-space">&nbsp;</span><em>generic
        singleton factory</em>, is used for function objects (<a href="ch7.xhtml#lev42"
        style="text-decoration: none;">Елемент 42</a>) such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Collections.reverseOrder</code>,
      and occasionally for collections such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Collections.emptySet</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Suppose
      that you want to write an identity function dispenser. The libraries
      provide<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Function.identity</code>,
      so there’s no reason to write your own (<a href="ch9.xhtml#lev59" style="text-decoration: none;">Елемент
        59</a>), but it is instructive. It would be wasteful to create a new
      identity function object time one is requested, because it’s stateless. If
      Java’s generics were reified, you would need one identity function per
      type, but since they’re erased a generic singleton will suffice. Here’s
      how it looks:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex42a" id="pch5ex42" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Generic singleton factory pattern</strong><br>
      private static UnaryOperator&lt;Object&gt; IDENTITY_FN = (t) -&gt; t;<br>
      <br>
      <strong>@SuppressWarnings("unchecked")</strong><br>
      public static &lt;T&gt; UnaryOperator&lt;T&gt; identityFunction() {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return<span class="Apple-converted-space">&nbsp;</span><strong>(UnaryOperator&lt;T&gt;)</strong><span
        class="Apple-converted-space">&nbsp;</span>IDENTITY_FN;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      cast of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">IDENTITY_FN</code><span
        class="Apple-converted-space">&nbsp;</span>to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">(UnaryFunction&lt;T&gt;)</code><span
        class="Apple-converted-space">&nbsp;</span>generates an unchecked cast
      warning, as<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">UnaryOperator&lt;Object&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>is not a<code style="font-family: 'Courier New', monospace;">UnaryOperator&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>for every<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code>. But the
      identity function is special: it returns its argument unmodified, so we
      know that it is typesafe to use it as a<code style="font-family: 'Courier New', monospace;">UnaryFunction&lt;T&gt;</code>,
      whatever the value of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code>.<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_137"></span>Therefore, we can confidently
      suppress the unchecked cast warning generated by this cast. Once we’ve
      done this, the code compiles without error or warning.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here
      is a sample program that uses our generic singleton as a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">UnaryOperator&lt;String&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">UnaryOperator&lt;Number&gt;</code>.
      As usual, it contains no casts and compiles without errors or warnings:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex43a" id="pch5ex43" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Sample program to exercise generic singleton</strong><br>
      public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;String[] strings = { "jute", "hemp", "nylon" };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;UnaryOperator&lt;String&gt; sameString =
      identityFunction();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (String s : strings)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(sameString.apply(s));<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;Number[] numbers = { 1, 2.0, 3L };<br>
      &nbsp;&nbsp;&nbsp;&nbsp;UnaryOperator&lt;Number&gt; sameNumber =
      identityFunction();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (Number n : numbers)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(sameNumber.apply(n));<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">It
      is permissible, though relatively rare, for a type parameter to be bounded
      by some expression involving that type parameter itself. This is what’s
      known as a<span class="Apple-converted-space">&nbsp;</span><em>recursive
        type bound</em>. A common use of recursive type bounds is in connection
      with the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable</code><span
        class="Apple-converted-space">&nbsp;</span>interface, which defines a
      type’s natural ordering (<a href="ch3.xhtml#lev14" style="text-decoration: none;">Елемент
        14</a>). This interface is shown here:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex44a" id="pch5ex44" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      interface Comparable&lt;T&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int compareTo(T o);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      type parameter<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">T</code><span
        class="Apple-converted-space">&nbsp;</span>defines the type to which
      elements of the type implementing<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Comparable&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>can be compared. In practice,
      nearly all types can be compared only to elements of their own type. So,
      for example,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">String</code><span
        class="Apple-converted-space">&nbsp;</span>implements<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Comparable&lt;String&gt;</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Integer</code><span
        class="Apple-converted-space">&nbsp;</span>implements<code style="font-family: 'Courier New', monospace;">Comparable&lt;Integer&gt;</code>,
      and so on.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Many
      methods take a collection of elements implementing<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Comparable</code><span class="Apple-converted-space">&nbsp;</span>to
      sort it, search within it, calculate its minimum or maximum, and the like.
      To do these things, it is required that every element in the collection be
      comparable to every other element in it, in other words, that the elements
      of the list be<span class="Apple-converted-space">&nbsp;</span><em>mutually
        comparable</em>. Here is how to express that constraint:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex45a" id="pch5ex45" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Using a recursive type bound to express mutual comparability</strong><br>
      public static<span class="Apple-converted-space">&nbsp;</span><strong>&lt;E
        extends Comparable&lt;E&gt;&gt;</strong><span class="Apple-converted-space">&nbsp;</span>E
      max(Collection&lt;E&gt; c);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_138"></span>The type bound<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">&lt;E extends
        Comparable&lt;E&gt;&gt;</code><span class="Apple-converted-space">&nbsp;</span>may
      be read as “any type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code><span class="Apple-converted-space">&nbsp;</span>that
      can be compared to itself,” which corresponds more or less precisely to
      the notion of mutual comparability.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here
      is a method to go with the previous declaration. It calculates the maximum
      value in a collection according to its elements’ natural order, and it
      compiles without errors or warnings:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex46a" id="pch5ex46" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Returns max value in a collection - uses recursive type bound</strong><br>
      public static &lt;E extends Comparable&lt;E&gt;&gt; E
      max(Collection&lt;E&gt; c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;if (c.isEmpty())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      IllegalArgumentException("Empty collection");<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;E result = null;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (E e : c)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (result == null ||
      e.compareTo(result) &gt; 0)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result
      = Objects.requireNonNull(e);<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Note
      that this method throws<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">IllegalArgumentException</code><span
        class="Apple-converted-space">&nbsp;</span>if the list is empty. A
      better alternative would be to return an<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Optional&lt;E&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>(<a href="ch8.xhtml#lev55" style="text-decoration: none;">Елемент
        55</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Recursive
      type bounds can get much more complex, but luckily they rarely do. If you
      understand this idiom, its wildcard variant (<a href="ch5.xhtml#lev31" style="text-decoration: none;">Елемент
        31</a>), and the<span class="Apple-converted-space">&nbsp;</span><em>simulated
        self-type</em><span class="Apple-converted-space">&nbsp;</span>idiom (<a
        href="ch2.xhtml#lev2" style="text-decoration: none;">Елемент 2</a>),
      you’ll be able to deal with most of the recursive type bounds you
      encounter in practice.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      summary, generic methods, like generic types, are safer and easier to use
      than methods requiring their clients to put explicit casts on input
      parameters and return values. Like types, you should make sure that your
      methods can be used without casts, which often means making them generic.
      And like types, you should generify existing methods whose use requires
      casts. This makes life easier for new users without breaking existing
      clients (<a href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент
        26</a>).</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        id="lev31" style="text-decoration: none;"></a><span epub:type="pagebreak"
        id="page_139"></span><strong>Елемент 31: Use bounded wildcards to
        increase API flexibility</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">As
      noted in<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елемент 28</a>, parameterized types are<span
        class="Apple-converted-space">&nbsp;</span><em>invariant</em>. In other
      words, for any two distinct types<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Type1</code><span class="Apple-converted-space">&nbsp;</span>and<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Type2</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;Type1&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>is neither a subtype nor a
      supertype of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;Type2&gt;</code>.
      Although it is counterintuitive that<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>is not a subtype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code>,
      it really does make sense. You can put any object into a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code>,
      but you can put only strings into a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code>.
      Since a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>can’t do everything a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;Object&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>can, it isn’t a subtype (by
      the Liskov substitution principal,<span class="Apple-converted-space"> </span><a
        href="ch3.xhtml#lev10" style="text-decoration: none;">Елемент 10</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Sometimes
      you need more flexibility than invariant typing can provide. Consider the<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack</code><span
        class="Apple-converted-space">&nbsp;</span>class from<span class="Apple-converted-space">
      </span><a href="ch5.xhtml#lev29" style="text-decoration: none;">Елемент 29</a>.
      To refresh your memory, here is its public API:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex47a" id="pch5ex47" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Stack&lt;E&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public Stack();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public void push(E e);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public E pop();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public boolean isEmpty();<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Suppose
      we want to add a method that takes a sequence of elements and pushes them
      all onto the stack. Here’s a first attempt:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex48a" id="pch5ex48" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        pushAll method without wildcard type - deficient!</strong><br>
      public void pushAll(Iterable&lt;E&gt; src) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (E e : src)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push(e);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      method compiles cleanly, but it isn’t entirely satisfactory. If the
      element type of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Iterable src</code><span
        class="Apple-converted-space">&nbsp;</span>exactly matches that of the
      stack, it works fine. But suppose you have a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack&lt;Number&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and you invoke<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">push(intVal)</code>,
      where<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">intVal</code><span
        class="Apple-converted-space">&nbsp;</span>is of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Integer</code>. This
      works because<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Integer</code><span
        class="Apple-converted-space">&nbsp;</span>is a subtype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Number</code>. So
      logically, it seems that this should work, too:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex49a" id="pch5ex49" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack&lt;Number&gt;
      numberStack = new Stack&lt;&gt;();<br>
      Iterable&lt;Integer&gt; integers = ... ;<br>
      numberStack.pushAll(integers);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">If
      you try it, however, you’ll get this error message because parameterized
      types are invariant:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex50a" id="pch5ex50" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">StackTest.java:7:
      error: incompatible types: Iterable&lt;Integer&gt;<br>
      cannot be converted to Iterable&lt;Number&gt;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberStack.pushAll(integers);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_140"></span>Luckily, there’s a way out.
      The language provides a special kind of parameterized type call a<span class="Apple-converted-space">&nbsp;</span><em>bounded
        wildcard type</em><span class="Apple-converted-space">&nbsp;</span>to
      deal with situations like this. The type of the input parameter to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pushAll</code><span class="Apple-converted-space">&nbsp;</span>should
      not be “<code style="font-family: 'Courier New', monospace;">Iterable</code><span
        class="Apple-converted-space">&nbsp;</span>of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code>” but “<code style="font-family: 'Courier New', monospace;">Iterable</code><span
        class="Apple-converted-space">&nbsp;</span>of some subtype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code>,” and there is a
      wildcard type that means precisely that:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Iterable&lt;? extends
        E&gt;</code>. (The use of the keyword<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">extends</code><span class="Apple-converted-space">&nbsp;</span>is
      slightly misleading: recall from<span class="Apple-converted-space"> </span><a
        href="ch5.xhtml#lev29" style="text-decoration: none;">Елемент 29</a><span
        class="Apple-converted-space">&nbsp;</span>that<em>subtype</em><span class="Apple-converted-space">&nbsp;</span>is
      defined so that every type is a subtype of itself, even though it does not
      extend itself.) Let’s modify<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pushAll</code><span class="Apple-converted-space">&nbsp;</span>to
      use this type:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex51a" id="pch5ex51" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Wildcard type for a parameter that serves as an E producer</strong><br>
      public void pushAll(<strong>Iterable&lt;? extends E&gt;</strong><span class="Apple-converted-space">&nbsp;</span>src)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (E e : src)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push(e);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">With
      this change, not only does<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">&nbsp;</span>compile
      cleanly, but so does the client code that wouldn’t compile with the
      original<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">pushAll</code><span
        class="Apple-converted-space">&nbsp;</span>declaration. Because<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack</code><span class="Apple-converted-space">&nbsp;</span>and
      its client compile cleanly, you know that everything is typesafe.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Now
      suppose you want to write a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">popAll</code><span class="Apple-converted-space">&nbsp;</span>method
      to go with<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">pushAll</code>.
      The<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">popAll</code><span
        class="Apple-converted-space">&nbsp;</span>method pops each element off
      the stack and adds the elements to the given collection. Here’s how a
      first attempt at writing the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">popAll</code><span class="Apple-converted-space">&nbsp;</span>method
      might look:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex52a" id="pch5ex52" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        popAll method without wildcard type - deficient!</strong><br>
      public void popAll(Collection&lt;E&gt; dst) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (!isEmpty())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst.add(pop());<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Again,
      this compiles cleanly and works fine if the element type of the
      destination collection exactly matches that of the stack. But again, it
      isn’t entirely satisfactory. Suppose you have a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack&lt;Number&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and variable of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Object</code>. If you pop
      an element from the stack and store it in the variable, it compiles and
      runs without error. So shouldn’t you be able to do this, too?</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex53a" id="pch5ex53" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Stack&lt;Number&gt;
      numberStack = new Stack&lt;Number&gt;();<br>
      Collection&lt;Object&gt; objects = ... ;<br>
      numberStack.popAll(objects);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">If
      you try to compile this client code against the version of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">popAll</code><span class="Apple-converted-space">&nbsp;</span>shown
      earlier, you’ll get an error very similar to the one that we got with our
      first version of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">pushAll</code>:<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Collection&lt;Object&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>is not a subtype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Collection&lt;Number&gt;</code>.
      Once again, wildcard types provide a way out. The type of the input
      parameter to<span class="Apple-converted-space">&nbsp;</span><span epub:type="pagebreak"
        id="page_141"></span><code style="font-family: 'Courier New', monospace;">popAll</code><span
        class="Apple-converted-space">&nbsp;</span>should not be “collection of<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code>”
      but “collection of some supertype of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code>” (where
      supertype is defined such that<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code><span class="Apple-converted-space">&nbsp;</span>is
      a supertype of itself [JLS, 4.10]). Again, there is a wildcard type that
      means precisely that:<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Collection&lt;? super
        E&gt;</code>. Let’s modify<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">popAll</code><span class="Apple-converted-space">&nbsp;</span>to
      use it:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex54a" id="pch5ex54" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Wildcard type for parameter that serves as an E consumer</strong><br>
      public void popAll(<strong>Collection&lt;? super E&gt;</strong><span class="Apple-converted-space">&nbsp;</span>dst)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;while (!isEmpty())<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dst.add(pop());<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">With
      this change, both<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack</code><span
        class="Apple-converted-space">&nbsp;</span>and the client code compile
      cleanly.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      lesson is clear.<span class="Apple-converted-space">&nbsp;</span><strong>For
        maximum flexibility, use wildcard types on input parameters that
        represent producers or consumers.</strong><span class="Apple-converted-space">&nbsp;</span>If
      an input parameter is both a producer and a consumer, then wildcard types
      will do you no good: you need an exact type match, which is what you get
      without any wildcards.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here
      is a mnemonic to help you remember which wildcard type to use:</p>
    <p class="center" style="margin-top: 7.5px; margin-bottom: 7.5px; text-align: center; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>PECS
        stands for producer-</strong><code style="font-family: 'Courier New', monospace;"><strong>extends</strong></code><strong>,
        consumer-</strong><code style="font-family: 'Courier New', monospace;"><strong>super</strong></code><strong>.</strong></p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      other words, if a parameterized type represents a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code><span class="Apple-converted-space">&nbsp;</span>producer,
      use<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">&lt;?
        extends T&gt;</code>; if it represents a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code><span class="Apple-converted-space">&nbsp;</span>consumer,
      use<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">&lt;?
        super T&gt;</code>. In our<code style="font-family: 'Courier New', monospace;">Stack</code><span
        class="Apple-converted-space">&nbsp;</span>example,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pushAll</code>’s<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">src</code><span class="Apple-converted-space">&nbsp;</span>parameter
      produces<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>instances for use by the<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Stack</code>,
      so the appropriate type for<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">src</code><span class="Apple-converted-space">&nbsp;</span>is<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Iterable&lt;?
        extends E&gt;</code>;<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">popAll</code>’s<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">dst</code><span class="Apple-converted-space">&nbsp;</span>parameter
      consumes<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>instances from the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Stack</code>, so the
      appropriate type for<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">dst</code><span class="Apple-converted-space">&nbsp;</span>is<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Collection&lt;?
        super E&gt;</code>. The PECS mnemonic captures the fundamental principle
      that guides the use of wild-card types. Naftalin and Wadler call it the<span
        class="Apple-converted-space">&nbsp;</span><em>Get and Put Principle</em>[Naftalin07,
      2.4].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">With
      this mnemonic in mind, let’s take a look at some method and constructor
      declarations from previous Елементs in this chapter. The<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Chooser</code>constructor
      in<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev28" style="text-decoration: none;">Елемент
        28</a><span class="Apple-converted-space">&nbsp;</span>has this
      declaration:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex55a" id="pch5ex55" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      Chooser(Collection&lt;T&gt; choices)</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      constructor uses the collection<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">choices</code><span class="Apple-converted-space">&nbsp;</span>only
      to<span class="Apple-converted-space">&nbsp;</span><strong>produce</strong><span
        class="Apple-converted-space">&nbsp;</span>values of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code><span class="Apple-converted-space">&nbsp;</span>(and
      stores them for later use), so its declaration should use a wildcard type
      that<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>extends</strong><span
          class="Apple-converted-space">&nbsp;</span>T</code>. Here’s the
      resulting constructor declaration:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex56a" id="pch5ex56" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Wildcard type for parameter that serves as an T producer</strong><br>
      public Chooser(Collection&lt;<strong>? extends T</strong>&gt; choices)</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">And
      would this change make any difference in practice? Yes, it would. Suppose
      you have a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code>,
      and you want to pass it in to the constructor<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_142"></span>for a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Chooser&lt;Number&gt;</code>.
      This would not compile with the original declaration, but it does once you
      add the bounded wildcard type to the declaration.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Now
      let’s look at the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">union</code><span
        class="Apple-converted-space">&nbsp;</span>method from<span class="Apple-converted-space">
      </span><a href="ch5.xhtml#lev30" style="text-decoration: none;">Елемент 30</a>.
      Here is the declaration:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex57a" id="pch5ex57" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Both
      parameters,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">s1</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">s2</code>, are<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code><span class="Apple-converted-space">&nbsp;</span>producers,
      so the PECS mnemonic tells us that the declaration should be as follows:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex58a" id="pch5ex58" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;?
      extends E&gt; s2)</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Note
      that the return type is still<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Set&lt;E&gt;</code>.<span
        class="Apple-converted-space">&nbsp;</span><strong>Do not use bounded
        wildcard types as return types.</strong><span class="Apple-converted-space">&nbsp;</span>Rather
      than providing additional flexibility for your users, it would force them
      to use wildcard types in client code. With the revised declaration, this
      code will compile cleanly:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex59a" id="pch5ex59" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Set&lt;Integer&gt;&nbsp;&nbsp;integers
      =&nbsp;&nbsp;Set.of(1, 3, 5);<br>
      Set&lt;Double&gt;&nbsp;&nbsp; doubles&nbsp;&nbsp;=&nbsp;&nbsp;Set.of(2.0,
      4.0, 6.0);<br>
      Set&lt;Number&gt;&nbsp;&nbsp;
      numbers&nbsp;&nbsp;=&nbsp;&nbsp;union(integers, doubles);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Properly
      used, wildcard types are nearly invisible to the users of a class. They
      cause methods to accept the parameters they should accept and reject those
      they should reject.<span class="Apple-converted-space">&nbsp;</span><strong>If
        the user of a class has to think about wildcard types, there is probably
        something wrong with its API.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Prior
      to Java 8, the type inference rules were not clever enough to handle the
      previous code fragment, which requires the compiler to use the
      contextually specified return type (or<span class="Apple-converted-space">&nbsp;</span><em>target
        type</em>) to infer the type of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">E</code>. The target type
      of the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">union</code><span
        class="Apple-converted-space">&nbsp;</span>invocation shown earlier is<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Set&lt;Number&gt;</code>.
      If you try to compile the fragment in an earlier version of Java (with an
      appropriate replacement for the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Set.of</code><span class="Apple-converted-space">&nbsp;</span>factory),
      you’ll get a long, convoluted error message like this:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex60a" id="pch5ex60" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Union.java:14:
      error: incompatible types<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;Number&gt; numbers
      = union(integers, doubles);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      ^<br>
      &nbsp;&nbsp;required: Set&lt;Number&gt;<br>
      &nbsp;&nbsp;found:&nbsp;&nbsp;&nbsp;&nbsp;Set&lt;INT#1&gt;<br>
      &nbsp;&nbsp;where INT#1,INT#2 are intersection types:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;INT#1 extends Number,Comparable&lt;? extends
      INT#2&gt;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;INT#2 extends Number,Comparable&lt;?&gt;</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Luckily
      there is a way to deal with this sort of error. If the compiler doesn’t
      infer the correct type, you can always tell it what type to use with an<em>explicit
        type<span class="Apple-converted-space">&nbsp;</span><span epub:type="pagebreak"
          id="page_143"></span>argument</em><span class="Apple-converted-space">&nbsp;</span>[JLS,
      15.12]. Even prior to the introduction of target typing in Java 8, this
      isn’t something that you had to do often, which is good because explicit
      type arguments aren’t very pretty. With the addition of an explicit type
      argument, as shown here, the code fragment compiles cleanly in versions
      prior to Java 8:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex61a" id="pch5ex61" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Explicit type parameter - required prior to Java 8</strong><br>
      Set&lt;Number&gt; numbers = Union<strong>.&lt;Number&gt;</strong>union(integers,
      doubles);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Next
      let’s turn our attention to the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">max</code><span class="Apple-converted-space">&nbsp;</span>method
      in<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev30" style="text-decoration: none;">Елемент
        30</a>. Here is the original declaration:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex62a" id="pch5ex62" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list)</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here
      is a revised declaration that uses wildcard types:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex63a" id="pch5ex63" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static &lt;T extends<span class="Apple-converted-space">&nbsp;</span><strong>Comparable&lt;?
        super T&gt;</strong>&gt; T max(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>List&lt;? extends
        T&gt;</strong><span class="Apple-converted-space">&nbsp;</span>list)</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">To
      get the revised declaration from the original, we applied the PECS
      heuristic twice. The straightforward application is to the parameter<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">list</code>.
      It produces<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">T</code><span
        class="Apple-converted-space">&nbsp;</span>instances, so we change the
      type from<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;? extends T&gt;</code>.
      The tricky application is to the type parameter<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code>. This is the
      first time we’ve seen a wildcard applied to a type parameter. Originally,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">T</code><span
        class="Apple-converted-space">&nbsp;</span>was specified to extend<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable&lt;T&gt;</code>,
      but a comparable of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code>consumes<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code><span class="Apple-converted-space">&nbsp;</span>instances
      (and produces integers indicating order relations). Therefore, the
      parameterized type<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>is replaced by the bounded
      wildcard type<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable&lt;?
        super T&gt;</code>. Comparables are always consumers, so you should
      generally<span class="Apple-converted-space">&nbsp;</span><strong>use</strong><span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>Comparable&lt;?
          super T&gt;</strong></code><span class="Apple-converted-space">&nbsp;</span><strong>in
        preference to</strong><span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;"><strong>Comparable&lt;T&gt;</strong></code><strong>.</strong><span
        class="Apple-converted-space">&nbsp;</span>The same is true of
      comparators; therefore, you should generally<span class="Apple-converted-space">&nbsp;</span><strong>use</strong><span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>Comparator&lt;?
          super T&gt;</strong></code><span class="Apple-converted-space">&nbsp;</span><strong>in
        preference to</strong><span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;"><strong>Comparator&lt;T&gt;</strong></code><strong>.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      revised<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">max</code><span
        class="Apple-converted-space">&nbsp;</span>declaration is probably the
      most complex method declaration in this book. Does the added complexity
      really buy you anything? Again, it does. Here is a simple example of a
      list that would be excluded by the original declaration but is permitted
      by the revised one:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex64a" id="pch5ex64" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">List&lt;ScheduledFuture&lt;?&gt;&gt;
      scheduledFutures = ... ;</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      reason that you can’t apply the original method declaration to this list
      is that<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">ScheduledFuture</code><span
        class="Apple-converted-space">&nbsp;</span>does not implement<code style="font-family: 'Courier New', monospace;">Comparable&lt;ScheduledFuture&gt;</code>.
      Instead, it is a subinterface of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Delayed</code>, which
      extends<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparable&lt;Delayed&gt;</code>.
      In other words, a<code style="font-family: 'Courier New', monospace;">ScheduledFuture</code><span
        class="Apple-converted-space">&nbsp;</span>instance isn’t merely
      comparable to other<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_144"></span><code style="font-family: 'Courier New', monospace;">ScheduledFuture</code><span
        class="Apple-converted-space">&nbsp;</span>instances; it is comparable
      to any<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Delayed</code><span
        class="Apple-converted-space">&nbsp;</span>instance, and that’s enough
      to cause the original declaration to reject it. More generally, the
      wildcard is required to support types that do not implement<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Comparable</code>(or<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Comparator</code>)
      directly but extend a type that does.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      is one more wildcard-related topic that bears discussing. There is a
      duality between type parameters and wildcards, and many methods can be
      declared using one or the other. For example, here are two possible
      declarations for a static method to swap two indexed Елементs in a list.
      The first uses an unbounded type parameter (<a href="ch5.xhtml#lev30" style="text-decoration: none;">Елемент
        30</a>) and the second an unbounded wildcard:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex65a" id="pch5ex65" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Two possible declarations for the swap method</strong><br>
      public static<span class="Apple-converted-space">&nbsp;</span><strong>&lt;E&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>void swap(<strong>List&lt;E&gt;
        list</strong>, int i, int j);<br>
      public static void swap(<strong>List&lt;?&gt; list</strong>, int i, int
      j);</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Which
      of these two declarations is preferable, and why? In a public API, the
      second is better because it’s simpler. You pass in a list—any list—and the
      method swaps the indexed elements. There is no type parameter to worry
      about. As a rule,<span class="Apple-converted-space">&nbsp;</span><strong>if
        a type parameter appears only once in a method declaration, replace it
        with a wildcard.</strong><span class="Apple-converted-space">&nbsp;</span>If
      it’s an unbounded type parameter, replace it with an unbounded wildcard;
      if it’s a bounded type parameter, replace it with a bounded wildcard.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There’s
      one problem with the second declaration for<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">swap</code>. The
      straightforward implementation won’t compile:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex66a" id="pch5ex66" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static void swap(List&lt;?&gt; list, int i, int j) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;list.set(i, list.set(j, list.get(i)));<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Trying
      to compile it produces this less-than-helpful error message:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex67a" id="pch5ex67" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Swap.java:5:
      error: incompatible types: Object cannot be<br>
      converted to CAP#1<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list.set(i, list.set(j,
      list.get(i)));<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;^<br>
      &nbsp;&nbsp;where CAP#1 is a fresh type-variable:<br>
      &nbsp;&nbsp;&nbsp;&nbsp;CAP#1 extends Object from capture of ?</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">It
      doesn’t seem right that we can’t put an element back into the list that we
      just took it out of. The problem is that the type of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">list</code><span class="Apple-converted-space">&nbsp;</span>is<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;?&gt;</code>,
      and you can’t put any value except<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">null</code><span class="Apple-converted-space">&nbsp;</span>into
      a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;?&gt;</code>.
      Fortunately, there is a way to implement this method without resorting to
      an unsafe cast or a raw type. The idea is to write a<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_145"></span>private helper method to<span
        class="Apple-converted-space">&nbsp;</span><em>capture</em><span class="Apple-converted-space">&nbsp;</span>the
      wildcard type. The helper method must be a generic method in order to
      capture the type. Here’s how it looks:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex68a" id="pch5ex68" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static void swap(List&lt;?&gt; list, int i, int j) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;swapHelper(list, i, j);<br>
      }<br>
      <br>
      <strong>// Private helper method for wildcard capture</strong><br>
      private static &lt;E&gt; void swapHelper(List&lt;E&gt; list, int i, int j)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;list.set(i, list.set(j, list.get(i)));<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">swapHelper</code><span
        class="Apple-converted-space">&nbsp;</span>method knows that<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">list</code><span class="Apple-converted-space">&nbsp;</span>is
      a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;E&gt;</code>.
      Therefore, it knows that any value it gets out of this list is of type<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>and that it’s safe to put any
      value of type<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">E</code><span
        class="Apple-converted-space">&nbsp;</span>into the list. This slightly
      convoluted implementation of<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">swap</code><span class="Apple-converted-space">&nbsp;</span>compiles
      cleanly. It allows us to export the nice wildcard-based declaration, while
      taking advantage of the more complex generic method internally. Clients of
      the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">swap</code><span
        class="Apple-converted-space">&nbsp;</span>method don’t have to confront
      the more complex<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">swapHelper</code><span
        class="Apple-converted-space">&nbsp;</span>declaration, but they do
      benefit from it. It is worth noting that the helper method has precisely
      the signature that we dismissed as too complex for the public method.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      summary, using wildcard types in your APIs, while tricky, makes the APIs
      far more flexible. If you write a library that will be widely used, the
      proper use of wildcard types should be considered mandatory. Remember the
      basic rule: producer-<code style="font-family: 'Courier New', monospace;">extends</code>,
      consumer-<code style="font-family: 'Courier New', monospace;">super</code><span
        class="Apple-converted-space">&nbsp;</span>(PECS). Also remember that
      all comparables and comparators are consumers.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        id="lev32" style="text-decoration: none;"></a><span epub:type="pagebreak"
        id="page_146"></span><strong>Елемент 32: Combine generics and varargs
        judiciously</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Varargs
      methods (<a href="ch8.xhtml#lev53" style="text-decoration: none;">Елемент
        53</a>) and generics were both added to the platform in Java 5, so you
      might expect them to interact gracefully; sadly, they do not. The purpose
      of varargs is to allow clients to pass a variable number of arguments to a
      method, but it is a<span class="Apple-converted-space">&nbsp;</span><em>leaky
        abstraction</em>: when you invoke a varargs method, an array is created
      to hold the varargs parameters; that array, which should be an
      implementation detail, is visible. As a consequence, you get confusing
      compiler warnings when varargs parameters have generic or parameterized
      types.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Recall
      from<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елемент 28</a><span class="Apple-converted-space">&nbsp;</span>that
      a non-reifiable type is one whose runtime representation has less
      information than its compile-time representation, and that nearly all
      generic and parameterized types are non-reifiable. If a method declares
      its varargs parameter to be of a non-reifiable type, the compiler
      generates a warning on the declaration. If the method is invoked on
      varargs parameters whose inferred type is non-reifiable, the compiler
      generates a warning on the invocation too. The warnings look something
      like this:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex69a" id="pch5ex69" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">warning:
      [unchecked] Possible heap pollution from<br>
      &nbsp;&nbsp;&nbsp;&nbsp;parameterized vararg type List&lt;String&gt;</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><em>Heap
        pollution</em><span class="Apple-converted-space">&nbsp;</span>occurs
      when a variable of a parameterized type refers to an object that is not of
      that type [JLS, 4.12.2]. It can cause the compiler’s automatically
      generated casts to fail, violating the fundamental guarantee of the
      generic type system.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">For
      example, consider this method, which is a thinly disguised variant of the
      code fragment on page 127:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex70a" id="pch5ex70" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Mixing generics and varargs can violate type safety!</strong><br>
      static void dangerous(<strong>List&lt;String&gt;... stringLists</strong>)
      {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;List&lt;Integer&gt; intList = List.of(42);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Object[] objects = stringLists;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;objects[0] =
intList;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>//
        Heap pollution</strong><br>
      &nbsp;&nbsp;&nbsp;&nbsp;String s = stringLists[0].get(0);<span class="Apple-converted-space">&nbsp;</span><strong>//
        ClassCastException</strong><br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      method has no visible casts yet throws a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space">&nbsp;</span>when invoked with one or more
      arguments. Its last line has an invisible cast that is generated by the
      compiler. This cast fails, demonstrating that type safety has been
      compromised, and<span class="Apple-converted-space">&nbsp;</span><strong>it
        is unsafe to store a value in a generic varargs array parameter.</strong></p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      example raises an interesting question: Why is it even legal to declare a
      method with a generic varargs parameter, when it is illegal to create a
      generic array explicitly? In other words, why does the method shown
      previously generate only a warning, while the code fragment on page 127
      generates an error? The<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_147"></span>answer is that methods with
      varargs parameters of generic or parameterized types can be very useful in
      practice, so the language designers opted to live with this inconsistency.
      In fact, the Java libraries export several such methods, including<code style="font-family: 'Courier New', monospace;">Arrays.asList(T...
        a)</code>,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Collections.addAll(Collection&lt;?
        super T&gt; c, T... elements)</code>, and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">EnumSet.of(E first, E...
        rest)</code>. Unlike the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">dangerous</code><span class="Apple-converted-space">&nbsp;</span>method
      shown earlier, these library methods are typesafe.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Prior
      to Java 7, there was nothing the author of a method with a generic varargs
      parameter could do about the warnings at the call sites. This made these
      APIs unpleasant to use. Users had to put up with the warnings or,
      preferably, to eliminate them with<code style="font-family: 'Courier New', monospace;">@SuppressWarnings("unchecked")</code><span
        class="Apple-converted-space">&nbsp;</span>annotations at every call
      site (<a href="ch5.xhtml#lev27" style="text-decoration: none;">Елемент 27</a>).
      This was tedious, harmed readability, and hid warnings that flagged real
      issues.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      Java 7, the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">SafeVarargs</code><span
        class="Apple-converted-space">&nbsp;</span>annotation was added to the
      platform, to allow the author of a method with a generic varargs parameter
      to suppress client warnings automatically. In essence,<span class="Apple-converted-space">&nbsp;</span><strong>the</strong><span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>SafeVarargs</strong></code><span
        class="Apple-converted-space">&nbsp;</span><strong>annotation
        constitutes a promise by the author of a method that it is typesafe.</strong><span
        class="Apple-converted-space">&nbsp;</span>In exchange for this promise,
      the compiler agrees not to warn the users of the method that calls may be
      unsafe.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">It
      is critical that you do not annotate a method with<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">@SafeVarargs</code><span
        class="Apple-converted-space">&nbsp;</span>unless it actually<span class="Apple-converted-space">&nbsp;</span><em>is</em><span
        class="Apple-converted-space">&nbsp;</span>safe. So what does it take to
      ensure this? Recall that a generic array is created when the method is
      invoked, to hold the varargs parameters. If the method doesn’t store
      anything into the array (which would overwrite the parameters) and doesn’t
      allow a reference to the array to escape (which would enable untrusted
      code to access the array), then it’s safe. In other words, if the varargs
      parameter array is used only to transmit a variable number of arguments
      from the caller to the method—which is, after all, the purpose of
      varargs—then the method is safe.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">It
      is worth noting that you can violate type safety without ever storing
      anything in the varargs parameter array. Consider the following generic
      varargs method, which returns an array containing its parameters. At first
      glance, it may look like a handy little utility:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex71a" id="pch5ex71" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        UNSAFE - Exposes a reference to its generic parameter array!</strong><br>
      static &lt;T&gt; T[] toArray(T... args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return args;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      method simply returns its varargs parameter array. The method may not look
      dangerous, but it is! The type of this array is determined by the
      compile-time types of the arguments passed in to the method, and the
      compiler may not have enough information to make an accurate
      determination. Because this method returns its varargs parameter array, it
      can propagate heap pollution up the call stack.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_148"></span>To make this concrete,
      consider the following generic method, which takes three arguments of type<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">T</code><span
        class="Apple-converted-space">&nbsp;</span>and returns an array
      containing two of the arguments, chosen at random:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex72a" id="pch5ex72" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">static
      &lt;T&gt; T[] pickTwo(T a, T b, T c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;switch(ThreadLocalRandom.current().nextInt(3)) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: return toArray(a, b);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: return toArray(a, c);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: return toArray(b, c);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError(); // Can't get here<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      method is not, in and of itself, dangerous and would not generate a
      warning except that it invokes the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">toArray</code><span class="Apple-converted-space">&nbsp;</span>method,
      which has a generic varargs parameter.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">When
      compiling this method, the compiler generates code to create a varargs
      parameter array in which to pass two<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code><span class="Apple-converted-space">&nbsp;</span>instances
      to<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">toArray</code>.
      This code allocates an array of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Object[]</code>, which is
      the most specific type that is guaranteed to hold these instances, no
      matter what types of objects are passed to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pickTwo</code><span class="Apple-converted-space">&nbsp;</span>at
      the call site. The<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">toArray</code><span
        class="Apple-converted-space">&nbsp;</span>method simply returns this
      array to<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">pickTwo</code>,
      which in turn returns it to its caller, so<code style="font-family: 'Courier New', monospace;">pickTwo</code><span
        class="Apple-converted-space">&nbsp;</span>will always return an array
      of type<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Object[]</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Now
      consider this main method, which exercises<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pickTwo</code>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex73a" id="pch5ex73" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;String[] attributes = pickTwo("Good", "Fast",
      "Cheap");<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      is nothing at all wrong with this method, so it compiles without
      generating any warnings. But when you run it, it throws a<code style="font-family: 'Courier New', monospace;">ClassCastException</code>,
      though it contains no visible casts. What you don’t see is that the
      compiler has generated a hidden cast to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">String[]</code><span class="Apple-converted-space">&nbsp;</span>on
      the value returned by<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">pickTwo</code><span class="Apple-converted-space">&nbsp;</span>so
      that it can be stored in<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">attributes</code>. The
      cast fails, because<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Object[]</code><span class="Apple-converted-space">&nbsp;</span>is
      not a subtype of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">String[]</code>.
      This failure is quite disconcerting because it is two levels removed from
      the method that actually causes the heap pollution (<code style="font-family: 'Courier New', monospace;">toArray</code>),
      and the varargs parameter array is not modified after the actual
      parameters are stored in it.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      example is meant to drive home the point that<span class="Apple-converted-space">&nbsp;</span><strong>it
        is unsafe to give another method access to a generic varargs parameter
        array,</strong>with two exceptions: it is safe to pass the array to
      another varargs method that is correctly annotated with<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">@SafeVarargs</code>, and
      it is safe to pass the array to a non-varargs method that merely computes
      some function of the contents of the array.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_149"></span>Here is a typical example of
      a safe use of a generic varargs parameter. This method takes an arbitrary
      number of lists as arguments and returns a single list containing the
      elements of all of the input lists in sequence. Because the method is
      annotated with<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">@SafeVarargs</code>,
      it doesn’t generate any warnings, on the declaration or at its call sites:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex74a" id="pch5ex74" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Safe method with a generic varargs parameter</strong><br>
      @SafeVarargs<br>
      static &lt;T&gt; List&lt;T&gt; flatten(List&lt;? extends T&gt;... lists) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt; result = new ArrayList&lt;&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (List&lt;? extends T&gt; list : lists)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addAll(list);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      rule for deciding when to use the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">SafeVarargs</code><span class="Apple-converted-space">&nbsp;</span>annotation
      is simple:<span class="Apple-converted-space">&nbsp;</span><strong>Use</strong><span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;"><strong>@SafeVarargs</strong></code><span
        class="Apple-converted-space">&nbsp;</span><strong>on every method with
        a varargs parameter of a generic or parameterized type,</strong><span class="Apple-converted-space">&nbsp;</span>so
      its users won’t be burdened by needless and confusing compiler warnings.
      This implies that you should<em>never</em><span class="Apple-converted-space">&nbsp;</span>write
      unsafe varargs methods like<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">dangerous</code><span class="Apple-converted-space">&nbsp;</span>or<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">toArray</code>.
      Every time the compiler warns you of possible heap pollution from a
      generic varargs parameter in a method you control, check that the method
      is safe. As a reminder, a generic varargs methods is safe if:</p>
    <p class="number1" style="margin-top: 2.6666667px; margin-bottom: 2.6666667px; margin-left: 36px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">1.
      it doesn’t store anything in the varargs parameter array, and</p>
    <p class="number1" style="margin-top: 2.6666667px; margin-bottom: 2.6666667px; margin-left: 36px; text-indent: -16px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">2.
      it doesn’t make the array (or a clone) visible to untrusted code. If
      either of these prohibitions is violated, fix it.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Note
      that the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">SafeVarargs</code><span
        class="Apple-converted-space">&nbsp;</span>annotation is legal only on
      methods that can’t be overridden, because it is impossible to guarantee
      that every possible overriding method will be safe. In Java 8, the
      annotation was legal only on static methods and final instance methods; in
      Java 9, it became legal on private instance methods as well.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">An
      alternative to using the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">SafeVarargs</code><span class="Apple-converted-space">&nbsp;</span>annotation
      is to take the advice of<span class="Apple-converted-space"> </span><a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елемент 28</a><span class="Apple-converted-space">&nbsp;</span>and
      replace the varargs parameter (which is an array in disguise) with a<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List</code><span
        class="Apple-converted-space">&nbsp;</span>parameter. Here’s how this
      approach looks when applied to our<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">flatten</code><span class="Apple-converted-space">&nbsp;</span>method.
      Note that only the parameter declaration has changed:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex75a" id="pch5ex75" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        List as a typesafe alternative to a generic varargs parameter</strong><br>
      static &lt;T&gt; List&lt;T&gt; flatten(<strong>List&lt;List&lt;? extends
        T&gt;&gt; lists</strong>) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;List&lt;T&gt; result = new ArrayList&lt;&gt;();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;for (List&lt;? extends T&gt; list : lists)<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.addAll(list);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return result;<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_150"></span>This method can then be used
      in conjunction with the static factory method<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List.of</code><span class="Apple-converted-space">&nbsp;</span>to
      allow for a variable number of arguments. Note that this approach relies
      on the fact that the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List.of</code><span class="Apple-converted-space">&nbsp;</span>declaration
      is annotated with<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">@SafeVarargs</code>:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex76a" id="pch5ex76" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">audience
      = flatten(List.of(friends, romans, countrymen));</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      advantage of this approach is that the compiler can<span class="Apple-converted-space">&nbsp;</span><em>prove</em><span
        class="Apple-converted-space">&nbsp;</span>that the method is typesafe.
      You don’t have to vouch for its safety with a<code style="font-family: 'Courier New', monospace;">SafeVarargs</code><span
        class="Apple-converted-space">&nbsp;</span>annotation, and you don’t
      have worry that you might have erred in determining that it was safe. The
      main disadvantage is that the client code is a bit more verbose and may be
      a bit slower.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      trick can also be used in situations where it is impossible to write a
      safe varargs method, as is the case with the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">toArray</code><span class="Apple-converted-space">&nbsp;</span>method
      on page 147. Its<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List</code><span
        class="Apple-converted-space">&nbsp;</span>analogue<span class="Apple-converted-space">&nbsp;</span><em>is</em><span
        class="Apple-converted-space">&nbsp;</span>the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List.of</code><span class="Apple-converted-space">&nbsp;</span>method,
      so we don’t even have to write it; the Java libraries authors have done
      the work for us. The<code style="font-family: 'Courier New', monospace;">pickTwo</code><span
        class="Apple-converted-space">&nbsp;</span>method then becomes this:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex77a" id="pch5ex77" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">static
      &lt;T&gt;<span class="Apple-converted-space">&nbsp;</span><strong>List&lt;T&gt;</strong><span
        class="Apple-converted-space">&nbsp;</span>pickTwo(T a, T b, T c) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;switch(rnd.nextInt(3)) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0: return<span class="Apple-converted-space">&nbsp;</span><strong>List.of(a,
        b)</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1: return<span class="Apple-converted-space">&nbsp;</span><strong>List.of(a,
        c)</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2: return<span class="Apple-converted-space">&nbsp;</span><strong>List.of(b,
        c)</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;throw new AssertionError();<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">and
      the main method becomes this:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex78a" id="pch5ex78" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>List&lt;String&gt;</strong><span class="Apple-converted-space">&nbsp;</span>attributes
      = pickTwo("Good", "Fast", "Cheap");<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      resulting code is typesafe because it uses only generics, and not arrays.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      summary, varargs and generics do not interact well because the varargs
      facility is a leaky abstraction built atop arrays, and arrays have
      different type rules from generics. Though generic varargs parameters are
      not typesafe, they are legal. If you choose to write a method with a
      generic (or parameterized) varargs parameter, first ensure that the method
      is typesafe, and then annotate it with<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">@SafeVarargs</code><span
        class="Apple-converted-space">&nbsp;</span>so it is not unpleasant to
      use.</p>
    <h3 class="h3" style="font-size: 21px; margin-top: 26.666668px; margin-bottom: 13.333334px; page-break-after: avoid; margin-left: 80px; text-indent: -80px; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        id="lev33" style="text-decoration: none;"></a><span epub:type="pagebreak"
        id="page_151"></span><strong>Елемент 33: Consider typesafe heterogeneous
        containers</strong></h3>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Common
      uses of generics include collections, such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Set&lt;E&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Map&lt;K,V&gt;</code>,
      and single-element containers, such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ThreadLocal&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and<code style="font-family: 'Courier New', monospace;">AtomicReference&lt;T&gt;</code>.
      In all of these uses, it is the container that is parameterized. This
      limits you to a fixed number of type parameters per container. Normally
      that is exactly what you want. A<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Set</code><span class="Apple-converted-space">&nbsp;</span>has
      a single type parameter, representing its element type; a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Map</code><span class="Apple-converted-space">&nbsp;</span>has
      two, representing its key and value types; and so forth.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Sometimes,
      however, you need more flexibility. For example, a database row can have
      arbitrarily many columns, and it would be nice to be able to access all of
      them in a typesafe manner. Luckily, there is an easy way to achieve this
      effect. The idea is to parameterize the<span class="Apple-converted-space">&nbsp;</span><em>key</em><span
        class="Apple-converted-space">&nbsp;</span>instead of the<em>container</em>.
      Then present the parameterized key to the container to insert or retrieve
      a value. The generic type system is used to guarantee that the type of the
      value agrees with its key.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">As
      a simple example of this approach, consider a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>class
      that allows its clients to store and retrieve a favorite instance of
      arbitrarily many types. The<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      for the type will play the part of the parameterized key. The reason this
      works is that class<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>is
      generic. The type of a class literal is not simply<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code>, but<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class&lt;T&gt;</code>.
      For example,<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">String.class</code><span
        class="Apple-converted-space">&nbsp;</span>is of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class&lt;String&gt;</code>,
      and<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Integer.class</code><span
        class="Apple-converted-space">&nbsp;</span>is of type<code style="font-family: 'Courier New', monospace;">Class&lt;Integer&gt;</code>.
      When a class literal is passed among methods to communicate both
      compile-time and runtime type information, it is called a<em>type token</em><span
        class="Apple-converted-space">&nbsp;</span>[<a href="ref.xhtml#rBracha04"
        style="text-decoration: none;">Bracha04</a>].</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      API for the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>class is simple. It looks
      just like a simple map, except that the key is parameterized instead of
      the map. The client presents a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      when setting and getting favorites. Here is the API:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex79a" id="pch5ex79" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Typesafe heterogeneous container pattern - API</strong><br>
      public class Favorites {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; void putFavorite(Class&lt;T&gt;
      type, T instance);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; T getFavorite(Class&lt;T&gt;
      type);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here
      is a sample program that exercises the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>class,
      storing, retrieving, and printing a favorite<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">String</code>,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Integer</code>, and<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class</code><span
        class="Apple-converted-space">&nbsp;</span>instance:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex80a" id="pch5ex80" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Typesafe heterogeneous container pattern - client</strong><br>
      public static void main(String[] args) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Favorites f = new Favorites();<br>
      &nbsp;&nbsp;&nbsp;&nbsp;f.putFavorite(String.class, "Java");<br>
      &nbsp;&nbsp;&nbsp;&nbsp;f.putFavorite(Integer.class, 0xcafebabe);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;f.putFavorite(Class.class, Favorites.class);<br>
      <span epub:type="pagebreak" id="page_152"></span>&nbsp;&nbsp;&nbsp;&nbsp;String
      favoriteString = f.getFavorite(String.class);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;int favoriteInteger =
      f.getFavorite(Integer.class);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;Class&lt;?&gt; favoriteClass =
      f.getFavorite(Class.class);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;System.out.printf("%s %x %s%n", favoriteString,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;favoriteInteger,
      favoriteClass.getName());<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">As
      you would expect, this program prints<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Java cafebabe Favorites</code>.
      Note, incidentally, that Java’s<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">printf</code><span class="Apple-converted-space">&nbsp;</span>method
      differs from C’s in that you should use<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">%n</code><span class="Apple-converted-space">&nbsp;</span>where
      you’d use<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">\n</code><span
        class="Apple-converted-space">&nbsp;</span>in C. The<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">%n</code><span class="Apple-converted-space">&nbsp;</span>generates
      the applicable platform-specific line separator, which is<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">\n</code><span class="Apple-converted-space">&nbsp;</span>on
      many but not all platforms.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">A<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>instance is<span class="Apple-converted-space">&nbsp;</span><em>typesafe</em>:
      it will never return an<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Integer</code><span class="Apple-converted-space">&nbsp;</span>when
      you ask it for a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">String</code>.
      It is also<span class="Apple-converted-space">&nbsp;</span><em>heterogeneous</em>:
      unlike an ordinary map, all the keys are of different types. Therefore, we
      call<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>a<span class="Apple-converted-space">&nbsp;</span><em>typesafe
        heterogeneous container</em>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      implementation of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>is surprisingly tiny. Here it
      is, in its entirety:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex81a" id="pch5ex81" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Typesafe heterogeneous container pattern - implementation</strong><br>
      public class Favorites {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;private<span class="Apple-converted-space">&nbsp;</span><strong>Map&lt;Class&lt;?&gt;,
        Object&gt; favorites</strong><span class="Apple-converted-space">&nbsp;</span>=
      new HashMap&lt;&gt;();<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; void putFavorite(Class&lt;T&gt;
      type, T instance) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;favorites.put(Objects.requireNonNull(type),
      instance);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      <br>
      &nbsp;&nbsp;&nbsp;&nbsp;public &lt;T&gt; T getFavorite(Class&lt;T&gt;
      type) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return<span class="Apple-converted-space">&nbsp;</span><strong>type.cast(favorites.get(type))</strong>;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}порівняння<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      are a few subtle things going on here. Each<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>instance
      is backed by a private<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Map&lt;Class&lt;?&gt;,
        Object&gt;</code><span class="Apple-converted-space">&nbsp;</span>called<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">favorites</code>.
      You might think that you couldn’t put anything into this<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Map</code><span class="Apple-converted-space">&nbsp;</span>because
      of the unbounded wildcard type, but the truth is quite the opposite. The
      thing to notice is that the wildcard type is nested: it’s not the type of
      the map that’s a wildcard type but the type of its key. This means that
      every key can have a<span class="Apple-converted-space">&nbsp;</span><em>different</em><span
        class="Apple-converted-space">&nbsp;</span>parameterized type: one can
      be<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class&lt;String&gt;</code>,
      the next<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class&lt;Integer&gt;</code>,
      and so on. That’s where the heterogeneity comes from.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      next thing to notice is that the value type of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">favorites Map</code><span
        class="Apple-converted-space">&nbsp;</span>is simply<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Object</code>. In other
      words, the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Map</code><span
        class="Apple-converted-space">&nbsp;</span>does not guarantee the type
      relationship between keys and values, which is that every value is of the
      type represented by its key. In<span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_153"></span>fact, Java’s type system is
      not powerful enough to express this. But we know that it’s true, and we
      take advantage of it when the time comes to retrieve a favorite.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">putFavorite</code><span
        class="Apple-converted-space">&nbsp;</span>implementation is trivial: it
      simply puts into<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">favorites</code><span
        class="Apple-converted-space">&nbsp;</span>a mapping from the given<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class</code><span
        class="Apple-converted-space">&nbsp;</span>object to the given favorite
      instance. As noted, this discards the “type linkage” between the key and
      the value; it loses the knowledge that the value is an instance of the
      key. But that’s OK, because the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">getFavorites</code><span
        class="Apple-converted-space">&nbsp;</span>method can and does
      reestablish this linkage.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      implementation of<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">getFavorite</code><span
        class="Apple-converted-space">&nbsp;</span>is trickier than that of<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">putFavorite</code>.
      First, it gets from the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">favorites</code><span class="Apple-converted-space">&nbsp;</span>map
      the value corresponding to the given<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object.
      This is the correct object reference to return, but it has the wrong
      compile-time type: it is<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Object</code><span class="Apple-converted-space">&nbsp;</span>(the
      value type of the<code style="font-family: 'Courier New', monospace;">favorites</code><span
        class="Apple-converted-space">&nbsp;</span>map) and we need to return a<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">T</code>.
      So, the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">getFavorite</code><span
        class="Apple-converted-space">&nbsp;</span>implementation<span class="Apple-converted-space">&nbsp;</span><em>dynamically
        casts</em><span class="Apple-converted-space">&nbsp;</span>the object
      reference to the type represented by the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object,
      using<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class</code>’s<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">cast</code><span
        class="Apple-converted-space">&nbsp;</span>method.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">cast</code><span
        class="Apple-converted-space">&nbsp;</span>method is the dynamic
      analogue of Java’s cast operator. It simply checks that its argument is an
      instance of the type represented by the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object.
      If so, it returns the argument; otherwise it throws a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code>.
      We know that the cast invocation in<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">getFavorite</code>won’t
      throw<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">ClassCastException</code>,
      assuming the client code compiled cleanly. That is to say, we know that
      the values in the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">favorites</code><span
        class="Apple-converted-space">&nbsp;</span>map always match the types of
      their keys.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">So
      what does the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">cast</code><span
        class="Apple-converted-space">&nbsp;</span>method do for us, given that
      it simply returns its argument? The signature of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">cast</code><span class="Apple-converted-space">&nbsp;</span>method
      takes full advantage of the fact that class<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>is
      generic. Its return type is the type parameter of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex82a" id="pch5ex82" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      class Class&lt;T&gt; {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;T cast(Object obj);<br>
      }</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">This
      is precisely what’s needed by the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">getFavorite</code><span class="Apple-converted-space">&nbsp;</span>method.
      It is what allows us to make<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>typesafe
      without resorting to an unchecked cast to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">T</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      are two limitations to the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>class
      that are worth noting. First, a malicious client could easily corrupt the
      type safety of a<code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>instance, by using a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      in its raw form. But the resulting client code would generate an unchecked
      warning when it was compiled. This is no different from a normal
      collection implementations such as<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">&nbsp;</span>and<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">HashMap</code>.
      You can easily put a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">&nbsp;</span>into
      a<code style="font-family: 'Courier New', monospace;">HashSet&lt;Integer&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>by using the raw type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">HashSet</code><span class="Apple-converted-space">&nbsp;</span>(<a
        href="ch5.xhtml#lev26" style="text-decoration: none;">Елемент 26</a>).
      That said, you can have runtime type safety if you’re willing to pay for
      it. The way to ensure that<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>never
      violates its type invariant is to have the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">putFavorite</code><span class="Apple-converted-space">&nbsp;</span><span
        epub:type="pagebreak" id="page_154"></span>method check that<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">instance</code><span class="Apple-converted-space">&nbsp;</span>is
      actually an instance of the type represented by<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">type</code>, and we
      already know how to do this. Just use a dynamic cast:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex83a" id="pch5ex83" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Achieving runtime type safety with a dynamic cast</strong><br>
      public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;favorites.put(type, type.cast(instance));<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">There
      are collection wrappers in<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">java.util.Collections</code><span
        class="Apple-converted-space">&nbsp;</span>that play the same trick.
      They are called<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">checkedSet</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">checkedList</code>,<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">checkedMap</code>,
      and so forth. Their static factories take a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      (or two) in addition to a collection (or map). The static factories are
      generic methods, ensuring that the compile-time types of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      and the collection match. The wrappers add reification to the collections
      they wrap. For example, the wrapper throws a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">ClassCastException</code><span
        class="Apple-converted-space">&nbsp;</span>at runtime if someone tries
      to put a<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Coin</code><span
        class="Apple-converted-space">&nbsp;</span>into your<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Collection&lt;Stamp&gt;</code>.
      These wrappers are useful for tracking down client code that adds an
      incorrectly typed element to a collection, in an application that mixes
      generic and raw types.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      second limitation of the<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>class
      is that it cannot be used on a non-reifiable type (<a href="ch5.xhtml#lev28"
        style="text-decoration: none;">Елемент 28</a>). In other words, you can
      store your favorite<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">String</code><span class="Apple-converted-space">&nbsp;</span>or<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">String[]</code>,
      but not your favorite<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code>.
      If you try to store your favorite<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code>,
      your program won’t compile. The reason is that you can’t get a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      for<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code>.
      The class literal<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;.class</code><span
        class="Apple-converted-space">&nbsp;</span>is a syntax error, and it’s a
      good thing, too.<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>share a single<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object,
      which is<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List.class</code>.
      It would wreak havoc with the internals of a<code style="font-family: 'Courier New', monospace;">Favorites</code><span
        class="Apple-converted-space">&nbsp;</span>object if the “type literals”<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">List&lt;String&gt;.class</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">List&lt;Integer&gt;.class</code><span
        class="Apple-converted-space">&nbsp;</span>were legal and returned the
      same object reference. There is no entirely satisfactory workaround for
      this limitation.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      type tokens used by<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Favorites</code><span class="Apple-converted-space">&nbsp;</span>are
      unbounded:<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">getFavorite</code><span
        class="Apple-converted-space">&nbsp;</span>and<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">put-Favorite</code><span
        class="Apple-converted-space">&nbsp;</span>accept any<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object.
      Sometimes you may need to limit the types that can be passed to a method.
      This can be achieved with a<span class="Apple-converted-space">&nbsp;</span><em>bounded
        type token</em>, which is simply a type token that places a bound on
      what type can be represented, using a bounded type parameter (<a href="ch5.xhtml#lev30"
        style="text-decoration: none;">Елемент 30</a>) or a bounded wildcard (<a
        href="ch5.xhtml#lev31" style="text-decoration: none;">Елемент 31</a>).</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">The
      annotations API (<a href="ch6.xhtml#lev39" style="text-decoration: none;">Елемент
        39</a>) makes extensive use of bounded type tokens. For example, here is
      the method to read an annotation at runtime. This method comes from the<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">AnnotatedElement</code><span
        class="Apple-converted-space">&nbsp;</span>interface, which is
      implemented by the reflective types that represent classes, methods,
      fields, and other program elements:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex84a" id="pch5ex84" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">public
      &lt;T extends Annotation&gt;<br>
      &nbsp;&nbsp;&nbsp;&nbsp;T getAnnotation(Class&lt;T&gt; annotationType);</p>
    <p class="noindent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 0.0026666669px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span
        epub:type="pagebreak" id="page_155"></span>The argument,<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">annotationType</code>, is
      a bounded type token representing an annotation type. The method returns
      the element’s annotation of that type, if it has one, or<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">null</code>, if it
      doesn’t. In essence, an annotated element is a typesafe heterogeneous
      container whose keys are annotation types.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Suppose
      you have an object of type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class&lt;?&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>and you want to pass it to a
      method that requires a bounded type token, such as<code style="font-family: 'Courier New', monospace;">getAnnotation</code>.
      You could cast the object to<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class&lt;? extends
        Annotation&gt;</code>, but this cast is unchecked, so it would generate
      a compile-time warning (<a href="ch5.xhtml#lev27" style="text-decoration: none;">Елемент
        27</a>). Luckily, class<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>provides
      an instance method that performs this sort of cast safely (and
      dynamically). The method is called<code style="font-family: 'Courier New', monospace;">asSubclass</code>,
      and it casts the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">Class</code><span
        class="Apple-converted-space">&nbsp;</span>object on which it is called
      to represent a subclass of the class represented by its argument. If the
      cast succeeds, the method returns its argument; if it fails, it throws a<span
        class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">ClassCastException</code>.</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">Here’s
      how you use the<span class="Apple-converted-space">&nbsp;</span><code style="font-family: 'Courier New', monospace;">asSubclass</code><span
        class="Apple-converted-space">&nbsp;</span>method to read an annotation
      whose type is unknown at compile time. This method compiles without error
      or warning:</p>
    <p class="codelink" style="font-size: 0.88em; margin-top: 8px; margin-bottom: 8px; font-weight: bold; page-break-after: avoid; font-family: sans-serif; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a
        href="ch5_images.xhtml#pch5ex85a" id="pch5ex85" style="text-decoration: none;">&nbsp;</a></p>
    <p class="pre" style="font-family: 'Courier New', monospace; font-size: 0.88em; margin-top: 13.333334px; margin-bottom: 13.333334px; margin-left: 20px; text-align: justify; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><strong>//
        Use of asSubclass to safely cast to a bounded type token</strong><br>
      static Annotation getAnnotation(AnnotatedElement element,<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String
      annotationTypeName) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;<strong>Class&lt;?&gt; annotationType</strong><span
        class="Apple-converted-space">&nbsp;</span>= null; // Unbounded type
      token<br>
      &nbsp;&nbsp;&nbsp;&nbsp;try {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;annotationType =
      Class.forName(annotationTypeName);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;} catch (Exception ex) {<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new
      IllegalArgumentException(ex);<br>
      &nbsp;&nbsp;&nbsp;&nbsp;}<br>
      &nbsp;&nbsp;&nbsp;&nbsp;return element.getAnnotation(<br>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>annotationType.asSubclass(Annotation.class)</strong>);<br>
      }</p>
    <p class="indent" style="margin-top: 0px; margin-bottom: 0px; text-indent: 20px; font-family: sans-serif; font-size: medium; font-weight: normal; letter-spacing: normal; line-height: 1.6; orphans: auto; text-align: justify; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px;">In
      summary, the normal use of generics, exemplified by the collections APIs,
      restricts you to a fixed number of type parameters per container. You can
      get around this restriction by placing the type parameter on the key
      rather than the container. You can use<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>objects
      as keys for such typesafe heterogeneous containers. A<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Class</code><span class="Apple-converted-space">&nbsp;</span>object
      used in this fashion is called a type token. You can also use a custom key
      type. For example, you could have a<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">DatabaseRow</code><span class="Apple-converted-space">&nbsp;</span>type
      representing a database row (the container), and a generic type<span class="Apple-converted-space">&nbsp;</span><code
        style="font-family: 'Courier New', monospace;">Column&lt;T&gt;</code><span
        class="Apple-converted-space">&nbsp;</span>as its key.</p>
    <p></p>
    <p>1 </p>
  </body>
</html>
