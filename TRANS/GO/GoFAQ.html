<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Frequently Asked Questions (FAQ) - The Go Programming Language</title>
    <link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">
    <link rel="search" type="application/opensearchdescription+xml" title="godoc"
      href="/opensearch.xml">
    <link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
    <script type="text/javascript">window.initFuncs = [];</script>
    <script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["b._setAccount", "UA-49880327-6"]);
window.trackPageview = function() {
  _gaq.push(["_trackPageview", location.pathname+location.hash]);
  _gaq.push(["b._trackPageview", location.pathname+location.hash]);
};
window.trackPageview();
</script> </head>
  <body>
    <div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;"><sub>
        ... </sub></div>
    <sub> </sub>
    <div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;"><sub>
        ... </sub></div>
    <sub><img src="file:///home/ac2epsilon/Dropbox/TRANS/ROR/Single%20Page%20%20%20Ruby%20on%20Rails%20Tutorial%20%283rd%20Ed.%29%20%20%20Softcover.io_files/seg"
        height="1" border="0" width="1">Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a>, Ніжин 2015 </sub>
    <div id="page" class="wide">
      <div class="container">
        <h1>Frequently Asked Questions (FAQ)</h1>
        <div id="nav"></div>
        <h2 id="Origins">Походження</h2>
        <h3 id="What_is_the_purpose_of_the_project">Яке призначення проекту?</h3>
        <p>На протязі десятиріччя не виникло важливої системної мови, але за цей
          час обчислювальний ландшафт змінився суттєво. Ось кілька тенденцій: </p>
        <ul>
          <li>Комп’ютери є невимовно швидші, але розробка програмного
            забезпечення не стала скоріша. </li>
          <li>Управління залежностіми сьогодні є великою частиною розробки
            програмного забезпечення, але “файли загловків” в мовах з
            традиціями&nbsp; C є антонімами до чистого аналізу залежностей — та
            швидкої компіляції. </li>
          <li>Є наростаючий протест проти громіздких систем типів, як ті, що
            в&nbsp; Java та C++, що підштовхує людей до динамічно типізованих
            мов, таких, як Python та JavaScript. </li>
          <li>Деякі фундаментальні концепції, такі як збирання сміття та
            паралельне обчислення, не дуже гарно підтримуються мовами популярних
            систем. </li>
          <li> Наступ багатоядерних комп’ютерів генерую занепокоєння та
            стурбованість. </li>
        </ul>
        <p>Ми віримо, що слід спробувати знову, створивши нову мову, конкурентну
          мову зі збиранням сміття, зі швидкою компіляцією. Щодо зазначеного
          вище: </p>
        <ul>
          <li>Можливо скомпілювати велику програму на Go за декілька секунд на
            одному комп’ютері. </li>
          <li> Go провадить модель для конструювання програмного забезпечення,
            що робить аналіз залежностей простим та уникає більшість розходів
            від включених файлів в стилі C та бібліотек. </li>
          <li>Система типів Go не має ієрархії. так що немає витрат часу
            навизначення відносин між типами. Також, позаяк Go має статичні
            типи, мова намагається зробити відчуття від типів легшим, ніж в
            типових OO мовах. </li>
          <li> Go повністю побудований на збиранні сміття, та провадить
            фундаментальну підтримку для конкурентної комунікації. </li>
          <li> По своїй будові Go просуває підхід для конструювання системного
            програмного забезпечення на багатоядерних машинах. </li>
        </ul>
        <p>Значно більш розширена відповідь на це питання доступна в статті <a
            href="//talks.golang.org/2012/splash.article">Go at Google: Language
            Design in the Service of Software Engineering</a>. </p>
        <h3 id="What_is_the_status_of_the_project"> Яким є статус проекту?</h3>
        <p> Go став публічний мідкритим кодом 10го листопада 2009 року. Після
          пари років дуже активної розробки, настав час стабільності, та Go 1
          був <a href="//blog.golang.org/2012/03/go-version-1-is-released.html">випущений</a>
          28 березня 2012 року. Go 1, що включає <a href="/ref/spec">специфікацію
            мови</a>, <a href="/pkg/">стандартні бібліотеки</a>, та <a href="/cmd/go/">власні
            інсрументи</a>, провадить стабільне підгрунтя для створення надійних
          продуктів, проектів та публікацій. </p>
        <p>З цією встановленою стабільністю, ми використовуємо Go для розробки
          програм, продуктів та інструментів, скоріше, ніж активно змінюємо мову
          та бібліотеки. Фактично призначення Go 1 є запровадити<a href="/doc/go1compat.html">
            довготермінову стабільність</a>. Зворотньо-несумісні зміни не будуть
          зроблені до жодного випуску Go 1. Ми бажаємо добре вивчити, як
          майбутні версії Go можуть виглядати, скоріше, ніж гратися з
          підгрунтями мови. </p>
        <p>Звісно, розробка буде продовжуватись над самим Go, але фокус буде на
          продуктивності, надійності, портативності та додаванням нової
          функціональності, такої, як розширена підтримка інтернаціолізації. </p>
        <p> Одного дня може гарно утворитись Go 2, але не через кілька років, та
          він буде навіяний тим, що ми навчимось, використовуючи Go 1, такий,
          яким ми його маємо сьогодні. </p>
        <h3 id="What_is_the_origin_of_the_name"> Звідки походить ім’я?</h3>
        <p> “Ogle” може бути гарним іменем для Go debugger. </p>
        <h3 id="Whats_the_origin_of_the_mascot"> Звідки походить талісман?</h3>
        <p> Талісман та лого були розроблені&nbsp;<a href="http://reneefrench.blogspot.com">Renée
            French</a>, що також розробила <a href="http://plan9.bell-labs.com/plan9/glenda.html">Glenda</a>,
          зайчиху з Plan 9. Тваринка (гофер) походить від того, що вона
          використала для дизайна <a href="http://wfmu.org/">WFMU</a>
          T-shirt&nbsp; декілька років тому. Лого та талісман захищені ліцензією
          <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons
            Attribution 3.0</a>. </p>
        <h3 id="history">Яке історія проекту?</h3>
        <p> Robert Griesemer, Rob Pike та Ken Thompson почали замальовки по
          цілям для нової мови на білій дошці 21 вересня 2007го року. За
          декілька днів цілі перетворилися на план щось зробити та ясна ідея що
          це має бути. Розробка продовжилась в вільний від інших непов’язаних
          робіт час. В січні&nbsp; 2008го Ken почав роботу над компілятором, з
          якими вивчались ідеї; він генерував код C в якості вихідного. За пів
          року проект став роботою на повний час, та був досі стабільний для
          створення виробничого компілятора. В травні 2008го Ian Taylor
          незалежно почав створення фронтенду GCC для Go з використанням
          чорнової специфікації. Russ Cox приєднавсяв кінці 2008го та допоміг
          перенести мову та бібліотеки з прототипу в реальність. </p>
        <p> Go став проектом з публічним відкритим кодом 10го листопада 2009го
          року. Багато людей зі спільноти вкладали свої ідеї, дискусію та код. </p>
        <h3 id="creating_a_new_language"> Чому ви створили нову мову?</h3>
        <p> Go народився з розчарування в існуючих мовах та оточеннях для
          системного програмування. Програмування стало надто складним та вибір
          мов був частково виною цього. Людина мала обирати або ефективний
          компілятор, ефективне виконання або легкість програмування; всі три
          властивості не були доступні в одній поширеній мові. Програмісти, якщо
          могли, обирали спрощення ніж безпеку та ефектівність, переміщуючись в
          динамічно типізовані мови, такі як Python та JavaScript, скорішен, ніж
          C++ або, в меньшій мірі, Java. </p>
        <p> Go є спробою комбінувати простоту програмування інтерпретованої,
          динамічно типізованої мови, з ефективністю та безпекою статично
          типізованої, компільованої мови. Він також намагається бути сучасним,
          з підтримкою мережевого та багатоядерного обчислення. Нарешті, він
          призначений бути&nbsp;<i>швидким</i>: він має забирати щонайбільше
          декілька секунд для побудови великого виконавчого файлу на одному
          комп’ютері. Щоб задовільнити цім цілям потрібно звернутись до
          декількох лінгвістичних питань: виразна, але легковажна система типів;
          конкурентність та збирання сміття; жорстка специфікація залежностей;
          та таке інше. Ці питання не можна добре вирішити завдяки бібліотекам
          або інструментам; це був запит на створення нової мови. </p>
        <p>Стаття <a href="//talks.golang.org/2012/splash.article">Go at Google</a>
          дискутує підгрунтя та мотивацію мови Go, а також провадить більше
          деталей щодо багатьох питань, наведених в цьому FAQ. </p>
        <h3 id="ancestors">Які попередники є в Go?</h3>
        <p> Go здебільшого з&nbsp; сім’ї C (базовий синтаксис), зі значним
          впливом сімейства Pascal/Modula/Oberon (декларації, пакунки), плюс
          деякі ідеї з мов, надихнутих CSP від Tony Hoare, таких як Newsqueak та
          Limbo (конкурентність). Однак це нова мова з усіх боків. В кожному
          аспекті мова була розроблена з думкою про те, що промісти роблять, та
          як зробити програмування, принаймні той тип програмування, що
          використовуємо ми, зробити більш ефективнм, що означає більше розваги.
        </p>
        <h3 id="principles">Що було керівними принципами при розробці?</h3>
        <p> Програмування сьогодні включає дуже багато бугалтерії, повторень, та
          роботи клерків. Як каже Dick Gabriel, “Старі програми читаються як
          тиха розмова між гарно розмовляючим робітником-дослідником, та гарно
          навченим механічним колегою, а не як дебати з компілятором. Хто міг
          знати, що витонченість створить такий шум?” Витонченість варта того,
          ніхто не хоче повертатись до стрих мов, але чи не можна досягти її
          більш тихіше? </p>
        <p> Go намагається зменшити кількість друкування в обох сенсах цього
          слова. Через свій дизайн, ми намагалися зменшити метушню та
          складність. Немає попередніх декларацій та нема файлв заголовків; все
          декларується тільки один раз. Ініціалізація виразна, автоматична, та
          проста в використанні. Синтаксис чистий та легкий по частині ключових
          слів. Заїкання (<code>foo.Foo* myFoo = new(foo.Foo)</code>) скорочено
          завдяки протсій декларації типів з використанням конструкції
          декларація-та-ініціалізація <code>:=</code>. Та, можливо, найбільш
          радикально - немає ієрархії типів: типи просто <i>є</i>, вони не
          повинні анонсувати свої відносини. Ці спрощення дозволяють Go бути
          виразним, та при тому зрозумілим, без принесення в жертву, так,
          витонченість.</p>
        Інший важливий принцип є утримувати концепцій ортогональними. Методи
        можуть бути реалізовані для кожного типу; структури репрезентують дані,
        тоді як інтерфейси репрезентують абстракції; і так далі. Ортогональність
        спрощує розуміння того, що відбувається, коли речі комбінуються.
        <h2 id="Usage">Використання</h2>
        <h3 id="Is_Google_using_go_internally"> Чи Google використовує Go
          внутрішньо?</h3>
        <p> Так. Тепер є декілька Go програм, розгорнутих в виробничому
          середовищі в самому Google. Публічний приклад є сервер за
          лаштунками&nbsp;<a href="//golang.org">golang.org</a>. Це лише сервер
          документу <a href="/cmd/godoc"><code>godoc</code></a>, що в вирбничій
          конфігурації на <a href="https://developers.google.com/appengine/">Google
            App Engine</a>. </p>
        <p>Другий приклад включає систему <a href="//code.google.com/p/vitess/">Vitess</a>
          для високо-масштабних інсталяцій SQL&nbsp; та сервер завантажень
          Google, <code>dl.google.com</code>, що доставляє двійникові файли
          Chrome та інші великі інсталяції, такі, як пакунки <code>apt-get</code>.
        </p>
        <h3 id="Do_Go_programs_link_with_Cpp_programs"> Чи програми Go
          лінкується з програмами C/C++?</h3>
        <p>Є дві реалізації компілятора Go, <code>gc</code> (програма <code>6g</code>
          та її друзі) та <code>gccgo</code>. <code>Gc</code> використовує
          іншу домовленість по викликам, та лінкер, так що може лінкуватись з C
          пргграмами, що використовують такі ж домовленості. Є такій компілятор
          C, але нема такого компілятора C++. <code>Gccgo</code> є фронтендом
          GCC, що може, із засторогою, бути злінкований до GCC-сумісними C або
          C++ програмами. </p>
        <p>Програма <a href="/cmd/cgo/">cgo</a> провадить механізм для
          інтерфейсу&nbsp; “зовнішніх функцій”, та дозволяє безпечний
          виклик&nbsp; бібліотек C з коду Go. SWIG розширює цю можливість на
          бібліотеки C++. </p>
        <h3 id="Does_Go_support_Google_protocol_buffers">Чи Go підтримує буфери
          протоколу Google?</h3>
        <p> Є окремий проект з відкритим кодом, що провадить необхідний додаток
          до компілятора та бібліотеку. Він доступний на&nbsp;<a href="//code.google.com/p/goprotobuf/">code.google.com/p/goprotobuf/</a>
        </p>
        <h3 id="Can_I_translate_the_Go_home_page">Можу я перевести домашню
          сторінку Go на іншу мову?</h3>
        <p>Абсолютно. Ми заохочуємо розробників робити сайти Go Language на
          власних мовах. Однак якщо ви обрали додати логотип Google або інші
          атрибути бренду до вашого сайту (це не з’являється на <a href="//golang.org/">golang.org</a>),
          вам буде потрібно слідувати настановам на <a href="//www.google.com/permissions/guidelines.html">www.google.com/permissions/guidelines.html</a>
        </p>
        <h2 id="Design">Дизайн</h2>
        <h3 id="unicode_identifiers">Що відбувається ідентифікаторами?</h3>
        <p>Для нас було важливо звільнити простір ідентифікаторів від
          обмеженості ASCII. Правило Go — символи ідентифікаторів identifier
          мають бути буквами або цифрами, як визначено в Unicode — просто щоб
          зрозуміти та реалізовати, але має обмеження. Комбінувати символи
          виключено за дизайном, наприклад. Доки немає узгодженого зовнішнього
          визначення, щодо того, чим може буте ідентифікатор, плюс визначення
          канонізації ідентифікаторів, що гарантуватиме відсутність
          двозначності, здається буде кращим притримати комбіновані символи за
          межами міксу. Таким чином, ми маємо просте правило, що може бути
          розширене пізніше без руйнування програм, таке, що уникає помилок, які
          будуть напевне виникати за правила, що визнає неоднозначні
          ідентифікатори. </p>
        <p>Одне з пов’язаних зауважень: оскільки експортований ідентифікатор
          мусить починатися з великої літери, ідентифікатори, створені з "буков"
          якоїсь мови, не може бути експортованим. На сьогодні єдиним рішенням є
          використання чогось на кшталт&nbsp;<code>X日本語</code>, що, зрозуміло,
          не є задовільним; ми роздумуємо над іншими варіантами. Однак, правило
          регістр-для-обзорності навряд чи зміниться; це одна за наших улюблених
          можливостей Go. </p>
        <h3 id="Why_doesnt_Go_have_feature_X">Чому Go не має можливості X?</h3>
        <p>Кожна мова містить новаторські можливості та нехтує чиїмось
          улюбленими можливостями. Go був розроблений з поглядом на задоволення
          від програмування, швидкість компіляції, ортогональності концепцій, та
          потреби підтримки можливостей, таких, як конкурентність та збирання
          сміття. Ваша улюблена можливість може бути втрачена, бо вона не
          підходить, тому що вона впливає на швидкість компіляції або ясність
          дизайну, або оскільки може зробити фундаментальну модель системи надто
          складною. </p>
        <p> Якщо ви занепокоєні тим, що Go бракує можливості <var>X</var>,
          будь-ласка пробачте нас та розслідуйте можливості, що має Go. Ви
          можете знайти, що вони компенсують відсутність <var>X <em></em></var>в
          цікавий спосіб. </p>
        <h3 id="generics">Чому Go не має родових типів?</h3>
        <p>Generics (родові типи) можуть бути додані в якійсь час. Ми не
          відчуваємо невідкладність в цьому питанні, хоча ми розуміємо, що деякі
          програмісти - так. </p>
        <p> Родові типи є зручними, але вони приходять разом з ціною в
          складності системи типів та часу виконання. Ми досі не знайшли такий
          дизайн, що надає вигоди, пропорційні складності, хоча ми продовжуємо
          думати про це. Тим часом, мапи та сегменти Go, плюс можливість
          використовувати пусті інтерфейси для створення контейнерів (з явним
          розпакуванням), означає, що в багатьох випадках є можливим написати
          код, що робить те же саме, що й можуть дозволити родові типи, може
          трохи менш гладко. </p>
        <p>Це зостається відкритим питанням. </p>
        <h3 id="exceptions">Чому Go не має виключень?</h3>
        <p>Ми віримо, що поєднання виключень з управляючими структурами, як в
          ідіомі&nbsp;<code>try-catch-finally</code>, призводить до згрнутого
          коду. Це також заохочує програмістів відмічати влеику кількість
          звичайних помилок, таких, як нездібність відкрити файл, як виняткових.
        </p>
        <p> Go приймає інший підхід. Для звичайної обробки помилок, в Go
          багато-значющі повернення роблять простим повідомити про помилку, без
          перевантаження повертаємого значення. <a href="/doc/articles/error_handling.html">Канонічний
            тип помилки, розм з іншими можливостями Go</a>, робить обробку
          помилок приємною, але дещо відмінною від інших мов. </p>
        <p> Go також має декілька вбудованих фукнцій, щоб сигналізувати та
          відновлюватись з дійсно виняткових умов. Механізм відновлення
          виконується тільки як частина частина стану функції, що пішла під
          відкіс після збою, що достатньо для обробки катастрофи, але не
          потребує додаткових структур управління, та, коли використовується
          добре, може призвести до ясного коду обробки помилок.</p>
        <p>Дивіться статтю <a href="/doc/articles/defer_panic_recover.html">Відкладання,
            паніка та відновлення</a> для деталей. </p>
        <h3 id="assertions">Чому Go не має допущеннь?</h3>
        <p> Go не провадить допущеннь. Вони без сумніву зручні, але наш досвід
          полягає в тому, що програмісти використовують їх щоб уникнути мислення
          щодо належної обробки помилок та сповіщень. Належна обробка помилок
          означає, що сервери продовжують функційовати після нефатальних
          помилок, замість того, щоб зламатись. Належне сповіщення означає, що
          помилки є прямі та безпосередні, що уберігає програміста від
          інтерпритації довгої трасировки збою. Точні помилки поміж іншим
          важливі, коли програміст бачить помилки, та не знайомий з кодом.</p>
        <p>Ми розуміємо, що це є точкою зіткненя. Є багато речей в мові Go та
          бібліотеках, що відрізняються від сучасних практик, просто туму, що ми
          відчуваємо сенс спробувати інший підхід. </p>
        <h3 id="csp">Чому конкуренція збудована на ідеях CSP?</h3>
        <p>Програмування конкуренції та багатопоточності мають репутацію
          складних. Ми віримо, що це частково через складний дизайн, як от
          pthreads, та частково через зайвий наголос на низькорівневих деталях,
          таких, як мьютекси, умовні змінні, та бар’єри пам’яті. Високорівневі
          інтерфейси дозволяють значно простіший код,&nbsp; навіть якщо як і
          раніше є мьютекси та таке інше під ковдрою. </p>
        <p>Одна з найбільш успішних моделей для провадження високорівневої
          лінгвістичної підтримки конкунтності походить від&nbsp;Hoare
          Communicating Sequential Processes, або CSP. Occam та Erlang є двома
          добре знаними мовами, що похдять від CSP. Примітиви конкурентності Go
          походять від іншої частини родинного дерева, чий найбільший внесок є
          потужна нотація каналів, як першокласних об’єктів. Досвід з декількома
          ранішніми мовами показав, що модель CSP гарно вписується в фрейморк
          процедурної мови. </p>
        <h3 id="goroutines">Чому використовуються goroutines&nbsp;замість
          потоків?</h3>
        <p> Goroutines я частиною того, щоб зробити конкурентність простою для
          уживання. Ідея, що вже маєріла деякий час, є в тому, щоб
          мультиплексувати незалежно виконувані функції&nbsp; — coroutines — і
          набір потоків. Коли coroutine блокується, наприклад викликаючи
          блокуючий системний виклик, оточення виконання автоматично переміщує
          другі coroutines на тому ж потоці операційної системи в інший, робочий
          потік, так, що вони не будуть блоковані. Програміст не бачить нічого з
          цього, і в цьому є сенс ідеї. Результат від використання goroutines
          може бути дуже дешевим: вони мають невеликі накладні розходи, окрім
          пам’яті в стеці, що є декілька кілобайт. </p>
        <p> Щоб утримуваи стек малим, оточення виконання Go використовує змінний
          розмір обмеженого стеку. Нова відчеканена goroutine отримує декілька
          кілобайтів, що майже завжди досить. Коли ні, оточення збільшує (та
          зменшує) пам’ять, для зберігання стеку автоматично, дозволяючи
          багатьом goroutines жити в поміркованому обсязі пам’яті. Навантаження
          на процесор в середньому складає три дешеві інструкції на один виклик
          функції. Є практичним створювати сотні та тисячі goroutines в одному
          тому адресному просторі. Якщо goroutines були б лише потоками,
          системні ресурси закінчились би на значно меньших кількостях. </p>
        <h3 id="atomic_maps"> Чому операції з мапами не визначені чк атомарні?</h3>
        <p> Після довгої дискуссії було вирішено, що типове використання мап не
          потребує безпечного доступу з багатьох goroutines, та в тих випадках,
          коли це так, мапа була можливо частиною більшої структури даних або
          обчислень, що все були синхронізованими. Таким чином, вимога, щоб
          кожна операція за мапами отримувала мьютекс, буде вповільнювати
          більшість програм, та ли трохи додасть в безпеці. Однак це було не
          легке рішення, оскільки неконтрольованний доступ до мапи може
          зруйнувати програму. </p>
        <p> Мова не запобігає атомарним оновленням мапи. Коли треба, наприклад
          коли приймається недовірена програма, реалізація може заблокувати
          доступ до мапи. </p>
        <h3 id="language_changes"> Чи можете ви прийняти мої зміни до мови?</h3>
        <p>Люди часто пропонують покращення до мови&nbsp; — <a href="//groups.google.com/group/golang-nuts">почтовий
            список</a> містить дагату історію таких дискуссій — але тількі
          небагато з ціх змін було прийнято. </p>
        <p> Хоча Go є проектом з відкритим кодом, мова та бібліотеки
          захищені&nbsp;<a href="/doc/go1compat.html">обіцянкою сумісності</a>,
          і це виключає зміни, що руйнують існуючі програми. Якщо ваша
          пропозиція порушує спицифікацію Go 1, ми не можемо навіть обігрувати
          цю ідею, незалежно від гідності. Наступний головний реліз Go може бути
          несумісним з Go 1, але ми не готові почати говорити про те, що це має
          бути. </p>
        <p>Навіть якщо ваша пропозиція сумісна з специфікацією Go 1, вона може
          бути не в дусі основних цілей Go. стаття <i><a href="//talks.golang.org/2012/splash.article">Go
              at Google: Дизайн мови в Service of Software Engineering</a></i>
          пояснює походження Go та мотивацію за цім дизайном. </p>
        <h2 id="types">Типи</h2>
        <h3 id="Is_Go_an_object-oriented_language">Чи є Go об’єктно-орієнтованою
          мовою?</h3>
        <p>Так і ні. Хоча Go має типи та методи, та дозволяє
          об’єктно-орієнтований стиль програмування, немає ієрархії типів.
          Концепція “інтерфейсів” в Go провадить другий підхід, що, ми віримо, є
          простим в ужитку, та до деякої міри більш загальним. Також є шляхи
          вбудувати типи в інші типи, щоб запровадити щось аналогічне — але не
          ідентчне — до підклассів. Більше того, методи в Go є більш загальним,
          ніж в C++ або Java: вони можуть бути визначені для любого типу даних,
          навіть для вбудованих типів, таких як звичайні, “неогорнуті” цілі.
          Вони не обмежені структурами (класами). </p>
        <p>Також, відсутність ієрархії класів робить “об’єкти” в Go більш
          легковажними, ніж в інших мовах, таких, як C++ або Java. </p>
        <h3 id="How_do_I_get_dynamic_dispatch_of_methods"> Як я можу виконати
          динамічний виклик методів?</h3>
        <p> Єдиним шляхом виконати динамічний виклик методів є використання
          інтерфейсів. Методи на структурах, або будь-які інші типи завжди
          розрішуються статично. </p>
        <h3 id="inheritance">Чому немає наслідування типів?</h3>
        <p>Об’єктно орієнтоване програмування, щонайменше в найбіьш знаних
          мовах, включає дуже багато дускусій щодо співідносин між типими,
          взаємовідносин, що часто можуть бути вирішені автоматично. Go приймає
          інший підхід. </p>
        <p>Скоріше ніж вимагати від програміста заздалегідь декларувати
          взаємозв’язоко двох типів, в Go тип автоматично задовільняє кожному
          інтерфейсу, що задає деяку підмножину його методів. Окрім зменьшення
          бухгалтерії, цей підхід має дійсні переваги. Типи можуть задовільняти
          багатьом інтерфейсам одночасно, без складностей традиційного
          множинного наслідування. Інтерфейси можуть були дуже легковажними —
          інтерфейс з одним або навіть без жодного метода, може виражати корисну
          концепцію. Інтерфейси можуть бути додані заднім числом, якщо з’явилась
          нова ідея або з метод тестування — без анотування оригінальних типів.
          Оскільки намає явного співвідношення між типами та інтерфейсами, немає
          і ієрархії типів, якою треба керувати або з приводу якої треба
          дискутувати. </p>
        <p> Можливо використовувати ці ідеї для побудови чогось подібного до
          типово-безпених каналів Unix. Наприклад,подивіться як <code>fmt.Fprintf</code>
          дозволяє форматований друк до любого виводу, не тільки до файлу, або
          як пакунок&nbsp;<code>bufio </code>може бути повністю відділений від
          файлового I/O, або як пакунок <code>image</code> генерує зжаті файли
          малюнків. Всі ці ідеї походять від одного інтерфейсу (<code>io.Writer</code>),
          що представляє один метод (<code>Write</code>). І це тільки одна
          подряпина на цій поверхні. Інтерфейси Go мають вирішальне значення на
          те, як структуровані програми. </p>
        <p>Це займає деякий час, призвичаїтись до такого стилю, але ця неявна
          залежність типів є найбільш продуктивною річчю, що є в Go. </p>
        <h3 id="methods_on_basics">Чому <code>len</code> є функцією, а не
          методом?</h3>
        <p>Ми обговорювали це питання, але обрали реалізувати&nbsp;<code>len</code>
          та подібні як функції, що є добрим на практиці та не цскладнює питання
          щодо інтерфейсу (в термінах Go) базових типів. </p>
        <h3 id="overloading">Чому Go не підтримує перевантаження методів та
          операторів?</h3>
        <p>Виклик методів спрощується, коли немає потреби також виконувати
          перевірку типів. Досвід з іншими мовами також підказує нам, що мати
          декілька методів з тим же ім’ям, але різними сигнатурами, було іноді
          корисним, але це також може створювати плутанину та є крихким на
          практиці. Співпадіння тільки имені та вимога щодо узгодження типів
          було головним рішенням щодо спрощення в системі типів Go. </p>
        <p>Відносно перевантаження операторів, це виглядає більше як зручність,
          ніж як абсолютна потреба. Знову ж, речі стають простішими без цього. </p>
        <h3 id="implements_interface">Чому Go не має декларації "implements"?</h3>
        <p>Тип Go задовільняє інтерфейсу, реалізуючи методи цього інтерфейсу, і
          ничого іншого. Ця властивість дозволяє інтерфейсам бути визначеними та
          використовуватись без модифікації існуючого коду. Це дозволяє такий
          тип структурної типізації, що просуває розподіл сфер стурбованості та
          покращує повторне використання коду, а також спрощує побудову
          шаблонів, що з’являються по мірі розвитку коду. Семантика інтерфейсів
          є однією з причин, чому Go відчувається таким стрімким та легковажним.
        </p>
        <p>Дивіться <a href="#inheritance">питання по наслідуванню типів</a>
          для додаткових деталей. </p>
        <h3 id="guarantee_satisfies_interface">Як я можу гарантувати, що мій тип
          задовільняє інтерфейсу?</h3>
        <p>Ви можете спитати компілятор, щоб перевірити, що тип&nbsp;<code>T</code>
          реалізує інтерфейс&nbsp;<code>I</code> за допомогою спроби присвоєння:
        </p>
        <pre>type T struct{}
var _ I = T{}   // Перевірити, що T реалізує I.
</pre>
        <p>Якщо <code>T</code> не реалізує&nbsp;<code>I</code>, помилка буде
          спіймана під час компіляції. </p>
        <p>Якщо ви бажаєте, щоб користувачі інтерфейсу явно декларували, що вони
          його реалізують, ви можете додати метод з описовим ім’ям для
          встановлення методу інтерфейсу. Наприклад: </p>
        <pre>type Fooer interface {
    Foo()
    ImplementsFooer()
}
</pre>
        <p>Після цього тип повинен реалізувати метод <code>ImplementsFooer</code>
          щоб бути <code>Fooer</code>, ясно документуючи цей факт та
          повідомляючи&nbsp; про це в&nbsp;<a href="/cmd/godoc/">godoc</a>. </p>
        <pre>type Bar struct{}
func (b Bar) ImplementsFooer() {}
func (b Bar) Foo() {}
</pre>
        <p>Більшість коду не використовує такі обмеження, оскільки вони
          обмежують використання ідеї інтерфейсів. Тим не менш іноді виникає
          потреба розрішити невизначеність між схожими інтерфейсами. </p>
        <h3 id="t_and_equal_interface"> Чому тип T не задовільняє інтерфейсу
          Equal?</h3>
        <p> Розглянемо цей простий інтерфейс, що представляє об’єкт що може
          порівняти себе з іншим значенням: </p>
        <pre>type Equaler interface {
    Equal(Equaler) bool
}
</pre>
        <p> та цей тип, <code>T</code>: </p>
        <pre>type T int
func (t T) Equal(u T) bool { return t == u } // не задовільняє Equaler
</pre>
        <p> На відміну від аналогічної ситуації в деяких поліморфних системах
          типів, <code>T</code> не реалізує <code>Equaler</code>. Тип
          аргументу&nbsp; <code>T.Equal</code> є&nbsp; <code>T</code>, не
          буквально потрібний тип&nbsp; <code>Equaler</code>. </p>
        <p>В Go система типів не просуває аргумент <code>Equal</code>; це є
          відповідальністю програміста, як ілюстровано в типі <code>T2</code>,
          що реалізує <code>Equaler</code>: </p>
        <pre>type T2 int
func (t T2) Equal(u Equaler) bool { return t == u.(T2) }  // задовільняє Equaler
</pre>
        <p>Навіть і це відбувається не таким же чином, як в інших системах
          типів, оскільки в Go <em>кожний</em> тип, що задовільняє&nbsp;<code>Equaler</code>,
          може бути переданийяк аргумент в&nbsp;<code>T2.Equal</code>, і під час
          виконання ми маємо перевірити, що аргумент є типу&nbsp;<code>T2</code>.
          Деякі мови роблять цю перевірку під час компіляції. </p>
        <p>Пов’язаний приклад робить іншим шляхом: </p>
        <pre>type Opener interface {
   Open() Reader
}

func (t T3) Open() *os.File
</pre>
        <p>В Go <code>T3</code> не задовільняє <code>Opener</code>, хоча це
          може бути в іншій мові. </p>
        <p>Хоча це вірно, що система типів в Go робить меньше для програміста в
          цьому сенсі, брак підкласів робить правила щодо задовільняння
          інтерфейсам дуже простим: чи є імена функцій та сигнатури точно такими
          ж, як в інтерфейсі? Правило Go також легко ефективно реалізувати. Ми
          відчуваємо, що ці переваги компенсують брак автоматичного просування
          типів. Якщо одного дня Go буде сприймати якусь з форм родинних типів,
          ми очікуємо, що буде і спосіб виразити ідею ціх прикладів, та також та
          також мати змогу статичної перевірки. </p>
        <h3 id="convert_slice_of_interface">Чи можу я перетворти []T на
          []interface{}?</h3>
        <p>Прямо ні, бо вони не мають того ж вигляду в пам’яті. Необхідно
          скопіювати елементи індивідуально на цільовий сегмент. Цей приклад
          перетворює сегмент з <code>int</code> на сегмент <code>interface{}</code>:
        </p>
        <pre>t := []int{1, 2, 3, 4}
s := make([]interface{}, len(t))
for i, v := range t {
    s[i] = v
}
</pre>
        <h3 id="nil_error">Чому моя помилка nil за значенням не дорівнює nil? </h3>
        <p> Внутрішньо інтерфейси реалізовані як два елементи, тип та значення.
          Значення, що має назву динамічним значенням інтерфейсу, з довільним
          конкретним значенням, та тип це саме тип значення. Для значення <code>int</code>&nbsp;
          3, значення інтерфейсу схематично містить (<code>int</code>, <code>3</code>).
          </p>
        <p>Значення інтерфейсу є <code>nil</code>, тільки якщо внутрішнє
          значення та тип обоє не встановлені, (<code>nil</code>, <code>nil</code>).
          Зокрема, інтерфейс&nbsp;<code>nil</code> буде завжди зберігати тип <code>nil</code>.
          Якщо ми зберігаємо вказівник типу <code>*int</code> в значені
          інтерфейсу, внутрішній тип буде&nbsp;<code>*int</code>, без відносно
          до значення вказівника: (<code>*int</code>, <code>nil</code>). Таким
          чином, значення інтерфейсу буде не-<code>nil</code>, <em>навіть якщо
            внутрішній вказівник є</em> <code>nil</code>. </p>
        <p>Ця ситуація може спантеличити, та часто виникає, коли значення&nbsp;<code>nil</code>
          зберігається в значенні інтерфейсу, такому, яке повертає&nbsp; <code>error</code>:
        </p>
        <pre>func returnsError() error {
	var p *MyError = nil
	if bad() {
		p = ErrBad
	}
	return p // Буде завжди повертати не-nil error.
}
</pre>
        <p>Якщо все піде добре, функція повертає&nbsp;<code>nil</code> <code>p</code>,
          і таким чином повернуте значення є інтерфейс <code>error</code>, що
          містить (<code>*MyError</code>, <code>nil</code>). Це означає, що
          якщо викликаюча сторона порівнює помилку з&nbsp;<code>nil</code>,
          завжди буде виглядати так, що виникла помилка. навіть коли нічого не
          відбулося. Щоб повернути дійсно&nbsp; <code>nil</code> <code>error</code>,
          функція мусить повернути явний <code>nil</code>: </p>
        <pre>func returnsError() error {
	if bad() {
		return ErrBad
	}
	return nil
}
</pre>
        <p>Є доброю ідеєю для функцій, що повертають помилки, завжди
          використовувати тип <code>error</code> в своїй сигнатурі (як ми
          робили вище), скоріше, ніж конкретний тип, такий, як&nbsp;<code>*MyError</code>,
          щоб допомогти гарантувати, що помилка створна коректно. В якості
          приклада, <a href="/pkg/os/#Open"><code>os.Open</code></a> повертає <code>error</code>,
          навіть якщо якщо це не <code>nil</code>, це завжди конкретний тип <a
            href="/pkg/os/#PathError"><code>*os.PathError</code></a>. </p>
        <p>Подібні до описаних тут ситуації можуть виникати кожного разу, коли
          використовуються інтерфейси. Просто тримайте на увазі, що якщо в
          інтерфейсі зберігається будь-яке конкретне значення, інтерфейс не може
          бути&nbsp;<code>nil</code>. За додатковою інформацією звертайтесь до <a
            href="/doc/articles/laws_of_reflection.html">Законів відображення</a>.
        </p>
        <h3 id="unions">Чому немає непомічених об’єднаннь, як в C?</h3>
        <p>Непомічені об’єднання порушують гарантії безпеки пам’яті в Go. </p>
        <h3 id="variant_types"> Чому Go не має варіантних типів?</h3>
        <p> Варіантні типи, також відомі як алгебраїчні типи, провадять шлях для
          того, щоб значення могло приймати набір один з набору інших типів, але
          тільки ціх типів. Загальним прикладом в системах програмування є
          завдання, що помилка, скажімо, може бути мережевою помилкою, помилкою
          безпеки або помилкою застосування, та дозволяє викликаючому звузити
          походження проблеми через перевірку типу помилки. Інший приклад є
          синтаксичне дерево, в якому кожний вузол може бути іншого типу:
          декларацією, твердженням, присвоєнням, і таке інше. </p>
        <p> Ми прийняли рішення додати варіантні типи до Go, але після дискусії
          зупинилися на тому, що не будемо їх використовувати, бо вони
          перетинаються в непевні шляхи з інтерфейсами. Що трапиться, якщо
          елементи варіатного типу самі будуть інтерфейсами? </p>
        <p>Також, дещо, з того, для чого використовуються варіантні типи, вже
          зроблено в самій мові. Приклад з помилками просто викласти через
          значення інтерфейсу, що утримує значення помилки та перемикач типу для
          відокремлення різних випадків. Приклад синтаксичного дерева також
          вірішується, хоча і не так елегантно. </p>
        <h2 id="values">Значення</h2>
        <h3 id="conversions">Чому Go не провадить неявні перетворення числових
          типів?</h3>
        <p> Зручність автоматичного перетворення між числовими типами в C
          перевантажено тими непорозуміннями, що викликає. Коли вираз є
          беззнаковим? Наскільки великим є значення? Чи воно перевантажене? Чи є
          результат переносним, що не залежить від машини, на якій він
          обчислений? Це також ускладнює компілятор; “звичайні аріфметичні
          перетворення” не просто реалізувати та є несумісними поміж
          архітектурами. Задля цілей мобільності ми вирішили, що речі будуть
          ясніші та прямолінійніші, ціною деяких явних перетворень в коді.
          Визначення констант в Go — значень довільної точності, вільних від
          ознак знаковості та анотацій розміру, значно покращує ситуацію. </p>
        <p> Споріднене питання: на відміну від C, <code>int</code> та <code>int64</code>
          є різними типами, навіть якщо&nbsp;<code>int</code> є 64-бітний тип.
          Тип <code>int</code> є загальним; якщо ви турбуєтесь скільки саме біт
          утримує ціле, Go заохочує вас явно це уточнювати. </p>
        <p> Пост блогу <a href="http://blog.golang.org/constants">Константи</a>,
          вивчає цю тему більш детально. </p>
        <h3 id="builtin_maps">Чому мапи вбудовані?</h3>
        <p>Відповідь та ж, що і для рядків: вони такі потужні та важливі
          структури даних, що впровадження однієї чудової реалізації з
          синтаксичною підтримкою зробить програмування більш приємним. Ми
          віримо, що реалізація мап в Go є досить сильною, щоб прислужитись у
          більшості випадків. Якщо спеціфічне застосування може отримати вигоди
          від власної реалізації, можливо написати таке, але воне не буде таким
          синтаксично зручним; це виглядає як логічна перешкода щоб не робити
          цього. </p>
        <h3 id="map_keys">Чому мапи не дозволяють сегменти як ключі?</h3>
        <p>Пошук в мапі потребує оператору рівності, що не реалізовано в
          сегментах. Вони не реалізують рівність, бо рівність не дуже добре
          визначена для таких типів; є багато підходів, включаючи поверхневу vs.
          глибоке порівняння, як бути з рекурсивними типами, і таке інше. Ми
          можемо переглянути це рішення — та реаліалізація для сегментів не буде
          руйнувати жодну існуючу програму — але без ясної ідеї, що має означати
          рівність для сегментів, буде простіше поки що відкласти це питання. </p>
        <p>В Go 1, на відміну від попередніх випусків, рівність визначена для
          структур та масивів, так що такі типи можуть бути використані як ключі
          мап. Сегменти, тим не менше, ще не мають визначення рівності. </p>
        <h3 id="references"> Чому мапи, сегменти та канали є вказівниками, коли
          масиси це значення?</h3>
        <p> Є багато віторичних причин з цього питання. З самого початку мапи та
          канали були синтаксичними вказівниками, та не було можливості
          визначити не-вказівниковий екземпляр. Також, ми боролися над тим, як
          мають працювати масиви. Нарешті ми дійшли висновку, що пряме
          розподілення вказівників та значень робить мову складнішою в ужитку.
          Зміна ціх типів, щоб вони робили як посилання на асоційовані,
          розділені структури даних, розв’язують ці питання. Ця зміна додає
          деякої прикрої складності до мови, але має широкий вплив на уживання:
          завдячуючи цім змінам Go став більш продуктивною, комфортною мовою. </p>
        <h2 id="Writing_Code">Написання коду</h2>
        <h3 id="How_are_libraries_documented">Як документовані бібліотеки?</h3>
        <p>Існує програма, <code>godoc</code>, написана на Go, що виділяє
          документацію пакунку з первинного коду. Вона може бути використана з
          командного рядка або через веб. Екземпляр робить на <a href="/pkg/">golang.org/pkg/</a>.
          Фактично, <code>godoc</code> реалізує цілий сайт <a href="/">golang.org/</a>.
        </p>
        <h3 id="Is_there_a_Go_programming_style_guide">Чи є керівництво з стилю
          програмування на Go?</h3>
        <p> Колись може з’явитись невеликий перелік правил в якості керівництва
          щодо іменування, розміщення та організації файлів. Документ&nbsp;<a href="effective_go.html">Ефективний
            Go</a> містить деякі підказки зі стилю. Більш безпосередньо,
          програма&nbsp;<code>gofmt</code> є гарно-друком, чиє призначення є
          примусове застосування привил розміщення; вона заміщує звичайну
          підбірку правли, що треба і чого не треба робити, що дозволяє різні
          інтерпретації. Весь код Go в репозитарії пройшов через&nbsp; <code>gofmt</code>.
        </p>
        <p> Документ, позначений як&nbsp;<a href="//golang.org/s/comments">Go:
            коментарі з огляду коду</a> є колекцією дуже коротких ессе, щодо
          деталей ідіоми Go, що часто пропускаються програмістами. Це зручне
          посилання для людей, що роблять огляди коду для проектів Go. </p>
        <h3 id="How_do_I_submit_patches_to_the_Go_libraries">Як я має надсилати
          патчі до бібліотек Go?</h3>
        <p>Первинні файи є в каталозі&nbsp;<code>src</code> репозитарію. Якщо ви
          бажаєте зробити значні зміни, будь-ласка обговоріть їх в списку
          розсилки, перед тім, як братися до справи. </p>
        <p>Дивіться документ <a href="contribute.html">Ваш внесок в проект</a>
          для отримання інформації з чого починати. </p>
        <h3 id="git_https">Чому "go get" використовує HTTPS, коли клонує
          репозитарій?</h3>
        <p> Компанії часто дозволяють вихідний трафік тільки на стандартний TCP
          портах 80 (HTTP) та 443 (HTTPS), блокуючи вихідний трафік на інших
          портах, включаючи TCP порт 9418 (git) та TCP порт 22 (SSH). Коли
          використовується HTTPS замість HTTP, <code>git</code> примушує
          перевірку сертифікатів по замовчанню, запобігаючи атакам типу
          людина-посередені, підглядання та&nbsp; втручання. Таким чином,
          команда <code>go get</code> використовує&nbsp; HTTPS для безпеки. </p>
        <p>Якщо ви використовуєте <code>git</code> та вважаєте за краще
          викладати зміни через SSH з використанням вашого існуючого ключа, є
          легкий шлях обійти це. Для GitHub, спробуйте одне з ціх рішень: </p>
        <ul>
          <li>Вручну клонуйте репозитарій в каталозі пакунку:
            <pre>$ cd $GOPATH/src/github.com/username
$ git clone git@github.com:username/package.git
</pre> </li>
          <li>Змусьте <code>git push</code> використовувати протокол <code>SSH</code>,
            додаючи ці два рядка до <code>~/.gitconfig</code>:
            <pre>[url "git@github.com:"]
	pushInsteadOf = https://github.com/
</pre> </li>
        </ul>
        <h3 id="get_version">Як я маю керувати версіями пакунків використовуючи
          "go get"?</h3>
        <p> "Go get" не має жодної явної концепції персій пакунків. Версії є
          джерелом значної складності, особливо в великих базах коду. Та нам
          невідомо щодо жодного підходу, що добре робить при маштабуванні для
          досить широкої різноманітності ситуацій, щоб примусити всіх
          користувачів Go користуватися їм. Що провадить "go get" та ширший
          набір інструментів Go, це ізоляція пакунків з різними шляхами імпорту.
          Наприклад, стандартні бібліотеки <code>html/template</code> та <code>text/template</code>
          співіснують, навіть якщо обидва є "шаблоном пакунку". Це спостереження
          призводить деяких порад для авторів та користувачів бібліотек. </p>
        <p>Пакунки, що призначені для публічного ужитку, мають спробувати
          підтримувати зворотню сумісність, по мірі розвитку.&nbsp;<a href="/doc/go1compat.html">Go
            1: керівництво з сумісності</a> є добрим посиланням: не видаляйте
          експортовані імена, заохочуйте помічені композитні літерали, і таке
          інше. Якщо потрібна різна функціональність, додайте нове ім’я, замість
          зміни існуючого. Якщо потрібно суцільне руйнування, створіть новий
          пакунок з новим шляхом імпорту.</p>
        <p>Якщо ви використовуєте пакунок з зовнішньою підтримкою, та
          хвилюєтесь, що вім може змінитися в неочікуваний спосіб, найпростше
          рішення є скопіювати його в ваш репозитарій. (Цей підхід Google
          використовує для себе). Збережіть копію під новим шляхом імпорту, що
          ідентифікує його як локальну копію. Наприклад, ви можете скопіювати
          "original.com/pkg" до "you.com/external/original.com/pkg". Утиліта від
          Keith Rarick <a href="https://github.com/kr/goven">goven</a> є одним
          з інструментів, що автиматизує цей процес. </p>
        <h2 id="Pointers">Вказівники та розміщення</h2>
        <h3 id="pass_by_value">Коли параметри функцій передаються як значення?</h3>
        <p>Як і в усіх мовах сімейства C, все в Go передається як значення. Саме
          так, функція завжди отримує копію того, що було передано, так, якби
          виконюється присвоєння значення параметру. Наприклад, передача
          значення <code>int</code> в функцію робить копію&nbsp;<code>int</code>,
          та передавання вказівника робить копію вказівника, але не даних, на
          які ін вказує. (Дивіться наступний розділ для обговорення того, як це
          впливає на отримувачі методів).</p>
        <p>Значення мап та секторів поводяться подібно до вказівників: вони є
          дескрипторами, що містять вказівники на підлеглі дані мапи або
          сектора. Копіювання значення мапи або сегменту не копіює дані, на які
          вони вказують. Копіювання значення інтерфейсу робить копію того, що
          міститься в значенні інтерфейсу. Якщо значення інтерфейсу містить
          структуру, копіювання інтерфейсу копіює значення структури інтерфейсу.
          Якщо значення інтерфейсу містить вказівник, копіювання інтерфейсу
          робить копію вказівника, але не даних, на які вказується.</p>
        <h3 id="pointer_to_interface">Коли я повинен використовувати вказівник
          на інтерфейс?</h3>
        <p>Майже ніколи. Вказівники на значення інтерфейсів виникають тільки
          рідких, хитрих ситуаціях, включаючи маскування типу значення
          інтерфейсу для відкладеного виконання. </p>
        <p>Однак є загальною помилкою передавати вказівник як значення
          інтерфейсу до функції, що очікує інтерфейс. Компілятор буде скаржитись
          через цю помилку, але ситуація може бути все ще незрозумілою, оскільки
          часом <a href="#different_method_sets">потрібен вказівник щоб
            задовільнити інтерфейс</a>. Задум полягає в тому, що хоча вказівник
          на конкретний тип може задовільняти інтерфейс, але є один
          виняток:&nbsp;<em>вказівник на інтерфейс ніколи не може задовільнити
            інтерфейс</em>. </p>
        <p> Розглянемо декларацію змінної, </p>
        <pre>var w io.Writer
</pre>
        <p>Функція друку <code>fmt.Fprintf</code> приймає перший аргумент, що
          задовільняє&nbsp;<code>io.Writer</code> — дещо, що реалізує канонічний
          метод <code>Write</code>. Таким чином ми можемо записати</p>
        <pre>fmt.Fprintf(w, "hello, world\n")
</pre>
        <p>Якщо ми передамо адресу <code>w</code>, програма не буде
          компілюватися. </p>
        <pre>fmt.Fprintf(&amp;w, "hello, world\n") // Помилка компіляції.
</pre>
        <p> Одне виключення полягає в тому, що любе значення, навіть вказівник
          на інтерфейс, може бути присвоєно змінній з типом порожнього
          інтерфейсу (<code>interface{}</code>). Навіть коли і так, це майже
          напевне помилка, якщо значенням є вказівник на інтерфейс; результат
          може бути неочікуваним. </p>
        <h3 id="methods_on_values_or_pointers"> Чи маю я визначати методи на
          значеннях чи на вказівниках?</h3>
        <pre>func (s *MyStruct) pointerMethod() { } // метод на вказівникові
func (s MyStruct)  valueMethod()   { } // метод на значенні
</pre>
        <p>Для програмістів, не дуже знайомих з вказівниками, різниця між двома
          прикладами може видатись незрозумілою, але ситуація, насправді, дуже
          проста. Коли визначається метод на типі, отримувач (як в наведених
          прикладах) поводиться точно так, якби це був аргументом методу. Коли
          визначати отримувач як значення, або як вказівник, є те ж питання,
          коли, треба визначати функцію для значення та коли для вказівника. Є
          декілька думок з цього приводу. </p>
        <p> Перше, та найбільш важливе, чи ма є метод змінювати отримувача? Якщо
          так, то отримувач <em>мусить</em> бути вказівником. (Сегменти та мапи
          діють як посилання, так що їх історія трохи тонкіша, та, наприклад,
          щоб змінити довжину сегмента в методі, отримувач мусить бути
          вказівником). В попередньому прикладі, якщо&nbsp;<code>pointerMethod</code>
          модифікує поля&nbsp;<code>s</code>, викликаючий буде бачити зміни, але
          <code>valueMethod</code> викликається тільки з копією аргументів
          викликача (це визначення передачі по значенню), так що зміни, що він
          робить, невидимі для викликаючого.</p>
        <p>До слова, отримувачі вказивників ідентичні до ситуації в Java, хоча в
          Java вказівники приховані під ковдрою; отримувачі значень є назвичною
          ознакою Go. </p>
        <p>Друге міркування є ефективність. Якщо отримувач великий, наприклад,
          великий <code>struct</code>, буде значно дешевше використовувати
          посилання на отримувач. </p>
        <p>Наступне це сумісність. Якщо деякі з методів типу мусять мати
          вказівники на отримувач, решта також мають це робити, так що набір
          методів є сумісним, незалежно від того, який тип використовується.
          Дивіться розділ про&nbsp;<a href="#different_method_sets">набори
            методів</a> для деталей. </p>
        <p>Для типів, таких, як базові типи, сегменти, та маленькі&nbsp;<code>structs</code>,
          отримувач-значення дуже дешевий, так що якщо семантика методу не
          вимагає вказівника, отримувач-значення є одночасно ефективним та
          ясним. </p>
        <h3 id="new_and_make">В чому різниця між new та make?</h3>
        <p>Коротко: <code>new</code> розміщує пам’ять, <code>make</code>
          ініціалізує типи сегменту, мапи або каналу. </p>
        <p> Дивіться <a href="/doc/effective_go.html#allocation_new">відповідні
            секці Ефективного Go</a> для додаткових деталей. </p>
        <h3 id="q_int_sizes">Якій розмір <code>int</code> на 64 бітній машині?</h3>
        <p> Розміри <code>int</code> та <code>uint</code> є залежними від
          реалізації, але є однаковими для обраної пратформи. Для мобільності,
          код, що покладається на окремий розмір значення, має використовувати
          типи з явним розміром як <code>int64</code>. До Go 1.1, 64-бітні
          компілятори Go (обоє, gc та gccgo) використовують 32-бітне
          представлення для <code>int</code>. В Go 1.1 вони використовують
          64-бітне представлення. З іншого боку, скаляри з плаваючою крапкою та
          комплексні числа завжди мають явну довжину: <code>float32</code>, <code>complex64</code>і
          так далі, оскількі програмісти будуть турбуватися про точність чисел с
          плаваючого крапкою. Розмір по замовчанню для констант з плаваючою
          крапкою є&nbsp;<code>float64</code>. </p>
        <h3 id="stack_or_heap">Як знати, чи є змінна розміщена в купі чи в
          стеку?</h3>
        <p>З точкі зору коректності, вам це не потрібно знати. Кожна змінна в Go
          існує настільки довго, доки є посилання на неї. Локація зберігання, що
          обирається реалізацією, є безвідносною до семантики мови.</p>
        <p> Локація зберігання впливає на написання ефективного коду. Коли
          можливо, компілятори Go будуть розміщувати змінні, що є локальними для
          фукнцій, в фрагменті стеку тієї функції. Однак, якщо компілятор не має
          впевненості, що змінна не використовується після повернення з функції,
          тоді компілятор мусить розмістити змінну в купі, що підлягає збору
          сміття, щоб запобігти помилок підвисання вказівників. Також, якщо
          локальна змінна дуже велика, може виявитись більше сенсу зберігати її
          в купі, скоріше ніж в стеку.</p>
        <p> В існуючих компіляторах, якщо змінна має операцію взяття адреси, ця
          змінна є кандидатом для розміщення в купі. Однак, базовий&nbsp;<em>аналіз
            виключення</em> розпізнає деяки випадки, коли такі змінні не живуть
          після повернення з функції і можуть залишатися в стеці. </p>
        <h3 id="Why_does_my_Go_process_use_so_much_virtual_memory"> Чому мій
          процесс Go використовує так багато віртуальної пам’яті?</h3>
        <p>Розміщувач пам’яті Go резервує великій регіон віртуальної пам’яті як
          арену для розміщення. Ця віртуальна пам’ять резервується спеціальним
          процесом Go; резервація не відбирає пам’ять в інших процесів. </p>
        <p>Щоб знайти розмір дійсної пам’яті, що розміщена для&nbsp;Go процесів,
          використовуйте Unix команду <code>top</code> та поцікавтесь
          стовпчиками <code>RES</code> (Linux) або <code>RSIZE</code> (Mac OS
          X).</p>
        <h2 id="Concurrency">Конкурентність</h2>
        <h3 id="What_operations_are_atomic_What_about_mutexes">Які операції є
          атомарними? Що з мьютексами?</h3>
        <p> Ми не повністю визначились з цім дотепер, але деякі деталі щодо
          атомарності доступні в специфікації <a href="/ref/mem">Go: модель
            пам’яті</a>. </p>
        <p>Відносно мьютексів, пакунок&nbsp;<a href="/pkg/sync">sync</a>
          реалізує їх, але ми маємо надію стиль програмування Go буде
          заохочувати людей до використання технологій вищого рівня. Зокрема,
          намагайтесь так структурувати ваші програми, щоб в кожний момент часу
          тільки одна goroutine обробляла одну частину часу.</p>
        <p> Не комунікуйте через розділення пам’яті. Замість цього, розділюйте
          пам’ять через комунікацію. </p>
        <p>Дивиться пояснення в коді <a href="/doc/codewalk/sharemem/">Розділюйте
            пам’ять через комунікацію</a> та пов’язану <a href="//blog.golang.org/2010/07/share-memory-by-communicating.html">статтю</a>
          для детальної дискусіїз цієї концепції. </p>
        <h3 id="Why_no_multi_CPU">Чому моя багато-goroutine програма не
          використовує багато CPU?</h3>
        <p> Ви можете встановити змінну командного оточення <code>GOMAXPROCS</code>,
          або використовувати подібно названу функцію&nbsp; <a href="/pkg/runtime/#GOMAXPROCS"><code>function</code></a>
          пакунку часу виконання, щоб дозволити підтримку використання більше
          ніж одного потоку операційної системи. </p>
        <p>Програми, що виконують паралельні обчислення повинні вигравати від
          збільшення <code>GOMAXPROCS</code>. Однак, майте на увазі, що&nbsp;<a
            href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">конкурентність
            не те, що й паралелізм</a>. </p>
        <h3 id="Why_GOMAXPROCS">Чому використання <code>GOMAXPROCS</code> &gt;
          1 часом робить мою прогаму повільнішою?</h3>
        <p>Це залежить від природи вашої програми. Проблеми, що по суті є
          послідовними, не можуть пришвидшитись за допомогою додавання більшого
          числа goroutines. Конкурентність тільки тоді стає паралелізмом, коли
          проблема сама є паралельною. </p>
        <p>В практичних термінах, програми, що проводять більше часу за
          комунікаціями через канали, ніж виконують обчислення, будуть зазнавати
          деградацію продуктивності, коли використовуватимуть більше потоків OS.
          Це тому, що пересилання даних між потоками включатиме перемикання
          контексту, що має значну ціну. Наприклад,&nbsp;<a href="/ref/spec#An_example_package">приклад
            решета простих</a> зі специфікації Go не має значного паралелізму,
          хоча він запускає багато goroutines; збільшення <code>GOMAXPROCS</code>
          найскоріше призупинить його, ніж прискорить. </p>
        <p>Планувальник Go goroutine не є таким добрим, яким мав би бути. В
          майбутньому він матиме розпізнавати такі випадки, та оптімізувати
          використання системних потоків. Наприклад, <code>GOMAXPROCS</code>
          має встановлюватись для кожного застосування окремо. </p>
        <p>Для додаткових деталей по цій темі дивіться розмову з назвою , <a href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">Конкурентність
            не є паралелізм</a>. </p>
        <h2 id="Functions_methods">Функції та методи</h2>
        <h3 id="different_method_sets">Чому T та *T мають інші набори методів?</h3>
        <p>Витяг зі специфікації <a href="/ref/spec#Types">Go Spec</a>: </p>
        <blockquote>Набір методів любого іншого іменованого типа&nbsp;<code>T</code>
          скаладється з усіх методів, з типом отримувача <code>T</code>. Набір
          методов для відповідного типу вказівника <code>*T</code> є набором
          всіх методів з отримувачем <code>*T</code> або <code>T</code> (саме
          так, він також включає набір методів <code>T</code>). </blockquote>
        <p>Якщо значення інтерфейсу містить вказівник <code>*T</code>, виклик
          методу може отримати значення через розв’язання вказівника, але якщо
          значення містить&nbsp;<code>T</code>, не має корисного шляху для
          виклика метода, щоб отримати вказівник.&nbsp;</p>
        <p> Навіть якщо компілятор може прийняти адресу значення до передачі в
          метод, і якщо метод модифікує значення, зміни будуть втрачені для
          викликаючого. Як загальний приклад розглянемо настуний код: </p>
        <pre>var buf bytes.Buffer
io.Copy(buf, os.Stdin)
</pre>
        <p> Він буде копіювати стандартний вхід в <i>копії</i> <code>buf</code>,
          не в самому <code>buf</code>. Це майже завжди не та поведінка, що
          треба. </p>
        <h3 id="closures_and_goroutines">Що відбувається з замиканнями, що
          виконуються як goroutines?</h3>
        <p> Деяке непорозуміння може виникнути, коли використовуються замикання
          разом з конкуренцією. Подивимось на наступний код: </p>
        <pre>func main() {
    done := make(chan bool)

    values := []string{"a", "b", "c"}
    for _, v := range values {
        go func() {
            fmt.Println(v)
            done &lt;- true
        }()
    }

    // очікування всіх goroutines, доки вони завершаться
    for _ = range values {
        &lt;-done
    }
}
</pre>
        <p> Дехто може помилково очікувати побачити <code>a, b, c </code>на
          виході. Замість ви побачите&nbsp;<code>c, c, c</code>. Це завдяки
          тому, що кожна ітерація циклу використовує той же екземпляр змінної <code>v</code>,
          так що кожне замикання розділяє ту ж єдину змінну. Коли викликається
          замикання, воно друкує значення <code>v</code> під час виконання <code>fmt.Println</code>,
          але <code>v</code> може бути модифікована з часу, коли goroutine була
          запущена. Щоб допомогти виявити це, та інші проблеми, перед тим як
          вони виникнуть, виконуйте&nbsp;<a href="/cmd/go/#hdr-Run_go_tool_vet_on_packages"><code>go
              vet</code></a>. </p>
        <p> Щоб прив’язати поточне значення <code>v</code> до кожного замикання
          під час запуску, треба модифікувати внутрішній цикл, щоб створити нову
          змінну на кожній ітерації. Один шлях передати змінну, це аргумент до
          замикання: </p>
        <pre>    for _, v := range values {
        go func(<b>u</b> string) {
            fmt.Println(<b>u</b>)
            done &lt;- true
        }(<b>v</b>)
    }
</pre>
        <p>І цьому прикладі значення <code>v</code> передається як аргумент до
          анонімної функції. Це значення потім доступне в функції як
          змінна&nbsp;<code>u</code>. </p>
        <p>Навіть простіше можна створити нову змінну, використовуючи стиль
          декларації, що може виглядати безглуздим, але добре робить в Go: </p>
        <pre>    for _, v := range values {
        <b>v := v</b> // створити новий 'v'
        go func() {
            fmt.Println(<b>v</b>)
            done &lt;- true
        }()
    }
</pre>
        <h2 id="Control_flow">Керування перебігом</h2>
        <h3 id="Does_Go_have_a_ternary_form">Чи має Go оператор&nbsp;<code>?:</code>
          ?</h3>
        <p> Немає тернарної форми в Go. Ви можете використовувати наступне, щоб
          досягти того ж результату: </p>
        <pre>if expr {
    n = trueVal
} else {
    n = falseVal
}
</pre>
        <h2 id="Packages_Testing">Пакунки та тестування</h2>
        <h3 id="How_do_I_create_a_multifile_package">Як меня створити
          багатофайловий пакунок?</h3>
        <p>Покладіть вся початкові файли для пакунку в каталог окремо. Початкові
          файли можуть за бажанням посилатися на елементи з декількох файлів;
          немає потреби в попередніх деклараціях або файлі заголовка.</p>
        <p>Окрім того, що вони можуть бути розділені в багатьох файлах, пакунки
          будуть компілюватись та тестуватись як пакунок в одному файлові.</p>
        <h3 id="How_do_I_write_a_unit_test">Як написати модульний тест?</h3>
        <p>Створіть новий файл що завершується на <code>_test.go</code> в тому
          ж каталозі, де і початкові файли вашого пакунку. В цьому файлі
          імпортуйте&nbsp;<code>import "testing"</code> та напишіть функції в
          формі </p>
        <pre>func TestFoo(t *testing.T) {
    ...
}
</pre>
        <p>Виконайте <code>go test</code> в цьому каталозі. Цей скрипт шукає
          функції <code>Test</code>, побудує двійниковий файл, та виконає його.
        </p>
        <p>Дивіться документ <a href="/doc/code.html">Як писати код Go</a>,
          пакунок <a href="/pkg/testing/"><code>testing</code></a> та
          підкоманду <a href="/cmd/go/#hdr-Test_packages"><code>go test</code></a>
          для більшої інформації.</p>
        <h3 id="testing_framework">Де моя улюблена функція для тестування?</h3>
        <p> Стандартний пакунок Go, <a href="/pkg/testing/"><code>testing</code></a>,
          робить простим писати модульні тести, але йому бракує можливостей, що
          їх провадять фреймворки тестування в інших мовах, таких, як функції
          допущень. В <a href="#assertions">попередньому розділі<span style="color: black;"></span></a>
          цього документу пояснюється, чому Go не має допущень, та ті ж самі
          аргументи стосуються і використання&nbsp;<code>assert</code> в тестах.
          Відповідна обробка помилок означає можливість іншим тестам
          продовжувати виконання, після того, як один з них схибить, так щоб
          той, хто налаштовує збої отримує повну картину, що іде невірно. Для
          тесту є більш корисним повідомляти, що&nbsp;<code>isPrime</code> дає
          помилкові відповіді для 2, 3, 5, та 7 (або для 2, 4, 8, та 16), ніж
          повідомити, що <code>isPrime</code> надає помилку відповідь для 2, і
          таким чином інші тести не будуть виконані. Програміст, що перемикає
          збій тесту, може не бути знайомий з кодом, що дає збій. Час, вкладений
          в написання доброго повідомлення про помилку,&nbsp; буде відплачено
          потім, коли тест дасть збій. </p>
        <p>Споріднена причина полягає в тому, що тестові фреймворки мають
          тенденцію розроблятись на власних міні-мовах, з умовами, примітивами
          керування та механізмами друку. Але Go вже має всі ці можливості; для
          чого винаходити їх знову? Ми краще будемо писати тести на Go; це
          вивчати на одну мову менше, та цей підхід підтримує тести
          прямолінійними та простими для розуміння. </p>
        <p> Якщо кількість додаткового коду, що треба для написання доброго
          обробки помилок, виглядає повторюваним та карколомним, тест може
          робити краще, базуючись на таблицях, ітеративно скануючи списки
          вхідних та вихідних структур даних (Go має чудову підтримку для
          літеральних структур даних). Після цього написання доброго тестового
          коду та добрих повідомлень про помилки може бути автоматизовано для
          багатьох випадків. Стандартна бібліотека Go повна іллюстративними
          прикладами, такими як в&nbsp; <a href="/src/fmt/fmt_test.go">форматування
            тестів для пакунку&nbsp;<code>fmt</code></a>. </p>
        <h2 id="Implementation">Реалізація</h2>
        <h3 id="What_compiler_technology_is_used_to_build_the_compilers">Що за
          компіляторна технологія використовувалась для побудови компіляторів?</h3>
        <p> <code>Gccgo</code> був фронт ендом, написаним на C++, зі звичайним
          рекурсивним парсером, у поєднанні зі стандартним GCC. <code>Gc</code>
          написаний на C з використанням <code>yacc</code>/<code>bison</code>
          для парсеру. Хоча це нова програма, вона відноситься до сюїти C
          компіляторів Plan 9 (<a href="http://plan9.bell-labs.com/sys/doc/compiler.html">http://plan9.bell-labs.com/sys/doc/compiler.html</a>)
          та використовує різновид завантажувача Plan 9 для генерації
          двійникових ELF/Mach-O/PE. </p>
        <p> Ми вирішили використовувати LLVM для <code>gc</code>, але ми
          відчуваємо, що це було дуже великим та повільним, щоб задовільнити
          нашим цілям щодо продуктивності. </p>
        <p>Ми також вирішили написати&nbsp; <code>gc</code>, оригінальний
          компілятор Go, на самому Go, але дійшли думки не робити це, завдяки
          складностям розкручування, та особливо дистрибуції з відкритим кодом —
          вам треба мати компілятор Go, щоб встановити оточення Go. <code>Gccgo</code>,
          що надійшов пізніше, робить можливим вирішити написати компілятор
          на&nbsp; Go. План зробити це за допомогою машинної трансляції, є під
          розробкою. <a href="http://golang.org/s/go13compiler">Окремий
            документ</a> пояснює причини для цього підходу.</p>
        <p> Окрім цього плану, Go є доброю мовою, де можна реалізувати
          само-змістовний компілятор: природні лексер та парсер доступні в
          пакунку&nbsp;<a href="/pkg/go/"><code>go</code></a>, та також був
          написаний окремий <a href="http://godoc.org/golang.org/x/tools/go/types">пакунок</a>
          для контролю типів. </p>
        <h3 id="How_is_the_run_time_support_implemented">Як реалізовано
          підтримка часу виконання?</h3>
        <p>Знову, з питань розкручування, код часу виконання був з початку
          написаний здебільшого на C (з невеликим вмістом асемблера), хоча з тих
          пір більшість його був перекладений на Go, і одного дня може бути
          перекладений він весь (за винятком фрагментів на асемблері). Підтримка
          часу виконання <code>Gccgo</code> використовує&nbsp;<code>glibc</code>.
          <code>Gc</code> використовує власну бібліотеку C, щоб утримувати
          контроль над ресурсами; він скомпільований з версією компілятора Plan
          9 C, що підтримує стеки змінного розміру для goroutines. Компілятор
          реалізує ці тільки під Linux, використовуючи техніку, що називається
          сегментованими стеками, що підтримується останніми модифікаціями до
          лінкера gold. </p>
        <h3 id="Why_is_my_trivial_program_such_a_large_binary">Чому моя
          тривіальна програма є таким великим файлом?</h3>
        <p> Лінкери в ланцюжку інструментів gc (<code>5l</code>, <code>6l</code>,
          and <code>8l</code>) виконують статичне зв’язування. Всі двійникові
          Go, таким чином, включають весь Go часу виконання, разом з інформацією
          типу, потрібною для підтримки перевірки динамічних типів,
          відображення, та навіть для обробки під час паніки. </p>
        <p> Проста програма на C "hello, world", компілюється та зв’язується
          статично, з використанням gcc на Linux, і займає близько 750Кб,
          включаючі реалізацію <code>printf</code>. Еквівалентна програма Go
          використовує <code>fmt.Printf</code> є близько 1.9Мб, але це включає
          більш потужну підтримку часу виконання та інформацію про типи. </p>
        <h3 id="unused_variables_and_imports"> Чи можу я перервати ці скарги про
          невикористану змінну або імпорт?</h3>
        <p> Наявність навикористаної змінної може вказувати на помилку, тоді як
          наявність невикористаного імпорту буде уповільнювати компіляцію,
          ефект, що може стату суттєвим, по мірі того, як з часом програма
          акумулює код та програмістів. З ціх причин Go відмовляється
          компілювати програми з невикористаними змінними та імпортами, міняючи
          короткотермінову зручність на довготривалу швидкість побудови та
          ясність програми. </p>
        <p>Не заважаючи на це, при розробці коду є загальним створювати ці
          ситуації тимчасово, та може викликати роздратування постійоно кожного
          разу, перед тим як скомпілювати програму.&nbsp;</p>
        <p>Деякі запитують про опцію компілятора, щоб відключити ці перевірки,
          або щонайменш зменшити їх до статусу попереджень. Такая опція не була
          додана, оскільки опції компіляції не мають впливати на семантику мови,
          та оскільки компілятор Go не звітує про попередження, тільки про
          помилки, що унеможливлюють компіляцію. </p>
        <p>Є дві причини щоб не мати попереджень. Перше, якщо щось варте
          скаржень, це має сенс виправити в коді. (Та якщо це не варте
          виправлення, це не варте і згадки). Друге, змушуючи компілятор
          генерувати попередження, заохочує реалізацію попереджати про слабкі
          випадки, що може призвести до галасливої компіляції, що замаскує
          реальні помилки, що&nbsp;<em>повинні</em> бути виправлені . </p>
        <p> Цю ситуацію, тим не менш, легко подолати. Використовуйте пустий
          ідентифікатор, шоб дозволити зберігання невикористаних речей, доки ви
          розробляєте. </p>
        <pre>import "unused"

// Ця декларація маркує імпорт як використаний, посилаючись на елемент за пакунку.
<br>var _ = unused.Item  // TODO: Видалити перед релізом!

func main() {
    debugData := debug.Profile()
    _ = debugData // Використовується тільки під час розробки.
    ....
}
</pre>
        <p> Тепер, більшість програм Go використовують інструмент, <a href="http://godoc.org/golang.org/x/tools/cmd/goimports">goimports</a>,
          що автоматично переписує код Go, щоб мати коректні імпорти, уникаючи
          на практиці проблеми невикористаних імпортів. Ця програма просто
          під’єднується до багатьох текстових редакторів, щоб виконуватись
          автоматично, коли записується файл з кодом G. </p>
        <h2 id="Performance">Продуктивність</h2>
        <h3 id="Why_does_Go_perform_badly_on_benchmark_x">Чому Go показує погану
          продуктивність у бенчмарку X?</h3>
        <p>Однією з цілей дизайну Go є спроба досягти продуктивності C для
          порівняних програм, але на декількох бенчмарках він все ще поводиться
          погано, включаючи декілька з <a href="/test/bench/shootout/">test/bench/shootout</a>.
          Найповільніший залежить від бібліотек, для яких ще не існує версій з
          порівняною продуктивністю для Go. Наприклад, <a href="/test/bench/shootout/pidigits.go">pidigits.go</a>
          залежить від пакунку математики зі змінною точністю, і C версії, на
          відміну від&nbsp; Go, використовують <a href="http://gmplib.org/">GMP</a>
          (що написаний на оптимізованому ассемблері). Бенчмарки, що залежать
          від регульрних виразів (наприклад, <a href="/test/bench/shootout/regex-dna.go">regex-dna.go</a>)
          є в основному порівнянням природного для Go пакунку <a href="/pkg/regexp">regexp</a>
          з досвідченими, високо оптимізованими бібліотеками регулярних виразів,
          таких, як PCRE. </p>
        <p> Бенчмарки-ігри виграють через існування через екстенсивне
          підлаштування, та версії більшості бенчмарків Go потребують уваги.
          Якщо ви вимірюєте порівнювані програми на C та Go (<a href="/test/bench/shootout/reverse-complement.go">reverse-complement.go</a>
          є одним з прикладів ), ви побачите, що ці дві мови значно ближчі в
          нетто-продуктивності, ніж може виявити ця сюїта. </p>
        <p>Тим не менш є місце для покращення. Компілятори гарні, але можуть
          бути краще, багато бібліотек потребуються загальної роботи над
          продуктивністю, та збирання сміття все ще не достатньо швидкий.
          (Навіть якщо він би і був, завжди пілкуйтесь і не генеруйте непотрібне
          сміття, і це матимо величезний ефект).</p>
        <p>В жодному випадку Go може бути дуже конкурентним. Було значне
          покращення в продуктивності багатьох програм, по мірі того, як
          розвивалась мова та інструменти. Дивіться блог пост щодо <a href="//blog.golang.org/2011/06/profiling-go-programs.html">профілювання
            Go програм</a> в пошуках інформативних прикладів. </p>
        <h2 id="change_from_c">Зміни відносно C</h2>
        <h3 id="different_syntax">Чому синтакс є відрізняється від C?</h3>
        <p>Окрім декларативного синтаксису, різниця не така й велика, та
          походить з двох бажань. Перше, синтаксис має відчуватися легким, без
          великої кількості обов’язкових ключових слів, повторень та таємниць.
          Друге, мова має бути розроблена простою для аналізу, та може бути
          розібрана без таблиці символів. Це робить значно простішим побудову
          інструментів, таких, як налагоджувачі, аналізатори залежностей,
          автоматичні екстрактори документації, додаткі до IDE, і таке інше. C
          та його послідовники є помітно складними в цьому сенсі. </p>
        <h3 id="declarations_backwards">Чому декларації ззаду наперед?</h3>
        <p>Вони ззаду наперед, тільки якщо ви до цього використовували C. В C
          запис такий, коли змінна декларується як вираз, що вказує на тип, що є
          милою ідеєю, але граматика типу та виразу не змішуються дуже добре, та
          результат може бути незрозумілим; розгляньте вказівники на функції. Go
          здебільшого розділяє синтаксис виразів та типів, і це спрощує речі
          (використання префіксу <code>*</code> для вказівників є виключенням,
          що тільки підтверджує правило). В декларації C</p>
        <pre>    int* a, b;
</pre>
        <p> декларується <code>a</code>, що це вказівник, але не&nbsp;<code>b</code>;
          in Go </p>
        <pre>    var a, b *int
</pre>
        <p>декларує, що обоє є вказівниками. Це ясніше та більше системно. Також
          форма скороченої декларації <code>:=</code>&nbsp; посилаєтсья на те,
          що повна декларація змінної має представляти той же порядок, що
          і&nbsp;<code>:=</code> , так що </p>
        <pre>    var a uint64 = 1
</pre>
        <p>має той же ефект, що і&nbsp;</p>
        <pre>    a := uint64(1)
</pre>
        <p>Розбір також спрощено, коли є окрема граматика для типів, що не є
          тільки граматикою виразів; ключаві слова, такі як&nbsp;<code>func</code>
          та&nbsp; <code>chan</code> пдітримують речі ясними. </p>
        <p>Дивіться статтю щодо&nbsp; <a href="/doc/articles/gos_declaration_syntax.html">Синтаксису
            декларацій в Go</a> для подальших деталей. </p>
        <h3 id="no_pointer_arithmetic">Чому немає арифметики вказівників?</h3>
        <p>Безпека. Без арифметики вказівників можливо створити мову, що ніколи
          не зможе отримати нелегальну адресу, що буде успішно-некоректною.
          Компілятор та апаратне забезпечення дішли такої точки в розвитку, що
          цикл з використанням індексів массивів може бути таким же ефективним,
          що і цикл з використанням арифметики вказівників. Також відсутність
          арифметики вказівників може спростити реалізацію збирача сміття. </p>
        <h3 id="inc_dec">Чому <code>++</code> та <code>-- </code>є
          твердження, а не вирази? Та чому постфіксні, а не префіксні?</h3>
        <p> Без аріфметики вказівників зручність мати пре- та пост-фіксні
          оператори зникає. Разом видаляючи їх з ієрархії виразів спрощує
          синтаксис та складні питання навколо порядку обчислень&nbsp;<code>++</code>
          та <code>--</code> (візміть наприклад <code>f(i++)</code> та <code>p[i]
            = q[++i]</code>) також зникають. Спрощення важливе. Як до
          постфіксного та префіксного, кожний буде робити добре, але постфіксна
          версія більше традиційна; наполегливість на префіксних постає з STL,
          бібліотеки для мови, чиє ім’я іронічно містить постфіксний інкремент.
        </p>
        <h3 id="semicolons"> Чому стільки дужок, але немає точок з комою? І чому
          я не можу розташувати відкриваючи дужки на наступному рядку?</h3>
        <p> Go використовує дужки для групування тверджень, синтаксис, знайомий
          для програмістів, хто робив з любою мовою з сімейства C. Точка з
          крапкою, одначе, для парсерів, не для людей, і ми бажали уникати її
          наскільки можливо. Щоб досягти цієї мети, Go запозичує трюк BCPL:
          точки з комою, що розділяють твердження, є формальною граматикою, але
          вводяться автоматично, без передбачання, самим лексером в кінці
          кожного рядка, що може бути кінцем твердження. Це робить дуже гарно на
          практиці, але накладає обмеження на стиль дужок. Наприклад,
          відкриваюча дужка функції не може з’являтися в рядку сама по
          собі.&nbsp; </p>
        <p>Деякі аргументують, що лексеру слід робити передбачання, щоб
          дозволити дужкам жити і на наступньому рядку. Ми не згодні. Оскільки
          код Go призначений щоб бути форматованим автоматично, через <a href="/cmd/gofmt/"><code>gofmt</code></a>,
          <i>деякий</i> стиль має бути обраним. Цей стиль може відрізнятися від
          того, що ви використовуєте в C або Java, але Go є новою мовою та
          стиль&nbsp;<code>gofmt</code> не кращий за будь який інший. Більш
          важливо — значно більше важливо — переваги єдиного, програмно
          нав’язаного стилю для всіх Go програм переважає можливі недоліки
          окремого стилю. Зауважте, також, що стиль Go означає, що інтерактивна
          реалізація Go може використовувати стандартний стиль в один рядок за
          раз без додаткових правил. </p>
        <h3 id="garbage_collection">Для чого виконувати збір сміття? Чи не є це
          дуже коштовним?</h3>
        <p>Один з найбільших джерел бухгалтерії в системних програмах є
          керування пам’ятью. Ми відчуваємо це критичним, виключити
          перевантаження програміста, та We feel it's critical to eliminate that
          programmer overhead, and advances in garbage collection technology in
          the last few years give us confidence that we can implement it with
          low enough overhead and no significant latency. </p>
        <p> Another point is that a large part of the difficulty of concurrent
          and multi-threaded programming is memory management; as objects get
          passed among threads it becomes cumbersome to guarantee they become
          freed safely. Automatic garbage collection makes concurrent code far
          easier to write. Of course, implementing garbage collection in a
          concurrent environment is itself a challenge, but meeting it once
          rather than in every program helps everyone. </p>
        <p> Finally, concurrency aside, garbage collection makes interfaces
          simpler because they don't need to specify how memory is managed
          across them. </p>
        <p> The current implementation is a parallel mark-and-sweep collector
          but a future version might take a different approach. </p>
        <p> On the topic of performance, keep in mind that Go gives the
          programmer considerable control over memory layout and allocation,
          much more than is typical in garbage-collected languages. A careful
          programmer can reduce the garbage collection overhead dramatically by
          using the language well; see the article about <a href="//blog.golang.org/2011/06/profiling-go-programs.html">profiling
Go
            programs</a> for a worked example, including a demonstration of Go's
          profiling tools. </p>
        <div id="footer"> Build version go1.4.2.<br>
          Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
          the content of this page is licensed under the Creative Commons
          Attribution 3.0 License, and code is licensed under a <a href="/LICENSE">BSD
            license</a>.<br>
          <a href="/doc/tos.html">Terms of Service</a> | <a href="http://www.google.com/intl/en/policies/privacy/">Privacy
            Policy</a> </div>
      </div>
      <!-- .container --> </div>
    <!-- #page -->
    <!-- TODO(adonovan): load these from <head> using "defer" attribute? -->
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
    <script type="text/javascript" src="/lib/godoc/jquery.treeview.js"></script>
    <script type="text/javascript" src="/lib/godoc/jquery.treeview.edit.js"></script>
    <script type="text/javascript" src="/lib/godoc/playground.js"></script>
    <script type="text/javascript" src="/lib/godoc/godocs.js"></script>
    <script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script> </body>
</html>
