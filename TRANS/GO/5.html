<!DOCTYPE html>
<!-- saved from url=(0038)http://www.golang-book.com/5/index.htm -->
<html lang="en">
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="content-type">
    <title>Вступ до Go | Структури керування Переклад українською - Арсеній
      Чеботарьов - Ніжин 2016</title>
  </head>
  <body>
    <address> Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2016</address>
    <div id="container">
      <div id="book">
        <h1>Структури керування</h1>
        <p>Тепер, коли ми знаємо, як використовувати змінні, настав час почати
          писати деякі корисні програми. Спершу давайте напишемо програму, що
          рахує до 10,
          починаючи з 1, друкуючи кожне число на окремому рядку. Використовуючи
          те, що ми вже знаємо, ми можемо записати таке:</p>
        <pre>package main

import "fmt"

func main() {
    fmt.Println(1)
    fmt.Println(2)
    fmt.Println(3)
    fmt.Println(4)
    fmt.Println(5)
    fmt.Println(6)
    fmt.Println(7)
    fmt.Println(8)
    fmt.Println(9)
    fmt.Println(10)
}</pre>
        <p>Або таке:</p>
        <pre>package main
import "fmt"

func main() {
    fmt.Println(`1
2
3
4
5
6
7
8
9
10`)
}</pre>
        <p>Але обі ці програми виснажливо писати. Що нам треба, це спосіб робити
          дещо декілька разів.</p>
        <h2 id="section1">For</h2>
        <p>Твердження <code>for</code> дозволяє нам повторювати список
          тверджень (блок) декілька разів. Перезапис нашої попередньої програми
          з використанням твердження <code>for</code> виглядає так:</p>
        <pre>package main

import "fmt"

func main() {
    i := 1
    for i &lt;= 10 {
        fmt.Println(i)
        i = i + 1
    }
}</pre>
        <p>Спршу ми створили змінну <code>i</code> , що ми використовуємо для
          зберігання числа, що ми бажаємо друкувати. Потім ми створюємо цикл <code>for</code>
          використовуючи ключове слово <code>for</code>, провадяи умовний
          вираз, що або <code>true</code> або <code>false</code>, та нарешті
          надаючи блок, що треба виконати. Цикл for робить таким чином:</p>
        <ul>
          <li>
            <p>Ми обчислюємо (виконуємо) вираз <code>i &lt;= 10</code> (“i
              меньше або дорівнює&nbsp; 10”). Якщо це обчислюється до true, тоді
              виконуємо твердження в блоці. Інакше ми перестрибуємо до наступного
              рядка після блоку. (в уьому випадку немає нічого після циклу, так
              що просто завершуємо програму)</p>
          </li>
          <li>
            <p>Післі виконання тверджень в блоці циклу ми повертаємось назад, до
              початку твердження, на крок 1.</p>
          </li>
        </ul>
        <p>Рядок <code>i = i + 1</code> вкрай важливий, оскільки без нього <code>i
            &lt;= 10</code> буде завжди обчислюватись до <code>true</code> і
          наша програма ніколи не завершиться. (Коли це трапитляється кажуть про
          безкінечний цикл)</p>
        <p>В якості приклада давайте пройдемо по програмі, як це робить комп'ютер:</p>
        <ul>
          <li>
            <p>Створимо змінні на ім'я&nbsp; <code>i</code> зі значенням 1</p>
          </li>
          <li>
            <p>Яи <code>i &lt;= 10</code>? Так.</p>
          </li>
          <li>
            <p>Друкуємо <code>i</code></p>
          </li>
          <li>
            <p>Встановлюємо <code>i</code> в <code>i + 1</code> (<code>i</code>
              тепер 2)</p>
          </li>
          <li>
            <p>Чи <code>i &lt;= 10</code>? Так.</p>
          </li>
          <li>
            <p>Друкуємо <code>i</code></p>
          </li>
          <li>
            <p>Встановлюємо <code>i</code> в <code>i + 1</code> (<code>i</code>
              тепер 3)</p>
          </li>
          <li>
            <p>…</p>
          </li>
          <li>
            <p>Встановлюємо <code>i</code> в <code>i + 1</code> (<code>i</code>
              тепер 11)</p>
          </li>
          <li>
            <p>Чи <code>i &lt;= 10</code>? Ні.</p>
          </li>
          <li>
            <p>Нічого не залишилось, виходимо</p>
          </li>
        </ul>
        <p>Інші мови програмування мають багато інших типів циклів (while, do,
          until, foreach, …), але Go має тільки один, що може використовуватись
          у різний спосіб. Попередня програма може також бути записана таким
          чином:</p>
        <pre>func main() {
    for i := 1; i &lt;= 10; i++ {
        fmt.Println(i)
    }
}</pre>
        <p>Тепер умовний вираз також містить два інші твердження, розділені
          крапкою з комою. Першою ми маємо ініціаліацію змінної, потім ми маємо
          умову, що ми перевіряємо кожного разу, та нарешті ми “інкрементуємо”
          змінну (Додавання 1 до змінної, є настільки загальним, що для цього
          існує окремий оператор: <code>++</code>. Подібним чином віднімання 1
          може бути зроблене за допомогою <code>--</code>).</p>
        <p>Ми побачимо додаткові метод використання циклів for в наступних
          главах.</p>
        <h2 id="section2">If</h2>
        <p>Давайте модифікуємо програму, що ми тільки що написали, так щоб
          замість просто друкувати числа 1-10 на кожному рядку, вона також
          вказувала, чи число є парним, чи ні. Наприклад, так:</p>
        <pre>1 odd
2 even
3 odd
4 even
5 odd
6 even
7 odd
8 even
9 odd
10 even</pre>
        <p>Спершу, нам треба шлях визначити. чи число парне. Простоий шлях
          сказати це є поділити число на 2. Якщо вам нічого не залишилось від
          ділення, число парне. Інакше ні. Як визначити залишок від ділення в
          Go? Ми використовуємо оператор <code>%</code>. <code>1 % 2</code>
          дорівнює <code>1</code>, <code>2 % 2</code>дорівнює&nbsp; <code>0</code>,
          <code>3 % 2</code> дорівнює <code>1</code> і так далі.</p>
        <p>Далі, нам треба спосіб обрати, як виконувати різні ресі на основі
          умови. Для цього ми використовуємо твердження&nbsp;<code>if</code>:</p>
        <pre>if i % 2 == 0 {
  // even
} else {
  // odd
}</pre>
        <p>Твердження <code>if</code> подібне до твердження <code>for</code> в
          тому, що воно має умову, за якою слідує блок. Твердження if також має
          опціональну частину <code>else</code>. Якщо умова обчислиться до <code>true</code>,
          тоді виконується блок післу умови, інакше блок пропускається, та якщо
          присутній блок <code>else</code> , він буде виконаний.&nbsp;</p>
        <p>Твердження if також може мати частину <code>else if</code>:</p>
        <pre>if i % 2 == 0 {
    // divisible by 2
} else if i % 3 == 0 {
    // divisible by 3
} else if i % 4 == 0 {
    // divisible by 4
}</pre>
        <p>Умови перевіряються зверху донизу, та перше, що дасть результат true,
          призведе до виконання асоційованого блока. Інші блоки не будуть
          виконані, навіть якщо їх умова буде давати true. (Таким чином,
          наприклад, число 8 ділиться на обоє, 4 та 2, але блок&nbsp; <code>//
            divisible by 4</code> ніколи не виконається, бо блок <code>//
            divisible by 2</code> буде виконаний першим). </p>
        <p>Складаючи все до купи ми маємо:</p>
        <pre>func main() {
    for i := 1; i &lt;= 10; i++ {
       if i % 2 == 0 {
            fmt.Println(i, "even")
        } else {
            fmt.Println(i, "odd")
        }
    }
}</pre>
        <p>Давайте пройдемось по програмі:</p>
        <ul>
          <li>
            <p>Створити змінну&nbsp;<code>i</code> типу <code>int</code> надати
              їй значення <code>1</code></p>
          </li>
          <li>
            <p>Чи <code>i</code> маньше або дорівнює <code>10</code>? Так
              застрибуємо в блок: </p>
          </li>
          <li>
            <p>Чи залишок <code>i</code> ÷ <code>2</code> дорівнює <code>0</code>?
              Ні: перехоидмо до блоку <code>else</code></p>
          </li>
          <li>
            <p>Друкуємо <code>i</code>, та після нього <code>odd</code></p>
          </li>
          <li>
            <p>Інкрементуємо <code>i</code> (твердження ісля умови)</p>
          </li>
          <li>
            <p>Чи&nbsp;<code>i</code> меньше або дорівнює <code>10</code>? Так,
              заходимо в блок</p>
          </li>
          <li>
            <p>Чи залишок <code>i</code> ÷ <code>2</code> доірвнює <code>0</code>?
              Так, заходимо в блок <code>if</code></p>
          </li>
          <li>
            <p>Друкуємо <code>i</code>, та після нього <code>even</code></p>
          </li>
          <li>
            <p>…</p>
          </li>
        </ul>
        <p>Оператор залишку, хоча рідко зустрічається після початкової школи,
          виявляється дійсно корисним в програмуванні. Ви побачите як він
          перемикає будь-що, від зебри до розділення наборів даних.</p>
        <h2 id="section3">Switch</h2>
        <p>Уявіть, що ви бажаєте написати програму, що друкує англійські назви
          чисел.Використовуючи те, що вже знаємо, ми можемо почати робити таке:</p>
        <pre>if i == 0 { 
    fmt.Println("Zero") 
} else if i == 1 {
    fmt.Println("One")
} else if i == 2 {
    fmt.Println("Two")
} else if i == 3 {
    fmt.Println("Three")
} else if i == 4 { 
    fmt.Println("Four")
} else if i == 5 {
    fmt.Println("Five")
}</pre>
        <p>Оскільки написання програми таким чином може бути досить виснажливим,
          Go
          провадить іншетвердження, що робить речі простішими: твердження <code>switch</code>.
          Ми можемо переписати нашу програму, щоб вона виглядала так:</p>
        <pre>switch i {
case 0: fmt.Println("Zero")
case 1: fmt.Println("One")
case 2: fmt.Println("Two")
case 3: fmt.Println("Three")
case 4: fmt.Println("Four")
case 5: fmt.Println("Five")
default: fmt.Println("Unknown Number")
}</pre>
        <p>Твердження switch починається з ключового слова&nbsp;<code>switch</code>,
          за яким слідує вираз (в цьому випадку <code>i</code>), та потім серія
          <code>case</code>. Значенн виразу порівнюється з виразами, що слідують
          за кожним <code>case</code>. Якщо вони еквівалентні, тоді виконується
          твердження за <code>:</code> . </p>
        <p>Як і твердження if, кожний case перевіряється згори донизу, та перший
          вдалий буде обраний. Команда switch також підтримує default, що
          отримає керування, якщо ніякий інший не співпаде (подібно до else
          в if)</p>
        <p>Це головні твердження контролю виконання. Додаткові будуть вивчені в
          подальших главах.</p>
        <h3>Проблеми</h3>
        <ul>
          <li>
            <p>Що друкує наступна програма:</p>
            <pre>i := 10
if i &gt; 10 {
    fmt.Println("Big")
} else {
    fmt.Println("Small")
}</pre>
          </li>
          <li>
            <p>Напишіть програму, що друкує всі числа, що нарівно діляться на 3
              між 1 та 100. (3, 6, 9, etc.)</p>
          </li>
          <li>
            <p>Напишіть програму, що друкує числа від 1 до 100. Але для
              дільників на три друкувала би "Fizz" замість числа, та для
              дільників п'яти друкувала би "Buzz". Для чисел, що діляться на три
              і на п'ять одночасно друк має становити "FizzBuzz".</p>
          </li>
        </ul>
      </div>
    </div>
  </body>
</html>
