<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Ефективний Go</title>
    <link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">
    <link rel="search" type="application/opensearchdescription+xml" title="godoc"
      href="/opensearch.xml">
    <link rel="stylesheet" href="/lib/godoc/jquery.treeview.css">
</head>
  <body>
    <div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
      ... </div>
    <div id="playground" class="play">
      <div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;"><sub>
          ... </sub></div>
      <sub> Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
          Чеботарьов</a> - Ніжин 2015 </sub>
      <h1>Ефективний Go</h1>
    </div>
    <div id="page" class="wide">
      <div class="container">
        <h2 id="introduction">Вступ</h2>
        <p> Go є новою мовою. Та хоча він позичає ідеї з існуючих мов, він має
          незвичайні властивості, що роблять ефективні Go програми іншими від
          програм, написаних на його родичах. Прямий переклад програми на C++
          або Java на Go навряд чи призведе до задовільного результату —
          програми Java написані на Java, не на Go. З іншого боку, розмірковуючи
          над проблемою з перспективи Go може спричинити успішну, але зовсім
          іншу програму. Іншими словами, щоб добре писати на Go важливо розуміти
          його властивості та ідіоми. Також важливо знати встановлені
          домовленості для програмування в Go, такі як іменування, форматування,
          конструкція програм, і таке інше, таким чином, щоб написані вами
          програми було добре зрозумілими для інших програмувальників на Go. </p>
        <p>Цей документ надає підказки для написання ясного, ідеоматичного коду
          Go. Він підводить рису під <a href="/ref/spec">специфікацією мови</a>,
          <a href="//tour.golang.org/">Тур по Go</a> та <a href="/doc/code.html">Як
            писати код на Go</a>, які треба прочитати заздалегідь. </p>
        <h3 id="examples">Приклади</h3>
        <p><a href="/src/">Початковий код пакунків Go</a> призначений не тільки
          як головна бібліотека, але також і як приклади з використання мови.
          Більше того, багато пакунків містять працюючі, самодостатні приклади
          застосувань, які ви можете виконувати напряму з сайту&nbsp;<a href="//golang.org">golang.org</a>,
          такі як&nbsp;<a href="//golang.org/pkg/strings/#example_Map">ось цей</a>
          (за необхідності клацніть на слові "Example" щоб відкрити його). Якщо
          ви маєте питання щодо підходів до проблеми, або як щось може бути
          реалізовано, документація, код та приклади в бібліотеці можуть надати
          відповіді, ідеї та підгрунтя. </p>
        <h2 id="formatting">Форматування</h2>
        <p>Питання форматування найбільш прискіпливі, але найменш логічного
          обгрунтовані. Люди можуть призвичаїтись до різних стилів форматування,
          але краще щоб вони цього не робили, і менше часу присвячували цім
          питанням, якщо всі дотримуватимуться єдиного стилю. Проблема в тому,
          як досягти цієї утопії без довгого описового підручника по стилю.</p>
        <p>З Go ми прийняли незвичайний підхід та доручили машині потурбуватися
          про більшість питань форматування. Програма <code>gofmt</code> (також
          доступна як <code>go fmt</code>, що оперує на рівні пакунків скоріше,
          ніж на рівні окремого початкового файлу) читає програму на Go та видає
          текст в стандартному стилі відступів та вертикальних вирівнювань,
          зберігаючи, та за потреби переформатуючі, коментарі. Якщо ви бажаєте
          знати як поводитись в новій ситуації розміщення, виконайте&nbsp;<code>gofmt</code>;
          якщо відповідь не виглядає природною, переробіть свою програму (або
          надішліть помилку щодо роботи <code>gofmt</code>), не намагайтесь
          просто обійти ситуацію. </p>
        <p>В якості прикладу, немає потреби гаяти час і вирівнювати коментарі
          для полей структури.&nbsp;<code>Gofmt</code> зробить це за вас. Беручи
          визначення&nbsp; </p>
        <pre>type T struct {
    name string // ім’я об’єкту
    value int // його значення
}
</pre>
        <p> <code>gofmt</code> підрівняє стовпчики: </p>
        <pre>type T struct {
    name    string // ім’я об’єкту
    value   int    // його значення
}
</pre>
        <p> Весь код Go в стандартних пакунках був сформатований за допомогою <code>gofmt</code>.
        </p>
        <p>Деякі деталі форматування зберігаються. Дуже стисло: </p>
        <dl>
          <dt>Відступи</dt>
          <dd>Ми використовуємо табуляцію для відступів і&nbsp;<code>gofmt</code>
            видає їх по замовчанню. Використовуйте проміжки тільки в разі
            потреби. </dd>
          <dt>Довжина рядків</dt>
          <dd> Go не має обмеження на довжину рядка. Не турбуйтесь про
            переповнення перфомапи. Якщо рядок виглядає дуже довгим, перенесіть
            його та зробіть відступ за допомогою додаткової табуляції.</dd>
          <dt>Дужки</dt>
          <dd> Go потребує меньшої кількості дужок, ніж C та Java: структури
            управління (<code>if</code>, <code>for</code>, <code>switch</code>)
            не мають дужок в своєму синтаксисі. Також ієрархія передування
            операторів є коротшою та яснішою, так що
            <pre>x&lt;&lt;8 + y&lt;&lt;16
</pre> означає на що вказують проміжки, на відміну від інших мов. </dd>
        </dl>
        <h2 id="commentary">Коментарі</h2>
        <p> Go надає блочні коментарі в стилі C <code>/* */</code> та коментарі
          в рядку в стилі C++<code>//</code>. Коментарі в рядку є нормою; блочні
          коментарі з’являються в основному як коментарі пакунку, але є
          корисними в виразах або для відключення великих клаптиків коду. </p>
        <p>Програма — та веб сервер — <code>godoc</code> обробляє первинні
          файли Go для виділення документації щодо вмісту пакунку. Коментарі, що
          з’являються перед визначеннями вищого рівня, разом з переводами рядка,
          виділяються разом з деклараціями щоб служити пояснювальним текстом для
          елементу. Природа та стиль ціх коментарів визначають якість
          документації, що продукує&nbsp;<code>godoc</code>. </p>
        <p>Кожний пакунок повинен мати&nbsp;<i>коментар пакунку</i>, блочний
          коментар, що передує фразі package. Для багатофайлових пакунків
          коментар пакунку має бути тільки в одному файлі, і тільки один.
          Коментар пакунку має надавати огляд пакунку і надавати інформацію
          стосовно пакунку як цілого. Він буде з’являтися першим на
          сторінці&nbsp;<code>godoc</code> та буде встановлювати детальну
          документацію, що послідує за ним. </p>
        <pre>/*
Пакунок regexp реалізує просту бібліотеку для регулярних виразів.

Синтаксис регулярних виразів наступний:

    regexp:
        concatenation { '|' concatenation }
    concatenation:
        { closure }
    closure:
        term [ '*' | '+' | '?' ]
    term:
        '^'
        '$'
        '.'
        character
        '[' [ '^' ] character-ranges ']'
        '(' regexp ')'
*/
package regexp
</pre>
        <p>Якщо пакунок простий, коментар пакунку може бути стислим. </p>
        <pre>// Пакунок path реалізує допоміжні процедури для маніпуляцій зі шляхами.
</pre>
        <p>Коментар не потребує додаткового форматування, такого як банери або
          зірочки. Сгенерований вихід може навіть не бути представленим шрифтом
          сталої ширини, так що не розраховуйте на проміжки та
          вирівнювання&nbsp;— <code>godoc</code>, подібно <code>gofmt</code>,
          попілкується про це. Коментарі є неінтерпретованим простим текстом,
          так що HTML та інші анотації, такі як&nbsp;<code>_this_</code> будуть
          представлені <i>дослівно</i> та не повинні використовуватися. Одне
          підлаштування, що робить&nbsp;<code>godoc</code> - це відображення
          вирівняного тексту шрифтом сталої ширини. Коментар пакунку для&nbsp;<a
            href="/pkg/fmt/"><code>пакунку fmt</code></a> використовує це для
          доброго ефекту. </p>
        <p>В залежності від контексту, <code>godoc</code> може навіть не
          переформатувати коментарі, так що впевніться, що вони і так гарно
          виглядають: використовуйте коректні написання, пунктуацію та склад
          речень, згортайте довгі рядки, тощо. </p>
        <p>В середині пакунку любий коментар, що безпосередньо передує
          визначенню верхнього рівня виступає як&nbsp;<i>документ-коментар</i>
          для цього визначення. Кожне експортоване (з великої літери) ім’я
          повинно мати такий коментар.&nbsp; </p>
        <p>Документ-коментарі краще працюють як повні речення, що дозволяє
          широке різноманіття автоматизованих презентацій. Перше речення повинно
          бути підсумовуючим одним реченням, що починається з імені, що
          визначається.&nbsp; </p>
        <pre>// Compile розбирає регулярний вираз та повертає, в разі успіху об’єкт Regexp
// що може бути використаний для порівнять з деяким текстом.
func Compile(str string) (regexp *Regexp, err error) {
</pre>
        <p>Якщо ім’я вже стоїть на початку коментаря, вихід з&nbsp;<code>godoc</code>
          може бути корисно спрямовано в&nbsp;<code>grep</code>. Уявіть, що ви
          не пам’ятаєте ім’я "Compile", але шукаєте функцію розбору для
          регулярних виразів, і таким чином можете викликати команду, </p>
        <pre>$ godoc regexp | grep parse
</pre>
        <p> Якщо всі документ-коментарі починаються з "Ця функція...", <code>grep</code>
          не допоможе згадати ім’я. але якщо пакунок починається з імені, ви
          побачите щось на зразок наступного, що нагадуватиме про слово, яке ви
          шукаєте. </p>
        <pre>$ godoc regexp | grep розбир
    Compile розбирає регулярний вираз та повертає, я разі успіху, розібраний Regexp.
$
</pre>
        <p>Синтаксис визначень Go дозволяє групування декларацій. Єдиний
          документ-коментар може описувати групу пов’язаних констант або
          змінних. Оскільки представлене ціле визначення, часто такий коментар
          може бути загальним. </p>
        <pre>// Error коди, що повертаються збоями при розборі виразу.
var (
    ErrInternal      = errors.New("regexp: internal error")
    ErrUnmatchedLpar = errors.New("regexp: unmatched '('")
    ErrUnmatchedRpar = errors.New("regexp: unmatched ')'")
    ...
)
</pre>
        <p>Групування також може вказувати на зв’язок між елементами, такий, як
          факт, що група змінних захищена мьютексом. </p>
        <pre>var (
    countLock   sync.Mutex
    inputCount  uint32
    outputCount uint32
    errorCount  uint32
)
</pre>
        <h2 id="names">Імена</h2>
        <p>Імена такі ж важливі в Go, як і усіх інших мовах. Вони навіть мають
          семантичний ефект: видимість імені за межами пакунку визначається тим,
          чи є перша літера великою. Таким чином є сенс витратити деякий час за
          розмовою про домовленості щодо імен в програмах Go. </p>
        <h3 id="package-names">Імена пакунків</h3>
        <p>Коли імпортується пакунок, ім’я пакунку стає точкою доступу до
          вмісту. Після&nbsp; </p>
        <pre>import "bytes"
</pre>
        <p>імпортуючий пакунок може звертатись до&nbsp; <code>bytes.Buffer</code>.
          Корисно, якщо будь-хто, використовуючи пакунок може використовувати це
          ж ім’я для посилань до його вмісту, з чого випливає, що ім’я пакунку
          має бути гарним: коротким, лаконічним, змістовним. По замовчанню імена
          пакунків складають з малих літер, одним словом; таким чином немає
          потреби в підкресленнях або змішанихРегістрах. Приставайте на сторону
          краткості, оскільки кожний, хто використовуватиме ваш пакунок, буде
          друкувати це ім’я. Та не турбуйтесь про колізії апріорі. Ім’я пакунку
          лише ім’я по замовчанню для імпорта; воно не має бути унікальним серед
          всього початкового коду, і в рідких випадках колізій імпортуючий
          пакунок може обрати інше ім’я для локального використання. В жодному
          разі непорозуміння є рідкими, бо ім’я файлу в імпорті визначає тільки
          те, який пакунок буде використано.&nbsp; </p>
        <p> Інша домовленість полягає в тому, що ім’я пакунку є базовим іменем
          його каталогу з початковим кодом; пакунок в&nbsp;<code>src/encoding/base64</code>
          імпортується як&nbsp;<code>"encoding/base64"</code>, але має ім’я <code>base64</code>,
          ні <code>encoding_base64</code> і ні <code>encodingBase64</code>. </p>
        <p>Імпортер пакунку буде використовувати ім’я для посилання на його
          вміст, так що експортовані імена в пакунку можуть використовувати цей
          факт для запобігання затинанню. (Не використовуйте запис <code>import
            .</code> , що може спростити тести, що мають робити за лаштунками
          пакунку, який вони тестують, але який треба уникати в іншому разі).
          Наприклад, тип буферизованого читача в пакунку <code>bufio</code>
          називається <code>Reader</code>, не <code>BufReader</code>, оскількі
          користувачі бачать його як <code>bufio.Reader</code>, що є ясним і
          лаконічним іменем. Більше того, оскількі імпортовані імена завжди
          адресуються за допомогою імені пакунка,&nbsp;<code>bufio.Reader</code>
          не конфліктує з&nbsp;<code>io.Reader</code>. Подібно до цього, функція
          для створення нового екземпляру <code>ring.Ring</code> — що є
          визначенням <em>конструктора</em> в Go — мав би зазвичай
          називатись&nbsp;<code>NewRing</code>, але оскільки <code>Ring</code>
          є єдиним типом, експортованим пакунком, та завдяки тому, що пакуок
          називається&nbsp;<code>ring</code>, він названий просто <code>New</code>,
          що з боку клієнтів пакунку виглядає як&nbsp;<code>ring.New</code>.
          Використовуйте структуру пакунку щоб допомогти собі визначити гарні
          імена. </p>
        <p>Інший гарний приклад <code>once.Do</code>; <code>once.Do(setup)</code>
          читається добре і не має бути імпортовано як&nbsp;<code>once.DoOrWaitUntilDone(setup)</code>.
          Довгі імена не роблять автоматично речі зрозумілішими. Корисний
          документ-коментар часто може виявитись більш вагомим, ніж додаткова
          довжина імені.</p>
        <h3 id="Getters">Геттери</h3>
        <p> Go не надає автоматичної підтримки для геттерів та сеттерів. Немає
          нічого хибного запровадити геттери та сеттери самому, і це часто так і
          потрібно зробити, але це не є ідеоматичним і не є потрібним
          включати&nbsp;<code>Get</code> в ім’я геттера. Якщо ви маєте поле на
          ім’я&nbsp;<code>owner</code> (нижній реєстр, не експортується), метод
          геттера слід назвати <code>Owner</code> (великий реєстр,
          експортується), не <code>GetOwner</code>. Використання великих літер
          в іменах є зручною можливістю відрізнити поле від метода. Метод
          сеттера, якщо вона потрібна, буде, називатись <code>SetOwner</code>.
          Обоє імен гарно читаються на практиці: </p>
        <pre>owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
</pre>
        <h3 id="interface-names">Імена інтерфейсів</h3>
        <p>За домовленістю інтерфейси з одного методу іменуються за іменем
          методу, плюс суфікс -er або схоже модифікувавши, щоб утворити
          прислівник: <code>Reader</code>, <code>Writer</code>, <code>Formatter</code>,
          <code>CloseNotifier</code> і так далі. </p>
        <p> Є деяке число імен та їх похідних, щоб вшанувати їх та імена
          функцій, що вони містять:&nbsp; <code>Read</code>, <code>Write</code>,
          <code>Close</code>, <code>Flush</code>, <code>String</code> і так
          далі, що мають канонічні сігнатури та значення. Щоб уникнути
          непорозумінь не надавайте своїм методам ціх імен, за винятком коли
          мають ту ж сигнатуру та значення. І навпаки, якщо ваш тип реалізує
          метод з тим значенням, що й метод добре відомого типу, надайте йому те
          ж ім’я та сигнатуру; назвіть метод перетворення в рядок&nbsp;<code>String</code>,
          не <code>ToString</code>. </p>
        <h3 id="mixed-caps">ЗмішаніЛітери</h3>
        <p>Наостаток, по домовленості, в Go використовуємо <code>MixedCaps</code>
          або <code>mixedCaps</code> скоріше, ніж підкреслення, для запису
          багатословних імен. </p>
        <h2 id="semicolons">Крапка з комою</h2>
        <p>Подібно до C, формальна граматика Go використовує крапку з комою для
          завершення тверджень, але на відміну від C, ці крапки з комою не
          з’являються в первинних кодах. Замість цього лексичний аналізатор
          використовує просте правило для автоматичної вставки крапок з комою по
          мірі сканування, і таким чином входний текст майже вільний від них. </p>
        <p>Правило наступне: якщо останній токен перед новим рядком є
          ідентифікатором (що включає такі слова, як&nbsp;<code>int</code> та <code>float64</code>),
базовий
          літерал, такий як число або константа типу рядок, або один з токенів</p>
        <pre>break continue fallthrough return ++ -- ) }
</pre>
        <p>лексичний анализатор завжди вставляє крапку з комою після токену. Це
          може бути підсумовано як "якщо новий рядок іде за токеном, що може
          бути завершенням твердження, вставляй крапку з комою”. </p>
        <p>Крапка з комою може бути пропущена безпосередньо перед закриваючих
          дужок, і таким чином твердження як&nbsp;</p>
        <pre>    go func() { for { dst &lt;- &lt;-src } }()
</pre>
        <p>не потребує крапки з комою. Ідеоматично програми Go мають крапки з
          комою тільки в таких місцях, як твердження циклів, для від’єднання
          ініціалізатору, умови та елементу продовження. Вони також потрібні для
          роз’єднання декількох тверджень в одному рядку, якщо ви забажаєте
          написати код таким чином.</p>
        <p>Одним слідоцтвом з правил вставляння крапки з комою є те, що іи не
          можете розташувати відкриваючу дужку управляючої структури (<code>if</code>,
          <code>for</code>, <code>switch</code> або <code>select</code>) на
          наступному рядку. Якщо ви так зробите, крапка з комою буде розміщена
          перед дужкою, що може викликати небажані ефекти. Записуйте їх
          наступним чином </p>
        <pre>if i &lt; f() {
    g()
}
</pre>
        <p>а не так </p>
        <pre>if i &lt; f()  // невірно!
{           // невірно!
    g()
}
</pre>
        <h2 id="control-structures">Структури управління</h2>
        <p>Структури усравління Go споріднені з такими в C, але відрізняються у
          важливий спосіб. Немає циклів <code>do</code> або <code>while</code>,
          тільки трохи узагальнений <code>for</code>; <code>switch</code>
          більш гнучкий; <code>if</code> та <code>switch</code> сприймають
          опціональні твердження ініціалізації, подібно до таких в <code>for</code>;
          твердження <code>break</code> та <code>continue</code> приймають
          опціональну мітку, що уточнює що саме треба перервати або продовжити;
          існують також нові структури управління, включаючи перемикач типу та
          багатошляховий селектор комунікації&nbsp;<code>select</code>.
          Синтаксис також троі інший: немає дужок та тіла мають бути обмежені в
          фігурних дужках. </p>
        <h3 id="if">If</h3>
        <p> В Go простий <code>if</code> виглядає таким чином: </p>
        <pre>if x &gt; 0 {
    return y
}
</pre>
        <p>Обов’язкові фігурні дужки підштовхують до написання простих
          тверджень&nbsp;<code>if</code> на декількох рядках. Це в жодному разі
          гарний стиль, особливо коли тіло містить управляюче твердження, таке
          як&nbsp;<code>return</code> або <code>break</code>. </p>
        <p>Оскількі&nbsp;<code>if</code> та <code>switch</code> стриймає
          твердження ініціалізації, є загальним бачити його використання для
          встановлення локальних змінних. </p>
        <pre>if err := file.Chmod(0664); err != nil {
    log.Print(err)
    return err
}
</pre>
        <p id="else">В бібліотеках Go ви знайдете, що коли твердження&nbsp;<code>if</code>
          не продовжується в наступному твердженні, тобто тіло завершується на <code>break</code>,
          <code>continue</code>, <code>goto</code> або <code>return </code>—
          непотрібний <code>else</code> пропускають. </p>
        <pre>f, err := os.Open(name)
if err != nil {
    return err
}
codeUsing(f)
</pre>
        <p> Це приклад загальної ситуації, коли код має захищати від серії
          помилкових умов. Код добре читається, якщо успішний потік управління
          збігає вниз по сторінці, уникаючи помилкових випадків по мірі їх
          виникнення. Оскільки помилкові випадки мають схильність завершуватися
          твердженнями&nbsp;<code>return</code>, остаточний код не потребує
          трерджень <code>else</code>. </p>
        <pre>f, err := os.Open(name)
if err != nil {
    return err
}
d, err := f.Stat()
if err != nil {
    f.Close()
    return err
}
codeUsing(f, d)
</pre>
        <h3 id="redeclaration">Повторна декларація та повторне присвоєння</h3>
        <p>Як сторонній ефект, останній приклад попереднього розділу демонструє,
          як працює коротка форма декларації <code>:=</code>. Декларація, що
          викликає&nbsp;<code>os.Open</code> читається як </p>
        <pre>f, err := os.Open(name)
</pre>
        <p>Це твердження декларує дві змінні, <code>f</code> та <code>err</code>.
          Декількома рядками піздніше виклик до&nbsp;<code>f.Stat</code>
          читається як </p>
        <pre>d, err := f.Stat()
</pre>
        <p> що виглядає як це б декларувало&nbsp;<code>d</code> та <code>err</code>.
          Зауважте, тим не менш, що <code>err</code> з’являється в обох
          твердженнях. Це повторення є законним:&nbsp;<code>err</code>
          декларується в першому твердженні, та тільки повторно присвоюється в
          другому. Це означає, що виклик до&nbsp;<code>f.Stat</code>
          використовує існуючу змінну <code>err</code>, що декларована вище, та
          тільки надає їй нове значення. </p>
        <p> В декларації <code>:=</code> змінна&nbsp; <code>v</code> може
          з’явитися навіть якщо вона вже декларована, за умови: </p>
        <ul>
          <li>ця декларація знаходиться в тому ж полі зору, що й існуюча
            декларація&nbsp;<code>v</code> (якщо <code>v</code> вже декларована
            в зовнішньому полі зору , декларація створить нову змінну §),</li>
          <li>відповідне значення в ініціалізації присвоєне&nbsp;<code>v</code>,
            та</li>
          <li>є щонайменше одна інша змінна в декларації, що створюється цією
            декларацією.</li>
        </ul>
        <p>Ця незвична властивість є чистим прагматизмом, роблячи простим
          використовувати єдине значення <code>err</code>, наприклад в довгому
          ланцюжку&nbsp;<code>if-else</code>. Ви побачите використання цього
          пізніше. </p>
        <p> § Слід при цьому зауважити, що в Go поле зору функціональних
          параметрів та зворотніх значень є таким же, що й тіло функції, навіть
          якщо вони лексично з’являються за межами дужок, що обмежують
          тіло.&nbsp; </p>
        <h3 id="for">For</h3>
        <p>В Go цикл <code>for</code> подібний, але не тотожній, такому ж в C.
          Це уніфікує&nbsp;<code>for</code> та <code>while</code>, а також
          немає <code>do-while</code>. Є три форми, тільки одна з них має
          крапку з комою. </p>
        <pre>// Подібне до C for
for init; condition; post { }

// Подібне до C while
for condition { }

// Подібне до C for(;;)
for { }
</pre>
        <p> Короткі декларації роблять простим декларувати індексні змінні
          безпосередньо в циклі. </p>
        <pre>sum := 0
for i := 0; i &lt; 10; i++ {
    sum += i
}
</pre>
        <p>Якщо ви робите цикл по масиву, сектору, рядку або мапі, або читаєте з
          каналу, вираз <code>range</code> може обслуговувати цей цикл. </p>
        <pre>for key, value := range oldMap {
    newMap[key] = value
}
</pre>
        <p> Якщо вам тільки треба перший елемент в діапазоні (ключ або індекс),
          відкиньте другий: </p>
        <pre>for key := range m {
    if key.expired() {
        delete(m, key)
    }
}
</pre>
        <p>Якщо ви тільки потребуете другий елемент в діапазоні (значення),
          використовуйте <em>пустий ідентифікатор</em>, знак підкреслення, щоб
          відкинути перший: </p>
        <pre>sum := 0
for _, value := range array {
    sum += value
}
</pre>
        <p>Пустий ідентифікатор має багато застосувань, як пояснюється в&nbsp;<a
            href="#blank">подальшому розділі</a>. </p>
        <p>Для рядків&nbsp;<code>range</code> робить ще більше роботи для вас,
          розбиваючи окремі точки коду Unicode, розбираючи UTF-8. Хибні
          кодування вживають один байт та продукують замінну руну U+FFFD. (Ім’я,
          з асоційованим вбудованим типом,&nbsp;<code>rune</code> в Go
          термінології є окремою кодовою точкою Unicode. Дивіться <a href="/ref/spec#Rune_literals">специфікацію
            мови</a> для отримання деталей). Цикл </p>
        <pre>for pos, char := range "日本\x80語" { // \x80 є незаконним кодуванням UTF-8
    fmt.Printf("character %#U starts at byte position %d\n", char, pos)
}
</pre>
        <p> друкує </p>
        <pre>character U+65E5 '日' starts at byte position 0
character U+672C '本' starts at byte position 3
character U+FFFD '�' starts at byte position 6
character U+8A9E '語' starts at byte position 7
</pre>
        <p>Наостанок, Go не має оператора коми, та <code>++</code> і <code>--</code>
          є твердженнями, а не виразами. Таким чином, якщо ви бажаєте оновлювати
          декілька змінних в&nbsp;<code>for</code>, вам треба виконувати
          паралельне присвоєння (проте це&nbsp; виключає <code>++</code> та <code>--</code>).
          </p>
        <pre>// Реверс a
for i, j := 0, len(a)-1; i &lt; j; i, j = i+1, j-1 {
    a[i], a[j] = a[j], a[i]
}
</pre>
        <h3 id="switch">Switch</h3>
        <p>В Go <code>switch</code> є більш загальним, ніж в C. Вираз не
          обов’язково має бути константою, та навіть цілим, випадки обчислюються
          зверху до низу, поки співпадіння не буде знайдене, та якщо&nbsp;<code>switch</code>
          не має виразу, він спрацьовує на <code>true</code>. Таким чином
          можливо, і ідіоматично, записати ланцюжок&nbsp;<code>if</code>-<code>else</code>-<code>if</code>-<code>else</code>
          у вигляді&nbsp;<code>switch</code>. </p>
        <pre>func unhex(c byte) byte {
    switch {
    case '0' &lt;= c &amp;&amp; c &lt;= '9':
        return c - '0'
    case 'a' &lt;= c &amp;&amp; c &lt;= 'f':
        return c - 'a' + 10
    case 'A' &lt;= c &amp;&amp; c &lt;= 'F':
        return c - 'A' + 10
    }
    return 0
}
</pre>
        <p>Немає автоматичного перебору, але випадки можуть бути представлені як
          розділені комами списки. </p>
        <pre>func shouldEscape(c byte) bool {
    switch c {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
        return true
    }
    return false
}
</pre>
        <p>Хоча вони й не близько так поширені в Go, як в деяких подібних до C
          мовах, вирази <code>break</code> можуть бути застосовані для раннього
          припинення <code>switch</code>. Однак, час від часу, є необхідність
          перервати оточующий цикл, а не перемикач, і в Go це може бути виконано
          надаючи мітку на цикл та "перерватись" по цій мітці. Цей випадок
          демонструє обидва використання. </p>
        <pre>Loop:
	for n := 0; n &lt; len(src); n += size {
		switch {
		case src[n] &lt; sizeOne:
			if validateOnly {
				break
			}
			size = 1
			update(src[n])

		case src[n] &lt; sizeTwo:
			if n+1 &gt;= len(src) {
				err = errShortInput
				break Loop
			}
			if validateOnly {
				break
			}
			size = 2
			update(src[n] + src[n+1]&lt;&lt;shift)
		}
	}
</pre>
        <p>Зрозуміло, що твердження&nbsp;<code>continue</code> також сприймає
          опціональну мітку, але це стосується тільки циклів. </p>
        <p>Щоб завершити цей розділ, надаємо функцію порівняння для байтових
          сегментів, що використовує два вирази&nbsp;<code>switch</code>: </p>
        <pre>// Compare повертає ціле, порівнюючи два байтових сегмента лексографічно
// Результат буде 0 якщо a == b, -1 якщо a &lt; b, та +1 якщо a &gt; b
func Compare(a, b []byte) int {
    for i := 0; i &lt; len(a) &amp;&amp; i &lt; len(b); i++ {
        switch {
        case a[i] &gt; b[i]:
            return 1
        case a[i] &lt; b[i]:
            return -1
        }
    }
    switch {
    case len(a) &gt; len(b):
        return 1
    case len(a) &lt; len(b):
        return -1
    }
    return 0
}
</pre>
        <h3 id="type_switch">Перемикач типу</h3>
        <p>Перемикач також може бути використаний для з’ясування динамічного
          типу змінної інерфейсу. Такий перемикач типу використовує синтаксис
          типового очікування з ключовим словом&nbsp;<code>type</code> в дужках.
          Якщо перемикач декларує змінну в виразі, змінна буде відповідний тип
          для кожного випадку. Також є ідіоматичним повторно використовувати
          ім’я в таких випадках, що ефективно декларує нову змінну з тим же
          ім’ям, та відміннним типом в кожному випадку. </p>
        <pre>var t interface{}
t = functionOfSomeType()
switch t := t.(type) {
default:
    fmt.Printf("невідомий тип %T", t)       // %T друкує який тип має t
case bool:
    fmt.Printf("boolean %t\n", t)             // t має тип bool
case int:
    fmt.Printf("integer %d\n", t)             // t має тип int
case *bool:
    fmt.Printf("pointer to boolean %t\n", *t) // t має тип *bool
case *int:
    fmt.Printf("pointer to integer %d\n", *t) // t має тип *int
}
</pre>
        <h2 id="functions">Функції</h2>
        <h3 id="multiple-returns">Множинні зворотні значення</h3>
        <p>Однією з незвичайних можливостей Go є те, що функції і методи можуть
          повертати множинні значення. Ця форма може бути використана для
          покращення декількох неоковирних ідіом в програмах на C: помилка в
          полосі повертає <code>-1</code> для <code>EOF</code> та модифікація
          аргументу, переданому як адреса. </p>
        <p>В C помилка запису сигналізує негативним відліком з кодом помилки,
          засекреченим подалі в змінному місці. В Go <code>Write</code> може
          повернути лічильник <em>та</em> код помилки: “Так, ви записали деякі
          байти, але не всі з них, бо ви заповнили пристрій". Сигнатура
          методу&nbsp; <code>Write</code> для файлів з пакунку <code>os</code>
          така: </p>
        <pre>func (file *File) Write(b []byte) (n int, err error)
</pre>
        <p> та як свідчить документація, він повертає підрахунок записаних
          байтів, та не-nil <code>error</code>, коли <code>n</code> <code>!=</code>
          <code>len(b)</code>. Це загальний стиль; дивіться розділ про обробку
          помилок для більшої кількості прикладів. </p>
        <p> Подібний підхід виключає необхідність передавати вказівник для
          зворотнього значення, щоб симулювати параметр-посилання. Це нескладна
          функція вибирає число по позиції в секторі байтів, та повертає його і
          число в наступній позиції. </p>
        <pre>func nextInt(b []byte, i int) (int, int) {
    for ; i &lt; len(b) &amp;&amp; !isDigit(b[i]); i++ {
    }
    x := 0
    for ; i &lt; len(b) &amp;&amp; isDigit(b[i]); i++ {
        x = x*10 + int(b[i]) - '0'
    }
    return x, i
}
</pre>
        <p>Ви можете використоувати її для сканування чисел у вхідному секторі <code>b</code>
          таким чином: </p>
        <pre>    for i := 0; i &lt; len(b); {
        x, i = nextInt(b, i)
        fmt.Println(x)
    }
</pre>
        <h3 id="named-results">Іменовані параметри результату</h3>
        <p>Зворотнє значення або "параметри" результату в Go функції можуть
          надаться імена і використовуватися як звичайні змінні, таким же чином
          як вхідні параметри. Будучі поіменованими, вони ініціалізуються
          нульовими значеннями для свойого типу на початку функції; якщо функція
          виконує твердження <code>return</code> без аргументів, поточні
          значення параметрів результату використовуються як зворотні значення.
        </p>
        <p>Імена не є обов’язковими, але вони можуть зробити код коротшим та
          зрозумілішим: вони є документацією. Якщо ім’я результату є <code>nextInt</code>,
          стає очевидним, який з параметрів повертає&nbsp;<code>int</code>, і
          яке саме. </p>
        <pre>func nextInt(b []byte, pos int) (value, nextPos int) {
</pre>
        <p> Оскільки іменовані результати ініціалізовані та прив’язані до
          необтяженого повертання, вони можуть спростит на прояснити справу. Ось
          версія <code>io.ReadFull</code> що гарно використовує це: </p>
        <pre>func ReadFull(r Reader, buf []byte) (n int, err error) {
    for len(buf) &gt; 0 &amp;&amp; err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
</pre>
        <h3 id="defer">Defer</h3>
        <p> Твердження Go <code>defer</code> планує виклик функції (<i>відкладеної
            функції</i>), щоб вона була викликана безпосередньо перед тим, як
          функція, що викликала <code>defer</code>, поверне управління. Це
          незвичайний, але ефективній шлях мати справу з ситаацією, такою я
          вивільнення ресурсів, що має бути виконана безвідносно від того, за
          яким шляхом функція дійде краю. Канонічні приклади є розблокування
          мьютексу або закриття файлу. </p>
        <pre>// Contents повертає вміст файлу одним рядком.
func Contents(filename string) (string, error) {
    f, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer f.Close()  // f.Close буде виконано коли ми закінчимо.

    var result []byte
    buf := make([]byte, 100)
    for {
        n, err := f.Read(buf[0:])
        result = append(result, buf[0:n]...) // append обговорюється пізніше.
        if err != nil {
            if err == io.EOF {
                break
            }
            return "", err  // f буде закрито, якщо ми повернемося тут.
        }
    }
    return string(result), nil // f буде закрито, якщо ми повернемося тут.
}
</pre>
        <p>Відкладання виклику функції, такої як&nbsp;<code>Close</code>, має
          дві переваги. По-перше, це гарантує, що ви ніколи не забудете закрити
          файл, помилка, яку легко зробити, якщо ви піздніше редагуєте функцію
          та додаєте новий зворотній шлях. По-друге, це означає, що закриття
          посідає своє місце біля відкриття, що значно ясніше, ніж розміщення їх
          на двох кінцях функції. </p>
        <p>Аргументи до відкладеної функції (що включає отримувача, якщо функція
          є методом) обчислюються коли викликається&nbsp;<i>defer</i>, не тоді,
          коли виконується сам <em>виклик</em>. Окрім виключення стурбованості,
          що змінні зміняться в процесі роботи функції, це означає, що одне
          місце відкладеного виклику може відкласти декілька виконань функції.
          Ось беззмістовний приклад. </p>
        <pre>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf("%d ", i)
}
</pre>
        <p>Відкладені функції виконуються в стеці LIFO, тож цей код спричинить
          друк <code>4 3 2 1 0</code> , коли функція поверне керування. Більш
          доречний приклад є простим способом зробити трасування виконання
          функції на протязі роботи програми. Ми можемо написати пару простих
          функцій трасування, як ці: </p>
        <pre>func trace(s string)   { fmt.Println("entering:", s) }
func untrace(s string) { fmt.Println("leaving:", s) }

// Використовуємо їх так:
func a() {
    trace("a")
    defer untrace("a")
    // робимо щось....
}
</pre>
        <p>Ми можемо зробити краще, використовуючи факт, що аргументи до
          відкладеної функції обчислюються коли виконується&nbsp;<code>defer</code>.
          Трасування може встановити аргумент для подпрограми де-трасування. Ось
          приклад: </p>
        <pre>func trace(s string) string {
    fmt.Println("entering:", s)
    return s
}

func un(s string) {
    fmt.Println("leaving:", s)
}

func a() {
    defer un(trace("a"))
    fmt.Println("in a")
}

func b() {
    defer un(trace("b"))
    fmt.Println("in b")
    a()
}

func main() {
    b()
}
</pre>
        <p> друкує </p>
        <pre>entering: b
in b
entering: a
in a
leaving: a
leaving: b
</pre>
        <p>Для програмістів, звикших до блок-рівня управління ресурсами з інших
          мов,&nbsp;<code>defer</code> може здаватись дивним, але його найбільш
          цікаві та потужні застосування витікають саме з факту, що він не
          блок-базований, а функція-базований. В розділах про&nbsp;<code>panic</code>
          та <code>recover</code> ми побачимо другий приклад його можливостей.</p>
        <h2 id="data">Дані</h2>
        <h3 id="allocation_new">Розміщення за допомогою <code>new</code></h3>
        <p> Go має два примітива розміщення, вбудовані функції&nbsp;<code>new</code>
          та <code>make</code>. Вони роблять різні речі та стосуються різних
          типів, що може спантеличити, але правила є простими. Спочатку
          побалакаємо про <code>new</code>. Це вбудована функція, що розміщує
          пам’ять, та на відміну від інших мов, вона <em>не ініціалізує</em>
          пам’ять, вона тільки занульовує її. Саме так, <code>new(T)</code>
          розміщує очищене вмістовище для нового елементу типу&nbsp;<code>T</code>
          та повертає її адресу, значення типу&nbsp;<code>*T</code>. В термінах
          Go вона повертає вказівник на нове нульове значення типу <code>T</code>.
        </p>
        <p> Оскільки пам’ть, що повертає <code>new</code>, є занульованою, вона
          буде корисною для розміщення, коли при розробці ваших структур даних
          нульові значення кожного типу можуть використовуватись без подальшої
          ініціалізації. Це означає, що користувач кожного типу може створити
          екземпляр за допомогою&nbsp;<code>new,</code> та вже бути готовим для
          роботи. Наприклад, документація для&nbsp;<code>bytes.Buffer</code>
          стверджує, що "нульове значення для&nbsp;<code>Buffer</code> є пустий
          буфер, готовий до ужитку". Подібно, <code>sync.Mutex</code> не має
          явного конструктора або методу <code>Init</code>. Навпаки, нульове
          значення для&nbsp;<code>sync.Mutex</code> є визначеним так, щоб бути
          незаблокованим мьютексом. </p>
        <p>Коли нульове значення є корисним, то це діє транзистивно. Розглянте
          наступне визначення. </p>
        <pre>type SyncedBuffer struct {
    lock    sync.Mutex
    buffer  bytes.Buffer
}
</pre>
        <p>Значення типу <code>SyncedBuffer</code> також готові для
          безпосереднього застосування після розташевання або визначення. В
          наступному клаптику обоє, <code>p</code> та <code>v</code>, будуть
          робить коректно без подальшого налаштування. </p>
        <pre>p := new(SyncedBuffer)  // тип *SyncedBuffer
var v SyncedBuffer      // тип  SyncedBuffer
</pre>
        <h3 id="composite_literals">Конструктори та складні літерали</h3>
        <p>Часом нульові значення недостатньо гарні, і тому потрібні
          конструктори ініціалізації, як в цьому прикладі, що є похідним з
          пакунку <code>os</code>. </p>
        <pre>func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := new(File)
    f.fd = fd
    f.name = name
    f.dirinfo = nil
    f.nepipe = 0
    return f
}
</pre>
        <p> Тут має місце забагато загального. Ми можемо спростити це з
          використанням <em>складного літералу</em>, що є виразом, що створює
          новий екземпляр кожного разу, коли буває обчислений. </p>
        <pre>func NewFile(fd int, name string) *File {
    if fd &lt; 0 {
        return nil
    }
    f := File{fd, name, nil, 0}
    return &amp;f
}
</pre>
        <p> Зауважте, що на відміну від C, є достатньо гарним повернути адресу
          локальної змінної; розташування, асоційоване зі змінною, утримується
          після повернення функції. Фактично, беручи адресу складного літералу,
          розміщує свіжий екземпляр кожного разу, коли обчислюється, і таким
          чином ми маємо змогу скомбіювати ці два останні рядки. </p>
        <pre>    return &amp;File{fd, name, nil, 0}
</pre>
        <p>Поля композитного літералу мають дотримуватися порядку та мають бути
          присутніми. Однак маркуючи елементи явно у вигляді пар <i>поле</i><code>:</code><i>значення</i>,
          ініціалізатори можуть з’являтися в будь якому порядку, залишаючи
          пропущені з їх власними нульовими значеннями. Таким чино можа сказати</p>
        <pre>    return &amp;File{fd: fd, name: name}
</pre>
        <p> Як обмежувальний випадок, якщо композитний літерал зовсім не містить
          полів, він створює нульове значення для типу. Вирази <code>new(File)</code>
          та <code>&amp;File{}</code> є еквівалентними. </p>
        <p>Композитні літерали можуть також бути створені для массивів, секторів
          та мап, де помітки полів будуть індесками або ключами мап, як
          належить. В ціх прикладах ініціалізатори роблять безвідносно до
          значення&nbsp;<code>Enone</code>, <code>Eio</code> та <code>Einval</code>,
          до тих пір, доки вони відрізняються. </p>
        <pre>a := [...]string   {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
s := []string      {Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
m := map[int]string{Enone: "no error", Eio: "Eio", Einval: "invalid argument"}
</pre>
        <h3 id="allocation_make">Розміщення за допомогою <code>make</code></h3>
        <p> Повернемося до розміщення. Вбудована функція <code>make(T, </code><i>args</i><code>)</code>
          прислуговується іншій цілі, ніж&nbsp;<code>new(T)</code>. Вона створює
          тільки сегменти, мапи або канали, та повертає <em>ініціалізоване</em>
          (не <em>занулене</em>) значення типу <code>T</code> (не <code>*T</code>).
          Смислом для різниці є те, що ці три типи за сценою представлють
          структури даних, що мають бути ініціалізованими перед використанням.
          Сегмент, наприклад, є три-єдиним дескриптором, що містить вказівник на
          дані (в масиві), довжину, та місткість. І поки ці три не будуть
          ініціалізовані, сектор є&nbsp;<code>nil</code>. Для секторів, мап та
          каналів, <code>make</code> ініціалізує внутрішню структуру даних та
          готує значення до використання. наприклад,&nbsp;</p>
        <pre>make([]int, 10, 100)
</pre>
        <p>розміщує масив з 100 цілих, після цього створює структуру сегменту
          довжиною 10 та місткістю 100, що вказує на перші 10 елементів масиву.
          (При створенні сегменту місткість може бути пропущена; дивіться розділ
          про сегменти для подальшої інформації). Для контрасту, <code>new([]int)</code>
          повертає вказівник на тільки що розташовану, занульовану структуру, і
          таким чином вказівник на значення сегменту <code>nil</code>. </p>
        <p> Ці приклади іллюструють розбіжності між&nbsp;<code>new</code> та <code>make</code>.
        </p>
        <pre>var p *[]int = new([]int)       // розміщує структуру сегменту; *p == nil; рідко корисне
var v  []int = make([]int, 100) // сегмент v тепер посилається на новий масив зі 100 цілих

// Дуже складно:
var p *[]int = new([]int)
*p = make([]int, 100, 100)

// Ідіоматично:
v := make([]int, 100)
</pre>
        <p>Запам’ятайте, що <code>make</code> придатний лише до мап, сегментів
          та каналів, та не повертає вказівника. Щоб отримати явний вказівник
          розташуйте <code>new</code> або явно візміть адресу від змінної. </p>
        <h3 id="arrays">Масиви</h3>
        <p> Масиви корисні, коли планується детальований розклад пам’яті та
          часом допомагають уникнути разміщення, але загалом вони є будівельними
          блоками для сегментів, предметом наступного розділу. Щоб покласти
          основу цієї теми, скажемо дещо про масиви.</p>
        <p>Є декілька основних відмінностей між роботою масивів в Go та C. В Go,
        </p>
        <ul>
          <li> масиви є значення. присвоєння одного масиву іншому копіює всі
            елементи. </li>
          <li>як слідоцтво, якщо ви передаєте масив в функцію, вона отримає <em>копію</em>
            масива, не вказівник на нього. </li>
          <li>Розмір масива є частиною його типу. Типи <code>[10]int</code> та<code>[20]int</code>
            відрізняються. </li>
        </ul>
        <p>Властивість значення може біти корисним, але також коштовним; якщо ви
          бажаєте поведінку як в C та бути ефективним, ви можете надати
          вказівник на масив. </p>
        <pre>func Sum(a *[3]float64) (sum float64) {
    for _, v := range *a {
        sum += v
    }
    return
}

array := [...]float64{7.0, 8.5, 9.1}
x := Sum(&amp;array)  // Зазанчте на явний оператор взяття адреси
</pre>
        <p>Але навіть цей стиль не є ідеоматичним для Go. Замість використовуйте
          сегменти. </p>
        <h3 id="slices">Сегменти</h3>
        <p> Сегменти огортають масиви щоб стати більш загальним, потужнім та
          зручним інтерфейсом для послідовностей даних. За винятком елементів з
          явним розміром, таких, як матриці перетворення, більшість
          програмування матриць в Go зроблене через сегменти, скоріше, ніж через
          масиви. </p>
        <p>Сегменти утримують посилання на підлягаючий масив, та якщо ви
          присвоїте один сегмент іншому, обоє будуть посилатись на ту ж матрицю.
          Якщо функція отримує аргумент типу сегмент, зміни до елементів
          сегменту будуть видимі викликаючій стороні, аналогічно передачі
          вказівника на підлягаючий масив. Функція <code>Read</code> може,
          таким чином, прийняти аргумент типу сегмент, скоріше, ніж вказівник на
          підрахунок; довжина в складі сегменту встановлює вище обмеження,
          скільки даних можна прочитати. Ось сігнатура методу <code>Read</code>
          типу <code>File</code> в пакунку <code>os</code>: </p>
        <pre>func (file *File) Read(buf []byte) (n int, err error)
</pre>
        <p> Метод повертає число байтів та значення помилки, якщо така виникне.
          Щоб прочитати перші 32 байтів більшого буферу <code>buf</code>, <i>наріжте</i>
          (тут в якості дієприкметника) буфер. </p>
        <pre>    n, err := f.Read(buf[0:32])
</pre>
        <p> Така нарізка є загальною та ефективною. Фактично, не розглядаючи
          ефективність прямо зараз, наступний клаптик може також читати перші 32
          байтів з буфера. </p>
        <pre>    var n int
    var err error
    for i := 0; i &lt; 32; i++ {
        nbytes, e := f.Read(buf[i:i+1])  // Читання одного байту.
        if nbytes == 0 || e != nil {
            err = e
            break
        }
        n += nbytes
    }
</pre>
        <p>Довжина сегменту може бути зміненою до тих пір, поки вона ще
          вкладається в обмеження підлягаючого масиву; тільки присвойте його до
          самого сегменту. <em>Містскість</em> сегменту, досутпна через
          вбудовану функцію&nbsp;<code>cap</code>, вказує на максимальну
          довжину, що може набути сегмент. Ось функція для додавання даних до
          сегменту. Якщо дані перевищують містскість, сегмент буде повторно
          розташований. Результуючий сегмент повертається. Функція використовує
          той факт, що&nbsp;<code>len</code> та <code>cap</code> припустимі,
          коли застосовуються до сегменту <code>nil</code>, та повертає 0. </p>
        <pre>func Append(slice, data[]byte) []byte {
    l := len(slice)
    if l + len(data) &gt; cap(slice) {  // повторне розміщення
        // Allocate double what's needed, for future growth.
        newSlice := make([]byte, (l+len(data))*2)
        // Функція копіювання заздалегідь визначена та процює для кожного типу сегментів.
        copy(newSlice, slice)
        slice = newSlice
    }
    slice = slice[0:l+len(data)]
    for i, c := range data {
        slice[l+i] = c
    }
    return slice
}
</pre>
        <p>Ми маємо повернути сегмент, оскільки, хоча <code>Append</code> може
          змінити елементи <code>slice</code>, самий сегмент (структура часу
          виконання, що утримує вказівник, довжину та місткість) передається по
          значенню. </p>
        <p>Ідея додавання до сегменту така корисна, що вона навіть вкладена в
          вбудовану функцію&nbsp;<code>append</code>. Щоб зрозуміти план цієї
          функції нам потрібно декілька більше інформації. Таким чином
          повернемося до цього пізніше.&nbsp;</p>
        <h3 id="two_dimensional_slices">Двовимірні сегменти</h3>
        <p> Масиви Go та сегменти є одновимірними. Щоб створити еквівалент
          двовимірного масиву або сегменту потрібно визначити масив-масивів або
          сегмент-сегментів, не кшталт наступного: </p>
        <pre>type Transform [3][3]float64  // Масив 3x3, настправді масив масивів.
type LinesOfText [][]byte     // Сегмент сегментів.
</pre>
        <p>Оскільки сегменти мають змінну довжину, можливо мати кожний
          внутрішний сегмент різної довжини. Це може бути загальною ситуацією,
          як в нашому прикладі <code>LinesOfText</code>: кожний рядок має
          незалежну довжину. </p>
        <pre>text := LinesOfText{
	[]byte("Now is the time"),
	[]byte("for all good gophers"),
	[]byte("to bring some fun to the party."),
}
</pre>
        <p> Часом необхідно розташувати двовимірний сегмент, ситуація, що
          виникає, наприклад, через обробку сканованих рядків пікселів. Є два
          шляхи досягти цього. Один є розташувати кожний сегмент окремо; інший -
          розташувати єдиний масив та вказати окремі сегменті в ньому. Що
          застосувати залежить від вашого застосування. Якщо сегменти можуть
          зростати або скорочуватись, вони мають бути розташовані окремо, для
          запобігання перезапису наступного рядка; якщо ні, може бути більше
          ефективним створити об’єкт з загальним розташуванням. Для посилання
          тут надаються обриси двох методів.&nbsp; Спершу рядок за раз: </p>
        <pre>// Allocate the top-level slice.
picture := make([][]uint8, YSize) // Один рядок для кожного y.
// Цикл по рядках, розташовующи сегмент для кожного рядка.
for i := range picture {
	picture[i] = make([]uint8, XSize)
}
</pre>
        <p>І тепер одне розташування, сегменти в рядках: </p>
        <pre>// Розміщення сегменту вищого рівня, як і раніше.
picture := make([][]uint8, YSize) // Один рядок для кожного y.
// Розташування одного більшого сегменту для утримання всіх пікселів.
pixels := make([]uint8, XSize*YSize) // Має тип []uint8 навіть якщо зображення є [][]uint8.
// Перебіг по рядках, нарізаючи кожний рядок з початку залишку сегменту пікселів.
for i := range picture {
	picture[i], pixels = pixels[:XSize], pixels[XSize:]
}
</pre>
        <h3 id="maps">Мапи</h3>
        <p> Мапи є зручною та потужною вбудованою структурою даних, що асоціює
          значеня одного типу (<em>ключ</em>) з значеннями іншого типу (<em>елементи
            </em>або <em>значення</em>). Ключ може бути любого типу, для якого
          визначено відповідний оператор, таким, як ціле, дійсне з плаваючою
          комою, або комплексне число, рядок, вказівник, інтерфейс (до тих пір,
          доки динамічний тип підтримує рівність), структура або масив. Сегменти
          не можуть виступати в ролі ключів мап, оскільки рівність не визначена
          для них. Подібно до сегментів, мапи утримують посилання на підлягаючу
          структуру даних. Якщо передати мапу до функції, що змінює вміст мапи,
          зміни будуть видимі викликаючій стороні.&nbsp;</p>
        <p>Мапи можуть буть побудовані з використанням синтаксису звичайного
          композитного літералу, з поділеними парами ключ-значення, так що
          просто збудувати їх на етапі ініціалізації. </p>
        <pre>var timeZone = map[string]int{
    "UTC":  0*60*60,
    "EST": -5*60*60,
    "CST": -6*60*60,
    "MST": -7*60*60,
    "PST": -8*60*60,
}
</pre>
        <p> Доступ та отримання значень мапи синтаксично подібно до виконання
          того ж для масивів та сегментів, за тим виключенням, що індекс не має
          бути цілим. </p>
        <pre>offset := timeZone["EST"]
</pre>
        <p> Спроба отримати значення мапи з ключем, що не присутній в мапі,
          повертатиме нульове значення для типу входжень в мапу. Наприклад, якщо
          мапа зберігає цілі, пошук неіснуючого ключа буде повертати&nbsp;<code>0</code>.
          Набір (множина) може бути зреалізована як мапа зі значенням <code>bool</code>.
          Встановіть елемент мапи в <code>true</code>, щоб вкласти значення
          набір, та потім перевірте його простим індексуванням.&nbsp;</p>
        <pre>attended := map[string]bool{
    "Ann": true,
    "Joe": true,
    ...
}

if attended[person] { // буде false, якщо людина не присутня в мапі
    fmt.Println(person, "was at the meeting")
}
</pre>
        <p>Часом ви маєте відрізнити відсутне значення від нульового значення.
          Чи є запис для <code>"UTC"</code>, або це пустий рядок, оскільки його
          зовсім немає в мапі? Ви можете визначити це за допомогою множинного
          присвоювання. </p>
        <pre>var seconds int
var ok bool
seconds, ok = timeZone[tz]
</pre>
        <p>За зрозумілих причин це називається ідіомою “кома ok”. В цьому
          прикладі, якщо <code>tz</code> присутній, <code>seconds</code> буде
          встановлено відповідно, та&nbsp;<code>ok</code> буде true; якщо ні, <code>seconds</code>
          буде встановленим в нуль, та<code> ok</code> буде false. Ось функція,
          що використовує це, разом з гарним друком помилки: </p>
        <pre>func offset(tz string) int {
    if seconds, ok := timeZone[tz]; ok {
        return seconds
    }
    log.Println("unknown time zone:", tz)
    return 0
}
</pre>
        <p> Щоб перевірити наявність в мапі без турбування про значення, ви
          можете використати <a href="#blank">пустий ідентифікатор</a> (<code>_</code>)
          замість звичайної змінної для значення. </p>
        <pre>_, present := timeZone[tz]
</pre>
        <p> Для видалення входження з мапи використовуйте вбудовану
          функцію&nbsp;<code>delete</code>, чиї аргументи є мапа та ключ, що має
          бути видалений. Є небезпечним робити це, навіть якщо ключ вже
          відсутній в мапі. </p>
        <pre>delete(timeZone, "PDT")  // Тепер Standard Time
</pre>
        <h3 id="printing">Друк</h3>
        <p>Форматований друк в Go використовує стиль, подібний до стилю
          сімейства C <code>printf</code>, але є багатшим та більш загальним.
          Функції живуть в пакунку&nbsp;<code>fmt</code>, та мають ім’я з
          великої літери: <code>fmt.Printf</code>, <code>fmt.Fprintf</code>, <code>fmt.Sprintf</code>
          та таке інше. Рядкові функції (<code>Sprintf</code> etc.) повертають
          рядок, що заповнює наданий буфер. </p>
        <p>Ви не маєте надавати рядок форматування. Для кожного <code>Printf</code>,
          <code>Fprintf</code> та <code>Sprintf</code> є інша пара функцій,
          наприклад&nbsp;<code>Print</code> та <code>Println</code>. Ці функцїї
          не беруть рядок формату, а замість цього генерують формат по
          замовчанню для кожного елементу. Версії&nbsp;<code>Println</code>
          також додають проміжок між аргументами та додають новий рядок до
          результату, тоді як версії&nbsp;<code>Print</code> додають проміжки
          тільки якщо операнд з будь-якого боку є рядоком. </p>
        <pre>fmt.Printf("Hello %d\n", 23)
fmt.Fprint(os.Stdout, "Hello ", 23, "\n")
fmt.Println("Hello", 23)
fmt.Println(fmt.Sprint("Hello ", 23))
</pre>
        <p>Функції форматованого друку <code>fmt.Fprint</code> та товариші
          сприймають в якості першого аргументу будь-який об’єкт, що реалізує
          інтерфейс <code>io.Writer</code>; змінні <code>os.Stdout</code> та <code>os.Stderr</code>
          є відомими прикладами. </p>
        <p>Тут речі починають відрізнятися від C. По-перше числові формати, такі
          як&nbsp;<code>%d</code>, не сприймають флаги щодо знаку та розміру;
          замість цього прецедури друку використовують тип аргументу для
          визначення ціх властивостей. </p>
        <pre>var x uint64 = 1&lt;&lt;64 - 1
fmt.Printf("%d %x; %d %x\n", x, x, int64(x), int64(x))
</pre>
        <p>друкує</p>
        <pre>18446744073709551615 ffffffffffffffff; -1 -1
</pre>
        <p>Якщо ви бажаєте тільки перетворення за замовчанням, таке, як
          десятичне для цілих, ви можете використати загально доступний
          формати&nbsp;<code>%v</code> (означає “value”); результат буде самий
          такий, що продукують&nbsp;<code>Print</code> та <code>Println</code>.
          Більше того, цей формат може друкувати <em>любе</em> значення, навіть
          масиви, сегменти, структури та мапи. Ось твердження друку для мапи
          часових поясів, визначена в попередньому розділі. </p>
        <pre>fmt.Printf("%v\n", timeZone)  // або ж fmt.Println(timeZone)
</pre>
        <p>що на виході дає </p>
        <pre>map[CST:-21600 PST:-28800 EST:-18000 UTC:0 MST:-25200]
</pre>
        <p>Для мап, зрозуміло, ключі можуть з’являтися на виході в будь-якому
          порядку. Коли друкується структура, модифікований формат&nbsp;<code>%+v</code>
          анотує поля структури з їх іменами, та для любого значення
          альтернативний формат <code>%#v</code> друкує значення в повному
          синтаксисі Go. </p>
        <pre>type T struct {
    a int
    b float64
    c string
}
t := &amp;T{ 7, -2.35, "abc\tdef" }
fmt.Printf("%v\n", t)
fmt.Printf("%+v\n", t)
fmt.Printf("%#v\n", t)
fmt.Printf("%#v\n", timeZone)
</pre>
        <p> друкує</p>
        <pre>&amp;{7 -2.35 abc   def}
&amp;{a:7 b:-2.35 c:abc     def}
&amp;main.T{a:7, b:-2.35, c:"abc\tdef"}
map[string] int{"CST":-21600, "PST":-28800, "EST":-18000, "UTC":0, "MST":-25200}
</pre>
        <p> (Зауважте амперсанди). Відомий квотований формат також доступний
          через&nbsp;<code>%q</code>, коли застосовується до значення
          типів&nbsp;<code>string</code> або <code>[]byte</code>.
          Альтернативний формат <code>%#q</code> буде, навпаки, використовувати
          зворотні лапки, коли це можливо. (Формат <code>%q</code> також
          придатний до цілих та рун, продукуючи константу-руну в одинарних
          лапках). Також, <code>%x</code> робить для рядків, байтових массивів
          та байтових сегментів, а також для цілих, генеруючи довгі
          шеснадцятеричні рядкі, та з проміжками в форматі (<code>%&nbsp;x</code>)
          формуються проміжки між байтами. </p>
        <p>Другий корисний формат є <code>%T</code>, що друкує <em>тип</em>
          значення. </p>
        <pre>fmt.Printf("%T\n", timeZone)
</pre>
        <p> друкує</p>
        <pre>map[string] int
</pre>
        <p>Якщо ви бажаєте контролювати формат по замовчанню для власного типу,
          все що потрібно - це визначити метод з сігнатурою&nbsp;<code>String()
            string</code> для цього типу. Для нашого простого типу <code>T</code>
          це може виглядати так. </p>
        <pre>func (t *T) String() string {
    return fmt.Sprintf("%d/%g/%q", t.a, t.b, t.c)
}
fmt.Printf("%v\n", t)
</pre>
        <p>щоб надрукувати в форматі </p>
        <pre>7/-2.35/"abc\tdef"
</pre>
        <p> (Якщо ви бажаєте друкувати <em>значення</em> типу&nbsp; <code>T</code>
          разом з вказівниками на <code>T</code>, отримувач для <code>String</code>
          має бути типу значення; цей приклад використовує вказівник, оскільки
          це більш ефективно та ідіоматично для структурних типів. Дивіться
          розділ нижче&nbsp; по&nbsp;<a href="#pointers_vs_values">отримувачі
            вказівників vs. значення</a> для додаткових даних). </p>
        <p>Наш метод <code>String</code> спроможний викликати <code>Sprintf</code>,
          оскільки процедури друку повністю реентерантні, та можуть бути
          огорнуті таким чином. Тим не менш, є одна важлива деталь для розуміння
          цього підходу: не конструюйте метод <code>String</code>,
          викликаючи&nbsp;<code>Sprintf</code> таким чином, цо буде створювати
          безкінечну рекурсію до вашого методу&nbsp; <code>String</code>. Це
          може статися, якщо виклик <code>Sprintf</code> намагатиметься
          друкувати отримувача напряму як рядок, що, з свого боку, буде
          викликати цей метод знову. Це поширена та проста помилка, що її
          роблять, як показує наступний приклад. </p>
        <pre>type MyString string

func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", m) // Помилка: буде рециклювати вічно.
}
</pre>
        <p>Це також легко виправити: перетворіть аргумент на базовий рядковий,
          що не має методу. </p>
        <pre>type MyString string
func (m MyString) String() string {
    return fmt.Sprintf("MyString=%s", string(m)) // OK: зауважте перетворення.
}
</pre>
        <p>В наступному розділу&nbsp;<a href="#initialization">ініціалізації</a>
          ми побачимо другий спосіб, що уникає цієї рекурсії. </p>
        <p>Друга технологія друку є передача аргументів процедури друку напряму
          іншій такій процедурі. Сігнатура&nbsp;<code>Printf</code> використовує
          тип <code>...interface{}</code> для останнього аргументу для вказання
          довільної кількості параметрів (довільного типу), що можуть з’явитися
          за форматом. </p>
        <pre>func Printf(format string, v ...interface{}) (n int, err error) {
</pre>
        <p>В функції&nbsp; <code>Printf</code> аргумент <code>v</code>
          виступає як змінна типу&nbsp;<code>[]interface{}</code>, але якщо він
          передається до іншої функції зі змінним списком параметрів, він
          виступає як звичайний список аргументів. Ось реалізація функції&nbsp;<code>log.Println</code>
          , що ми використовували вище. Вона передає аргументи напряму до <code>fmt.Sprintln</code>
          для саме форматування. </p>
        <pre>// Println друкує до стандартного журналу в стилі fmt.Println.
func Println(v ...interface{}) {
    std.Output(2, fmt.Sprintln(v...))  // Вихід сприймає (int, string)
}
</pre>
        <p> Ми друкуємо&nbsp;<code>...</code> після <code>v</code> у вкладеному
          виклику до <code>Sprintln</code>, щоб сказати компілятору
          розцінювати&nbsp;<code>v</code> як список аргументів; інакше він
          тільки передасть&nbsp;<code>v</code> як один аргумент типу сектор. </p>
        <p> Є навіть більше до друку, чим тут змальовано. Дивіться документацію
          <code>godoc</code> до пакунтку <code>fmt</code> для додаткових
          деталей. </p>
        <p>До речі, параметр <code>...</code> може бути визначеного типу,
          наприклад,&nbsp;<code>...int</code> для функції min, що обирає
          найменше зі списку цілих: </p>
        <pre>func Min(a ...int) int {
    min := int(^uint(0) &gt;&gt; 1)  // найбільше int
    for _, i := range a {
        if i &lt; min {
            min = i
        }
    }
    return min
}
</pre>
        <h3 id="append">Додавання</h3>
        <p>Тепер ми маємо недостаючі частини для пояснення роботи вбудованої
          функції&nbsp;<code>append</code>. Сігнатура&nbsp;<code>append</code>
          відрізняється від нашої власної функції&nbsp;<code>Append</code>,
          зазначеною вище. Семантично, це на кшталт такого: </p>
        <pre>func append(slice []<i>T</i>, elements ...<i>T</i>) []<i>T</i>
</pre>
        <p> де <i>T</i> є замісником для любого окремого типу. Насправді, ви не
          можете написати функцію на Go, де тип <code>T</code> визначається
          викликаючою стороною. Ось чому&nbsp;<code>append</code> є вбудованою:
          вона потребує допомоги від компілятора. </p>
        <p> Що робить <code>append</code>, це додає елементи в кінець сегменту,
          та повертає результат. Результат потребує бути повернуним, бо, так як
          і з нашим&nbsp;<code>Append</code>, підлягаючий масив може змінитись.
          Ось простий приклад</p>
        <pre>x := []int{1,2,3}
x = append(x, 4, 5, 6)
fmt.Println(x)
</pre>
        <p> друкує <code>[1 2 3 4 5 6]</code>. Таким чином <code>append</code>
          робить дещо подібне до&nbsp;<code>Printf</code>, збираючи довільну
          кількість аргументів. </p>
        <p> Але що, коли ми бажаємо робити те, що робить наш <code>Append</code>,
          та додавати сегмент до сегменту? Просто використовуйте <code>...</code>
          на боці виклику, саме так, як робили в виклику до&nbsp;<code>Output</code>
          вище. Цей клаптик продукує ідентичний вихід до наданого вище. </p>
        <pre>x := []int{1,2,3}
y := []int{4,5,6}
x = append(x, y...)
fmt.Println(x)
</pre>
        <p>Без цього&nbsp;<code>...</code> це не скомпілюється, оскільки типи
          будуть невірними, ; <code>y</code> не є типу <code>int</code>. </p>
        <h2 id="initialization">Ініціалізація</h2>
        <p> Хоча це не виглядае значно іншим від ініціалізації в C or C++,
          ініціалізація в Go є більш потужною. Складні структури можуть бути
          збудовані протягом ініціалізації, та питання порядку&nbsp;між
          ініціалізованими об’єктами, навіть між різними пакунками, обробляються
          коректно. </p>
        <h3 id="constants">Константи</h3>
        <p>Константи в Go є саме цим — константами. Вони створюються під час
          компіляції, навіть якщо визначені як локальні до функцій, та можуть
          бути тільки числами, символами (рунами), рядками або логічними.
          Завдяки обмеженням часу компіляції, вирази, що утворюють їх, мають
          бути сталими виразами, що можуть бути обчислені компілятором.
          Наприклад,&nbsp;<code>1&lt;&lt;3</code> є сталим виразом, тоді
          як&nbsp;<code>math.Sin(math.Pi/4)</code> ні, бо виклик функції
          до&nbsp;<code>math.Sin</code> має відбутися під час виконання. </p>
        <p>В Go перелік констант створюється з використанням переліку <code>iota</code>.
          Позаяк <code>iota</code> може бути частиною виразу та вирази можуть
          бути неявно повторюватися, є легким побудувати похідні набори даних. </p>
        <pre>type ByteSize float64

const (
    _           = iota <span class="comment">// ігноруємо перше значення, присвоюючи його пустому ідентифікатору</span>
    KB ByteSize = 1 &lt;&lt; (10 * iota)
    MB
    GB
    TB
    PB
    EB
    ZB
    YB
)</pre>
        <p> Спроможність приєднувати метод, такий як <code>String</code> до
          кожного визначеного користувачем типу, робить можливим для довільних
          значень форматувати самих себе автоматично для друку. Хоча ви більше
          побачите це відносно до структур, цей підхід також корисний для
          скалярних типів, таких, як типи с плаваючою комою на кшталт&nbsp;<code>ByteSize</code>.
        </p>
        <pre>func (b ByteSize) String() string {
    switch {
    case b &gt;= YB:
        return fmt.Sprintf("%.2fYB", b/YB)
    case b &gt;= ZB:
        return fmt.Sprintf("%.2fZB", b/ZB)
    case b &gt;= EB:
        return fmt.Sprintf("%.2fEB", b/EB)
    case b &gt;= PB:
        return fmt.Sprintf("%.2fPB", b/PB)
    case b &gt;= TB:
        return fmt.Sprintf("%.2fTB", b/TB)
    case b &gt;= GB:
        return fmt.Sprintf("%.2fGB", b/GB)
    case b &gt;= MB:
        return fmt.Sprintf("%.2fMB", b/MB)
    case b &gt;= KB:
        return fmt.Sprintf("%.2fKB", b/KB)
    }
    return fmt.Sprintf("%.2fB", b)
}</pre>
        <p> Вираз <code>YB</code> друкується як <code>1.00YB</code>, тоді як <code>ByteSize(1e13)</code>
          друкується як <code>9.09TB</code>. </p>
        <p> Використання <code>Sprintf</code> для реалізації методу <code>ByteSize</code>
          <code>String</code> є безпечним (не дає рекурсувати безкінечно) не
          завдяки перетворенню, але завдяки тому, що викликається <code>Sprintf</code>
          з <code>%f</code>, що не є форматом рядка: <code>Sprintf</code> буде
          викликати метод&nbsp;<code>String</code>, коли він бажає отримати
          рядок, та <code>%f</code> потребує значення з плаваючою комою. </p>
        <h3 id="variables">Змінні</h3>
        <p> Змінні можуть бути ініціалізовані таким же чином, як і константи,
          але ініціалізатором може бути загальний вираз, що обчислюється під час
          виконання. </p>
        <pre>var (
    home   = os.Getenv("HOME")
    user   = os.Getenv("USER")
    gopath = os.Getenv("GOPATH")
)
</pre>
        <h3 id="init">Функція init</h3>
        <p>Нарешті, кожний первинний файл може визначити свою власну
          функцію&nbsp;<code>init</code> для встановлення такого стану, якого
          він потребує. (Насправді, кожний файл може мати декілька функцій <code>init</code>).
          Та, нарешті, тут означає саме нарешті: <code>init</code> викликається
          після обчислення всіх декларацій змінних в пакунку, які з свого боку
          обчислюються після того, як всі імпортовані пакунки були
          ініціалізовані.&nbsp;</p>
        <p> Окрім ініціалізацій, що не можуть бути обчислені як декларації,
          загальне використання функцій&nbsp;<code>init</code> є перевірка або
          відновлення достовірності стану програми перед початком дійсного
          виконання програми. </p>
        <pre>func init() {
    if user == "" {
        log.Fatal("$USER not set")
    }
    if home == "" {
        home = "/home/" + user
    }
    if gopath == "" {
        gopath = home + "/go"
    }
    // gopath може бути переписаний через флаг --gopath в командному рядку.
    flag.StringVar(&amp;gopath, "gopath", gopath, "override default GOPATH")
}
</pre>
        <h2 id="methods">Методи</h2>
        <h3 id="pointers_vs_values">Вказівники vs. Значення</h3>
        <p>Як ми бачили з&nbsp;<code>ByteSize</code>, методи можуть бути
          визначені для любого іменованого типу (за винятком указівника або
          інтерфейсу); отримувач не має бути структурою. </p>
        <p>В дискусії про сегменти вище, ми написали функцію&nbsp;<code>Append</code>.
          Замість цього ми можемо визначити її як метод для сегментів. Щоб це
          зробити, спершу ми визначимо іметований тип, до якого ми зможемо
          приєднати метод, та потім зробити отримувача для методу значенням
          цього типу.</p>
        <pre>type ByteSlice []byte

func (slice ByteSlice) Append(data []byte) []byte {
    // Тіло точно таке як раніше
}
</pre>
        <p>Це як і раніше потребує щоб метод повертав оновлений сегмент. Ми
          можето уникнути ціх складностей, перевизначивши метод, щоб він
          сприймав <em>вказівник</em> на <code>ByteSlice</code>, на на свій
          приймач, і, таким чином, метод може переписати сегмент викликача.</p>
        <pre>func (p *ByteSlice) Append(data []byte) {
    slice := *p
    // тіло як і раніше, без виклику return.
    *p = slice
}
</pre>
        <p> Фактично, ми можемо зробити ще краще, якщо ми модифікуємо нашу
          функцію, так, щоб вона виглядала як стандартний метод&nbsp;<code>Write</code>,
          як це, </p>
        <pre>func (p *ByteSlice) Write(data []byte) (n int, err error) {
    slice := *p
    // Знову як і раніше.
    *p = slice
    return len(data), nil
}
</pre>
        <p> коли тип <code>*ByteSlice</code> задовільняє інтерфейсові&nbsp;<code>io.Writer</code>,
          що є зручним. Наприклад, ми можемо друкувати в сегмент. </p>
        <pre>    var b ByteSlice
    fmt.Fprintf(&amp;b, "This hour has %d days\n", 7)
</pre>
        <p>Ми передаємо адресу&nbsp;<code>ByteSlice</code>, оскільки&nbsp;
          тільки <code>*ByteSlice</code> задовільняє&nbsp; <code>io.Writer</code>.
          Правило щодо вказівників vs. значень для отримувачів полягає в тому,
          що методи можуть бути викликані на вказівниках та значеннях, але
          методи для вказівників можуть бути викликані тільки для вказівників. </p>
        <p> Це правило постає, оскільки вказівникові методи можуть модифікувати
          отримувача; виклик їх для значень може спричинити те, що метод отримає
          копію значення, і, таким чином, всі зміни буде відкинуто. Таким чином
          мова не дозволяє ці помилки. Однак є зручне виключення. Коли значення
          адресується, мова пілкується про загальний випадок виклику
          вказівникового методу на значенні, вставляючи оператор взяття адреси
          автоматично. В нашому випадку змінна&nbsp;<code>b</code> адресована,
          так що ми можемо викликати її метод <code>Write</code> за допомогою <code>b.Write</code>.
          Компілятор перезапише це як&nbsp;<code>(&amp;b).Write</code>за нас . </p>
        <p> До речі, ідея використання <code>Write</code> на сегменті байтів є
          центральною для реалізації <code>bytes.Buffer</code>. </p>
        <h2 id="interfaces_and_types">Інтерфейси та інші типи</h2>
        <h3 id="interfaces">Інтерфейси</h3>
        <p>Інтерфейси в Go провадять шлях для завдання поведінки об’єкту: якщо
          щось може робити <em>це</em>, тоді це може використовуватись <em>тут</em>.
          Ми вже бачили пару прикладів; саморобні друкарі можуть бути
          реалізовані методом <code>String, </code>тоді як <code>Fprintf</code>
          може генерувати вихід до будь-чого з методом&nbsp;<code>Write</code>.
          Інтерфейси з одним або двома методами є загальними в коді Go, і ми
          зазвичай отримуємо ім’я від методу, такого як <code>io.Writer</code>
          для чогось, що реалізує <code>Write</code>. </p>
        <p> Тип може реалізувати декілька інтерфейсів. Наприклад, набір може
          бути відсортовано процедурами в пакунку&nbsp;<code>sort,</code> якщо
          він реалізує <code>sort.Interface</code>, що містить <code>Len()</code>,
          <code>Less(i, j int) bool</code>, та <code>Swap(i, j int)</code>, та
          він також може мати свій форматувальник. І цьому прикладі <code>Sequence</code>
          задовільняє обом . </p>
        <pre>type Sequence []int

<span class="comment">// Методи на вимогу sort.Interface.</span>
func (s Sequence) Len() int {
    return len(s)
}
func (s Sequence) Less(i, j int) bool {
    return s[i] &lt; s[j]
}
func (s Sequence) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}

<span class="comment">// Метод для друку - сортує елементи для друку.</span>
func (s Sequence) String() string {
    sort.Sort(s)
    str := "["
    for i, elem := range s {
        if i &gt; 0 {
            str += " "
        }
        str += fmt.Sprint(elem)
    }
    return str + "]"
}</pre>
        <h3 id="conversions">Перетворення</h3>
        <p>Метод <code>String</code> з <code>Sequence</code> знови робить ту ж
          роботу, що <code>Sprint</code> вже робить для сегментів. Ми можемо
          розділити намагання, якщо ми перетворимо&nbsp;<code>Sequence</code> в
          простий <code>[]int</code> перед викликом <code>Sprint</code>. </p>
        <pre>func (s Sequence) String() string {
    sort.Sort(s)
    return fmt.Sprint([]int(s))
}
</pre>
        <p> Цей метод є іншим прикладом техніки перетворення для безпечного
          виклику&nbsp;<code>Sprintf</code> з методу <code>String</code>.
          Оскільки два типи (<code>Sequence</code> та <code>[]int</code>) є
          однаковими, якщо ми ігноруємо ім’я типу, є законним перетворення між
          ними. Перевторення не створює нове значення, воно лише тимчасово діє
          як якби старе значення мало новий тип. (Є і інші допустимі
          перетворення, такі як з цілого числа в число з плаваючою комою, що
          створюють нове значення).</p>
        <p>Це є ідеомою програм Go перетворювати тип виразу для отримання іншого
          набору методів. Як приклад ми можемо використовувати існуючий
          тип&nbsp;<code>sort.IntSlice</code> для зменшення цілого прикладу до
          цього: </p>
        <pre>type Sequence []int

// Метод для друку - сортує елементи перед друком
func (s Sequence) String() string {
    sort.IntSlice(s).Sort()
    return fmt.Sprint([]int(s))
}
</pre>
        <p> Тепер, замість примушувати <code>Sequence</code> реалізувати
          декілька інтерфейсів (сортування та друк), ми використовуємо здатність
          елемента даних бути перетвореним до декількох типів (<code>Sequence</code>,
          <code>sort.IntSlice</code> та <code>[]int</code>), кожний з яких
          робить свою частину роботи. Це досить незвично на практиці, але це
          може буть ефективним. </p>
        <h3 id="interface_conversions">Перетворення інтерфейсів та очікування
          типів</h3>
        <p> <a href="#type_switch">Перемикачі типів</a> є формою перетворення:
          вони беруть інтерфейс та, для кожного випадку в перемикачі намагаються
          конвертувати його до типу в даному випадку. Ось спрощена версія того,
          як код під <code>fmt.Printf</code> перетворює значення в рядок з
          використанням перемикачу типу. Якщо це вже рядок, ми бажаємо щоб
          дійсне значення рядка утримувалось в інтерфейсі, тоді як якщо він має
          метод <code>String</code>, ми бажаємо щоб результатом був цей метод.
        </p>
        <pre>type Stringer interface {
    String() string
}

var value interface{} // Значення, надане викликаючим.
switch str := value.(type) {
case string:
    return str
case Stringer:
    return str.String()
}
</pre>
        <p> Перший випадок шукає конкретне значення; другий перетворює інтерфейс
          в інший інтерфейс. Це цілковито гарно змішувати інтерфейси таким
          шляхом. </p>
        <p> Що, коли нас цікавить тільки один тип? Якщо ми знаємо, що значення
          утримує <code>string</code>, та ми тільки бажаємо виділити його?
          Перемикач з одним випадком зробить це, але також це може зробити <em>очікування
            типу</em>. Очікування типу бере значення інтерфейсу та виділяє з
          нього значення явно вказаного типу. Синтаксис позичений в
          відкриваючому реченні перемикача типу, але з явно вказаним типом, а не
          ключовим словом&nbsp;<code>type</code>: </p>
        <pre>value.(typeName)
</pre>
        <p> та результатом є нове значення зі статичним типом <code>typeName</code>.
          Цей тип може бути або конкретним типом, що утримується інтерфейсом,
          або другим типом інтерфейсу, до якого може бути приведене значення.
          Щоб виділити рядок, що ми знаємо є в значенні, ми можемо записати: </p>
        <pre>str := value.(string)
</pre>
        <p>Але якщо стане відомо, що значення не містить рядок, програма зазнає
          краху з помилкою часу виконання. Для захисту проти цього,
          використовуйте ідіому "крапка, ok" для безпечної перевірки, чи є
          значення рядком: </p>
        <pre>str, ok := value.(string)
if ok {
    fmt.Printf("значення рядка: %q\n", str)
} else {
    fmt.Printf("значення не є рядком\n")
}
</pre>
        <p>Якщо очікування типу не справдилось, <code>str</code> буде існувати
          як і раніше, та буде мати тип рядка, але вона буде мати нульове
          значення, пустий рядок. </p>
        <p> Як іллюстрація цієї можливості, ось твердження <code>if</code>-<code>else,</code>
          що еквівалентне до перемикача типу в початку ціього розділу. </p>
        <pre>if str, ok := value.(string); ok {
    return str
} else if str, ok := value.(Stringer); ok {
    return str.String()
}
</pre>
        <h3 id="generality">Загальність</h3>
        <p>Якщо тип існіє тільки для реалізації інтерфейсу, та не має
          експортованих методів за межами цього інтерфейсу, не має потреби
          експортувати ам тип. Експорт тільки інтерфейсу робить прозорим, що це
          і є важлива поведінка, не реалізація, та що інші реалізації з іншими
          властивостями можуть відзеркалювати поведінку оригінального типу. Це
          також запобігає потребі повторювти документацію по кожному екземпляру
          загального методу.</p>
        <p>В таким випадках констрктор має повертати значення інтерфейсу,
          скоріше, ніж реалізованого типу. Як приклад, в хеш таблицях обидва<code>crc32.NewIEEE</code>
          та <code>adler32.New</code> повертають тип інтерфейсу <code>hash.Hash32</code>.
          Заміщення алгоритма CRC-32 на Adler-32 в програмі Go потребує тільки
          зміни виклику конструктора; залишок кода не зазнає змін від зміни
          алгоритму. </p>
        <p> Схожий підхід дозволяє алгоритмам шифрування потоків в різних
          пакунках&nbsp;<code>crypto</code> бути відокремленими від блочних
          шифрів, що вони сціплюють разом. Інтерфейс <code>Block</code> в
          пакунку <code>crypto/cipher</code> вказує поведінку блочного шифру,
          що провадить шифрування окремого блоку даних. Після цього, по аналогії
          з пакунком&nbsp;<code>bufio</code>, пакунки шифрування, що реалізують
          цей інтерфейс, можуть бути застосовані для побудови потокових шифрів,
          представлених інтерфейсом&nbsp;<code>Stream</code>, без знання деталей
          блокового шифрування. </p>
        <p>Інтерфейси <code>crypto/cipher</code> виглядають на кшталт такого: </p>
        <pre>type Block interface {
    BlockSize() int
    Encrypt(src, dst []byte)
    Decrypt(src, dst []byte)
}

type Stream interface {
    XORKeyStream(dst, src []byte)
}
</pre>
        <p> Ось визначення потоку режиму підрахунку (CTR), який перетворює
          блоковий шифр в поточний шифр; зауважте, що деталі блокового шифру
          геть абстраговані: </p>
        <pre>// NewCTR повертає Stream що шифрує/дешифрує, використовуючи даний Block в режимі
// підрахунку. Довжина iv має бути такою ж, як і розір блоку Block.
func NewCTR(block Block, iv []byte) Stream
</pre>
        <p> <code>NewCTR</code> стосується не тільки до одного специфічного
          алгоритму шифрування та витоку даних, але до любої реалізації
          інтерфейсу&nbsp;<code>Block</code> та любого <code>Stream</code>.
          Оскільки вони повертають значення інтерфейсу, заміна шифрування CTR з
          другим режимом шуфрування є локалізованою зміною. Виклики конструктора
          мають бути відредаговані, але, оскільки оточующий код має трактувати
          результат тільки як&nbsp;<code>Stream</code>, він не замітить різниці.
        </p>
        <h3 id="interface_methods">Інтерфейси і методи</h3>
        <p>Оскільки майже все може мати приєднані методи, також майже все може
          задовільняти інтерфейсам. Один ілюстративний приклад є пакунок <code>http</code>,
          що визначає інтерфейс <code>Handler</code>. Кожний об’єкт, що
          реалізує&nbsp;<code>Handler</code>, може обслуговувати запити HTTP. </p>
        <pre>type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
</pre>
        <p> <code>ResponseWriter</code> сам по собі є інтерфейсом, що провадить
          доступ до методів, що потрібні для повертання відповіді клієнту. Ці
          методи включають стандартний метод&nbsp;<code>Write</code>, і тека
          інше, і таки чином <code>http.ResponseWriter</code> може бути
          використано будь-де, де може бути використаний&nbsp;<code>io.Writer</code>.
          <code>Request</code> є структурою, що містить розібраний вигляд запиту
          клієнта. </p>
        <p>Для краткості проігноруємо POST та уявимо, що запити HTTP
          завжди&nbsp; GET; це спрощення не впливає на шлях, як встановлюється
          обробники. Ось тривіальна, але повна реалізація обробки, до підраховує
          число разів, скільки відкривалася сторінка. </p>
        <pre>// Простий сервер підрахунку.
type Counter struct {
    n int
}

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ctr.n++
    fmt.Fprintf(w, "підраховано = %d\n", ctr.n)
}
</pre>
        <p> (Притримуючись нашої теми, зауважте, як&nbsp;<code>Fprintf</code>
          може друкувати в <code>http.ResponseWriter</code>.) Для посилання,
          ось як приєднати такий сервер до вузла в дереві URL. </p>
        <pre>import "net/http"
...
ctr := new(Counter)
http.Handle("/counter", ctr)
</pre>
        <p> але чому робити <code>Counter</code> структурою? Ціле це все, що
          потрібно. (Отримувач потребує бути вказівником, так що збільшення буде
          видно викликаючому).</p>
        <pre>// Спрощений сервер підрахунку.
type Counter int

func (ctr *Counter) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    *ctr++
    fmt.Fprintf(w, "підраховано = %d\n", *ctr)
}
</pre>
        <p>Що, якщо ваша програма буде мати деякий внутрішній стан, що потребує
          бути сповіщенним, коли сторінка відкривається? Прив’яжіть канал до
          сторінки. </p>
        <pre>// Канал, що надсилає сповіщення при кожному візиту.
// (Віногідно, канал не має бути буферизованим)
type Chan chan *http.Request

func (ch Chan) ServeHTTP(w http.ResponseWriter, req *http.Request) {
    ch &lt;- req
    fmt.Fprint(w, "notification sent")
}
</pre>
        <p> Нарешті, скажімо, ми бажаємо представити на <code>/args</code>
          аргументи, що використовуються для виклику двійникового коду серверу.
          Це просто, написати функцію для друку аргументів.&nbsp;</p>
        <pre>func ArgServer() {
    fmt.Println(os.Args)
}
</pre>
        <p> Як ми перетворимо це на HTTP сервер? Ми можемо зробити <code>ArgServer</code>
          методом деякого типу, чиє значення ми ігноруємо, але є чистіший шлях.
          Позаяк ми можемо визначити метод для любого типу, за винятку
          вказівників та інтерфейсів, ми можемо записати метод для функції.
          Пакунок&nbsp;<code>http</code> містить цей код: </p>
        <pre>// HandlerFunc тип є адаптером, щоб дозволити використання
// звичайних функцій як обробників HTTP. Якщо фукнція
// має відповідну сигнатуру, HandlerFunc(f) є об’єктом
// Handler , що викликає f.
type HandlerFunc func(ResponseWriter, *Request)

// ServeHTTP викликає f(c, req).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, req *Request) {
    f(w, req)
}
</pre>
        <p> <code>HandlerFunc</code> є типом з методом,&nbsp;<code>ServeHTTP</code>,
          що значення цього типу можуть обробляти HTTP запити. Подивіться на
          реалізацію цього методу: отримувач є функція,&nbsp;<code>f</code>, та
          метод викликає&nbsp;<code>f</code>. Це може виглядати дивним, але це
          не дуже відрізняється від, скажімо, того, щоб отримувачем був канал і
          метод надсилав в канал. </p>
        <p>Щоб перетворити <code>ArgServer</code> в HTTP сервер, ми спочатку
          модифікуємо його, якщо ми маємо відру сигнатуру. </p>
        <pre>// Ще один сервер.
func ArgServer(w http.ResponseWriter, req *http.Request) {
    fmt.Fprintln(w, os.Args)
}
</pre>
        <p> <code>ArgServer</code> тепер має ту ж сигнатуру, що і <code>HandlerFunc</code>,
          і таким чином він може бути перетворений в тип для доступу до методів,
          так само, як ми перетворили&nbsp;<code>Sequence</code> до <code>IntSlice</code>
          для доступу до <code>IntSlice.Sort</code>. Код для цього є вкрай
          стислим: </p>
        <pre>http.Handle("/args", http.HandlerFunc(ArgServer))
</pre>
        <p> Коли хтось заходить на сторінку <code>/args</code>, обробник,
          встановлений для цієї сторінки, має значення&nbsp;<code>ArgServer</code>
          та тип <code>HandlerFunc</code>. HTTP сервер буде викликати
          метод&nbsp;<code>ServeHTTP</code> для цього типу, з <code>ArgServer</code>
          в якості отримувача, що в свою чергу буде викликати <code>ArgServer</code>
          (через виклик <code>f(c, req)</code> з середини&nbsp; <code>HandlerFunc.ServeHTTP</code>).
          Після чого аргументи будуть відображені. </p>
        <p>В розділі ми робили HTTP сервер зі структури, цілого, каналу та
          функції, і все завдяки тому, що інтерфейси це лише набори методів, що
          можуть бути визначені для (майже) любого типу.&nbsp;</p>
        <h2 id="blank">Пустий ідентифікатор</h2>
        <p> Ми згадували пустий ідентифікатор вже пару разів, в контексті&nbsp;<a
            href="#for"><code>for</code> <code>range</code> циклів</a> та<a href="#maps">
            мап</a>. Пустий ідентифікатор може бути присвоєний або декларований
          для любого типу, щоб значення було відкинуте без перешкод. Це є трохи
          схожим на записуванняв файл Unix <code>/dev/null</code>: він
          представляє собою значення тільки для запису, що використовується як
          замісник, де потрібна змінна, але насправді значення не має значення.
          Він має використання і поза цім, ям ми вже бачили. </p>
        <h3 id="blank_assign">Пустий ідентифікатор в множинному присвоюванні</h3>
        <p> Ідея пустого ідентифікатору в циклі&nbsp;<code>for</code> <code>range</code>
          є особливим випадком загальнішої ситуації: множинного присвоювання. </p>
        <p>Якщо присвоєння потребує декількох значень з лівого боку, але одне зі
          значень не буде використовуватися в програмі, пустий ідентифікатор с
          лівої сторони присвоювання уникає необхідності створювати непотрібну
          змінну та ясно вказує на те, що значення буде відкинуте. Наприклад,
          коли викликається функція, що повертає значення та помилку, але тільки
          помилка має значення, використовуйте пустий ідентифікатор, щоб
          відкинути не маюче відношення значення. </p>
        <pre>if _, err := os.Stat(path); os.IsNotExist(err) {
	fmt.Printf("%s does not exist\n", path)
}
</pre>
        <p> Колись ви побачите код, що відкидає значення помилки, щоб ігнорувати
          помилку; це жахлива практика. Завжди перевіряйте повернуті помилки;
          вони створені вказувати на причину. </p>
        <pre>// Поганно! Цей код буде ламатись, якщо путь не існує.
fi, _ := os.Stat(path)
if fi.IsDir() {
    fmt.Printf("%s is a directory\n", path)
}
</pre>
        <h3 id="blank_unused">Невикористані імпорти на змінні</h3>
        <p>Є помилкою імпортувати пакунок або декларувати змінну без
          використання. Невикористані імпорти зающують програму та сповільнюють
          компіляцію, тодя як змінна, що ініціалізована, але не використана, є
          щонайменше змарене обчислення, та, можливо, вказує на гірший недолік.
          Коли програма знаходиться в стані активної розробки, одначе,
          невикористані імпорти та змінні часто виникають, та може виявитись
          нудним видаляти їх, тільки для того, щоб пройти компіляцію, та потім
          знову потребувати їх. Пустий ідентифікатор провадить кружний шлях.</p>
        <p> Ця напів написана програма має два невикористані імпорти (<code>fmt</code>
          та <code>io</code>) та невикористану змінну (<code>fd</code>), так що
          вона не буде компілюватися, та було б гарно побачити, що код працює
          вже на цьому етапі. </p>
        <pre>package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment">// TODO: використати fd.</span>
}</pre>
        <p> Щоб припинити скарги на невикористання імпортів, використовуйте
          пустий ідентифікатор для посилання на символ з імпортованого пакунку.
          Подібно, присвоюючи невикористану змінну&nbsp;<code>fd</code> пустому
          ідентифікатору приспить помилку невикористанної змінної. </p>
        <pre>package main

import (
    "fmt"
    "io"
    "log"
    "os"
)

var _ = fmt.Printf <span class="comment">// For debugging; delete when done.</span>
var _ io.Reader    <span class="comment">// For debugging; delete when done.</span>

func main() {
    fd, err := os.Open("test.go")
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment">// TODO: use fd.</span>
    _ = fd
}</pre>
        <p>За домовленістю, глобальні декларації для заглушення помилок імпорту
          повинні слідувати прямо за імпортами та бути коментовані, щоб їх було
          просто знайти та як нагадування, щоб підчистити їх потім. </p>
        <h3 id="blank_import">Імпорт та побічні ефекти</h3>
        <p> Невикористаний імпорт як <code>fmt</code> або <code>io</code> в
          попередпьому прикладі, будуть з часом або використані, або видалені:
          пусті присвоєння ідентифікують що роботу не скінчено. Але іноді
          корисно імпортувати пакунок тільки для побічних ефектів, без жодного
          явного використання. Наприклад, протягом їх <code>init</code>
          функцій, пакунок <code><a href="/pkg/net/http/pprof/">net/http/pprof</a></code>
          регіструє обробники HTTP, що провадить відладочну інформацію. Це має
          експортовані API, але більшість клієнтів потребує тільки реєстрацію
          обробника, та отримують дані через веб сторінку. Щоб імпортувати
          пакунок тільки заради їх побічних ефектів, переіменуйте пакунок в
          пустий ідентифікатор: </p>
        <pre>import _ "net/http/pprof"
</pre>
        <p> Ця форма імпорту робить зрозумілим, що цей пакунок був імпортований
          лише заради побічних ефектів, оскільки немає інших можливих шляхів
          використання цього пакунку: в цьому файлі він не має імені. (Якщо він
          мав, і ми не використали це ім’я, компілятор буде відхиляти саму
          програму).</p>
        <h3 id="blank_implements">Перевірка інтерфейсу</h3>
        <p> Як ми бачили в дискусії про <a href="#interfaces_and_types">інтерфейси</a>
          вище, тип не має відкрито декларувати, що він реалізує інтерфейс.
          Замість цього, тип реалізує інтерфейс тільки реалізуючи методи
          інтерфейсу. На практиці, більшість перетворень інтерфейсів є
          статичними, і, таким чином, перевіряються на етапі компіляції.
          Наприклад, передаючи <code>*os.File</code> до функції, що очікує <code>io.Reader</code>,
          не буде компілюватися, якщо&nbsp;<code>*os.File</code> не реалізує
          інтерфейс&nbsp; <code>io.Reader</code>. </p>
        <p>Однак деякі перевірки інтерфейсу виконуються і під час виконання.
          Один такий випадок є пакунок <code><a href="/pkg/encoding/json/">encoding/json</a></code>,
          що визначає інтерфейс <code><a href="/pkg/encoding/json/#Marshaler">Marshaler</a></code>.
          Коли кодувальник JSON отримує значення, що реалізує інтерфейс,
          кодувальник викликає метод маршалінгу для перетворення його на JSON,
          замість виконання стандартного перетворення. Кодувальник перевіряє цю
          властивість під час виконання за допомогою <a href="#interface_conversions">очікування
            типу</a>: </p>
        <pre>m, ok := val.(json.Marshaler)
</pre>
        <p>Якщо це треба лише для запиту, чи тип реалізує інтерфейс, без
          дійсного використання інтерфейсу, можливо як частина перевірки
          помилок, використовуйте пустий ідентифікатор для ігнорування значення
          очікування типу: </p>
        <pre>if _, ok := val.(json.Marshaler); ok {
    fmt.Printf("value %v of type %T implements json.Marshaler\n", val, val)
}
</pre>
        <p> Одне місце, де виникає ця ситуація, це коли потрібно гарантувати в
          пакунку, що реалізує тип, що він дійсно задовольняє інтерфейсу. Якщо
          тип&nbsp; — наприклад, <code><a href="/pkg/encoding/json/#RawMessage">json.RawMessage</a></code>
          — потребує власної репрезентації JSON, він має реалізувати <code>json.Marshaler</code>,
          але немає статичного перетворенн, що може примусити компілятор
          перевірити це автоматично. Якщо тип несподівано схибить, не
          відповідаючи інтерфейсу, кодувальник JSON буде як і раніше робити, але
          не буде використовувати власну реалізацію. Щоб гарантувати те, що
          реалізація коректна, може використовуваться глобальна декларація з
          використанням пустого ідентифікатору: </p>
        <pre>var _ json.Marshaler = (*RawMessage)(nil)
</pre>
        <p>В цій декларації присвоювання включає перетворення <code>*RawMessage</code>
          до&nbsp;<code>Marshaler,</code> що потребує, щоб <code>*RawMessage</code>
          реалізував <code>Marshaler</code>, та ця властивість буде перевірена
          під час компіляції. Якщо інтерфейс<span style="font-family: monospace;">
          </span><code>json.Marshaler</code> зміниться, цей пакунок більше не
          буде компілюватись, і це буде нам сигналом, що треба оновлюватись.</p>
        <p> Поява пустого ідентифікатора в цій конструкції є сигналом, що
          декларація існує лише для перевірки типу, не для створення змінної.
          Однак не робіть цього для кожного типу, що задовільняє інтерфейсу. По
          домовленості такі декларації використовуються тільки коли немає
          статичних перетворень, що є в коді, що є рідким випадком. </p>
        <h2 id="embedding">Вбудовування</h2>
        <p> Go не надає типового, базованого на типах, запису для підклассів,
          але він надає можливість "позичати" частини реалізації шляхом <em>вбудування</em>
          типів в структуру або інтерфейс. </p>
        <p> Вбудовування інтерфейсів дуже просте. Ми вже згадували
          інтерфейи&nbsp;<code>io.Reader</code> та <code>io.Writer</code>; ось
          їх визначення. </p>
        <pre>type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}
</pre>
        <p> Пакунок <code>io</code> також експортує декілька інших інтерфейсів,
          що задають об’єкти, що можуть реалізувати декілька таких методів.
          Наприклад, є&nbsp;<code>io.ReadWriter</code>, інтерфейс, що містить
          обоє,&nbsp;<code>Read</code> та <code>Write</code>. Ми можемо
          задати&nbsp;<code>io.ReadWriter</code> через перелік двох методів
          явно, але легше та більш доцільно вбудувати два інтерфейси, щоб
          утворити новий, таким чином: </p>
        <pre>// ReadWriter є інтерфейсом, що комбінує інтерфейси Reader та Writer.
type ReadWriter interface {
    Reader
    Writer
}
</pre>
        <p> Це каже саме те, на що виглядає: <code>ReadWriter</code> може
          робити те, що робить <code>Reader</code> та що робить <code>Writer</code>;
          це об’єднання вбудованих інтерфейсів (що мають бути неперетинаючими
          наборами методів). Тільки інтерфейси можуть бути вбудованими в
          інтерфейси. </p>
        <p> Та ж базова ідея стосується структур, але з більше далеко-йдучими
          наслідками. Пакунок <code>bufio</code> має два структурні типа, <code>bufio.Reader</code>
          та <code>bufio.Writer</code>, кожний з яких, зрозуміло, реалізує
          аналогічні інтерфейси з пакунку&nbsp;<code>io</code>. Та <code>bufio</code>
          також реалізує буферизований ввод-вивод, що робиться за допомогою
          комбінування читача та письменника в одну структуру з використанням
          вбудовування: він перелічує типи в структурі, але не дає їм імен
          полів. </p>
        <pre>// ReadWriter зберігає вказівники на Reader та Writer.
// Він реалізує io.ReadWriter.
type ReadWriter struct {
    *Reader  // *bufio.Reader
    *Writer  // *bufio.Writer
}
</pre>
        <p>Вбудовані елементи є вказівниками на структури, та, зрозуміло, мають
          бути ініціалізованими на часі в дієві структури перед тим, як зможуть
          бути використані. Структура&nbsp;<code>ReadWriter</code> може бути
          записана як&nbsp; </p>
        <pre>type ReadWriter struct {
    reader *Reader
    writer *Writer
}
</pre>
        <p> але після цього щоб продвинути методи полів та задовільнити
          інтерфейсам&nbsp; <code>io</code>, нам також знадобиться впровадити
          методи пересилання, на зразок таких: </p>
        <pre>func (rw *ReadWriter) Read(p []byte) (n int, err error) {
    return rw.reader.Read(p)
}
</pre>
        <p> Вбудовуючи структури напряму, ми уникаємо цієї бухгалтерії. Методи
          вбудований типів доступні безкоштовно, що ознчає, що&nbsp;<code>bufio.ReadWriter</code>
          не тільки має методи <code>bufio.Reader</code> та <code>bufio.Writer</code>,
          він також задовільняє всі трьом інтерфейсам: <code>io.Reader</code>,
          <code>io.Writer</code> та <code>io.ReadWriter</code>. </p>
        <p> Це важливий спосіб, яким вбудовування відрізняється від створення
          підклассів. Коли ми вбудовуємо тип, методи цього типу стають методами
          зовнішнього типу, але коли вони викликаються отримувачем є метод
          внутрішнього типу, не зовнішнього. В нашому прикладі, коли
          викликається метод&nbsp;<code>Read</code> з <code>bufio.ReadWriter</code>,
          це має точно той же ефект, що і пересилання методу, що існує зовні;
          отримувачем є поле&nbsp;<code>reader</code> з <code>ReadWriter</code>,
          не сам&nbsp; <code>ReadWriter</code>. </p>
        <p> Вбудовування може також бути просто зручним. Цей приклад показує
          вбудоване поле поряд зі звичайним, іменованим полем. </p>
        <pre>type Job struct {
    Command string
    *log.Logger
}
</pre>
        <p> Тип <code>Job</code> тепер має <code>Log</code>, <code>Logf</code>
          та інші методи з <code>*log.Logger</code>. Ми можемо надати додаткове
          ім’я полю <code>Logger</code>, звичайно, але ми не маємо це робити.
          Але тепер, коли вже ініціалізовано, ми можемо писати в журнал
          через&nbsp;<code>Job</code>: </p>
        <pre>job.Log("starting now...")
</pre>
        <p><code>Logger</code> є звичайним полем структури <code>Job</code>,
          так що ми можемо ініціалізувати його звичайним шляхом в
          конструкторі&nbsp;<code>Job</code>, як тут, </p>
        <pre>func NewJob(command string, logger *log.Logger) *Job {
    return &amp;Job{command, logger}
}
</pre>
        <p> або через композитний літерал, </p>
        <pre>job := &amp;Job{command, log.New(os.Stderr, "Job: ", log.Ldate)}
</pre>
        <p> Якщо ми потребуємо посилатись на вбудоване поле напряму, ім’я типу
          поля, ігноруючи кваліфікатор пакунку, виступає як ім’я поля, як це
          зроблено в методі&nbsp;<code>Read</code> нашої структури&nbsp;<code>ReaderWriter</code>.
          Тут, якщо нам треба дістатися до <code>*log.Logger</code> змінної <code>Job</code>
          <code>job</code>, ми маємо писати <code>job.Logger</code>, що може
          бути корисним, якщо ми бажаємо покращити методи&nbsp;<code>Logger</code>.
        </p>
        <pre>func (job *Job) Logf(format string, args ...interface{}) {
    job.Logger.Logf("%q: %s", job.Command, fmt.Sprintf(format, args...))
}
</pre>
        <p>Вбудовані типи привносять проблему конфлікту імен, але правила їх
          розв’язання є простими. Спершу, поле або метод <code>X</code>
          перекриває любі інші&nbsp;<code>X</code> на більш глибоких рівнях
          вкладеності цього типу. Якщо <code>log.Logger</code> містить поле або
          метод з назвами , поле <code>Command</code> з <code>Job</code> буде
          домінувати . </p>
        <p> Друге, якщо те ж ім’я з’являється на тому ж рівні вкладеності,
          зазвичай це помилка; це буде помилковим вбудовувати <code>log.Logger</code>,
          якщо структура&nbsp;<code>Job</code> містить інше поле або метод з
          назвою&nbsp;<code>Logger</code>. Одначе, якщо продубльоване ім’я
          ніколи не з’являється в програмі за межами визначення типу, це буде
          OK. Ця кваліфікація надає деякий захист проти змін, зроблених до
          вбудованих типів зовні; не буде проблемою, якщо додається поле. що
          конфліктує з іншим полем в іншому підтипі, якщо жодне поле ніколи не
          використовується. </p>
        <h2 id="concurrency">Конкурентне виконання</h2>
        <h3 id="sharing">Розділ через спілкування</h3>
        <p>Конкурентне програмування є великою темою і тут є місце тільки для
          деякіх уточнень щодо специфіки Go. </p>
        <p>Конкурентне прогрумування в багатьох оточеннях є складним завдяки
          деталям, що потрібні для забезпечення коректного одночасного доступу
          до загальних змінних. Go заохочує до іншого підходу, коли роздільні
          змінні передаються по каналах, та, фактично, ніколи активно не
          розділяються різними потоками виконання. Тільки одна goroutine має
          доступ до значення в даний момент часу. Гонки даних не можуть
          виникнути за визначенням. Щоб заохотити цей спосіб мислення, ми вклали
          його в слоган: </p>
        <blockquote>Не спілкуйтесь розділюючи пам’ять; замість цього, розділюйте
          пам’ять через спілкування. </blockquote>
        <p>Цей підхід може завести дуже далеко. Підрахунок посилань може бути
          краще зроблений через передачу мьютексу як цілої змінною, наприклад.
          Але для високорівневого підходу використання каналів для контролю
          доступу робить простішим написання ясних та коректних програм. </p>
        <p> Одним з шляхів думати про цю модель, це уявити типову однопоточну
          програму, що робить на одному процесорі. Вона не потребує примітивів
          синхронізації. Теперь виконайте інший екземпляр; він теж не потребує
          синхронізації. Теперь дозвольте ім спілкуватися; якщо спілкування
          синхронізоване, то все ще немає потреби в синхронізації. Труби Unix,
          наприклад, чудово вкладаються в цю модель. Хоча підхід Go до
          конкуренції має витоки в Hoare's Communicating Sequential Processes
          (CSP), він може також розглядатись як безпечне до типів узагальнення
          труб Unix. </p>
        <h3 id="goroutines">Goroutine</h3>
        <p>Вони називаються <em>goroutine</em>, оскільки існуючи терміни —
          потоки, ко-процедури, процеси, і таке інше&nbsp; — створюють неточні
          побічні уявлення. Goroutine має просту модель: це функція, що
          конкурентно виконується з іншими такими ж goroutine в тому ж адресному
          просторі. Вони легковажні, та коштують трохи більше, ніж роміщення
          простору в стеку. Та і стек починається з малого, так що вони дешеві,
          та зростають, розміщуючи (та звільняючи) хранилище з кучі по мірі
          необхідності.</p>
        <p> Goroutine мультіплексовані в багатьох потоках OS, так що коли одній
          треба заблокуватися, напрклад в очікуванні вводу-виводу, інші
          продовжують працювати. Їх дизайн приховує багато зі складностей
          створення та управління потоками.</p>
        <p> Вставьте перед функцією або методом префікс&nbsp; <code>go</code>
          щоб запустити виклик в новії goroutine. Коли виклик завершиться,
          goroutine виходить, тихо. (Ефект подібний до нотації оболонки
          Unix-нотації <code>&amp;</code> для запуску команди в фоні). </p>
        <pre>go list.Sort()  // виконує list.Sort конкурентно; не чекаємо її.
</pre>
        <p>Літерал функції може трапитися в нагоді при виклику goroutine. </p>
        <pre>func Announce(message string, delay time.Duration) {
    go func() {
        time.Sleep(delay)
        fmt.Println(message)
    }()  // Зауважте дужки - маємо викликати функцію.
}
</pre>
        <p> В Go функціональні літерали є замиканнями: реалізація надає
          впевненість, що змінні, на які є посилання в функції, будуть доступні,
          доки вони активні. </p>
        <p>Ці приклади не є дуже корисними, оскільки функції не мають шляху
          сигналізувати про своє завершення. Для цього потрібні канали. </p>
        <h3 id="channels">Канали</h3>
        <p>Подібно до мап, канали розміщуються за допомогою <code>make</code>,
          та отримане значення служить як посилання на підлягаючу структуру
          даних. Якщо надається додатковий цілий параметр, він встановлює розмір
          буферу для каналу. По замовчанню це нуль, для створення
          небуферизованого або синхронного каналу.&nbsp; </p>
        <pre>ci := make(chan int)            // небуферизований канал цілих
cj := make(chan int, 0)         // небуферизований канал цілих
cs := make(chan *os.File, 100)  // буферизований канал вказівників на файли
</pre>
        <p>Небуферизовані канали комбінують комунікацію — обмін значеннями — з
          синхронізацією — гарантією, що два обчислювання (goroutine) є в
          відомому стані. </p>
        <p>Є безліч гарних ідіом з використанням каналів. Ось один, щоб з чогось
          почати. В попередньому розділі ми стартували сортирування в фоні.
          Канал може дозволити запуск goroutine для очікування завершення
          сортування. </p>
        <pre>c := make(chan int)  // Розмістити канал.
// Запустить сортування в goroutine; коли вона скінчиться - сигналізувати в канал.
go func() {
    list.Sort()
    c &lt;- 1  // Відіслати сигнал; значення не має значення (с).
}()
doSomethingForAWhile()
&lt;-c   // Очікувати завершення сортування; отримане значення відкінути.
</pre>
        <p> Отримувачі завжди блокуються до того, як отримають дані. Якщо канал
          не буферизований, відсилач блокується до тих пір, доки отримувач не
          отримає значення. Якщо канал має буфер, відсилач блокується тільки до
          часу, доки значення не скопіюється в буфер; якщо буфер заповнено, це
          означає очікування, доки отримувач не отримає звідти значення. </p>
        <p> Буферизований канал може використовуватися як семафор, наприклад щоб
          обмежити пропускну здібність. В цьому прикладі входящі запроси
          передаються до&nbsp;<code>handle</code>, що надсилає значення в канал,
          обробляє відповідь, та потім отримує значення з каналу щоб зробити
          семафор "готовим" для нового користувача. Місткість буферу канала
          обмежує число одночасних викликів <code>process</code>. </p>
        <pre>var sem = make(chan int, MaxOutstanding)

func handle(r *Request) {
    sem &lt;- 1    // Очікувати спустошення активної черги.
    process(r)  // Може зайняти довгий час.
    &lt;-sem       // Є; дозволити запуск наступного запиту.
}

func Serve(queue chan *Request) {
    for {
        req := &lt;-queue
        go handle(req)  // Не чекати завершення обробки.
    }
}
</pre>
        <p> Як тільки обробники <code>MaxOutstanding</code> виконають <code>process</code>,
          інші будуть блокуватись, намагаючись надіслати в заповнений буфер
          каналу, до тих пір, як один з існуючих обробників завершить та надішле
          з буфера. </p>
        <p> Цей підхід має ваду, подивіться: <code>Serve</code> створює новий
          goroutine для кожного вхідного запиту, навіть якщо тільки&nbsp;<code>MaxOutstanding</code>
          з них можуть працювати одночасно. Як результат програма може спожити
          безмежні ресурси, якщо запроси будуть надходити дуже швидко. Ми можемо
          адресувати цю недолугість, змінюючи&nbsp; <code>Serve</code>, щоб
          відбувалась помірне створення goroutine. Ось очевидне рішення, еле
          начувайтесь, воно має ваду, що ми виправимо пізніше: </p>
        <pre>func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func() {
            process(req) // Негарно; дивіться пояснення нижче.
            &lt;-sem
        }()
    }
}</pre>
        <p> Помилка в циклі Go <code>for</code>, де змінна циклу повторно
          використовується для кожної ітерації, так що змінна <code>req</code>
          розділяється між goroutine. Це не те, чого ми бажаємо. Нам треба бути
          впевненими, що <code>req</code> є унікальною для goroutine. Ось шлях
          це зробити, передаючи значення&nbsp;<code>req</code> як аргумент в
          замикання в goroutine: </p>
        <pre>func Serve(queue chan *Request) {
    for req := range queue {
        sem &lt;- 1
        go func(req *Request) {
            process(req)
            &lt;-sem
        }(req)
    }
}</pre>
        <p>Порівняйте цю версію з попередньою, щоб побачити різницю в тому, як
          замикання декларується та виконується. Інше рішення в простому
          створенні нової змінної з тим же ім’ям, як в наступному прикладі: </p>
        <pre>func Serve(queue chan *Request) {
    for req := range queue {
        req := req // Створити новий екземпляр req для goroutine.
        sem &lt;- 1
        go func() {
            process(req)
            &lt;-sem
        }()
    }
}</pre>
        <p> Може здаватися марним записувати наступне</p>
        <pre>req := req
</pre>
        <p>але робити це законно та ідіоматично для Go. Ви отримуєте свіжу
          версію змінної з тим же ім’ям, навмисне затінюючи змінну циклу, але
          унікальну для кожної goroutine. </p>
        <p> Повертаючись до головної проблеми напиання серверу, інший підхід до
          доброго управління ресурсами є запуск сталої кількості&nbsp;<code>handle</code>
          goroutine, і щоб всі читали з каналу запросів. Число goroutine обмежує
          число одночасних викликів&nbsp;<code>process</code>. Ця Функція&nbsp;<code>Serve</code>
          також приймає канал, в який буде повідомлятися про вихід; після
          запуску декількох goroutine сервер блокується до отримання з каналу. </p>
        <pre>func handle(queue chan *Request) {
    for r := range queue {
        process(r)
    }
}

func Serve(clientRequests chan *Request, quit chan bool) {
    // Запуск обробників
    for i := 0; i &lt; MaxOutstanding; i++ {
        go handle(clientRequests)
    }
    &lt;-quit  // Очікувати команди на вихід.
}
</pre>
        <h3 id="chan_of_chan">Канали каналів</h3>
        <p>Однією з найбільш важливих властивостей Go є те, що канал є
          першокласним значенням, що може бути розміщеним та переданим
          будь-куди, як любе інше. Загальне використання цієї властивості є
          реалізація беспечної паралельної демультіплекції. </p>
        <p>В прикладі в попередньому розділі <code>handle</code> було
          ініціалізовано посиланням для запросів, та не було визначено типу, що
          він обслуговуватиме. Якщо тип включає канал, по якому відповідати,
          кожний клієнт може провадити власний шлях для відповіді. Ось
          схематичне визначення типу <code>Request</code>. </p>
        <pre>type Request struct {
    args        []int
    f           func([]int) int
    resultChan  chan int
}
</pre>
        <p>Клієнт надає функцію та її аргументи, а також канал, в самому об’єкті
          запиту, по якому він очікує відповідь. </p>
        <pre>func sum(a []int) (s int) {
    for _, v := range a {
        s += v
    }
    return
}

request := &amp;Request{[]int{3, 4, 5}, sum, make(chan int)}
// Надіслати запрос
clientRequests &lt;- request
// Очікувати відповідь.
fmt.Printf("answer: %d\n", &lt;-request.resultChan)
</pre>
        <p>На стороні сервера функція обробки є єдиною річчю, що змінюється. </p>
        <pre>func handle(queue chan *Request) {
    for req := range queue {
        req.resultChan &lt;- req.f(req.args)
    }
}
</pre>
        <p>Звісно є багато чого, що треба змінити, щоб зробити це реалістичним,
          але цей код є конструкцією для обмеженою за полосою, паралельною та
          неблокуючою RPC системою, і тут немає жодних мьютексів на горизонті. </p>
        <h3 id="parallel">Паралелізація</h3>
        <p>Другим застосуванням ціх ідей є паралелізація обчислень між
          декількома процесорними ядрами. Якщо обчислення може бути поділене на
          декілька частин, що можуть виконуватись окремо, вони можуть
          паралезуватись, з використанням каналу для сигналізації, коли кожна
          частина добігає кінця.</p>
        <p> Скажімо, ми маємо коштовну операцію, що застосовується до вектору
          елементів, та значення для кожної операції є незалежним, як в цьому
          ідеалізованому прикладі. </p>
        <pre>type Vector []float64

// Застосувати операцію до v[i], v[i+1] ... до v[n-1].
func (v Vector) DoSome(i, n int, u Vector, c chan int) {
    for ; i &lt; n; i++ {
        v[i] += u.Op(v[i])
    }
    c &lt;- 1    // сигналізувати, що ця частина виконана
}
</pre>
        <p> Ми запускаємо кожну частину окремо в циклі, один для кожного
          процесора. Вони можуть завершитися в довільному порядку, але це не має
          значення; ми тільки підраховуємо сигнали завершення, спустошуючи канал
          після запуску всіх goroutine. </p>
        <pre>const NCPU = 4  // кількість ядер CPU

func (v Vector) DoAll(u Vector) {
    c := make(chan int, NCPU)  // Буферизація необов’язкова, але чутлива.
    for i := 0; i &lt; NCPU; i++ {
        go v.DoSome(i*len(v)/NCPU, (i+1)*len(v)/NCPU, u, c)
    }
    // Спустошеня каналу.
    for i := 0; i &lt; NCPU; i++ {
        &lt;-c    // очікування завершення одного завдання
    }
    // Є.
}

</pre>
        <p>Поточна реалізація середи виконання Go не буде паралелізувати цей код
          по замовчанню. Вона виділяє лише одне ядро для обчислень на рівні
          користувача. Довільне число goroutine можуть бути блоковані в
          системних викликах, але по замовчанню тільки одне може обчислювати код
          на рівні користувача в даний час. Це повинне бути розумнішим, і одного
          дня це буде розумнішим, але до цього дня, якщо ви бажаєте паралелізм
          на рівні CPU, ви повинні сповістити середовищу виконання, скільки
          goroutine ви бажаєте виконувати через ваш код. Є два споріднені
          способи зробити це. Кожний виконує ваше завдання зі змінною
          середовища&nbsp;<code>GOMAXPROCS</code>, встановленою в число ядер до
          використання, або імпортує пакунок <code>runtime</code> та викликає <code>runtime.GOMAXPROCS(NCPU)</code>.
          Корисним може виявитись значення <code>runtime.NumCPU()</code>, що
          доповідає кількість логічних CPUs на локальній машині. Знову ж, ця
          вимога очікує своєї відставки з покращенням планування та середовища
          часу виконання. </p>
        <p> Впевніться, що не плутаєтесь в&nbsp; ідеях одночасного виконання,
          структуруванням програми як незалежно виконуваних компонент, та
          паралелізмом, виконанням обчислень паралельно для ефективного
          використання декількох процесорів. Хоча можливості конкуренціі в Go
          можуть спричинити структурування деякіх проблем як паралельних
          обчислень, Go є конкурентною мовою, не паралельною, та не всі проблеми
          паралелізму пасують до моделі Go. Для обговорення різниці ознайомтеся
          з&nbsp;<a href="//blog.golang.org/2013/01/concurrency-is-not-parallelism.html">цім
            блоговим повідомленням</a>. </p>
        <h3 id="leaky_buffer">Протікаючий буфер</h3>
        <p>Інструменти для конкурентного програмування можуть навіть зробити
          неконкурентні ідеї простішими для вираження. Ось приклад, що
          виокремлений з пакунку RPC. Клієнтська&nbsp; goroutine в циклі отримує
          дані з деякого джерела, можливо з мережі. Щоб запобігти розміщенню та
          вивільненню буферів, вона тримає вільний список, і використовує
          буферізований канал, щоб представляти його. Якщо канал пустий, новий
          буфер стає розміщеним. Коли буфер повідомлень готовий, посилається до
          сервера&nbsp;<code>serverChan</code>. </p>
        <pre>var freeList = make(chan *Buffer, 100)
var serverChan = make(chan *Buffer)

func client() {
    for {
        var b *Buffer
        // Захопити буфер коли є доступний, розташувати якщо ні.
        select {
        case b = &lt;-freeList:
            // Отримав, більше нічого робить.
        default:
            // Немає вільних, розміщую новий.
            b = new(Buffer)
        }
        load(b)              // Читати наступне повідомлення з мережі.
        serverChan &lt;- b      // Надіслати на сервер.
    }
}
</pre>
        <p>Серверний цикл отримує кожне повідомлення від клієнта, обробляє його
          та повертає буфер в список пустих. </p>
        <pre>func server() {
    for {
        b := &lt;-serverChan    // Очікую роботи.
        process(b)
        // Використати буфер, якщо є місце.
        select {
        case freeList &lt;- b:
            // Буфер в списку вільних, більше нічого робити.
        default:
            // Список пустих повний, тільки відкинути.
        }
    }
}
</pre>
        <p>Клієнт намагається отримати буфер з <code>freeList</code>; якщо
          нічого немає, він розміщує новий. Сервер посилає до&nbsp; <code>freeList</code>
          і повертає <code>b</code> знову в список вільних, якщо список не
          повний. В останньому випадку буфер відкидається в пул для подальшого
          прибирання збирачем сміття. (Випадки <code>default</code> в
          конструкції <code>select</code> виконуються, коли жодний з інших
          варіантів не готовий, що означає, що&nbsp;<code>select</code> ніколи
          не блокується.) Це реалізація будує список вільних типу протікаюче
          відро тільки за декілька рядків, покладаючись на буферизований канал
          та збирач сміття для ведення справ. </p>
        <h2 id="errors">Помилки</h2>
        <p>Бібліотечні процедури мають часто повертати деякий сорт вказівок на
          помилку до викликаючої сторони. Як зазначалося раніше, багатозначні
          результати Go роблять це простим повернути детальний опис помилки,
          разом з нормальним значенням. Є добрим стилем користатися цією
          можливістю для провадження детальної інформації щодо помилок.
          Наприклад, як ми побачимо,&nbsp;<code>os.Open</code> не тільки
          повертає вказівник <code>nil</code> в разі збою, він також повертає
          значення помилки, що описує що пішло хибно. </p>
        <p> По домовленості помилки мають тип <code>error</code>, простий
          вбудований інтерфейс. </p>
        <pre>type error interface {
    Error() string
}
</pre>
        <p> Створювач бібліотеки вільний реалізувати цей інтерфейс за багатшою
          моделлю, роблячи можливим не тільки отримати помилки, але й також
          впровадити деякий контекст. Як зазначено, поряд з звичайним
          типом&nbsp;<code>*os.File</code>, <code>os.Open</code> також повертає
          значення помилки. Якщо файл відкритий успішно, помилка буде&nbsp;<code>nil</code>,
          але якщо виникне проблема, там буде міститися&nbsp;<code>os.PathError</code>:
        </p>
        <pre>// PathError записує помилку та операцію, а також шлях файлу, що її викликав
type PathError struct {
    Op string    // "open", "unlink", etc.
    Path string  // Асоційований файл.
    Err error    // Повертається системним викликом.
}

func (e *PathError) Error() string {
    return e.Op + " " + e.Path + ": " + e.Err.Error()
}
</pre>
        <p> <code>PathError</code>'s <code>Error</code> генерує рядки на
          кшталт такого: </p>
        <pre>open /etc/passwx: no such file or directory
</pre>
        <p> Така помилка, що включає проблематичний файловий шлях, операцію, і
          помилку операційної системи, що виникла, є корисною, навіть якщо
          викликається далеко від виклику, що спричинив її; вона значно більше
          інформативна, ніж плаский "no such file or directory". </p>
        <p>Коли можливо, рядки помилок повинні ідентифікувати своє походження,
          таке як мати префіксне іменування&nbsp; з операцією або пакунком, що
          згенерували помилку. Наприклад,&nbsp; в пакунку <code>image</code>
          рядок що представляє помилку декодування через невідомий формат вказує
          пакунок "image: unknown format". </p>
        <p>Викликаюча сторона, що турбується через точні деталі помилки, можуть
          використовувати перемикач або очікування типу, щоб подивитись на
          специфічні помилки та отримати деталі. Для&nbsp;<code>PathErrors</code>
          це може включати перевірку внутрішнього поля <code>Err</code> в
          пошуках можливого відновлення після збою. </p>
        <pre>for try := 0; try &lt; 2; try++ {
    file, err = os.Create(filename)
    if err == nil {
        return
    }
    if e, ok := err.(*os.PathError); ok &amp;&amp; e.Err == syscall.ENOSPC {
        deleteTempFiles()  // Викроюємо трохи місця.
        continue
    }
    return
}
</pre>
        <p> Друге твердження&nbsp;<code>if</code> є іншим <a href="#interface_conversions">очікуванням
            типу</a>. Якщо він не спрацює, <code>ok</code> стане невірним і <code>e</code>
          буде <code>nil</code>. Якщо він спрауює, <code>ok</code> буде true,
          що означає, що помилка була типу&nbsp;<code>*os.PathError</code>, і
          також і <code>e</code>, і що ми можемо дослідити подальшу інформацію
          щодо помилки. </p>
        <h3 id="panic">Паніка</h3>
        <p>Звичайний шлях доповіді про помилку викликаючій стороні є
          повертання&nbsp;<code>error</code> в якості додаткового зворотнього
          значення. Канонічний метод&nbsp;<code>Read</code> є гарно-відомим
          взірцем; він повертає підрахунок байтів та <code>error</code>. Але
          що, коли помилка є невиправною? Іноді програма просто не в змозі
          продовжувати роботу. </p>
        <p> Для ціх цілей є вбудована функція&nbsp;<code>panic,</code> що
          ефективно створює помилку часу виконання, яка зупиняє програму (або
          дивіться наступний розділ). Функція приймає один аргумент довільного
          типу — часто рядок&nbsp; — щоб надрукувати, що програма вмирає. Також
          це є шлях вказати, що сталося щось неможливе, таке, як утворився
          безкінечний цикл. </p>
        <pre>// Несправжня реалізація пошуку кубічного кореня з використанням метода Ньютона.
func CubeRoot(x float64) float64 {
    z := x/3   // Довільне початкове значення
    for i := 0; i &lt; 1e6; i++ {
        prevz := z
        z -= (z*z*z-x) / (3*z*z)
        if veryClose(z, prevz) {
            return z
        }
    }
    // Мільйон ітерацій не дає результату, щось не так.
    panic(fmt.Sprintf("CubeRoot(%g) did not converge", x))
}
</pre>
        <p>Це тільки приклад, але реальні бібліотеки повинні уникати&nbsp;<code>panic</code>.
          Якщо проблема може бути замаскована або обійдена, завжди краще
          дозволити речам продовжувати виконання, скоріше, ніж завалити всю
          програму. Один можливий контр-приклад є етап ініціалізації: якщо
          бібліотека дійсно не може підняти сама себе, то дійсно логічним буде
          викликати паніку, так би мовити. </p>
        <pre>var user = os.Getenv("USER")

func init() {
    if user == "" {
        panic("немає значення для $USER")
    }
}
</pre>
        <h3 id="recover">Відновлення</h3>
        <p>Коли викликається <code>panic</code>, включаючи неявний для помилок
          часу виконання, таких як індексування сегменту, що вийшло за межі, або
          помилкове припущення щодо типу, він безпосередньо завершує виконання
          поточною функції та починає розмотивати стек процедури goroutine,
          виконуючи любі відкладені функції, що трапляються на шляху. Якщо це
          розмотування досягає вершини стеку, програма вмирає. Однак можливо
          використати вбудовану функцію&nbsp;<code>recover</code> щоб отримати
          контроль над goroutine та відновити нормальне виконання. </p>
        <p>Виклик <code>recover</code> перериває розмотування та повертає
          аргумент, переданий до&nbsp;<code>panic</code>. Оскільки єдиним кодом,
          що виконується при розмотуванні знаходиться в відкладених функціях, <code>recover</code>
          корисний тільки в відкладених функціях. </p>
        <p>Одне застосування <code>recover</code> є завершення збійної
          goroutine на сервері без вбивства інших працюючих goroutine. </p>
        <pre>func server(workChan &lt;-chan *Work) {
    for work := range workChan {
        go safelyDo(work)
    }
}

func safelyDo(work *Work) {
    defer func() {
        if err := recover(); err != nil {
            log.Println("work failed:", err)
        }
    }()
    do(work)
}
</pre>
        <p>В цьому прикладі якщо <code>do(work)</code> панікує, результат буде
          занесено до журналу та goroutine буде завершена без перешкод для
          інших. Немає потреби робити будь-що інше в відкладеному замиканні;
          виклик&nbsp;<code>recover</code> обробляє умови остаточно. </p>
        <p>Оскільки <code>recover</code> завжди повертає <code>nil</code>, за
          винятком коли напряму викликається з відкладеної функції, відкладений
          код може викликати бібліотечний код, що сам використовує&nbsp;<code>panic</code>
          та <code>recover</code> без створення збою. Як приклад, відкладена
          функція в&nbsp;<code>safelyDo</code> може викликати функцію
          журналювання перед викликом&nbsp;<code>recover</code>, і цей код
          журналювання буде працювати безвідносно до стану паніки. </p>
        <p>З цім шаблоном відновлення, функція <code>do</code> (та будь що вона
          викликає) може вийти з будь якої складної ситуації чистою,
          викликавши&nbsp;<code>panic</code>. Ми можемо використовувати цю ідею
          для спрощення обробки помилок в складному забезпеченні. Давайте
          поглянемо на ідеалізовану версію пакунку&nbsp;<code>regexp</code>, що
          звітує про помилки розбору викликаючи <code>panic</code> з локальним
          типом помилки. Ось визначення <code>Error</code>, методу <code>error</code>,
          а також функція <code>Compile</code>. </p>
        <pre>// Error є типом помилки розбору; він задовольняє інтерфейсу error.
type Error string
func (e Error) Error() string {
    return string(e)
}

// error є методом *Regexp, що звітує помилки розбору через паніку з Error.
func (regexp *Regexp) error(err string) {
    panic(Error(err))
}

// Compile повертає розібрану репрезентацію регулярного виразу.
func Compile(str string) (regexp *Regexp, err error) {
    regexp = new(Regexp)
    // doParse буде паніковати якщо виникне помилка розбору.
    defer func() {
        if e := recover(); e != nil {
            regexp = nil    // Очистити значення розбору.
            err = e.(Error) // Буде повторно панікувати, якщо помилка не типу розбору.
        }
    }()
    return regexp.doParse(str), nil
}
</pre>
        <p> Якщо <code>doParse</code> панікує, блок відновлення буде
          встановлювати зворотнє значення в <code>nil </code>— відкладена
          функція може змінити іменовані значення що повертаються. Після цього
          буде виконана перевірка, в присвоюванні&nbsp; <code>err</code>, що це
          була помилка саме розбору, очікуючи, що в цьому разі помилка має
          локальний тип <code>Error</code>. Якщо це не так, тип очікування не
          співпаде, що викличе помилку часу виконання, що продовжить
          розмотування стеку, якби нічого ії не переривало. Ця перевірка
          означає, що якщо трапиться щось непередбачене, як вихід індексу за
          межі, код отримає збій, навіть якщо ми використовуємо&nbsp;<code>panic</code>
          та <code>recover</code> для обробки помилок розбору. </p>
        <p>З обробкою помилок на своєму місці, метод <code>error</code>
          (оскільки цей метод прив’язаний до типу, це добре, навіть природно,
          для нього мати теж ім’я, що і у вбудованого типу&nbsp;<code>error</code>)
          робить постим сповіщати про помилки розбору без турботи про
          розмотування стеку розбору вручну: </p>
        <pre>if pos == 0 {
    re.error("'*' illegal at start of expression")
}
</pre>
        <p>Позаяк цей підхід є корисним, він має використовуватися тільки в
          межах пакунку. <code>Parse</code> перетворює свої внутрішні виклики <code>panic</code>
          в значення <code>error</code>; він не показує <code>panics</code>
          для своїх клієнтів. Це гарне правило, щоб йому слідувати. </p>
        <p>До речі, ця ідіома ре-паніки змінює значення паніки у разі виникнення
          дійсної помилки.&nbsp; Однак, обидва, оригінальний та новий збій,
          будуть представлені в доповіді, і таким чином докорінна причина
          проблеми буде постійно видимою. Таким чином цей простий підхід
          повторної паніки зазвичай достатній - це крах загалом - але якщо ви
          бажаєте відобразити тільки оригинальне значення, ви можете написати
          трохи більше коду для фільтрування неочікуваних проблем, і
          ре-панікувати оригінальну помилку. Це зостається в якості завдання для
          читача.&nbsp; </p>
        <h2 id="web_server">Веб сервер</h2>
        <p>Давайте закінчимо повною програмою на Go, веб сервером. Насправді це
          деяка різновидь веб ре-сервера. Google провадить сервіс <a href="http://chart.apis.google.com">http://chart.apis.google.com</a>,
          що робить автоматичне форматування даних в вигляді графіків та
          діаграм. Його, тим не менш, складно використовувати інтерактивно, тому
          що вам потрібно вкласти дані в URL як запит. Наша програма надає
          кращий інтерфейс для однієї форми даних: беручи короткий відрізок
          тексту, вона викликає сервер графіків для продукування QR коду,
          матриці прямокутників, що закодовують цей текст. Це зображення може
          бути збереженим в вашому сотовому телефоні або камері, та
          інтерпретовано, наприклад, як URL, зберігаючи ваш набір цього URL на
          мініатюрній клавіатурі телефону. </p>
        <p> Ось повна програма. Пояснення ітимуть далі. </p>
        <pre>package main

import (
    "flag"
    "html/template"
    "log"
    "net/http"
)

var addr = flag.String("addr", ":1718", "http service address") <span class="comment">// Q=17, R=18</span>

var templ = template.Must(template.New("qr").Parse(templateStr))

func main() {
    flag.Parse()
    http.Handle("/", http.HandlerFunc(QR))
    err := http.ListenAndServe(*addr, nil)
    if err != nil {
        log.Fatal("ListenAndServe:", err)
    }
}

func QR(w http.ResponseWriter, req *http.Request) {
    templ.Execute(w, req.FormValue("s"))
}

const templateStr = `
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;QR Link Generator&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
{{if .}}
&lt;img src="http://chart.apis.google.com/chart?chs=300x300&amp;cht=qr&amp;choe=UTF-8&amp;chl={{.}}" /&gt;
&lt;br&gt;
{{.}}
&lt;br&gt;
&lt;br&gt;
{{end}}
&lt;form action="/" name=f method="GET"&gt;&lt;input maxLength=1024 size=70
name=s value="" title="Text to QR Encode"&gt;&lt;input type=submit
value="Show QR" name=qr&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;
`</pre>
        <p> За частиною вище&nbsp;<code>main</code> нескладно прослідувати. Один
          флаг визначає порт HTTP по замовчанню для нашого сервера. Змінна
          шаблону&nbsp;<code>templ</code> - місце, де починається розвага. Тут
          будується шаблон HTML, що буде виконаний сервером для відображення
          сторінки; трохі більше про це піздніше. </p>
        <p>Функція <code>main</code> розпізнає флаги та за допомогою механізму,
          про який мі казали вище, закріплює функцію&nbsp;<code>QR</code> до
          кореневого шляху серверу. По тому викликається&nbsp;<code>http.ListenAndServe</code>
          для початку роботи сервера; вона блокується доки сервер робить. </p>
        <p> <code>QR</code> тільки отримує запити, що містять дані, та виконує
          шаблон для ціх даних в значенні форми на ім’я&nbsp;<code>s</code>. </p>
        <p>Пакунок шаблонів <code>html/template</code> є потужним; ця програма
          тільки дотикається до ії можливостей. В основі він переписує частини
          тексту HTML на ходу, підставляючи елементи, що походять від даних,
          переданих в&nbsp;<code>templ.Execute</code>, в цьому випадку значення
          форми. В тексті шаблону (<code>templateStr</code>), частини, що двічі
          в фігурних дужках, вказують дії шаблону. Частина від <code>{{if .}}</code>
          до <code>{{end}}</code> виконується тільки якщо значення поточного
          елементу даних, що називається крапка&nbsp;<code>.</code> (dot), не є
          порожнім. Таким чином, коли рядок порожній, ця частина шаблону
          подавляється. </p>
        <p>Два клаптика <code>{{.}}</code> кажуть відобразити дані,
          представлені в шаблону — рядок запиту — на веб сторінці. Пакунок HTML
          шаблону автоматично провадить потрідне виключення, і таким чином текст
          є беспечним для відображення. </p>
        <p>Решта рядка шаблону є тільки частиною HTML для відображення коли
          сторінка завантажується. Якщо це дуже швидко для пояснення, дивіться <a
            href="/pkg/html/template/">докуметацію</a> по пакету шаблонов для
          біль заглибленої дискусії. </p>
        <p>І, нарешті, ви маєте: корисний веб сервер в декілька рядків кода,
          плюс деякий рушійний даними текст HTML. Go є достатньо потужним щоб
          зробити це в декілька рядків. </p>
        Build version go1.4.2.<br>
        <div id="footer"> Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
          the content of this page is licensed under the Creative Commons
          Attribution 3.0 License, and code is licensed under a <a href="/LICENSE">BSD
            license</a>.<br>
          <a href="/doc/tos.html">Terms of Service</a> | <a href="http://www.google.com/intl/en/policies/privacy/">Privacy
            Policy</a>
          <script type="text/javascript">(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script></div> </div>
    </div>
  </body>
</html>
