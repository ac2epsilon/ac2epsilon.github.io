<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect2">
<h3 id="__tor">Джерело Tor</h3>
</div>
<div class="sect1">
<h2 id="____">Ласкаво просимо до Тор</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця документація описує загальну структуру бази коду Tor, як вона поєднується, яка функціональність доступна для розширення Tor, а також дає деякі примітки про те, як Tor дістався таким чином. Він також містить посилання на майже кожну функцію, тип, файл та модуль у вихідному коді Tor. Документація на високому рівні - це незавершена праця.</p></div>
<div class="paragraph"><p>Сам Tor також залишається незавершеним: ми працювали над ним майже два десятиліття, і ми багато чого дізналися про хороше кодування з моменту свого першого запуску. Це означає, однак, що деякі з старих частин Tor матимуть у них якийсь кодовий «присмак», який може витримати бурхливий рефакторинг. Тож, коли ми описуємо фрагмент коду, ми іноді дамо примітку про те, як це вийшло, і чи ми все ще вважаємо, що це гарна ідея.</p></div>
<div class="paragraph"><p>Цей документ не є оглядом протоколу Tor. Для цього дивіться проектну документацію та технічні характеристики на <a href="https://spec.torproject.org/">https://spec.torproject.org/</a>.</p></div>
<div class="paragraph"><p>Для отримання додаткової інформації про стандарти кодування Tor та деякі корисні засоби розробки див. Doc/HACKING у репозиторії Tor.</p></div>
<div class="sect2">
<h3 id="___">Огляд високого рівня</h3>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____2">Дуже високий рівень</h2>
<div class="sectionbody">
<div class="paragraph"><p>Зрештою, Tor працює як мережевий демон, керований подіями: він реагує на мережеві події, сигнали та таймери, надсилаючи та отримуючи дущо по мережі. Клієнти, реле та повноваження каталогів усі використовують одну і ту ж базу коду: процес Tor запускається як клієнт, ретранслятор або довірений вузол, залежно від його конфігурації.</p></div>
<div class="paragraph"><p>Tor має декілька основних залежностей, включаючи Libevent (використовується для того, щоб визначити, які сокети читаються і можна записати), OpenSSL або NSS (використовується для багатьох функцій шифрування та для реалізації протоколу TLS), і zlib (використовується для стиснення та розжаття інформації каталогів) .</p></div>
<div class="paragraph"><p>Більшість робіт Tor сьогодні виконується в одному основному потоці, що керованій подіями. Tor також створює одну або кілька робочих ниток для вирішення завдань, що вимагають навантаження на процесор. (Зараз це включає лише шифрування ланцюга та більш коштовні алгоритми стиснення).</p></div>
<div class="paragraph"><p>Під час запуску Tor ініціалізує свої бібліотеки, зчитує та реагує на файли  конфігурації та запускає основний цикл подій. Спочатку єдиними подіями, які Tor слухає, є декілька сигналів (наприклад, TERM та HUP) та один або більше слухаючих сокетів (для різних видів вхідних з'єднань). Tor також налаштовує кілька таймерів для обробки періодичних подій. У міру того, як Тор виконується, з часом відкриватимуться інші події, а також заплановані нові події.</p></div>
<div class="paragraph"><p>Кодова база поділена на кілька підкаталогів верхнього рівня, кожен з яких містить кілька підмодулів.</p></div>
<div class="ulist"><ul>
<li>
<p>
ext - код, який підтримується в іншому місці, який ми включаємо в розподіл джерел Tor.
</p>
</li>
<li>
<p>
lib - код утиліт нижчого рівня, не обов'язково специфічний для tor.
trunnel – Automatically generated code (from the Trunnel tool): used to parse and encode binary formats.
</p>
</li>
<li>
<p>
trunnel - автоматично генерований код (від інструменту Trunnel): використовується для розбору та кодування двійкових форматів.
</p>
</li>
<li>
<p>
core - мережевий код, який реалізує центральні частини протоколу Tor та основний цикл.
</p>
</li>
<li>
<p>
feature - аспекти Tor (наприклад, управління каталогами, запуск ретрансляції, запуск повноважень каталогів, керування списком вузлів, запуск та використання цибульних сервісів), які побудовані поверх коду головного циклу.
</p>
</li>
<li>
<p>
app - функціональність найвищого рівня; відповідальний за налаштування та налаштування демона Tor, переконуючись, що всі модулі нижчого рівня запускаються при необхідності тощо.
</p>
</li>
<li>
<p>
tools - бінарні файли, крім Tor, які ми виробляємо. В даний час це <code>tor-resolve</code>, <code>tor-gencert</code> та допоміжний модуль <code>tor_runner.o</code>.
</p>
</li>
<li>
<p>
test - юніт тести, регресійні тести та кілька інтеграційних тестів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Теоретично, вищезазначені частини кодової бази сортуються від найвищого рівня до нижнього рівня, де код високого рівня дозволений лише для виклику коду нижчого рівня, а код нижчого рівня ніколи не включає або не залежить від коду вищого рівня . Насправді цей рефакторинг є неповним: модулі в lib є добре впорядковані, але в core та feature є багато порушень шару ("висхідні залежності"). Ми прагнемо усунути їх з часом.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_____">Деякі ключові абстракції високого рівня</h2>
<div class="sectionbody">
<div class="paragraph"><p>Найважливіші абстракції на високому рівні Tor - це з'єднання, канали, схеми та вузли.</p></div>
<div class="paragraph"><p>"З'єднання" (<code>connection_t</code>) являє собою інформаційний потік. Більшість з'єднань - це з'єднання TCP з віддаленими серверами Tor та клієнтами. (Але як короткий шлях, реле іноді встановлюватиме з'єднання, фактично не використовуючи TCP-з'єднання. Детальніше про це пізніше). Підключення існують у різних різновидах, залежно від того, яку функціональність вони надають. Принциповими типами з'єднання є <code>edge_connection_t</code> (наприклад, з'єднання сокета або з'єднання від реле виходу до пункту призначення), <code>or_connection_t</code> (потік TLS, який підключається до реле), <code>dir_connection_t</code> (HTTP-з'єднання для отримання інформації про мережу) та <code>control_connection_t</code> ( з'єднання від контролера).</p></div>
<div class="paragraph"><p>"Схема" (<code>circuit_t</code>) - це стійкий тунель через мережу Tor, створений за допомогою криптографії з відкритим ключем, і використовується для передачі коміркам одного або декількох переходів. Клієнти відслідковують мульти-хоп-схеми (<code>origin_circuit_t</code>), а також криптографію, пов'язану з кожним стрибком. Реле, з іншого боку, відстежують лише їхній стрибок кожного ланцюга (<code>or_circuit_t</code>).</p></div>
<div class="paragraph"><p>"Канал" (<code>channel_t</code>) - це абстрактний вигляд передачі комірок до та з реле Tor. В даний час всі канали реалізовані за допомогою OR з'єднань (<code>channel_tls_t</code>). Якщо ми в майбутньому перейдемо до інших стратегій, у нас буде більше типів підключення.</p></div>
<div class="paragraph"><p>"Вузол" (<code>node_t</code>) - це перегляд сучасних знань та думок екземпляра Tor щодо реле або мосту Tor.</p></div>
<div class="sect2">
<h3 id="______2">Практика дизайну коду високого рівня</h3>
<div class="paragraph"><p>На цій сторінці описані практики дизайну високого рівня для коду Tor. Цей дизайн - це довгострокова мета того, як ми хочемо щоб виглядав наш код, а не опис того, яким він є в даний час.</p></div>
<div class="paragraph"><p>Загалом, ми хочемо, щоб різні частини коду tor взаємоділи між собою через невелику кількість інтерфейсів.</p></div>
<div class="paragraph"><p>Ми хочемо уникати «об’єктів бога» чи «модулів бога». Це об'єкти або модулі, які занадто багато знають про інші частини коду. Бог об'єкти/модулі, як правило, визнані антипатерном програмного забезпечення.</p></div>
<div class="paragraph"><p>Історично в tor існували модулі, які прагнули стати модулями бога. До них відносяться модулі, які допомагають більш спеціалізованому коду спілкуватися із зовнішнім світом: наприклад, модулі конфігурації та управління. Інші - це модулі, які займаються глобальним станом, ініціалізацією чи відключенням.</p></div>
<div class="paragraph"><p>Якщо централізованому модулю потрібно викликати код майже в кожному іншому модулі в системі, то краще, якщо він експортує невеликий, загальний інтерфейс, який викликають інші модулі. Централізований модуль не повинен явно викликати всі модулі, які взаємодіють з ним.</p></div>
<div class="paragraph"><p>Натомість модулі, які взаємодіють з централізованим модулем, повинні викликати інтерфейси реєстрації. Ці інтерфейси дозволяють модулям реєструвати обробники таких речей, як аналіз конфігурації та виконання команд управління. (Конфігураційні модулі та модулі управління - приклади цього). Крім того, реєстрація може відбуватися через статично ініціалізовані структури даних. (Приклад цього є механізмом підсистеми).</p></div>
</div>
<div class="sect2">
<h3 id="____3">Ініціалізація та завершення</h3>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_">Огляд</h2>
<div class="sectionbody">
<div class="paragraph"><p>Tor has a single entry point: tor_run_main() in main.c. All the ways of starting a Tor process (ntmain.c, tor_main.c, and tor_api.c) work by invoking tor_run_main().
Tor має єдину точку входу: <code>tor_run_main()</code> в <code>main.c</code>. Всі способи запуску процесу Tor (<code>ntmain.c</code>, <code>tor_main.c</code> та <code>tor_api.c</code>) працюють, викликаючи <code>tor_run_main()</code>.</p></div>
<div class="paragraph"><p>Функція <code>tor_run_main()</code> зазвичай виходить через <code>return</code>: не викликаючи <code>abort()</code> або <code>exit()</code>. Перш ніж повернутися, він викликає <code>tor_cleanup()</code> в <code>shutdown.c</code>.</p></div>
<div class="paragraph"><p>Концептуально існує кілька етапів запуску Tor.</p></div>
<div class="paragraph"><p>Спочатку ми ініціалізуємо ті модулі, які не залежать від конфігурації. Це відбувається в першій половині <code>tor_run_main()</code>, і в першій половині <code>tor_init()</code>.</p></div>
<div class="paragraph"><p>По-друге, ми аналізуємо командний рядок та нашу конфігурацію та налаштовуємо системи, які залежать від нашої конфігурації чи стану. Ця конфігурація відбувається посередині проходження <code>tor_init()</code>, який викликає <code>options_init_from_torrc()</code>. Потім ми ініціалізуємо більше систем із другої половини <code>tor_init()</code>.</p></div>
<div class="paragraph"><p>У цей момент ми можемо швидко вийти, якщо нас попросять зробити щось, що не потребує подальшої ініціалізації, наприклад, надрукувати наш номер версії або створити новий ключ підпису. В іншому випадку ми переходимо до <code>run_tor_main_loop()</code>, який ініціалізує деякі специфічні для мережі частини Tor, захоплює деякі лише для демона ресурси (наприклад, блокування каталогу даних) і запускає сам Tor.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
<code>tor_run_main()</code> може закінчуватися викликом <code>abort()</code> або <code>exit()</code>, але лише при збої через помилку або при змушуванні працювати як демон.
</p>
</li>
<li>
<p>
Частини коду, які я описую як перша частина <code>tor_init()</code> тощо, заслуговують на те, щоб бути функціями зі своїм іменем. Я хотів би переробити їх, але перед тим, як зробити це, потрібно зробити невелику перебудову. Зокрема, виклик <code>nt_service_parse_options()</code> повинен, логічно, бути згодом у нашій послідовності ініціалізації. Дивіться квиток 32447 для нашого прогресу рефакторингу.
</p>
</li>
</ol></div>
<div class="sect2">
<h3 id="____4">Підсистеми та ініціалізація</h3>
<div class="paragraph"><p>Наша діюча угода полягає у використанні механізму підсистем для ініціалізації та очищення частин Tor. Цей останній механізм використовуватимуть останні оновлені частини Tor. Для прикладів див. <code>time_sys.c</code> або <code>log_sys.c</code>.</p></div>
<div class="paragraph"><p>Найпростіше кажучи, підсистема - це логічно окрема частина Tor, яку можна ініціалізувати, вимикати, керувати та конфігурувати дещо незалежно від решти програми.</p></div>
<div class="paragraph"><p>Тип <code>subsys_fns_t</code> описує підсистему та набір функцій, які ініціалізують її, деконструюють її тощо. Щоб визначити підсистему, ми оголосимо екземпляр <code>const subsys_fns_t</code>. Повний список цих функцій див. У документації для <code>subsys_fns_t</code>.</p></div>
<div class="paragraph"><p>Після визначення підсистеми вона повинна бути вставлена у <code>subsystem_list.c</code>. У цей момент механізми, керовані таблицею в <code>subsysmgr.c</code>, будуть викликати її функції, коли це доречно.</p></div>
<div class="sect3">
<h4 id="____5">Ініціалізація або конфігурація</h4>
<div class="paragraph"><p>Зауважимо, що фаза ініціалізації Tor відбувається до того, як будь-яка конфігурація зчитується з диска, а отже, перед тим, як будь-які інші файли читаються з диска. Тому будь-яка поведінка, що залежить від конфігурації або стану Tor, має відбуватися після процесу ініціалізації під час конфігурації.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_____tor">Потік даних у процесі Tor</h3>
<div class="paragraph"><p>Ми читаємо байти з мережі, записуємо байти в мережу. Здебільшого, байти, які ми пишемо, приблизно відповідають байтам, які ми прочитали, з доданими бітами криптографії.</p></div>
<div class="paragraph"><p>Решта - це питання деталей.</p></div>
<div class="sect3">
<h4 id="________">З'єднання та буфери: читання, запис та інтерпретація.</h4>
<div class="paragraph"><p>На низькому рівні мережевий код Tor заснований на "з'єднаннях". Кожне з'єднання являє собою об'єкт, який може надсилати або приймати події, подібні до мережі. Здебільшого кожне з'єднання має один базовий потік TCP (я обговорюю контрприклади нижче).</p></div>
<div class="paragraph"><p>З'єднання, яке веде себе як потік TCP, має вхідний буфер і вихідний буфер. Вхідні дані записуються у вхідний буфер ("inbuf"); Дані, що підлягають запису в мережу, стоять у черзі на вихідному буфері ("outbuf").</p></div>
<div class="paragraph"><p>Буфери реалізовані в <code>buffers.c</code>. Кожен з цих буферів реалізований у вигляді пов'язаної черги екстентів пам'яті у стилі класичних BSD <code>mbufs</code> або Linux <code>skbufs</code>.</p></div>
<div class="paragraph"><p>Читання та запис з'єднання може бути включено або вимкнено. За лаштунками ця функціональність реалізована за допомогою подій <code>libevent</code>: одна для читання, друга для письма. Ці події вмикаються/вимикаються в <code>main.c</code>, у функціях <code>connection_{start,stop}_{reading,writing}</code>.</p></div>
<div class="paragraph"><p>Коли подія читання або запису вмикається, головний цикл <code>libevent</code> опитує ядро, запитуючи, які сокети готові читати чи писати. (Це опитування відбувається під час виклику <code>event_base_loop()</code> у <code>run_main_loop_once()</code> у <code>main.c</code>) Коли <code>libevent</code> знаходить сокет, готовий читати чи писати, він викликає <code>conn_ {read, write} _callback()</code>, також у <code>main.c</code></p></div>
<div class="paragraph"><p>Ці функції зворотного виклику делегуються до <code>connection_handle_read()</code> та <code>connection_handle_write()</code> у <code>connection.c</code>, які читають або записують у мережі за необхідності, можливо делегуючи до <code>openssl</code>.</p></div>
<div class="paragraph"><p>Після зчитування чи запису даних або іншої події ці функції <code>connection_handle_read_write()</code> викликають логічні функції, завдання яких - відповідати на інформацію. Деякі приклади:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>connection_flushed_some()</code> - викликається після того, як з'єднання записує будь-яку кількість даних зі свого <code>outbuf</code>.
</p>
</li>
<li>
<p>
<code>connection_finished_flushing()</code> - викликається, коли з'єднання спорожніло свій <code>outbuf</code>.
</p>
</li>
<li>
<p>
<code>connection_finished_connecting()</code> - викликається, коли в процесі з'єднання закінчується встановлення віддаленого з'єднання.
</p>
</li>
<li>
<p>
<code>connection_reached_eof()</code> - викликається після отримання <code>FIN</code> від віддаленого сервера.
</p>
</li>
<li>
<p>
connection_process_inbuf() - викликається, коли більше даних надходить на <code>inbuf</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Потім ці функції викликають конкретні реалізації залежно від типу з'єднання. Наприклад, якщо з'єднання є <code>edge_connection_t</code>, <code>connection_reached_eof()</code> зателефонує <code>connection_edge_reached_eof()</code>.</p></div>
<div class="paragraph"><p>Примітка: "Також є <code>bufferevents</code>!" У нас є рудиментальний код для альтернативної низькорівневої реалізації мереж, заснований на коді <code>Libevent</code> <code>evbuffer</code> і <code>bufferevent</code>. Ці два типи об'єктів беруть на себе (більшість) ролі буферів та з'єднань відповідно. Це не працює в сучасному Tor, через смердіння коду та можливі затяжні помилки <code>libevent</code>. Потрібно більше роботи; було б добре зробити це знову ефективно, мати підтримку IOCP в Windows.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____6">Контроль з'єднань</h3>
<div class="paragraph"><p>У з’єднанні може бути включено чи вимкнено читання чи запис із найрізноманітніших причин, зокрема:</p></div>
<div class="ulist"><ul>
<li>
<p>
Запис вимкнено, коли немає більше даних для запису
</p>
</li>
<li>
<p>
Для деяких типів з'єднання зчитування відключено, коли <code>inbuf</code> файл занадто заповнений.
</p>
</li>
<li>
<p>
Читання/запис тимчасово вимикається на з'єднаннях, які нещодавно прочитали/записали достатньо даних до своєї пропускної здатності
</p>
</li>
<li>
<p>
Читання відключається на з'єднаннях, коли зчитування з них більшої кількості даних вимагає, щоб дані були завантажені в інше місце, яке вже є повним.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Currently, these conditions are checked in a diffuse set of increasingly complex conditional expressions. In the future, it could be helpful to transition to a unified model for handling temporary read/write suspensions.
В даний час ці умови перевіряються в розмитому наборі все більш складних умовних виразів. Надалі може бути корисним зробити перехід до єдиної моделі для тимчасової зупинки читання/запису.</p></div>
</div>
<div class="sect2">
<h3 id="____7">Види з'єднань</h3>
<div class="paragraph"><p>Сьогодні Tor має такі типи з'єднання та псевдоз'єднання. Здебільшого кожен тип каналу має асоційований модуль С, який реалізує його основну логіку.</p></div>
<div class="ulist"><ul>
<li>
<p>
Крайові з'єднання отримують дані і доставляють дані до точок поза мережею цибулевої маршрутизації. Дивіться <code>connection_edge.c</code>. Вони поділяються на два типи:
</p>
<div class="ulist"><ul>
<li>
<p>
Вхідні з'єднання - це тип крайового з'єднання. Вони отримують дані від користувача, який працює з клієнтом Tor, і доставляють дані цьому користувачеві. Вони використовуються для реалізації <code>SOCKSPort</code>, <code>TransPort</code>, <code>NATDPort</code> тощо. Іноді їх називають з’єднаннями "AP" з історичних причин (раніше вони позначалися як "Application Proxy").
</p>
</li>
<li>
<p>
Вихідні з'єднання - це тип крайового з'єднання. Вони існують на вузлі виходу та передають трафік в мережу та з неї.
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>(Вхідні з'єднання та вихідні з'єднання також використовуються як заповнювачі при виконанні віддаленого запиту DNS; вони не відокремлюються від поняття "потік" у протоколі Tor. Це реалізується частково в <code>connection_edge.c</code>, а частково в <code>dnsserv.c</code> і <code>dns.c</code>.)</p></div>
<div class="ulist"><ul>
<li>
<p>
OR з'єднання надсилають та приймають комірки Tor через TLS, використовуючи деяку версію протоколу зв'язку Tor. Їх реалізація розповсюджується через <code>connection_or.c</code>, маючи трохи логіки у <code>command.c</code>, <code>relay.c</code> та <code>channeltls.c</code>.
</p>
</li>
<li>
<p>
Розширені з'єднання OR - це тип OR з'єднання для використання на мостах, що використовують підключувані транспорти, так що PT може повідомляти мосту деяку інформацію про вхідне з'єднання перед передачею його даних. Вони реалізовані в <code>ext_orport.c</code>.
</p>
</li>
<li>
<p>
Підключення до каталогу - це з'єднання на стороні сервера або на клієнті, які реалізують протокол каталогів, заснований на HTTP. Вони створюються миттєво за допомогою сокета, коли Tor здійснює незашифроване з'єднання HTTP. Коли Tor налаштовує запит на каталог через ланцюг Tor, підключення до каталогу реалізуються за допомогою зв'язаної пари з'єднань (див. Нижче). Підключення до каталогу реалізовані в <code>directory.c</code>; частина логіки на сервері реалізована в <code>dirserver.c</code>.
</p>
</li>
<li>
<p>
підключення контролера - це локальні з'єднання до процесу контролера, що реалізує протокол контролера з <code>control-spec.txt</code>. Вони знаходяться в <code>control.c</code>.
</p>
</li>
<li>
<p>
Підключення слухача не орієнтовані на потік! Швидше вони огортають сокет для прослуховування, щоб виявити нові вхідні з'єднання. Вони обходять більшу частину логіки потоку. Вони не мають асоційованих буферів. Вони реалізовані <code>connection.c</code>.
</p>
<div class="literalblock">
<div class="content">
<pre><code>Зауваження: "Час історії!" Ви можете час від часу знайти посилання на кілька типів з'єднань, яких більше не існує в сучасному Tor. З'єднання CPUWorker з'єднувало основний процес Tor з потоком або процесом, що використовується для обчислення. (Сьогодні ми використовуємо внутрішньо-процесну комунікацію). Навіть більш стародавнє з'єднання DNSWorker з'єднувало основний процес tor з окремим потоком або процесом, який використовується для запуску `gethostbyname()` або `getaddrinfo()`. (Сьогодні ми використовуємо засоби `evdns` з `Libevent` для виконання запитів DNS асинхронно.)</code></pre>
</div></div>
</li>
</ul></div>
<div class="sect4">
<h5 id="_____2">Пов'язані з'єднання</h5>
<div class="paragraph"><p>Іноді два канали з'єднуються разом, так що дані, які надсилає процес Tor в один повинні бути негайно отримані тим самим процесом Tor з іншого. (Наприклад, коли Tor здійснює тунельне підключення до каталогу, це реалізовується на стороні клієнта як з'єднання з каталогом, вихід якого надходить не в мережу, а в локальне з'єднання входу. І коли каталог отримує тунельне підключення до каталогу, це реалізується як з'єднання виходу, вихід якого надходить не в мережу, а в локальне підключення до каталогу).</p></div>
<div class="paragraph"><p>Найдавніші версії Tor для підтримки поєднаних з'єднань використовували для цього <code>socketpairs</code>. Але використання <code>socketpairs</code> змусило нас копіювати дані через простір ядра і витрачало обмежені дескриптори файлів. Отже, замість цього, пара з'єднань може бути пов'язана в самому процесі. Кожне пов'язане з'єднання має вказівник на інший, таким чином, що дані, написані на одній стороні, можна відразу читати на іншій, і навпаки.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="______3">Від з'єднань до каналів</h3>
<div class="paragraph"><p>Існує шар абстракції над з'єднаннями OR (ті, що керують комірками) та під комірками під назвою Канали. Призначенням каналу є передача автентифікованих комірок від одного екземпляра Tor (ретранслятора або клієнта) до іншого.</p></div>
<div class="paragraph"><p>В даний час існує лише одна реалізація: <code>Channel_tls</code>, яка надсилає та приймає комірки через АБО-з'єднання на базі TLS.</p></div>
<div class="paragraph"><p>Комірки надсилаються на канал, використовуючи <code>channel_write _ {,packed_,var_}cell()</code>. Вхідні комірки надходять на канал зі свого сервера, використовуючи <code>channel_queue*_cell()</code>, і негайно обробляються за допомогою <code>channel_process_cells()</code>.</p></div>
<div class="paragraph"><p>Деякі типи комірок обробляються нижче шару каналу, наприклад, ті, що впливають лише на рукостискання. І деякі інші передаються до загального коду міжканальних каналів у <code>command.c</code>: комірки типу <code>DESTROY</code> та <code>CREATED</code> - це тривіально для обробки. Але ретранслятор вимагає спеціального керування &#8230;</p></div>
</div>
<div class="sect2">
<h3 id="_____3">З каналів через ланцюги</h3>
<div class="paragraph"><p>Коли реле-комірка потрапляє на існуючий ланцюг, вона обробляється у <code>circuit_receive_relay_cell()</code> - одна з найцентральніших функцій в Tor. Ця функція зашифровує або розшифровує релейну комірку за необхідності та визначає, чи призначена комірка для поточного стрибка ланцюга.</p></div>
<div class="paragraph"><p>Якщо комірка призначена для поточного переходу, ми передаємо її до <code>connection_edge_process_relay_cell()</code> у <code>relay.c</code>, яка діє на неї на основі своєї команди реле та (можливо) ставить в чергу його дані на <code>edge_connection_t</code>.</p></div>
<div class="paragraph"><p>Якщо комірка не призначена для поточного переходу, ми ставимо її в чергу для наступного каналу в послідовності з додаванням <code>cell_to_circuit_queue()</code>. Це розміщує комірку на черзі на ланцюг, спрямованих на цей конкретний канал.</p></div>
</div>
<div class="sect2">
<h3 id="______">Відправлення комірок по схемах: складні матерії.</h3>
<div class="paragraph"><p>Комірки ретрансляції ставляться в черги на ланцюги з одного з двох (головних) джерел: зчитування даних з крайових з'єднань і отримання комірки, яка повинна бути ретрансльована по ланцюгу. Обидва ці джерела розміщують свої комірки в черзі комірок: у кожній схемі є одна черга комірок для кожного напрямку, в якому вона проходить.</p></div>
<div class="paragraph"><p>Наївна реалізація може пропустити використання черги комірок, і замість цього записати кожну вихідну реле клітинку. (Тор це робив у своїх попередніх версіях). Але такий підхід, як правило, дає низьку продуктивність, оскільки він дозволяє об'ємним ланцюгам засмічувати канали, і він змушує сервер Tor надсилати дані з черги на схему, навіть після того, як він був зачинений.</p></div>
<div class="paragraph"><p>Таким чином, використовуючи черги у кожній схемі, ми можемо додавати комірки до кожного каналу прямо зараз, вибираючи комірку в кожен момент на основі алгоритму, орієнтованого на ефективність.</p></div>
<div class="paragraph"><p>Ця логіка реалізована у двох основних модулях: <code>scheduler.c</code> та <code>circuitmux*.c</code>. Код планувальника несе відповідальність за визначення глобально, за всіма каналами, які могли б записувати клітинки, якому слід отримувати клітини в черзі. Код <code>circuitmux</code> визначає для всіх ланцюгів з чергами комірки для каналу, який слід ставити в чергу наступної комірки.</p></div>
<div class="paragraph"><p>(Ця логіка стосується лише вихідних релейних комірок; вхідні ретрансляційні комірки обробляються по мірі їх надходження).</p></div>
</div>
<div class="sect2">
<h3 id="___tor">Сертифікати в Tor.</h3>
<div class="paragraph"><p>На жаль, у Tor є кілька типів сертифікатів.</p></div>
<div class="paragraph"><p>Тип <code>tor_x509_cert_t</code> представляє сертифікат X.509. Цей документ не пояснить вам X.509 - можливо, жоден документ не може. (OTOH, "Посібник зі стилю x.509 Пітера Гутмана", хоч і суворо прострочений, добре допомагає пояснити, наскільки жахливим може бути х.509). Не вводьте жодних нових звичаїв X.509. Зараз ми використовуємо його лише в тих місцях, де TLS змушує нас це робити. Дивіться <code>x509.c</code> для отримання додаткової інформації про використання цього типу.</p></div>
<div class="paragraph"><p>Тип <code>authority_cert_t</code> використовується лише для авторизованих ключів каталогу. Він має середньостроковий ключ підпису (який довірені сторони фактично зберігають в Інтернеті), підписаний довгостроковим ідентифікаційним ключем (який дійсно краще було б оператору зберігати в автономному режимі). Не використовуйте його для будь-якого нового виду сертифікатів.</p></div>
<div class="paragraph"><p>Для нових місць, де вам потрібен сертифікат, врахуйте <code>tor_cert_t</code>: він являє собою щось типіззоване та датоване, підписане ключем Ed25519. Формат описаний у <code>tor-spec</code>. На відміну від <code>x.509</code>, ви можете написати його на серветці. Файл <code>torcert.c</code> використовується для управління цими сертифікатами та пов'язаними з ними ключами.</p></div>
<div class="paragraph"><p>(Крім того, дизайн каталогу Tor використовує досить широкий спектр документів, що включають ключі та підписані ключами. Ви можете вважати ці документи додатковим різновидом сертифікатів, якщо хочете).</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___tor_2">Потоки в Tor</h2>
<div class="sectionbody">
<div class="paragraph"><p>Tor заснований на одній головній нитці та одній або декількох робочих нитках. Ми прагнемо (із середнім успіхом) використовувати робочі потоки для активних процесорних дій та основну нитку для нашої мережі. На щастя (?), у нас є достатньо криптографії, що перенесення того, що ми можемо, про криптографічні процеси до працівників, повинен досягти гарного паралелізму при більшості навантажень. На жаль, ми маємо лише невелику частину нашої криптографії, зробленої в наших робочих нитках.</p></div>
<div class="paragraph"><p>Наша абстракція потоків і робітників визначена в <code>workqueue.c</code>, який поєднує чергу роботи з пулом потоків і інтегрує сигналізацію з <code>libevent</code>. Основний екземпляр робочої черги Tor інстанціюється в <code>cpuworker.c</code>. Ймовірно, знадобиться деякий рефакторинг, оскільки додається більше видів робіт.</p></div>
<div class="paragraph"><p>На нижчому рівні ми надаємо замки з <code>tor_mutex_t</code> в <code>lib/lock</code> та інструменти для locking/ threading верхніх рівнів у <code>lib/thread</code>, включаючи умови (<code>tor_cond_t</code>), локальне зберігання потоків (<code>tor_threadlocal_t</code>) тощо.</p></div>
<div class="paragraph"><p>Постарайтеся мінімізувати обмін між потоками: зазвичай краще просто зробити працівника «власником» усіх необхідних йому даних, поки робота триває, і відмовитися від права власності, коли вона закінчиться.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____tor">Обробка рядків у Tor</h2>
<div class="sectionbody">
<div class="paragraph"><p>Оскільки ви читаєте про програму C, ви, ймовірно, очікували цей розділ: він наповнений функціями для маніпулювання (сумнівно непевною) абстракцією рядка C. Я опишу тут деякі часто пропущені моменти.</p></div>
<div class="sect3">
<h4 id="_______2">Порівняння рядків і фрагментів пам'яті</h4>
<div class="paragraph"><p>Ми надаємо <code>strcmpstart()</code> і <code>strcmpend()</code> для виконання <code>strcmp</code> з початком або кінцем рядка.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Для порівняння двох рядкових покажчиків, кожен з яких може бути <code>NULL</code>, використовуйте <code>strcmp_opt()</code>.</p></div>
<div class="paragraph"><p>Для пошуку рядка або фрагмента пам'яті в ненульовому блоці пам'яті, використовуйте <code>tor_memstr</code> або <code>tor_memmem</code> відповідно.</p></div>
<div class="paragraph"><p>Ми уникаємо використання memcmp () безпосередньо, оскільки він, як правило, краще використовується у випадках, коли операція з постійним часом була б кращою. Натомість ми рекомендуємо <code>tor_memeq()</code> та <code>tor_memneq()</code>, коли вам потрібна операція постійного часу. У випадках, коли вам потрібно швидке порівняння, і витоки часу не становлять небезпеки, ви можете використовувати <code>fast_memeq()</code> та <code>fast_memneq()</code>.</p></div>
<div class="paragraph"><p>Це звичайний зразок - взяти рядок, що представляє один або кілька рядків тексту, і шукати всередині нього якийсь інший рядок, на початку рядка. Ви можете шукати <code>"\\ntarget"</code>, але це буде пропускати перший рядок. Замість цього використовуйте <code>find_str_at_start_of_line</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__">Розбір тексту</h4>
<div class="paragraph"><p>За ці роки ми накопичили багато способів розбору тексту - напевно, занадто багато. Реконструкція їх на безпечніше і змістовніше може бути хорошим проектом! Найбільш стійким до помилок є текенізація тексту з <code>smartlist_split_strings()</code>. Ця функція приймає <code>smartlist</code>, рядок і роздільник, і розбиває рядок на зустрічі подільника, додаючи нові рядки для піделементів до даного <code>smartlist</code>.</p></div>
<div class="paragraph"><p>Для обробки часу можна скористатися однією з функцій, згаданих вище у розділі "Розбір і кодування значень часу".</p></div>
<div class="paragraph"><p>Для цифр взагалі використовуйте сімейство функцій <code>tor_parse_{long, ulong, double, uint64}</code>. Кожне з них можна визвати кількома способами. Найбільш загальне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">const</span> <span class="n">int</span> <span class="nc">BASE</span> <span class="k">=</span> <span class="mi">10</span><span class="o">;</span>
  <span class="n">const</span> <span class="n">int</span> <span class="nc">MINVAL</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span> <span class="nc">MAXVAL</span> <span class="k">=</span> <span class="mi">10000</span><span class="o">;</span>
  <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">next</span><span class="o">;</span>
  <span class="n">int</span> <span class="n">ok</span><span class="o">;</span>
  <span class="n">long</span> <span class="n">lng</span> <span class="k">=</span> <span class="n">tor_parse_long</span><span class="o">(</span><span class="s">&quot;100&quot;</span><span class="o">,</span> <span class="nc">BASE</span><span class="o">,</span> <span class="nc">MINVAL</span><span class="o">,</span> <span class="nc">MAXVAL</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">ok</span><span class="o">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Повертане значення слід ігнорувати, якщо для <code>ok</code> встановлено значення <code>false</code>. Рядок введення повинен містити ціле число, або воно вважається недійсним &#8230; якщо тільки вказівник <code>next</code> недоступний, в цьому випадку додаткові символи в кінці дозволені, а <code>next</code> встановлений, щоб вказувати на перший такий символ .</p></div>
</div>
<div class="sect3">
<h4 id="____8">Генерування блоків тексту</h4>
<div class="paragraph"><p>Для не надто великих блоків тексту ми надаємо <code>tor_asprintf()</code>, який поводиться як інші члени сімейства <code>sprintf()</code>, за винятком того, що він завжди виділяє достатню кількість пам’яті на купі для його виведення.</p></div>
<div class="paragraph"><p>Для більших блоків: Замість використання <code>strlcat</code> та <code>strlcpy</code> для створення тексту або утримуючи покажчики на внутрішній блок пам'яті, ми рекомендуємо використовувати функції <code>smartlist_*</code> для складання <code>smartlist</code>, повного підрядків. Тоді ви можете об'єднати їх у єдиний рядок із <code>smartlist_join_strings()</code>, який також приймає необов'язкові аргументи роздільника та термінатора.</p></div>
<div class="paragraph"><p>Крім того, вам може бути зручнішим (і більш ефективним при розподілі) використовувати API буфера в <code>buffers.c</code>: Створіть об'єкт <code>buf_t</code>, додайте до нього свої дані за допомогою <code>buf_add_string()</code>, <code>buf_add_printf()</code> тощо, а потім викличте <code>buf_extract()</code>, щоб отримати результат.</p></div>
<div class="paragraph"><p>Для зручності ми пропонуємо smartlist_add_asprintf(), який поєднує в собі два вищевказаних методи. Багато функцій криптографічних дайджестів також приймають ще не об'єднаний <code>smartlist</code> рядків.</p></div>
</div>
<div class="sect3">
<h4 id="___2">Помічники журналювання</h4>
<div class="paragraph"><p>Часто ми хочемо журналювати значення, яке надходить з ненадійного джерела. Для цього використовуйте <code>escape()</code>, щоб уникнути недрукувальних символів та інших заплутаних елементів у рядку та оточити його в лапки. (Використовуйте <code>esc_for_log()</code>, якщо вам потрібно розташувати новий рядок.)</p></div>
<div class="paragraph"><p>Також зручно розміщувати фрагменти пам'яті в шістнадцять разів перед журналюванням; ви можете використовувати для цього <code>hex_str(memory, length)</code>.</p></div>
<div class="paragraph"><p>Обидві функції <code>escape()</code> та <code>hex_str()</code> забезпечують результати, які є дійсними лише до наступного виклику; вони не є безпечними в нитках.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="______tor">Час та періодичні події в Tor</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="____9">Що таке час?</h4>
<div class="paragraph"><p>У нас є кілька уявлень про поточний час у Торі.</p></div>
<div class="paragraph"><p>Час настінного годинника доступний з <code>time(NULL)</code> з точністю до секунд і <code>tor_gettimeofday()</code> з мікросекундною деталізацією. Це найбільше відповідає "поточному часу та даті".</p></div>
<div class="paragraph"><p>Монотонний час доступний із набором функцій <code>monotime_*</code>, оголошених у <code>compat_time.h</code>. На відміну від часу настінного годинника, він може рухатися лише вперед. Це не обов'язково відповідає реальному світовому часу і не є сумісним між системами.</p></div>
<div class="paragraph"><p>Грубий монотонний час доступний із набору функцій <code>monotime_coarse_*</code> в <code>compat_time.h</code>. Це те саме, що <code>monotime_*</code> на деяких платформах. Для інших він дає монотонний таймер з меншою точністю, але до нього є більш ефективний доступ.</p></div>
</div>
<div class="sect3">
<h4 id="____10">Кешовані виміри часу.</h4>
<div class="paragraph"><p>У деяких системах (наприклад, Linux) багато функцій часу використовують VDSO, щоб уникнути накладних витрат системного виклику. Але в інших системах <code>gettimeofday()</code> та <code>time()</code> можуть бути досить дорогими, що ви не хочете визивати їх десятками тисяч разів. Щоб отримати останній, але не особливо точний перегляд поточного часу, див. <code>approx_time()</code> та <code>tor_gettimeofday_cached()</code>.</p></div>
</div>
<div class="sect3">
<h4 id="______4">Розбір і кодування значень часу</h4>
<div class="paragraph"><p>Tor має функції для розбору та форматування часу в таких форматах:</p></div>
<div class="ulist"><ul>
<li>
<p>
RFC1123 формат. (<code>"Пт, 29 вересня 2006 15:54:20 GMT"</code>). Для цього використовуйте <code>format_rfc1123_time()</code> та <code>parse_rfc1123_time</code>.
</p>
</li>
<li>
<p>
Формат ISO8601 (<code>"2006-10-29 10:57:20"</code>) Для цього використовуйте <code>format_local_iso_time()</code> та <code>format_iso_time()</code>. Ми також підтримуємо варіант формату <code>"2006-10-29T10:57:20"</code> з <code>format_iso_time_nospace()</code> та <code>"2006-10-29T10:57:20.123456"</code> з <code>format_iso_time_nospace_usec ()</code>.
</p>
</li>
<li>
<p>
Колекції формату HTTP (переважно <code>"пн, 25 липня 2016 04:01:11 GMT"</code> або, можливо, <code>"ср. 30 червня 21:49:08 1993"</code> або навіть "<code>25 липня-16 04:01:11 GMT"</code>). Для цього використовуйте <code>parse_http_time()</code>. Не створюйте нічого, крім першого формату.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Деякі з цих функцій використовують <code>struct tm</code>. Ви можете використовувати стандартні <code>tor_localtime_r()</code> та <code>tor_gmtime_r()</code>, щоб обернути їх безпечним способом. Також у нас є функція <code>tor_timegm()</code>.</p></div>
</div>
<div class="sect3">
<h4 id="___3">Планування подій</h4>
<div class="paragraph"><p>Основний спосіб запланувати не надто часті періодичні події стосовно Tor цикла - через механізм в <code>periodic.c</code>. У <code>mainloop.c</code> є велика таблиця <code>periodic_events</code>, кожна з яких викликається за власним графіком. Не слід очікувати більше, ніж приблизно секунди точності від цих таймерів.</p></div>
<div class="paragraph"><p>Ви можете створити незалежний таймер за допомогою безпосередньо libevent або за допомогою функції <code>periodic_timer_new()</code>. Але вам слід уникати цього для таймерів підключення або за схемою: внутрішня реалізація таймеру Libevent використовує міні-купу, і ті, як правило, починають погано масштабувати, коли у вас є кілька тисяч записів.</p></div>
<div class="paragraph"><p>Якщо вам потрібно створити велику кількість дрібнозернистих таймерів з якоюсь метою, вам слід розглянути механізм у <code>src/common/timers.c</code>, який оптимізовано для випадку, коли у вас є велика кількість таймерів з не надто довгою тривалістю, багато з яких буде видалено до того, як вони дійсно закінчуються. Ці таймери повинні бути досить точними протягом кількох мілісекунд - можливо, навіть краще на деяких платформах. (Модуль <code>timers.c</code> використовує впровадження <code>timeout.c</code> Вільяма Агерна в якості основи, який базується на ієрархічному алгоритмі колеса хронометражу. Це круті речі; подивіться на це.)</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="______5">Параметри конфігурації та постійний стан</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__2">Вступ</h3>
<div class="paragraph"><p>Tor використовує спільний механізм, керований таблицею, для обробки файлів його конфігурації (torrc) та файлів стану. Кожен модуль може оголосити набір іменованих полів для цих файлів та отримувати сповіщення про кожну зміну конфігурації або коли стан збираються передати на диск.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Оголошення параметрів</h3>
<div class="paragraph"><p>Для більшості модулів потрібно буде використовувати макроси в <code>confdecl.h</code> для оголошення конфігурації або структури стану.</p></div>
<div class="paragraph"><p>You&#8217;ll write something like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// my_module_config.inc</span>
<span class="n">BEGIN_CONF_STRUCT</span><span class="p">(</span><span class="n">module_options_t</span><span class="p">)</span>
<span class="n">CONF_VAR</span><span class="p">(</span><span class="n">FieldOne</span><span class="p">,</span> <span class="n">INT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;7&quot;</span><span class="p">)</span>
<span class="n">CONF_VAR</span><span class="p">(</span><span class="n">FieldTwo</span><span class="p">,</span> <span class="n">STRING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="n">END_CONF_STRUCT</span><span class="p">(</span><span class="n">module_options_t</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Вищенаведений приклад призведе до структури під назвою <code>module_config_t</code> з двома полями: одним цілим числом під назвою <code>FieldOne</code> і одним рядком під назвою <code>FieldTwo</code>. Ціле число отримує значення за замовчуванням <code>7</code>; значенням за замовчуванням рядка є <code>NULL</code>.</p></div>
<div class="paragraph"><p>Створивши такий файл визначення, ви включаєте його двічі: один раз у заголовок, після вимови <code>#define CONF_CONTEXT STRUCT</code> та один раз у C-файлі, після вимови <code>#define CONF_CONTEXT TABLE</code>. Перший раз це визначає структуру <code>module_options_t</code>, а другий раз визначає таблицю, яка каже менеджеру конфігурації, як ним користуватися.</p></div>
<div class="paragraph"><p>Використовуючи таблицю, ви оголошуєте <code>const config_format_t</code>, який пов'язує поля з набором функцій для їх перевірки та нормалізації, списком абревіатур, викллючення та іншими функціями.</p></div>
<div class="paragraph"><p>Докладнішу інформацію див. у розділі <code>confdecl.h</code> та <code>conftypes.h</code>. Для прикладів використання див. <code>crypto_options.inc</code> або <code>mainloop_state.inc</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___5">Отримання сповіщень</h3>
<div class="paragraph"><p>Після використання цих макросів необхідно повідомити код управління підсистемою про конфігурацію/стан вашого модуля.</p></div>
<div class="paragraph"><p>Якщо ви пишете код конфігурації, вам знадобиться функція, яка приймає об’єкт конфігурації і діє на нього. Ця функція повинна бути безпечною для виклику кілька разів, оскільки Tor буде перенастроювати свої підсистеми кожного разу, коли він перечитує <code>torrc</code>, отримує зміну конфігурації від контролера або перезапускає процес. Ця функція знаходиться в полі <code>subsys_fns_t.set_options</code> підсистеми.</p></div>
<div class="paragraph"><p>Якщо ви пишете код стану, вам знадобиться функція, яка отримує стан (<code>subsys_fns_t.set_state</code>), і функція, яка перетворює стан програми в об'єкт стану (<code>subsys_fns_t.flush_state</code>). Функція <code>set_state</code> буде викликана один раз (1), коли Tor запускається, тоді як функція <code>flush_state</code> буде викликатися, коли Tor збирається зберегти стан на диску.</p></div>
<div class="paragraph"><p>Дивіться <code>subsys_fns_t</code> для отримання додаткової інформації тут, а також Ініціалізація та вимкнення для отримання додаткової інформації про ініціалізацію та підсистеми загалом.</p></div>
<div class="paragraph"><p>&gt;1. Технічно стан встановлюється один раз при запуску.</p></div>
<div class="paragraph"><p>Пам'ятайте, що Tor можна зупиняти і запускати кілька разів в тому самому процесі. Якщо це сталося, то ваша функція <code>set_state()</code> викликається один раз при кожному запуску Tor.</p></div>
</div>
<div class="sect2">
<h3 id="____11">Як це працює</h3>
<div class="paragraph"><p>Загальна логіка, яка використовується для обробки файлів конфігурації та стану, живе у <code>lib/confmgt</code>. На найвищому рівні об'єкт диспетчера конфігурації (<code>config_mgr_t</code>) підтримує список об'єктів конфігурації кожного модуля та список усіх їх полів. Коли користувач вказує значення конфігурації, менеджер з'ясовує, як проаналізувати його, де зберігати його та на який об’єкт конфігурації задіяний.</p></div>
<div class="paragraph"><p>Модуль конфігурації верхнього рівня (<code>config.c</code>) та модуль стану (<code>statefile.c</code>) використовують <code>config_mgr_t</code> для створення, ініціалізації, встановлення, порівняння та звільнення "об'єкта конфігурації верхнього рівня". Цей об'єкт містить перелік підоб’єктів: по одному для кожного модуля, який бере участь у системі конфігурації/стану. Цей код верхнього рівня потім викликає код менеджера підсистеми (<code>subsysmgr.c</code>) для передачі відповідної конфігурації або стану об'єктів кожному модулю, який має такий.</p></div>
<div class="paragraph"><p>Зауважте, що код верхнього рівня не має легкого доступу до об'єктів конфігурації, які використовуються підмодулями. Це відповідає задуму. Модуль може викрити деяку або всю його конфігурацію або об'єкт стану через функції аксессора, якщо бажаєте, але якщо його немає, цей об'єкт слід вважати локальним в межах модуля.</p></div>
</div>
<div class="sect2">
<h3 id="____12">Додавання нових типів</h3>
<div class="paragraph"><p>Поля конфігурації та стану мають "тип". Ці типи задають, як значення полів представлені в C; як вони зберігаються у файлах; і як вони кодуються при переміщенні вперед і назад.</p></div>
<div class="paragraph"><p>Існує набір вбудованих типів, перелічених у <code>conftypes.h</code>, але код вищого рівня може визначати його власні типи. Для цього ви робите екземпляр <code>var_type_fns_t</code>, який описує, як керувати своїм типом, і екземпляр <code>var_type_def_t</code>, який обертає ваш <code>var_type_fns_t</code> з іменем та необов'язковими параметрами та прапорами.</p></div>
<div class="paragraph"><p>Для прикладу того, як визначено тип вищого рівня, див. <code>ROUTERSET_type_defn</code> в <code>routerset.c</code>. Також дивіться <code>typedef config_decl_ROUTERSET</code>. Вони разом дозволяють використовувати тип маршрутизатора разом з макросами в <code>confdecl.h</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_____4">Стара конфігурація та стан</h3>
<div class="paragraph"><p>Станом на час написання цього тексту (листопад 2019 р.) більшість конфігурації та стану все ще обробляються безпосередньо у <code>config.c</code> та <code>statefile.c</code> та зберігаються у монолітних структурах <code>or_options_t</code> та <code>or_state_t</code> відповідно.</p></div>
<div class="paragraph"><p>До цих структур верхнього рівня звертаються за допомогою get_options () та get_state() та користувуються протягом більшої частини коду, на рівні ядра та вище.</p></div>
<div class="paragraph"><p>З часом ми сподіваємось переробити цю конфігурацію на більш розумні фрагменти, щоб вони більше не були (ефективно) глобальними змінними, що використовуються в коді.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_________tor">Публікація та підписка на повідомлення, що передаються в Tor</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__3">Вступ</h3>
<div class="paragraph"><p>Tor ввів загальний механізм публікації та підписки для доставки внутрішніх повідомлень. Це покликане допомогти нам покращити модульність нашого коду, уникаючи прямого зв'язку між модулями, які насправді не потребують виклику один одного.</p></div>
<div class="paragraph"><p>Цей механізм публікації та підписки не призначений для вирішення багатопотокових чи багатопроцесорних питань. Ми думаємо, що з часом він може бути розширений і адаптований для цієї мети. Натомість ми сьогодні використовуємо публікацію-підписку для роз’єднання модулів, які не повинні викликати один одного безпосередньо.</p></div>
<div class="paragraph"><p>Наприклад, є численні частини нашого коду, які, можливо, повинні вжити заходів, коли ланцюг завершено: можливо, потрібно повідомити контролер, можливо, потрібно буде приєднати переговори щодо обслуговування цибулі, можливо, варто охопити позначку як працюючу, або можливо, потрібно підключити клієнтське з'єднання. Але багато з цих дій відбувається на більш високому рівні, ніж завершення ланцюга: виклик їх безпосередньо є порушенням рівня, і робить наш код важчим для розуміння та аналізу.</p></div>
<div class="paragraph"><p>Але, передаючи повідомлення, ми можемо перевернути це порушення шару: завершення схеми може стати "повідомленням", яке публікує код схеми, і на які підписуються шари вищого рівня. Це означає, що керування ланцюгами можна від'єднати від модулів вищого рівня та залишатися приємними та простими. (1)</p></div>
<div class="paragraph"><p>(1). На жаль, як і більшість нашого коду, обробка схеми ще не відновлена ​​для використання публікації-підписки впродовж усього процессу. Натомість порушення, описані тут, досить часто зустрічаються в Tor. Щоб побачити невелику частину того, що відбувається сьогодні, коли схема завершена, перегляньте <code>circuit_build_no_more_hops()</code>, та пов'язаний з ним код.</p></div>
</div>
<div class="sect2">
<h3 id="_____5">Канали та політика доставки</h3>
<div class="paragraph"><p>Для роботи з повідомленнями, особливо при рефакторингу існуючого коду, вам потрібно зрозуміти "канали" та "політику доставки".</p></div>
<div class="paragraph"><p>Кожне повідомлення доставляється на "каналі повідомлень". Кожен канал (концептуально) структура схожа на чергу, яка може підтримувати довільну кількість типів повідомлень. Якщо канали різняться, це механізми їх доставки та гарантії щодо того, коли обробляються повідомлення.</p></div>
<div class="paragraph"><p>Наразі можливі три політики доставки:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>DELIV_PROMPT</code> - викликає обробку повідомлень за допомогою зворотного виклику в циклі подій Tor. Це, як правило, найкращий вибір, оскільки це дозволяє уникнути несподіваного зростання стека.
</p>
</li>
<li>
<p>
<code>DELIV_IMMEDIATE</code> - викликає негайну обробку повідомлень у стеку викликів при їх публікації. Цей вибір збільшує стек і може призвести до несподіваної складності в графіку викликів. Ми повинні використовувати його лише при необхідності.
</p>
</li>
<li>
<p>
<code>DELIV_NEVER</code> - призводить до того, що система передачі повідомлень взагалі не надсилає повідомлення. Натомість, якась інша частина коду повинна викликати <code>dispatch_flush()</code>, щоб доставити повідомлення.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Див. <code>mainloop_pubsub.c</code> та <code>mainloop_pubsub.h</code> для отримання додаткової інформації та відомостей про реалізацію.</p></div>
</div>
<div class="sect2">
<h3 id="___vs___vs_mainloop">Рівні: диспетчеризація vs публікації-підписки vs mainloop.</h3>
<div class="paragraph"><p>На найнижчому рівні повідомлення надсилаються через модуль <code>"dispatcher"</code> в <code>lib/dispeatch.</code> Для продуктивності цей диспетчер працює з нетипізованими повідомленнями. Видавці, підписники, канали та повідомлення відрізняються короткими цілими числами. Пов'язані дані обробляються як динамічно типізовані покажчики даних, а їх типи також зберігаються у вигляді коротких цілих чисел.</p></div>
<div class="paragraph"><p>Звичайно, це призводить до небезпечного типу API API, тому більшість інших модулів не повинні викликати <code>lib/dispatch</code> безпосередньо. На більш високому рівні <code>lib/pubsub</code> визначає набір функцій та макросів, які роблять повідомлення іменованими та безпечними для типу. Це те, що повинні використовувати інші модулі, коли вони хочуть надіслати або отримати повідомлення.</p></div>
<div class="paragraph"><p>Два вищевказані модулі не обробляють доставку повідомлень. Натомість модуль відправки приймає зворотний виклик, який може викликати, коли канал стає порожнім, і визначає функцію <code>dispatch_flush()</code> для доставки всіх повідомлень, що стоять у черзі в каналі. Робота над тим, щоб переконатися, що <code>dispatch_flush()</code> викликається, коли це доцільно, потрапляє в основний цикл, який повинен інтегрувати диспетчер повідомлень з рештою наших подій та зворотних викликів. Ця робота відбувається в <code>mainloop_pubsub.c</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_____6">Як публікувати та підписуватись</h3>
<div class="paragraph"><p>У цьому розділі наведено огляд способів створення нових повідомлень та способів їх використання. Для отримання детальної інформації див. <code>pubsub_macros.h</code>.</p></div>
<div class="paragraph"><p>Перш ніж хтось може опублікувати або підписатись на повідомлення, повідомлення повинно бути оголошено, як правило, у заголовку. Для цього використовується <code>DECLARE_MESSAGE()</code> або <code>DECLARE_MESSAGE_INT()</code>.</p></div>
<div class="paragraph"><p>Лише підсистеми можуть публікувати або передплачувати повідомлення. Для отримання додаткової інформації про архітектуру підсистем див. Ініціалізацію та вимкнення.</p></div>
<div class="paragraph"><p>Щоб опублікувати повідомлення, ви повинні:</p></div>
<div class="ulist"><ul>
<li>
<p>
Додайте заголовок, який оголошує повідомлення.
</p>
</li>
<li>
<p>
Оголосіть набір допоміжних функцій за допомогою <code>DECLARE_PUBLISH()</code>. Вони повинні бути видимі там, де ви телефонуєте <code>PUBLISH()</code>.
</p>
</li>
<li>
<p>
Зателефонуйте <code>PUBLISH()</code>, щоб фактично надіслати повідомлення.
</p>
</li>
<li>
<p>
Підключіть свою підсистему до диспетчера, викликавши <code>DISPATCH_ADD_PUB()</code> з зворотного виклику підсистеми <code>subsys_fns_t.add_pubsub</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Щоб підписатися на повідомлення, необхідно:</p></div>
<div class="ulist"><ul>
<li>
<p>
Додайте заголовок, який оголошує повідомлення.
</p>
</li>
<li>
<p>
Визначте функцію зворотного виклику, яку потрібно викликати під час доставки повідомлення.
</p>
</li>
<li>
<p>
Use DISPATCH_SUBSCRIBE at file scope to define a set of wrapper functions to call your callback function with the appropriate type.
</p>
</li>
<li>
<p>
Використовуйте <code>DISPATCH_SUBSCRIBE</code> в області файлу, щоб визначити набір функцій обгортки для виклику функції зворотного виклику відповідного типу.
</p>
</li>
<li>
<p>
Підключіть свою підсистему до диспетчера, викликавши <code>DISPATCH_ADD_SUB ()</code> зі зворотного виклику підсистеми <code>subsys_fns_t.add_pubsub</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Знову ж таки, документація на рівні файлу для <code>pubsub_macros.h</code> описує, як оголосити повідомлення, як його опублікувати та як підписатись на нього.</p></div>
</div>
<div class="sect2">
<h3 id="____13">Створення хороших повідомлень</h3>
<div class="paragraph"><p>Частота: система публікації-підписки використовує кілька викликів функцій та розподілів для кожного надісланого повідомлення. Це робить його непридатним для подій з дуже високою пропускною здатністю, наприклад "отримання однієї комірки даних" або "сокет став доступним для запису". Однак це добре для подій, які зазвичай трапляються трохи рідше, ніж це, як, наприклад, закінчення ланцюга, відкриття нового з'єднання тощо.</p></div>
<div class="paragraph"><p>Семантика: Повідомлення повинно зазначати, що щось сталося чи відбувається, а не що-небудь зокрема має бути зроблене.</p></div>
<div class="paragraph"><p>Наприклад, припустимо, ви хочете налаштувати повідомлення так, щоб сервіси цибулі очищали кеші їх відтворення, коли нам не вистачає пам’яті. Подія повинна бути чимось на зразок <code>memory_low</code>, а не <code>clean_up_replay_caches</code>. Остання назва означала б, що видавець знав, хто підписує повідомлення, і що вони мають на меті з цим зробити, що було б порушенням рівнів.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-05-07 22:58:41 EEST
</div>
</div>
</body>
</html>
