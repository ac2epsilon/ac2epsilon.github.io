<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_linux_kernel_crypto_api">Linux Kernel Crypto API</h2>
<div class="sectionbody">
<div class="paragraph"><p>Author: Stephan Mueller, Marek Vasut</p></div>
<div class="paragraph"><p>У цій документації викладено крипто API ядра Linux з його концепціями, деталі щодо розробки реалізацій шифрів, використання API для випадків використання криптографічного використання, а також приклади програмування.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____api">Специфікація інтерфейсу крипто API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>Крипто API ядра пропонує багатий набір криптографічних шифрів, а також інші механізми трансформації даних та методи їх виклику. Цей документ містить опис API та надає приклад коду.</p></div>
<div class="paragraph"><p>Для розуміння та правильного використання крипто-API ядра наведено коротке пояснення його структури. Виходячи з архітектури, API можна розділити на різні компоненти. Після специфікації архітектури надаються підказки розробникам шифрів. Вказівки на документацію щодо виклику функції API наводяться в кінці.</p></div>
<div class="paragraph"><p>Крипто API ядра називає всі алгоритми "трансформаціями". Тому змінна ручка шифру зазвичай має назву <code>"tfm"</code>. Крім криптографічних операцій, крипто API також знає перетворення стиснення і обробляє їх так само, як і шифри.</p></div>
<div class="paragraph"><p>Крипто API ядра обслуговує такі типи об'єктів:</p></div>
<div class="ulist"><ul>
<li>
<p>
споживачі, які запитують криптографічні послуги
</p>
</li>
<li>
<p>
реалізації перетворень даних (як правило, шифри), які можуть викликати споживачі за допомогою крипто API
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця специфікація призначена для споживачів криптовалютного API ядра, а також для розробників, що реалізують шифри. Ця специфікація API, однак, не обговорює всі виклики API, доступні для реалізації перетворень даних (тобто реалізація шифрів та інші перетворення (наприклад, CRC або навіть алгоритми стиснення), які можуть реєструватися в крипто API).</p></div>
<div class="paragraph"><p>Примітка: Терміни "перетворення" та шифровий алгоритм використовуються взаємозамінно.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Термінологія</h3>
<div class="paragraph"><p>Реалізація перетворення - це фактичний код або інтерфейс до апаратного забезпечення, який реалізує певну трансформацію з точно визначеною поведінкою.</p></div>
<div class="paragraph"><p>Об'єкт перетворення (TFM) - це примірник здійснення перетворення. З однією реалізацією перетворення може бути асоційовано кілька об'єктів перетворення. Кожен з цих об'єктів трансформації утримується споживачем крипто API або іншою трансформацією. Об'єкт трансформації виділяється, коли споживач криптовалютного API вимагає здійснення перетворення. Потім споживачеві надається структура, яка містить об'єкт перетворення (TFM).</p></div>
<div class="paragraph"><p>Структура, що містить об'єкти перетворення, також може називатися "ручкою шифру". Така ручка шифру завжди підпорядкована наступним фазам, які відображаються у викликах API, застосовних до такої ручки шифру:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Ініціалізація ручки шифру.
</p>
</li>
<li>
<p>
Ви конання всіх призначених для шифрування операцій, застосовних до ручки, де ручка шифру повинна бути забезпечена кожному виклику API.
</p>
</li>
<li>
<p>
Знищення ручки шифру.
</p>
</li>
</ol></div>
<div class="paragraph"><p>При використанні викликів API ініціалізації створюється ручка шифру і повертається споживачеві. Тому, будь ласка, зверніться до всіх викликів API ініціалізації, які стосуються типу структури даних, який, як очікується, отримає споживач і згодом буде використовувати. Виклики API ініціалізації мають усі однакові умови іменування <code>crypto_alloc*</code>.</p></div>
<div class="paragraph"><p>Контекст перетворення - це приватні дані, пов'язані з об'єктом перетворення.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____api_2">Ядро криптовалютної архітектури API</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="___">Типи алгоритму шифрування</h3>
<div class="paragraph"><p>Крипто API API ядра забезпечує різні виклики API для таких типів шифрів:</p></div>
<div class="ulist"><ul>
<li>
<p>
Симетричні шифри
</p>
</li>
<li>
<p>
Шифри AEAD
</p>
</li>
<li>
<p>
Дайджест повідомлень, включаючи дайджест ключових повідомлень
</p>
</li>
<li>
<p>
Генерація випадкових чисел
</p>
</li>
<li>
<p>
Інтерфейс користувальницького простору
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____2">Шифри та шаблони</h2>
<div class="sectionbody">
<div class="paragraph"><p>Крипто API ядра забезпечує реалізацію одноблокових шифрів та дайджестів повідомлень. Крім того, крипто API ядра надає численні "шаблони", які можуть використовуватися спільно з шифрами єдиного блоку та дайджестами повідомлень. Шаблони включають всі типи блочного режиму ланцюга, механізм HMAC тощо.</p></div>
<div class="paragraph"><p>Одноблокові шифри та дайджести повідомлень можуть або безпосередньо використовуватися абонентом, або викликатися разом із шаблоном для формування багатоблокових шифрів або наборів ключових повідомлень.</p></div>
<div class="paragraph"><p>Одиночний блок-шифр може навіть викликатися з декількома шаблонами. Однак шаблони не можна використовувати без єдиного шифру.</p></div>
<div class="paragraph"><p>Перегляньте <code>/proc/crypto</code> та знайдіть "ім'я". Наприклад:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>aes
ecb(aes)
cmac(aes)
ccm(aes)
rfc4106(gcm(aes))
sha1
hmac(sha1)
authenc(hmac(sha1),cbc(aes))</code></pre>
</div></div>
<div class="paragraph"><p>У цих прикладах "aes" і "sha1" - це шифри, а всі інші - шаблони.</p></div>
<div class="sect2">
<h3 id="____">Синхронні та асинхронні операції</h3>
<div class="paragraph"><p>Крипто-API ядра забезпечує синхронні та асинхронні операції API.</p></div>
<div class="paragraph"><p>Під час використання синхронної операції API, абонент викликає операцію шифрування, яка синхронно виконується крипто API. Це означає, що абонент чекає, поки закінчиться операція шифрування. Тому виклики крипто API ядра працюють як звичайні виклики функцій. Для синхронної роботи набір викликів API невеликий і концептуально схожий з будь-якою іншою крипто бібліотекою.</p></div>
<div class="paragraph"><p>Асинхронна операція забезпечується крипто-API ядра, що означає, що виклик шифрованої операції завершиться майже миттєво. Це виклик запускає роботу шифру, але не сигналізує про його завершення. Перед тим, як викликати операцію з шифруванням, абонент повинен надати функцію зворотного виклику, яку може викликати крипто API ядра, щоб сигналізувати про завершення операції шифрування. Крім того, абонент повинен переконатися, що він може обробляти такі асинхронні події, застосовуючи відповідне блокування навколо своїх даних. Крипто-API ядра не виконує жодної спеціальної операції серіалізації для захисту цілісності даних абонента.</p></div>
</div>
<div class="sect2">
<h3 id="____api__">Посилання на крипто-API та пріоритет</h3>
<div class="paragraph"><p>Шифр посилається абонентом за допомогою рядка. Цей рядок має таку семантику:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>шаблон (одноблоковий шифр)</code></pre>
</div></div>
<div class="paragraph"><p>де "шаблон" і "одноблоковий шифр" є вищезгаданим шаблоном і одноблоковим шифром відповідно. Якщо можливо, додаткові шаблони можуть містити інші шаблони, такі як</p></div>
<div class="listingblock">
<div class="content">
<pre><code>шбалон1 (шаблон2 (одноблоковий шифр)))</code></pre>
</div></div>
<div class="paragraph"><p>Крипто API ядра може надавати кілька реалізацій шаблону або одного блочного шифру. Наприклад, AES для новіших апаратних засобів Intel має такі реалізації: AES-NI, реалізація асемблера або прямий C. Тепер, коли використовується рядок "aes" з крипто API ядра, яка шифрована реалізація використовується? Відповідь на це питання - номер пріоритету, присвоєний кожній програмі шифрування крипто API. Коли абонент використовує рядок для посилання на шифр під час ініціалізації ручки шифру, крипто API шукає всі реалізації, що забезпечують реалізацію з цим ім'ям, і вибирає реалізацію з найвищим пріоритетом.</p></div>
<div class="paragraph"><p>Тепер у абонента може виникнути потреба звернутися до конкретної програми шифрування, і тому він не хоче покладатися на вибір, орієнтований на пріоритет. Для адаптації до цього сценарію крипто API ядра дозволяє реалізації шифрованому реєструвати унікальне ім’я на додаток до загальних імен. При використанні цього унікального імені, абонент завжди повинен обов'язково посилатися на передбачувану реалізацію шифру.</p></div>
<div class="paragraph"><p>Список доступних шифрів наведено в <code>/proc/crypto</code>. Однак у цьому списку не вказані всі можливі перестановки шаблонів та шифрів. Кожен блок, перелічений у <code>/proc/crypto</code>, може містити таку інформацію - якщо один із перелічених нижче компонентів не застосовується до шифру, він не відображається:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>name</code>: загальне ім'я шифру, що підлягає вибору на основі пріоритету - це ім'я може використовуватися при виклику API розподілу шифрів (усі перелічені вище імена є прикладами для таких загальних імен)
</p>
</li>
<li>
<p>
<code>driver</code>: унікальне ім'я шифру - це ім'я може використовуватися при виклику API розподілу шифрів
</p>
</li>
<li>
<p>
<code>module</code>: модуль ядра, що забезпечує реалізацію шифру (або "ядро" для статично пов'язаних шифрів)
</p>
</li>
<li>
<p>
<code>priority</code>: пріоритетне значення реалізації шифру
</p>
</li>
<li>
<p>
<code>refcnt</code>: кількість посилань відповідного шифру (тобто кількість поточних споживачів цього шифру)
</p>
</li>
<li>
<p>
<code>selftest</code>: уточнення, чи пройшов самотест для шифру
</p>
</li>
<li>
<p>
<code>type</code>:
</p>
<div class="ulist"><ul>
<li>
<p>
<code>skcipher</code> для симетричних ключових шифрів
</p>
</li>
<li>
<p>
<code>cipher</code> для одноблокових шифрів, які можуть використовуватися з додатковим шаблоном
</p>
</li>
<li>
<p>
<code>shash</code> для синхронного дайджесту повідомлень
</p>
</li>
<li>
<p>
<code>ahash</code> для асинхронного дайджесту повідомлень
</p>
</li>
<li>
<p>
<code>aead</code> для типу шифру AEAD
</p>
</li>
<li>
<p>
<code>compression</code> для перетворень типу стиснення
</p>
</li>
<li>
<p>
<code>rng</code> для генератора випадкових чисел
</p>
</li>
<li>
<p>
<code>givcipher</code> для шифру з пов'язаним IV генератором (див. запис geniv нижче для специфікації типу IV генератора, використовуваного при впровадженні шифру)
</p>
</li>
<li>
<p>
<code>kpp</code> для шифрувального протоколу протоколу ключових угод (KPP), такого як виконання ECDH або DH
</p>
</li>
</ul></div>
</li>
<li>
<p>
<code>blocksize</code>: блокування шифру в байтах
</p>
</li>
<li>
<p>
<code>keysize</code>: розмір ключа в байтах
</p>
</li>
<li>
<p>
<code>ivsize</code>: IV розмір у байтах
</p>
</li>
<li>
<p>
<code>seedsize</code>: необхідний розмір даних зерня для генератора випадкових чисел
</p>
</li>
<li>
<p>
<code>digestsize</code>: розмір виводу дайджесту повідомлень
</p>
</li>
<li>
<p>
<code>geniv</code>: тип генерації IV:
</p>
<div class="ulist"><ul>
<li>
<p>
<code>eseqiv</code> для зашифрованого порядкового номера на основі генерації IV покоління
</p>
</li>
<li>
<p>
<code>seqiv</code> для послідовного номера на основі генерації IV
</p>
</li>
<li>
<p>
<code>chainiv</code> для генерації ланцюга iv
</p>
</li>
<li>
<p>
<code>&lt;builtin&gt;</code> - маркер, за допомогою якого шифр реалізує генерацію IV та обробку, оскільки він специфічний для даного шифру
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="__">Розміри ключів</h3>
<div class="paragraph"><p>Виділяючи ручку шифру, абонент визначає лише тип шифру. Однак симетричні шифри, як правило, підтримують кілька розмірів ключа (наприклад, AES-128 vs. AES-192 vs. AES-256). Ці розміри ключів визначаються довжиною наданого ключа. Таким чином, крипто API ядра не забезпечує окремого способу вибору конкретного розміру ключа симетричного шифру.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Тип виділення шифрів і маски</h3>
<div class="paragraph"><p>Різні функції розподілу ручок шифрів дозволяють задати тип та прапор маски. Обидва параметри мають наступне значення (і тому не висвітлюються в наступних розділах).</p></div>
<div class="paragraph"><p>Прапор типу визначає тип алгоритму шифрування. Абонент, як правило, отримує 0, коли абонент хоче обробку за замовчуванням. В іншому випадку абонент може надати наступні варіанти, які відповідають вищезазначеним типам шифрів:</p></div>
<div class="paragraph"><p><code>CRYPTO_ALG_TYPE_CIPHER</code> Одноблочний шифр
<code>CRYPTO_ALG_TYPE_COMPRESS</code> Стиснення
<code>CRYPTO_ALG_TYPE_AEAD</code> Автентифіковане шифрування з пов’язаними даними (MAC)
<code>CRYPTO_ALG_TYPE_BLKCIPHER</code> Синхронний багатоблоковий шифр
<code>CRYPTO_ALG_TYPE_ABLKCIPHER</code> Асинхронний багатоблоковий шифр
<code>CRYPTO_ALG_TYPE_GIVCIPHER</code> Асинхронний багатоблоковий шифр, упакований разом з IV генератором (див. <code>geniv</code> поле у ​​списку <code>/proc/crypto</code> для відомих IV генераторів)
<code>CRYPTO_ALG_TYPE_KPP</code> Примітив протокла ключових угод (KPP), такий як впровадження ECDH або DH
<code>CRYPTO_ALG_TYPE_DIGEST</code> Дайджест сирого повідомлення
<code>CRYPTO_ALG_TYPE_HASH</code> Псевдонім для <code>CRYPTO_ALG_TYPE_DIGEST</code>
<code>CRYPTO_ALG_TYPE_SHASH</code> Синхронний мультиблоковий хеш
<code>CRYPTO_ALG_TYPE_AHASH</code> Асинхронний мультиблоковий хеш
<code>CRYPTO_ALG_TYPE_RNG</code> Генерація випадкових чисел
<code>CRYPTO_ALG_TYPE_AKCIPHER</code> Асиметричний шифр
<code>CRYPTO_ALG_TYPE_PCOMPRESS</code> Розширена версія CRYPTO_ALG_TYPE_COMPRESS, що дозволяє сегментувати компресію/декомпресію замість виконання операції лише на одному сегменті. <code>CRYPTO_ALG_TYPE_PCOMPRESS</code> призначений замінити <code>CRYPTO_ALG_TYPE_COMPRESS</code> після перетворення існуючих споживачів.</p></div>
<div class="paragraph"><p>Прапор маски обмежує тип шифру. Єдиний дозволений прапор - це <code>CRYPTO_ALG_ASYNC</code> для обмеження функції пошуку шифрів асинхронними шифрами. Зазвичай абонент надає 0 для прапора маски.</p></div>
<div class="paragraph"><p>Коли абонент надає специфікацію маски та типу, виклик обмежує пошук, який може виконувати крипто API API ядра для відповідної реалізації шифру для даного імені шифру. Це означає, що навіть коли абонент використовує ім'я шифру, яке існує під час його виклику ініціалізації, API криптовалути ядра може не вибрати його через використовуваний тип та поля маски.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____api_3">Внутрішня структура крипто API</h2>
<div class="sectionbody">
<div class="paragraph"><p>API крипто ядра має внутрішню структуру, де шифрована реалізація може використовувати багато шарів та непрямих напрямків. Цей розділ допоможе з’ясувати, як крипто API API використовує різні компоненти для реалізації повного шифру.</p></div>
<div class="paragraph"><p>Наступні підрозділи пояснюють внутрішню структуру на основі існуючих шифрованих реалізацій. Перший розділ стосується найскладнішого сценарію, коли всі інші сценарії утворюють логічну підмножину.</p></div>
<div class="sect2">
<h3 id="____aead">Загальна структура шифрів AEAD</h3>
<div class="paragraph"><p>Наступне мистецтво ASCII розкладає шари API криптовалюти ядра при використанні шифру AEAD з автоматизованою генерацією IV. Наведений приклад використовується шаром IPSEC.</p></div>
<div class="paragraph"><p>Для інших випадків використання шифрів AEAD застосовується також мистецтво ASCII, але абонент може не використовувати шифр AEAD з окремим IV генератором. У цьому випадку абонент повинен генерувати IV.</p></div>
<div class="paragraph"><p>Наведений приклад розкладає шифр AEAD GCM (AES) на основі загальних реалізацій C (<code>gcm.c</code>, <code>aes-generic.c</code>, <code>ctr.c</code>, <code>ghash-generic.c</code>, <code>seqiv.c</code>). Загальна реалізація слугує прикладом, що показує повну логіку крипто API ядра.</p></div>
<div class="paragraph"><p>Можливо, що деякі обтічні реалізації шифрів (наприклад, AES-NI) забезпечують реалізацію об'єднуючих аспектів, які з точки зору крипто API не можуть розкладатися на шари. У разі реалізації AES-NI режим CTR, реалізація GHASH та шифр AES об'єднуються в одну реалізацію шифру, зареєстровану за допомогою крипто API ядра. У цьому випадку також застосовується концепція, описана в наступному мистецтві ASCII. Однак декомпозиція GCM на окремі підкомпоненти за допомогою крипто-API ядра вже не робиться.</p></div>
<div class="paragraph"><p>Кожен блок у наступному мистецтві ASCII є незалежним екземпляром шифру, отриманим від крипто API ядра. До кожного блоку звертається абонент або інші блоки з використанням функцій API, визначених крипто API ядра для типу реалізації шифру.</p></div>
<div class="paragraph"><p>Блоки нижче вказують тип шифру, а також певну логіку, реалізовану в шифрі.</p></div>
<div class="paragraph"><p>Зображення мистецтва ASCII також вказує структуру виклику, тобто хто викликає, який компонент. Стрілки вказують на викликаний блок, де абонент використовує API, застосовний до типу шифру, визначеного для блоку.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>kernel crypto API                                |   IPSEC Layer
                                                 |
+-----------+                                    |
|           |            (1)
|   aead    | &lt;-----------------------------------  esp_output
|  (seqiv)  | ---+
+-----------+    |
                 | (2)
+-----------+    |
|           | &lt;--+                (2)
|   aead    | &lt;-----------------------------------  esp_input
|   (gcm)   | ------------+
+-----------+             |
      | (3)               | (5)
      v                   v
+-----------+       +-----------+
|           |       |           |
|  skcipher |       |   ahash   |
|   (ctr)   | ---+  |  (ghash)  |
+-----------+    |  +-----------+
                 |
+-----------+    | (4)
|           | &lt;--+
|   cipher  |
|   (aes)   |
+-----------+</code></pre>
</div></div>
<div class="paragraph"><p>Наступна послідовність викликів застосовна, коли рівень IPSEC запускає операцію шифрування за допомогою функції <code>esp_output</code>. Під час конфігурації адміністратор встановив використання rfc4106 (gcm (aes)) в якості шифру для ESP. Наступна послідовність викликів тепер зображена в області ASCII вище:</p></div>
<div class="paragraph"><p><code>esp_output()</code> викликає <code>crypto_aead_encrypt()</code>, щоб запустити операцію шифрування шифру AEAD з IV генератором.</p></div>
<div class="paragraph"><p>У випадку GCM реалізація SEQIV реєструється як GIVCIPHER у <code>crypto_rfc4106_alloc()</code>.</p></div>
<div class="paragraph"><p>SEQIV виконує свою операцію з генерування IV, де основною функцією є <code>seqiv_geniv()</code>.</p></div>
<div class="paragraph"><p>Тепер SEQIV використовує виклики функції AEAD API, щоб викликати пов'язаний AEAD шифр. У нашому випадку під час інстанції SEQIV ручка шифру для GCM надається SEQIV. Це означає, що SEQIV викликає операції шифрування AEAD за допомогою ручки шифру GCM.</p></div>
<div class="paragraph"><p>Під час створення екземпляра рукоятки GCM інстанціюються шифри CTR (AES) та GHASH. Ручки шифрів для CTR (AES) та GHASH зберігаються для подальшого використання.</p></div>
<div class="paragraph"><p>Реалізація GCM несе відповідальність за виклик AES режиму CTR та шифру GHASH належним чином для реалізації специфікації GCM.</p></div>
<div class="paragraph"><p>Реалізація типу шифрування AEAD GCM тепер викликає API SKCIPHER з інстанційною ручкою шифру CTR (AES).</p></div>
<div class="paragraph"><p>Під час інстанціювання шифру CTR (AES), реалізація AES типу CIPHER інстанціюється. Ручка шифру для AES збережена.</p></div>
<div class="paragraph"><p>Це означає, що SKCIPHER реалізація CTR(AES) реалізує лише режим ланцюга блоків CTR. Після виконання операції зціплення блоків викликається CIPHER реалізація AES.</p></div>
<div class="paragraph"><p>Тепер SKCIPHER CTR(AES) викликає API CIPHER за допомогою шифру AES для шифрування одного блоку.</p></div>
<div class="paragraph"><p>Реалізація GCM AEAD також викликає реалізацію шифру GHASH через API AHASH.</p></div>
<div class="paragraph"><p>Коли рівень IPSEC запускає функцію <code>esp_input()</code>, слідує та сама послідовність викликів з тією лише різницею, що операція починається з кроку (2).</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Загальна структура блокового шифру</h3>
<div class="paragraph"><p>Універсальні блок-шифри дотримуються тієї ж концепції, що зображена на зображенні ASCII мистецтва вище.</p></div>
<div class="paragraph"><p>Наприклад, CBC(AES) реалізований за допомогою <code>cbc.c</code> та <code>aes-generic.c</code>. Зображення мистецтва ASCII вище застосовується також з тією різницею, що використовується лише крок (4), а режимом ланцюга блоків SKCIPHER є CBC.</p></div>
</div>
<div class="sect2">
<h3 id="______">Загальна структура дайжестів повідомлень з ключами</h3>
<div class="paragraph"><p>Реалізації дайджестів ключових повідомлень знову слідують тій самій концепції, що зображена на малюнку ASCII мистецтва вище.</p></div>
<div class="paragraph"><p>Наприклад, HMAC (SHA256) реалізований з <code>hmac.c</code> та <code>sha256_generic.c</code>. Наступне мистецтво ASCII ілюструє реалізацію:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>kernel crypto API            |       Caller
                             |
+-----------+         (1)    |
|           | &lt;------------------  some_function
|   ahash   |
|   (hmac)  | ---+
+-----------+    |
                 | (2)
+-----------+    |
|           | &lt;--+
|   shash   |
|  (sha256) |
+-----------+</code></pre>
</div></div>
<div class="paragraph"><p>Наступна послідовність викликів застосовується, коли абонент запускає операцію HMAC:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Функції API AHASH викликаються абонентом. Реалізація HMAC виконує свою роботу за потребою.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Під час ініціалізації шифру HMAC інстанціюється тип шифра SHASH типу SHA256. Ручка шифру для екземпляра SHA256 збережена.</p></div>
<div class="paragraph"><p>Свого часу реалізація HMAC вимагає операції SHA256, де використовується ручка шифру SHA256.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Екземпляр HMAC тепер викликає API SHASH за допомогою шифру SHA256 для обчислення дайджесту повідомлень.
</p>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____3">Розробка алгоритмів шифрів</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="______2">Реєстрація та де-реєстрація трансформації</h3>
<div class="paragraph"><p>У Crypto API існує три різних типи функції реєстрації. Один використовується для реєстрації загальної криптографічної трансформації, а два інших є специфічними для перетворень HASH та COMPRESS. Останні два ми обговоримо в окремій главі, тут ми розглянемо лише загальне.</p></div>
<div class="paragraph"><p>Перш ніж обговорювати функції регістру, слід врахувати структуру даних, яку слід заповнити, <code>struct crypto_alg</code> - див. Опис цієї структури даних нижче.</p></div>
<div class="paragraph"><p>Загальні функції реєстрації можна знайти в <code>include/linux/crypto.h</code>, їх визначення можна побачити нижче. Перша функція реєструє єдине перетворення, тоді як остання працює над масивом дескрипторів перетворень. Останнє корисно при реєстрації перетворень масово, наприклад, коли драйвер здійснює кілька перетворень.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">crypto_register_alg</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">crypto_register_algs</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_alg</span> <span class="o">*</span><span class="n">algs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Нижче перераховані доповнення до цих функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">crypto_unregister_alg</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">crypto_unregister_algs</span><span class="p">(</span><span class="k">struct</span> <span class="n">crypto_alg</span> <span class="o">*</span><span class="n">algs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що функції реєстрації та дереєстрації повертають значення, тому обов'язково обробляйте помилки. Код повернення нуля означає успіх. Будь-який код повернення &lt;0 означає помилку.</p></div>
<div class="paragraph"><p>Функції масової реєстрації/дереєстрації реєструють/скасовують кожне перетворення у заданому масиві довжини <code>count</code>. Вони обробляють помилки наступним чином:</p></div>
<div class="paragraph"><p><code>crypto_register_algs()</code> досягає успіху лише тоді, коли успішно реєструє всі задані перетворення. Якщо помилка трапляється частково, вона скасовує успішні реєстрації перед поверненням коду помилки. Зауважте, що якщо драйверу необхідно обробляти помилки реєстрації для окремих перетворень, тоді він повинен буде використовувати замість нього функцію <code>crypto_register_alg()</code>.</p></div>
<div class="paragraph"><p><code>crypto_unregister_algs()</code> намагається скасувати реєстрацію всіх заданих перетворень, продовжуючи помилку. Він реєструє помилки і завжди повертає нуль.</p></div>
</div>
<div class="sect2">
<h3 id="____cifher">Одноблокові симетричні шифри [CIFHER]</h3>
<div class="paragraph"><p>Приклад перетворень: aes, arc4, &#8230;</p></div>
<div class="paragraph"><p>У цьому розділі описано найпростішу з усіх реалізацій перетворення, який є типом CIPHER, що використовується для симетричних шифрів. Тип CIPHER використовується для перетворень, які працюють на одному блоці за один раз і взагалі відсутні залежності між блоками.</p></div>
<div class="sect3">
<h4 id="___2">Особливості реєстрації</h4>
<div class="paragraph"><p>Реєстрація алгоритму [CIPHER] є специфічною у тому, що в структурі  <code>crypto_alg</code> поля <code>.cra_type</code> порожнє. <code>.cra_u.cipher</code> має бути заповнений відповідними зворотними викликами для здійснення цієї трансформації.</p></div>
<div class="paragraph"><p>Див. Структуру cipher_alg нижче.</p></div>
</div>
<div class="sect3">
<h4 id="____struct_cipher_alg">Визначення шифру в struct cipher_alg</h4>
<div class="paragraph"><p><code>Struct cipher_alg</code> визначає шифр з одним блоком.</p></div>
<div class="paragraph"><p>Ось схеми того, як викликаються ці функції при роботі з іншою частиною ядра. Зауважте, що виклик <code>.cia_setkey()</code> може статися до або після того, як відбудеться будь-яка з цих схем, але не повинно відбуватися під час польоту.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>KEY ---.    PLAINTEXT ---.
       v                 v
 .cia_setkey() -&gt; .cia_encrypt()
                         |
                         '-----&gt; CIPHERTEXT</code></pre>
</div></div>
<div class="paragraph"><p>Зверніть увагу, що шаблон, де <code>.cia_setkey()</code> викликається кілька разів, також дійсний:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>KEY1 --.    PLAINTEXT1 --.         KEY2 --.    PLAINTEXT2 --.
       v                 v                v                 v
 .cia_setkey() -&gt; .cia_encrypt() -&gt; .cia_setkey() -&gt; .cia_encrypt()
                         |                                  |
                         '---&gt; CIPHERTEXT1                  '---&gt; CIPHERTEXT2</code></pre>
</div></div>
</div>
</div>
<div class="sect2">
<h3 id="___3">Багатоблокові шифри</h3>
<div class="paragraph"><p>Приклад перетворень: cbc (aes), ecb (arc4), &#8230;</p></div>
<div class="paragraph"><p>У цьому розділі описано реалізацію багато блочного шифрування. Багатоблокові шифри використовуються для перетворень, які працюють на розсипчастому списку даних, що надходять до функцій перетворення. Вони також виводять результат у розкидний список даних.</p></div>
<div class="sect3">
<h4 id="___4">Особливості реєстрації</h4>
<div class="paragraph"><p>Реєстрація багатоблокових шифрових алгоритмів є однією з найбільш стандартних процедур у крипто-API.</p></div>
<div class="paragraph"><p>Зауважте, якщо шифрована реалізація вимагає належного вирівнювання даних, абонент повинен використовувати функції <code>crypto_skcipher_alignmask()</code> для ідентифікації маски вирівнювання пам'яті. API криптовалюти ядра здатний обробляти запити, які не відповідають вимогам. Це означає, однак, додаткові накладні витрати, оскільки крипто API ядра повинен виконувати перестановку даних, що може передбачати переміщення даних.</p></div>
</div>
<div class="sect3">
<h4 id="_____blkcipher_alg__ablkcipher_alg">Визначення шифру в структурах blkcipher_alg та ablkcipher_alg</h4>
<div class="paragraph"><p>Структура <code>blkcipher_alg</code> визначає шифр синхронного блоку, тоді як структура <code>ablkcipher_alg</code> визначає асинхронний шифр блоку.</p></div>
<div class="paragraph"><p>Будь ласка, зверніться до опису шифру одного блоку, щоб отримати схеми використання блочного шифру.</p></div>
</div>
<div class="sect3">
<h4 id="_____3">Особливості асинхронного багатоблокового шифру</h4>
<div class="paragraph"><p>Існує пара особливостей асинхронного інтерфейсу.</p></div>
<div class="paragraph"><p>Перш за все, деякі з драйверів захочуть використовувати Generic ScatterWalk у випадку, якщо на апаратне забезпечення потрібно подавати окремі фрагменти списку розсипу, який містить простий текст і міститиме шифротекст. Будь ласка, зверніться до інтерфейсу ScatterWalk, запропонованого реалізацією списку розсіювання/збору ядра Linux.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__hash">Хешинг [HASH]</h3>
<div class="paragraph"><p>Приклад перетворень: crc32, md5, sha1, sha256, &#8230;</p></div>
<div class="sect3">
<h4 id="_____4">Реєстрація та дереєстрація трансформації</h4>
<div class="paragraph"><p>Існує кілька способів реєстрації перетворення HASH, залежно від того, чи є перетворення синхронним [SHASH] чи асинхронним [AHASH] та кількістю перетворень HASH, які ми реєструємо. Ви можете знайти прототипи, визначені в <code>include/crypto/Internal/hash.h</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">crypto_register_ahash</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">crypto_register_shash</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">crypto_register_shashes</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_alg</span> <span class="o">*</span><span class="n">algs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Відповідними доповненнями для реєстрації трансформації HASH є такі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">crypto_unregister_ahash</span><span class="p">(</span><span class="k">struct</span> <span class="n">ahash_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">crypto_unregister_shash</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_alg</span> <span class="o">*</span><span class="n">alg</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">crypto_unregister_shashes</span><span class="p">(</span><span class="k">struct</span> <span class="n">shash_alg</span> <span class="o">*</span><span class="n">algs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="____shash_alg__ahash_alg">Визначення шифру Структура shash_alg та ahash_alg</h4>
<div class="paragraph"><p>Ось схеми того, як викликаються ці функції при роботі з іншою частиною ядра. Зауважте, що виклик <code>.setkey()</code> може статися до або після того, як відбудеться будь-яка з цих схем, але не повинна відбуватися під час будь-якого з них. Зауважте, що виклик <code>.init()</code>, за яким негайно переходить <code>.finish()</code>, також є абсолютно допустимим перетворенням.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>I)   DATA -----------.
                     v
      .init() -&gt; .update() -&gt; .final()      ! .update() може і не
                  ^    |         |            викликатись.
                  '----'         '---&gt; HASH

II)  DATA -----------.-----------.
                     v           v
      .init() -&gt; .update() -&gt; .finup()      ! .update() може і не
                  ^    |         |            викликатись.
                  '----'         '---&gt; HASH

III) DATA -----------.
                     v
                 .digest()                  ! Весь процес обробляється
                     |                        викликом .digest().
                     '---------------&gt; HASH</code></pre>
</div></div>
<div class="paragraph"><p>Ось схема схеми виклику функцій <code>.export()/.import()</code> при використанні з іншої частини ядра.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>KEY--.                 DATA--.
     v                       v                  ! .update() може і не
 .setkey() -&gt; .init() -&gt; .update() -&gt; .export()   викликатись.
                          ^     |         |
                          '-----'         '--&gt; PARTIAL_HASH

----------- тут відбуваються інші перетворення -----------

PARTIAL_HASH--.   DATA1--.
              v          v
          .import -&gt; .update() -&gt; .final()     ! .update() може і не
                      ^    |         |           викликатись.
                      '----'         '--&gt; HASH1

PARTIAL_HASH--.   DATA2-.
              v         v
          .import -&gt; .finup()
                        |
                        '---------------&gt; HASH2</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="____hash">Особливості асинхронної трансформації HASH</h4>
<div class="paragraph"><p>Деякі з драйверів захочуть використовувати Generic ScatterWalk у випадку, якщо для реалізації потрібно подавати окремі фрагменти списку розсипання, який містить вхідні дані. Буфер, що містить отриманий хеш, завжди буде належним чином вирівняний до <code>.cra_alignmask</code>, тому не потрібно турбуватись з цього приводу.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-05-14 16:39:15 EEST
</div>
</div>
</body>
</html>
