:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

= Препроцесор C

Востаннє переглянуто липень 1992 року для версії 2 GCC
Richard M. Stallman

Ця брошура, зрештою, призначена для формування першої глави посібника з мови GNU C.

Copyright c 1987, 1989, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.

Надання дозволу на виготовлення та розповсюдження дослівних копій цього посібника за умови, що це повідомлення про авторські права та це повідомлення про дозвіл зберігаються на всіх примірниках.

Дозвіл надається для копіювання та розповсюдження модифікованих версій цього посібника в умовах дословного копіювання, за умови, що вся отримана робота поширюється за умовами повідомлення про дозвіл, ідентичне цьому.

== Глава 1. Препроцесор C

Препроцесор C - це макропроцесор, який автоматично використовується компілятором C та трансформує вашу програму до фактичної компіляції. Його називають макропроцесором, оскільки це дозволяє вам визначати макроси, які є короткими абревіатурами для довших конструкцій. Препроцесор C пропонує чотири окремі засоби, якими ви можете користуватися:

* Включення файлів заголовка. Це файли декларацій, які можна підставлені у вашій програмі.
* Розширення макросів. Ви можете визначити макроси, які є абревіатурами довільних фрагментів коду С, і потім препроцесор C замінить макроси їхніми визначеннями у всій програмі.
* Умовна компіляція. Використовуючи спеціальні директиви попередньої обробки, ви можете включити або виключити частини програми відповідно до різних умов.
* Контроль рядків. Якщо ви використовуєте програму для комбінування або переставлення джерела у проміжний файл, який потім компілюється, ви можете використовувати управління рядками, щоб повідомити компілятор звідки походив кожен рядок джерела.

C препроцесори відрізняються деякими деталями. У цьому посібнику обговорюється препроцесор GNU C, препроцесор сумісного компілятора C. Препроцесор GNU C забезпечує набір функцій стандарту ANSI Standard C.

Стандарт ANSI C вимагає відмови від багатьох нешкідливих конструкцій, які зазвичай використовуються сьогоднішніми програмами C. Така несумісність була б незручною для користувачів, тому препроцесор GNU C готовий прийняти ці конструкції за замовчуванням. Строго кажучи, щоб отримати 
ANSI Standard C, ви повинні використовувати параметри `-trigraphs `, `-undef` `-pedantic`, але на практиці наслідки жорсткого стандарту ANSI C роблять це небажаним.

=== 1.1 Перетворення, що здійснюються глобально

Більшість функцій препроцесора C неактивні, якщо ви не надаєте конкретні директиви, щоб вимагати їх використання. (Директиви щодо попередньої обробки - це рядки, що починаються з `"#"`; див. Розділ 1.2 [Директиви], сторінка 2). Але є три перетворення, які препроцесор завжди робить на вході, який він отримує, навіть за відсутності директив. 

* Усі коментарі C замінюються на поодинокі проміжки.
* Послідовності Backslash-Newline видаляються, незалежно від того, де. Ця функція дозволяє вам розбивати довгі рядки в косметичних цілях, не змінюючи їх значення.
*  Заздалегідь назви макросів замінюються їх розширеннями.

Перші два перетворення робляться до того, як будуть розпізнані майже всі інші синтаксичні розробки та до того, як будуть розпізнані директиви попередньої обробки. Так, наприклад, ви можете розділити лінію косметично за допомогою Backslash-Newline де завгодно (крім випадків, коли використовуються триграфи).
[source,с]
----
/*
*/ # /*
*/ defi\
ne FO\
O 10\
20
----

is equivalent into `#define FOO 1020'. You can split even an escape sequence with Backslash-Newline. For example, you can split "foo\bar" between the `\' and the `b'
еквівалентно `#define FOO 1020`. Ви можете розділити навіть ескейп послідовність за допомогою Backslash-Newline. Наприклад, ви можете розділити `"foo\bar"` між `"\"` і `"b"`, щоб отримати

[source,c]
----
"foo\\
bar"
----

Така поведінка є нечіткою: у всіх інших контекстах зворотня коса може бути вставлена у рядкову константу як звичайний символ, записавши подвійну зворотню косу, і це створює виняток. Але стандарт ANSI C цього вимагає. Строгий ANSI C не дозволяє Newline в рядкових константах, тому вони не вважають це проблемою.

Але є кілька винятків з усіх трьох перетворень.

* C коментарі та попередньо задані імена макросів не розпізнаються у директиві `#include`, в якій ім'я файла оточене `<` та `>`.
* C коментарі та попередньо задані імена макросів ніколи не розпізнаються в межах символу або рядка-константи. (Строго кажучи, це правило, а не виняток, але воно варте нагадування тут в жодному разі.) 
* Backslash-Newline не можна безпечно використовувати в межах ANSI триграфів. Триграфи перетворюються до видалення Backslash-Newline. Якщо ви пишете щось схоже на триграф із Backslash-Newline всередині, Backslash-Newline видаляється, як завжди, але після цього пізно обробляти триграф. Цей виняток є актуальним лише у тому випадку, якщо ви використовуєте опцію `-trigraphs`, щоб увімкнути обробку триграфів.

=== 1.2 Директиви попередньої обробки

Більшість функцій препроцесора активні, лише якщо ви використовуєте директиви щодо попередньої обробки.

Директиви препроцесора - це рядки у вашій програмі, які починаються з `"#"`. Після `"#"` йде ідентифікатор, який є ім'ям директиви. Наприклад, `#define` - це директива, яка визначає макрос. Проміжок також дозволений до і після `"#"`. Набір дійсних імен директив фіксований. Програми не можуть створювати нові директиви попередньої обробки.

Деякі назви директив вимагають аргументи; вони складають решту рядка директиви і повинні бути відокремлені від назви директиви проміжком. Наприклад, `#define` повинен супроводжуватись ім'ям макросу та передбачуваним розширенням макросу.

Директива препроцесора не може мати більше одного рядка за звичайних обставин. Він може бути косметично розділений Backslash-Newline, але це не впливає на його значення. Коментарі, що містять Newlines, також можуть розділити директиву на кілька рядків, але коментарі будуть замінені на проміжки до того, як директива буде інтерпретована. Єдиний спосіб, коли в директиві препроцесора може виникнути значущий Newline, це в межах константи рядка або константи символів. Зауважте, що більшість компіляторів C, які можуть бути застосовані до виводу з препроцесора, не приймають рядкові чи символьні константи, що містять Newlines. 

`#` та ім'я директиви не можуть походить від розширення макросу. Наприклад, якщо `foo` визначено як макрос, який розширюється на `define`, це не робить `#foo` дійсною директивою попередньої обробки.

=== 1.3 Файли заголовків

Заголовок - це файл, що містять декларації C та визначення макро, які мають бути спільними для декількох джерел. Ви вмикаєте використання файла заголовка у вашій програмі директивою попередньої обробки C `#include`.

==== 1.3.1 Використання файлів заголовка

Файл заголовока служить двом цілям. 

* Заголовок системи оголошує інтерфейси до частин операційної системи. Ви включаєте їх у свою програму для надання визначень та декларацій, необхідних для виклику системних викликів та бібліотек. 
* Ваш власний заголовок містить декларації для інтерфейсів між вихідними файлами програми. Кожен раз, коли у вас є група пов'язаних декларацій та макровизначень, всі або більшість з яких потрібні в декількох різних джерелах, рекомендується створити для них заголовок.

Включення файлу заголовка дає такі самі результати в компіляції C, як і копіювання файлу заголовка у кожен вихідний файл, де він потрібен. Але таке копіювання буде трудомістким і схильним до помилок. З файлом заголовка відповідні декларації з’являються лише в одному місці. Якщо їх потрібно змінити, їх можна змінити в одному місці, а програми, що містять заголовок, автоматично використовуватимуть нову версію при наступній перекомпіляції. Файл заголовка виключає роботу копіювання та зміну всіх копій, а також ризик того, що невдача однієї копії призведе до невідповідностей всередині програми.

Звичайна домовленість - давати файлам заголовка імена, які закінчуються на `.h`. Уникайте незвичних символів у назвах файлів заголовків, оскільки вони зменшують мобільність. 

==== 1.3.2 Директива "#include" 

І файли заголовків користувача, і заголовоки системи включаються за допомогою директиви препроцесора `#include`. Він має три варіанти:

===== #include <file>

Цей варіант використовується для файлів заголовків системи. Він шукає файл з іменем файлу в списку каталогів, визначених вами, а потім у стандартному списку системних каталогів. Ви вказуєте каталоги для пошуку файлів заголовків опцією команди `-I`. Параметр `-nostdinc` гальмує пошук стандартних системних каталогів; у цьому випадку шукаються лише вказані вами каталоги.

Синтаксичний аналіз цієї форми `#include` є дещо особливим, оскільки коментарі не розпізнаються в `<:::>`. Таким чином, у `#include <x/*y>` символи `/*` не починає коментар, і директива вказує включення файлу системного заголовка під назвою `x/*y`. Звичайно, файл заголовка з таким ім'ям навряд чи існуватиме в Unix, де з можливостями підстановки оболонки важко буде маніпулювати. Файл аргументу може не містити символу `>`. Однак він може містити символ `<`.

===== #include "file"

Цей варіант використовується для файлів заголовків вашої власної програми. Він шукає файл з ім'ям файлу file спочатку у поточному каталозі, а потім у тих самих каталогах, які використовуються для файлів заголовків системи. Поточний каталог - це каталог поточного вхідного файлу. Це спробується в першу чергу, оскільки це, як вважається, розташування файлів, на які посилається поточний вхідний файл. (Якщо використовується опція `-I-`, спеціальна обробка поточного каталогу заборонена.)

Файл аргументу не може містити символів `"`. Якщо у `file` зустрічаються зворотні косі риски, вони вважаються звичайними текстовими символами, а не символами ескейп послідовностей. Жодна з ескейп послідовностей, що відповідає рядковим константам у С, не обробляється. Таким чином, у `#include "x\n\\y"` вказується ім'я, що містить три зворотні коси риски. Не зрозуміло, чи ця поведінка буває корисна, але стандарт ANSI визначає її.

===== #include будь-що-інше

Цей варіант називається обчисленим `#include`. Будь-яка директива `#include`, аргумент якої не містить дві вищевказані форми, є обчисленою. Текст `будь-що-інше` перевіряється на макровиклики, які розгортаються. Коли це зроблено, результат повинен мати один із перелічених вище варіантів, зокрема, розгорнутий текст повинен бути врешті оточений лапками або кутовими дужками.

Ця функція дозволяє визначити макрос, який керує іменем файлу, що пізніше буде використаний у програмі. Одне із застосувань цього полягає в тому, щоб дозволити конфігураційному файлу, визначеному сайтом для вашої програми, вказати назви системних файлів включення, які слід використовувати. Це може допомогти в перенесенні програми на різні операційні системи, в яких необхідні файли заголовків системи знаходяться в різних місцях.

==== 1.3.3 Як працює #inclue

Директива `#include` працює, направляючи препроцесора C сканувати вказаний файл як вхідний, перш ніж продовжувати решту поточного файлу. Вихід з препроцесора містить вже сформований результат, потім код з включеного файлу, а нарешті вихід, який надходить з тексту після директиви `#include`. Наприклад, задавши файл заголовка `header.h` наступним чином,

[source,c]
----
char *test ();
----

і основну програму під назвою `program.c`, яка використовує файл заголовка, наприклад,

[source,c]
----
int x;
#include "header.h"
main ()
{
  printf (test ());
}
----

отримаємо вихід, згенерований препроцесором C для `program.c` як вхідний

[source,c]
----
int x;
char *test ();
main ()
{
  printf (test ());
}
----

Файли, що включаються, не обмежуються деклараціями та макрозначеннями; це лише типові види використання. Будь-який фрагмент програми С може бути включений з іншого файлу. Файл `include` може навіть містити початок твердження, яке завершується у файлі, що його містить. Або кінець дечого, що розпочате у файлі, який його включає. Однак коментар, або рядок, або константа символів не можуть починатись у включеному файлі та завершуватись у файлі включення. Незавершений коментар, константа рядка або константа символів у включеному файлі мають завершитись (із повідомленням про помилку) в кінці файлу.

Можна, щоб файл заголовка починав або закінчував синтаксичну одиницю, таку як визначення функції, але це було б дуже приголомшливо, тому не робіть цього.

Рядок, що слідує за директивою `#include`, завжди розглядається як окремий рядок C препроцесора, навіть якщо у включеному файлі відсутній новий рядок.

==== 1.3.4. Файли, що вставляються лише один раз

Дуже часто один заголовок містить інший. Це може легко призвести до того, що певний файл заголовка включається не один раз. Це може призвести до помилок, якщо файл заголовка містить типи структури або `typedef` і, безумовно, марнотратно. Тому ми часто хочемо запобігти багаторазовому включенню заголовкового файлу.

Стандартний спосіб зробити це - укласти весь реальний вміст файлу в умовному порядку:

[source,c]
----
#ifndef FILE_FOO_SEEN
#define FILE_FOO_SEEN
вміст цілого файлу
#endif /* FILE_FOO_SEEN */
----

Макрос `FILE_FOO_SEEN` вказує, що файл уже включений один раз. У файлі заголовка користувача ім'я макросу не повинно починатися з `_`. У файлі системного заголовка це ім'я повинно починатися з `__`, щоб уникнути конфліктів із програмами користувача. У будь-якому виді файла заголовка ім'я макросу має містити ім'я файлу та деякий додатковий текст, щоб уникнути конфліктів з іншими файлами заголовків.

Препроцесор GNU C запрограмований так, щоб помітити, коли файл заголовка використовує цю особливу конструкцію, та обробляє її ефективно. Якщо файл заголовка повністю міститься в умовному блоці `#ifndef`, він записує цей факт. Якщо наступний `#include` вказує той самий файл, а макрос в `#ifndef` вже визначено, то файл повністю пропускається, навіть не читаючи його.

Існує також явна директива сказати препроцесору, що він не повинен містити файл більше одного разу. Це називається `#pragma once`, і його використовували на додаток до умовного `#ifndef` навколо вмісту файлу заголовка. `#pragma once` тепер застаріла і її взагалі не слід використовувати.

У мові Objective C існує варіант `#include`, який називається `#import`, який включає файл, але робить це не більше одного разу. Якщо ви використовуєте `#import` замість `#include`, вам не потрібні умовні директиви всередині файлу заголовка, щоб запобігти багаторазовому виконанню вмісту.

`#import` є застарілим, оскільки це не добре розроблена функція. Вона вимагає від користувачів файлу заголовка (програмістів) знати, що певний файл заголовка повинен бути включений лише один раз. Набагато краще реалізатору заголовочного файлу написати файл, щоб користувачі не знали цього. Використання `#ifndef` досягає цієї мети.

==== 1.3.5 Наслідування та файли заголовків

Спадкування - це те, що відбувається, коли один об’єкт або файл отримує частину свого вмісту шляхом віртуального копіювання з іншого об'єкта чи файла. Що стосується файлів заголовків C, спадкування означає, що один заголовок містить інший файл заголовка, а потім щось замінює або додає. Якщо у файла успадковуваного заголовка та у базовому файлі заголовка різні імена, то успадкування є простим: просто запишіть `#include "base"` у файл-наслідувач. Іноді потрібно надати спадковим файлам те саме ім'я, що і базовому файлу. Це менш прямолінійно.

Наприклад, прикладна програма використовує файл заголовка системи `sys/signal.h`, але у певній системі версія `/usr/include/sys/signal.h` не робить того, що очікує прикладна програма. Можливо, було б зручно визначитие `\local` версію, наприклад під назвою `/usr/local/include/sys/signal.h`, щоб змінити або додати до тієї, яку постачає система.

Це можна зробити, скориставшись опцією `-I.` для компіляції, та написати файл `sys/signal.h`, який робить те, що очікує прикладна програма. Але зробити, щоб цей файл включав стандартний `sys/signal.h` не так просто. Запис `#include <sys/signal.h>` у цей файл не працює, оскільки він включає вашу власну версію файлу, а не стандартну версію системи. Використання у тому самому файлі призводить до явної рекурсії та фатальної помилки при компіляції. `#include </usr/include/sys/signal.h>` знайде належний файл, але це не чисто, оскільки він робить припущення про те, де розташований файл заголовка системи. Це погано для обслуговування, оскільки означає, що будь-яка зміна місця зберігання файлів заголовків системи потребує змін десь в іншому місці.

Чистий спосіб вирішити цю проблему - використовувати `#include_next`, що означає включити наступний файл з цим ім'ям. Ця директива працює як `#include`, за винятком пошуку визначеного файлу: вона починає пошук у списку каталогів файлів заголовка після каталогу, в якому був знайдений поточний файл. Припустимо, ви вказали `-I/usr/local/include`, а список каталогів для пошуку також включає `/usr/include`; припустимо, що обидва каталоги містять файл з назвою `sys/ signal.h`. Звичайний `#include <sys/signal.h>` знайде файл в `/usr/local/include`. Якщо цей файл містить `#include_next <sys/signal.h>`, він починає пошук за цим каталогом, і вкладає файл `/usr/include`.

=== 1.4 Макро

Макро - це такий тип абревіатури, який ви можете визначити один раз, і потім використовувати. Є багато складних функцій, пов'язаних з макросами в препроцесорі С.

==== 1.4.1 Прості макроси

Простий макрос - це свого роду абревіатура. Це ім'я, яке означає фрагмент коду. Деякі люди називають це проголошенням констант. Перш ніж використовувати макрос, його потрібно чітко визначити за допомогою директиви `#define`. `#define` супроводжується назвою макросу, і потім код, для якого він повинен бути абревіатурою. Наприклад,

[source,c]
----
#define BUFFER_SIZE 1020
----

denes a macro named `BUFFER_SIZE' as an abbreviation for the text `1020'. If somewhere after this `#define' directive there comes a C statement of the form
визначає макро з назвою `BUFFER_SIZE` як абревіатуру для тексту `1020`. Якщо десь після цієї директиви `#define` з'являється твердження C вигляду

[source,c]
----
foo = (char *) xmalloc (BUFFER_SIZE);
----

тоді препроцесор C розпізнає і розширить макрос `BUFFER_SIZE`, в результаті чого отримаємо

[source,c]
----
foo = (char *) xmalloc (1020);
----

Використання всього верхнього регістру для імен макросів є стандартною домовленостю. Програми легше читати, коли можна з першого погляду сказати, які назви є макросами. Зазвичай макро визначення повинно бути єдиним рядком, як і всі директиви препроцесора C. (Ви можете розділити довге визначення макро косметично за допомогою Backslash-Newline.) 

Є один виняток: нові рядки можуть бути включені до макроспису, якщо вони знаходяться в рядку чи символьній константі. Це через те, що визначення макро не може містити незбалансовані лапки - визначення автоматично розширяється, щоб включати відповідні лапки, що завершують рядок або символьну константу. 

Коментарі в макро визначенні можуть містити нові рядки, які не мають різниці, оскільки коментарі будуть повністю замінені проміжками, незалежно від їхнього вмісту.

Окрім сказаного, немає обмежень щодо того, що може відбуватися в тілі макро. Дужки не потребують балансу. Тіло не повинно нагадувати дійсний код С. (Якщо цього не відбувається, ви можете отримати повідомлення про помилки від компілятора C під час використання макросу.)

Препроцесор C послідовно сканує вашу програму, і макро визначення приймають ефект у тому місці, де ви їх записуєте. Тому наступний вхід для препроцесора С

[source,c]
----
foo = X;
#define X 4
bar = X;
----

виробляє на вихіді

[source,c]
----
foo = X;
bar = 4;
----

Після того, як препроцесор розширить ім'я макросу, тіло визначення макросу додається на передню частину входу, що залишився, і перевірка макровикликів продовжується. Тому тіло макросів може містити виклики до інших макросів. Наприклад, після

[source,c]
----
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
----

назва `TABLESIZE` при використанні в програмі проходила би через два етапи розширення, в результаті чого в кінцевому підсумку вийшло `1020`. Це зовсім не те, що дефініція `TABLESIZE` має бути `1020`. `#define` для `TABLESIZE` використовує саме тіло, яке ви вказали, в цьому випадку `BUFSIZE`. Лише коли ви використовуєте `TABLESIZE`, результат його розширення перевіряється на присутність інших імен макросів.

==== 1.4.2 Макроси з аргументами

Простий макрос завжди означає точно той самий текст, щоразу, коли він використовується. Макроси можуть бути більш розширюваними, коли вони приймають аргументи. Аргументи - це фрагменти коду, які ви надаєте щоразу, коли використовується макрос. Ці фрагменти включаються в розширення макросу відповідно до вказівок у макро визначенні. 

Макрос, який приймає аргументи, називається макрос-функція, оскільки синтаксис його використання виглядає як виклик функції. Щоб визначити макрос, який використовує аргументи, ви пишете директиву `#define` зі списком імен аргументів у дужках після імені макросу. Імена аргументів можуть бути будь-якими дійсними ідентифікаторами C, розділеними комами, та необов'язково проміжками. Відкриваючі дужки мають безпосередньо слідувати за ім'ям макросу, не маючи проміжків між ними.

Наприклад, ось макрос, який обчислює мінімум двох числових значень, як це визначено у багатьох програмах C:

[source,c]
----
#define min(X, Y) ((X) < (Y) ? (X) : (Y))
----

(Це не найкращий спосіб визначити макрос мінімуму у GNU C.)

Щоб використовувати макрос, який очікує аргументів, ви записуєте ім'я макросу, а за ним список фактичних аргументів у дужках, розділених комами. Кількість фактичних аргументів, які ви наводите, має відповідати кількості аргументів, які очікує макрос.

Приклади використання макроса `min` включають `min (1, 2)` і `min (x + 28, *p)`. Текст розширення макроса залежить від використовуваних вами аргументів. Кожне з назв аргументу макросу замінюється у всьому макро відповідним фактичним аргументом. Використовуючи той самий макрос `min`, який визначений вище, `min (1, 2)` розширюється на `((1) < (2) ? (1) : (2))`, де `1` був підставлений замість `X` і `2` замість `Y`. Подібно до цього, `min (x + 28, *p)` розширюється до
`((x + 28) < (*p) ? (x + 28) : (*p))`.

Дужки в фактичних аргументах повинні врівноважуватися; кома в дужках не закінчує аргумент. Однак немає вимоги врівноважувати фігурні або квадратні дужки, і вони не заважають комі відокремлювати аргументи. Таким чином, макрос `(array[x = y, x + 1])` передає два аргументи макросу: `array[x = y` і `x + 1]`. Якщо ви хочете надати `array [x = y, x + 1]` як аргумент, ви повинні записати його як `array [(x = y, x + 1)]`, що є еквівалентним кодом C.

Після того, як фактичні аргументи будуть замінені в тілі макросу, весь результат додається на передню частину входу, що залишився, і перевірка макро-викликів продовжується. Тому фактичні аргументи можуть містити виклики до інших макросів, з аргументами або без них, або навіть до того ж макросу. Тіло макросу також може містити виклики до інших макросів. Наприклад, `min (min (a, b), c)` розширюється на цей текст: 

[source,с]
----
((((a) < (b) ? (a) : (b))) < (c) ? (((a) < (b) ? (a) : (b))) : (c))
----

Якщо макро `foo` приймає один аргумент, і ви хочете надати порожній аргумент, ви повинні написати принаймні деякий проміжок між дужками, як-от так: `foo ( )`. Просто `foo ()` не надає аргументів, що є помилкою, якщо `foo` очікує аргументу. Але `foo0 ()` - це правильний спосіб викликати макро, що визначений так, щоб приймати нуль аргументів, наприклад: `#define foo0 () :::`.

Якщо ви використовуєте ім'я макроса, за яким слідує щось інше, ніж відкрита дужка (після ігнорування будь-якії проміжків, табуляцій та коментарів, які ідуть далі), це не виклик макросу, і препроцесор не змінює те, що ви написали. Таким чином, можливо, що те саме ім’я є змінною або функцією у вашій програмі, а також макросом, і ви можете в кожному випадку вибирати, чи слід посилатися на макрос (якщо слідує фактичний список аргументів) або змінну чи функцію (якщо список аргументів не слідує).

Таке подвійне використання одного імені може бути заплутаним і його слід уникати, за винятком випадків, коли два значення є ефективно синонімами: тобто коли ім’я є і макросом, і функцією, і два мають подібні ефекти. Ви можете вважати ім'я просто функцією; використання імені для інших цілей, ніж його виклик (наприклад, для отримання адреси) буде стосуватися функції, тоді як виклики розширять макрос і генерують кращий, але еквівалентний код. Наприклад, ви можете використовувати функцію з назвою `min` у тому самому вихідному файлі, що і макрос. Якщо ви пишете `& min` без списку аргументів, ви посилаєтесь на функцію. Якщо ви пишете `min (x, bb)` зі списком аргументів, розгортається макрос. Якщо ви пишете `(min) (a, bb)`, де за ім'ям `min` не йде відкрита дужка, макрос не розширюється, тому ви скінчите викликом функції `min`.


Ви не можете мати одне й те саме ім'я, як і простий макрос, і макрос з аргументами. У визначенні макросу з аргументами список імен аргументів повинен негайно слідувати імені макросу, не маючи проміжків між ними. Якщо після імені макросу є проміжок, макрос визначається як такий, що не приймає аргументів, а весь інший рядок вважається розширенням. Причиною цього є те, що часто корисно визначити макрос, який не приймає аргументів і чиє призначення починається з ідентифікатора в дужках. Це правило про проміжки дозволяє вам робити це:

[source,c]
----
#define FOO(x) - 1 / (x)
----

(що визначає `FOO` взяти аргумент і розгорнути вираз з ним), або це:

[source,c]
----
#define BAR (x) - 1 / (x)
----

(що визначає `BAR` без аргументу, і завжди розгортається як `(x) - 1 / (x)`).

Зауважте, що використання макросу з аргументами може мати проміжки перед лівою дужкою; це визначення, де важливо, чи є проміжок.

==== 1.4.3 Попередньо визначені макроси

Заздалегідь визначено кілька простих макросів. Ви можете користуватися ними, не надаючи для них умовних позначень. Вони поділяються на два класи: стандартні макроси та макроси, визначені системою.

===== 1.4.3.1 Стандартні передвизначені макроси

Стандартні заздалегідь задані макроси доступні з однаковими значеннями незалежно від машини чи операційної системи, в якій ви використовуєте GNU C. Їх імена починаються та закінчуються подвійними підкресленнями. Ті, що передували `__GNUC__` у цій таблиці, стандартизовані ANSI C; решта - це розширення GNU C.

`__FILE__` Цей макрос розширюється до імені поточного вхідного файлу у вигляді рядка-константи С. Точне повернене ім'я - це те, що було вказано у `#include` або як аргумент імені вхідного файлу.

`__LINE__` Цей макрос розширюється до поточного номера рядка введення у вигляді десяткової цілої константи. Хоча ми називаємо це заздалегідь визначеним макросом, це досить дивний макрос, оскільки його визначення змінюється з кожним новим рядком вихідного коду. Це, та `__FILE__` корисні при створенні повідомлення про помилку для повідомлення про невідповідність, виявлену програмою; повідомлення може містити рядок джерела, у якому було виявлено невідповідність. Наприклад,

[source,c]
----
fprintf (stderr, "Internal error: "
"negative string length "
"%d at %s, line %d.",
length, __FILE__, __LINE__);
----

Директива `#include` змінює розширення `__FILE__` та `__LINE__`, щоб відповідати включеному файлу. Наприкінці цього файлу, коли обробка поновлюється на вхідному файлі, що містив директиву `#include`, розширення `__FILE__` та `__LINE__` повертаються до значень, які вони мали до `#include` (але `__LINE__` потім збільшується на одиницю, коли обробка рухається до рядка після `#include`). Розширення як `__FILE__`, так і `__LINE__` змінюються, якщо використовується директива `#line`.

`__DATE__` Цей макрос розширюється до рядкової константи, яка описує дату запуску препроцесора. Рядок константа містить одинадцять символів і виглядає як `"Jan 29 1987" ` або `"Apr 1 1905"`. 

`__TIME__` Цей макрос розширюється до рядкової константи, яка описує час запуску препроцесора. Строкова константа містить вісім символів і виглядає як `"23:59:01"`.

`__STDC__` Цей макрос розширюється до константи `1`, щоб позначати, що це стандарт ANSI C. (Чи справді це дійсно, залежить від того, який компілятор C буде працювати на виході з препроцесора.)


`__STDC_VERSION__` Цей макрос розширюється до номера версії C Standard, довгої цілої константи форми `yyyymmL`, де `yyyy` і `mm` - рік та місяць стандартної версії. Це означає, якій версії стандарту відповідає препроцесор. Як і `__STDC__` ', чи точно цей номер версії для всієї реалізації залежить від того, який компілятор C буде працювати на виході з препроцесора.

`__GNUC__` Цей макрос визначений, якщо і тільки якщо це GNU C. Цей макрос визначений лише тоді, коли використовується весь компілятор GNU C; якщо ви будете викликати препроцесор безпосередньо, `__GNUC__` не буде визначено. Значення ідентифікує номер основної версії CC GNU (`1` для GNU CC версії 1, яка тепер застаріла, і `2` для версії 2).

`__GNUC_MINOR__` Макрос містить молодший номер версії компілятора. Це можна використовувати для подолання відмінностей між різними випусками компілятора (наприклад, якщо відомо, що gcc 2.6.3 підтримує функцію, ви можете перевірити наявність `__GNUC__> 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > = 6))`. Останнє число, "3" у наведеному вище прикладі, позначає рівень помилки компілятора `bugx`; жоден макрос не містить цього значення.

`__GNUG__` Компілятор GNU C визначає це, коли мова компіляції C++; використовуйте `__GNUG__`, щоб розрізняти GNU C і GNU C ++. 

`__cplusplus` Проект стандарту ANSI для C ++, який використовується для попереднього визначення цієї змінної. Хоча це більше не потрібно, GNU C ++ продовжує визначати це, як і інші популярні компілятори C++. Ви можете використовувати `__cplusplus`, щоб перевірити, чи заголовок збирається компілятором C або компілятором C ++.

`__STRICT_ANSI__` Цей макрос визначений, якщо та лише у випадку, коли був заданий перемикач `-ansi` при виклику GNU C. Його умовою є нульовий рядок. Цей макрос існує насамперед для того, щоб спрямовувати певні файли заголовків GNU не визначати певні традиційні конструкції Unix, несумісні з ANSI C.

`__BASE_FILE__` Цей макрос розширюється до імені головного вхідного файлу у вигляді рядка-константи С. Це вихідний файл, що вказано як аргумент, коли викликався компілятор C.

`__INCLUDE_LEVEL__` Цей макрос розширюється до десяткової цілої константи, яка представляє глибину занурення в файли включення. Значення цього макросу збільшується на кожній директиві `#include` і зменшується в кожному кінці файлу. Для вхідних файлів, визначених аргументами командного рядка, рівень вкладення дорівнює нулю.

`__VERSION__` Цей макрос розширюється до рядка, який описує номер версії GNU C. Рядок, як правило, є послідовністю десяткових чисел, розділених періодами, наприклад, `"2.6.0"`. Єдине розумне використання цього макросу - це включення його до рядкової константи.

`__OPTIMIZE__` Цей макрос визначений для оптимізації компіляцій. Це змушує певні файли заголовків GNU визначати альтернативні макрозначення для деяких функцій системної бібліотеки. Нерозважливо посилатися або перевіряти визначення цього макросу, якщо ви не впевнені, що програми будуть виконуватись із тим самим ефектом незалежно від цього.

`__CHAR_UNSIGNED__` Цей макрос визначено, якщо і лише тоді, коли тип даних `char` не має знаку на цільовій машині. Він існує, щоб стандартний файл заголовка `limit.h` працював правильно. Погана ідея посилатися на цей макрос самостійно; замість цього зверніться до стандартних макросів, визначених у `limit.h`. Препроцесор використовує цей макрос, щоб визначити, чи слід доповнювати або розширювати великі константи символів, написані у восьмериці.

`__REGISTER_PREFIX__` Цей макрос розширюється до рядка, що описує префікс, застосований до регістрів процесора в коді асемблера. Він може бути використаний для запису коду асемблера, який можна використовувати в різних середовищах. Наприклад, у середовищі `m68k-aout` він розширюється до рядка `""`, але в середовищі `m68k-coff` він розширюється до рядка `"%"`.

`__USER_LABEL_PREFIX__` Цей макрос розширюється до рядка, що описує префікс, застосований до генерованих користувачем міток у коді асемблера. Він може бути використаний для запису коду асемблера, який можна використовувати в різних середовищах. Наприклад, у середовищі `m68k-aout` він розширюється на рядок `"_"`, але в середовищі `m68k-coff` він розширюється на рядок `""`.

===== 1.4.3.2 Нестандартні передвизначені макроси

У препроцесорі С зазвичай є кілька заздалегідь встановлених макросів, які різняться між машинами, оскільки їх мета полягає в тому, щоб вказати, який тип системи та машини використовується. Цей посібник, призначений для всіх систем і машин, не може точно сказати, як їх називають; натомість ми описуємо список типових. Ви можете використовувати `cpp -dM`, щоб переглянути значення існуючих макросів.

Деякі нестандартні задані макроси описують використовувану операційну систему з більш-менш конкретним змістом. Наприклад, `unix` зазвичай передбачений у всіх системах Unix. `BSD` визначений для останніх версій Berkeley Unix (можливо, лише у версії 4.3).


Інші нестандартні попередньо визначені макроси описують тип процесора з більш-менш специфікою. Наприклад, `vax` визначено на комп'ютерах Vax. `mc68000` передбачений на більшості комп'ютерів, процесором яких є Motorola 68000, 68010 або 68020. `m68k` також передбачено для більшості комп'ютерів, процесор яких становить 68000, 68010 або 68020; проте деякі виробники використовують `mc68000`, а деякі використовують `m68k`. Деякі навіть обидва імені. Що відбувається в GNU C, залежить від системи, якою ви користуєтесь.

Помічено, що `M68020` є попередньо визначеним у деяких системах, які використовують процесори 68020, крім `mc68000` та `m68k`, які менш специфічні. `_AM29K`, `_AM29000` призначені для сімейства процесорів AMD 29000. `ns32000` визначений на комп'ютерах, які використовують процесор National Semiconductor 32000 серії CPU. Ще інші макроси описують виробника системи. Наприклад, `sun` визначене на всіх моделях комп’ютерів Sun. `pyr` є ​​на всіх моделях комп'ютерів Pyramid. `sequent` визначена на всіх моделях комп'ютерів Sequent.

Ці попередньо задані символи не тільки нестандартні, вони суперечать стандарту ANSI, оскільки їх назви не починаються з підкреслення. Тому опція `-ansi` гальмує визначення цих символів. Це робить `-ansi` марним, оскільки багато програм залежать від власних нестандартних символів. Навіть файли заголовків системи перевіряють їх і генерують неправильні декларації, якщо вони не знайдуть очікувані імена. Ви можете подумати, що файли заголовків, що постачаються для комп'ютера Uglix, не потребують тестування, на якій машині вони працюють, тому що вони можуть просто припустити, що це Uglix; але часто це роблять, і вони роблять це, використовуючи звичайні назви. Як результат, дуже мало програм C буде компілюватися із `-ansi`. Ми маємо намір уникнути подібних проблем у системі GNU.

Що ж тоді робити в програмі ANSI C, щоб перевірити тип машини, на якій вона буде працювати? Для цієї мети GNU C створює паралельний ряд символів, назви яких складаються із звичних, додаючи на початку та в кінці `__`. Таким чином, символ `__vax__` буде доступний у Vax тощо. Набір нестандартних заздалегідь заданих імен контролюється у препроцесорі GNU C (коли `cpp` сам компілюється) макросом `CPP_PREDEFINES`, який повинен бути рядком, що містить параметри `-D`, розділені проміжками. Наприклад, на Sun 3 ми використовуємо таке визначення:

[source,c]
----
#define CPP_PREDEFINES "-Dmc68000 -Dsun -Dunix -Dm68k"
----

Цей макрос зазвичай вказується в `tm.h`.

==== 1.4.4 Рядкофікація

Рядкофікація означає перетворення фрагмента коду в константу рядка, вмістом якого є текст для фрагмента коду. Наприклад, рядкофікація `foo (z)` призводить до `"foo (z)"`. У препроцесорі С, це є варіантом, який доступний, коли макроаргументи підміняються на макрозначення. Коли відображається ім'я аргументу, в тілі дефініції символ `"#"` перед ім'ям вказує строкову відповідність фактичного аргументу, коли він заміщений у цій точці дефініції. Цей самий аргумент може бути заміщений в інших місцях дефініції без утвореняя рядків, якщо назва аргументу відображається в тих місцях, де немає `"#"`.

Ось приклад макро визначення, яке використовує цей механізм:

[source,c]
----
#define WARN_IF(EXP) \
do { if (EXP) \
fprintf (stderr, "Warning: " #EXP "\n"); } \
while (0)
----

Тут фактичний аргумент для `EXP` замінюється один раз, як задано, в операторі `if` і один раз як перетворений на рядок, в аргументі `fprintf`. `do` та `while (0)` є хиткою, щоб дати можливість записати `WARN_IF (arg);`, що зробить подібне з функцією `WARN_IF`, щоб програмісти C захотіли б зробити. Рядкофікація обмежується перетворенням одного аргументу макросу в одну константну строку: немає способу поєднати аргумент з іншим текстом, а потім узагальнити його разом. Але наведений вище приклад показує, як еквівалентний результат можна отримати в ANSI Standard C, використовуючи функцію, що суміжні константи рядків об'єднуються як одна константа рядків. Препроцесорний рядок розміщує фактичне значення `EXP` в окрему строкову константу, в результаті чого стає подібним до тексту

[source,c]
----
do { if (x == 0) \
fprintf (stderr, "Warning: " "x == 0" "\n"); } \
while (0)
----

але компілятор C потім бачить три послідовних рядка і з'єднує їх у один:

[source,c]
----
do { if (x == 0) \
fprintf (stderr, "Warning: x == 0\n"); } \
while (0)
----

Рядкофікація у С передбачає більше, ніж розміщення символів подвійних лапок навколо фрагмента; необхідно поставити зворотні косі риски навпроти всіх символів подвійного квотування та всіх косих рядків та символьних констант, щоб отримати дійсну константу рядка C із належним вмістом. Таким чином, перетворюючи на рядок `p="foo\n ";` призводить до `"p = \"foo\\n\";"`. Однак косі риски, що не знаходяться всередині рядкових або символьних констант, не дублюються: `\n` сам по собі дає `"\n"`.

Проміжки (включаючи коментарі) у тексті, який передається в рядку, обробляється за точними правилами. Усі провідні та кінцеві проміжки ігноруються. Будь-яка послідовність проміжків у середині тексту перетворюється на єдиний проміжок у рядковому результаті.

==== 1.4.5 Поєднання

З’єднання означає об'єднання двох рядків в один. В контексті макророзширення конкатенація означає з'єднання двох лексичних одиниць у одну довшу. Зокрема, фактичний аргумент макросу може бути об'єднаний з іншим фактичним аргументом або з текстом, щоб отримати довше ім'я. Більш довге ім'я може бути ім'ям функції, змінної чи типу, або ключовим словом C; це може бути навіть ім'я іншого макросу, і в цьому випадку він буде розширений.

Коли ви визначаєте макрос, ви вимагаєте конкатенації спеціальним оператором `##` у тілі макросу. Коли макрос викликається, після заміни фактичних аргументів, всі оператори `##` видаляються, а також будь-які проміжки поруч з ними (включаючи проміжок, який був частиною фактичного аргументу). Результатом є об'єднання синтаксичних лексем по обидві сторони `##`.

Розглянемо програму C, яка інтерпретує названі команди. Напевно, повинна бути таблиця команд, можливо, масив структур, оголошений так:

[source,c]
----
struct command
{
  char *name;
  void (*function) ();
};
struct command commands[] =
{
{ "quit", quit_command},
{ "help", help_command},
::: };
----

Було б більш ясніше без потреби не давати ім'я кожної команди двічі, один раз у постійній строці та один раз у назві функції. Макрос, який приймає назву команди як аргумент, може зробити це непотрібним. Постійна константа може бути створена за допомогою рядкування, а ім'я функції шляхом об'єднання аргументу з `_command`. Ось як це робиться:

[source,c]
----
#define COMMAND(NAME) { #NAME, NAME ## _command }
struct command commands[] =
{
COMMAND (quit),
COMMAND (help),
::: };
----

Звичайний випадок конкатенації - це об'єднання двох імен (або імені та числа) у більш довге ім'я. Але це не єдиний дійсний випадок. Також можна об'єднати два числа (або число і ім’я, наприклад, `"1,5"` і `"e3"`) у число. Також багатосимсвольні оператори, такі як `+=`, можуть утворюватися шляхом конкатенації. У деяких випадках можливо навіть з'єднати рядкові константи. Однак два фрагменти тексту, які не утворюють разом дійсну лексичну одиницю, не можуть бути об'єднані. Наприклад, конкатенація з `"x"` на одній стороні та `"+"` з іншого не має сенсу, оскільки ці два символи не можуть поєднатися в жодній лексичній одиниці C. Стандарт ANSI говорить, що такі спроби конкатенації не визначені, але в препроцесорі GNU C він чітко визначений: він ставить поряд `x` і `+` без певних особливих результатів.

Майте на увазі, що препроцесор C перетворює коментарі у проміжки, перш ніж макроси навіть розглядаються. Отже, ви не можете створити коментар, об'єднуючи `/` і `*`: послідовність `/*`, яка починає коментар, не є лексичною одиницею, а скоріше символом початку проміжків. Також ви можете вільно використовуйте коментарі поруч із символом `"##"` у макро визначенні або в фактичних аргументах, які будуть об'єднані, оскільки коментарі будуть перетворені в проміжки з першого погляду, а пізніше конкатенація відкине ці проміжки.

==== 1.4.6 Знищення макросів

Знищити певний макрос означає скасувати його визначення. Це робиться за допомогою директиви `#undef`. `#undef` супроводжується іменем макросу, який слід не скасувати. Як і визначення, відімна визначення виникає у визначеній точці у вихідному файлі, і застосовується починаючи з цієї точки. Ім’я перестає бути іменем макросу, і з цього моменту препроцесор трактує це так, як ніби воно ніколи не було іменем макросу. Наприклад,

[source,scala]
----
#define FOO 4
x = FOO;
#undef FOO
x = FOO;
----

розширюється в

[source,scala]
----
x = 4;
x = FOO;
----

У цьому прикладі `FOO` краще бути змінною або функцією, а також (тимчасово) макросом, щоб результат розширення був дійсним кодом С. Та ж форма директиви `#undef` скасуватиме визначення з аргументами чи визначення, які не очікують аргументів. Директива `#undef` не має ефекту при використанні імені, яке наразі не визначено як макрос.

==== 1.4.7 Повторне визначення макросів

Оновити макрос означає визначити (за допомогою `#define`) ім'я, яке вже визначено як макрос.

Повторне визначення є тривіальним, якщо нове визначення прозоро ідентичне старому. Ви, мабуть, навмисно не напишете тривіальне перевизначення, але вони можуть відбуватися автоматично, коли файл заголовка включається не один раз, тому вони приймаються мовчки і без ефекту. Вважається, що нетривіальне відновлення вважається помилкою, тому воно провокує попереджувальне повідомлення від препроцесора. Однак іноді корисно змінити визначення макросу в середині компіляції. Ви можете заборонити попередження, скасувавши макрос за допомогою `#undef` перед другим визначенням.

Для того, щоб повторна декларація була тривіальною, нове визначення повинно точно відповідати тому, яке вже є у нас, за двома можливими винятками: проміжки можуть бути додані або видалені на початку або в кінці. Проміжок може бути змінений посередині (але не всередині рядків). Однак він може не бути ліквідований повністю, і він не може бути доданий там, де взагалі не було проміжку. Нагадаємо, що коментар вважається проміжком.

==== 1.4.8 Підводні камені та тонкощі макросів

У цьому розділі ми описуємо деякі спеціальні правила, що застосовуються до макросів та розширення макросів, і вказуємо на певні випадки, коли правила мають контрінтуїтивні наслідки, за якми потрібно стежити.

===== 1.4.8.1 Неправильно вкладені конструкції

Нагадаємо, що коли макрос викликається з аргументами, аргументи підміняються в тілі макросу, а результат перевіряється разом з рештою вхідного файлу для більшої кількості викликів макросів. Можна скласти разом виклик макросів, що надходить частково від тіла макросу і частково з фактичних аргументів. Наприклад,

[source,scala]
----
#define double(x) (2*(x))
#define call_with_1(x) x(1)
----

розширить `call_with_1 (double)` в `(2 * (1))`.

У макро визначеннях не обов'язково повинно бути збалансованих дужок. Записавши незбалансовані відкриті дужки в тіло макросу, можна створити виклик макросу, який починається всередині визначення, але закінчується поза ним. Наприклад,

[source,scala]
----
#define strange(file) fprintf (file, "%s %d",
::: strange(stderr) p, 35)
----

Цей химерний приклад розширюється на `fprintf (stderr,"%s %d", p, 35)`!

===== 1.4.8.2 Ненавмисне групування арифметики

Можливо, ви помітили, що у більшості наведених вище прикладів макросів, кожне виникнення імені аргументу макросу навколо нього має круглі дужки. Крім того, ще одна пара дужок, як правило, оточує все макрозначення. Ось чому найкраще саме так писати макроси. Припустимо, ви  визначили макрос наступним чином,

[source,scala]
----
#define ceil_div(x, y) (x + y - 1) / y
----

мета якої - розділити, округлити. (Одне використання для цієї операції - це обчислити, скільки `int` об'єктів потрібно для утримання певної кількості об'єктів `char`.) Тоді припустимо, що він використовується наступним чином:

[source,scala]
----
a = ceil_div (b & c, sizeof (int));
----

Це переростає в

[source,scala]
----
a = (b & c + sizeof (int) - 1) / sizeof (int);
----

який не робить того, що призначено. Правила пріоритету оператора C роблять його рівнозначним
до цього:

[source,scala]
----
a = (b & (c + sizeof (int) - 1)) / sizeof (int);
----

Але ми хочемо, це:

[source,scala]
----
a = ((b & c) + sizeof (int) - 1)) / sizeof (int);
----

Визначення макросу як

[source,scala]
----
#define ceil_div(x, y) ((x) + (y) - 1) / (y)
----

забезпечує бажаний результат.

Однак ненавмисне групування може спричинити інший спосіб. Розглянемо `sizeof ceil_div (1, 2)`. Це має вираз C, який обчислює розмір типу `ceil_div (1, 2)`, але насправді це означає щось дуже інше. Ось на що це розширюється:

[source,scala]
----
sizeof ((1) + (2) - 1) / (2)
----

Це візьме розмір цілого числа і розділить його на два. Правила пріоритету поставили поділ поза `sizeof`, коли він мав бути всередині. Дужки навколо цілого макро визначення можуть запобігти подібній проблемі. Ось рекомендований спосіб визначити `ceil_div`:

[source,scala]
----
#define ceil_div(x, y) (((x) + (y) - 1) / (y))
----

===== 1.4.8.3 Проковтування крапки з комою

Часто бажано розробити макрос, який перетвориться на складений вислів. Розглянемо, наприклад, наступний макрос, який переміщує вказівник (аргумент `p` говорить, куди його дістати) через символи пробілу:

[source,scala]
----
#define SKIP_SPACES (p, limit) \
{ register char *lim = (limit); \
while (p != lim) { \
if (*p++ != ' ') { \
p--; break; }}}
----

Тут Backslash-Newline використовується для розділення макро визначення, яке повинно бути єдиним рядком, щоб воно нагадувало спосіб, як такий C код був би викладений, якби не частина макрозначення. Виклик до цього макросу може бути `SKIP_SPACES (p, lim)`. Строго кажучи, виклик розширюється до складеного оператора, який є повним висловлюванням, не маючи крапки з комою для його завершення. Але це виглядає як виклик функції. Таким чином, це зводить до мінімуму плутанину, якщо ви можете використовувати його як виклик функції, записавши після цього крапку з комою, як у `SKIP_SPACES (p, lim);` Але це може спричинити неприємності перед твердженнями `else`, тому що крапка з комою - це фактично нульове твердження. Припустимо, ви пишете

[source,scala]
----
if (*p != 0)
SKIP_SPACES (p, lim);
else :::
----

Наявність двох операторів складеного оператора та нульового твердження між умовою `if` та `else` робить недійсним код C. Визначення макросу `SKIP_SPACES` може бути змінено для вирішення цієї проблеми, використовуючи оператор `do:::while`. Ось як:

[source,scala]
----
#define SKIP_SPACES (p, limit) \
do { register char *lim = (limit); \
while (p != lim) { \
if (*p++ != ' ') { \
p--; break; }}} \
while (0)
----

Тепер `SKIP_SPACES (p, lim);` розширюється в `do {:::} while (0);`, що є одним твердженням.

===== 1.4.8.4 Дублювання побічних ефектів

Багато програм C визначають макрос `min` для мінімуму, наприклад:

[source,scala]
----
#define min(X, Y) ((X) < (Y) ? (X) : (Y))
----

When you use this macro with an argument containing a side eect, as shown here,
next = min (x + y, foo (z));
it expands as follows:
next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));
where `x+y' has been substituted for `X' and `foo (z)' for `Y'.
The function `foo' is used only once in the statement as it appears in the program, but
the expression `foo (z)' has been substituted twice into the macro expansion. As a result,
`foo' might be called two times when the statement is executed. If it has side eects or if
it takes a long time to compute, the results might not be what you intended. We say that
`min' is an unsafe macro.
The best solution to this problem is to dene `min' in a way that computes the value of
`foo (z)' only once. The C language oers no standard way to do this, but it can be done
with GNU C extensions as follows:
#define min(X, Y) \
({ typeof (X) __x = (X), __y = (Y); \
(__x < __y) ? __x : __y; })
If you do not wish to use GNU C extensions, the only solution is to be careful when
using the macro `min'. For example, you can calculate the value of `foo (z)', save it in a
variable, and use that variable in `min':
#define min(X, Y) ((X) < (Y) ? (X) : (Y))
::: {
int tem = foo (z);
next = min (x + y, tem);
}
(where we assume that `foo' returns type `int').

===== 1.4.8.5 Самореференційні макроси

A self-referential macro is one whose name appears in its denition. A special feature of
ANSI Standard C is that the self-reference is not considered a macro call. It is passed into
the preprocessor output unchanged.
Let's consider an example:
#define foo (4 + foo)
where `foo' is also a variable in your program.
Following the ordinary rules, each reference to `foo' will expand into `(4 + foo)'; then
this will be rescanned and will expand into `(4 + (4 + foo))'; and so on until it causes a
fatal error (memory full) in the preprocessor.
However, the special rule about self-reference cuts this process short after one step, at
`(4 + foo)'. Therefore, this macro denition has the possibly useful eect of causing the
program to add 4 to the value of `foo' wherever `foo' is referred to.
In most cases, it is a bad idea to take advantage of this feature. A person reading the
program who sees that `foo' is a variable will not expect that it is a macro as well. The
reader will come across the identier `foo' in the program and think its value should be
that of the variable `foo', whereas in fact the value is four greater.
The special rule for self-reference applies also to indirect self-reference. This is the case
where a macro x expands to use a macro `y', and the expansion of `y' refers to the macro
`x'. The resulting reference to `x' comes indirectly from the expansion of `x', so it is a
self-reference and is not further expanded. Thus, after
#define x (4 + y)
#define y (2 * x)
`x' would expand into `(4 + (2 * x))'. Clear?
But suppose `y' is used elsewhere, not from the denition of `x'. Then the use of `x'
in the expansion of `y' is not a self-reference because `x' is not \in progress". So it does
expand. However, the expansion of `x' contains a reference to `y', and that is an indirect
self-reference now because `y' is \in progress". The result is that `y' expands to `(2 * (4 +
y))'.
It is not clear that this behavior would ever be useful, but it is specied by the ANSI C
standard, so you may need to understand it.
1.4.8.6 Separate Expansion of Macro Arguments
We have explained that the expansion of a macro, including the substituted actual
arguments, is scanned over again for macro calls to be expanded.
What really happens is more subtle: rst each actual argument text is scanned separately
for macro calls. Then the results of this are substituted into the macro body to produce
the macro expansion, and the macro expansion is scanned again for macros to expand.
The result is that the actual arguments are scanned twice to expand macro calls in them.
Most of the time, this has no eect. If the actual argument contained any macro calls,
they are expanded during the rst scan. The result therefore contains no macro calls, so the
second scan does not change it. If the actual argument were substituted as given, with no
Chapter 1: The C Preprocessor 21
prescan, the single remaining scan would nd the same macro calls and produce the same
results.
You might expect the double scan to change the results when a self-referential macro is
used in an actual argument of another macro (see Section 1.4.8.5 [Self-Reference], page 20):
the self-referential macro would be expanded once in the rst scan, and a second time in
the second scan. But this is not what happens. The self-references that do not expand in
the rst scan are marked so that they will not expand in the second scan either.
The prescan is not done when an argument is stringied or concatenated. Thus,
#define str(s) #s
#define foo 4
str (foo)
expands to `"foo"'. Once more, prescan has been prevented from having any noticeable
eect.
More precisely, stringication and concatenation use the argument as written, in unprescanned form. The same actual argument would be used in prescanned form if it is
substituted elsewhere without stringication or concatenation.
#define str(s) #s lose(s)
#define foo 4
str (foo)
expands to `"foo" lose(4)'.
You might now ask, \Why mention the prescan, if it makes no dierence? And why not
skip it and make the preprocessor faster?" The answer is that the prescan does make a
dierence in three special cases:  Nested calls to a macro.  Macros that call other macros that stringify or concatenate.  Macros whose expansions contain unshielded commas.
We say that nested calls to a macro occur when a macro's actual argument contains a
call to that very macro. For example, if `f' is a macro that expects one argument, `f (f
(1))' is a nested pair of calls to `f'. The desired expansion is made by expanding `f (1)'
and substituting that into the denition of `f'. The prescan causes the expected result to
happen. Without the prescan, `f (1)' itself would be substituted as an actual argument,
and the inner use of `f' would appear during the main scan as an indirect self-reference and
would not be expanded. Here, the prescan cancels an undesirable side eect (in the medical,
not computational, sense of the term) of the special rule for self-referential macros.
But prescan causes trouble in certain other cases of nested macro calls. Here is an
example:
#define foo a,b
#define bar(x) lose(x)
#define lose(x) (1 + (x))
bar(foo)
We would like `bar(foo)' to turn into `(1 + (foo))', which would then turn into `(1 +
(a,b))'. But instead, `bar(foo)' expands into `lose(a,b)', and you get an error because
22 The C Preprocessor
lose requires a single argument. In this case, the problem is easily solved by the same
parentheses that ought to be used to prevent misnesting of arithmetic operations:
#define foo (a,b)
#define bar(x) lose((x))
The problem is more serious when the operands of the macro are not expressions; for
example, when they are statements. Then parentheses are unacceptable because they would
make for invalid C code:
#define foo { int a, b; ::: }
In GNU C you can shield the commas using the `({:::})' construct which turns a compound
statement into an expression:
#define foo ({ int a, b; ::: })
Or you can rewrite the macro denition to avoid such commas:
#define foo { int a; int b; ::: }
There is also one case where prescan is useful. It is possible to use prescan to expand
an argument and then stringify it|if you use two levels of macros. Let's add a new macro
`xstr' to the example shown above:
#define xstr(s) str(s)
#define str(s) #s
#define foo 4
xstr (foo)
This expands into `"4"', not `"foo"'. The reason for the dierence is that the argument
of `xstr' is expanded at prescan (because `xstr' does not specify stringication or concatenation of the argument). The result of prescan then forms the actual argument for `str'.
`str' uses its argument without prescan because it performs stringication; but it cannot
prevent or undo the prescanning already done by `xstr'.
1.4.8.7 Cascaded Use of Macros
A cascade of macros is when one macro's body contains a reference to another macro.
This is very common practice. For example,
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
This is not at all the same as dening `TABLESIZE' to be `1020'. The `#define' for
`TABLESIZE' uses exactly the body you specify|in this case, `BUFSIZE'|and does not check
to see whether it too is the name of a macro.
It's only when you use `TABLESIZE' that the result of its expansion is checked for more
macro names.
This makes a dierence if you change the denition of `BUFSIZE' at some point in
the source file. `TABLESIZE', dened as shown, will always expand using the denition
of `BUFSIZE' that is currently in eect:
#define BUFSIZE 1020
#define TABLESIZE BUFSIZE
#undef BUFSIZE
#define BUFSIZE 37
Chapter 1: The C Preprocessor 23
Now `TABLESIZE' expands (in two stages) to `37'. (The `#undef' is to prevent any warning
about the nontrivial redenition of BUFSIZE.)
1.4.9 Newlines in Macro Arguments
Traditional macro processing carries forward all newlines in macro arguments into the
expansion of the macro. This means that, if some of the arguments are substituted more
than once, or not at all, or out of order, newlines can be duplicated, lost, or moved around
within the expansion. If the expansion consists of multiple statements, then the eect is
to distort the line numbers of some of these statements. The result can be incorrect line
numbers, in error messages or displayed in a debugger.
The GNU C preprocessor operating in ANSI C mode adjusts appropriately for multiple
use of an argument|the rst use expands all the newlines, and subsequent uses of the
same argument produce no newlines. But even in this mode, it can produce incorrect line
numbering if arguments are used out of order, or not used at all.
Here is an example illustrating this problem:
#define ignore_second_arg(a,b,c) a; c
ignore_second_arg (foo (),
ignored (),
syntax error);
The syntax error triggered by the tokens `syntax error' results in an error message citing
line four, even though the statement text comes from line ve.
1.5 Conditionals
In a macro processor, a conditional is a directive that allows a part of the program to be
ignored during compilation, on some conditions. In the C preprocessor, a conditional can
test either an arithmetic expression or whether a name is dened as a macro.
A conditional in the C preprocessor resembles in some ways an `if' statement in C, but it
is important to understand the dierence between them. The condition in an `if' statement
is tested during the execution of your program. Its purpose is to allow your program to
behave dierently from run to run, depending on the data it is operating on. The condition
in a preprocessing conditional directive is tested when your program is compiled. Its purpose
is to allow dierent code to be included in the program depending on the situation at the
time of compilation.
1.5.1 Why Conditionals are Used
Generally there are three kinds of reason to use a conditional.  A program may need to use dierent code depending on the machine or operating
system it is to run on. In some cases the code for one operating system may be
erroneous on another operating system; for example, it might refer to library routines
that do not exist on the other system. When this happens, it is not enough to avoid
executing the invalid code: merely having it in the program makes it impossible to link
24 The C Preprocessor
the program and run it. With a preprocessing conditional, the oending code can be
eectively excised from the program when it is not valid.  You may want to be able to compile the same source file into two dierent programs. Sometimes the dierence between the programs is that one makes frequent
time-consuming consistency checks on its intermediate data, or prints the values of
those data for debugging, while the other does not.  A conditional whose condition is always false is a good way to exclude code from the
program but keep it as a sort of comment for future reference.
Most simple programs that are intended to run on only one machine will not need to
use preprocessing conditionals.
1.5.2 Syntax of Conditionals
A conditional in the C preprocessor begins with a conditional directive: `#if', `#ifdef'
or `#ifndef'. See Section 1.5.4 [Conditionals-Macros], page 26, for information on `#ifdef'
and `#ifndef'; only `#if' is explained here.
1.5.2.1 The `#if' Directive
The `#if' directive in its simplest form consists of
#if expression
controlled text
#endif /* expression */
The comment following the `#endif' is not required, but it is a good practice because it
helps people match the `#endif' to the corresponding `#if'. Such comments should always
be used, except in short conditionals that are not nested. In fact, you can put anything at
all after the `#endif' and it will be ignored by the GNU C preprocessor, but only comments
are acceptable in ANSI Standard C.
expression is a C expression of integer type, sub ject to stringent restrictions. It may
contain
 Integer constants, which are all regarded as long or unsigned long.  Character constants, which are interpreted according to the character set and conventions of the machine and operating system on which the preprocessor is running. The
GNU C preprocessor uses the C data type `char' for these character constants; therefore, whether some character codes are negative is determined by the C compiler used
to compile the preprocessor. If it treats `char' as signed, then character codes large
enough to set the sign bit will be considered negative; otherwise, no character code is
considered negative.  Arithmetic operators for addition, subtraction, multiplication, division, bitwise operations, shifts, comparisons, and logical operations (`&&' and `||').  Identiers that are not macros, which are all treated as zero(!).  Macro calls. All macro calls in the expression are expanded before actual computation
of the expression's value begins.
Chapter 1: The C Preprocessor 25
Note that `sizeof' operators and enum-type values are not allowed. enum-type values,
like all other identiers that are not taken as macro calls and expanded, are treated as zero.
The controlled text inside of a conditional can include preprocessing directives. Then
the directives inside the conditional are obeyed only if that branch of the conditional succeeds. The text can also contain other conditional groups. However, the `#if' and `#endif'
directives must balance.
1.5.2.2 The `#else' Directive
The `#else' directive can be added to a conditional to provide alternative text to be
used if the condition is false. This is what it looks like:
#if expression
text-if-true
#else /* Not expression */
text-if-false
#endif /* Not expression */
If expression is nonzero, and thus the text-if-true is active, then `#else' acts like a failing
conditional and the text-if-false is ignored. Contrariwise, if the `#if' conditional fails, the
text-if-false is considered included.
1.5.2.3 The `#elif' Directive
One common case of nested conditionals is used to check for more than two possible
alternatives. For example, you might have
#if X == 1
::: #else /* X != 1 */
#if X == 2
::: #else /* X != 2 */
::: #endif /* X != 2 */
#endif /* X != 1 */
Another conditional directive, `#elif', allows this to be abbreviated as follows:
#if X == 1
::: #elif X == 2
::: #else /* X != 2 and X != 1*/
::: #endif /* X != 2 and X != 1*/
`#elif' stands for \else if". Like `#else', it goes in the middle of a `#if'-`#endif' pair
and subdivides it; it does not require a matching `#endif' of its own. Like `#if', the `#elif'
directive includes an expression to be tested.
The text following the `#elif' is processed only if the original `#if'-condition failed and
the `#elif' condition succeeds. More than one `#elif' can go in the same `#if'-`#endif'
26 The C Preprocessor
group. Then the text after each `#elif' is processed only if the `#elif' condition succeeds
after the original `#if' and any previous `#elif' directives within it have failed. `#else' is
equivalent to `#elif 1', and `#else' is allowed after any number of `#elif' directives, but
`#elif' may not follow `#else'.
1.5.3 Keeping Deleted Code for Future Reference
If you replace or delete a part of the program but want to keep the old code around
as a comment for future reference, the easy way to do this is to put `#if 0' before it and
`#endif' after it. This is better than using comment delimiters `/*' and `*/' since those
won't work if the code already contains comments (C comments do not nest).
This works even if the code being turned o contains conditionals, but they must be
entire conditionals (balanced `#if' and `#endif').
Conversely, do not use `#if 0' for comments which are not C code. Use the comment
delimiters `/*' and `*/' instead. The interior of `#if 0' must consist of complete tokens; in
particular, singlequote characters must balance. But comments often contain unbalanced
singlequote characters (known in English as apostrophes). These confuse `#if 0'. They do
not confuse `/*'.
1.5.4 Conditionals and Macros
Conditionals are useful in connection with macros or assertions, because those are the
only ways that an expression's value can vary from one compilation to another. A `#if'
directive whose expression uses no macros or assertions is equivalent to `#if 1' or `#if 0';
you might as well determine which one, by computing the value of the expression yourself,
and then simplify the program.
For example, here is a conditional that tests the expression `BUFSIZE == 1020', where
`BUFSIZE' must be a macro.
#if BUFSIZE == 1020
printf ("Large buffers!\n");
#endif /* BUFSIZE is large */
(Programmers often wish they could test the size of a variable or data type in `#if', but
this does not work. The preprocessor does not understand sizeof, or typedef names, or
even the type keywords such as int.)
The special operator `defined' is used in `#if' expressions to test whether a certain
name is dened as a macro. Either `defined name' or `defined (name)' is an expression
whose value is 1 if name is dened as macro at the current point in the program, and 0
otherwise. For the `defined' operator it makes no dierence what the denition of the
macro is; all that matters is whether there is a denition. Thus, for example,
#if defined (vax) || defined (ns16000)
would succeed if either of the names `vax' and `ns16000' is dened as a macro. You can
test the same condition using assertions (see Section 1.5.5 [Assertions], page 27), like this:
#if #cpu (vax) || #cpu (ns16000)
Chapter 1: The C Preprocessor 27
If a macro is dened and later undened with `#undef', subsequent use of the `defined'
operator returns 0, because the name is no longer dened. If the macro is dened again
with another `#define', `defined' will recommence returning 1.
Conditionals that test whether just one name is dened are very common, so there are
two special short conditional directives for this case.
#ifdef name
is equivalent to `#if defined (name)'.
#ifndef name
is equivalent to `#if ! defined (name)'.
Macro denitions can vary between compilations for several reasons.  Some macros are predened on each kind of machine. For example, on a Vax, the name
`vax' is a predened macro. On other machines, it would not be dened.  Many more macros are dened by system header files. Dierent systems and machines
dene dierent macros, or give them dierent values. It is useful to test these macros
with conditionals to avoid using a system feature on a machine where it is not implemented.  Macros are a common way of allowing users to customize a program for dierent machines or applications. For example, the macro `BUFSIZE' might be dened in a conguration file for your program that is included as a header file in each source file. You
would use `BUFSIZE' in a preprocessing conditional in order to generate dierent code
depending on the chosen conguration.  Macros can be dened or undened with `-D' and `-U' command options when you
compile the program. You can arrange to compile the same source file into two dierent programs by choosing a macro name to specify which program you want, writing
conditionals to test whether or how this macro is dened, and then controlling the state
of the macro with compiler command options. See Section 1.9 [Invocation], page 31.
1.5.5 Assertions
Assertions are a more systematic alternative to macros in writing conditionals to test
what sort of computer or system the compiled program will run on. Assertions are usually
predened, but you can dene them with preprocessing directives or command-line options.
The macros traditionally used to describe the type of target are not classied in any
way according to which question they answer; they may indicate a hardware architecture,
a particular hardware model, an operating system, a particular version of an operating
system, or specic conguration options. These are jumbled together in a single namespace.
In contrast, each assertion consists of a named question and an answer. The question is
usually called the predicate. An assertion looks like this:
#predicate (answer)
You must use a properly formed identier for predicate. The value of answer can be any
sequence of words; all characters are signicant except for leading and trailing whitespace,
and dierences in internal whitespace sequences are ignored. Thus, `x+y' is dierent from
`x+y' but equivalent to `x+y'. `)' is not allowed in an answer.
28 The C Preprocessor
Here is a conditional to test whether the answer answer is asserted for the predicate
predicate:
#if #predicate (answer)
There may be more than one answer asserted for a given predicate. If you omit the answer,
you can test whether any answer is asserted for predicate:
#if #predicate
Most of the time, the assertions you test will be predened assertions. GNU C provides
three predened predicates: system, cpu, and machine. system is for assertions about the
type of software, cpu describes the type of computer architecture, and machine gives more
information about the computer. For example, on a GNU system, the following assertions
would be true:
#system (gnu)
#system (mach)
#system (mach 3)
#system (mach 3.subversion)
#system (hurd)
#system (hurd version)
and perhaps others. The alternatives with more or less version information let you ask more
or less detailed questions about the type of system software.
On a Unix system, you would nd #system (unix) and perhaps one of: #system (aix), #system (bsd), #system (hpux), #system (lynx), #system (mach), #system (posix), #system (svr3), #system (svr4), or #system (xpg4) with possible version numbers following.
Other values for system are #system (mvs) and #system (vms). Portability note: Many Unix C compilers provide only one answer for the system assertion: #system (unix), if they support assertions at all. This is less than useful.
An assertion with a multi-word answer is completely dierent from several assertions
with individual single-word answers. For example, the presence of system (mach 3.0) does
not mean that system (3.0) is true. It also does not directly imply system (mach), but
in GNU C, that last will normally be asserted as well.
The current list of possible assertion values for cpu is: #cpu (a29k), #cpu (alpha), #cpu (arm), #cpu (clipper), #cpu (convex), #cpu (elxsi), #cpu (tron), #cpu (h8300), #cpu (i370), #cpu (i386), #cpu (i860), #cpu (i960), #cpu (m68k), #cpu (m88k), #cpu
(mips), #cpu (ns32k), #cpu (hppa), #cpu (pyr), #cpu (ibm032), #cpu (rs6000), #cpu
(sh), #cpu (sparc), #cpu (spur), #cpu (tahoe), #cpu (vax), #cpu (we32000). You can create assertions within a C program using `#assert', like this:
#assert predicate (answer)
(Note the absence of a `#' before predicate.)
Each time you do this, you assert a new true answer for predicate. Asserting one answer
does not invalidate previously asserted answers; they all remain true. The only way to
remove an assertion is with `#unassert'. `#unassert' has the same syntax as `#assert'.
You can also remove all assertions about predicate like this:
Chapter 1: The C Preprocessor 29
#unassert predicate
You can also add or cancel assertions using command options when you run gcc or cpp. See Section 1.9 [Invocation], page 31.
1.5.6 The `#error' and `#warning' Directives
The directive `#error' causes the preprocessor to report a fatal error. The rest of the
line that follows `#error' is used as the error message.
You would use `#error' inside of a conditional that detects a combination of parameters
which you know the program does not properly support. For example, if you know that the
program will not run properly on a Vax, you might write
#ifdef __vax__
#error Won't work on Vaxen. See comments at get_last_object.
#endif
See Section 1.4.3.2 [Nonstandard Predened], page 12, for why this works.
If you have several conguration parameters that must be set up by the installation in
a consistent way, you can use conditionals to detect an inconsistency and report it with
`#error'. For example,
#if HASH_TABLE_SIZE % 2 == 0 || HASH_TABLE_SIZE % 3 == 0 \
|| HASH_TABLE_SIZE % 5 == 0
#error HASH_TABLE_SIZE should not be divisible by a small prime
#endif
The directive `#warning' is like the directive `#error', but causes the preprocessor to
issue a warning and continue preprocessing. The rest of the line that follows `#warning' is
used as the warning message.
You might use `#warning' in obsolete header files, with a message directing the user to
the header file which should be used instead.
1.6 Combining Source Files
One of the jobs of the C preprocessor is to inform the C compiler of where each line of
C code came from: which source file and which line number.
C code can come from multiple source files if you use `#include'; both `#include' and
the use of conditionals and macros can cause the line number of a line in the preprocessor
output to be dierent from the line's number in the original source file. You will appreciate
the value of making both the C compiler (in error messages) and symbolic debuggers such
as GDB use the line numbers in your source file.
The C preprocessor builds on this feature by oering a directive by which you can control
the feature explicitly. This is useful when a file for input to the C preprocessor is the output
from another program such as the bison parser generator, which operates on another file
that is the true source file. Parts of the output from bison are generated from scratch,
other parts come from a standard parser file. The rest are copied nearly verbatim from the
source file, but their line numbers in the bison output are not the same as their original
line numbers. Naturally you would like compiler error messages and symbolic debuggers to
know the original source file and line number of each line in the bison input.
30 The C Preprocessor
bison arranges this by writing `#line' directives into the output file. `#line' is a
directive that species the original line number and source file name for subsequent input
in the current preprocessor input file. `#line' has three variants:
#line linenum
Here linenum is a decimal integer constant. This species that the line number
of the following line of input, in its original source file, was linenum. #line linenum lename
Here linenum is a decimal integer constant and lename is a string constant.
This species that the following line of input came originally from source file
lename and its line number there was linenum. Keep in mind that lename is
not just a file name; it is surrounded by doublequote characters so that it looks
like a string constant.
#line anything else
anything else is checked for macro calls, which are expanded. The result should
be a decimal integer constant followed optionally by a string constant, as described above.
`#line' directives alter the results of the `__FILE__' and `__LINE__' predened macros
from that point on. See Section 1.4.3.1 [Standard Predened], page 10.
The output of the preprocessor (which is the input for the rest of the compiler) contains
directives that look much like `#line' directives. They start with just `#' instead of `#line',
but this is followed by a line number and file name as in `#line'. See Section 1.8 [Output],
page 31.
1.7 Miscellaneous Preprocessing Directives
This section describes three additional preprocessing directives. They are not very useful,
but are mentioned for completeness.
The null directive consists of a `#' followed by a Newline, with only whitespace (including
comments) in between. A null directive is understood as a preprocessing directive but has
no eect on the preprocessor output. The primary signicance of the existence of the null
directive is that an input line consisting of just a `#' will produce no output, rather than a
line of output containing just a `#'. Supposedly some old C programs contain such lines.
The ANSI standard species that the `#pragma' directive has an arbitrary, implementationdened eect. In the GNU C preprocessor, `#pragma' directives are not used, except for
`#pragma once' (see Section 1.3.4 [Once-Only], page 5). However, they are left in the
preprocessor output, so they are available to the compilation pass.
The `#ident' directive is supported for compatibility with certain other systems. It is
followed by a line of text. On some systems, the text is copied into a special place in the
ob ject file; on most systems, the text is ignored and this directive has no eect. Typically
`#ident' is only used in header files supplied with those systems where it is meaningful.
Chapter 1: The C Preprocessor 31
1.8 C Preprocessor Output
The output from the C preprocessor looks much like the input, except that all preprocessing directive lines have been replaced with blank lines and all comments with spaces.
Whitespace within a line is not altered; however, a space is inserted after the expansions of
most macro calls.
Source file name and line number information is conveyed by lines of the form
# linenum lename ags
which are inserted as needed into the middle of the input (but never within a string or
character constant). Such a line means that the following line originated in file lename at
line linenum. After the file name comes zero or more ags, which are `1', `2', `3', or `4'. If there are
multiple ags, spaces separate them. Here is what the ags mean:
`1' This indicates the start of a new file.
`2' This indicates returning to a file (after having included another file).
`3' This indicates that the following text comes from a system header file, so certain
warnings should be suppressed.
`4' This indicates that the following text should be treated as C.
1.9 Invoking the C Preprocessor
Most often when you use the C preprocessor you will not have to invoke it explicitly:
the C compiler will do so automatically. However, the preprocessor is sometimes useful on
its own.
The C preprocessor expects two file names as arguments, inle and outle. The preprocessor reads inle together with any other files it species with `#include'. All the output
generated by the combined input files is written in outle. Either inle or outle may be `-', which as inle means to read from standard input
and as outle means to write to standard output. Also, if outle or both file names are
omitted, the standard output and standard input are used for the omitted file names.
Here is a table of command options accepted by the C preprocessor. These options can
also be given when compiling a C program; they are passed along automatically to the
preprocessor when it is invoked by the compiler.
`-P' Inhibit generation of `#'-lines with line-number information in the output from
the preprocessor (see Section 1.8 [Output], page 31). This might be useful when
running the preprocessor on something that is not C code and will be sent to a
program which might be confused by the `#'-lines.
`-C' Do not discard comments: pass them through to the output file. Comments
appearing in arguments of a macro call will be copied to the output before the
expansion of the macro call.
`-traditional'
Try to imitate the behavior of old-fashioned C, as opposed to ANSI C.
32 The C Preprocessor
 Traditional macro expansion pays no attention to singlequote or doublequote characters; macro argument symbols are replaced by the argument
values even when they appear within apparent string or character constants.  Traditionally, it is permissible for a macro expansion to end in the middle
of a string or character constant. The constant continues into the text
surrounding the macro call.  However, traditionally the end of the line terminates a string or character
constant, with no error.  In traditional C, a comment is equivalent to no text at all. (In ANSI C, a
comment counts as whitespace.)  Traditional C does not have the concept of a \preprocessing number". It
considers `1.0e+4' to be three tokens: `1.0e', `+', and `4'.  A macro is not suppressed within its own denition, in traditional C. Thus,
any macro that is used recursively inevitably causes an error.  The character `#' has no special meaning within a macro denition in traditional C.  In traditional C, the text at the end of a macro expansion can run together
with the text after the macro call, to produce a single token. (This is
impossible in ANSI C.)  Traditionally, `\' inside a macro argument suppresses the syntactic signi-
cance of the following character.
`-trigraphs'
Process ANSI standard trigraph sequences. These are three-character sequences, all starting with `??', that are dened by ANSI C to stand for single
characters. For example, `??/' stands for `\', so `'??/n'' is a character constant
for a newline. Strictly speaking, the GNU C preprocessor does not support
all programs in ANSI Standard C unless `-trigraphs' is used, but if you ever
notice the dierence it will be with relief.
You don't want to know any more about trigraphs.
`-pedantic'
Issue warnings required by the ANSI C standard in certain cases such as when
text other than a comment follows `#else' or `#endif'.
`-pedantic-errors'
Like `-pedantic', except that errors are produced rather than warnings.
`-Wtrigraphs'
Warn if any trigraphs are encountered (assuming they are enabled).
`-Wcomment'
Warn whenever a comment-start sequence `/*' appears in a comment.
`-Wall' Requests both `-Wtrigraphs' and `-Wcomment' (but not `-Wtraditional').
Chapter 1: The C Preprocessor 33
`-Wtraditional'
Warn about certain constructs that behave dierently in traditional and ANSI
C.
`-I directory'
Add the directory directory to the head of the list of directories to be searched
for header files (see Section 1.3.2 [Include Syntax], page 3). This can be used
to override a system header file, substituting your own version, since these
directories are searched before the system header file directories. If you use
more than one `-I' option, the directories are scanned in left-to-right order; the
standard system directories come after.
`-I-' Any directories specied with `-I' options before the `-I-' option are searched
only for the case of `#include "file"'; they are not searched for `#include
<file>'.
If additional directories are specied with `-I' options after the `-I-', these
directories are searched for all `#include' directives.
In addition, the `-I-' option inhibits the use of the current directory as the
rst search directory for `#include "file"'. Therefore, the current directory is
searched only if it is requested explicitly with `-I.'. Specifying both `-I-' and
`-I.' allows you to control precisely which directories are searched before the
current one and which are searched after.
`-nostdinc'
Do not search the standard system directories for header files. Only the directories you have specied with `-I' options (and the current directory, if
appropriate) are searched.
`-nostdinc++'
Do not search for header files in the C++-specic standard directories, but do
still search the other standard directories. (This option is used when building
libg++.)
`-D name' Predene name as a macro, with denition `1'.
`-D name=denition'
Predene name as a macro, with denition denition. There are no restrictions
on the contents of denition, but if you are invoking the preprocessor from a
shell or shell-like program you may need to use the shell's quoting syntax to
protect characters such as spaces that have a meaning in the shell syntax. If
you use more than one `-D' for the same name, the rightmost denition takes
eect.
`-U name' Do not predene name. If both `-U' and `-D' are specied for one name, the
`-U' beats the `-D' and the name is not predened.
`-undef' Do not predene any nonstandard macros.
`-A predicate(answer)'
Make an assertion with the predicate predicate and answer answer. See Section 1.5.5 [Assertions], page 27.
34 The C Preprocessor
You can use `-A-' to disable all predened assertions; it also undenes all predened macros that identify the type of target system.
`-dM' Instead of outputting the result of preprocessing, output a list of `#define'
directives for all the macros dened during the execution of the preprocessor,
including predened macros. This gives you a way of nding out what is predened in your version of the preprocessor; assuming you have no file `foo.h',
the command
touch foo.h; cpp -dM foo.h
will show the values of any predened macros.
`-dD' Like `-dM' except in two respects: it does not include the predened macros,
and it outputs both the `#define' directives and the result of preprocessing.
Both kinds of output go to the standard output file.
`-M [-MG]' Instead of outputting the result of preprocessing, output a rule suitable for make
describing the dependencies of the main source file. The preprocessor outputs
one make rule containing the ob ject file name for that source file, a colon, and
the names of all the included files. If there are many included files then the rule
is split into several lines using `\'-newline.
`-MG' says to treat missing header files as generated files and assume they live
in the same directory as the source file. It must be specied in addition to `-M'.
This feature is used in automatic updating of makeles.
`-MM [-MG]'
Like `-M' but mention only the files included with `#include "file"'. System
header files included with `#include <file>' are omitted.
`-MD file' Like `-M' but the dependency information is written to file. This is in addition
to compiling the file as specied|`-MD' does not inhibit ordinary compilation
the way `-M' does.
When invoking gcc, do not specify the file argument. Gcc will create file names
made by replacing ".c" with ".d" at the end of the input file names.
In Mach, you can use the utility md to merge multiple dependency files into a
single dependency file suitable for using with the `make' command.
`-MMD file' Like `-MD' except mention only user header files, not system header files.
`-H' Print the name of each header file used, in addition to other normal activities.
`-imacros file'
Process file as input, discarding the resulting output, before processing the
regular input file. Because the output generated from file is discarded, the only
eect of `-imacros file' is to make the macros dened in file available for use
in the main input.
`-include file'
Process file as input, and include all the resulting output, before processing the
regular input file.
Chapter 1: The C Preprocessor 35
`-idirafter dir '
Add the directory dir to the second include path. The directories on the second
include path are searched when a header file is not found in any of the directories
in the main include path (the one that `-I' adds to).
`-iprefix prex'
Specify prex as the prex for subsequent `-iwithprefix' options.
`-iwithprefix dir '
Add a directory to the second include path. The directory's name is made
by concatenating prex and dir, where prex was specied previously with
`-iprefix'.
`-isystem dir '
Add a directory to the beginning of the second include path, marking it as a
system directory, so that it gets the same special treatment as is applied to the
standard system directories.
`-lang-c'
`-lang-c89'
`-lang-c++'
`-lang-objc'
`-lang-objc++'
Specify the source language. `-lang-c' is the default; it allows recognition
of C++ comments (comments that begin with `//' and end at end of line),
since this is a common feature and it will most likely be in the next C standard. `-lang-c89' disables recognition of C++ comments. `-lang-c++' handles
C++ comment syntax and includes extra default include directories for C++.
`-lang-objc' enables the Ob jectiveC`#import' directive. `-lang-objc++' enables both C++ and Ob jective C extensions.
These options are generated by the compiler driver gcc, but not passed from
the `gcc' command line unless you use the driver's `-Wp' option.
`-lint' Look for commands to the program checker lint embedded in comments,
and emit them preceded by `#pragma lint'. For example, the comment `/*
NOTREACHED */' becomes `#pragma lint NOTREACHED'.
This option is available only when you call cpp directly; gcc will not pass it
from its command line.
`-$' Forbid the use of `$' in identiers. This is required for ANSI conformance. gcc
automatically supplies this option to the preprocessor if you specify `-ansi',
but gcc doesn't recognize the `-$' option itself|to use it without the other
eects of `-ansi', you must call the preprocessor directly.
