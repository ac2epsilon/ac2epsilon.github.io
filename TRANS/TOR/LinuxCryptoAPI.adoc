:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== Linux Kernel Crypto API

Author:	Stephan Mueller, Marek Vasut

У цій документації викладено крипто API ядра Linux з його концепціями, деталі щодо розробки реалізацій шифрів, використання API для випадків використання криптографічного використання, а також приклади програмування.

== Специфікація інтерфейсу крипто API

=== Вступ

Крипто API ядра пропонує багатий набір криптографічних шифрів, а також інші механізми трансформації даних та методи їх виклику. Цей документ містить опис API та надає приклад коду.

Для розуміння та правильного використання крипто-API ядра наведено коротке пояснення його структури. Виходячи з архітектури, API можна розділити на різні компоненти. Після специфікації архітектури надаються підказки розробникам шифрів. Вказівки на документацію щодо виклику функції API наводяться в кінці.

Крипто API ядра називає всі алгоритми "трансформаціями". Тому змінна ручка шифру зазвичай має назву `"tfm"`. Крім криптографічних операцій, крипто API також знає перетворення стиснення і обробляє їх так само, як і шифри.

Крипто API ядра обслуговує такі типи об'єктів:

* споживачі, які запитують криптографічні послуги
* реалізації перетворень даних (як правило, шифри), які можуть викликати споживачі за допомогою крипто API

Ця специфікація призначена для споживачів криптовалютного API ядра, а також для розробників, що реалізують шифри. Ця специфікація API, однак, не обговорює всі виклики API, доступні для реалізації перетворень даних (тобто реалізація шифрів та інші перетворення (наприклад, CRC або навіть алгоритми стиснення), які можуть реєструватися в крипто API).

Примітка: Терміни "перетворення" та шифровий алгоритм використовуються взаємозамінно.

=== Термінологія

Реалізація перетворення - це фактичний код або інтерфейс до апаратного забезпечення, який реалізує певну трансформацію з точно визначеною поведінкою.

Об'єкт перетворення (TFM) - це примірник здійснення перетворення. З однією реалізацією перетворення може бути асоційовано кілька об'єктів перетворення. Кожен з цих об'єктів трансформації утримується споживачем крипто API або іншою трансформацією. Об'єкт трансформації виділяється, коли споживач криптовалютного API вимагає здійснення перетворення. Потім споживачеві надається структура, яка містить об'єкт перетворення (TFM).

Структура, що містить об'єкти перетворення, також може називатися "ручкою шифру". Така ручка шифру завжди підпорядкована наступним фазам, які відображаються у викликах API, застосовних до такої ручки шифру:

1. Ініціалізація ручки шифру.
2. Ви конання всіх призначених для шифрування операцій, застосовних до ручки, де ручка шифру повинна бути забезпечена кожному виклику API.
3. Знищення ручки шифру.

При використанні викликів API ініціалізації створюється ручка шифру і повертається споживачеві. Тому, будь ласка, зверніться до всіх викликів API ініціалізації, які стосуються типу структури даних, який, як очікується, отримає споживач і згодом буде використовувати. Виклики API ініціалізації мають усі однакові умови іменування `crypto_alloc*`.

Контекст перетворення - це приватні дані, пов'язані з об'єктом перетворення.

== Ядро криптовалютної архітектури API

=== Типи алгоритму шифрування

Крипто API API ядра забезпечує різні виклики API для таких типів шифрів:

* Симетричні шифри
* Шифри AEAD
* Дайджест повідомлень, включаючи дайджест ключових повідомлень
* Генерація випадкових чисел
* Інтерфейс користувальницького простору

== Шифри та шаблони

Крипто API ядра забезпечує реалізацію одноблокових шифрів та дайджестів повідомлень. Крім того, крипто API ядра надає численні "шаблони", які можуть використовуватися спільно з шифрами єдиного блоку та дайджестами повідомлень. Шаблони включають всі типи блочного режиму ланцюга, механізм HMAC тощо.

Одноблокові шифри та дайджести повідомлень можуть або безпосередньо використовуватися абонентом, або викликатися разом із шаблоном для формування багатоблокових шифрів або наборів ключових повідомлень.

Одиночний блок-шифр може навіть викликатися з декількома шаблонами. Однак шаблони не можна використовувати без єдиного шифру.

Перегляньте `/proc/crypto` та знайдіть "ім'я". Наприклад:

----
aes
ecb(aes)
cmac(aes)
ccm(aes)
rfc4106(gcm(aes))
sha1
hmac(sha1)
authenc(hmac(sha1),cbc(aes))
----

У цих прикладах "aes" і "sha1" - це шифри, а всі інші - шаблони.

=== Синхронні та асинхронні операції

Крипто-API ядра забезпечує синхронні та асинхронні операції API.

Під час використання синхронної операції API, абонент викликає операцію шифрування, яка синхронно виконується крипто API. Це означає, що абонент чекає, поки закінчиться операція шифрування. Тому виклики крипто API ядра працюють як звичайні виклики функцій. Для синхронної роботи набір викликів API невеликий і концептуально схожий з будь-якою іншою крипто бібліотекою.

Асинхронна операція забезпечується крипто-API ядра, що означає, що виклик шифрованої операції завершиться майже миттєво. Це виклик запускає роботу шифру, але не сигналізує про його завершення. Перед тим, як викликати операцію з шифруванням, абонент повинен надати функцію зворотного виклику, яку може викликати крипто API ядра, щоб сигналізувати про завершення операції шифрування. Крім того, абонент повинен переконатися, що він може обробляти такі асинхронні події, застосовуючи відповідне блокування навколо своїх даних. Крипто-API ядра не виконує жодної спеціальної операції серіалізації для захисту цілісності даних абонента.

=== Посилання на крипто-API та пріоритет

Шифр посилається абонентом за допомогою рядка. Цей рядок має таку семантику:

----
шаблон (одноблоковий шифр)
----

де "шаблон" і "одноблоковий шифр" є вищезгаданим шаблоном і одноблоковим шифром відповідно. Якщо можливо, додаткові шаблони можуть містити інші шаблони, такі як

----
шбалон1 (шаблон2 (одноблоковий шифр)))
----

Крипто API ядра може надавати кілька реалізацій шаблону або одного блочного шифру. Наприклад, AES для новіших апаратних засобів Intel має такі реалізації: AES-NI, реалізація асемблера або прямий C. Тепер, коли використовується рядок "aes" з крипто API ядра, яка шифрована реалізація використовується? Відповідь на це питання - номер пріоритету, присвоєний кожній програмі шифрування крипто API. Коли абонент використовує рядок для посилання на шифр під час ініціалізації ручки шифру, крипто API шукає всі реалізації, що забезпечують реалізацію з цим ім'ям, і вибирає реалізацію з найвищим пріоритетом.

Тепер у абонента може виникнути потреба звернутися до конкретної програми шифрування, і тому він не хоче покладатися на вибір, орієнтований на пріоритет. Для адаптації до цього сценарію крипто API ядра дозволяє реалізації шифрованому реєструвати унікальне ім’я на додаток до загальних імен. При використанні цього унікального імені, абонент завжди повинен обов'язково посилатися на передбачувану реалізацію шифру.

Список доступних шифрів наведено в `/proc/crypto`. Однак у цьому списку не вказані всі можливі перестановки шаблонів та шифрів. Кожен блок, перелічений у `/proc/crypto`, може містити таку інформацію - якщо один із перелічених нижче компонентів не застосовується до шифру, він не відображається:

* `name`: загальне ім'я шифру, що підлягає вибору на основі пріоритету - це ім'я може використовуватися при виклику API розподілу шифрів (усі перелічені вище імена є прикладами для таких загальних імен)
* `driver`: унікальне ім'я шифру - це ім'я може використовуватися при виклику API розподілу шифрів
* `module`: модуль ядра, що забезпечує реалізацію шифру (або "ядро" для статично пов'язаних шифрів)
* `priority`: пріоритетне значення реалізації шифру
* `refcnt`: кількість посилань відповідного шифру (тобто кількість поточних споживачів цього шифру)
* `selftest`: уточнення, чи пройшов самотест для шифру
* `type`: 
** `skcipher` для симетричних ключових шифрів
** `cipher` для одноблокових шифрів, які можуть використовуватися з додатковим шаблоном
** `shash` для синхронного дайджесту повідомлень
** `ahash` для асинхронного дайджесту повідомлень
** `aead` для типу шифру AEAD
** `compression` для перетворень типу стиснення
** `rng` для генератора випадкових чисел
** `givcipher` для шифру з пов'язаним IV генератором (див. запис geniv нижче для специфікації типу IV генератора, використовуваного при впровадженні шифру)
** `kpp` для шифрувального протоколу протоколу ключових угод (KPP), такого як виконання ECDH або DH
* `blocksize`: блокування шифру в байтах
* `keysize`: розмір ключа в байтах
* `ivsize`: IV розмір у байтах
* `seedsize`: необхідний розмір даних зерня для генератора випадкових чисел
* `digestsize`: розмір виводу дайджесту повідомлень
* `geniv`: тип генерації IV:
** `eseqiv` для зашифрованого порядкового номера на основі генерації IV покоління
** `seqiv` для послідовного номера на основі генерації IV
** `chainiv` для генерації ланцюга iv
** `<builtin>` - маркер, за допомогою якого шифр реалізує генерацію IV та обробку, оскільки він специфічний для даного шифру

=== Розміри ключів

Виділяючи ручку шифру, абонент визначає лише тип шифру. Однак симетричні шифри, як правило, підтримують кілька розмірів ключа (наприклад, AES-128 vs. AES-192 vs. AES-256). Ці розміри ключів визначаються довжиною наданого ключа. Таким чином, крипто API ядра не забезпечує окремого способу вибору конкретного розміру ключа симетричного шифру.

=== Тип виділення шифрів і маски

Різні функції розподілу ручок шифрів дозволяють задати тип та прапор маски. Обидва параметри мають наступне значення (і тому не висвітлюються в наступних розділах).

Прапор типу визначає тип алгоритму шифрування. Абонент, як правило, отримує 0, коли абонент хоче обробку за замовчуванням. В іншому випадку абонент може надати наступні варіанти, які відповідають вищезазначеним типам шифрів:

`CRYPTO_ALG_TYPE_CIPHER` Одноблочний шифр
`CRYPTO_ALG_TYPE_COMPRESS` Стиснення
`CRYPTO_ALG_TYPE_AEAD` Автентифіковане шифрування з пов’язаними даними (MAC)
`CRYPTO_ALG_TYPE_BLKCIPHER` Синхронний багатоблоковий шифр
`CRYPTO_ALG_TYPE_ABLKCIPHER` Асинхронний багатоблоковий шифр
`CRYPTO_ALG_TYPE_GIVCIPHER` Асинхронний багатоблоковий шифр, упакований разом з IV генератором (див. `geniv` поле у ​​списку `/proc/crypto` для відомих IV генераторів)
`CRYPTO_ALG_TYPE_KPP` Примітив протокла ключових угод (KPP), такий як впровадження ECDH або DH
`CRYPTO_ALG_TYPE_DIGEST` Дайджест сирого повідомлення
`CRYPTO_ALG_TYPE_HASH` Псевдонім для `CRYPTO_ALG_TYPE_DIGEST`
`CRYPTO_ALG_TYPE_SHASH` Синхронний мультиблоковий хеш
`CRYPTO_ALG_TYPE_AHASH` Асинхронний мультиблоковий хеш
`CRYPTO_ALG_TYPE_RNG` Генерація випадкових чисел
`CRYPTO_ALG_TYPE_AKCIPHER` Асиметричний шифр
`CRYPTO_ALG_TYPE_PCOMPRESS` Розширена версія CRYPTO_ALG_TYPE_COMPRESS, що дозволяє сегментувати компресію/декомпресію замість виконання операції лише на одному сегменті. `CRYPTO_ALG_TYPE_PCOMPRESS` призначений замінити `CRYPTO_ALG_TYPE_COMPRESS` після перетворення існуючих споживачів.

Прапор маски обмежує тип шифру. Єдиний дозволений прапор - це `CRYPTO_ALG_ASYNC` для обмеження функції пошуку шифрів асинхронними шифрами. Зазвичай абонент надає 0 для прапора маски.

Коли абонент надає специфікацію маски та типу, виклик обмежує пошук, який може виконувати крипто API API ядра для відповідної реалізації шифру для даного імені шифру. Це означає, що навіть коли абонент використовує ім'я шифру, яке існує під час його виклику ініціалізації, API криптовалути ядра може не вибрати його через використовуваний тип та поля маски.

== Внутрішня структура крипто API

API крипто ядра має внутрішню структуру, де шифрована реалізація може використовувати багато шарів та непрямих напрямків. Цей розділ допоможе з’ясувати, як крипто API API використовує різні компоненти для реалізації повного шифру.

Наступні підрозділи пояснюють внутрішню структуру на основі існуючих шифрованих реалізацій. Перший розділ стосується найскладнішого сценарію, коли всі інші сценарії утворюють логічну підмножину.

=== Загальна структура шифрів AEAD

Наступне мистецтво ASCII розкладає шари API криптовалюти ядра при використанні шифру AEAD з автоматизованою генерацією IV. Наведений приклад використовується шаром IPSEC.

Для інших випадків використання шифрів AEAD застосовується також мистецтво ASCII, але абонент може не використовувати шифр AEAD з окремим IV генератором. У цьому випадку абонент повинен генерувати IV.

Наведений приклад розкладає шифр AEAD GCM (AES) на основі загальних реалізацій C (`gcm.c`, `aes-generic.c`, `ctr.c`, `ghash-generic.c`, `seqiv.c`). Загальна реалізація слугує прикладом, що показує повну логіку крипто API ядра.

Можливо, що деякі обтічні реалізації шифрів (наприклад, AES-NI) забезпечують реалізацію об'єднуючих аспектів, які з точки зору крипто API не можуть розкладатися на шари. У разі реалізації AES-NI режим CTR, реалізація GHASH та шифр AES об'єднуються в одну реалізацію шифру, зареєстровану за допомогою крипто API ядра. У цьому випадку також застосовується концепція, описана в наступному мистецтві ASCII. Однак декомпозиція GCM на окремі підкомпоненти за допомогою крипто-API ядра вже не робиться.

Кожен блок у наступному мистецтві ASCII є незалежним екземпляром шифру, отриманим від крипто API ядра. До кожного блоку звертається абонент або інші блоки з використанням функцій API, визначених крипто API ядра для типу реалізації шифру.

Блоки нижче вказують тип шифру, а також певну логіку, реалізовану в шифрі.

Зображення мистецтва ASCII також вказує структуру виклику, тобто хто викликає, який компонент. Стрілки вказують на викликаний блок, де абонент використовує API, застосовний до типу шифру, визначеного для блоку.

----

kernel crypto API                                |   IPSEC Layer
                                                 |
+-----------+                                    |
|           |            (1)
|   aead    | <-----------------------------------  esp_output
|  (seqiv)  | ---+
+-----------+    |
                 | (2)
+-----------+    |
|           | <--+                (2)
|   aead    | <-----------------------------------  esp_input
|   (gcm)   | ------------+
+-----------+             |
      | (3)               | (5)
      v                   v
+-----------+       +-----------+
|           |       |           |
|  skcipher |       |   ahash   |
|   (ctr)   | ---+  |  (ghash)  |
+-----------+    |  +-----------+
                 |
+-----------+    | (4)
|           | <--+
|   cipher  |
|   (aes)   |
+-----------+
----

Наступна послідовність викликів застосовна, коли рівень IPSEC запускає операцію шифрування за допомогою функції `esp_output`. Під час конфігурації адміністратор встановив використання rfc4106 (gcm (aes)) в якості шифру для ESP. Наступна послідовність викликів тепер зображена в області ASCII вище:

`esp_output()` викликає `crypto_aead_encrypt()`, щоб запустити операцію шифрування шифру AEAD з IV генератором.

У випадку GCM реалізація SEQIV реєструється як GIVCIPHER у `crypto_rfc4106_alloc()`.

SEQIV виконує свою операцію з генерування IV, де основною функцією є `seqiv_geniv()`.

Тепер SEQIV використовує виклики функції AEAD API, щоб викликати пов'язаний AEAD шифр. У нашому випадку під час інстанції SEQIV ручка шифру для GCM надається SEQIV. Це означає, що SEQIV викликає операції шифрування AEAD за допомогою ручки шифру GCM.

Під час створення екземпляра рукоятки GCM інстанціюються шифри CTR (AES) та GHASH. Ручки шифрів для CTR (AES) та GHASH зберігаються для подальшого використання.

Реалізація GCM несе відповідальність за виклик AES режиму CTR та шифру GHASH належним чином для реалізації специфікації GCM.

Реалізація типу шифрування AEAD GCM тепер викликає API SKCIPHER з інстанційною ручкою шифру CTR (AES).

Під час інстанціювання шифру CTR (AES), реалізація AES типу CIPHER інстанціюється. Ручка шифру для AES збережена.

Це означає, що SKCIPHER реалізація CTR(AES) реалізує лише режим ланцюга блоків CTR. Після виконання операції зціплення блоків викликається CIPHER реалізація AES.

Тепер SKCIPHER CTR(AES) викликає API CIPHER за допомогою шифру AES для шифрування одного блоку.

Реалізація GCM AEAD також викликає реалізацію шифру GHASH через API AHASH.

Коли рівень IPSEC запускає функцію `esp_input()`, слідує та сама послідовність викликів з тією лише різницею, що операція починається з кроку (2).

=== Загальна структура блокового шифру

Універсальні блок-шифри дотримуються тієї ж концепції, що зображена на зображенні ASCII мистецтва вище.

Наприклад, CBC(AES) реалізований за допомогою `cbc.c` та `aes-generic.c`. Зображення мистецтва ASCII вище застосовується також з тією різницею, що використовується лише крок (4), а режимом ланцюга блоків SKCIPHER є CBC.

=== Загальна структура дайжестів повідомлень з ключами

Реалізації дайджестів ключових повідомлень знову слідують тій самій концепції, що зображена на малюнку ASCII мистецтва вище.

Наприклад, HMAC (SHA256) реалізований з `hmac.c` та `sha256_generic.c`. Наступне мистецтво ASCII ілюструє реалізацію:

----

kernel crypto API            |       Caller
                             |
+-----------+         (1)    |
|           | <------------------  some_function
|   ahash   |
|   (hmac)  | ---+
+-----------+    |
                 | (2)
+-----------+    |
|           | <--+
|   shash   |
|  (sha256) |
+-----------+
----

Наступна послідовність викликів застосовується, коли абонент запускає операцію HMAC:

1. Функції API AHASH викликаються абонентом. Реалізація HMAC виконує свою роботу за потребою.

Під час ініціалізації шифру HMAC інстанціюється тип шифра SHASH типу SHA256. Ручка шифру для екземпляра SHA256 збережена.

Свого часу реалізація HMAC вимагає операції SHA256, де використовується ручка шифру SHA256.

2. Екземпляр HMAC тепер викликає API SHASH за допомогою шифру SHA256 для обчислення дайджесту повідомлень.

== Розробка алгоритмів шифрів

=== Реєстрація та де-реєстрація трансформації

У Crypto API існує три різних типи функції реєстрації. Один використовується для реєстрації загальної криптографічної трансформації, а два інших є специфічними для перетворень HASH та COMPRESS. Останні два ми обговоримо в окремій главі, тут ми розглянемо лише загальне.

Перш ніж обговорювати функції регістру, слід врахувати структуру даних, яку слід заповнити, `struct crypto_alg` - див. Опис цієї структури даних нижче.

Загальні функції реєстрації можна знайти в `include/linux/crypto.h`, їх визначення можна побачити нижче. Перша функція реєструє єдине перетворення, тоді як остання працює над масивом дескрипторів перетворень. Останнє корисно при реєстрації перетворень масово, наприклад, коли драйвер здійснює кілька перетворень.

[source,c]
----
int crypto_register_alg(struct crypto_alg *alg);
int crypto_register_algs(struct crypto_alg *algs, int count);
----

Нижче перераховані доповнення до цих функцій.

[source,c]
----
int crypto_unregister_alg(struct crypto_alg *alg);
int crypto_unregister_algs(struct crypto_alg *algs, int count);
----

Зауважте, що функції реєстрації та дереєстрації повертають значення, тому обов'язково обробляйте помилки. Код повернення нуля означає успіх. Будь-який код повернення <0 означає помилку.

Функції масової реєстрації/дереєстрації реєструють/скасовують кожне перетворення у заданому масиві довжини `count`. Вони обробляють помилки наступним чином:

`crypto_register_algs()` досягає успіху лише тоді, коли успішно реєструє всі задані перетворення. Якщо помилка трапляється частково, вона скасовує успішні реєстрації перед поверненням коду помилки. Зауважте, що якщо драйверу необхідно обробляти помилки реєстрації для окремих перетворень, тоді він повинен буде використовувати замість нього функцію `crypto_register_alg()`.

`crypto_unregister_algs()` намагається скасувати реєстрацію всіх заданих перетворень, продовжуючи помилку. Він реєструє помилки і завжди повертає нуль.

=== Одноблокові симетричні шифри [CIFHER]

Приклад перетворень: aes, arc4, ...

У цьому розділі описано найпростішу з усіх реалізацій перетворення, який є типом CIPHER, що використовується для симетричних шифрів. Тип CIPHER використовується для перетворень, які працюють на одному блоці за один раз і взагалі відсутні залежності між блоками.

==== Особливості реєстрації

Реєстрація алгоритму [CIPHER] є специфічною у тому, що в структурі  `crypto_alg` поля `.cra_type` порожнє. `.cra_u.cipher` має бути заповнений відповідними зворотними викликами для здійснення цієї трансформації.

Див. Структуру cipher_alg нижче.

==== Визначення шифру в struct cipher_alg

`Struct cipher_alg` визначає шифр з одним блоком.

Ось схеми того, як викликаються ці функції при роботі з іншою частиною ядра. Зауважте, що виклик `.cia_setkey()` може статися до або після того, як відбудеться будь-яка з цих схем, але не повинно відбуватися під час польоту.

----

KEY ---.    PLAINTEXT ---.
       v                 v
 .cia_setkey() -> .cia_encrypt()
                         |
                         '-----> CIPHERTEXT
----

Зверніть увагу, що шаблон, де `.cia_setkey()` викликається кілька разів, також дійсний:

----

KEY1 --.    PLAINTEXT1 --.         KEY2 --.    PLAINTEXT2 --.
       v                 v                v                 v
 .cia_setkey() -> .cia_encrypt() -> .cia_setkey() -> .cia_encrypt()
                         |                                  |
                         '---> CIPHERTEXT1                  '---> CIPHERTEXT2
----

=== Багатоблокові шифри

Приклад перетворень: cbc (aes), ecb (arc4), ...

У цьому розділі описано реалізацію багато блочного шифрування. Багатоблокові шифри використовуються для перетворень, які працюють на розсипчастому списку даних, що надходять до функцій перетворення. Вони також виводять результат у розкидний список даних.

==== Особливості реєстрації

Реєстрація багатоблокових шифрових алгоритмів є однією з найбільш стандартних процедур у крипто-API.

Зауважте, якщо шифрована реалізація вимагає належного вирівнювання даних, абонент повинен використовувати функції `crypto_skcipher_alignmask()` для ідентифікації маски вирівнювання пам'яті. API криптовалюти ядра здатний обробляти запити, які не відповідають вимогам. Це означає, однак, додаткові накладні витрати, оскільки крипто API ядра повинен виконувати перестановку даних, що може передбачати переміщення даних.

==== Визначення шифру в структурах blkcipher_alg та ablkcipher_alg

Структура `blkcipher_alg` визначає шифр синхронного блоку, тоді як структура `ablkcipher_alg` визначає асинхронний шифр блоку.

Будь ласка, зверніться до опису шифру одного блоку, щоб отримати схеми використання блочного шифру.

==== Особливості асинхронного багатоблокового шифру

Існує пара особливостей асинхронного інтерфейсу.

Перш за все, деякі з драйверів захочуть використовувати Generic ScatterWalk у випадку, якщо на апаратне забезпечення потрібно подавати окремі фрагменти списку розсипу, який містить простий текст і міститиме шифротекст. Будь ласка, зверніться до інтерфейсу ScatterWalk, запропонованого реалізацією списку розсіювання/збору ядра Linux.

=== Хешинг [HASH]

Приклад перетворень: crc32, md5, sha1, sha256, ...

==== Реєстрація та дереєстрація трансформації

Існує кілька способів реєстрації перетворення HASH, залежно від того, чи є перетворення синхронним [SHASH] чи асинхронним [AHASH] та кількістю перетворень HASH, які ми реєструємо. Ви можете знайти прототипи, визначені в `include/crypto/Internal/hash.h`:

[source,c]
----
int crypto_register_ahash(struct ahash_alg *alg);

int crypto_register_shash(struct shash_alg *alg);
int crypto_register_shashes(struct shash_alg *algs, int count);
----

Відповідними доповненнями для реєстрації трансформації HASH є такі:

[source,c]
----
int crypto_unregister_ahash(struct ahash_alg *alg);

int crypto_unregister_shash(struct shash_alg *alg);
int crypto_unregister_shashes(struct shash_alg *algs, int count);
----

==== Визначення шифру Структура shash_alg та ahash_alg

Ось схеми того, як викликаються ці функції при роботі з іншою частиною ядра. Зауважте, що виклик `.setkey()` може статися до або після того, як відбудеться будь-яка з цих схем, але не повинна відбуватися під час будь-якого з них. Зауважте, що виклик `.init()`, за яким негайно переходить `.finish()`, також є абсолютно допустимим перетворенням.

----

I)   DATA -----------.
                     v
      .init() -> .update() -> .final()      ! .update() може і не 
                  ^    |         |            викликатись.
                  '----'         '---> HASH

II)  DATA -----------.-----------.
                     v           v
      .init() -> .update() -> .finup()      ! .update() може і не
                  ^    |         |            викликатись.
                  '----'         '---> HASH

III) DATA -----------.
                     v
                 .digest()                  ! Весь процес обробляється
                     |                        викликом .digest().
                     '---------------> HASH
----

Ось схема схеми виклику функцій `.export()/.import()` при використанні з іншої частини ядра.

----

KEY--.                 DATA--.
     v                       v                  ! .update() може і не 
 .setkey() -> .init() -> .update() -> .export()   викликатись.
                          ^     |         |
                          '-----'         '--> PARTIAL_HASH

----------- тут відбуваються інші перетворення -----------

PARTIAL_HASH--.   DATA1--.
              v          v
          .import -> .update() -> .final()     ! .update() може і не  
                      ^    |         |           викликатись.
                      '----'         '--> HASH1

PARTIAL_HASH--.   DATA2-.
              v         v
          .import -> .finup()
                        |
                        '---------------> HASH2
----

==== Особливості асинхронної трансформації HASH

Деякі з драйверів захочуть використовувати Generic ScatterWalk у випадку, якщо для реалізації потрібно подавати окремі фрагменти списку розсипання, який містить вхідні дані. Буфер, що містить отриманий хеш, завжди буде належним чином вирівняний до `.cra_alignmask`, тому не потрібно турбуватись з цього приводу.

