:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

=== Джерело Tor

== Ласкаво просимо до Тор

Ця документація описує загальну структуру бази коду Tor, як вона поєднується, яка функціональність доступна для розширення Tor, а також дає деякі примітки про те, як Tor дістався таким чином. Він також містить посилання на майже кожну функцію, тип, файл та модуль у вихідному коді Tor. Документація на високому рівні - це незавершена праця.

Сам Tor також залишається незавершеним: ми працювали над ним майже два десятиліття, і ми багато чого дізналися про хороше кодування з моменту свого першого запуску. Це означає, однак, що деякі з старих частин Tor матимуть у них якийсь кодовий «присмак», який може витримати бурхливий рефакторинг. Тож, коли ми описуємо фрагмент коду, ми іноді дамо примітку про те, як це вийшло, і чи ми все ще вважаємо, що це гарна ідея.

Цей документ не є оглядом протоколу Tor. Для цього дивіться проектну документацію та технічні характеристики на https://spec.torproject.org/.

Для отримання додаткової інформації про стандарти кодування Tor та деякі корисні засоби розробки див. Doc/HACKING у репозиторії Tor.

=== Огляд високого рівня

== Дуже високий рівень

Зрештою, Tor працює як мережевий демон, керований подіями: він реагує на мережеві події, сигнали та таймери, надсилаючи та отримуючи дущо по мережі. Клієнти, реле та повноваження каталогів усі використовують одну і ту ж базу коду: процес Tor запускається як клієнт, ретранслятор або довірений вузол, залежно від його конфігурації.

Tor має декілька основних залежностей, включаючи Libevent (використовується для того, щоб визначити, які сокети читаються і можна записати), OpenSSL або NSS (використовується для багатьох функцій шифрування та для реалізації протоколу TLS), і zlib (використовується для стиснення та розжаття інформації каталогів) .

Більшість робіт Tor сьогодні виконується в одному основному потоці, що керованій подіями. Tor також створює одну або кілька робочих ниток для вирішення завдань, що вимагають навантаження на процесор. (Зараз це включає лише шифрування ланцюга та більш коштовні алгоритми стиснення).

Під час запуску Tor ініціалізує свої бібліотеки, зчитує та реагує на файли  конфігурації та запускає основний цикл подій. Спочатку єдиними подіями, які Tor слухає, є декілька сигналів (наприклад, TERM та HUP) та один або більше слухаючих сокетів (для різних видів вхідних з'єднань). Tor також налаштовує кілька таймерів для обробки періодичних подій. У міру того, як Тор виконується, з часом відкриватимуться інші події, а також заплановані нові події.

Кодова база поділена на кілька підкаталогів верхнього рівня, кожен з яких містить кілька підмодулів.

* ext - код, який підтримується в іншому місці, який ми включаємо в розподіл джерел Tor.
* lib - код утиліт нижчого рівня, не обов'язково специфічний для tor.
trunnel – Automatically generated code (from the Trunnel tool): used to parse and encode binary formats.
* trunnel - автоматично генерований код (від інструменту Trunnel): використовується для розбору та кодування двійкових форматів.
* core - мережевий код, який реалізує центральні частини протоколу Tor та основний цикл.
* feature - аспекти Tor (наприклад, управління каталогами, запуск ретрансляції, запуск повноважень каталогів, керування списком вузлів, запуск та використання цибульних сервісів), які побудовані поверх коду головного циклу.
* app - функціональність найвищого рівня; відповідальний за налаштування та налаштування демона Tor, переконуючись, що всі модулі нижчого рівня запускаються при необхідності тощо.
* tools - бінарні файли, крім Tor, які ми виробляємо. В даний час це `tor-resolve`, `tor-gencert` та допоміжний модуль `tor_runner.o`.
* test - юніт тести, регресійні тести та кілька інтеграційних тестів.

Теоретично, вищезазначені частини кодової бази сортуються від найвищого рівня до нижнього рівня, де код високого рівня дозволений лише для виклику коду нижчого рівня, а код нижчого рівня ніколи не включає або не залежить від коду вищого рівня . Насправді цей рефакторинг є неповним: модулі в lib є добре впорядковані, але в core та feature є багато порушень шару ("висхідні залежності"). Ми прагнемо усунути їх з часом.

== Деякі ключові абстракції високого рівня

Найважливіші абстракції на високому рівні Tor - це з'єднання, канали, схеми та вузли.

"З'єднання" (`connection_t`) являє собою інформаційний потік. Більшість з'єднань - це з'єднання TCP з віддаленими серверами Tor та клієнтами. (Але як короткий шлях, реле іноді встановлюватиме з'єднання, фактично не використовуючи TCP-з'єднання. Детальніше про це пізніше). Підключення існують у різних різновидах, залежно від того, яку функціональність вони надають. Принциповими типами з'єднання є `edge_connection_t` (наприклад, з'єднання сокета або з'єднання від реле виходу до пункту призначення), `or_connection_t` (потік TLS, який підключається до реле), `dir_connection_t` (HTTP-з'єднання для отримання інформації про мережу) та `control_connection_t` ( з'єднання від контролера).

"Схема" (`circuit_t`) - це стійкий тунель через мережу Tor, створений за допомогою криптографії з відкритим ключем, і використовується для передачі клітинам одного або декількох переходів. Клієнти відслідковують мульти-хоп-схеми (`origin_circuit_t`), а також криптографію, пов'язану з кожним стрибком. Реле, з іншого боку, відстежують лише їхній стрибок кожного ланцюга (`or_circuit_t`).

"Канал" (`channel_t`) - це абстрактний вигляд передачі клітин до та з реле Tor. В даний час всі канали реалізовані за допомогою OR з'єднань (`channel_tls_t`). Якщо ми в майбутньому перейдемо до інших стратегій, у нас буде більше типів підключення.

"Вузол" (`node_t`) - це перегляд сучасних знань та думок екземпляра Tor щодо реле або мосту Tor.

=== Практика дизайну коду високого рівня

На цій сторінці описані практики дизайну високого рівня для коду Tor. Цей дизайн - це довгострокова мета того, як ми хочемо щоб виглядав наш код, а не опис того, яким він є в даний час.

Загалом, ми хочемо, щоб різні частини коду tor взаємоділи між собою через невелику кількість інтерфейсів.

Ми хочемо уникати «об’єктів бога» чи «модулів бога». Це об'єкти або модулі, які занадто багато знають про інші частини коду. Бог об'єкти/модулі, як правило, визнані антипатерном програмного забезпечення.

Історично в tor існували модулі, які прагнули стати модулями бога. До них відносяться модулі, які допомагають більш спеціалізованому коду спілкуватися із зовнішнім світом: наприклад, модулі конфігурації та управління. Інші - це модулі, які займаються глобальним станом, ініціалізацією чи відключенням.

Якщо централізованому модулю потрібно викликати код майже в кожному іншому модулі в системі, то краще, якщо він експортує невеликий, загальний інтерфейс, який викликають інші модулі. Централізований модуль не повинен явно викликати всі модулі, які взаємодіють з ним.

Натомість модулі, які взаємодіють з централізованим модулем, повинні викликати інтерфейси реєстрації. Ці інтерфейси дозволяють модулям реєструвати обробники таких речей, як аналіз конфігурації та виконання команд управління. (Конфігураційні модулі та модулі управління - приклади цього). Крім того, реєстрація може відбуватися через статично ініціалізовані структури даних. (Приклад цього є механізмом підсистеми).

=== Ініціалізація та завершення

== Огляд

Tor has a single entry point: tor_run_main() in main.c. All the ways of starting a Tor process (ntmain.c, tor_main.c, and tor_api.c) work by invoking tor_run_main().
Tor має єдину точку входу: `tor_run_main()` в `main.c`. Всі способи запуску процесу Tor (`ntmain.c`, `tor_main.c` та `tor_api.c`) працюють, викликаючи `tor_run_main()`.

Функція `tor_run_main()` зазвичай виходить через `return`: не викликаючи `abort()` або `exit()`. Перш ніж повернутися, він викликає `tor_cleanup()` в `shutdown.c`.

Концептуально існує кілька етапів запуску Tor.

Спочатку ми ініціалізуємо ті модулі, які не залежать від конфігурації. Це відбувається в першій половині `tor_run_main()`, і в першій половині `tor_init()`.

По-друге, ми аналізуємо командний рядок та нашу конфігурацію та налаштовуємо системи, які залежать від нашої конфігурації чи стану. Ця конфігурація відбувається посередині проходження `tor_init()`, який викликає `options_init_from_torrc()`. Потім ми ініціалізуємо більше систем із другої половини `tor_init()`.

У цей момент ми можемо швидко вийти, якщо нас попросять зробити щось, що не потребує подальшої ініціалізації, наприклад, надрукувати наш номер версії або створити новий ключ підпису. В іншому випадку ми переходимо до `run_tor_main_loop()`, який ініціалізує деякі специфічні для мережі частини Tor, захоплює деякі лише для демона ресурси (наприклад, блокування каталогу даних) і запускає сам Tor.

1. `tor_run_main()` може закінчуватися викликом `abort()` або `exit()`, але лише при збої через помилку або при змушуванні працювати як демон.

2. Частини коду, які я описую як перша частина `tor_init()` тощо, заслуговують на те, щоб бути функціями зі своїм іменем. Я хотів би переробити їх, але перед тим, як зробити це, потрібно зробити невелику перебудову. Зокрема, виклик `nt_service_parse_options()` повинен, логічно, бути згодом у нашій послідовності ініціалізації. Дивіться квиток 32447 для нашого прогресу рефакторингу.

=== Підсистеми та ініціалізація

Our current convention is to use the subsystem mechanism to initialize and clean up pieces of Tor. The more recently updated pieces of Tor will use this mechanism. For examples, see e.g. time_sys.c or log_sys.c.
Наша діюча угода полягає у використанні механізму підсистеми для ініціалізації та очищення шматочків Tor. Цей останній механізм використовуватиме останні оновлені частини Tor. Для прикладів див. time_sys.c або log_sys.c.

In simplest terms, a subsytem is a logically separate part of Tor that can be initialized, shut down, managed, and configured somewhat independently of the rest of the program.

The subsys_fns_t type describes a subsystem and a set of functions that initialize it, desconstruct it, and so on. To define a subsystem, we declare a const instance of subsys_fns_t. See the documentation for subsys_fns_t for a full list of these functions.

After defining a subsytem, it must be inserted in subsystem_list.c. At that point, table-driven mechanisms in subsysmgr.c will invoke its functions when appropriate.

Initialization versus configuration
We note that the initialization phase of Tor occurs before any configuration is read from disk – and therefore before any other files are read from disk. Therefore, any behavior that depends on Tor's configuration or state must occur after the initialization process, during configuration.