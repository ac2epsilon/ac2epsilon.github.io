:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== Джерело Tor

=== Ласкаво просимо до Тор

Ця документація описує загальну структуру бази коду Tor, як вона поєднується, яка функціональність доступна для розширення Tor, а також дає деякі примітки про те, як Tor дістався таким чином. Він також містить посилання на майже кожну функцію, тип, файл та модуль у вихідному коді Tor. Документація на високому рівні - це незавершена праця.

Сам Tor також залишається незавершеним: ми працювали над ним майже два десятиліття, і ми багато чого дізналися про хороше кодування з моменту свого першого запуску. Це означає, однак, що деякі з старих частин Tor матимуть у них якийсь кодовий «присмак», який може витримати бурхливий рефакторинг. Тож, коли ми описуємо фрагмент коду, ми іноді дамо примітку про те, як це вийшло, і чи ми все ще вважаємо, що це гарна ідея.

Цей документ не є оглядом протоколу Tor. Для цього дивіться проектну документацію та технічні характеристики на https://spec.torproject.org/.

Для отримання додаткової інформації про стандарти кодування Tor та деякі корисні засоби розробки див. Doc/HACKING у репозиторії Tor.

== Огляд високого рівня

=== Дуже високий рівень

Зрештою, Tor працює як мережевий демон, керований подіями: він реагує на мережеві події, сигнали та таймери, надсилаючи та отримуючи дущо по мережі. Клієнти, реле та повноваження каталогів усі використовують одну і ту ж базу коду: процес Tor запускається як клієнт, ретранслятор або довірений вузол, залежно від його конфігурації.

Tor має декілька основних залежностей, включаючи Libevent (використовується для того, щоб визначити, які сокети читаються і можна записати), OpenSSL або NSS (використовується для багатьох функцій шифрування та для реалізації протоколу TLS), і zlib (використовується для стиснення та розжаття інформації каталогів) .

Більшість робіт Tor сьогодні виконується в одному основному потоці, що керованій подіями. Tor також створює одну або кілька робочих ниток для вирішення завдань, що вимагають навантаження на процесор. (Зараз це включає лише шифрування ланцюга та більш коштовні алгоритми стиснення).

Під час запуску Tor ініціалізує свої бібліотеки, зчитує та реагує на файли  конфігурації та запускає основний цикл подій. Спочатку єдиними подіями, які Tor слухає, є декілька сигналів (наприклад, TERM та HUP) та один або більше слухаючих сокетів (для різних видів вхідних з'єднань). Tor також налаштовує кілька таймерів для обробки періодичних подій. У міру того, як Тор виконується, з часом відкриватимуться інші події, а також заплановані нові події.

Кодова база поділена на кілька підкаталогів верхнього рівня, кожен з яких містить кілька підмодулів.

* ext - код, який підтримується в іншому місці, який ми включаємо в розподіл джерел Tor.
* lib - код утиліт нижчого рівня, не обов'язково специфічний для tor.
trunnel – Automatically generated code (from the Trunnel tool): used to parse and encode binary formats.
* trunnel - автоматично генерований код (від інструменту Trunnel): використовується для розбору та кодування двійкових форматів.
* core - мережевий код, який реалізує центральні частини протоколу Tor та основний цикл.
* feature - аспекти Tor (наприклад, управління каталогами, запуск ретрансляції, запуск повноважень каталогів, керування списком вузлів, запуск та використання цибульних сервісів), які побудовані поверх коду головного циклу.
* app - функціональність найвищого рівня; відповідальний за налаштування та налаштування демона Tor, переконуючись, що всі модулі нижчого рівня запускаються при необхідності тощо.
* tools - бінарні файли, крім Tor, які ми виробляємо. В даний час це `tor-resolve`, `tor-gencert` та допоміжний модуль `tor_runner.o`.
* test - юніт тести, регресійні тести та кілька інтеграційних тестів.

Теоретично, вищезазначені частини кодової бази сортуються від найвищого рівня до нижнього рівня, де код високого рівня дозволений лише для виклику коду нижчого рівня, а код нижчого рівня ніколи не включає або не залежить від коду вищого рівня . Насправді цей рефакторинг є неповним: модулі в lib є добре впорядковані, але в core та feature є багато порушень шару ("висхідні залежності"). Ми прагнемо усунути їх з часом.

== Деякі ключові абстракції високого рівня

Найважливіші абстракції на високому рівні Tor - це з'єднання, канали, схеми та вузли.

"З'єднання" (`connection_t`) являє собою інформаційний потік. Більшість з'єднань - це з'єднання TCP з віддаленими серверами Tor та клієнтами. (Але як короткий шлях, реле іноді встановлюватиме з'єднання, фактично не використовуючи TCP-з'єднання. Детальніше про це пізніше). Підключення існують у різних різновидах, залежно від того, яку функціональність вони надають. Принциповими типами з'єднання є `edge_connection_t` (наприклад, з'єднання сокета або з'єднання від реле виходу до пункту призначення), `or_connection_t` (потік TLS, який підключається до реле), `dir_connection_t` (HTTP-з'єднання для отримання інформації про мережу) та `control_connection_t` ( з'єднання від контролера).

"Схема" (`circuit_t`) - це стійкий тунель через мережу Tor, створений за допомогою криптографії з відкритим ключем, і використовується для передачі коміркам одного або декількох переходів. Клієнти відслідковують мульти-хоп-схеми (`origin_circuit_t`), а також криптографію, пов'язану з кожним стрибком. Реле, з іншого боку, відстежують лише їхній стрибок кожного ланцюга (`or_circuit_t`).

"Канал" (`channel_t`) - це абстрактний вигляд передачі комірок до та з реле Tor. В даний час всі канали реалізовані за допомогою OR з'єднань (`channel_tls_t`). Якщо ми в майбутньому перейдемо до інших стратегій, у нас буде більше типів підключення.

"Вузол" (`node_t`) - це перегляд сучасних знань та думок екземпляра Tor щодо реле або мосту Tor.

=== Практика дизайну коду високого рівня

На цій сторінці описані практики дизайну високого рівня для коду Tor. Цей дизайн - це довгострокова мета того, як ми хочемо щоб виглядав наш код, а не опис того, яким він є в даний час.

Загалом, ми хочемо, щоб різні частини коду tor взаємоділи між собою через невелику кількість інтерфейсів.

Ми хочемо уникати «об’єктів бога» чи «модулів бога». Це об'єкти або модулі, які занадто багато знають про інші частини коду. Бог об'єкти/модулі, як правило, визнані антипатерном програмного забезпечення.

Історично в tor існували модулі, які прагнули стати модулями бога. До них відносяться модулі, які допомагають більш спеціалізованому коду спілкуватися із зовнішнім світом: наприклад, модулі конфігурації та управління. Інші - це модулі, які займаються глобальним станом, ініціалізацією чи відключенням.

Якщо централізованому модулю потрібно викликати код майже в кожному іншому модулі в системі, то краще, якщо він експортує невеликий, загальний інтерфейс, який викликають інші модулі. Централізований модуль не повинен явно викликати всі модулі, які взаємодіють з ним.

Натомість модулі, які взаємодіють з централізованим модулем, повинні викликати інтерфейси реєстрації. Ці інтерфейси дозволяють модулям реєструвати обробники таких речей, як аналіз конфігурації та виконання команд управління. (Конфігураційні модулі та модулі управління - приклади цього). Крім того, реєстрація може відбуватися через статично ініціалізовані структури даних. (Приклад цього є механізмом підсистеми).

=== Ініціалізація та завершення

== Огляд

Tor has a single entry point: tor_run_main() in main.c. All the ways of starting a Tor process (ntmain.c, tor_main.c, and tor_api.c) work by invoking tor_run_main().
Tor має єдину точку входу: `tor_run_main()` в `main.c`. Всі способи запуску процесу Tor (`ntmain.c`, `tor_main.c` та `tor_api.c`) працюють, викликаючи `tor_run_main()`.

Функція `tor_run_main()` зазвичай виходить через `return`: не викликаючи `abort()` або `exit()`. Перш ніж повернутися, він викликає `tor_cleanup()` в `shutdown.c`.

Концептуально існує кілька етапів запуску Tor.

Спочатку ми ініціалізуємо ті модулі, які не залежать від конфігурації. Це відбувається в першій половині `tor_run_main()`, і в першій половині `tor_init()`.

По-друге, ми аналізуємо командний рядок та нашу конфігурацію та налаштовуємо системи, які залежать від нашої конфігурації чи стану. Ця конфігурація відбувається посередині проходження `tor_init()`, який викликає `options_init_from_torrc()`. Потім ми ініціалізуємо більше систем із другої половини `tor_init()`.

У цей момент ми можемо швидко вийти, якщо нас попросять зробити щось, що не потребує подальшої ініціалізації, наприклад, надрукувати наш номер версії або створити новий ключ підпису. В іншому випадку ми переходимо до `run_tor_main_loop()`, який ініціалізує деякі специфічні для мережі частини Tor, захоплює деякі лише для демона ресурси (наприклад, блокування каталогу даних) і запускає сам Tor.

1. `tor_run_main()` може закінчуватися викликом `abort()` або `exit()`, але лише при збої через помилку або при змушуванні працювати як демон.

2. Частини коду, які я описую як перша частина `tor_init()` тощо, заслуговують на те, щоб бути функціями зі своїм іменем. Я хотів би переробити їх, але перед тим, як зробити це, потрібно зробити невелику перебудову. Зокрема, виклик `nt_service_parse_options()` повинен, логічно, бути згодом у нашій послідовності ініціалізації. Дивіться квиток 32447 для нашого прогресу рефакторингу.

=== Підсистеми та ініціалізація

Наша діюча угода полягає у використанні механізму підсистем для ініціалізації та очищення частин Tor. Цей останній механізм використовуватимуть останні оновлені частини Tor. Для прикладів див. `time_sys.c` або `log_sys.c`.

Найпростіше кажучи, підсистема - це логічно окрема частина Tor, яку можна ініціалізувати, вимикати, керувати та конфігурувати дещо незалежно від решти програми.

Тип `subsys_fns_t` описує підсистему та набір функцій, які ініціалізують її, деконструюють її тощо. Щоб визначити підсистему, ми оголосимо екземпляр `const subsys_fns_t`. Повний список цих функцій див. У документації для `subsys_fns_t`.

Після визначення підсистеми вона повинна бути вставлена у `subsystem_list.c`. У цей момент механізми, керовані таблицею в `subsysmgr.c`, будуть викликати її функції, коли це доречно.

==== Ініціалізація або конфігурація

Зауважимо, що фаза ініціалізації Tor відбувається до того, як будь-яка конфігурація зчитується з диска, а отже, перед тим, як будь-які інші файли читаються з диска. Тому будь-яка поведінка, що залежить від конфігурації або стану Tor, має відбуватися після процесу ініціалізації під час конфігурації.

=== Потік даних у процесі Tor

Ми читаємо байти з мережі, записуємо байти в мережу. Здебільшого, байти, які ми пишемо, приблизно відповідають байтам, які ми прочитали, з доданими бітами криптографії.

Решта - це питання деталей.

==== З'єднання та буфери: читання, запис та інтерпретація.

На низькому рівні мережевий код Tor заснований на "з'єднаннях". Кожне з'єднання являє собою об'єкт, який може надсилати або приймати події, подібні до мережі. Здебільшого кожне з'єднання має один базовий потік TCP (я обговорюю контрприклади нижче).

З'єднання, яке веде себе як потік TCP, має вхідний буфер і вихідний буфер. Вхідні дані записуються у вхідний буфер ("inbuf"); Дані, що підлягають запису в мережу, стоять у черзі на вихідному буфері ("outbuf").

Буфери реалізовані в `buffers.c`. Кожен з цих буферів реалізований у вигляді пов'язаної черги екстентів пам'яті у стилі класичних BSD `mbufs` або Linux `skbufs`.

Читання та запис з'єднання може бути включено або вимкнено. За лаштунками ця функціональність реалізована за допомогою подій `libevent`: одна для читання, друга для письма. Ці події вмикаються/вимикаються в `main.c`, у функціях `connection_{start,stop}_{reading,writing}`.

Коли подія читання або запису вмикається, головний цикл `libevent` опитує ядро, запитуючи, які сокети готові читати чи писати. (Це опитування відбувається під час виклику `event_base_loop()` у `run_main_loop_once()` у `main.c`) Коли `libevent` знаходить сокет, готовий читати чи писати, він викликає `conn_ {read, write} _callback()`, також у `main.c`

Ці функції зворотного виклику делегуються до `connection_handle_read()` та `connection_handle_write()` у `connection.c`, які читають або записують у мережі за необхідності, можливо делегуючи до `openssl`.

Після зчитування чи запису даних або іншої події ці функції `connection_handle_read_write()` викликають логічні функції, завдання яких - відповідати на інформацію. Деякі приклади:

* `connection_flushed_some()` - викликається після того, як з'єднання записує будь-яку кількість даних зі свого `outbuf`.
* `connection_finished_flushing()` - викликається, коли з'єднання спорожніло свій `outbuf`.
* `connection_finished_connecting()` - викликається, коли в процесі з'єднання закінчується встановлення віддаленого з'єднання.
* `connection_reached_eof()` - викликається після отримання `FIN` від віддаленого сервера.
* connection_process_inbuf() - викликається, коли більше даних надходить на `inbuf`.

Потім ці функції викликають конкретні реалізації залежно від типу з'єднання. Наприклад, якщо з'єднання є `edge_connection_t`, `connection_reached_eof()` зателефонує `connection_edge_reached_eof()`.

Примітка: "Також є `bufferevents`!" У нас є рудиментальний код для альтернативної низькорівневої реалізації мереж, заснований на коді `Libevent` `evbuffer` і `bufferevent`. Ці два типи об'єктів беруть на себе (більшість) ролі буферів та з'єднань відповідно. Це не працює в сучасному Tor, через смердіння коду та можливі затяжні помилки `libevent`. Потрібно більше роботи; було б добре зробити це знову ефективно, мати підтримку IOCP в Windows.

=== Контроль з'єднань

У з’єднанні може бути включено чи вимкнено читання чи запис із найрізноманітніших причин, зокрема:

* Запис вимкнено, коли немає більше даних для запису
* Для деяких типів з'єднання зчитування відключено, коли `inbuf` файл занадто заповнений.
* Читання/запис тимчасово вимикається на з'єднаннях, які нещодавно прочитали/записали достатньо даних до своєї пропускної здатності
* Читання відключається на з'єднаннях, коли зчитування з них більшої кількості даних вимагає, щоб дані були завантажені в інше місце, яке вже є повним.

Currently, these conditions are checked in a diffuse set of increasingly complex conditional expressions. In the future, it could be helpful to transition to a unified model for handling temporary read/write suspensions.
В даний час ці умови перевіряються в розмитому наборі все більш складних умовних виразів. Надалі може бути корисним зробити перехід до єдиної моделі для тимчасової зупинки читання/запису.

=== Види з'єднань

Сьогодні Tor має такі типи з'єднання та псевдоз'єднання. Здебільшого кожен тип каналу має асоційований модуль С, який реалізує його основну логіку.

* Крайові з'єднання отримують дані і доставляють дані до точок поза мережею цибулевої маршрутизації. Дивіться `connection_edge.c`. Вони поділяються на два типи:

** Вхідні з'єднання - це тип крайового з'єднання. Вони отримують дані від користувача, який працює з клієнтом Tor, і доставляють дані цьому користувачеві. Вони використовуються для реалізації `SOCKSPort`, `TransPort`, `NATDPort` тощо. Іноді їх називають з’єднаннями "AP" з історичних причин (раніше вони позначалися як "Application Proxy").

** Вихідні з'єднання - це тип крайового з'єднання. Вони існують на вузлі виходу та передають трафік в мережу та з неї.

(Вхідні з'єднання та вихідні з'єднання також використовуються як заповнювачі при виконанні віддаленого запиту DNS; вони не відокремлюються від поняття "потік" у протоколі Tor. Це реалізується частково в `connection_edge.c`, а частково в `dnsserv.c` і `dns.c`.)

* OR з'єднання надсилають та приймають комірки Tor через TLS, використовуючи деяку версію протоколу зв'язку Tor. Їх реалізація розповсюджується через `connection_or.c`, маючи трохи логіки у `command.c`, `relay.c` та `channeltls.c`.

* Розширені з'єднання OR - це тип OR з'єднання для використання на мостах, що використовують підключувані транспорти, так що PT може повідомляти мосту деяку інформацію про вхідне з'єднання перед передачею його даних. Вони реалізовані в `ext_orport.c`.

* Підключення до каталогу - це з'єднання на стороні сервера або на клієнті, які реалізують протокол каталогів, заснований на HTTP. Вони створюються миттєво за допомогою сокета, коли Tor здійснює незашифроване з'єднання HTTP. Коли Tor налаштовує запит на каталог через ланцюг Tor, підключення до каталогу реалізуються за допомогою зв'язаної пари з'єднань (див. Нижче). Підключення до каталогу реалізовані в `directory.c`; частина логіки на сервері реалізована в `dirserver.c`.

* підключення контролера - це локальні з'єднання до процесу контролера, що реалізує протокол контролера з `control-spec.txt`. Вони знаходяться в `control.c`.

* Підключення слухача не орієнтовані на потік! Швидше вони огортають сокет для прослуховування, щоб виявити нові вхідні з'єднання. Вони обходять більшу частину логіки потоку. Вони не мають асоційованих буферів. Вони реалізовані `connection.c`.

  Зауваження: "Час історії!" Ви можете час від часу знайти посилання на кілька типів з'єднань, яких більше не існує в сучасному Tor. З'єднання CPUWorker з'єднувало основний процес Tor з потоком або процесом, що використовується для обчислення. (Сьогодні ми використовуємо внутрішньо-процесну комунікацію). Навіть більш стародавнє з'єднання DNSWorker з'єднувало основний процес tor з окремим потоком або процесом, який використовується для запуску `gethostbyname()` або `getaddrinfo()`. (Сьогодні ми використовуємо засоби `evdns` з `Libevent` для виконання запитів DNS асинхронно.)

===== Пов'язані з'єднання

Іноді два канали з'єднуються разом, так що дані, які надсилає процес Tor в один повинні бути негайно отримані тим самим процесом Tor з іншого. (Наприклад, коли Tor здійснює тунельне підключення до каталогу, це реалізовується на стороні клієнта як з'єднання з каталогом, вихід якого надходить не в мережу, а в локальне з'єднання входу. І коли каталог отримує тунельне підключення до каталогу, це реалізується як з'єднання виходу, вихід якого надходить не в мережу, а в локальне підключення до каталогу).

Найдавніші версії Tor для підтримки поєднаних з'єднань використовували для цього `socketpairs`. Але використання `socketpairs` змусило нас копіювати дані через простір ядра і витрачало обмежені дескриптори файлів. Отже, замість цього, пара з'єднань може бути пов'язана в самому процесі. Кожне пов'язане з'єднання має вказівник на інший, таким чином, що дані, написані на одній стороні, можна відразу читати на іншій, і навпаки.

=== Від з'єднань до каналів

Існує шар абстракції над з'єднаннями OR (ті, що керують комірками) та під комірками під назвою Канали. Призначенням каналу є передача автентифікованих комірок від одного екземпляра Tor (ретранслятора або клієнта) до іншого.

В даний час існує лише одна реалізація: `Channel_tls`, яка надсилає та приймає комірки через АБО-з'єднання на базі TLS.

Комірки надсилаються на канал, використовуючи `channel_write _ {,packed_,var_}cell()`. Вхідні комірки надходять на канал зі свого сервера, використовуючи `channel_queue*_cell()`, і негайно обробляються за допомогою `channel_process_cells()`.

Деякі типи комірок обробляються нижче шару каналу, наприклад, ті, що впливають лише на рукостискання. І деякі інші передаються до загального коду міжканальних каналів у `command.c`: комірки типу `DESTROY` та `CREATED` - це тривіально для обробки. Але ретранслятор вимагає спеціального керування ...

=== З каналів через ланцюги

Коли реле-комірка потрапляє на існуючий ланцюг, вона обробляється у `circuit_receive_relay_cell()` - одна з найцентральніших функцій в Tor. Ця функція зашифровує або розшифровує релейну комірку за необхідності та визначає, чи призначена комірка для поточного стрибка ланцюга.

Якщо комірка призначена для поточного переходу, ми передаємо її до `connection_edge_process_relay_cell()` у `relay.c`, яка діє на неї на основі своєї команди реле та (можливо) ставить в чергу його дані на `edge_connection_t`.

Якщо комірка не призначена для поточного переходу, ми ставимо її в чергу для наступного каналу в послідовності з додаванням `cell_to_circuit_queue()`. Це розміщує комірку на черзі на ланцюг, спрямованих на цей конкретний канал.

=== Відправлення комірок по схемах: складні матерії.

Комірки ретрансляції ставляться в черги на ланцюги з одного з двох (головних) джерел: зчитування даних з крайових з'єднань і отримання комірки, яка повинна бути ретрансльована по ланцюгу. Обидва ці джерела розміщують свої комірки в черзі комірок: у кожній схемі є одна черга комірок для кожного напрямку, в якому вона проходить.

Наївна реалізація може пропустити використання черги комірок, і замість цього записати кожну вихідну реле клітинку. (Тор це робив у своїх попередніх версіях). Але такий підхід, як правило, дає низьку продуктивність, оскільки він дозволяє об'ємним ланцюгам засмічувати канали, і він змушує сервер Tor надсилати дані з черги на схему, навіть після того, як він був зачинений.

Таким чином, використовуючи черги у кожній схемі, ми можемо додавати комірки до кожного каналу прямо зараз, вибираючи комірку в кожен момент на основі алгоритму, орієнтованого на ефективність.

Ця логіка реалізована у двох основних модулях: `scheduler.c` та `circuitmux*.c`. Код планувальника несе відповідальність за визначення глобально, за всіма каналами, які могли б записувати клітинки, якому слід отримувати клітини в черзі. Код `circuitmux` визначає для всіх ланцюгів з чергами комірки для каналу, який слід ставити в чергу наступної комірки.

(Ця логіка стосується лише вихідних релейних комірок; вхідні ретрансляційні комірки обробляються по мірі їх надходження).

=== Сертифікати в Tor.

На жаль, у Tor є кілька типів сертифікатів.

Тип `tor_x509_cert_t` представляє сертифікат X.509. Цей документ не пояснить вам X.509 - можливо, жоден документ не може. (OTOH, "Посібник зі стилю x.509 Пітера Гутмана", хоч і суворо прострочений, добре допомагає пояснити, наскільки жахливим може бути х.509). Не вводьте жодних нових звичаїв X.509. Зараз ми використовуємо його лише в тих місцях, де TLS змушує нас це робити. Дивіться `x509.c` для отримання додаткової інформації про використання цього типу.

Тип `authority_cert_t` використовується лише для авторизованих ключів каталогу. Він має середньостроковий ключ підпису (який довірені сторони фактично зберігають в Інтернеті), підписаний довгостроковим ідентифікаційним ключем (який дійсно краще було б оператору зберігати в автономному режимі). Не використовуйте його для будь-якого нового виду сертифікатів.

Для нових місць, де вам потрібен сертифікат, врахуйте `tor_cert_t`: він являє собою щось типіззоване та датоване, підписане ключем Ed25519. Формат описаний у `tor-spec`. На відміну від `x.509`, ви можете написати його на серветці. Файл `torcert.c` використовується для управління цими сертифікатами та пов'язаними з ними ключами.

(Крім того, дизайн каталогу Tor використовує досить широкий спектр документів, що включають ключі та підписані ключами. Ви можете вважати ці документи додатковим різновидом сертифікатів, якщо хочете).

== Потоки в Tor

Tor заснований на одній головній нитці та одній або декількох робочих нитках. Ми прагнемо (із середнім успіхом) використовувати робочі потоки для активних процесорних дій та основну нитку для нашої мережі. На щастя (?), у нас є достатньо криптографії, що перенесення того, що ми можемо, про криптографічні процеси до працівників, повинен досягти гарного паралелізму при більшості навантажень. На жаль, ми маємо лише невелику частину нашої криптографії, зробленої в наших робочих нитках.

Наша абстракція потоків і робітників визначена в `workqueue.c`, який поєднує чергу роботи з пулом потоків і інтегрує сигналізацію з `libevent`. Основний екземпляр робочої черги Tor інстанціюється в `cpuworker.c`. Ймовірно, знадобиться деякий рефакторинг, оскільки додається більше видів робіт.

На нижчому рівні ми надаємо замки з `tor_mutex_t` в `lib/lock` та інструменти для locking/ threading верхніх рівнів у `lib/thread`, включаючи умови (`tor_cond_t`), локальне зберігання потоків (`tor_threadlocal_t`) тощо.

Постарайтеся мінімізувати обмін між потоками: зазвичай краще просто зробити працівника «власником» усіх необхідних йому даних, поки робота триває, і відмовитися від права власності, коли вона закінчиться.

== Обробка рядків у Tor

Оскільки ви читаєте про програму C, ви, ймовірно, очікували цей розділ: він наповнений функціями для маніпулювання (сумнівно непевною) абстракцією рядка C. Я опишу тут деякі часто пропущені моменти.

==== Порівняння рядків і фрагментів пам'яті

Ми надаємо `strcmpstart()` і `strcmpend()` для виконання `strcmp` з початком або кінцем рядка.

[source,с]
----
    tor_assert(!strcmpstart("Hello world","Hello"));
    tor_assert(!strcmpend("Hello world","world"));

    tor_assert(!strcasecmpstart("HELLO WORLD","Hello"));
    tor_assert(!strcasecmpend("HELLO WORLD","world"));
----

Для порівняння двох рядкових покажчиків, кожен з яких може бути `NULL`, використовуйте `strcmp_opt()`.

Для пошуку рядка або фрагмента пам'яті в ненульовому блоці пам'яті, використовуйте `tor_memstr` або `tor_memmem` відповідно.

Ми уникаємо використання memcmp () безпосередньо, оскільки він, як правило, краще використовується у випадках, коли операція з постійним часом була б кращою. Натомість ми рекомендуємо `tor_memeq()` та `tor_memneq()`, коли вам потрібна операція постійного часу. У випадках, коли вам потрібно швидке порівняння, і витоки часу не становлять небезпеки, ви можете використовувати `fast_memeq()` та `fast_memneq()`.

Це звичайний зразок - взяти рядок, що представляє один або кілька рядків тексту, і шукати всередині нього якийсь інший рядок, на початку рядка. Ви можете шукати `"\\ntarget"`, але це буде пропускати перший рядок. Замість цього використовуйте `find_str_at_start_of_line`.

==== Розбір тексту

За ці роки ми накопичили багато способів розбору тексту - напевно, занадто багато. Реконструкція їх на безпечніше і змістовніше може бути хорошим проектом! Найбільш стійким до помилок є текенізація тексту з `smartlist_split_strings()`. Ця функція приймає `smartlist`, рядок і роздільник, і розбиває рядок на зустрічі подільника, додаючи нові рядки для піделементів до даного `smartlist`.

Для обробки часу можна скористатися однією з функцій, згаданих вище у розділі "Розбір і кодування значень часу".

Для цифр взагалі використовуйте сімейство функцій `tor_parse_{long, ulong, double, uint64}`. Кожне з них можна визвати кількома способами. Найбільш загальне:
[source,scala]
----
  const int BASE = 10;
  const int MINVAL = 10, MAXVAL = 10000;
  const char *next;
  int ok;
  long lng = tor_parse_long("100", BASE, MINVAL, MAXVAL, &ok, &next);
----

Повертане значення слід ігнорувати, якщо для `ok` встановлено значення `false`. Рядок введення повинен містити ціле число, або воно вважається недійсним ... якщо тільки вказівник `next` недоступний, в цьому випадку додаткові символи в кінці дозволені, а `next` встановлений, щоб вказувати на перший такий символ .

==== Генерування блоків тексту

Для не надто великих блоків тексту ми надаємо `tor_asprintf()`, який поводиться як інші члени сімейства `sprintf()`, за винятком того, що він завжди виділяє достатню кількість пам’яті на купі для його виведення.

Для більших блоків: Замість використання `strlcat` та `strlcpy` для створення тексту або утримуючи покажчики на внутрішній блок пам'яті, ми рекомендуємо використовувати функції `smartlist_*` для складання `smartlist`, повного підрядків. Тоді ви можете об'єднати їх у єдиний рядок із `smartlist_join_strings()`, який також приймає необов'язкові аргументи роздільника та термінатора.

Крім того, вам може бути зручнішим (і більш ефективним при розподілі) використовувати API буфера в `buffers.c`: Створіть об'єкт `buf_t`, додайте до нього свої дані за допомогою `buf_add_string()`, `buf_add_printf()` тощо, а потім викличте `buf_extract()`, щоб отримати результат.

Для зручності ми пропонуємо smartlist_add_asprintf(), який поєднує в собі два вищевказаних методи. Багато функцій криптографічних дайджестів також приймають ще не об'єднаний `smartlist` рядків.

==== Помічники журналювання

Часто ми хочемо журналювати значення, яке надходить з ненадійного джерела. Для цього використовуйте `escape()`, щоб уникнути недрукувальних символів та інших заплутаних елементів у рядку та оточити його в лапки. (Використовуйте `esc_for_log()`, якщо вам потрібно розташувати новий рядок.)

Також зручно розміщувати фрагменти пам'яті в шістнадцять разів перед журналюванням; ви можете використовувати для цього `hex_str(memory, length)`.

Обидві функції `escape()` та `hex_str()` забезпечують результати, які є дійсними лише до наступного виклику; вони не є безпечними в нитках.

== Час та періодичні події в Tor

==== Що таке час?

У нас є кілька уявлень про поточний час у Торі.

Час настінного годинника доступний з `time(NULL)` з точністю до секунд і `tor_gettimeofday()` з мікросекундною деталізацією. Це найбільше відповідає "поточному часу та даті".

Монотонний час доступний із набором функцій `monotime_*`, оголошених у `compat_time.h`. На відміну від часу настінного годинника, він може рухатися лише вперед. Це не обов'язково відповідає реальному світовому часу і не є сумісним між системами.

Грубий монотонний час доступний із набору функцій `monotime_coarse_*` в `compat_time.h`. Це те саме, що `monotime_*` на деяких платформах. Для інших він дає монотонний таймер з меншою точністю, але до нього є більш ефективний доступ.

==== Кешовані виміри часу.

У деяких системах (наприклад, Linux) багато функцій часу використовують VDSO, щоб уникнути накладних витрат системного виклику. Але в інших системах `gettimeofday()` та `time()` можуть бути досить дорогими, що ви не хочете визивати їх десятками тисяч разів. Щоб отримати останній, але не особливо точний перегляд поточного часу, див. `approx_time()` та `tor_gettimeofday_cached()`.

==== Розбір і кодування значень часу

Tor має функції для розбору та форматування часу в таких форматах:

* RFC1123 формат. (`"Пт, 29 вересня 2006 15:54:20 GMT"`). Для цього використовуйте `format_rfc1123_time()` та `parse_rfc1123_time`.
* Формат ISO8601 (`"2006-10-29 10:57:20"`) Для цього використовуйте `format_local_iso_time()` та `format_iso_time()`. Ми також підтримуємо варіант формату `"2006-10-29T10:57:20"` з `format_iso_time_nospace()` та `"2006-10-29T10:57:20.123456"` з `format_iso_time_nospace_usec ()`.
* Колекції формату HTTP (переважно `"пн, 25 липня 2016 04:01:11 GMT"` або, можливо, `"ср. 30 червня 21:49:08 1993"` або навіть "`25 липня-16 04:01:11 GMT"`). Для цього використовуйте `parse_http_time()`. Не створюйте нічого, крім першого формату.

Деякі з цих функцій використовують `struct tm`. Ви можете використовувати стандартні `tor_localtime_r()` та `tor_gmtime_r()`, щоб обернути їх безпечним способом. Також у нас є функція `tor_timegm()`.

==== Планування подій

Основний спосіб запланувати не надто часті періодичні події стосовно Tor цикла - через механізм в `periodic.c`. У `mainloop.c` є велика таблиця `periodic_events`, кожна з яких викликається за власним графіком. Не слід очікувати більше, ніж приблизно секунди точності від цих таймерів.

Ви можете створити незалежний таймер за допомогою безпосередньо libevent або за допомогою функції `periodic_timer_new()`. Але вам слід уникати цього для таймерів підключення або за схемою: внутрішня реалізація таймеру Libevent використовує міні-купу, і ті, як правило, починають погано масштабувати, коли у вас є кілька тисяч записів.

Якщо вам потрібно створити велику кількість дрібнозернистих таймерів з якоюсь метою, вам слід розглянути механізм у `src/common/timers.c`, який оптимізовано для випадку, коли у вас є велика кількість таймерів з не надто довгою тривалістю, багато з яких буде видалено до того, як вони дійсно закінчуються. Ці таймери повинні бути досить точними протягом кількох мілісекунд - можливо, навіть краще на деяких платформах. (Модуль `timers.c` використовує впровадження `timeout.c` Вільяма Агерна в якості основи, який базується на ієрархічному алгоритмі колеса хронометражу. Це круті речі; подивіться на це.)

== Параметри конфігурації та постійний стан

=== Вступ

Tor використовує спільний механізм, керований таблицею, для обробки файлів його конфігурації (torrc) та файлів стану. Кожен модуль може оголосити набір іменованих полів для цих файлів та отримувати сповіщення про кожну зміну конфігурації або коли стан збираються передати на диск.

=== Оголошення параметрів

Для більшості модулів потрібно буде використовувати макроси в `confdecl.h` для оголошення конфігурації або структури стану.

You'll write something like this:

[source,c]
----
// my_module_config.inc
BEGIN_CONF_STRUCT(module_options_t)
CONF_VAR(FieldOne, INT, 0, "7")
CONF_VAR(FieldTwo, STRING, 0, NULL)
END_CONF_STRUCT(module_options_t)
----

Вищенаведений приклад призведе до структури під назвою `module_config_t` з двома полями: одним цілим числом під назвою `FieldOne` і одним рядком під назвою `FieldTwo`. Ціле число отримує значення за замовчуванням `7`; значенням за замовчуванням рядка є `NULL`.

Створивши такий файл визначення, ви включаєте його двічі: один раз у заголовок, після вимови `#define CONF_CONTEXT STRUCT` та один раз у C-файлі, після вимови `#define CONF_CONTEXT TABLE`. Перший раз це визначає структуру `module_options_t`, а другий раз визначає таблицю, яка каже менеджеру конфігурації, як ним користуватися.

Використовуючи таблицю, ви оголошуєте `const config_format_t`, який пов'язує поля з набором функцій для їх перевірки та нормалізації, списком абревіатур, викллючення та іншими функціями.

Докладнішу інформацію див. у розділі `confdecl.h` та `conftypes.h`. Для прикладів використання див. `crypto_options.inc` або `mainloop_state.inc`.

=== Отримання сповіщень

Після використання цих макросів необхідно повідомити код управління підсистемою про конфігурацію/стан вашого модуля.

Якщо ви пишете код конфігурації, вам знадобиться функція, яка приймає об’єкт конфігурації і діє на нього. Ця функція повинна бути безпечною для виклику кілька разів, оскільки Tor буде перенастроювати свої підсистеми кожного разу, коли він перечитує `torrc`, отримує зміну конфігурації від контролера або перезапускає процес. Ця функція знаходиться в полі `subsys_fns_t.set_options` підсистеми.

Якщо ви пишете код стану, вам знадобиться функція, яка отримує стан (`subsys_fns_t.set_state`), і функція, яка перетворює стан програми в об'єкт стану (`subsys_fns_t.flush_state`). Функція `set_state` буде викликана один раз (1), коли Tor запускається, тоді як функція `flush_state` буде викликатися, коли Tor збирається зберегти стан на диску.

Дивіться `subsys_fns_t` для отримання додаткової інформації тут, а також Ініціалізація та вимкнення для отримання додаткової інформації про ініціалізацію та підсистеми загалом.

>1. Технічно стан встановлюється один раз при запуску.

Пам'ятайте, що Tor можна зупиняти і запускати кілька разів в тому самому процесі. Якщо це сталося, то ваша функція `set_state()` викликається один раз при кожному запуску Tor.

=== Як це працює

Загальна логіка, яка використовується для обробки файлів конфігурації та стану, живе у `lib/confmgt`. На найвищому рівні об'єкт диспетчера конфігурації (`config_mgr_t`) підтримує список об'єктів конфігурації кожного модуля та список усіх їх полів. Коли користувач вказує значення конфігурації, менеджер з'ясовує, як проаналізувати його, де зберігати його та на який об’єкт конфігурації задіяний.

Модуль конфігурації верхнього рівня (`config.c`) та модуль стану (`statefile.c`) використовують `config_mgr_t` для створення, ініціалізації, встановлення, порівняння та звільнення "об'єкта конфігурації верхнього рівня". Цей об'єкт містить перелік підоб’єктів: по одному для кожного модуля, який бере участь у системі конфігурації/стану. Цей код верхнього рівня потім викликає код менеджера підсистеми (`subsysmgr.c`) для передачі відповідної конфігурації або стану об'єктів кожному модулю, який має такий.

Зауважте, що код верхнього рівня не має легкого доступу до об'єктів конфігурації, які використовуються підмодулями. Це відповідає задуму. Модуль може викрити деяку або всю його конфігурацію або об'єкт стану через функції аксессора, якщо бажаєте, але якщо його немає, цей об'єкт слід вважати локальним в межах модуля.

=== Додавання нових типів

Поля конфігурації та стану мають "тип". Ці типи задають, як значення полів представлені в C; як вони зберігаються у файлах; і як вони кодуються при переміщенні вперед і назад.

Існує набір вбудованих типів, перелічених у `conftypes.h`, але код вищого рівня може визначати його власні типи. Для цього ви робите екземпляр `var_type_fns_t`, який описує, як керувати своїм типом, і екземпляр `var_type_def_t`, який обертає ваш `var_type_fns_t` з іменем та необов'язковими параметрами та прапорами.

Для прикладу того, як визначено тип вищого рівня, див. `ROUTERSET_type_defn` в `routerset.c`. Також дивіться `typedef config_decl_ROUTERSET`. Вони разом дозволяють використовувати тип маршрутизатора разом з макросами в `confdecl.h`.

=== Стара конфігурація та стан

Станом на час написання цього тексту (листопад 2019 р.) більшість конфігурації та стану все ще обробляються безпосередньо у `config.c` та `statefile.c` та зберігаються у монолітних структурах `or_options_t` та `or_state_t` відповідно.

До цих структур верхнього рівня звертаються за допомогою get_options () та get_state() та користувуються протягом більшої частини коду, на рівні ядра та вище.

З часом ми сподіваємось переробити цю конфігурацію на більш розумні фрагменти, щоб вони більше не були (ефективно) глобальними змінними, що використовуються в коді.

== Публікація та підписка на повідомлення, що передаються в Tor

=== Вступ

Tor ввів загальний механізм публікації та підписки для доставки внутрішніх повідомлень. Це покликане допомогти нам покращити модульність нашого коду, уникаючи прямого зв'язку між модулями, які насправді не потребують виклику один одного.

Цей механізм публікації та підписки не призначений для вирішення багатопотокових чи багатопроцесорних питань. Ми думаємо, що з часом він може бути розширений і адаптований для цієї мети. Натомість ми сьогодні використовуємо публікацію-підписку для роз’єднання модулів, які не повинні викликати один одного безпосередньо.

Наприклад, є численні частини нашого коду, які, можливо, повинні вжити заходів, коли ланцюг завершено: можливо, потрібно повідомити контролер, можливо, потрібно буде приєднати переговори щодо обслуговування цибулі, можливо, варто охопити позначку як працюючу, або можливо, потрібно підключити клієнтське з'єднання. Але багато з цих дій відбувається на більш високому рівні, ніж завершення ланцюга: виклик їх безпосередньо є порушенням рівня, і робить наш код важчим для розуміння та аналізу.

Але, передаючи повідомлення, ми можемо перевернути це порушення шару: завершення схеми може стати "повідомленням", яке публікує код схеми, і на які підписуються шари вищого рівня. Це означає, що керування ланцюгами можна від'єднати від модулів вищого рівня та залишатися приємними та простими. (1)

(1). На жаль, як і більшість нашого коду, обробка схеми ще не відновлена ​​для використання публікації-підписки впродовж усього процессу. Натомість порушення, описані тут, досить часто зустрічаються в Tor. Щоб побачити невелику частину того, що відбувається сьогодні, коли схема завершена, перегляньте `circuit_build_no_more_hops()`, та пов'язаний з ним код.

=== Канали та політика доставки

Для роботи з повідомленнями, особливо при рефакторингу існуючого коду, вам потрібно зрозуміти "канали" та "політику доставки".

Кожне повідомлення доставляється на "каналі повідомлень". Кожен канал (концептуально) структура схожа на чергу, яка може підтримувати довільну кількість типів повідомлень. Якщо канали різняться, це механізми їх доставки та гарантії щодо того, коли обробляються повідомлення.

Наразі можливі три політики доставки:

* `DELIV_PROMPT` - викликає обробку повідомлень за допомогою зворотного виклику в циклі подій Tor. Це, як правило, найкращий вибір, оскільки це дозволяє уникнути несподіваного зростання стека.
* `DELIV_IMMEDIATE` - викликає негайну обробку повідомлень у стеку викликів при їх публікації. Цей вибір збільшує стек і може призвести до несподіваної складності в графіку викликів. Ми повинні використовувати його лише при необхідності.
* `DELIV_NEVER` - призводить до того, що система передачі повідомлень взагалі не надсилає повідомлення. Натомість, якась інша частина коду повинна викликати `dispatch_flush()`, щоб доставити повідомлення.

Див. `mainloop_pubsub.c` та `mainloop_pubsub.h` для отримання додаткової інформації та відомостей про реалізацію.

=== Рівні: диспетчеризація vs публікації-підписки vs mainloop.

На найнижчому рівні повідомлення надсилаються через модуль `"dispatcher"` в `lib/dispeatch.` Для продуктивності цей диспетчер працює з нетипізованими повідомленнями. Видавці, підписники, канали та повідомлення відрізняються короткими цілими числами. Пов'язані дані обробляються як динамічно типізовані покажчики даних, а їх типи також зберігаються у вигляді коротких цілих чисел.

Звичайно, це призводить до небезпечного типу API API, тому більшість інших модулів не повинні викликати `lib/dispatch` безпосередньо. На більш високому рівні `lib/pubsub` визначає набір функцій та макросів, які роблять повідомлення іменованими та безпечними для типу. Це те, що повинні використовувати інші модулі, коли вони хочуть надіслати або отримати повідомлення.

Два вищевказані модулі не обробляють доставку повідомлень. Натомість модуль відправки приймає зворотний виклик, який може викликати, коли канал стає порожнім, і визначає функцію `dispatch_flush()` для доставки всіх повідомлень, що стоять у черзі в каналі. Робота над тим, щоб переконатися, що `dispatch_flush()` викликається, коли це доцільно, потрапляє в основний цикл, який повинен інтегрувати диспетчер повідомлень з рештою наших подій та зворотних викликів. Ця робота відбувається в `mainloop_pubsub.c`.

=== Як публікувати та підписуватись

У цьому розділі наведено огляд способів створення нових повідомлень та способів їх використання. Для отримання детальної інформації див. `pubsub_macros.h`.

Перш ніж хтось може опублікувати або підписатись на повідомлення, повідомлення повинно бути оголошено, як правило, у заголовку. Для цього використовується `DECLARE_MESSAGE()` або `DECLARE_MESSAGE_INT()`.

Лише підсистеми можуть публікувати або передплачувати повідомлення. Для отримання додаткової інформації про архітектуру підсистем див. Ініціалізацію та вимкнення.

Щоб опублікувати повідомлення, ви повинні:

* Додайте заголовок, який оголошує повідомлення.
* Оголосіть набір допоміжних функцій за допомогою `DECLARE_PUBLISH()`. Вони повинні бути видимі там, де ви телефонуєте `PUBLISH()`.
* Зателефонуйте `PUBLISH()`, щоб фактично надіслати повідомлення.
* Підключіть свою підсистему до диспетчера, викликавши `DISPATCH_ADD_PUB()` з зворотного виклику підсистеми `subsys_fns_t.add_pubsub`.

Щоб підписатися на повідомлення, необхідно:

* Додайте заголовок, який оголошує повідомлення.
* Визначте функцію зворотного виклику, яку потрібно викликати під час доставки повідомлення.
* Use DISPATCH_SUBSCRIBE at file scope to define a set of wrapper functions to call your callback function with the appropriate type.
* Використовуйте `DISPATCH_SUBSCRIBE` в області файлу, щоб визначити набір функцій обгортки для виклику функції зворотного виклику відповідного типу.
* Підключіть свою підсистему до диспетчера, викликавши `DISPATCH_ADD_SUB ()` зі зворотного виклику підсистеми `subsys_fns_t.add_pubsub`.

Знову ж таки, документація на рівні файлу для `pubsub_macros.h` описує, як оголосити повідомлення, як його опублікувати та як підписатись на нього.

=== Створення хороших повідомлень

Частота: система публікації-підписки використовує кілька викликів функцій та розподілів для кожного надісланого повідомлення. Це робить його непридатним для подій з дуже високою пропускною здатністю, наприклад "отримання однієї комірки даних" або "сокет став доступним для запису". Однак це добре для подій, які зазвичай трапляються трохи рідше, ніж це, як, наприклад, закінчення ланцюга, відкриття нового з'єднання тощо.

Семантика: Повідомлення повинно зазначати, що щось сталося чи відбувається, а не що-небудь зокрема має бути зроблене.

Наприклад, припустимо, ви хочете налаштувати повідомлення так, щоб сервіси цибулі очищали кеші їх відтворення, коли нам не вистачає пам’яті. Подія повинна бути чимось на зразок `memory_low`, а не `clean_up_replay_caches`. Остання назва означала б, що видавець знав, хто підписує повідомлення, і що вони мають на меті з цим зробити, що було б порушенням рівнів.