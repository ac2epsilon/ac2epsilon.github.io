Переклад українською - Арсеній Чеботарьов - ac2epsilon@gmail.com - Ніжин 2015 

                   TC: Протокол Керування Tor (Version 1)

0. Огляд

  Цей документ описує залежний від реалізації проткол, що використовується для інших програм (таких як інтерфейс користувача) для комунікації з локально виконуваним процесом Tor. Він не є частиною протоколу цибульного маршрутного протоколу Tor.

  Цей протокол заміщує 0 TC, що тепер є неуживаним. Для посилань, TC 0 описаний як "control-spec-v0.txt". Реалізаторам рекомендовано уникати використання TC напряму, та замість цього використовувати бібліотеку, що може бути легко оновлена для використання нового протоколу. (Версія 0 використовується Tor версій 0.1.0.x; протокол в цьому документі робить тільки з Tor версій серії 0.1.1.x та пізніших).

      Ключові слова  "ЗОБОВ’ЯЗАНИЙ", "ЗОБОВ’ЯЗАНИЙ НЕ", "ПОТРЕБУЄ", "БУДЕ", "БУДЕ НЕ", "ПОВИНЕН", "НЕ ПОВИНЕН", "РЕКОМЕНДОВАНО",  "МОЖЕ" та
      "ОПЦІОНАЛЬНО" в цьому документі інтерпретуютсья так, як визначено в RFC 2119.

1. Обрис протоколу

  TC є двонаправленим протоколом на базі повідомлень. Він покладається на підлеглий потік комунікацій між контролючим процесом ("клієнт" або "контролер"), та процесом Tor (або "сервером"). Потік може бути реалізовано через TCP, TLS-over-TCP, сокети Unix, і таке інше, але це має провадити надійну впорядковану доставку. Для безпеки потік не має бути доступним для недовірених сторін.

  В TC клієнт та сервер надсилають типові повідомлення один одному через потік. Клієнт надсилає "команди", сервер надсилає "відповіді".

  По замовчанню всі повідомлення від сервера є відповідями на повідомлення від клієнта. Деякі запити клієнт, тим не менше, спричинять те, що сервер надішле повідомлення до клієнта у невизначеному майбутньому. Такі "асинхронні" відповіді відповідно відмічені.

  Сервер відповідає на повідомлення в порядку надходження повідомлень.

1.1. Майбутня сумісність

  Це є протокол що розвивається; нові поведінки клієнта на сервера будуть з’являтися в майбутньому. Щоб уможливити нову поведінку попередньо-сумісного клієнта, ми можемо додати нові команди та дозволити існуючим командам приймати нові аргументи в майбутніх версіях. Щоб уможливити нову поведінку попередньо-сумісного сервера, ми нотуємо різні місця нижче, де сервери, розмовляючі новою персією цього протоколу, можуть вставляти нові дані, та вказуємо, де клієт може або мусить пропускати неочікувані елементи в ціх місцях. Є два шляхи щоб зробити це:

  * Додати нове поле до повідомлення:

    Наприклад, ми можемо сказати "Це повідомлення має три поділених проміжками поля; clients ЗОБОВ’ЯЗАНИЙ пропускати більше полів". Це означає, що клієнт ЗОБОВ’ЯЗАНИЙ НЕ ламатися або інакше давати збій при розборі повідомлення, або інших послідуючих повідомлень, коли є більше ніж три поля, тоді він МАЄ функціонувати щонайменш так гарно, якби він отримав лише ту кількість і тих полів, що він сприймає. Самий явний шлях зробити це є ігнорування додаткових полів; наступний самий-явний-шлях є доповідь про додаткові поля буквально користувачеві, можливо як частина експертного інтерфейсу UI.

  * Додати нове можливе значення до списку альтернатив:

    Наприклад, ми можемо сказати "Це поле може бути OPEN, CLOSED або
    CONNECTED. Клієнти ЗОБОВ’ЯЗАНІ продускати неочікувані значення". Це означає, що клієнт ЗОБОВ’ЯЗАНИЙ НЕ ламатися або інакше давати збій при розборі повідомлення, або інших послідуючих повідомлень, коли є неочікувані значення, та що клієнт МАЄ спробувати використати залишок повідомлення, так гарно, як це можливо. Самий явний шлях зробити це є очікування того, що кожний список альтернатив має додатковий елемент "нерозпізнанного значення", та відображення любого нерозпізнанного значення на цей елемент; наступний самий-явний-шлях є створення окремого елемента "нерізпознанного значення" для кожного нерозпізнанного значення.

    Клієнти НЕ ПОВИННІ "пропускати" нерозпізнані альтернативи, вдаючи що повідомлення, що їх містить, відсутнє. Наприклад, потік, що зачинений з нерозпізненої причини, все одно є зачинений, і має бути сповіщений як такий.

    (Якщо надається деякий список альтернатив, і нема явної вказівки, що клієнт мусить пропускати неочікувані значення, клієнти вже ж таки мають пропускати невідомі значення. Може бути одне виключення, коли є явні вказівка на те, що в майбутньому ніколи не будуть додані нові значення).

2. Формат повідомлень

2.1. Визначення формату

  Формат повідомлень, перелічених нижче, використовує ABNF, як визначено в RFC 2234. Саме протокол віддалено базується на SMTP (дивіться RFC 2821).

  Ми використовуємо наступні nonterminals з RFC 2822: atom, qcontent

  Ми визначаємо наступнийі nonterminals загального використання:

     QuotedString = DQUOTE *qcontent DQUOTE

  Немає явного обмеження на довжину рядка. Всі 8-бітні символи є дозволеними, якщо не є явно забороненими. В QuotedStrings зворотні слеши та лапки мають бути виключені; інші символи не мають виключатись.

  Коли CRLF є вказаний як той, що сприймається з контролера, Tor МОЖЕ також сприймати LF. Tor, одначе, ЗОБОВ’ЯЗАНИЙ НЕ генерувати LF замість CRLF. Контролери ПОВИННІ завжди надсилати CRLF.

2.1.1. Зауваження щодо помилки виключення

     CString = DQUOTE *qcontent DQUOTE

  Зауважте, що хоча ці nonterminals мають ту ж граматику, вони інтерпретуються відмінно. В QuotedString зворотній слеш, за яким слідує любий символ, репрезенує чей символ. Але в CString ці виключення "\n", "\t", "\r", та вісьміркові виклюення "\0" ... "\377" представляють новий рядок, табуляцію, перевод каретки, та 256 можливих значень, відповідно.

  Використання CString в цьому документі відзеркалює помилку в Tor; заміть цього вони мають бути QuotedString. В майбутньому вони можуть мігрувати для використання QuotedString. Якщо це відбудеться, реалізація   QuotedString ніколи не буде розміщувати зворотній слеш перед "n", "t", "r" або цифру, щоб упевнитись, що старі контролери не будуть спантеличені.

  Для підготовки для майбутнього контолери МОЖУТЬ використовувати настуні правила, щоб бути сумісними з помилковими реалізаціями Tor та з майбутніми, що реалізують специфікацію як слід:

    Читати \n \t \r та \0 ... \377 як C виключення.
    Розглядати зворотній слеш, за яким слідуе інший символ як самий цей символ.

  Наразі, багато з екземплярів QuotedString нижче, що походять від Tor, фактично є CStrings. Ми збираємось полагодити це в майбутніх версіях Tor, та задокументувати, які випадки були пошкодженими. (Дивіться квиток відсліджування помилки #14555 для більшої інформації з цього приводу).

  Зауважте, що ця помилка існує тільки в рядках, згенерованих Tor для контролера Tor; Tor буде розбирати вхідні QuotedStrings від контролера коректно.


2.2. Команди контролера до Tor

    Command = Keyword OptArguments CRLF / "+" Keyword OptArguments CRLF CmdData
    Keyword = 1*ALPHA
    OptArguments = [ SP *(SP / VCHAR) ]

  Команда є або одним рядком, що містить ключове слово (Keyword) та аргументи, або команда в декілька рядків, чиї початкові ключові слова починаються з +, та чиї розділи даних завершуються поддинокою ".". (Ми використовуємо спеціальний символ щоб відрізняти багаторядкові команди, так що Tor може коректно розбирати багаторядкові команди, які він не розуміє). Окремі команди та їх аргументи описуються нижче в розділі 3.

2.3. Відповіді від Tor контролеру

    Reply = SyncReply / AsyncReply
    SyncReply = *(MidReplyLine / DataReplyLine) EndReplyLine
    AsyncReply = *(MidReplyLine / DataReplyLine) EndReplyLine

    MidReplyLine = StatusCode "-" ReplyLine
    DataReplyLine = StatusCode "+" ReplyLine CmdData
    EndReplyLine = StatusCode SP ReplyLine
    ReplyLine = [ReplyText] CRLF
    ReplyText = XXXX
    StatusCode = 3DIGIT

  Окремі відповіді перелічені нижче в розділі 3, та розкривається ще більше в розділі 4.

  [Зауваження з сумісності:  версії Tor перед 0.2.0.3-alpha часом генерують асинхронні відповіді (AsyncReplies) в формі "*(MidReplyLine / DataReplyLine)". Це є некоректним, але контролери, що вимушені працювати з ціми версіями Tor, повинні бути готовими отримувати багаторядкові відповіді AsyncReplies з відсутнім останнім рядком (звичано "650 OK")]

2.4. Загально уживані токени

  * CRLF означає "символ поверненя каретки ASCII Carriage Return (десяткове значення 13), за яким слідує символ нового рядка ASCII Linefeed (десяткове значення 10)"
  CRLF = CR LF

  * Як контролер сповіщає Tor про окремий OR. Є чотири можливих форматів:
      
      $Fingerprint -- Маршрутник, чий ключ ідентифікації хешується до наданого відтиску. Це бажаний шлях для посилання на OR.
      
      $Fingerprint~Nickname -- Маршрутник, чий ключ ідентифікації хешується до наданого відтиску, але тільки коли цей маршрутник має наданий нікнейм (скорочене ім’я).

      $Fingerprint=Nickname -- Маршрутник, чий ключ ідентифікації хешується до наданого відтиску, але тільки якщо він іменований та має наданий нікнейм (скорочене ім’я).
  
      Nickname -- Іменований маршрутник (має статус Named) з наданим нікнеймом, або, якщо такого нікнейма не існує, любий маршрутник, чий нікнейм підходить під наданий. Це не є безпечним шляхом посилатись на маршрутники, оскільки статус Named може при деяких умовах з часом змінюватись.
  
  * Токени, що реалізують надане вище, такі: 

  ServerSpec = LongName / Nickname
  LongName   = Fingerprint [ ( "=" / "~" ) Nickname ]

  Fingerprint = "$" 40*HEXDIG
  NicknameChar = "a"-"z" / "A"-"Z" / "0" - "9"
  Nickname = 1*19 NicknameChar

      Наступне є простроченим шляхом посилатись на OR. Можливість VERBOSE_NAMES заміщує ServerID з LongName в подіях та результатах GETINFO. VERBOSE_NAMES може бути включений починаючи з версії 0.1.2.2-alpha, та є завжди ввімкненим в 0.2.2.1-alpha та пізніших.
  ServerID = Nickname / Fingerprint


  * Унікальні ідентифікатои для потоків або ланцюжків. Наразі Tor використовує тільки цифри, але це може змінитись
  
  StreamID = 1*16 IDChar
  CircuitID = 1*16 IDChar
  ConnID = 1*16 IDChar
  QueueID = 1*16 IDChar
  IDChar = ALPHA / DIGIT

  Address = ip4-address / ip6-address / hostname   (XXXX Визначте це)

  * Розділ "CmdData" є послідовністю октетів, що завершуються послідовністю CRLF "." CRLF. Завершальна послідовність не може зустрітись в тілі даних. Перша крапка в рядку виключається додатковою крапкою, як в RFC 2821 розділ 4.5.2.
  
  CmdData = *DataLine "." CRLF
  DataLine = CRLF / "." 1*LineItem CRLF / NonDotItem *LineItem CRLF
  LineItem = NonCR / 1*CR NonCRLF
  NonDotItem = NonDotCR / 1*CR NonCRLF

  * ISOTime, ISOTime2 та ISOTime2Frac є форматами часу, як вказано в ISO8601.
  
  Приклад ISOTime:      "2012-01-11 12:15:33"
  Приклад ISOTime2:     "2012-01-11T12:15:33"
  Приклад ISOTime2Frac: "2012-01-11T12:15:33.51"
  
  IsoDatePart = 4*DIGIT "-" 2*DIGIT "-" 2*DIGIT
  IsoTimePart = 2*DIGIT ":" 2*DIGIT ":" 2*DIGIT
  ISOTime  = IsoDatePart " " IsoTimePart
  ISOTime2 = IsoDatePart "T" IsoTimePart
  ISOTime2Frac = IsoTime2 [ "." 1*DIGIT ]

3. Команди

  Всі команди не залежать від регістру, але більшість ключових слів - так.

3.1. SETCONF

  Змінити значення одного або більше значення змінних конфігурації.
    Синтаксис:
    "SETCONF" 1*(SP keyword ["=" value]) CRLF
    value = String / QuotedString

  Tor поводиться так, наче він тількі що прочитав кожну пару ключ-значення зі свого файлу конфігурації. Ключові слова без відповідного значення скидаються в 0 або NULL (використовуйте RESETCONF, якщо ви бажаєте встановити його знову в значення по замовчанню). SETCONF є вс-або-нічого: якщо є помилка в любому з налаштувань конфігурації, Tor не встановить жодного з них.

  Tor відповідає "250 configuration values set" в разі успіху. Якщо деякі з перелічених ключових слів не можуть бути знайдені, Tor відповідає повідомленням "552 Unrecognized option". Інакше Tor відповідає "513 syntax error in configuration values" в разі синткасичної помилки, або "553 impossible configuration setting" на семантичну помилку.

  Деякі опції конфігурації (такі як "Bridge") приймають декілька значень. Також дяекі ключі (наприклад, для прихованих сервісів та для списків вхідних захисників) формують залежну від контексту групу, де порядок має значення (дивіться GETCONF нижче). В ціх випадках встановлення _любої_ з опцій в команді SETCONF призведе до скидання всіх інших. Наприклад, якщо було сконфігуровано два значення ORListenAddress, та команда SETCONF  містить одне значення ORListenAddress, нове значення з команди замінить два старих значення.

  Часом неможливо змінити опцію конфігурації, тільки надсилаючи послідовності команд SETCONF, оскільки значення опцій конфігурації залежать від значень інших, що ще не були встановлені. Такі ситуації можна подолати, встановлюючи декілька опцій конфігурації в одній команді SETCONF (наприклад, SETCONF ORPort=443 ORListenAddress=9001).

3.2. RESETCONF

  Видалити всі налаштування для даної опції повністю, присвоїти їй значення по замовчанню (якщо таке є), та після присвоїти впроваджене значення String. Типово String залищається пустим, щоб спростити встановлення опціі назад до її замовчання. 
  Синтаксис:
    "RESETCONF" 1*(SP keyword ["=" String]) CRLF

  Інакше це робить як SETCONF вище.

3.3. GETCONF

  Запин на значення змінної коніягурації.
  Синтаксис:
    "GETCONF" 1*(SP keyword) CRLF

  Якщо всі перелічені ключові слова існують в конфігурації Tor, Tor відповідає послідовністю рядків відповіді в формі:
      250 keyword=value
  Якщо опція встановлена в значення 'default', семантично відмінне від порожнього рядка, Tor може відповісти рядком в формі:
      250 keyword

  Значення може бути необробленним значенням або рядком в лапках. Tor буде намагатися використовувати значення без лапок, за винятком, коли значення може бути навірно тлумачено через відсутність ціх лапок. (Зараз Tor не підтримує таких незрозумілих значень для опцій конфінурації).

  Якщо деякі з ключових слів не можуть бути знайдені, Tor відповідає повідомленням "552 unknown configuration keyword".

  Якщо опція з’являється декілька разів в конфігурації, всі ці пари будуть повернені в тому ж порядку.

  Деякі опції залежать від контексту, та залежать від інших опцій з різними ключовими словами. Вони не можуть бути отримані напряму. Наразі є тільки одна така опція: клієнтам слідує використовувати віртуальне ключове слово "HiddenServiceOptions" для отримання всіх налаштувань опцій HiddenServiceDir, HiddenServicePort, HiddenServiceVersion, та HiddenserviceAuthorizeClient.

3.4. SETEVENTS

  Запит до сервера інформувати клієнта щодо цікавих подій. Синтакс такий:

     "SETEVENTS" [SP "EXTENDED"] *(SP EventCode) CRLF

     EventCode = 1*(ALPHA / "_")  (див розділ 4.1.x в пошуках типів подій)

  Любі події, не перераховані в рядку SETEVENTS будуть вимкнені; таким чином, надсилання SETEVENTS з пустим тілом відключає всі сповіщення про продії.

  Сервер відповідає "250 OK" в разі успіху, та "552 Unrecognized event", якщо коди подій не були розпізнані. (В разі помилки список активних кодів подій не змінюється).

  Якщо флаговий рядок "EXTENDED" присутній, Tor може провадити додаткову інформацію з подіями для цього з’єднання; дивіться 4.1 для більшої інформації. 

  ЗАУВАЖЕННЯ: Всі події для даного з’єднання будуть провадитись в поширеному уорматі, або жодне.
  
  ЗАУВАЖЕННЯ: "EXTENDED" вперше підтримувався в Tor 0.1.1.9-alpha; він завжди вімкнений в Tor 0.2.2.1-alpha та пізніших.

  Кожна подія описана більш детально в Розділі 4.1.

3.5. AUTHENTICATE

  Надсилається від клієнта на сервер.  
  Синтаксис:
     "AUTHENTICATE" [ SP 1*HEXDIG / QuotedString ] CRLF

  Сервер відповідає "250 OK" в разі успіху, або "515 Bad authentication", якщо аутентифікаційний cookie некоректний. Tor зачиняє з’єднання, якщо аутентифікація неуспішна.

  Токен актентифікації може бути заданий або як ASCII рядок в лапках, або як шеснадцятеричне без лапок від того ж самого рядка (щоб запобігти пробеми з виключенями).

  Для отримання інформації, щодо того, як реалізація безпечно зберігає інформацію аутентифікації на диск, дивіться розділ 5.1.

  Перед тим, як клієнт буде аутентифікований, всі команди є недійсними, окрім PROTOCOLINFO, AUTHCHALLENGE, AUTHENTICATE, або QUIT. Якщо контролер надсилає любу іншу команду, або надсилає невірну команду, або неуспішну  команду AUTHENTICATE, або надсилає PROTOCOLINFO або AUTHCHALLENGE більше одного разу, Tor відсилає у відповідь помилку та зачиняє з’єднання.

  Щоб запобігти деяким крос-протокольним атакам, команда AUTHENTICATE все ще є обов’язковою, навіть якщо всі методи аутентифікації в Tor відключені. В цьому випадку контролер повинен надіслати лише "AUTHENTICATE" CRLF.

  (Версії Tor перед 0.1.2.16 та 0.2.0.4-alpha не зачиняють з’єднання після невдачної аутентифікації).

3.6. SAVECONF

  Надсилається від клієнта на сервер.  
  Синтаксис:
     "SAVECONF" CRLF

  Інструктує сервер записати свої опції конфігурації в свій torrc. Сервер повертає "250 OK" в разі успіху, або "551 Unable to write configuration
  to disk", якщо він не може записати в файл, або виникла інша помилка.

  Дивіться також команду "getinfo config-text", якщо контролер бажає записати файл torrc власноруч.

3.7. SIGNAL

  Надсилається від клієнта на сервер. 
  Синтаксис:
     "SIGNAL" SP Signal CRLF

     Signal = "RELOAD" / "SHUTDOWN" / "DUMP" / "DEBUG" / "HALT" /
              "HUP" / "INT" / "USR1" / "USR2" / "TERM" / "NEWNYM" /
              "CLEARDNSCACHE" / "HEARTBEAT"

  Значення сигналів наступні:

      RELOAD    -- Перезавантаження: перезавантажити елементи конфігурації (як HUP).
      SHUTDOWN  -- Контрольоване завершення: Якщо сервер є OP, вийти негайно. Якщо він є OR, закрити слухачів та вийти після ShutdownWaitLength секунд. (як INT)
      DUMP      -- Скинути стани: записати в журнал інформацію про відкриті з’єднання та ланцюжки (як USR1)
      DEBUG     -- Відлаштування: перемикнути всі відкриті журнали на рівень debug (як USR2)
      HALT      -- Безпосередньє завершення: очистити все та негайно вийти (як TERM)
      CLEARDNSCACHE -- Забути кешовані клієнтські IP для всіх імен.
      NEWNYM    -- Перемикач для очищення ланцюжків, так що запити нового застосування не будуть поділяти ланцюжки зі старими запитами. Також очищує клієнтський DNS кеш. (Tor МОЖЕ обмежувати частоту відповідей на цей сигнал).
      HEARTBEAT -- Зробити дамп Tor незапланованого повідомлення Heartbeat в журнал.

  Сервер відповідає "250 OK", якщо сигнал розпізнано (або просто закриває сокет, якщо було прохання закрити негайно), або "552 Unrecognized signal", якщо сигнал не розпізнано.

3.8. MAPADDRESS

  Надсилається від клієнта на сервер.
  Синтаксис:
    "MAPADDRESS" 1*(Address "=" Address SP) CRLF

  Перша адреса в кожній парі є "оригінальною" адресою; друга є "замінною" адресою. Клієнт надсилає це повідомлення на сервер для того, щоб наказати подальшим SOCKS запитам на з’єднання з оригінальною адресою замінювати на з’єднання з вказанною заміною адреси. Якщо адреси гарно сформовані, та сервер в змозі задовільнити запит, сервер відповідає повідомленням 250:
    250-OldAddress1=NewAddress1
    250 OldAddress2=NewAddress2

  що містить відправну та цільову адреси. Якщо запит є невірно сформований, сервер відповідає "512 syntax error in command argument". Якщо сервер не може задовільнити запит, він відповідає "451 resource exhausted".

  Клієнт може відмовитись надавати тіло оригінальної адреси, та замість надіслати спеціальну нульову адресу ("0.0.0.0" для IPv4, "::0" для IPv6, або "." для імені вузла), наголошуючи, що сервер має сам обрати оригінальну адресу, та повернути її в відповіді. Сервер має впевнитись, що він повертає елемент адресного простору, що мало вірогудно щоб дійсно був в ужитку. Якщо завжди є адреса, відображена на цільову адресу, сервер може повторно використати цю адресу.

  Якщо оригінальна адреса вже відображена на іншу адресу, старе відображення видаляється. Якщо аригінальна адреса та цільова адрема ті ж самі, сервер видаляє любі існуючі відображення для оригінальної адреси.

  Приклад:
    C: MAPADDRESS 0.0.0.0=torproject.org 1.2.3.4=tor.freehaven.net
    S: 250-127.192.10.10=torproject.org
    S: 250 1.2.3.4=tor.freehaven.net

  {Зауваження: ця можливість розроблена, щоб допомогти Tor-іфікувати застосування, що потребують використовувати SOCKS4 або SOCKS5 без імені вузла. Є три підходи, щоб зробити це:
     1. Якось зробити так, щоб вони використовували SOCKS4a або SOCKS5-з-іменами замість цього.
     2. Використовувати tor-resolve (або інший інтерфейс для Tor resolve-over-SOCKS можливості), щоб розрішити ім’я вузла віддалено. Це не робить зі спеціальними адресами, як x.onion або x.y.exit.
     3. Використовувати MAPADDRESS, щоб відобразити IP адресу на бажане ім’я, та потім намагатися обдурити застосування, щоб воно думало, що це ім’я було розрішене до цього IP.
  Це функціональність розрахована для допомоги в реалізації третього підхіду}

  Переназначення, встановлені контролером, діють до того, як завершиться процес Tor: вони николи не прострочуються. Якщо контролер бажає, щоб переназначення працювало тільки деякий час, тоді він має явно відізвати адресу, коли цей час спливе.

3.9. GETINFO

  Надсилається від клієнта на сервер. Синтаксис як для GETCONF:
    "GETINFO" 1*(SP keyword) CRLF
  один або більше NL(новий рядок)-завершених рядків. Сервер відповідає повідомленням INFOVALUE, або помилками 551 або 552.

  На відміну від GETCONF, ще повідомлення використовується для даних, що не зберігаються в файлі конфігурації Tor, та можуть бути довшими, ніж один рядок. В разі успіху для кожного запиту значення надсилається окремий рядок відповіді ReplyLine, за чим слідує заключий 250 OK. Якщо значення підходить до одного рядка, формат наступний:
      250-keyword=value
  Якщо значення повинно бути розбитим на декілька рядків, формат такий:
      250+keyword=
      value
      .
  Розпізнаються наступні ключі та їх значення, що включають:

    "version" -- Версія програмного забезпечення серверу, включаючи ім’я серверу. (приклад: "Tor 0.0.9.4")

    "config-file" -- Розміщення файлу конфігурації Tor ("torrc").

    "config-defaults-file" -- РОзміщення файлу з конфігурацією по замовчанню Tor ("torrc.defaults"). Цей файл розбирається перед torrc, та типово використовується для заміни значень конфігурації Tor по замовчанню. [Вперше реалізовано в 0.2.3.9-alpha].

    "config-text" -- Вміст, що Tor буде записувати, якщо ви пошлете йому команду SAVECONF, так що контролер може сам записати файл на диск. [Вперше реалізовано в 0.2.2.7-alpha.]

    "exit-policy/default" -- Вихідна політика по замовчанню, що Tor буде *додавати* до опції конфігурації ExitPolicy.

    "exit-policy/ipv4"
    "exit-policy/ipv6"
    "exit-policy/full" -- Вихідна політика OR тільки в IPv4, тільки в IPv6, або в усіх випадках.

    "desc/id/<OR identity>" або "desc/name/<OR nickname>" -- останній дескриптор сервера для даного OR. (Зауважте, що сучасні клієнти Tor не завантажують серверні дескриптори по замованню, але замість цього завантажують мікродескриптори. Якщо мікродескриптори дозволені, вам потрібно використовувати md/* замість цього).

    "md/id/<OR identity>" або "md/name/<OR nickname>" -- останній мікродескриптор для даного OR. [Вперше реалізовано в
      0.2.3.8-alpha.]

    "dormant" -- Невід’ємне ціле: нуль, якщо Tor в даний момент активний та будує ланцюжки, та не нуль, якщо Tor простоює за відсутності використання або за схожих причин.  [Вперше реалізовано в 0.2.3.16-alpha]

    "desc-annotations/id/<OR identity>" -- виводить рядок анотацій (джерело, часова печатка прибуття, призначення, таке інше) для відповідного декриптора. [Вперше реалізовано в 0.2.0.13-alpha.]

    "extra-info/digest/<digest>"  -- документ extrainfo, чий дайджест (в шістнадцятиричному) є <digest>. Доступно тільки якщо ми завантажуємо документи extra-info.

    "ns/id/<OR identity>" або "ns/name/<OR nickname>" -- останній статус маршрутника (в стилі каталогу v3) для заданого OR. Статусна інформація така, як надається в dir-spec.txt, та відзеркалює поточні переконання цього Tor щодо маршрутника в питанні. Подібно до кліентів каталогу, контролери ЗОБОВ’ЯЗАНІ пропускати незрозумілі флаги та рядки. Опублікована дата та дайджест дескриптора є тими, що за переконанням є кращими для цього Tor, не обов’язково ті для дескриптора, що той Tor начасі має.
      [Вперше реалізовано в 0.1.2.3-alpha.]
      [In 0.2.0.9-alpha this switched from v2 directory style to v3]

    "ns/all" -- Інформація щодо статусу маршрутника (в стилі каталогу v3) для всіх OR, щодо яких ми маємо якісь переконання, поєднані новими рядками.
      [Вперше реалізовано в 0.1.2.3-alpha.]
      [В 0.2.0.9-alpha ми перейшли з стилю каталогу v2 до v3]

    "ns/purpose/<purpose>" -- Інформація статусу маршрутника (в стилі каталогу v3) для всіх OR для цього призначення. В основному розроблено для запитів /ns/purpose/bridge.
      [Вперше реалізовано в 0.2.0.13-alpha.]
      [В 0.2.0.9-alpha ми перейшли з стилю каталогу v2 до v3]

    "desc/all-recent" -- останній дескриптор серверу для кожного маршрутника, про які знає Tor. (Див зауваження до md desc/id/* та desc/name/* вище).

    "network-status" -- розділений проміжками список (в стилі каталогу v1) всіх відомих іденціях OR. Це той же формат, що й рядок router-status в каталогах v1; дивіться розділ dir-spec-v1.txt для деталей. (Якщо включено VERBOSE_NAMES, на вихід не буде відповідати dir-spec-v1.txt; замість цього результат буде розділеним проміжками списком LongName, кожний з "!" зпереду, якщо ми вважаємо що він не працює). Ця опція визнана застарілою; використовуйте "ns/all" замість цього.

    "address-mappings/all"
    "address-mappings/config"
    "address-mappings/cache"
    "address-mappings/control" -- розділений \r\n список відображень адрес,  кожна в формі "from-address to-address expiry". Ключ 'config' повертає ті відображення адрес, що вказані в конфігурації; ключ'cache' повертає ті відображення, що є в кеші DNS на стороні клієнта; ключ 'control' повертає відображення, встановлені через керуючий інтерфейс; ціль'all' повертає відображення, що встановлені через любий механізм.
      
      Expiry відформатовано як в подіях ADDRMAP, за тим винятком,що "expiry" є завжди в часі UTC або є рядком "NEVER"; див розділ 4.1.7.
      Вперше з’явилось в 0.2.0.3-alpha.

    "addr-mappings/*" -- як для address-mappings/*, але без частини про прострочення значень. Використання цього значення застарілоз 0.2.0.3-alpha; замість використовуйте address-mappings.

    "address" -- найкраща здогадка нашої зовнішньої IP адреси. Якщо ми не маємо здогадки, повертається помилка 551. (Додано в 0.1.2.2-alpha)

    "fingerprint" -- Вміст файлу відтиску, що Tor записує як ретранслятор,  або 551, якщо ми начасі не є ретранслятором. (Додано в 0.1.2.3-alpha)

    "circuit-status"
      Послідовність рядків, як для події статусу ланцюжка. Кодний рядок є в формі, описаній в розділі 4.1.1, виключаючи початковий "650 CIRC ". Зауважте, що клієнти мають бути готові сприймати додаткові аргументи, як описано в розділі 4.1.

    "stream-status"
      Послідовність рядків, як для події статусу потоку. Кожний рядок в формі:
         StreamID SP StreamStatus SP CircuitID SP Target CRLF

    "orconn-status"
      Послідовніть рядків, для подіі статусу з’єднання OR. В Tor 
      0.1.2.2-alpha з ввімкненою можливістью VERBOSE_NAMES та в Tor
      0.2.2.1-alpha та пізніших, по замовчанню кожний рядок в формі:
         LongName SP ORStatus CRLF

     В Tor версії 0.1.2.2-alpha до 0.2.2.1-alpha з вимкненою функцією
     VERBOSE_NAMES та перед версією 0.1.2.2-alpha, кожний рядок має форму:
         ServerID SP ORStatus CRLF

    "entry-guards"
      Послідовніть рядків, що перелічують наразі обрани сутності охоронців, якщо такі є. В Tor 0.1.2.2-alpha з вімкненою можливістю VERBOSE_NAMES та в Tor 0.2.2.1-alpha та пізніших по замовчанню кожний рядок має форму:
         LongName SP Status [SP ISOTime] CRLF

     В Tor версіях 0.1.2.2-alpha до 0.2.2.1-alpha з вимкненою можливістю 
     VERBOSE_NAMES, та перед версією 0.1.2.2-alpha, кожний рядок має форму:
         ServerID2 SP Status [SP ISOTime] CRLF
         ServerID2 = Nickname / 40*HEXDIG

      Визначення Status однакове в обох:
         Status = "up" / "never-connected" / "down" /
                  "unusable" / "unlisted"

      [З 0.1.1.4-alpha до 0.1.1.10-alpha, вхідні охоронці називались 
       "helper-nodes". Tor все ще підтримує назву "helper-nodes", але вона застаріла, та не має використовуватись].

      [Старіші версії Tor (перед 0.1.2.x-final) генерували 'down' замість unlisted/unusable. Між 0.1.2.x-final та 0.2.6.3-alpha,
       'down' ніколи не генерувався].

      [XXXX ServerID2 відрізняється від ServerID тим, що відбитки не мають префіксу $. Це помилка реалізації. Було б добре додати $ знову, якщо ми можемо це зробити, не порушуючи сумісність].

    "traffic/read" -- Загально прочитаних байт (завантажено).

    "traffic/written" -- Загально байт записано (відвантажено).

    "accounting/enabled"
    "accounting/hibernating"
    "accounting/bytes"
    "accounting/bytes-left"
    "accounting/interval-start"
    "accounting/interval-wake"
    "accounting/interval-end"
      Інформаця щодо статусу рахунків. Якщо рахунки вімкнені, "enabled" є 1;  інакше 0. Поле "hibernating" є "hard", коли ми не приймаємо дані; "soft", якщо ми не приймаємо нових з’єднань, та "awake", якщо ми зовсім не гібернуємо. Поля "bytes" та "bytes-left" містять (read-bytes SP write-bytes), для початку та залишку інтервала, відповідно. Поля 'interval-start' та 'interval-end' є граничними для поточного інтервалу; поле 'interval-wake' є часом в поточному інтервалі (якщо є), коли ми плануємо або планували почати бути активними. Час наводиться в UTC.

    "config/names"
      Послідовність рядків, що перелічують доступні опції конфігурації. Кожна з них в формі:
         OptionName SP OptionType [ SP Documentation ] CRLF
         OptionName = Keyword
         OptionType = "Integer" / "TimeInterval" / "TimeMsecInterval" /
           "DataSize" / "Float" / "Boolean" / "Time" / "CommaList" /
           "Dependant" / "Virtual" / "String" / "LineList"
         Documentation = Text

    "config/defaults"
      Послідовності рядків, що перелічують значення по замовчанню для кожної опції конфігурації. Опції, які не мають прийнятного значення по замовчанню, не відображаються в цьому списку. З’явилося в Tor 0.2.4.1-alpha.
         OptionName SP OptionValue CRLF
         OptionName = Keyword
         OptionValue = Text

    "info/names"
      Послідовності рядків, що перелічують доступні опції GETINFO. Кожна з них в формі:
         OptionName SP Documentation CRLF
         OptionPrefix SP Documentation CRLF
         OptionPrefix = OptionName "/*"
      Форма OptionPrefix вказує число опцій, що починаються з префікса. Так що коли "config/*" буде перелічено, інші опції, що починаються з       "config/" будуть працювати, але "config/*" не є опцією сама по собі.

    "events/names"
      Розділений проміжками список всіх подій, що підтримується цією версією 
      Tor для SETEVENTS.

    "features/names"
      Розділений проміжками список всіх можливостей, що підтримуються цією версією Tor для USEFEATURE.

    "signal/names"
      Розділений проміжками список всіх значень, що підтримуються командою SIGNAL.

    "ip-to-country/*"
      Відображує IP адреси на 2-символьні коди країн. Наприклад, "GETINFO ip-to-country/18.0.0.1" дасть "US".

    "next-circuit/IP:port"
      XXX todo.

    "process/pid" -- id процесу, що належить головному процесу tor.
    "process/uid" -- id користувача, що виконує процес tor, -1 якщо невідомо (це не реалізовано під Windows, повертає -1).
    "process/user" -- Ім’я користувача, під яким праціює процес tor, провадить пустий рядок, якщо немає такого (це не реалізовано під      Windows, повертає пустий рядок).
    "process/descriptor-limit" -- Верхня межа лиміту файлових дескрипторів, -1 якщо невідомо.

    "dir/status-vote/current/consensus" [Додано в Tor 0.2.1.6-alpha]
    "dir/status/authority"
    "dir/status/fp/<F>"
    "dir/status/fp/<F1>+<F2>+<F3>"
    "dir/status/all"
    "dir/server/fp/<F>"
    "dir/server/fp/<F1>+<F2>+<F3>"
    "dir/server/d/<D>"
    "dir/server/d/<D1>+<D2>+<D3>"
    "dir/server/authority"
    "dir/server/all"
      Послідовності рядків, що перелічують вміст каталогу, що провадиться згідно до специфікації для URL, перелічених в Розділі 4.4 в dir-spec.txt. Зауважте, що Tor ЗОБОВ’ЯЗАНИЙ НЕ провадити приватну інформацію, таку, як дескриптори для маршрутників, що не відмічені як для загального призначення. Коли питається про інформацію 'authority', для якої цей Tor не є авторитетним, Tor відповідає пустим рядком.

      Зауважте, що в Tor 0.2.3.3-alpha, Tor клієнти більше не завантажують серверних дескрипторів, але замість цього мікродескриптори. Так що відповідь "551 Servers unavailable" на всі "GETINFO dir/server/*" насправді є коректною. Якщо ви маєте стару програму, що абсолютно потребує дескриптори для своєї роботи, спробуйте встановити UseMicrodescriptors 0 або FetchUselessDescriptors 1 в вашому клієнтському client's.

    "status/circuit-established"
    "status/enough-dir-info"
    "status/good-server-descriptor"
    "status/accepted-server-descriptor"
    "status/..."
      Ці запити надають поточні інутрішні значення Tor для різних станів Tor. Див Розділ 4.1.10 для пояснень. (Тільки декілька з статусних подій наразі доступні для запитів статусу. Повідомте нас, якщо ви бажаєте, щоб ми показували більше).    
    "status/reachability-succeeded/or"
      0 або 1, в залежності від того, чи ми виявили наш ORPort досяжним.
    "status/reachability-succeeded/dir"
      0 або 1, в залежності від того, чи ми виявили наш DirPort досяжним.
    "status/reachability-succeeded"
      "OR=" ("0"/"1") SP "DIR=" ("0"/"1")
      Комбінує status/reachability-succeeded/*; контролери ЗОБОВ’ЯЗАНІ ігнорувати нерозпізнані елементи в цьому елементі.
    "status/bootstrap-phase"
      Повертає найбільш новішу надіслану подію фази розкручування. Більш конкретно, повертається рядок, що починається або з "NOTICE BOOTSTRAP ..." або "WARN BOOTSTRAP ...". Контролери мають використовувати цей статус, коли вони з’єднуються або приєднуються до Tor, щоб визначити стан розкручування.
    "status/version/recommended"
      Список поточних рекомендованих версій.
    "status/version/current"
      Статус поточної версії. Одне з: new, old, unrecommended, recommended, new in series, obsolete, unknown.
    "status/version/num-concurring"
    "status/version/num-versioning"
      Ці опції застарілі; вони більше не несуть корисної інформації.
    "status/clients-seen"
      Підсумок, з яких країн ми нещодавно бачили клієнтів, форматовано так само, як стани CLIENTS_SEEN, що описані в Розділі 4.1.14. Ця опція  GETINFO наразі доступна тільки для ретрансляторів-мостів.

    "net/listeners/or"
    "net/listeners/dir"
    "net/listeners/socks"
    "net/listeners/trans"
    "net/listeners/natd"
    "net/listeners/dns"
    "net/listeners/control"
      В лапках, розділений проміжками список локацій, де Tor слухає на з’єднання вказаного типу. Це можуть бути, включаючи, мережеві адреси IPv4...

        "127.0.0.1:9050" "127.0.0.1:9051"

      ... або локальні сокети Unix...

        "unix:/home/my_user/.tor/socket"

      ... або адреси мережі IPv6:

        "[2001:0db8:7000:0000:0000:dead:beef:1234]:9050"

      [Нове в Tor 0.2.2.26-beta.]

    "dir-usage"
      Розділений новими рядками список того, як багато байтів ми обслуговували кожний тип запитів каталогу. Формат кожного рядка такий:
         Keyword 1*SP Integer 1*SP Integer
      де перше ціле є числом записаних байт, а друге є числом запитів, на які відповів сервер.

    "bw-event-cache"
      Розділений проміжками підсумок поточних подій RW в хронологічному порядку, від старіших до новіших. Кожна подія представлена розділеною комою парою "R,W", R є числом прочитаних байт, та W є числом записаних.Кожне з ціх входжень представляють біля кожної секунди трафіку.
      [Нове в Tor 0.2.6.3-alpha]

     "consensus/valid-after"
     "consensus/fresh-until"
     "consensus/valid-until"
      Кожний з них продукує ISOTime, що описує частину життевого часу поточного (достовірного, прийнятого) консенсусу, що має Tor.
      [Нове в Tor 0.2.6.3-alpha]

  Приклади:
     C: GETINFO version desc/name/moria1
     S: 250+desc/name/moria=
     S: [Descriptor for moria]
     S: .
     S: 250-version=Tor 0.1.1.0-alpha-cvs
     S: 250 OK

3.10. EXTENDCIRCUIT

  Надсилається від клієнта на сервер. Формат наступний:
      "EXTENDCIRCUIT" SP CircuitID
                      [SP ServerSpec *("," ServerSpec)]
                      [SP "purpose=" Purpose] CRLF

  Цей запит приймає один з двох форм: або CircuitID є нульовим, в якому разі це запит для сервера створити новий ланцюжок, або CircuitID не є нульовим, в якому разі це є запит для сервера роширити існуючий ланцюжок із тим ID до вказаної довжини.

  Якщо CircuitID є 0, контролер має опцію провадити шлях для Tor, що слід використовувати для побудови ланцюжка. Якщо він не надає шлях, Tor обере такий самостійно від високопотужних вузлів, згідно з path-spec.txt.

  Якщо CircuitID є 0 та вказано "purpose=", тоді встановлюється призначення ланцюжка.Розпізнаються два вибори: "general" та "controller". Якщо не вказано, ланцюжок буде створено як "general".

  Коли запит буде вдалим, сервер надсилає відповідь, що містить тіло повідомлення, що містить CircuitID (можливо тільки що створеного) ланцюжка. Синтаксис "250" SP "EXTENDED" SP CircuitID CRLF.

3.11. SETCIRCUITPURPOSE

  Надсилається від клієнта на сервер.  Формат наступний:
      "SETCIRCUITPURPOSE" SP CircuitID SP "purpose=" Purpose CRLF

  Це змінює призначення ланцюжка. ДИвіться EXTENDCIRCUIT вище для деталей.

3.12. SETROUTERPURPOSE

  Надсилається від клієнта на сервер. Формат наступний:
      "SETROUTERPURPOSE" SP NicknameOrKey SP Purpose CRLF

  Це змінює призначення дескриптора. дивіться +POSTDESCRIPTOR нижче для деталів.

  ЗАУВАЖЕННЯ: Ця команда була відключена та визнана застарілою від Tor
  0.2.0.8-alpha. Вона більше не існує, та наводиться лише для історичного інтересу.

3.13. ATTACHSTREAM

  Надсилається від клієнта на сервер.
  Синтаксис:
     "ATTACHSTREAM" SP StreamID SP CircuitID [SP "HOP=" HopNum] CRLF

  Це повідомлення інформує сервер, що вказаний потік має бути асоційований з вказанним ланцюжком. Кожний потік може бути асоційований щонайбільше з одни ланцюжком, там багато потоків можуть розділяти один і той ланцюжок. Потоки можуть бути приєднані до завершених ланцюжків (тобто до ланцюжків, що мають відісланий статус ланцюжка 'BUILT', або перелічені як побудовані в запиті статусів ланцюжків GETINFO).

  Якщо ID ланцюжка є 0, відповідальність про приєднання цього потоку повертається до Tor.

  Якщо вказано HOP=HopNum, Tor буде обирати стрибок с номером HopNumth в ланцюжку в якості вихідного вузла. Стрибки починаються з одиниці (1); загалом, не дозволяеться подключатися до стрибка 1.

  Tor відповідає "250 OK" якщо він може підключити до потік, 552 якщо ланцюжок або потік не існують, 555 якщо потік не в належному стані, щоб бути приєднаним (тобто він вже відкритий), або 551, якщо потік не може бути приєднаний по іншій причині.

  {Зауваження з реалізації: Tor буде зачиняти неприєднані потоки самостійно, приблизно через дві хвилини як вони були утворені. Дайте знати розробникам, якщо виявиться, що це викликає проблеми}.

  {Зауваження з реалізації: По замовчанню Tor автоматично підєднує потоки до ланцюжків самотужки, окрім випадку, коли змінна конфігурації   "__LeaveStreamsUnattached"встановлена в "1". Спроба приєднати потоки через TC, коли "__LeaveStreamsUnattached" не діє може спричинити стан гонки між 
  Tor та контролером, коли обидва намагаються приєднати потоки до ланцюжків}.

  {Зауваження з реалізації: Ви можете спробувати підключити потік, що вже відіслав запит на підключення або на пошук імені, але досі не зазнав успіху. В Цьому разі Tor відключить потік від поточного ланцюжка перед тим, як зробити новий запит на підключення}.

3.14. POSTDESCRIPTOR

  Надсилається від клієнта на сервер. 
  Синтаксис:
    "+POSTDESCRIPTOR" [SP "purpose=" Purpose] [SP "cache=" Cache]
                      CRLF Descriptor CRLF "." CRLF

  Це повідомлення інформує сервер про новий дескриптор. Якщо Purpose вказано, воно має бути або "general", "controller", або "bridge", в іншому випадку буде повернено 552 помилку. По замовчанню "general".

  Якщо вказаний Cache, він має бути або "no" або "yes", інакше ми повертаємо помилку 552. Якщо Cache не вказаний, Tor буде вирішувати самостійно, чи бажає він використовувати кеш для дескриптора, та контролери не мають покладатися на його вибір.

  Дескриптор, коли розбірається, мусить містити число гарно-відомих полей, включаючи поля для скороченого імені (нікнейм) та ідентичності.

  Якщо виникає помилка при розборі дескриптора, сервер мусить надіслати відповідь "554 Invalid descriptor". Якщо дескриптор гарно сформований, але сервер обирає не додавати його, він має відповісти повідомленням 251, чиє тіло пояснює, чому сервер не додає його. Якщо дескриптор доданий, Tor відповідає "250 OK".

3.15. REDIRECTSTREAM

  Надсилається від клієнта на сервер. 
  Синтаксис:
    "REDIRECTSTREAM" SP StreamID SP Address [SP Port] CRLF

  Наказує серверу змінити вихідну адресу на вказаному потоці. Якщо вказано   Port, змінити також і цільовий порт. Не виконується переміщення для нової запровадженої адреси.

  Щоб впевнитися, що буде використовуватись нова модифікована адреса, ця подія має бути надіслана після того, як буде отримано подію нового потоку, та перед приєднання цього потоку до ланцюжка.

  Tor відповідає "250 OK" в разі успіху.

3.16. CLOSESTREAM

  Надсилається від клієнта на сервер.  
  Синтаксис:
    "CLOSESTREAM" SP StreamID SP Reason *(SP Flag) CRLF

  Наказує серверу закрити обраний потік. Причиною має одна з причин Tor RELAY_END, наданих в tor-spec.txt, як десятичне число. Флаги начасі не використовуються; сервери Tor МАЮТЬ ігнорувати нерозпізнані флаги. Tor може утримувати потік відкритим, щоб скинути любі дані, що очікують на це.

  Tor відповідає "250 OK" в разі успіху, або 512 якщо недостатньо аргументів, або 552, якщо він не розпізнав StreamID або причину.

3.17. CLOSECIRCUIT

   Синтаксис:
     "CLOSECIRCUIT" SP CircuitID *(SP Flag) CRLF
     Flag = "IfUnused"

  Наказує серверу закрити вказаний ланцюжок.Якщо вказано "IfUnused", не закривати ланцюжок, доки він не перестане використовуватись.

  Інші флаги можеть бути визначені в майбутньому; Tor МАЄ ігнорувати нерозпізнані флаги.

  Tor відповідає "250 OK" в разі успіху, або 512, якщо недостатньо аргументів, або 552, якщо він не розпізнав CircuitID.

3.18. QUIT

  Наказує серверу перервати це з’єдання з контролером. Ця команда може використовуватись до аутентифікації.

3.19. USEFEATURE

  Додаванняє додаткових можливостей до протоколу керування часом ламає зворотню сумісність. Спочатку такі можливості додаються в Tor та виключені по замовчан. USEFEATURE може включити ці додаткові можливості.

  Синтаксис:

    "USEFEATURE" *(SP FeatureName) CRLF
    FeatureName = 1*(ALPHA / DIGIT / "_" / "-")

  Імена можливостей чутливі до реєстру буков.

  Коли вже вімкнені, можливості лишаються вімкненими на протязі з’єднання з контролером. Нове з’єднання з контролером має біти відкритим, щоб знову вимкнути ці можливості.

  Можливості є механізмом сумісності з майбутнім; кожна можливість колись стане стандартною частиною протоколоу керування. Коли можливість стане частиною протокола, вона буде завжди-вімкненою. Кожна можливість документує версію, коли вона з’явилась як можливість, та версію, коли вона стане частиною протоколу.

  Tor буде ігнорувати запит до використання любої можливості, що завжди-вімкнена. Tor видаватиме помилку 552 у відповідь на нерозпізнану можливість.

  EXTENDED_EVENTS

     Те ж, що надіслати 'EXTENDED' до SETEVENTS; це рекомендований шлях для запиту синтаксису розширених подій.

     Ця можливість була введена в 0.1.2.3-alpha. Вона завжди-вімкнена та є частиною протокола в Tor 0.2.2.1-alpha та пізніших.

  VERBOSE_NAMES

     Замінює ServerID на LongName в подіях та результатах GETINFO. LongName провадить відтиск Fingerprint для всіх маршрутників, індикацію статусу Named, та скороче ім’я Nickname, якщо воно відоме. LongName безсумнівно більш інформативне, ніж ServerID, що провадить тільки Fingerprint або  Nickname.

     Ця можливість з’явилась в 0.1.2.2-alpha. Вона завжди вімкнена та є частиною протокола в Tor 0.2.2.1-alpha та пізніших.

3.20. RESOLVE

  Синтаксис
    "RESOLVE" *Option *Address CRLF
    Option = "mode=reverse"
    Address = a hostname or IPv4 address

  Ця команда запускає пошук віддаленого імені вузла для кожгого вказаного запиту (або зворотній пошук, якщо вказано "mode=reverse"). Зауважте, що запит виконується у фоні: щоб побачити відповіді, ваш контролер буде потребувати слухати події ADDRMAP; див 4.1.7 нижче.

  [Added in Tor 0.2.0.3-alpha]

3.21. PROTOCOLINFO

  Синтаксис:
    "PROTOCOLINFO" *(SP PIVERSION) CRLF

  Відповідь серверу маю вигляд:
    "250-PROTOCOLINFO" SP PIVERSION CRLF *InfoLine "250 OK" CRLF

    InfoLine = AuthLine / VersionLine / OtherLine

     AuthLine = "250-AUTH" SP "METHODS=" AuthMethod *("," AuthMethod)
                       *(SP "COOKIEFILE=" AuthCookieFile) CRLF
     VersionLine = "250-VERSION" SP "Tor=" TorVersion OptArguments CRLF

     AuthMethod =
      "NULL"           / ; Аутентифікація не потрібна
      "HASHEDPASSWORD" / ; Контролер повинен надати оригінальний пароль
      "COOKIE"         / ; Контролер повинен підтримувати вміст cookie
      "SAFECOOKIE"       ; Контролер повинен підтвердити знання cookie

     AuthCookieFile = QuotedString
     TorVersion = QuotedString

     OtherLine = "250-" Keyword OptArguments CRLF

    PIVERSION: 1*DIGIT

  Tor МОЖЕ надавати свої InfoLines в любому порядку; контролери ЗОБОВ’ЯЗАНІ ігнорувати InfoLines з ключовими словами, що вони не розуміють.   Контролер ЗОБОВ’ЯЗАНИЙ ігнорувати додаткові дані в любому InfoLine.

  PIVERSION є випадком, коли ми суттєво змінюємо синтаксис одного дня. Тепер це має завжди бути "1". Контролери МОЖУТЬ провадити список провадити список версій протоколів, що вони підтримують; Tor МОЖЕ обрати версію, що контролер не підтримує.

  AuthMethod використовується для задання одного або більше методів аутентифікації, що ії підтримує Tor на даний час.

  AuthCookieFile вказує абсолютний шлях та ім’я файлу cookie аутентифікації, що очікує Tor, та надається, якщо поле METHODS містить методи "COOKIE" та/або "SAFECOOKIE". Контролер ЗОБОВ’ЯЗАНИЙ обробляти послідовності виключення в цьому рядку.

  Всі cookies аутентифікації мають довжину 32 бійти. Контролери ЗОБОВ’ЯЗАНІ НЕ використовувати вміст файлів з довжиною не 32 байти в якості cookie аутентифікації.

  Якщо поле METHODS містить метод "SAFECOOKIE", кожний AuthCookieFile має містити той же самий cookie аутентифікації.

  Метод аутентифікації COOKIE показує користувачеві, що виконує контролер, атаку ненамисного розкриття інформації, якщо контролер має більші права по читанню, ніж той процес, до якого він підключений. (Зауважте, що контролер може під’єднуватися до процесів, інших ніж Tor). Це майже ніколи не небезпечно, навіть якщо користувач контролеру явно вказав, з якого файлу читати cookie аутентифікації. З цієї причини метод аутентифікації COOKIE було візнано застарілим, та буде видалено в майбутніх версіях Tor.

  Рядок VERSION містить версію Tor.

  [На відміну від інших команд, крім AUTHENTICATE, PROTOCOLINFO може бути використано (але тільки один раз!) перед AUTHENTICATE.]

  [PROTOCOLINFO не підтримувався до Tor 0.2.0.5-alpha.]

3.22. LOADCONF

  Синтаксис:
    "+LOADCONF" CRLF ConfigText CRLF "." CRLF

  Ця команда дозволяє контролеру завантажувати текст файлу конфігурації в Tor через керуючий порт. Цей файл конфігурації після цього завантажується тим же чином, наче він був прочитаний з диску.

  [LOADCONF було додано в Tor 0.2.1.1-alpha.]

3.23. TAKEOWNERSHIP

  Синтаксис:
    "TAKEOWNERSHIP" CRLF

  Ця команда інструктує Tor завершитися, коли це управляюче з’єднання буде закрито. Це також впливає на кожне управляюче з’єднанн, що надсилає його незалежно; якщо декілька управляючих з’єднань надсилають команду TAKEOWNERSHIP до екземпляру Tor, Tor буде завершено, коли любе з ціх з’єднань буде закрито.

  (Як щодо Tor 0.2.5.2-alpha, Tor не чекає деякий час, докі ланцюжки закрилися, коли завершується через закриття управляючого з’єднання. Якщо ви бажаєте впевнитися в чистому завершенні - а ви маєте - тоді надішліть "SIGNAL SHUTDOWN", та очікуйте, коли Tor виконає всі закритя). 

  Ця команда призначена, щоб використовуватись з опцією конфінурації
  __OwningControllerProcess. Контролер, що стартує процес Tor, що не може бути легко скерований користувачем або завершитись, повинен "заволодіти" процесом Tor:

    * Коли запускається Tor, контролер має вказати свій PID в
      __OwningControllerProcess в командному рядку Tor's. Це призведе до того, що Tor буде опитувати наявність процесу з таким PID, та вийде, якщо він не знайде такий процес. (Це не повністю надійний шлях, щоб визначити, що "володіючий контролер" ще працює, але буде досить добре працювати в більшості випадків).

    * Коли контролер підключиться до порту керування Tor, він має надіслати команду TAKEOWNERSHIP разом зі з’єднанням керування. В цій точці, *обоє*Ю команда TAKEOWNERSHIP та опція __OwningControllerProcess мають ефект: Tor буде зевершено, коли завершиться з’єднання керування *та* Tor завелшиться, якщо виявить, що немає процесу з PID, вкзаним в опції      __OwningControllerProcess.

    * Після того, як контролер надіслав команду TAKEOWNERSHIP, він має надіслати "RESETCONF __OwningControllerProcess" через керуюче з’єднання. Це призведе до того, що Tor перестане опитувати наявність процесу з PID контролера-власника; Tor буде як і раніше виходити по завершенню керуючого з’єднання.

  [TAKEOWNERSHIP було додано в Tor 0.2.2.28-beta.]

3.24. AUTHCHALLENGE

  Синтаксис:
    "AUTHCHALLENGE" SP "SAFECOOKIE"
                    SP ClientNonce
                    CRLF

    ClientNonce = 2*HEXDIG / QuotedString

  Якщо сервер сприймає команду, формат відповіді сервера буде наступним:
    "250 AUTHCHALLENGE"
            SP "SERVERHASH=" ServerHash
            SP "SERVERNONCE=" ServerNonce
            CRLF

    ServerHash = 64*64HEXDIG
    ServerNonce = 64*64HEXDIG

  Значення ClientNonce, ServerHash та ServerNonce закодовані-розкодовані тим же чином, як і аргумент, що передано в команді AUTHENTICATE. ServerNonce ЗОБОВ’ЯЗАНИЙ бути 32 байтиі довжини.

  ServerHash обчислюється наступним чином:
    HMAC-SHA256("Tor safe cookie authentication server-to-controller hash",
                CookieString | ClientNonce | ServerNonce)
  (з ключем HMAC в якості першого аргументу)

  Після того, як контролер надсилає успішну команду AUTHCHALLENGE, наступна команда, надіслана в з’єднання, має бути AUTHENTICATE, та тільки рядок аутентифікації, що буде сприйматися цією командою AUTHENTICATE, буде наступна:
    HMAC-SHA256("Tor safe cookie authentication controller-to-server hash",
                CookieString | ClientNonce | ServerNonce)

  [На відміну від інших команд, крім AUTHENTICATE, AUTHCHALLENGE може бути використана (але тільки один раз!) перед AUTHENTICATE.]

  [AUTHCHALLENGE було додано в Tor 0.2.3.13-alpha.]

3.25. DROPGUARDS

  Синтаксис:
    "DROPGUARDS" CRLF

  Наказує серверу відкинути всі вузли-охоронці. Не викликайте цю команду навмання; це може підвищити вразливість, та з часом до можливого відсліджування.

  Tor відповідає "250 OK" в разі успіху.

  [DROPGUARDS було додано в Tor 0.2.5.2-alpha.]

4. Відповіді

  Коди відповідей слідують тому ж 3-символьному формату, що використовуєтся і в SMTP, з першим символом що визначає статус, другий символ визначає підсистему, та третій надає уточнену інформацію.

  Протокол TC наразі використовує наступні перші символи:

    2yz   Позитивна відповідь завершення
       Команда була вдалою; новий запит може бути надіслано.

    4yz   Тимчасова негативна відповідь завершення
       Команда не була вдалою, та може бути спробувана пізніше.

    5yz   Постійна негативна відповідь завершення
       Команда була неуспішною; клієнт не має намагатися спробувати саме таку послідовність команд.

    6yz   Асинхронная відповідь
       Надсилається в будь якому порядку як відповідь на попередню команду SETEVENTS.

  Використовуються наступні другі символи:

    x0z   Синтакс
       Посилається у відповідь на невірно форматовані або незвістовні команди.

    x1z   Протокол
       Посилаєтся на операції Tor Control protocol.

    x5z   Tor
       Посилається на дійсні операції системи Tor.

  Визначені наступні коди:

     250 OK
     251 Operation was unnecessary (Операція непотрібна)
         [Tor відмовився виконувати операцію, але шкоди не завдано.]

     451 Resource exhausted (Ресурси вичерпано)

     500 Syntax error: protocol (Синтаксична помилка: протокол)

     510 Unrecognized command (Нерозпізнана команда)
     511 Unimplemented command (Нереалізована команда)
     512 Syntax error in command argument (Синтаксична помилка в аргументі команди)
     513 Unrecognized command argument (Нерозпізнаний аргумент команди)
     514 Authentication required (Потрібна аутентифікація)
     515 Bad authentication (Погана аутентифікація)

     550 Unspecified Tor error (Невказана помилка Tor)

     551 Internal error (Внутрішня помилка)
               [Щось не те в самому Tor, так що запит клієнта не може бути реалізовано]

     552 Unrecognized entity (Нерозпізнана сутність)
               [Ключ конфігурації, ID потоку, ID ланцюжка, подія, вказані в команді, насправді не існують]

     553 Invalid configuration value (Невірне значення конфігурації)
         [Клієнт намагається встановити опцію конфігурації, в некоректне, пага зформоване або неможливе значення]

     554 Invalid descriptor (Недійсний дескриптор)

     555 Unmanaged entity (Незадіяна сутність)

     650 Asynchronous event notification (Сповіщення асинхронної події)

  Якщо не вказано, що це має особистий вміст, призначені для людини повідомлення не призначені, щоб на них покладатись в тому вигляді, як вони приведені в цьому документі.

4.1. Асинхронні події

  Ці відповіді можуть бути надіслані після відповідних команд SETEVENTS, що були прийняті. Вони не будуть перемішуватися з іншими елементами Reply, але вони можуть з’являтися між командою та відповідною відповіддю. Наприклад, можлива така послідовність:

     C: SETEVENTS CIRC
     S: 250 OK
     C: GETCONF SOCKSPORT ORPORT
     S: 650 CIRC 1000 EXTENDED moria1,moria2
     S: 250-SOCKSPORT=9050
     S: 250 ORPORT=0

  Але така послідовніть не є допустимою:
     C: SETEVENTS CIRC
     S: 250 OK
     C: GETCONF SOCKSPORT ORPORT
     S: 250-SOCKSPORT=9050
     S: 650 CIRC 1000 EXTENDED moria1,moria2
     S: 250 ORPORT=0

  Клієнт ЗОБОВ’ЯЗАНИЙ пропускати більше аргументів в асинхронній відповіді, чим очікувалось, та ЗОБОВ’ЯЗАНИЙ пропускати більше рядків в асинхронній відповіді, ніж очікувалось. Наприклад, клієнт, що очікує CIRC повідомлення, як:
      650 CIRC 1000 EXTENDED moria1,moria2
  має також погоджуватися з такими:
      650-CIRC 1000 EXTENDED moria1,moria2 0xBEEF
      650-EXTRAMAGIC=99
      650 ANONYMITY=high

  Якщо клієнт отримує розщирені події (обрані через USEFEATUERE
  EXTENDED_EVENTS в Tor 0.1.2.2-alpha..Tor-0.2.1.x, та завжди ввікнені в   Tor 0.2.2.x та пізніших), тоді кожний рядок події, як вказано нижче, може завершуватися додатковими аргументами та додатковими рядками. Додаткові рядки будуть мати форму:
      "650" ("-"/" ") KEYWORD ["=" ARGUMENTS] CRLF
  Додаткові аргументи будуть мати такий вигляд
      SP KEYWORD ["=" ( QuotedString / * NonSpDquote ) ]

  Клієнт ЗОБОВ’ЯЗАНИЙ пропускати події, чиї аргументи та ключові слова він не розуміє, та ПОВИНЕН обробляти ті події, як ті невідомі аргументи та ключові слова були відсутні.

  Клієтни НЕ ПОВИННІ залежати від порядку аргуентів keyword=value, та НЕ ПОВИННІ залежати від того, щоб нові аргументи keyword=value не з’являлись між існуючими аргументами keyword=value, хоча як на момент написання (Jun 2011) деякі залежать.  Таким чином, розширення до цього протоколу повинні додавати нові ключові слова тільки після існуючих ключових слів, докі всі відомі контролери не будуть виправлені. В деякій точці це "НЕ ПОВИННІ" може перетворитись на "ЗОБОВ’ЯЗАНИЙ НЕ".

4.1.1. Статус ланцюжка змінився

   Синтаксис:

     "650" SP "CIRC" SP CircuitID SP CircStatus [SP Path]
          [SP "BUILD_FLAGS=" BuildFlags] [SP "PURPOSE=" Purpose]
          [SP "HS_STATE=" HSState] [SP "REND_QUERY=" HSAddress]
          [SP "TIME_CREATED=" TimeCreated]
          [SP "REASON=" Reason [SP "REMOTE_REASON=" Reason]]
          [SP "SOCKS_USERNAME=" EscapedUsername]
          [SP "SOCKS_PASSWORD=" EscapedPassword]
          CRLF

      CircStatus =
               "LAUNCHED" / ; ID ланцюжки, присвоєний новому ланцюжку
               "BUILT"    / ; всі стрибки завершені, можна приймати потоки
               "EXTENDED" / ; ще один стрибок було завершено
               "FAILED"   / ; ланцюжок закрито (не ув побудований)
               "CLOSED"     ; ланцюжок закрито (був побудований)

      Path = LongName *("," LongName)
        ; В Tor версій 0.1.2.2-alpha до 0.2.2.1-alpha з можливістю
        ; VERBOSE_NAMES вимкнено і до версії 0.1.2.2-alpha, Path
        ; в такому вигляді:
        ; Path = ServerID *("," ServerID)

      BuildFlags = BuildFlag *("," BuildFlag)
      BuildFlag = "ONEHOP_TUNNEL" / "IS_INTERNAL" /
                  "NEED_CAPACITY" / "NEED_UPTIME"

      Purpose = "GENERAL" / "HS_CLIENT_INTRO" / "HS_CLIENT_REND" /
                "HS_SERVICE_INTRO" / "HS_SERVICE_REND" / "TESTING" /
                "CONTROLLER" / "MEASURE_TIMEOUT"

      HSState = "HSCI_CONNECTING" / "HSCI_INTRO_SENT" / "HSCI_DONE" /
                "HSCR_CONNECTING" / "HSCR_ESTABLISHED_IDLE" /
                "HSCR_ESTABLISHED_WAITING" / "HSCR_JOINED" /
                "HSSI_CONNECTING" / "HSSI_ESTABLISHED" /
                "HSSR_CONNECTING" / "HSSR_JOINED"

      EscapedUsername = QuotedString
      EscapedPassword = QuotedString

      HSAddress = 16*Base32Character
      Base32Character = ALPHA / "2" / "3" / "4" / "5" / "6" / "7"

      TimeCreated = ISOTime2Frac
      Seconds = 1*DIGIT
      Microseconds = 1*DIGIT

      Reason = "NONE" / "TORPROTOCOL" / "INTERNAL" / "REQUESTED" /
               "HIBERNATING" / "RESOURCELIMIT" / "CONNECTFAILED" /
               "OR_IDENTITY" / "OR_CONN_CLOSED" / "TIMEOUT" /
               "FINISHED" / "DESTROYED" / "NOPATH" / "NOSUCHSERVICE" /
               "MEASUREMENT_EXPIRED"

   Проваджений шлях тільки коли ланцюжок був розширений щонайменше на один стрибок.

   Поле "BUILD_FLAGS" провадиться тільки для версій 0.2.3.11-alpha
   та пізніших.  Клієнт ЗОБОВ’ЯЗАНИЙ приймати флаги побудови, що не вказані тут. Флаги побудови визначаються таким чином:

      ONEHOP_TUNNEL   (однострибковий ланцюжок, використовується для 
                       підключення тунелем до серверу)
      IS_INTERNAL     (внутрішній ланцюжок, не може бути використаний для
                       вихідних потоків)
      NEED_CAPACITY   (цей ланцюжок має викоритсовувати тільки потужні вузли)
      NEED_UPTIME     (цей ланцюжок має використовувати тільки давно 
                       живучі вузли)

   Поле "PURPOSE" провадиться тільки в версії 0.2.1.6-alpha та пізніших, та тільки якщо включені розширені події (див 3.19). Клієнт ЗОБОВ’ЯЗАНИЙ приймати призначення, не вказані вище. Призначення визначені наступним чином:

      GENERAL         (ланцюжок для AP та/або потоку запиту каталогу)
      HS_CLIENT_INTRO (HS ланцюжок клієтської точки введення)
      HS_CLIENT_REND  (HS ланцюжок клієнсьої точки рандеву; несе AP потоки)
      HS_SERVICE_INTRO (HS ланцюжок серверної точки введення)
      HS_SERVICE_REND (HS ланцюжок серверонї точки рандеву)
      TESTING         (ланцюжок перевірки досяжності; не створює трафік)
      CONTROLLER      (ланцюжок, сбудований контролером)
      MEASURE_TIMEOUT (ланцюжок, що був утримуваний лише для того, щоб
                       перевірити, скільки це займе часу)

   Поле "HS_STATE" впроваджено тільки для ланцюжків прихованих сервисів, та тільки в версіях 0.2.3.11-alpha та пізнішіх. Клієнт ЗОБОВ’ЯЗАНИЙ приймати стани прихованого сервісу, не перелічені нижче. Стани прихованого сервісу перелічені наступним чином:

      HSCI_*      (стани вхідних клієнтських ланцюжків)
        HSCI_CONNECTING          (під’єднання до вхідної точки)
        HSCI_INTRO_SENT          (надіслано INTRODUCE1; очікуємо від IP)
        HSCI_DONE                (отримано від ретранслятора IP; зачиняємось)

      HSCR_*      (стани рандеву клієнтських ланцюжків)
        HSCR_CONNECTING          (під’єднання або очікування відповіді RP)
        HSCR_ESTABLISHED_IDLE    (встановлення RP; очікуівння введення)
        HSCR_ESTABLISHED_WAITING (введення надіслано до HS; очікування rend)
        HSCR_JOINED              (під’єднанно HS)

      HSSI_*      (стани вхідних серверних ланцюжків)
        HSSI_CONNECTING          (під’єднання до вхідної точки)
        HSSI_ESTABLISHED         (встановлено точку входу)

      HSSR_*      (стани рандеву серверних ланцюжків)
        HSSR_CONNECTING          (підключення до клієнтської точки рандеву)
        HSSR_JOINED              (підключено до клієнтсьокого ланцюжка RP)

   Поля "SOCKS_USERNAME" та "SOCKS_PASSWORD" вказуюсть на дані користувача, що були застосовані SOCKS клієнтом для під’єднання до Tor SOCKS порту та ініціювати цей ланцюжок. 

   (Потоки для клієнтив SOCKS, підключених для інших імен-паролів, є ізольованими в окремих ланцюжках, якщо активований флаг IsolateSOCKSAuth; див Пропозицію 171).

   Поле "REND_QUERY" провадиться тільки для пов’язаних з прихованими сервісами ланцюжками, та тільки з версії 0.2.3.11-alpha та пізнішіх. Клієнт ЗОБОВ’ЯЗАНИЙ приймати адреси прихованих серсівів в форматах, що не вказані вище.

   Поле "TIME_CREATED" провадиться тільки в версіях 0.2.3.11-alpha та пізніших. TIME_CREATED є часом, коли ланцюжок був створений або канабалізований.

   Поле "REASON" провадиться тільки для подій FAILED та CLOSED, та тільки якщо дозволені розширені події (див 3.19). Клієнт ЗОБОВ’ЯЗАНИЙ приймати причини не пераховані вище. Причини такі, що надаються в файлі tor-spec.txt, за винятком:

      NOPATH              (Недостатньо вузлів щоб створити ланцюжок)
      MEASUREMENT_EXPIRED (Як "TIMEOUT", за тип винятком, що ми залишаємо 
                           ланцюжок відкритим для цілей замірів, щоб побачити, як довго він буде завершуватись).

   Поле "REMOTE_REASON" провадиться тільки коли ми отримали клітину DESTROY або TRUNCATE, та тільки якщо дозволені розширені події. Воно містить дійсну причину, надану віддаленим OR для закриття ланцюжка. Клієнт  ЗОБОВ’ЯЗАНИЙ сприймати причини, не перелічені вище. Причини перелічені в tor-spec.txt.

4.1.2. Змінено статус потоку

    Синтаксис:

      "650" SP "STREAM" SP StreamID SP StreamStatus SP CircuitID SP Target
          [SP "REASON=" Reason [ SP "REMOTE_REASON=" Reason ]]
          [SP "SOURCE=" Source] [ SP "SOURCE_ADDR=" Address ":" Port ]
          [SP "PURPOSE=" Purpose]
          CRLF

      StreamStatus =
               "NEW"          / ; Новий запит на з’єдання
               "NEWRESOLVE"   / ; Новий запит на розв’язання адреси
               "REMAP"        / ; Адресу змінено на іншу
               "SENTCONNECT"  / ; Післано клітину з’єднання по ланцюжкові
               "SENTRESOLVE"  / ; Післано клітину розв’язання по ланцюжкові
               "SUCCEEDED"    / ; Отримано відповідь; встановлено потік
               "FAILED"       / ; Потік зруйновано, не підлягає відновленню
               "CLOSED"       / ; Потік закрито
               "DETACHED"       ; Від’єднано від ланцюжка; можна відновити

       Target = TargetAddress ":" Port
       Port = ціле від 0 до 65535 включно
       TargetAddress = Address / "(Tor_internal)"

  ID ланцюжка вказує, до якого ланцюжка під’єднано цей потік. Якщо потік не під’єднано вказується ланцюжок з ID "0". Ціль вказує на адресу, до якої треба під’єднатися або яку треба розв’язати; це може бути "(Tor_internal)" для віртуальних потоків, створених програмою Tor для розмов з собою.

      Reason = "MISC" / "RESOLVEFAILED" / "CONNECTREFUSED" /
               "EXITPOLICY" / "DESTROY" / "DONE" / "TIMEOUT" /
               "NOROUTE" / "HIBERNATING" / "INTERNAL"/ "RESOURCELIMIT" /
               "CONNRESET" / "TORPROTOCOL" / "NOTDIRECTORY" / "END" /
               "PRIVATE_ADDR"

   Поле "REASON" надається тільки для подій FAILED, CLOSED та DETACHED, та тільки якщо дозволені розширені події (див 3.19). Клієтн ЗОБОВ’ЯЗАНИЙ
   сприймати причини, не вказані вище. Причини наведені в tor-spec.txt,
   за винятком:

      END          (Ми отримали клітину RELAY_END з іншого боку цьго потоку).
      PRIVATE_ADDR (Клієни намагався под’єднатися до приватної адреси
                    типу 127.0.0.1 або 10.0.0.1 через Tor.)
      [XXXX document more. -NM]

   Поле "REMOTE_REASON" провадиться тільки коли ми отримали клітину RELAY_END, та тільку у випадку, коли дозволені розширені події. Він містить дійсну причину, надану віддаленим OR для зачинення потоку. Клієнт ЗОБОВ’ЯЗАНИЙ сприймати причини, не вказані вище. Причини перелічені в tor-spec.txt.

   Події "REMAP" включають Source, якщо дозволені розширені події:
      Source = "CACHE" / "EXIT"
   Клієнти ЗОБОВ’ЯЗАНІ сприймати джерела, що не вказані вище. "CACHE" надається, коли клієнт Tor вирішує перемістити адресу завдяки відповіді з кешу, та "EXIT" вказується, коли віддалений вузол, що ми опитуємо, надав нам нову адресу в якості відповіді.

   Поле "SOURCE_ADDR" включається з подіями NEW та NEWRESOLVE, якщо включені розширені події. Воно вказує адресу та порт, що запросили з’єднання, та може, таким чином, використовуватися для пошуку запитуючої програми.

      Purpose = "DIR_FETCH" / "DIR_UPLOAD" / "DNS_REQUEST" /
                "USER" /  "DIRPORT_TEST"

   Поле "PURPOSE" надається тільки для подій NEW та NEWRESOLVE, та тільки в разі, коли дозволені розширені події (див 3.19). Клієнти ЗОБОВ’ЯЗАНІ сприймати призначення, що не перелічені вище. Призначення вище визначені наступним чином:

       "DIR_FETCH" -- Цей потік сгенеровано внутрішньо в Tor для отримання інформації каталогу.
       "DIR_UPLOAD" -- Внутрішній потік для завантаження інформації на довірений сервер каталогу.
       "DIRPORT_TEST" -- Потік, що ми використовуємо для перевірки нашого власного порту каталогу, щоб впевнитись що від досяжний.
       "DNS_REQUEST" -- Ініційований користувачем DNS запит.
       "USER" -- Цей потік обробляє трафік користувача, АБО він є внутрішнім до Tor, але його призначення не співпадає з одним з призначень вище.

4.1.3. Статус з’єднання OR змінився

  Синтаксис:

    "650" SP "ORCONN" SP (LongName / Target) SP ORStatus [ SP "REASON="
             Reason ] [ SP "NCIRCS=" NumCircuits ] [ SP "ID=" ConnID ] CRLF

    ORStatus = "NEW" / "LAUNCHED" / "CONNECTED" / "FAILED" / "CLOSED"

        ; В версіях Tor 0.1.2.2-alpha до 0.2.2.1-alpha з можливістю
        ; VERBOSE_NAMES виключено та до версії 0.1.2.2-alpha, OR
        ; Connection є наступним:
        "650" SP "ORCONN" SP (ServerID / Target) SP ORStatus [ SP "REASON="
                 Reason ] [ SP "NCIRCS=" NumCircuits ] CRLF

  NEW для вхідних з’єднань, та LAUNCHED для вихідних з’єднань. CONNECTED означає рукопотискання TLS було завершено (в любому напрямку). FAILED означає з’єднання було закрито, але не завершило рукопотискання, та CLOSED для з’єднань, що закриті, але пройшли рукопотискання.

  LongName або ServerID вказуються, якщо це не NEW з’єднання; в цьому разі ми не знаємо що це за сервер, так що ми використовуємо Address:Port.

  Якщо розширені події дозволені (див 3.19), інформація про додаткову причину та підрахунок ланцюжків провадиться для подій CLOSED та FAILED.

      Reason = "MISC" / "DONE" / "CONNECTREFUSED" /
               "IDENTITY" / "CONNECTRESET" / "TIMEOUT" / "NOROUTE" /
               "IOERROR" / "RESOURCELIMIT" / "PT_MISSING"

  NumCircuits підраховує обоє, встановлені та очікуючі ланцюжки.

  Значення ORStatus наступні:
     NEW -- Ми отримали нове вхідне OR з’єднання, та починаємо рукопотискання сервера.
     LAUNCHED -- Ми запустили нове вихідне OR з’єднання, та починаємо клієнтське рукопотискання.
     CONNECTED -- З’єднання OR було встановлено, та рукопотискання було виконано.
     FAILED -- Наша спроба відкрити з’єднання OR зазнало невдачі.
     CLOSED -- З’єднання OR закрите невиразним шляхом.

  Значення Reason для закритих та навдалих OR з’єднань наступні:
     DONE -- З’єднання OR було завершено чисто.
     CONNECTREFUSED -- Ми отримали ECONNREFUSED при спробі підключитися до цільового OR.
     IDENTITY -- Ми підключилисядо OR, але винайшли, що його ідентичнісь не та, на яку ми сподівались.
     CONNECTRESET -- Ми отримали ECONNRESET, або подібну помилку IO від з’єднання з OR.
     TIMEOUT -- Ми отримали ETIMEOUT або подібну помилку IO від з’єднання з OR, або ми закриваємо з’єднання, тому що воно було в таймауті дуже довго.
     NOROUTE -- Ми отримали ENOTCONN, ENETUNREACH, ENETDOWN, EHOSTUNREACH, або подібну помилку при підключенні до OR.
     IOERROR -- Ми отримали деяку іншу IO помилку на нашому з’єднанні до OR.
     RESOURCELIMIT -- Ми не маємо досить ресурсів операційної системи (файлових дескрипторів, буферів, інше), щоб під’єднатися до OR.
     PT_MISSING -- Немає доступних підключаємих транспортів.
     MISC -- З’єднання закрито по якійсь іншій причині.

  [ID параметр було додано в 0.2.5.2-alpha]

4.1.4. Пропускна здібнісь, використана за останню секунду

  Синтаксис:
     "650" SP "BW" SP BytesRead SP BytesWritten *(SP Type "=" Num) CRLF
     BytesRead = 1*DIGIT
     BytesWritten = 1*DIGIT
     Type = "DIR" / "OR" / "EXIT" / "APP" / ...
     Num = 1*DIGIT

  BytesRead та BytesWritten є підсумками. [В майбутній версії Tor,
  ми можемо також включити розрізнення типів з’єднання, що використовують полосу пропускання за цю секунду (досі не реалізовано).]

4.1.5. Повідомлення журналу

  Синтаксис:
     "650" SP Severity SP ReplyText CRLF
  або
     "650+" Severity CRLF Data 650 SP "OK" CRLF

     Severity = "DEBUG" / "INFO" / "NOTICE" / "WARN"/ "ERR"

4.1.6. Доступні нові дескриптори

  Синтаксис:
     "650" SP "NEWDESC" 1*(SP LongName) CRLF
        ; В версіях Tor 0.1.2.2-alpha до 0.2.2.1-alpha з можливостю 
        ; VERBOSE_NAMES вимкнено та до версії 0.1.2.2-alpha, це виглядає
        ; таким чином:
        "650" SP "NEWDESC" 1*(SP ServerID) CRLF

4.1.7. Нове відображення адреси

  Ці події генеруються, коли нове відображення адреси з’являється в адресному кеші Tor, або коли відповідь для команди RESOLVE було знайдено.  Входження може бути створено через вдалий або навдалий пошук в DNS, вдалу або невдалу спробу з’єднання, команду RESOLVE, команду MAPADDRESS, можливість AutomapHostsOnResolve, або можливість TrackHostExits.

  Синтаксис:
     "650" SP "ADDRMAP" SP Address SP NewAddress SP Expiry
       [SP "error=" ErrorCode] [SP "EXPIRES=" UTCExpiry] [SP "CACHED=" Cached]
       CRLF

     NewAddress = Address / "<error>"
     Expiry = DQUOTE ISOTime DQUOTE / "NEVER"

     ErrorCode = "yes" / "internal" / "Unable to launch resolve request"
     UTCExpiry = DQUOTE IsoTime DQUOTE

     Cached = DQUOTE "YES" DQUOTE / DQUOTE "NO" DQUOTE

  Тільки Error та UTCExpiry провадятся, якщо включені зовнішні події. Значеня для Error майже некорисні. Майбутні значення будуть обиратись щоб задовільняти 1*(ALNUM / "_"); значення "Unable to launch resolve request" є помилкою в Tor до 0.2.4.7-alpha.

  Expiry виражено як локальний час (скоріше ніж UTC).  Це помилка, полишена для зворотньої сумісності; новий код має дивитись на UTCExpiry замість цього. (Якщо Expiry є "NEVER", UTCExpiry буде пропущеним.)

  Cached вказує, чи відображеня буде зберігатись до того як вийде строк придатності, або якщо це лише сповіщення у відповідь на команду RESOLVE.

4.1.8. Дескриптори були завантажені до нас в нашій ролі як довіреного серверу каталогу

  Tor генерує цю подію, коли це довірений сервер каталогу, і хтось тільки що завантажив дескриптор сервра.

  Синтаксис:
     "650" "+" "AUTHDIR_NEWDESCS" CRLF Action CRLF Message CRLF
       Descriptor CRLF "." CRLF "650" SP "OK" CRLF
     Action = "ACCEPTED" / "DROPPED" / "REJECTED"
     Message = Text

  Поле Descriptor є текстом перверного дескриптора; поле Action є "ACCEPTED", якщо ми прийняли дескриптор, як новий найкращий дескриптор для його маршрутизатора, "REJECTED", якщо ми не беремо дескриптор, та ми скаржимося до завантажуючого ретранслятора про це, та "DROPPED", якщо ми вирішуємо відкинути дескриптор без скарг. Поле Message є зрозумілим для людини рядком, чому ми обрали саме цю Action. (Він не містить символів нового рядка).

4.1.9. Наш дескриптор змінено

  Синтаксис:
     "650" SP "DESCCHANGED" CRLF

  [Вперше з’явилось в 0.1.2.2-alpha.]

4.1.10. Події статусу

  Події статусу (STATUS_GENERAL, STATUS_CLIENT, and STATUS_SERVER) надсилаються базуючись на процессах Tor, що належать до головного стану програми. Загалом, вони відповідають повідомленням журналу з важливістю Notice або вище. Вони відрізняються від журнальних повідомлень в тому, що їх формат є визначенний інтерфейс.

  Синтаксис:
     "650" SP StatusType SP StatusSeverity SP StatusAction
                                         [SP StatusArguments] CRLF

     StatusType = "STATUS_GENERAL" / "STATUS_CLIENT" / "STATUS_SERVER"
     StatusSeverity = "NOTICE" / "WARN" / "ERR"
     StatusAction = 1*ALPHA
     StatusArguments = StatusArgument *(SP StatusArgument)
     StatusArgument = StatusKeyword '=' StatusValue
     StatusKeyword = 1*(ALNUM / "_")
     StatusValue = 1*(ALNUM / '_')  / QuotedString

     StatusAction є рядком, та StatusArguments є серіями пар keyword=value на тому ж рядку. Значення можуть завершуватися обмеженими проміжками рядками або квотованими рядками.

     Ці події завжди зроблені з EXTENDED_EVENTS та VERBOSE_NAMES; дивіться пояснення в розділі USEFEATURE для деталей.

     Контролер ЗОБОВ’ЯЗАНИЙ пропускати нерозпізнані акції, ЗОБОВ’ЯЗАНИЙ пропускати незрозумілі аргументи, ЗОБОВ’ЯЗАНИЙ допускати відсутні аргументи, та ЗОБОВ’ЯЗАНИЙ допускати аргументи, що ідуть в довільному порядку.

     Кожний дескриптор події нижче іде разом з рекомендацією для контроллерів. Ці рекомендації є тільки рекомендаціями; контролер не має їх дотримуватись.

  Зауваження сумісності: версії Tor перед 0.2.0.22-rc невірно генерували  "STATUS_SERVER" як "STATUS_SEVER". Щоб бути сумісним з тими версіями, інструменти мають стриймати обоє варивнтів.

  Дії для STATUS_GENERAL можуть бути наступними:

     CLOCK_JUMPED
     "TIME=NUM"
       Tor проводить досить часу без циклів CPU, так що він закриває всі свої ланцюжки та потім створює їх знову. Це типово відбувається, коли лептоп іде до сну, та потім знову просинається. Це також відбувається, коли система обмінюється з диском настільки важко, що Tor починає голодувати. Аргумент "time" вказує число секунд, що Tor думає він був непритомний (або альтернативно, число секунд, на які він відійшов назад в часі).

       Ця статусна подія звичайно надсилається з важливістю NOTICE, але важливість WARN, якщо Tor в даний момент виконується як сервер.

       {Рекомендація для контролера: ігноруйте його, оскільки ми насправді не знаємо, що користувач має насправді робити. Hm.}

     DANGEROUS_VERSION
     "CURRENT=version"
     "REASON=NEW/OBSOLETE/UNRECOMMENDED"
     "RECOMMENDED=\"version, version, ...\""
       Tor з’ясував, що сервери каталогу не рекомендують свою версію програмного забезпечення Tor. RECOMMENDED є комами та проміжками поділений рядок версій Tor, що рекомендовані. REASON є NEW, якщо це версія Tor є новішою, цим жодна рекомендована версія, OBSOLETE, якщо це версія Tor старіша, ніж люба рекомендована версія, та
       UNRECOMMENDED, якщо деякі версії Tor новіші, та інші старіші, чим ця версія. (Причина "OBSOLETE" була названа  "OLD", починаючи з Tor 0.1.2.3-alpha та до, включаючи 0.2.0.12-alpha.)

       {Контролери можуть побажати підказати, щоб користувач обновив OLD або
       UNRECOMMENDED версії. Версії NEW можуть мати відомі вади безпеки, або можуть бути просто тими, що розробляються.}

     TOO_MANY_CONNECTIONS
     "CURRENT=NUM"
       Tor досяг свій "ulimit -n" або будь який природний ліміт на файлові дескриптори або сокети. CURRENT є числом сокетів Tor, що зараз відкриті. Користувач має зробити щось з цим. Аргумент "current" показує число з’єднань, що наразі відкриті.

       {Контролери можуть рекомендувати, щоб користувач збільшив цей ліміт, або сам збільшити його. Рекомендації мають перефразовані в термінах OS, та бути автоматизовані, якщо це можливо.}

     BUG
     "REASON=STRING"
       Tor виявив ситуацію, що його розробники ніколи не очікували, і розробники бажали б вивчити, що трапилось. Можливо контролер може пояснити це користувачу, та заохотити його надіслати повідомлення про помилку?

       {Контролери мають занотовувати помилки в журнал, але не повинні докучати користувачеві в випадку, коли помилка з’являється часто.}

     CLOCK_SKEW
       SKEW="+" / "-" SECONDS
       MIN_SKEW="+" / "-" SECONDS.
       SOURCE="DIRSERV:" IP ":" Port /
              "NETWORKSTATUS:" IP ":" Port /
              "OR:" IP ":" Port /
              "CONSENSUS"
         Якщо "SKEW" присутній, це очікування того, наскільки далеко ми знаходимось від часу, задекларованого в джерелі. (Іншими словами, якщо ми знаходимось на годину в минулому, значення буде -3600). Якщо присутній "MIN_SKEW", це нижній бар’єр. Якщо джерело є  DIRSERV, ми отримуємо поточний час від з’єднання з сервером каталогу. Якщо джерелом є NETWORKSTATUS, ми схибили через те, що отримали мережевий статус v2 з далечини в минулому. Якщо джерелом є OR, здвиг утворився прийшов з клітини NETINFO, отриманої від іншого ретранслятора. Якщо джерелом є CONSENSUS, доходимо думки, що ми зсунулися через отримання консенсусу мережевого статусу з майбутнього.

         {Tor має надсилати це повідомлення до контролерів, коли він вважає, що зсув в часі такий, що буде впливати на вірне функціонування Tor. Контролери не мають сліпо підкручувати годинники, тому що саме акуратне джерело інформації зсуву (DIRSERV) на даний час не аутентифіковано.}

     BAD_LIBEVENT
     "METHOD=" libevent method
     "VERSION=" libevent version
     "BADNESS=" "BROKEN" / "BUGGY" / "SLOW"
     "RECOVERED=" "NO" / "YES"
        Tor знає про помилки в використанні сконфігурованого методу подій для цієї версії libevent. "BROKEN" події зовсім не роблять; "BUGGY" libevents можуть робити гарно; "SLOW" libevents будуть робити добре, ален не швидко. Якщо "RECOVERED" є YES, Tor вдалося перемикнутися на біль надійний (але потенцівльно повільніші!) методи.

        {Контролери можуть побажати попередити користувача, коли виникає цей випадок, хоча загалом це помилка того, хто будував двоїчний образ Tor і користувачеві немає чого дуже робити, окрім як оновити версію libevent або обновити двоїчний образ.}

     DIR_ALL_UNREACHABLE
       Tor вірить, що не один з відомих серверів каталогу не доступні -- найбільш вірогідніше це через те, що локальна мережа не налаштована, або щось інше не робить, і може допомогти пояснити для користувача, чому виглядає, що Tor поломаний.

       {контролери можуть побажати попередити користувача, якщо виникає ця подія; подальші дії в основному неможливі.}

     CONSENSUS_ARRIVED
        Tor отримав та перевірив новий консенсус мережевого статусу.
        (Ця подія може бути трохи відкладена після того, як консенсусу буде отримано, якщо Tor потребує отримати сертифікати.)

  Дії для подій STATUS_CLIENT можуть бути наступними:

     BOOTSTRAP
     "PROGRESS=" num
     "TAG=" Keyword
     "SUMMARY=" String
     ["WARNING=" String]
     ["REASON=" Keyword]
     ["COUNT=" num]
     ["RECOMMENDATION=" Keyword]
     ["HOST=" QuotedString]
     ["HOSTADDR=" QuotedString]

       Tor зробив деякий прогрес по встановленю з’єднання до своєї мережі, отримавши інформацію каталогу, або зробивши свій перший ланцюжок; або він спіткав проблему під час розкручування. Ця подія статусу особливо корисна для користувачів з повільним з’єднанням або з проблемами з’єднання.

       "Progress" набуває значення від 0 та 100 в залежності від того, як далеко зайшов прогрес розкручування. "Summary" є рядком, що може відображатися користувачеві, щоб змалювати *наступне* завдання, що Tor буде виконувати, тобто завдання, над яким він працює після надсилання події. "Tag" є рядком, що контролери можуть використовувати для різпізнавання фаз розкручування, якщо вони бажають зробити щось розумніше, ніж тільки сліпо друкувати підсумкові рядки; дивіться Розділ 5 для поточних тегів, що їх використовує Tor.

       StatusSeverity описує, чи є це звичайною фазою розкручування (рівень повідомлення), або це є вказівкою на проблему розкручування (рівень попередження).

       Для проблем розкручування ми включили ті же значення: прогрес, тег та підсумок, як і для звичайних повідомнель розкручування, але ми також включили комбінацію з пар ключ\значення: "warning", "reason", "count" та "recommendation". Число "count" каже, як багато проблем розкручування було оттримано на цьому етапі розкручування. Рядок "reason" перелічує одну з причин, дозволених в події ORCONN. Аргумент-рядок "warning" містить рядок з любими підказками, що тоже надати Tor, щодо того, чому він має складності з розкручуванням.

       Значення "reason" є довготерміновими, призначені для контролера, теги, щоб ідентифікувати окремі проблеми на крочі розкручування. Рдяки попередження, з другого боку, є спрямованими до людини-читача. Контролери НЕ ПОВИННІ покладатися на формат любого рядка попередження.На часі можливі рішення для "recommendation" є або "ignore" або
       "warn" -- в разі ігнорування, контролер може акумулювати рядок в купі проблем, щоб відобразити користувачеві, якщо користувач спитає; в разі попередження, контролер повинен повідомити користувача, що Tor мало не впевнений, що виникла проблема розкручування.

       Значення "host" є дайджестом сущності (шеснадцятирічне) вузла, до якого ми намагаємось підключитися; "hostaddr" є комбінацією address:port, де 'address' є або ipv4 або ipv6 адреса.

       Наразі Tor використовує recommendation=ignore для перших дев’яти проблем розкручування для окремої фази, та потім використовує recommendation=warn для подальших проблем на цій фазі. Маємо надію, що це добрий баланс між ігноруванням випадкових помилок, та швидкою доповіддю про серьйозні проблеми.

     ENOUGH_DIR_INFO
       Tor тепер знає дотатньо про документи мережевого статусу, та досить серверних дескрипторів, так що тепер він збирається почати спроби побудувати ланцюжки.

      [Новіші версії Tor (0.2.6.2-alpha та пізніші):
       Якщо консенсус містить Exits (типовий випадок), Tor буде будувати обоє, вихідні та внутрішні ланцюжки. Якщо ні, Tor буде будувати тільки внутрішні ланцюжки.]

       {Контролери можуть побажати використати цю подію для вирішення, коли індикувати прогрес до своїх користувачів, але не повинні переривати перегляд користувача, щоб повідомити йому це.}

     NOT_ENOUGH_DIR_INFO
       Ми відкинули прострочені статуси та серверні дескриптори, щоб відкотитися нижче бажаного рівня інформації каталогу. Ми не збираємось будувати жодних ланцюжків до того, як знову отримаємо ENOUGH_DIR_INFO.

       {Контролери можуть побажати використати цю подію для вирішення, коли індикувати прогрес до своїх користувачів, але не повинні переривати перегляд користувача, щоб повідомити йому це.}

     CIRCUIT_ESTABLISHED
       Tor в змозі встановити ланцюжки для використання клієнтами. Ця подія буде відіслана тільки в випадку, якщо ми тільки що побудували ланцюєок, що змінив нашу думку -- тобто, до цієї події ми не можемо знати, чи можемо ми встановити ланцюжок.

       {Пропоноване використання: контролери можуть повідомити користувача, що Tor є готовим для використання в якості клієнта, коли вони побачили цю подію статусу. [Можливо, контролери також мають встановити таймаут, коли пройшло багато часу, та це повідомлення не виникає, щоб надати підказку по виправленню ситуації. З другого боку, сподіваємость Tor буде і надалі надсилати наступні події статусу, якщо він буде в змозі розпізнати проблему.]}

     CIRCUIT_NOT_ESTABLISHED
     "REASON=" "EXTERNAL_ADDRESS" / "DIR_ALL_UNREACHABLE" / "CLOCK_JUMPED"
       Ми більше не впевнені в тому, що можемо будувати ланцюжки. Ключове слово "reason" провадить пояснення: яка друга подія статусу призвела до втрати нашої впевненості.

       {Контролери можуть побажати використати цю подію для вирішення, коли індикувати прогрес до своїх користувачів, але не повинні переривати перегляд користувача, щоб повідомити йому це.}
       
       [Зауваження: наразі реалізовано тільки REASON=CLOCK_JUMPED.]

     DANGEROUS_PORT
     "PORT=" port
     "RESULT=" "REJECT" / "WARN"
       Потік було ініційовано на порті, що зазвичай використовується для уражуваних протоколів відкритим текстом. Якщо Result є "reject", ми відхиляємо з’єднання; коли значення набуває "warn", ми дозволяємо його.

       {Контроли повинні попередити своїх користувачів, коли виникає ця помилка, за винятком випадку, коли вони вже знають, що застосування, що використовує Tor, фактично робить це коректно (наприклад, коли воно є частиною пакунку розповсюдження). Вони можуть також бажати даяку різновидь інтерфейсу, щоб дозволити користувачеві конфігурацію своїх опцій RejectPlaintextPorts та WarnPlaintextPorts.}

     DANGEROUS_SOCKS
     "PROTOCOL=" "SOCKS4" / "SOCKS5"
     "ADDRESS=" IP:port
       З’єднання було зроблене до порту Tor SOCKS з використанням одного з підходів SOCKS, що не підтримує імен вузлів -- тільки голі IP адреси. Якщо застосування клієнта отримує цю адресу від gethostbyname(), може виникнути витік цільової адреси через  DNS.

       {Контролери повинні попереджати своїх користувачів коли це трапляється, за винятком випадку, коли вони вже знають, що застосування, що використовує Tor, фактично робить це коректно (наприклад, коли воно є частиною пакунку розповсюдження).}

     SOCKS_UNKNOWN_PROTOCOL
       "DATA=string"
       З’єднання було зроблено на Tor SOCKS порт, що намагається використовувати його для чогось іншого, ніж SOCKS протокол. Вірогідно, що користувач використовує Tor як HTTP проксі? DATA є першими декількома символами, надісланими до Tor на SOCKS порт.

       {Контролери можуть побажати попередити своїх користувачів, коли це трапляється: це вказує на навірно сконфігуроване застосування.}

     SOCKS_BAD_HOSTNAME
      "HOSTNAME=QuotedString"
       Деяке застосування надало нам дивно виглядаюче ім’я вузлу. Може воно побите? В любому випадку цене буде працювати з Tor, і користувачі мають про це знати.

       {Контролери можуть побажати попередити своїх користувачів, коли це відбувається: це зазвичай означає на навірно сконфігуроване застосування.}

  Дії для STATUS_SERVER можуть бути наступними:

     EXTERNAL_ADDRESS
     "ADDRESS=IP"
     "HOSTNAME=NAME"
     "METHOD=CONFIGURED/DIRSERV/RESOLVED/INTERFACE/GETHOSTNAME"
       Наша найкраща ідея для нашого видимого ззовні IP була змінена на 'IP'.Якщо 'HOSTNAME' присутній, ми отримуємо новий IP через пошук 'NAME'. Якщо метод є 'CONFIGURED', IP був наданий буквально, як опція конфігурації. Якщо метод є 'RESOLVED', ми винайшли опцію конфігурації Address щоб отримати IP. Якщо метод є 'GETHOSTNAME', ми використовуємо ім’я вузла для пошуку IP. Якщо метод є 'INTERFACE', ми отримуємо адресу одного з наших мережевих інтерфейсів для отримання IP. Якщо метод є 'DIRSERV', сервер каталогу каже нам сподівання, яким може бути наш IP.

       {Контролери можуть побажати записати цю інформацію та відображати її користувачеві.}

     CHECKING_REACHABILITY
     "ORADDRESS=IP:port"
     "DIRADDRESS=IP:port"
       Ми починаємо тестування досяжності нашого зовнішнього порту OR, або порту каталогу.

       {Ця подія може впливати на ідею контролера щодо статусу сервера, але контролер не повинен переривати користувача, щоб повідомити йому це.}

     REACHABILITY_SUCCEEDED
     "ORADDRESS=IP:port"
     "DIRADDRESS=IP:port"
       Ми успішно перевірили досяжність нашого зовнішнього порту OR, або порту каталогу (в залежності на який, ORADDRESS або DIRADDRESS це надходить.)

       {Ця подія може впливати на ідею контролера щодо статусу сервера, але контролер не повинен переривати користувача, щоб повідомити йому це.}

     GOOD_SERVER_DESCRIPTOR
       Ми успішно завантажили наш дескриптор сервера на щонайменш один довірений сервер каталогу, без нарікань.

       {Спочатку ціллю цієї події була декларація "кожний довірений сервер прийняв наш дескриптор, так що не буде нарікань на нього". Але оскільки деякі довірені сервери можуть знаходитись в стані офлайн, то впевнено досягти цієї мети виявилось складніше, ніж ми сподівались. Таким чином, ця подія є еквівалентом до ACCEPTED_SERVER_DESCRIPTOR нижче. Контролери мають тільки шукати ACCEPTED_SERVER_DESCRIPTOR та мають ігнорувати цю подія, принаймні зараз.}

     SERVER_DESCRIPTOR_STATUS
     "STATUS=" "LISTED" / "UNLISTED"
       Ми тільки отримали новий консенсус мережевого статусу, та ми можемо або ні бути перелічені в ньому, але наш статус змінився. Більш специфічно, коли статус буде "listed", якщо ми є в ньому, та до цієї точки ми не знали, що ми були перелічені в консенсусі; та статус буде "unlisted", якщо ми думаємо, що маємо бути перелічені в ньому (наприклад, якщо ми там були останнього разу), але насправді це не так.

       {Переміщення від переліченого до непереліченого не обов’язково є приводом для тривоги. Ретранслятор може схибити в декількох перевірках досяжності, або інтернет може мати деякі проблеми маршрутизації. Так що ця можливість загалом може надавати інформацію операторам ретранслятора, коли їхній ретранслятор успішно був перелічений в консенсусі.}

       [Досі не реалізовано. Ми будемо робити це в 0.2.2.x. -RD]

     NAMESERVER_STATUS
     "NS=addr"
     "STATUS=" "UP" / "DOWN"
     "ERR=" message
        Один з наших серверів імен змінив статус.

        {Ця подія може впливати на ідею контролера про статус сервера, але контролер не повинен переривати користувача щоб повідомити йому це.}

     NAMESERVER_ALL_DOWN
        Всі з наших серверів імен відключені.

        {Це проблема; Якщо це відбувається, часто без того, щоб сервери імен знову піднялись, користувач потребує сконфігурувати більше або кращі сервери імен.}

     DNS_HIJACKED
        Наш DNS провайдер провадить адресу, тоді коли б він мав сказати "NOTFOUND"; Tor буде дивитись на цю адресу як на синоним "NOTFOUND".

        {Це дратує; контролери можуть забажати повідомити коритсувача, що його DNS провайдер не є довіреним.}

     DNS_USELESS
        Наш DNS провайдер надає перехвачену адресу, замість добре відомої для відомих веб сайтів; Tor не буде намагатися стати віхідним вузлом.

        {Контролери можуть попередити адміністратора, якщо ретранслятор налаштовано на роботу вихідним вузлом: адміністратор має сконфігурувати гарний DNS сервер. В якості альтернативи, це трапляється багато разів в деяких обмежених середовищах (готелях, університетах, кафетеріях), коли користувач не є зареєстрованим.}

     BAD_SERVER_DESCRIPTOR
     "DIRAUTH=addr:port"
     "REASON=string"
        Довірений вузол каталогу відхилив наш дескриптор. Можливі причини включають невірно сформовані дескриптори, невірні ключі, дуже зсунутий час, і так далі.

        {Контролери мають повідомляти адміністратора, та намагатися дати раду, якщо зможуть.}

     ACCEPTED_SERVER_DESCRIPTOR
     "DIRAUTH=addr:port"
        Один довірений сервер каталогу прийняв наш дескриптор.
        // насправді повідомлення

       {Ця подія може вплинути на ідею контролера про статус сервера, але контролер не повинен переривати користувача, щоб повідомити йому про це.}

     REACHABILITY_FAILED
     "ORADDRESS=IP:port"
     "DIRADDRESS=IP:port"
       Ми схибили при з’єднанні до наш зовнішній OR порт або порт каталогу недосяжний.

       {Ця подія може вплинути на ідею контролера про статус сервера. Контролер повинен попередити адміністратора, та запропонувати логічні кроки.}

4.1.11. Наш набір вузлів охоронців змінено

  Синтаксис:
     "650" SP "GUARD" SP Type SP Name SP Status ... CRLF
     Type = "ENTRY"
     Name = ServerSpec
       (Ідентифікує охоронця, до якого відноситься повідомлення)
     Status = "NEW" | "UP" | "DOWN" | "BAD" | "GOOD" | "DROPPED"

  Тип ENTRY індикує охоронця. що використовується для під’єднання до мережі Tor.

  Значення Status наступні:
    "NEW"  -- Цей вузол не був до цього використано як охоронця; тепер ми
              маємо його як одного з обраних.
    "DROPPED" -- Цей вузол є один з попередньо обраних в якості охоронця;
              ми більше не розглядяємо його як одного з нашого списку охоронців.
    "UP"   -- Охоронець тепер виглядає як досяжний.
    "DOWN" -- Охоронець тепер виглядає як недосяжний.
    "BAD"  -- Завдяки набору флагів в консенсусі та/або значенням в 
              конфінурації, цей вузол тепер непридатний як охоронець.
    "GOOD" -- Завдяки набору флагів в консенсусі та/або значенням в 
              конфінурації, цей вузол тепер є придатний як охоронець.

  Контролери ЗОБОВ’ЯЗАНІ сприймати незрозумілі типи та незрозумілі статуси.

4.1.12. Статус мережі змінено

  Синтаксис:
     "650" "+" "NS" CRLF 1*NetworkStatus "." CRLF "650" SP "OK" CRLF

  Подія використовується, коли наше локальне бачення статусу ретранслятора змінюється. Це трапляється, коли ми отримуємо новий консенсус v3 (в якому випадку входження, які ми бачимо, є дублікатами того, що ми бачимо в події NEWCONSENSUS, нижче), та це також трапляється, коли ми вирішуємо маркувати ретранслятор, що підвищує або понижує наш локальний статус, наприклад, на основі спроб встановити з’єднання.

  [Вперше з’явилось в 0.1.2.3-alpha]

4.1.13. Ширина полоси, що використовується для потоку застосування

  Синтаксис:
     "650" SP "STREAM_BW" SP StreamID SP BytesWritten SP BytesRead CRLF
     BytesWritten = 1*DIGIT
     BytesRead = 1*DIGIT

  BytesWritten та BytesRead є числом байтів, записаних та прочитаних застосуванням з часу останнього надходження події STREAM_BW для цього потоку.

  Зауважте, що з перспективи Tor, *читання* байту на потоці означає, що застосування *записує* байт. Ось чому порядок *записаних* та *прочитаних* зворотній для подій stream_bw, у порівнянні до bw подій.

  Ці події генеруються близько разу в секунду; події не генеруються для потоків, в які не записували або які не читали. Ці події стосуються тільки для потоків, що входять в Tor (такі як SOCKSPort, TransPort, та таке інше).Вони не генеруються для вихідних потоків.

4.1.14. Статус клєнтів по країнах

  Синтаксис:
     "650" SP "CLIENTS_SEEN" SP TimeStarted SP CountrySummary SP
     IPVersions CRLF

  Ми тільки що генерували новий підрахунок з яких країн ми бачили клієнтів останнім часом. Контролер може відобразити це для користувача, наприклад, у його вікні конфігурації ретрансляторів, щоб надати деякий сенс, та що вони дійсно були корисними.

  На зараз тільки ретранслятори-мости будуть посилати цю подію, але одного дня ми зрозуміємо, як достатньо повно агрегувати та очистити клінтські підрахунки на головних ретрансляторах, ми можемо вирішити відсилання ці події також і в інших випадках.

  TimeStarted є квотований рядок, індикуючий, з якого часу ведеться відлік (в UTCS).

  Ключове слово CountrySummary має в частині аргументу розділений комами, можливо пустий, набір пар "countrycode=count". Наприклад (без переносу рядка), 650-CLIENTS_SEEN TimeStarted="2008-12-25 23:50:43"
  CountrySummary=us=16,de=8,uk=8

  Ключове слово IPVersions має свій аргумент, розділений комами набір пар   "protocol-family=count". Наприклад, IPVersions=v4=16,v6=40

4.1.15. Прибув новий консенсус статусу мережі

  Синтаксис:
     "650" "+" "NEWCONSENSUS" CRLF 1*NetworkStatus "." CRLF "650" SP
     "OK" CRLF

  Прибув новий консенсус мережевого статусу. Ми включаємо NS-style рядки для кожного ретранслятора в консенсусі. NEWCONSENSUS є окремою подією від події NS, оскільки представлений тут список представляє дуже корисні ретранслятори: таким чином, любий ретранслятор, що *не* представлений в цьому списку неявно не є рекомендованим.

  [Вперше з’явилось в 0.2.1.13-alpha]

4.1.16. Було встановлено новий час побудови ланцюжка

  Синтаксис:
     "650" SP "BUILDTIMEOUT_SET" SP Type SP "TOTAL_TIMES=" Total SP
        "TIMEOUT_MS=" Timeout SP "XM=" Xm SP "ALPHA=" Alpha SP
        "CUTOFF_QUANTILE=" Quantile SP "TIMEOUT_RATE=" TimeoutRate SP
        "CLOSE_MS=" CloseTimeout SP "CLOSE_RATE=" CloseRate
        CRLF
     Type = "COMPUTED" / "RESET" / "SUSPENDED" / "DISCARD" / "RESUME"
     Total = Ціле, підрахунок збережених таймаутів
     Timeout = Ціле, таймаут у мілісекундах
     Xm = Очікуване ціле, параметр Pareto Xm в мілісекундах
     Alpha = Очікуване з плаваючою комою Paredo альфа параметр
     Quantile = З плаваючою комою, CDF квантована точка відсічення для даного таймауту
     TimeoutRate = З плаваючою комою, доля ланцюжків, що дістали таймауту
     CloseTimeout = Як довго утримувати заміряні ланцюжки в мілісекундах
     CloseRate = З плаваючою комою, доля заміряних ланцюжків, що закриті

  Було встановлено новий таймаут побудови ланцюжків. Якщо Type є "COMPUTED", Tor обчислив значення, базоване на історичних даних. Якщо Type є "RESET", ініціалізація або значні мережеві зміни змусили Tor скинути таймаути назад до замовчань, та навчатись з початку. Якщо Type "SUSPENDED", Tor зафіксував втрату мережевого з’єднання та тимчасово змінив значення таймаута до замовчання до тих пір, доки мережа не відновиться. Якщо тип "DISCARD", Tor вирішив відкинути значення таймаутут, що вірогідно трапилось за часів, коли мережа не працювала. Якщо тип є "RESUME", Tor вирішив відновити обчислення таймаутів.

  Значення Total є лічильником часу побудови ланцюжків, що використовує Tor  при своїх обчисленнях. Воне захвачується внутрішньо на максимальному числі часів побудови, що зберігає Tor (NCIRCUITS_TO_OBSERVE).

  Сам Timeout провадиться в мілісекундах. Внутрішньо Tor округлює значення до ближчої секунди перед його застосуванням. 
  
  [Вперше з’явилось в 0.2.2.7-alpha]

4.1.17. Отримано сигнал

  Синтаксис:
     "650" SP "SIGNAL" SP Signal CRLF

     Signal = "RELOAD" / "DUMP" / "DEBUG" / "NEWNYM" / "CLEARDNSCACHE"

  Було отримано сигнал та Tor підприйняв дії. Значення кожного сигналу, та відображення на сигнали Unix, визначено в розділі 3.7. Подальші версії  МОЖУТЬ генерувати інші сигнали, відмінні від тих, що перераховані тут;  контролери ЗОБОВ’ЯЗАНІ бути в змозі прийняти їх.

  Якщо Tor обирає ігнорувати сигнал (такий як NEWNYM), цей сигнал не буде відіслано. Зауважте, що деякі опації (як ReloadTorrcOnSIGHUP), можуть вплинути на семантику ціх сигналів.

  ТАкож зверніть увагу, що сигнали HALT (SIGTERM) та SHUTDOWN (SIGINT) на даний час не генерують подію.

  [Вперше з’явилось в 0.2.3.1-alpha]

4.1.18. Конфінурацію змінено

  Синтаксис:
     StartReplyLine *(MidReplyLine) EndReplyLine

     StartReplyLine = "650-CONF_CHANGED" CRLF
     MidReplyLine = "650-" KEYWORD ["=" VALUE] CRLF
     EndReplyLine = "650 OK"

  Опціі конфігурації Tor було змінено (наприклад, через SETCONF або сигнал RELOAD). KEYWORD та VALUE задають опції конфигурації, що були змінені. Невизначені опції конфігурації містять тільки KEYWORD.

4.1.19. Статус ленцюжка незначно змінився

  Синтаксис:

    "650" SP "CIRC_MINOR" SP CircuitID SP CircEvent [SP Path]
          [SP "BUILD_FLAGS=" BuildFlags] [SP "PURPOSE=" Purpose]
          [SP "HS_STATE=" HSState] [SP "REND_QUERY=" HSAddress]
          [SP "TIME_CREATED=" TimeCreated]
          [SP "OLD_PURPOSE=" Purpose [SP "OLD_HS_STATE=" HSState]] CRLF

    CircEvent =
             "PURPOSE_CHANGED" / ; призначення ланцюжка або HS стан змінено
             "CANNIBALIZED"      ; ланцюжок канібалізовано

  Клієнт ЗОБОВ’ЯЗАНИЙ приймати події ланцюжка, що не перелічені раніше.

  Поле "OLD_PURPOSE" провадиться для обох подій, PURPOSE_CHANGED та
  CANNIBALIZED.  Поле "OLD_HS_STATE" провадиться коли провадиться поле "OLD_PURPOSE", та ціллю є зміна статусу прихованого сервісу.

  Інші поля вказані в розділі 4.1.1 вище.

  [Вперше з’явилось в 0.2.3.11-alpha]

4.1.20. Запущено підключуваний транспорт

  Синтаксис:

    "650" SP "TRANSPORT_LAUNCHED" SP Type SP Name SP TransportAddress SP Port
    Type = "server" | "client"
    Name = Ім’я підключуваного транспорту
    TransportAddress = IPv4 або IPv6 адреса, на якій підключуваний транспорт 
                       слухає для з’єднання
    Port = TCP порт, на якому очікується з’єднання.

    Підключуваний транспорт на ім’я 'Name' типу 'Type' було запущено вдало, та він слухає з’єднання на 'Address':'Port'.

4.1.21. Полоса пропускання, використана на OR або DIR або EXIT з’єднанні

  Синтаксис:
     "650" SP "CONN_BW" SP "ID=" ConnID SP "TYPE=" ConnType
              SP "READ=" BytesRead SP "WRITTEN=" BytesWritten CRLF

     ConnType = "OR" /  ; Переносячи трафік в мережі tor. Це може бути як 
                          на ш власний (клієнтській) трафік, або трафік, що ми ретранслювали в мережі.
                "DIR" / ; Отримуючи дані про дескриптори tor, або передаючи 
                          дескриптори, що ми зазеркалюємо.
                "EXIT"  ; Переносячи трафік між мережою tor та зовнішніми
                          пунктами призначення.

     BytesRead = 1*DIGIT
     BytesWritten = 1*DIGIT

  Контролери ЗОБОВ’ЯЗАНІ пропускати невідомі типи з’єднання.

  BytesWritten та BytesRead є числом байт, записаних та прочитаних Tor з часу останньої події CONN_BW на цьому з’єднанні.

  Ці події генеруються приблизно раз на секунду для кожного з’єднання; подіх не генеруються для з’єднань, що не були прочитані або записані. Ці події генеруються тільки якщо встановлено TestingTorNetwork.

  [Вперше з’явилось в 0.2.5.2-alpha]

4.1.22. Полоса пропускання, використана всіма потоками, приєднаними до ланцюжка

  Синтаксис:
     "650" SP "CIRC_BW" SP "ID=" CircuitID SP "READ=" BytesRead SP
              "WRITTEN=" BytesWritten CRLF
     BytesRead = 1*DIGIT
     BytesWritten = 1*DIGIT

  BytesRead та BytesWritten є числом байтів, прочитаних або записаних всіма застосуваннями з потоками, приєднаними до цього ланцюжка з асу останньої події CIRC_BW.

  Ці події генеруються приблизно раз на секунду для кожного ланцюжка; події не генеруються для ланцюжків, що не мають приєднаних потоків запису або читання.

  [Вперше з’явилось в 0.2.5.2-alpha]

4.1.23. По-ланцюжковий статус клитин

  Синтаксис:
     "650" SP "CELL_STATS"
              [ SP "ID=" CircuitID ]
              [ SP "InboundQueue=" QueueID SP "InboundConn=" ConnID ]
              [ SP "InboundAdded=" CellsByType ]
              [ SP "InboundRemoved=" CellsByType SP
                   "InboundTime=" MsecByType ]
              [ SP "OutboundQueue=" QueueID SP "OutboundConn=" ConnID ]
              [ SP "OutboundAdded=" CellsByType ]
              [ SP "OutboundRemoved=" CellsByType SP
                   "OutboundTime=" MsecByType ] CRLF
     CellsByType, MsecByType = CellType ":" 1*DIGIT
                               0*( "," CellType ":" 1*DIGIT )
     CellType = 1*( "a" - "z" / "0" - "9" / "_" )

  Приклади:
     650 CELL_STATS ID=14 OutboundQueue=19403 OutboundConn=15
         OutboundAdded=create_fast:1,relay_early:2
         OutboundRemoved=create_fast:1,relay_early:2
         OutboundTime=create_fast:0,relay_early:0
     650 CELL_STATS InboundQueue=19403 InboundConn=32
         InboundAdded=relay:1,created_fast:1
         InboundRemoved=relay:1,created_fast:1
         InboundTime=relay:0,created_fast:0
         OutboundQueue=6710 OutboundConn=18
         OutboundAdded=create:1,relay_early:1
         OutboundRemoved=create:1,relay_early:1
         OutboundTime=create:0,relay_early:0

  ID є локально унікальним ідентифікатором ланцюжка, який включається тільки в випадку, якщо ланцюжок походить з цього вузла.

  Входящий та виходящий посилається на напрям руху клітини по цепочці, що є до точки походження (inbound) або від походження (outbound).

  InboundQueue та OutboundQueue є ідентифікаторами входящої та виходящої черг ланцюжків для цього ланцюжка. Ці ідентифікатори унікальні тільки для цього OR з’єднання. OutboundQueue обирається цім вузлом, та співпадає з  InboundQueue наступного вузла в ланцюжку.

  InboundConn та OutboundConn є локально унікальними ID входящого та виходящого OR з’єднання. OutboundConn не обов’язково співпадає з   InboundConn наступного вузла в ланцюжку.

  InboundQueue та InboundConn не присутні, якщо ланцюжок походить на цьому вузлі. OutboundQueue та OutboundConn не присутні, якщо ланцюжок (на даний момент) закінчується науьому вузлі.

  InboundAdded та OutboundAdded є загальним числом клітин, по типу клітини, що додані до входящої та виходящої черги. Присутнє, тільки якщо хоча б одна клітина була додана в чергу.

  InboundRemoved та OutboundRemoved є загальним числом клітин, по типу клітин, що оброблені з входящої та виходящої черги. InboundTime та
  OutboundTime є загальний час очікування в мілісекундах всіх оброблених клітин по типам. Присутнє, тільки якщо хоча б одна клітина була видалена з черги.

  Ці події генеруються приблизно раз на секунду для кожного ланцюжка; події не генеруються для ланюєків, що не були додані, або оброблені, жодні клітини. Ці події генеруються тільки якщо встановлено TestingTorNetwork.

  [Вперше з’явилось в 0.2.5.2-alpha]

4.1.24. Пакунки токенів перезаповнені

  Синтаксис:
     "650" SP "TB_EMPTY" SP BucketName [ SP "ID=" ConnID ] SP
              "READ=" ReadBucketEmpty SP "WRITTEN=" WriteBucketEmpty SP
              "LAST=" LastRefill CRLF

     BucketName = "GLOBAL" / "RELAY" / "ORCONN"
     ReadBucketEmpty = 1*DIGIT
     WriteBucketEmpty = 1*DIGIT
     LastRefill = 1*DIGIT

  Приклади:
     650 TB_EMPTY ORCONN ID=16 READ=0 WRITTEN=0 LAST=100
     650 TB_EMPTY GLOBAL READ=93 WRITTEN=93 LAST=100
     650 TB_EMPTY RELAY READ=93 WRITTEN=93 LAST=100

  Ця подія генерується, коли перезаповнюються попередньо порожні пакунки токенів. Для BucketNames ключові слова"GLOBAL" та "RELAY" використовуються для глобальних або ретрансляторних пакунків токенів, BucketName "ORCONN" використовується для пакунків токенів OR з’єднання. Контролер Controllers ЗОБОВ’ЯЗАНИЙ пропускати нерозпізнані імена пакунків.

  ConnID включається тільки якщо BucketName є "ORCONN".

  Якщо обоє, глобальні та ретрансляторні пакунки та/або пакунки одного або быльше OR з’єднань витрачають токени одночасно, генерується декілька окремих подій.

  ReadBucketEmpty (WriteBucketEmpty) є часом в мілісекундах, що пакунок для читання (запису) був порожній з останнього перезаповнення. LastRefill є часом в мілісекундах після останнього перезаповнення.

  Якщо пакунок заходить в негативне, та якщо перезаповнення токенів не робить його знову позитивним, буде декілька послідовних подій TB_EMPTY для кожного інтервалу перезаповнення, на протяжку якого пакунок містив нуль токенів або менше. В такому випадку ReadBucketEmpty або WriteBucketEmpty фіксуються як LastRefill, щоб не доповідати пустий випадок більше ніж один раз.

  Ці подіі генеруються тільки якщо встановлено TestingTorNetwork.

  [Вперше з’явилось в 0.2.5.2-alpha]

4.1.25. Дескриптори HiddenService 

  Синтаксис:

    "650" SP "HS_DESC" SP Action SP HSAddress SP AuthType SP HsDir [SP DescriptorID]
    [SP "REASON=" Reason]

    Action =  "REQUESTED" / "RECEIVED" / "IGNORE" / "FAILED"
    HSAddress = 16*Base32Character
    AuthType = "NO_AUTH" / "BASIC_AUTH" / "STEALTH_AUTH" / "UNKNOWN"
    HsDir = LongName / Fingerprint
    DescriptorID = 32*Base32Character
    Reason = "BAD_DESC" / "QUERY_REJECTED" / "NOT_FOUND" / "UNEXPECTED"

    Ці події будуть спрацьовувати, коли дескриптор запрошеного HiddenService не найдений в кеші та застосовується отримання з мережі. Якщо ми вже маємо дескриптор v0, по новому отриманий дескриптор v2 буде ігноровано та подія "HS_DESC" з акцією "IGNORE" буде згенеровано.

    Для HsDir, LongName є завжди бажаним. Якщо HsDir не може бути знайдений в списку вузлів під час, коли подію було надіслано, замість буде використано Fingerprint.

    Якщо Action є "FAILED", Tor МАЄ надіслати також і поле Reason. Можливі значення для Reason:
       - "BAD_DESC" - дескриптор був отриманий, але був визнаний не підлягаючий розбору.
       - "QUERY_REJECTED" - запит був відхилений каталогом HS.
       - "NOT_FOUND" - дескриптор HS з даним ідентифікатором не було знайдено.
       - "UNEXPECTED" - природу збою не встановлено.

5. Нотатки реалізації

5.1. Аутентифікація

  Якщо порт керування відкрито, та нема операцій аутентифікації що дозволені, Tor довіряє любому локальному користувачеві, що підключається на порт керування. Це загалом слабка ідея.

  Якщо опція 'CookieAuthentication' є true, Tor записує файл "magic
  cookie" з іменем "control_auth_cookie" в свій каталог даних (або до іншого файлу, що вказано в опції 'CookieAuthFile'). Для аутентифікації контролер має демонструвати, що він може читати вміст файла cookie:

  * Поточна версії Tor підтримують аутентифікацію cookie з використанням  методу аутентифікації "COOKIE": контролер надсилає вміст файлу cookie, закодований в шеснадцятеричній формі. Цей метод аутентифікації викриває користувача що виконує контролер для атаки ненавмисного розкриття інформації, коли контролер має більший доступ по читанню до файлової системи, ніж процесс, до якого він підключений. (Зауважте, що конролер може під’єднуватися до процесів, інших ніж Tor). Це майже ніколи не є небезпечним для використання, навіть якщо користувачу було явно вказано, з якого файла читати аутентифійний cookie. За цієї причини метод аутентифікації COOKIE був відсторонений, та буде видалений з Tor перед якоюсь з наступних версій Tor.

  * Версії 0.2.2.x Tor, починаючи з 0.2.2.36, та всі версії Tor після 0.2.3.12-alpha, підтримують аутентифікацію cookie, з використанням методу аутентифікації "SAFECOOKIE", що розкриває набагато менше інформації про вміст файлу cookie.

  Якщо опція 'HashedControlPassword' встановлена, вона має містити започаткований сілью хеш секретного паролю. Започаткований хеш обчислюється згідно алгорітму S2K в RFC 2440 (OpenPGP), та має префікс з вказівкою на s2k. Після цього він закодований як шеснадцятиричне, якому передує індикаторна послідовність "16:". Таким чином, наприклад, пароль 'foo' повинен кодуватись як:
     16:660537E3E1CD49996044A3BF558097A981F539FEA2F9DA662B4626C1C2
        ++++++++++++++++**^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
           сіль                       хешоване значення
                    індикатор
  Ви можете згенерувати сіль паролю, викликаючи 
           'tor --hash-password <password>'
  або з використанням коду прикладу в бібліотеках контролерів на Python та Java. Для вутентифікації по цій схемі, контролер надсилає Tor оригінальний секрет, що був використаний для генерації паролю, або як квотований рядок, або закодований як шеснадцятирічне.

5.2. Не давайте буферу стати занадто великим.

  Якщо ви запитаєте багато подій, та 16MB з них стануть в чергу в буфері, процес Tor закриє сокет.

5.3. Зворотня сумісність за допомогою протокола керування v0.

  Протокол керування 'version 0' був заміщений в Tor 0.1.1.x. Підтримка була видалена в Tor 0.2.0.x. Кожна незастаріла версія Tor тепер підтримує версію 1 протоколу керування.

  Для зворотньої сумісності з протоколом керування "version 0", Tor використовує перевірку, чи третій октет першої команди є нуль. (Якщо так, Tor розуміє що використовується версія 0).

  Ця сумісність була видалена в Tor 0.1.2.16 та 0.2.0.4-alpha.

5.4. Опції конфігурації Tor для використання контролерами

  Tor провадить декілька спеціальних опцій конфігурації для використання контролерами. Ці опції можуть бути встановлені та перевірені через команди SETCONF та GETCONF, але не зберігаються на диску поSAVECONF.

  Загалом, ці опції роблять Tor некорисним, відключаючи частину нормальних операцій Tor. Якщо контролер не провадить заміщуючу функціональність для заповнення цього проміжку, Tor не буде вірно обробляти запроси користувачів.

  __AllDirActionsPrivate

    Якщо true, Tor буде намагатися запустити всі операції з каталогом через анонімні з’єднання. (Зазавичай Tor намагається анонімізувати тільки запроси до прихованих сервісів). Ця опція буде вповільняти доступ до каталогів, та може спричинити повне припинення роботи Tor, якщо він ще не має достатньо інформації каталогу, щоб збудувати ланцюжки.

    (Boolean. Default: "0".)

  __DisablePredictedCircuits

    Якщо true, Tor не буде запускати витісняючі ланцюжки "загального ужитку" для потоків, щоб приєднати їх. (Він буде як і завжди запускати ланцюжки для тестування та для прихованих сервісів).

    (Boolean. Default: "0".)

  __LeaveStreamsUnattached

    Якщо true, Tor не буде автоматично приєднувати нові потоки до ланцюжків;
    замість цього контролер має приєднати їх за допомогою ATTACHSTREAM. Якщо контролер не приєднує потоки, іх дані ніколи не будуть маршрутизовані.

    (Boolean. Default: "0".)

  __HashedControlSessionPassword

    Те ж, що і HashedControlPassword, але не зберігається в файлі torrc по SAVECONF. Додано в Tor 0.2.0.20-rc.

  __ReloadTorrcOnSIGHUP

    Якщо ця опція є true (по замовчанню), ми перезавантажуємо torrc з диску кожного разу, коли ми отримуємо SIGHUP (через контролер або через сигнал). В іншому випадку ми цього не робитимо. Ця опція існує, щоб контролери могли свої опції від того, щоб бути перезаписаними, коли користувач надсилає Tor сигнал HUP за іншими причинами (наприклад, щоб зробити ротацію журналів).

    (Boolean.  Default: "1")

  __OwningControllerProcess

    Якщо встановлена ца опція в ID процесу, Tor буде періодично перевіряти, чи не існує процесу з таким PID, та виходить, якщо його немає. Додано в Tor 0.2.2.28-beta. Заплановане використання цієї опції документовано в розділі 3.23 разом зі спорідненою командою TAKEOWNERSHIP.

    Зауважте, що ця опція може задавати тільки один ID процесу, на відміну від команди TAKEOWNERSHIP, що може бути надіслана разом з багатьма керуючими з’єднаннями.

    (String.  Default: unset.)

5.5. Фази від подій статусу розкручування.

  Цей розділ описує різноманітні фази розкручування, що наразі сповіщуються Tor. Контроллери не мають очікувати, що відсотки та теги, перелічені тут, будуть і надалі співпадать, або навіть те, що тегі будуть оставатись в тому ж порядку. Деякі фази можуть також бути пропущені (не сповіщені), якщо цей кроп розкручування вже завершено, або якщо ца фаза більше не є необхідною. Тільки "starting" та "done" гарантовано будуть присутні у всіх подальших версіях.

  Поточні версії Tor проходять ці фази по порядку, монотонно. Майбутні версії Tor МОЖУТЬ повертатись до ранніх стадій.
 [XXXX: чи ми повертаємось до ранніх стадій, якщо відказує мережа?]

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor буде будувати обоє, вихідні та внутрішні ланцюжки. Коли розкручування скінчиться, Tor буде готовий обробляти пристосування, що запитує вихідний ланцюжок до сервісів, таких як World Wide Web.

  Якщо консенсус не містить Exits, Tor буде будувати тільки внутрішні ланцюжки. В цьому випадку, ранішні статуси будуть включати "internal", як показано вище. Коли розкручування завершиться, Tor буде готовий обробляти пристосування, що запитує внутришній ланцюжок до прихованого сервісу за адресою ".onion".

  Якщо майбутній консенсус містить Exits, вихідні ланцюжки можуть бути доступними].

  Фаза 0:
  tag=starting summary="Starting"

  Tor розпочинає з цієї фази.

  Фаза 5:
  tag=conn_dir summary="Connecting to directory server"

  Tor надсилає цю подію як тільки Tor обирає сервер каталогу -- тобто один з довірених вузлів, якщо це розкручування в перший раз, або після довгої відсутності, або один з ретрансляторів, перелічених в інформації з кешованого каталога, в іншому разі. 
  
  Tor буде знаходитись на цій фазі, доки він не матиме встановленого TCP з’єднання з деяким сервером каталогу. Пробелми на цій фазі переважно трапляються, якщо Tor не має мережевого з’єднання, або якщо локальний фаєрволл відкидає SYN пакети.

  Фаза 10:
  tag=handshake_dir summary="Finishing handshake with directory server"

  Ця подія виникає, коли Tor встановлює TCP з’єднання з ретранслятором або довіреним вузлом, що використовується як сервер каталогу (або його https проксі, якщо ми використовуємо проксі). Tor зостається на цій фазі до тих пір, доки рукопотискання TLS з ретранслятором або довіреним вузлом не буде завершено.

  Проблеми на цій фазі в основному виникають завдяки фаерволл Tor робить більш витончені MITM атаки на нього, або робить розпізнавання ключових слів на рівні пакета рукопотискання Tor.

  Фаза 15:
  tag=onehop_create summary="Establishing an encrypted directory connection"

  Коли TLS закінчено з ретранслятором, Tor почне надсилати клітину CREATE_FAST для встановлення однострибкового ланцюжка для отримання інформації. Ми будено залишатися на цій фазі доти, доки не отримаємо клітину CREATED_FAST назад, що вказує, що ланцюжок готовий.

  Фаза 20:
  tag=requesting_status summary="Asking for networkstatus consensus"

  Коли ми закінчили наш однострибковий ланцюжок, ми запускаємо новий потік для отримання консенсусу статусу мережі. Ми будемо знаходитись в цій фазі доти, доки не отримаємо 'connected' клітину ретранслятора, що вказуватиме, що ми встановили з’єднання з каталогом.

  Фаза 25:
  tag=loading_status summary="Loading networkstatus consensus"

  Коли ми отримали з’єднання з каталогом, ми будемо починати отримання документу консенсусу мережевого статусу. Це може зайняти деякий час; ця фаза є гарною нагодою для використання ключового слова "progress" для інікації часткового прогресу.

  Це фаза може завмерти, якщо сервер каталогу, що ми обрали, не має копії консенсусу networkstatus, так що ми маємо запитати інший, або якщо він надасть нам копяю, але ми не визнаємо її як викликаючу довіру.

  Фаза 40:
  tag=loading_keys summary="Loading authority key certs"

  Часом, коли ми завершили завантаження консенсусу networkstatus, ми виявимо, що ми не маємо всіх довірених сертифікатів для ключів, що підписують консенсус. В цій точці ми відкладаємо консенсус, що завантажено, та отримуємо ключі, щоб таким чином перевіріти сігнатури.

  Фаза 45
  tag=requesting_descriptors summary="Asking for relay descriptors
                                      [ for internal paths]"

  Коли ми матимемо достовірний консенсус networkstatus і ми перевіримо всі його сигнатури, ми починаємо запитувати дескриптори ретрансляторів. Ми зостаємось в цій фазі до тих пір, доки ми не отримуємо 'connected' клітину ретранслятора у відповідь на запит по дескриптори.

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor буде запитувати дескриптори для обох, вихідних та внутрішніх шляхів. Якщо ні, Tor буде тульки запитувати дескриптори для внутрішніш шляхів. В цьому випадку статус буде включати "internal" як показано вище].

  Фаза 50:
  tag=loading_descriptors summary="Loading relay descriptors[ for internal
                                   paths]"

  Ми будемо запитувати дескриптори ретрансляторів для деякіх різних локацій, таким чином цей крок буде, вирогідно, складати основну частку розкрутки, особливо для користувачів з повільним з’єднанням. Ми зостаємось в цій фазі до тих пір, доки не матимемо досить дескрипторів для значної частки придатних для користування ретрансляторів, зі списку в консенсусі networkstatus (це може бути між 25% та 95%, в залежності від конфігурації Tor та параметрів мережевого консенсусу). Ця фаза також є гарною нагодою для використання ключового слова "progress" для індікації часткових кроків.

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor буде завантажувати дескриптори для обох, вихідних та внутрішніх шляхів. Якщо ні, Tor буде завантажувати дескриптори для внутрішніх шляхів. В цьому випадку цей статус включатиме "internal", як вказано вище].

  Фаза 80:
  tag=conn_or summary="Connecting to the Tor network[ internally]"

  Коли ми маємо викликаючий довіру консенсус та досить дескрипторів ретрансляторів, ми обираємо захисників входу та починаємо намагатись будувати деякі ланцюжки. Цей крок подібний до фази "conn_dir" вище; одна різниця в контекті.

  Якщо Tor починає з достатньо недавньої інформації в кешованій директорії, його першою подією статусу розкрутки буде для фази conn_or.

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor буде будувати обоє, вихідний та внутрішній ланцюжок. Якщо ні, Tor буде будувати тільки внітрішні ланцюжки. В цьому випадку цей статус буде включати "internal(ly)" як показано вище].

  Фаза 85:
  tag=handshake_or summary="Finishing handshake with first hop[ of internal
                            circuit]"

  Ця фаза подібна до фази "handshake_dir", але вона досягається, коли ми закінчили TCP з’єднання з Tor ретраслятором та вже досягли фази "conn_or". Ми будемо знаходитись в цій фазі, доки не завершимо рукопотискання TLS з ретранслятором Tor.

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor може завершити рукопотискання з першим стрибком, якщо це вихід або внутрішній ланцюжок. В цьому випадку він не буде вказувати який тип. Якщо консенсус не містить Exits, Tor буде тільки будувати внутрішні ланцюжки. В цьому випадку цей статус буде включати "internal", як вказано вище].

  Фаза 90:
  tag=circuit_create summary="Establishing a[n internal] Tor circuit"

  Як тільки ми завершили наше TLS рукопотискання з першим стрибком ланцюжка, ми готові щоб намагатися зробити деякі три-стрибкові ланцюжки, в разі, коли вони нам скоро знадобляться. 
  
 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо консенсус містить Exits (типовий випадок), Tor буде будувати обидва, вихідний та внутрішній ланцюжок. Якщо ні, Tor буде тільки будувати внутрішні ланцюжки. В цьому випадку цей статус буде включати "internal", як вказано вище].

  Фаза 100:
  tag=done summary="Done"

  Повний 3-стрибковий ланцюжок було встановлено. Тепер Tor готовий обробляти з’єднання застосувань.

 [Новіші версії Tor (0.2.6.2-alpha та пізніші):
  Якщо сонсенсус містить Exits (типовий випадок), Tor буде будувати обоє, вихідні та внутрішні ланцюжки. На цьому стадії Tor буде готовий для обробки застосувань, що запитують вихідні ланцюжки для отримання сервісів, як World Wide Web.

  Якщо консенсус не містить Exits, Tor буде будувати тільки внутрішні ланцюжки. В цьому випадку ранішні статуси будуть мати включеним "internal", як вказувалося раніше. На цій стадії Tor буде готовий для обробки застосувань, що запитують внутрішні ланцюжки до прихованих сервісів за ".onion" адресами.

  Якщо майбутній консенсус містить Exits, можуть бути доступними вихідні ланцюжки].
