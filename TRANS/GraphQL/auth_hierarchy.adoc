:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

= Иерархия прав доступа

Недостатки представления прав доступа в виде произвольного графа без единого корневогоо элемента:

* Возможность циклических ссылок. Сами циклические ссылки не являются невозможной ситуацией и иногда необходимы. Но их наличие предполагает политики их обработки в виде наложения глубины отсечения, рекрсивного парсинга и т.п. Таким образом эффективные права будут не вполне описаны графом, а также зависеть от реализации обработчика. Чем можно воспользоваться.

* Возможность двойного наследования. Само двойное наследование не есть окончательное зло, но является источником повышенной сложности и постоянных ошибок. В контексте безопасности это возможность неаккуратного наследования роли, которая подтянет за собой нежелательные права. 

* Сиротки ака Orphants. Отсутствие единого корневого элемента позволяет создавать отдельно стоящие сегменты. Это, часто нежелательное, состояние в распределенных вычислениях называется разделением (partitioning). В ООП не принадлежащие к иерархии классы называются микс-инами или трейтами. Не смотря на некоторый "сервис" это довольно порочная практика. Например, рассмотрим существующие права в виде произвольного графа. Три роли, а именно `Editor`, `Moderator`, `ScreeningViewer` не принадлежат к дереву, и, таким образом, являются микс-инами. Кроме того что два первых используются всего один раз для создания роли `EditorialMember`, такая схема позволяет создать пользователя `Editor`, который даже не будет являться `RegisteredUser`. Все опять решается на уровне политики, заложенной в коде - но схема может и должна противостоять даже соблазну подобных ошибок.  

* Форвардинг привелегий. Технически ничто не мешает устраивать "ралли привелегий", когда одни привелегии подразумевают (автоматически включают) другие. Это также является вызовом для администратора, особенно в условиях, когда тысячи привелегий могут создавать тысячи триггеров. Просчитать последствия изменений не представляется возможным. Особенно тяжелый случай, когда отзывается первичный стимул, и автоматически отзываются вторичные. По этой причине право выполнения или записи файла не подменяет право на чтение. По аналогии строятся и таблицы ACL в известных распределенных кластерах. Форвардинг привелегий признан плохой практикой по умолчанию. 

== Вот как можно организовать схему авторизации доступа в виде дерева

[source,js]
----
{
  Guest: {
    may: ['viewAlbums','viewComments','viewPhoto'],
    children: [
      InactiveUser: {
        may: ['manageOwnProfile'],
        children: []
      },
      RegisteredUser: {
        may: ['createAlbum', 'manageAlbum', 'manageOwnProfile', 'postComment', 'uploadPhoto'],
        children: [
          EditorialMember: {
            may: ['editDBData', 'editPhotoData', 'processCommentQueue', 
              'viewCommentQueue', 'viewRejectedComments'],
            children: [
              CensorViewer: {
                may: ['viewCensorQueue'],
                children: [
                  Censor: {
                    may: ['processCensorQueue'],
                    children: [
                      Administrator: {
                        may: ['manageUsers'], 
                        children: []
                      }
                    ]
                  }
                ]
              },
              ScreeningViewer: {
                may: ['viewRejectedPhoto', 'viewScreeningQueue'],
                children: [
                  Screener: {
                    may: ['processScreeningQueue'], 
                    children: []
                  }
                ]
              },
            ]
          }
        ]
      }
    ],
  }
}
----