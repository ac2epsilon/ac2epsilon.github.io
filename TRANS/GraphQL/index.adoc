:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

= GraphQL 101 ~by ac2~
Язык запросов:

[width="96%",cols="<l,<2"]
|====
|
# тип и имя операции
query HeroNameAndFriends
# переменная со значением по умолчанию
      ($episode: Episode  = JEDI, 
# обязательная переменная
        $withFriends: Boolean!) {
# поле с аргументом
  hero($episode: Episode) {
# поле с псевдонимом
    hero_name: name
# поле-массив и директива, включающая блок
    friends @include(if: $withFriends) {
      name
# поле с аргументом формата
      height(unit: FOOT)
    }
  }
}

|
*Тип операции*: `query`, `mutation`, `subsription`. `query` можно не указывать, но тогда нельзя присвоить имя, а имена мы по договоренности всегда присваиваем. 

*Имя операции*: осмысленный идентификатор. Имя можно не указывать, но по договоренности его лучше всегда указывать - для отладки и ссылок в документации.

*Список полей*: список скалярных или обьектных полей. Обьектньые поля содержат свои поля, и так далее. 

*Тип поля*: тип поля определяется в схеме. Если вложенное поле определено в схеме как массив - будет возвращаться массив. 

*Псевдонимы*: иногда в одном запросе нужно получить то же самое поле дважды. Другой случай - когда вы хотите дать полю более выразительное имя. Для этого перед именем можно указать `псевдоним:` - новое имя и две точки.

*Аргументы*: запросы можно параметризировать с помощью `(аргументов)` после имени поля. Любое поле может содержать аргументы для выборки или форматирования. 

*Переменные*: аргументы, кроме констант, могут принимать переменные. Имена переменных начинаюся с символа `$`. Переменные могут иметь значение по умолчанию. Переменные также служат документированию параметров запроса. Вы никогда не должны конструировать запросы с помощью интерполяции строк.Восклицательный знак в типе переменной указывает, что данный аргумент обязательный.

*Директивы*: для условного включения части запроса можно использовать директивы `@include(if: Boolean)` и `@skip(if: Boolean)`. Реализации могут добавлять свои директивы. 

*Пакетное выполнение*: одно обращение может содержать несколько запросов. Именно поэтому в ответном пакете нужен промежуточный контейнер `data`. В противном случае был бы риск получить невалидный JSON.

*Комментарии*: строка после `#` является комментарием.
|
# определение фрагмента
fragment fragAppears on Character {
  appearsIn
}
# использование фрагмента
...fragAppears

query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
# мета данные
    `__typename`
# инлайн фрагменты на основе типа контейнера
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}
|
*Фрагменты*: сложные запросы можно упростить, вынеся части запроса во фрагменты. Эти фрагменты можно использовать повторно. Фрагменты имеют доступ к переменым запроса.

*Инлайн фрагменты*: если запрашиваемое поле возвращает интерфейс или юнион, для анализа результата придется использовать инлайн фрагменты, как показано в примере.  Аналогично можно использовать именованные фрагменты, поскольку они всегда имеют тип.

*Мета данные*: в ситуации, когда клиент должен знать тип данных, когда он не определен, вы можете использовать мета поле `__typename`. Оно возвращает объектный тип в данной точке запроса.

|# мутация по соглашению должна иметь имя
mutation CreateReviewForEpisode

# на вход поступают скаляры или объекты
      ($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {

# мутация также возвразает новые данные
    stars
    commentary
  }
}
| *Мутации*: позволяют модифицировать данные на сервере. Входные данные мутации могут быть как скалярами, так и объектами. Мутации возвращают поля только что модифицированных данных.

*Очередность мутаций*: как и запросы, мутации могут выполняться в пакетном режиме. Важное отличие: мутации никогда не выполняются параллельно, только последовательно. Это исключает состояние гонки.  Запросы всегда пытаются выполняться параллельно.
 
|====