:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== 2.3 Застосування

Об'єкт застосування енкапсулює контекст виконання, в якому виконується запит. Головне завдання є зібрати деяку базову інформацію щодо запиту, та перестати її в відповідний контролер для подальшої обробки. Він також служить як центральне місце для утримання налаштувань конфігурації рівня застосування. З цієї причини об'єкт застосування також називають `front-controller`.

Об'єкт застосування створюється як синглтон вхідним скриптом. Застосування-синглтон доступний в кожній точці коду через `Yii::app()`.

=== 2.3.1 Конфігурація застосування

По замовчанню об'єкт застосування є примірником `CWebApplication`. Щоб налаштувати його, ми зазвичай провадимо файл налаштувань (або масив), щоб ініціалізувати значеннями його властивості під час створення. Альтернативним шляхом налаштування є розщирення `CWebApplication`.

Конфігурація є масивом пар ключ-значення. Кожний ключ представляє ім'я властивості примірника застосування, та кожне значення є початкове значення відповідної властивості. Наприклад, настуий масив конфігурації встановлює властивості застосування `name` та `defaultController`.

[source,php]
----
array(
  ’name’=>’Yii Framework’,
  ’defaultController’=>’site’,
)
----

Зауважте, що застосування є компонентом, як майже всі класи Yii. Це означає дві речі:

* Ви не можете встановлювати довільні властивості, як зі звичайними PHP об'єктами. Властивість має бути визначена в класі застосування.

* Застосування підтримує сеттери для визначення властивості, так що ви можете, наприклад, встановити властивість, визначену методом `setImport`, наступним чином:

[source,php]
----
array(
  ’import’=>array(
    ’application.components.*’,
  ),
)
----

Звичайно ми зберігаємо конфігурацію в окремому скрипті PHP (`protected/config/main.php`). В скрипті ми повертаємо масив конфігурації наступним чином:

[source,php]
----
  return array(...);
----

Щоб застосувати конфігурацію, ми передаємо ім'я файла конфігурації, як параметр до конструктора застосування, або до `Yii::createWebApplication()`, в наступний спосіб, зазвичай у вхідному скрипті:

[source,php]
----
$app=Yii::createWebApplication($configFile);
----

*Підказка:* якщо конфігурація дуже складна, ми можемо поділити її на декілька файлів, де кожний повертає частину масиву конфігурації. Потім, в головному файлі конфігурації, ми можемо викликати PHP `include()` для вставки решти файлів конфігурації, та поєднання їх в повний масив конфігурації.

=== 2.3.2 Базова директорія застосування

Базова директорія є кореневою директорією, під якою знаходяться всі чутливі скрипти та дані PHP. По замовчанню це суб-директорія на ім'я `protected`, що знаходиться під директорією, що містить вхідний скрипт. Це можна налаштувати, встановивши влативість `basePath` в конфігурації налаштування.

Вміст базової директорії застосування має бути захищене від доступу з боку web користувачів. Для HTTP сервера `Apache` це можна легко зробити, поклавши файл `.htaccess` в цю директорію. Вміст цього файла має бути наступним:

[source,php]
----
deny from all
----
=== Компоненти застосування

Функціональність об'єкту застосування може бути легко налаштована та підсилена, використовуючи його компонентну архитектуру. Об'єкт керує набором компонент, кожен з яких реалізує певну можливість. Наприклад, він виконує деяку початкову обробку користувацького запиту за допомогою компонент `CUrlManager` та `CHttpRequest`.

Конфігуруючи властивість `components` примірника застосування ми можемо налаштувати клас та значення властивостей, які використовує кожний компонент застосування. Наприклад, ми можемо сконфігурувати компонент `CMemCache`, так щоб він міг використовувати для кешування декілька memcache серверів, таким чином:

[source,php]
----
array(
  ...
  ’components’=>array(
    ...
    ’cache’=>array(
      ’class’=>’CMemCache’,
      ’servers’=>array(
        array(’host’=>’server1’, ’port’=>11211, ’weight’=>60),
        array(’host’=>’server2’, ’port’=>11211, ’weight’=>40),
      ),
    ),
  ),
)
----

Тут ми додаємо елемент `cache` до масиву `components`. Елемент `cache` стверджує, що клас компонента є `CMemCache`, та його властивість `servers` повинна бути ініціалізована певним чином.

Для отримання доступу до компоненту застосування використовуйте `Yii::app()->ComponentID`, де `ComponentID` посилається на `ID` компонента (тобто, `Yii::app()->cache`).

Компонент застосування може бути відключений встановленням `enabled` в `false` в його конфігурації. Коли ми отримуємо доступ до відключеного компоненту, повертається `Null`.

*Підказка:* по замовчанню компоненти створюються на вимогу. Це означає, що компонент застосування може бути взагалі не створений, якщо до нього нема доступу на протязі запиту користувача. Як результат, загальна продуктивність може не деградувати, навіть якщо застосування зконфігуроване з багатьма компонентами. Деякі компоненти застосування (як `CLogRouter`) мають бути зконфігуровані незалежно від того, чи отримують вони доступ. Щоб зробити це, перелічіть їх `ID` у властивості застосування `preload`.

=== 2.3.4 Основні компоненти застосування

Yii передвизначає набір основних компонент застосування, що провадять можливості, загальні для web застосувань. Наприклад, компонент `request` використовується для збирання інформації про запит користувача, і провадить інформацію, таку як запитаний `URL` та кукі. Конфігуруючи властивості ціх ключових компонент, ми можемо змінити поведінку по замовчанню майже кожного аспекту Yii.

Ось список компонент, що передвизначені для `CWebApplication`:

* `assertManager:CAssertManager` - керує публікацією приватних файлів ассетів.
* `authManager:CAuthManager` - керує роле-базованим контролем доступу (RBAC).
* `cache:CCache` - провадить функціональність кешування даних. Зауважте, що ви маєте вказати справжній клас (як `CMemCache, CDbCache`). Інакше при доступі до цього компонента буде повертатись `null`.
* `clientScript:CClientScript` - керує клієнтськими скриптами (javascript та CSS).
* `coreMessages:CPhpMessageSource` - провадить переклади головних повідомлень, що використовуються фреймворком Yii.
* `db:CDbConnection` - провадить з'єднання з базою даних. Зауважте, що ви маєте зконфігурувати його властивість `connectionString`, щоб використовувати цей компонент.
* `errorHandler:CErrorHandler` - обробляє неперехоплені помилки та виключення PHP.
* `format:CFormatter` - форматує значення даних для відображення.
* `messages:CPhpMessageSource` - провадить перекладені повідомлення, що використовуються в Yii застосуванні.
* `request:CHttpRequest` - провадить інформацію щодо користувацького запиту. 
* `securityManager:CSecurityManager` - провадить безпеко-пов'язані сервіси, такі як хешування та шифрування.
* `session:CHttpSession` - провадить сессія-пов'язану функціональність. 
* `statePersister:CStatePersister` - провадить механізм для збереження глобального стану. 
* `urlManager:CUrlManager` - провадить функціонал для парсингу та створення URL.
* `user:CWebUser` - несе пов'язану з ідентичністю інформацію щодо поточного користувача.
* `themeManager:CThemeManager` - керує схемами.

=== 2.3.5 Життєвий цикл застосування

Коли обробляється запит користувача, застосування проходитиме наступний життєвий цикл:

1. Попередня ініціалізація застосування в `CApplication::preinit`;
2. Встановлення обробки помилок;
3. Реєстрація головних компонент застосування;
4. Завантаження конфігурації застосування;
5. Ініціалізація застосування за допомогою `CApplication:init()`
  * Реєстрація поведінок застосування;
  * Завантаження статичних компонент застосування;
6. Підіймання події `onBeginRequest`;
7. Обробка користувацького запиту:
  * Збір інформації щодо запиту;
  * Створення контролеру;
  * Виконання контролеру;
8. Підіймання події `onEndRequest`;

== 2.4 Контролер

`controler` є примірником `CController`, або класу, що розширює `CController`. Він створюється об'єктом застосування, коли користувач запитує його. Коли контролер виконується, він виконує запитувану дію, що зазвичай отримує потрібні моделі, та рендерить відповідне вью. Дія `action`, в простішій формі, є просто методом класу контролера, чиє ім'я починається з `action`.

Контролер має дію по замовчанню. Коли запит користувача не вказує, яку дію треба виконати, буде виконана дія по замовчанню. По замовчанню, дія по замовчанню має ім'я `index`. Це може бути змінено через налаштування публічної змінної примірника, `CController::defaultAction`.

Наступний код визначає контролер `site`, дію `index` (дія по замовчанню), та дію `contact`:

[source,php]
----
class SiteController extends CController 
{
  public function actionIndex() {
    //...
  }
  public function actionContact() {
    //...
  }
}
----

=== 2.4.1 Роути

Контролери та дії ідентифікуються по ID. ID контролера має формат `path/to/xyz`, що відповідає файлу класу контролера `protected/controllers/path/to/XyzController.php`. ID дії є ім'я методу дії без префіксу `action`. Наприклад, якщо клас контролера містить метод `actioinEdit`, ID відповідної дії буде `edit`.

Користувачі запитують певний контролер та дію в термінах роутів. Роут формується конкатенацією ID контролера та ID дії, роздідені косою. Наприклад, роут `post/edit` посилається на `PostController` та дію `edit`. По замовчанню URL `http://hostname/index.php?r=post/edit` буде запитувати контролер `post` та дію `edit`.

*Зауваження:* По замовчанню роути чутливі до реєстру. Можливо зробити їх нечутливими, встановивши `CUrlManager::caseSensitive` в `false` в конфігурації застосування. В режимі нечутливості до реєстра переконайтесь, що ви слідуєте домовленості, за якої директорії, які містять файли класу контролера, є в нижньому реєстрі, та обоє, мапа контролера та мапа дій обоє мають ключі в нижньому реєстрі.

Застосування може містити модулі. Роут для дії контролера в модулі має формат `moduleID/controllerID/actionID`. Для додаткових подробиць дивіть розділ про модулі. 

=== 2.4.2 Створення примірника контролера

Примірник контролера створюється, коли `CWebApplication` обробляє прийдешній запит. Маючи ID контролера, застосування буде використовувати наступні правила для визначення, який буде клас контролера, та де розташовано файл класу.

* Якщо вказаний `CWebApplication::catchAllRequest`, контролер буде створений базуючись на цій властивості, і наданий користувачем ID контролера буде проігнорований. Це в основному використовується для перемикання застосування в режим обслуговування, та відображення статичної сторінки повідомлення.

* Якщо ID знайдений в `CWebApplication::controllerMap`, для ствоерння примірника контролера буде використана відповідна конфігурація контролера.

* Якщо ID в форматі `path/to/xyz`, ім'я класу контролера вважається `XyzController`, та відповідний файл класу є `protected/controllers/path/to/XyzController.php`. Наприклад, ID контролера `admin/user` буде відображено на клас контролера `UserController`, та файл класу `protected/controllers/admin/UserController.php`. Якщо клас не знайдено, буде закинуте `CHttpException` 404.

Коли використовуються модулі, цей процес трохи інший. Зокрема, застосування буде превіряти, чи ID посилається на контролер в модулі, і якщо це так, спочатку буде створено примірник модуля, за яким буде створено примірник контролера. 

=== 2.4.3 Дії

Як вже зазначалось, дія може бути визначена як метод, чиє ім'я починається зі слова `action`. Більш просунута техніка є визначення класу дії, та запит до контролера створити примірник за потреби. Це дозволяє повторно використовувати події, і, таким чином, додати реюзабіліті.

Для визначення нового класу події зробіть наступне:

[source,php]
----
class UpdateAction extends CAction 
{
  public function run() 
  {
    // action logic
  }
}
----

Щоб контролер знав про цю дію, ми перекриваємо метод `actions()` нашого класу контролера:

[source,php]
----
class PostController extends CController 
{
  public function actions() 
  {
    return array(
      'edit'=>'application.controllers.post.UpdateAction',
    );
  }
}
----

Вище ми використовуємо псевдоним шляху `application.controllers.post.UpdateAction`. щоб вказати, що файл класу дії є `protected/controllers/post/UpdateAction.php`.

Створюючи базовані на класах дії ми можемо організувати застосування в модульний спосіб. Наприклад, наступна структура директорій може бути використана для організації коду для контролерів:

[source,bash]
----
protected/
  controllers/
    PostController.php
    UserController.php
    post/
      CreateAction.php
      ReadAction.php
      UpdateAction.php
    user/
      CreateAction.php
      ListAction.php
      ProfileAction.php
      UpdateAction.php
----

==== Біндінг параметрів дії

З версії 1.1.4 Yii додає підтримку автоматичного біндінгу (прикреплення) парамерів дій. Тобто, метод дії контролера може визначати іменовані параметри, чиї значення будуть автоматично заповнюватись Yii з `$_GET`.

Щоб проілюструвати, як це робить, давайте уявимо, що нам треба написати дію `create` для `PostController`. Дія потребує два параметри:

* `category`: ціле, що вказує ID категорії, під якою буде створено новий пост;

* `lannguage`: рядок, що вказує код мови, на якій буде новий пост.

Ми можемо створити такій нудний код для цієї цілі, що отримує потрібні значення параметрів з `$_GET`:

[source,php]
----
class PostController extends CController 
{
  public function actionCreate() 
  {
    if(isset($ GET[’category’]))
      $category=(int)$ GET[’category’];
    else
      throw new CHttpException(404,’invalid request’);

    if(isset($ GET[’language’]))
      $language=$ GET[’language’];
    else
      $language=’en’;

    // ... code
  }
}
----

Тепер, використовуючи можливість параметрів дії, ми можемо досягти цієї цілі більш приємно:

[source,php]
----
class PostController extends CController
{
  public function actionCreate($category, $language=’en’)
  {
    $category=(int)$category;
    // ... code
  }
}
----

Зверніть увагу, як ми додаємо два параметри до методу дії `actionCreate`. Імена ціх параметрів мають бути точно такі сами, які ми очікуємо від `$_GET`. Параметр `$language` приймає значення по замовчанню `en`, в випадку, коли запит не містить такого параметру. Оскільки `$category` не має значення по замовчанню, якщо запит не включає параметра `category`, автоматично буде закинуте `CHttpException` (код помилки 400).

Починаючи з версії 1.1.5 Yii також підтримує розпізнання типу массиву для параметрів дії. Це робиться через підказки типів PHP з використанням наступного синтаксису:

[source,php]
----
class PostController extends CController
{
  public function actionCreate(array $categories)
  {
    // Yii переконається, що $categories є массивом
  }
}
----

Тобто, ми дадаємо ключове слово `array` перед `$categories` в декларації параметра метода. Коли ми робимо це, якщо `$_GET['categories']` є простий рядок, він буде перетворений на масив, що складається з одного рядка.

*Зауваження:* якщо параметр декларовано без підказки типу `array`, це означає, що він має бути скаларом (тобто, не масивом). В цьому випадку передача параметру-массиву через `$_GET` спричинить виключення HTTP.

Починаючи з версії 1.1.7 автоматичне прикріплення параметрів також робить для базованих на класах дій. Якщо метод `run()` класу дії визначений з деякими параметрами, вони будуть заповнені відповідними іменованими параметрами запиту. Наприклад: 

[source,php]
----
class UpdateAction extends CAction
{
  public function run($id)
    {
    // $id отримає значення від $_GET[’id’]
    }
}
----

=== 2.4.4 Фільтри

Фільтр є частиною коду, що зконфігурований для виконання перед та/або після виконання дії контролера. Наприклад, фільтр контроля доступу може бути виконаний, щоб переконатись, що користувач аутентифікаваний перед виконанням запитаної дії; фільтр профілювання може бути використаний для виміру часу, протягом якого виконується дія.

Дія може мати декілька фільтрів. Фільтри виконуються в тому порядку, в якому вони трапляються в списку фільтрів. Фільтр може запобігти виконанню дії і решти невиконаних фільтрів. 

Фільтр може бути визначений як метод класу контролера. Ім'я метода має починатись з `filter`. Наприклад, метод на ім'я `filterAccessControl` визначає фільтр на ім'я `accessControl`. Метод фільтру повинен мати вірну сигнатуру:

[source,php]
----
public function filterAccessControl($filterChain)
{
// викличте $filterChain->run() для продовження виконання фільтрів та дії
}
----

Тут `$filterChain` є примірником `CFilterChain`, що представляє список фільтрів, асоційований з запитаною дією. В методі фільтра ми можемо викликати `$filterChain->run()` для продовження виконання фільтрів та дії.

Фільтр також може бути примірником `CFilter`, або дочірнього класу. Наступний код визначає новий клас фільтру:

[source,php]
----
class PerformanceFilter extends CFilter
{
  protected function preFilter($filterChain)
  {
    // логіка для застосування до виконання дії
    return true; // false для переривання виконання дії
  }

  protected function postFilter($filterChain)
  {
    // логіка для застосування після виконання дії
  }
}  
----

Щоб застосувати фільтри до дій, нам треба перекрити метод `CController::filters()`. Метод має повертати масив конфігурацій фільтрів. Наприклад:

[source,php]
----
class PostController extends CController
{
  ...
  public function filters()
  {
    return array(
      ’postOnly + edit, create’,
      array(
        ’application.filters.PerformanceFilter - edit, create’,
        ’unit’=>’second’,
      ),
    );
  }
}
----

Цей код визначає два фільтри: `postOnly` та `PerformanceFilter`. Фільтр `postOnly` базований на методі (відповідний метод фільтру вже визначений в `CControler`); тоді як фільтр `PerformanceFilter` базований на об'єкті. Псевдоним шляху `application.filters.PerformanceFilter` вказує, що файл фільтра є `protected/filters/PerformanceFilter.php`. Ми використовуємо масив для конфігурації `PerformanceFilter`, так що він може бути використаний для ініціалізації значень властивостей об'єкту фільтра. Тут є властивість `unit` для `PerformanceFilter`, що буде ініціалізований як `second`.

Використовуючи оператори плюс та мінус ми можемо задати, до яких дій фільтр має бути або не має бути застосований. Вище фільтр `postOnly` буде застосований до дій `edit` та `create`, коли фільтр `PerformanceFilter` буде застосований до всіх дій, КРІМ `edit` та `create`. Якщо в конфігурації фільтру не трапляється ні плюса, ані мінуса, фільтр буде застосовано до всіх дій.

== 2.5 Модель

Модель є примірником `CModel`, або класу, що розширює `CModel`. Моделі використовуються щоб утримувати дані та їх відповідні бізнес правила.

Модель представляє окремий об'єкт даних. Це може бути рядок в таблиці бази даних, або html форму з вхідними даними користувача. Кожне поле об'єкта даних представлене атрибутом моделі. Атрибут має мітку, і може бути валідований згідно набору правил.

Yii реалізує два різновиди моделей: моделі форм та ектив записи. Вони обоє розширюють той самий базовий клас, `CModel`.

Модель форми є примірником `CFormModel`. Моделі форм використовуються для зберігання даних, зібранних зі входу. Такі дані часто збираються, використовуються, та потім відкидаються. Наприклад, на формі логіну ми можемо використати модель форми для представлення інформації щодо імені та пароля користувача, наданих користувачем. Для додаткової інформації звертайтесь до розділу Робота з формами.

Active Record (AR) є шаблоном розробки для абстрактного доступу до бази даних в об'єктно-орієнтовному стилі. Кожний AR об'єкт є примірником `CActiveRecord`, або субкласом цього класу, представляючи окремий рядок в таблиці бази даних. Поля в рядку представлені як властивості AR об'єкта. Деталі щодо AR можна знайти в Active Record.

Для кращої практики по визначенню ваших моделей перевірте Best MVC Practices, розділ Model.

== 2.6 Вью

Вью є PHP скрипт, що здебільшого складається з елементів користувацького інтерфейсу. Він може містити PHP твердження, але рекомендовано, щоб ці твердження не змінювали моделі даних, та були відносно простими. В дусі розділення логіки від презентації, великі шматки логіки повинні розташовуватись в контролерах або моделях, скоріше ніж у вью.

Вью має ім'я, що використовується для ідентифікації файла скрипта вью під час малювання. Ім'я вью є те саме, що і ім'я його скрипта. Наприклад, ім'я вью `edit` послається на скрипт вью `edit.php`. Щоб відобразити вью викличте `CControler:render()` з ім'ям вью. Метод буде шукати відповідний файл вью в директорії `protected/views/ControllerID`.

У вью скрипті ми можемо отримати доступ до примірника контролера з використанням `$this`. Так що ми можемо `pull` любу властивість контролера через обчислення `$this->propertyName` всередині вью.

Також ми можемо використовувати наступний `push` підхід для передачі даних у вью:

[source,php]
----
$this->render(’edit’, array(
  ’var1’=>$value1,
  ’var2’=>$value2,
));
----

Вище метод `render()` буде виділяти значення з другого параметру в змінні. Як результат в скрипті вью ми зможемо отримати доступ до змінних `$var1` та `$var2`.

=== 2.6.1 Лейаути

Лейаут э особливим вью, що використовуються для декорування вью. Він звичайно містить частини користувацького інтерфейсу, що є загальними для декількох вью. Наприклад, лейаут може містити хедер та футер, та вставити вью посередині, таким чином:

[source,php]
----
......хедер......
<?php echo $content; ?>
......футер......
----

де `$content` зберігає результат рендерінгу вью.

Лейаут неявно застосовується коли викликається `render()`. По замовчанню в якості лейаута використовується вью `protected/views/layouts/main.php`. Це можна налаштувати або змінівши `CWebApplication::layout` або `CController::layout`. Щоб відрендерити вью без застосування жодного лейаута використовуйте `renderPartial()`.

=== 2.6.2 Віджет

Віджет є примірником `CWidget`, або дочірнім класом `CWidget`. Це компонент, що служить здебільшого цілям презентації. Віджет зазвичай вбудовується у вью скрипт для генерації складного, але самодостатнього користувацького інтерфейсу. Наприклад, віджет календаря може бути використаний для рендерінга складного користувацького інтерфейсу календаря. Віджети спрощують кращу реюзабіліті в коді користувацького інтерфейсу.

Щоб використати віджет зробіть наступне в вью скрипті:

[source,php]
----
<?php $this->beginWidget(’path.to.WidgetClass’); ?>
...тіло вмісту, що може бути захоплений віджетом...
<?php $this->endWidget(); ?>
----

або

[source,php]
----
<?php $this->widget(’path.to.WidgetClass’); ?>
----

Останнє використовується, коли віджет не потребує жодного тіла вмісту.

Віджети можуть бути зконфігуровані для налаштування їх поведінки. Це робиться через встановлення їх початкових значень властивостей, викликаючи `CBaseController::beginWidget` або `CBaseController::widget`. Наприклад, коли використовується віджет `CMaskedTextField`, нам може знадобитись задати маску для використання. Ми можемо зробити це, передавши масив початкових значень властивостей, як показано нижче, де ключі масиву є іменами властивостей, та масив значень є значеннями ініціалізації відповідних властивостей віджету:

[source,php]
----
<?php
$this->widget(’CMaskedTextField’,array(
  ’mask’=>’99/99/9999’
));
?>
----

Щоб визначити новий віджет, розширьте `CWidget`, та перекрийте його методи `init()` та `run()`.

[source,php]
----
class MyWidget extends CWidget
{
  public function init()
  {
    // викликається CController::beginWidget()
  }
  public function run()
  {
    // викликається CController::endWidget()
  }
}
----

Подібно до контролера, віджет також може мати свій власний вью. По замовчанню файли вью віджета розташовані в субдиректорії `views` директорії, де розташований файл класу віджета. Ці вью можуть рендеритись через виклик `CWidget::render()`, подібно тому, як це робиться в контролері. Одна різниця полягає в тому, що при цьому не буде застосовано лейаут. Також `$this` у вью буде посилатись на примірник віджету, замість примірника контролера.

*Підказка:* `CWidgetFactory::widgets` може бути використаний для конфігурації віджетів на рівні сайту, дозволяючи значно простіше базове конфігурування. Ви можете знайти деталі в розділі про теми.

=== 2.6.3 Системні вью

Системні вью посилаються на вью, що використовуються Yii для відображення помилок та журнальної інформації. Наприклад, коли користувач запитує неіснуючий контролер або дію, Yii буде закидати виключення з поясненням помилки. Yii відображує виключення, використовуючи спеціальне системне вью.

Іменування системних вью слідує деяким правилам. Імена як `errorXXX` посилаються на вью для відображення `CHttpException` з кодом помилки `XXX`. Наприклад, якщо `CHttpException` підійнято з кодом помилки 404, буде відображено вью `error404`.

Yii провадить набір системних вью по замовчанню, розташованих в `framework/vievs`. Вони можуть бути налаштовані, якщо створити так само названі файли вью в `protected/views/system`.

== 2.7 Компонент

