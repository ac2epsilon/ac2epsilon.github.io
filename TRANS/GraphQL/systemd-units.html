<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p><a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">Оригінал</a></p></div>
<div class="sect1">
<h2 id="__systemd_unit___">Розуміння systemd unit та юніт файлів</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>Все більше дистрибутиви Linux адаптують, або планують адаптувати, систему ініціалізації <code>systemd</code>. Ця потужна програмна сюїта може керувати багатьма аспектами вашого сервера, від сервісів до монтованих пристроїв та системних станів.</p></div>
<div class="paragraph"><p>В <code>systemd</code> юніт посилається на любий ресурс, про який система знає, як з ним поводитись та керувати. Це первинний об'єкт, з яким має справу <code>systemd</code>. Ці ресурси визначаються з використанням файлів конфігурації, що мають назву юніт файлів.</p></div>
<div class="paragraph"><p>В цій настанові ми представимо різні юніти, які може обробляти <code>systemd</code>. Ми також розглянемо деякі з багатьох директив, що можуть бути використані в юніт файлах, щоб окреслити спосіб, як ці ресури обробляються в вашій системі.</p></div>
</div>
<div class="sect2">
<h3 id="_____systemd">Що вам дають юніти Systemd?</h3>
<div class="paragraph"><p>Юніти є об'єктами, якими вміє керувати <code>systemd</code>. Це загалом стандартизоване представлення системних ресурсів, що можуть керуватись сюїтою демонів і маніпульовані наданими утілітами.</p></div>
<div class="paragraph"><p>Юніти деяким чином подібні до сервісів або завдань в інших <code>init</code> системах. Однак юніт має значно ширше визначення, тому що вони можуть використовуватись для абстрактних сервісів, мережевих ресурсів, пристроїв, монтованих файлових систем, та ізольованих ресурсних пулів.</p></div>
<div class="paragraph"><p>Ідеї, що можуть бути представлені в інших <code>init</code> системах уніфікованими визначеннями сервісів, можуть бути розбиті на юніт компоненти, відповідно до їх фокусування. Це організує за функцією і дозволяє легко вмикати, вимикати, або розширювати функціональність без модифікації базової поведінки юніта.</p></div>
<div class="paragraph"><p>Ось деякі можливості, які можна легко реалізувати за допомогою юнітів:</p></div>
<div class="paragraph"><p><strong>*активація від сокетів</strong>: Сокети, асоційовані з сревісом, поділяються самим демоном, щоб оброблятись окремо. Це надає декілька переваг, таких, як відкладання запуску сервісу до першого доступу до сервісу. Це також дозволяє системі створювати всі сокети раніше, в процесі завантаження, що дозволяє паралельно завантажувати асоційовані сервіси.</p></div>
<div class="paragraph"><p><strong>*активація від шини</strong>: Юніти також можуть бути активовані на шинному інтерфейсі, що провадить D-Bus. Юніт може бути запущено, коли публікується асоційована шина.</p></div>
<div class="paragraph"><p><strong>*активація за шляхом</strong>: Юніт може бути запущений за активністю або доступністю за певними шляхами файлової системи. Це використовує <code>inotify</code>.</p></div>
<div class="paragraph"><p><strong>*активація за пристроєм</strong>: Юніти також можуть бути запущені за першої доступності асоційованого пристрою через використання подій udev.</p></div>
<div class="paragraph"><p><strong>*неявний меппінг залежностей</strong>: Більшість дерева залежностей для юнітів може бути побудоване самим <code>systemd</code>. Але ви також можете додати інформацію щодо залежностей та впорядкування, але більшість важкої роботи вже виконані за вас.</p></div>
<div class="paragraph"><p><strong>*примірники та шаблони</strong>: Шаблонні файли юнітів використовуються для створення декількох примірників того самого загального юніту.</p></div>
<div class="paragraph"><p><strong>*просте підсилення безпеки</strong>: Юніти можуть реалізувати деякі досить гарні можливості безпеки через додавання простих директив. Наприклад, ви можете вказати відсутність доступу до частини файлової системи, або тільки на читання, обмежити можливості ядра та присвоїти приватний <code>/tmp</code> та доступ до мережі.</p></div>
<div class="paragraph"><p><strong>*дроп-іни та сніпети</strong>: Юніти легко можуть бути розширені додаванням сніпетів, що перекривають частини системного юніт файла. Це спрощує перехід від штатної до власної реалізації юніта.</p></div>
<div class="paragraph"><p>Є багато інших переваг юнітів <code>systemd</code> над елементами інших систем ініціалізації, але це має надати вам ідею тієї потужності, яку можна досягти, залучивши природні директиви конфігурації.</p></div>
</div>
<div class="sect2">
<h3 id="____">Де розташовані файли юнітів</h3>
<div class="paragraph"><p>Файли, що визначають, як <code>systemd</code> буде обробляти юніт, можуть розташовуватись в багатьох різних місцях, кожне з яких має різні преоритети та наслідки.</p></div>
<div class="paragraph"><p>Системна копія файлів загалом знаходяться в системній директорії <code>/lib/systemd/system</code>. Коли програма встановлює файли юнітів в системі, це місце, де вони розташовуються по замовчанню.</p></div>
<div class="paragraph"><p>Файли юнітів, що зберігаються тут, здатні запускатись і зупинятись на вимогу протягом сессії. Це буде загальний, штатний юніт файл, часто написаний службою підтримки проекта, і має робити на любій системі, що має <code>systemd</code> в своїй стандартній реалізації. Вам не треба редагувати файли в цій директорії. Замість цього ви маєте за потреби перекрити файл іншим юніт файлом в іншій локації, що перекриє цей файл.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте модифікувати спосіб, в який функціонує юніт, кращою локацією зробити це є директорія <code>/etc/systemd/system</code>. Файли юнітів в цій директорії мають перевагу над всіма іншими розташуваннями файлової системи. Якщо вам треба модифікувати системну копію юніт файла, покласти заміну в цей каталог є найбезпечнішим і найбільш гнучким шляхом зробити це.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте перекрити лише певні директиви системного юніт файла, ви насправді можете використати сніпети юніт файла в субдиректорії. Вони будуть доповнювати або модифікувати директиви в системній копії, дозволяючи вам вказувати тільки опції, які ви бажаєте змінити.</p></div>
<div class="paragraph"><p>Коректний спосіб зробити це є створити директорію з назвою юніт файла, з доданим <code>.d</code> в кінці. Так що для юніта на ім'я <code>example.service</code> має бути створена субдиректорія  <code>example.service.d</code>. В цій директорії можна використати файл <code>.conf</code> для перекриття або розширення атрибутів системного юніт файла.</p></div>
<div class="paragraph"><p>Також існує локація для рантайм визначень юнітів в <code>/run/systemd/system</code>. Юніт файли в цій директорії мають преоритет між файлами <code>/etc/systemd/system</code> та <code>/lib/systemd/system</code>. Файли з цім розташуванням менш вагомі ніж такі в першому місці, і більш вагомі ніж в останньому.</p></div>
<div class="paragraph"><p>Сам процес <code>systemd</code> використовує це розташування для динамічно створених юніт файлів під час виконання. Ця директорія може бути використана для зміни поведінки системного юніта на протязі сессії. Всі зміни в цій директорії будуть втрачені при перезавантаженні сервера.</p></div>
</div>
<div class="sect2">
<h3 id="__">Типи юнітів</h3>
<div class="paragraph"><p><code>Systemd</code> поділяє юніти відповідно до типу ресурса, який вони описують. Простіший спосіб визначити тип юніта є вказати суфікс типу, що додається в кінці імені ресурса. Наступний список описує типи юнітів, доступні в <code>systemd</code>:</p></div>
<div class="paragraph"><p><strong>.service</strong>: Юніт сервісу описує, як керувати сервісом або застосуванням на сервері. Це включає спосіб запуску та припинення сервісу, за яких умов він має бути автоматично запущений, та інформація про залежності та впорядкування для пов'язаних програм.</p></div>
<div class="paragraph"><p><strong>.socket</strong>: Юніт сокета описує мережу або сокет IPC, або FIFO буфер, які <code>systemd</code> використовує для сокет активації. Вони завжди мають асоційований файл <code>.service</code>, який буде запущено, коли на визначеному сокеті буде помічена активність.</p></div>
<div class="paragraph"><p><strong>.device</strong>: Юніт, що описує пристрій, визначений як той, що потребує керування <code>systemd</code> через <code>udev</code> або файловою системою <code>sysfs</code>. Не всі пристрої матимуть файли <code>.device</code>. Деякі сценарії, коли може знадобитись юніт <code>.device</code>, є впорядкування, монтування та доступ до пристроїв.</p></div>
<div class="paragraph"><p><strong>.mount</strong>: Цей юніт визачає точку монтування, що має керуватись <code>systemd</code>. Вони мають назви по шляхам монтування, з косими заміненими на мінуси. Елементи в <code>/etc/fstab</code> можуть мати юніти, створені автоматично.</p></div>
<div class="paragraph"><p><strong><code>.automount</code></strong>: Юніт <code>.automount</code> конфігурує точу монтування, що буде змонтована автоматично. Вони мають називатись як точки монтування, на які вони посилаються, і мати співпадаючий юніт <code>.mount</code> для визначення особливостей монтування.</p></div>
<div class="paragraph"><p><strong>.swap</strong>: Цей юніт описує простір свопа в системі. Ім'я ціх юнітів повинно відображувати пристрій або шлях до сховища.</p></div>
<div class="paragraph"><p><strong>.target</strong>: Таргетний юніт використовується для провадження точок синхронізації для інших юнітів при завантаженні або зміни стану. Вони також можуть використовуватись для приведення системи до нового стану. Інші юніти вказують своє відношення до таргетів, щоб прив'язатись до таргетних операцій.</p></div>
<div class="paragraph"><p><strong>.path</strong>: Цей юніт визначає шлях, який може використовуватись для активації за шляхом. По замовчанню буде запущений <code>.service</code> з тим самим базовим ім'ям, коли шлях набуде вказаного стану. Це використовує <code>inotify</code> для моніторінга шляху.</p></div>
<div class="paragraph"><p><strong>.timer</strong>: Юніт визначає таймер, що буде керуватись <code>systemd</code>, подібно до <code>cron</code> для відкладених та запланованих завдань. Співпадаючий юніт буде запущений, коли спрацює таймер.</p></div>
<div class="paragraph"><p><strong>.snapshot</strong>: Юніт <code>.snapshot</code> створюється автоматично командою <code>systemctl snapshot</code>. Це дозволяє вам відновити поточний стан після внесення змін. Снепшоти не зберігаються між сессіями, і використовуються для відкату тимчасових змін.</p></div>
<div class="paragraph"><p><strong>.slice</strong>: Юніт <code>.slice</code> асоційований з вузлами Linux Control Group, дозволяючи обмеження або надання ресурсів до любих процессів, асоційованих зі слайсами. Ім'я відображує ієрархічну позицію в дереві <code>cgroup</code>. Юніти покладаються в певні слайси по замовчанню, в залежності від їх типу.</p></div>
<div class="paragraph"><p><strong>.scope</strong>: Скоуп юніти створюються автоматично <code>systemd</code> з інформації, отриманої з шинних інтерфейсів. Вони використовуються для керування наборами системних процессів, що створені ззовні.</p></div>
<div class="paragraph"><p>Як ви можете бачити, є багато різних юнітів, про які знає <code>systemd</code>. Багато з типів юнітів роблять разом для додавання функціональності. Наприклад деякі юніти використовуються для перемикання інших юнітів, і провадять функціональність активації.</p></div>
<div class="paragraph"><p>Ми в основному сфокусуємось на юнітах <code>.service</code> через їх користь і узгодженість, з якою адміністратори мають керувати ціма юнітами.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___">Анатомія юніт файла</h2>
<div class="sectionbody">
<div class="paragraph"><p>Внутрішня структура юніт файлів організована як секції. Секції позначаються парами прямокутних дужок “[” та “]”, що оточують ім'я секції. Кожна секція подовжується до початку нової секції, або до кінця файлу.</p></div>
<div class="sect2">
<h3 id="_____2">Загальні характеристики юніт файлів</h3>
<div class="paragraph"><p>Назви секцій гарно визначені і враховують реєстр. Так що секція <code>[Unit]</code> не буде сприйматись коректно, якщо буде записане як <code>[UNIT]</code>. Якщо вам треба додати нестандартні розділи, що розбираються деінде крім <code>systemd</code>, ви можете додати префікс <code>X-</code> до назви секції.</p></div>
<div class="paragraph"><p>В ціх секціях метадані та поведінка юніта визначаються через використання простих директив в форматі ключ-значення, зі знаком рівності в якості ознаки присвоєння, таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В випадку перекриття файлів (що розташовані в директорії <code>unit.type.d</code>), директиви можуть бути скинуті через присвоєння до них порожнього рядка. Наприклад, системна копія юніт файлу може містити таку директиву:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>default_value</code> може бути виключена в файлі перекриття, посилаючись на <code>Directive1</code> без значення:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Загалом, <code>systemd</code> дозволяє просту та гнучку конфігурацію. Наприклад, сприймаються декілька булевих виразів (<code>1</code>, <code>yes</code>, <code>on</code>, <code>true</code> для ствердження, та <code>0</code>, <code>no</code>, <code>off</code>, <code>false</code> для зворотнього). Час може бути інтелігентно розібраний, де значення без одиниць позначають секунди, та декілька форматів підтримуються природно.</p></div>
</div>
<div class="sect2">
<h3 id="___unit">Директиви секції [Unit]</h3>
<div class="paragraph"><p>Перша секція, що трапляється в більшості юніт файлів, є секція <code>[Unit]</code>. Вона в основному використовується для визначення метаданих для юніта, та конфігурації відношень юніта з іншими юнітами.</p></div>
<div class="paragraph"><p>Хоча порядок секцій не має значення для <code>systemd</code> при розборі файлу, цей розділ часто розташовується зверху, оскільки він провадить огляд юніту. Деякі загальні директиви, що ви можете побачити в секції <code>[Unit]</code>:</p></div>
<div class="paragraph"><p><strong>*Description=</strong>: Ця директива може бути використана для опису імені та базової функціональності юніта. Вона повертається різними інструментами <code>systemd</code>, так що гарно встановити її в дещо стисле, специфічне та інформативне.</p></div>
<div class="paragraph"><p><strong>*Documentation=</strong>: Ця директива провадить розташування списку URI для документації. Це може бути вбудованими man сторінками, або доступні веб URL. Команда <code>systemctl status</code> буде показувати цю інформацію, дозволяючи просте дослідження.</p></div>
<div class="paragraph"><p><strong>*Requires=</strong>: Ця директива перелічує любі юніти, від яких конче залежить цей юніт. Якщо поточний юніт активується, перелічені тут юніти також мають успішно активізуватись, інакше цей юніт схибить. По замовчанню ці юніти стартують паралельно з поточним юнітом.</p></div>
<div class="paragraph"><p><strong>*Wants=</strong>: Ця директива подібна до <code>Requires=</code>, але менш сувора. <code>Systemd</code> буде намагатись запустити любі юніти, перелічені тут, при активації цього юніта. Якщо ці юніти не знайдені або не можуть стартувати, поточний юніт буде продовжувати роботу. Це рекомендований спосіб зконфігурувати більшість відношень залежності. Знову, це передбачає паралельну активацію, якщо не модифіковано іншими директивами.</p></div>
<div class="paragraph"><p><strong>*BindsTo=</strong>: Ця директива подібна до <code>Requires=</code>, але також спричиняє зупинення поточного юніта,якщо припиняється асоційований юніт.</p></div>
<div class="paragraph"><p><strong>*Before=</strong>: Юніти, перераховані в цій директиві, не будуть запущені, доки поточний юніт не буде відмічений як запущений, якщо вони активовані одночасно. Це не передбачає відносин залежності, і має використовуватись в поєднанні з одною з попередніх директив, якщо це бажано.</p></div>
<div class="paragraph"><p><strong>*After=</strong>: Юніти, перелічені і цій директиві, будуть запущені перед запуском поточного юніта. Це не передбачає відносин залежності, і має використовуватись в поєднанні з одною з попередніх директив, якщо це бажано.</p></div>
<div class="paragraph"><p><strong>*Conflicts=</strong>: Це можна використати для переліку юнітів, що не можуть використовуватись одночасно з поточним юнтом. Запуск юніта з такою залежністю спричинить зупинку іншого юніта.</p></div>
<div class="paragraph"><p><strong>*Condition&#8230;=</strong>: Це декілька директив, що починаються з <code>Condition</code>, що дозволяють адміністратору перевіряти певні кондиції перед запуском юніта. Це може бути використано для запровадження узагальненого юніт файла, що буде виконуватись тільки на відповідних системах. Якщо кондиція не справдилась юніт буде безпечно пропущений.</p></div>
<div class="paragraph"><p><strong>*Assert&#8230;=</strong>: Подібно до директив, що починаються з  <code>Condition</code>, ці директиви первіряють різні аспекти оточення виконання, щоб прийняти рішення, чи слід активувати юніт. Однак, на відміну від директив <code>Condition</code>, негативний результат спричиняє збій цієї директиви.</p></div>
<div class="paragraph"><p>Використовуючи ці та декілька інших директив, можна встановити відносини між юнітом та іншими юнітами  та операційною систнмою.</p></div>
</div>
<div class="sect2">
<h3 id="___install">Директиви секції [Install]</h3>
<div class="paragraph"><p>На протилежній стороні файла останньою секцією часто є секція <code>[Install]</code>. Ця секція опціональна, та використовується для визначення поведінки юніта коли він буде ввімкнений або вимкнений. Ввімкнення юніта відмічає його для автоматичного запуску при запуску. В основі це досягається зчепленням розгляданого юніта з іншим юнітом, що знаходиться десь в черзі юнітів, які запускаються при завантаженні.</p></div>
<div class="paragraph"><p>Через це тільки юніти, які можуть бути ввімкнені, будуть мати цей розділ. Директиви всередині диктують, що має відбуватись, коли юніт ввімкнений:</p></div>
<div class="paragraph"><p><strong>*WantedBy=</strong>: Директива <code>WantedBy</code> є найбільш загальним шляхом вказати, як треба вмикати юніт. Ця директива дозволяє вам задати відношення залежності, в спосіб подібний до директиви <code>Wants</code> в секції <code>[Unit]</code>. Різниця в тому, що ця директива включена в залежний юніт, що залишає первинний юніт відносно чиистим. Коли юніт з цією директивою вімкнено, в <code>/etc/systemd/system</code> буде створена директорія за назвою юніта та <code>.wants</code> в кінці. В ній буде створено символічне посилання на поточний юніт, що створиь залежність. Наприклад, якщо поточний юніт має <code>WantedBy=multi-user.target</code>, буде створена директорія <code>multi-user.target.wants</code> в <code>/etc/systemd/system</code> (якщо її ще не існує), і в неї буде покладено посилання на поточний юніт. Відключення юніта видалить посилання і відносини залежності разом з ним.</p></div>
<div class="paragraph"><p><strong>*RequiredBy=</strong>: Ця директива дуже подібна до директиви <code>WantedBy</code>, але замість вказує потрібну залежність, що, коли не справдиться, призведе до збою активації. Коли вімкнений, юніт з цією директивою створюватиме директорію, що матиме в кінці <code>.requires</code>.</p></div>
<div class="paragraph"><p><strong>*Alias=</strong>: Ця директива дозволяє юніту бути також вімкненим під іншим ім'ям. Між іншими застосуваннями це дозволяє існування декількох провайдерів функції, так що пов'язані юніти можуть шукати любого провайдера по загальному імені.</p></div>
<div class="paragraph"><p><strong>*Also=</strong>: Ця директива дозволяє юнітам вмикатись або відмикатися як набір. Тут можливо перелічити юніти підтримки, що повинні завжди бути під рукою, коли запущений наш юніт.</p></div>
<div class="paragraph"><p><strong>*DefaultInstance=</strong>: For template units (covered later) which can produce unit instances with unpredictable names, this can be used as a fallback value for the name if an appropriate name is not provided.</p></div>
</div>
<div class="sect2">
<h3 id="_unit_specific_section_directives">Unit-Specific Section Directives</h3>
<div class="paragraph"><p>Sandwiched between the previous two sections, you will likely find unit type-specific sections. Most unit types offer directives that only apply to their specific type. These are available within sections named after their type. We will cover those briefly here.</p></div>
<div class="paragraph"><p>The device, target, snapshot, and scope unit types have no unit-specific directives, and thus have no associated sections for their type.</p></div>
<div class="paragraph"><p>The [Service] Section
The [Service] section is used to provide configuration that is only applicable for services.</p></div>
<div class="paragraph"><p>One of the basic things that should be specified within the [Service] section is the Type= of the service. This categorizes services by their process and daemonizing behavior. This is important because it tells systemd how to correctly manage the servie and find out its state.</p></div>
<div class="paragraph"><p>The Type= directive can be one of the following:</p></div>
<div class="paragraph"><p>simple: The main process of the service is specified in the start line. This is the default if the Type= and Busname= directives are not set, but the ExecStart= is set. Any communication should be handled outside of the unit through a second unit of the appropriate type (like through a .socket unit if this unit must communicate using sockets).
forking: This service type is used when the service forks a child process, exiting the parent process almost immediately. This tells systemd that the process is still running even though the parent exited.
oneshot: This type indicates that the process will be short-lived and that systemd should wait for the process to exit before continuing on with other units. This is the default Type= and ExecStart= are not set. It is used for one-off tasks.
dbus: This indicates that unit will take a name on the D-Bus bus. When this happens, systemd will continue to process the next unit.
notify: This indicates that the service will issue a notification when it has finished starting up. The systemd process will wait for this to happen before proceeding to other units.
idle: This indicates that the service will not be run until all jobs are dispatched.
Some additional directives may be needed when using certain service types. For instance:</p></div>
<div class="paragraph"><p>RemainAfterExit=: Ця директива is commonly used with the oneshot type. It indicates that the service should be considered active even after the process exits.
PIDFile=: If the service type is marked as “forking”, Ця директива is used to set the path of the file that should contain the process ID number of the main child that should be monitored.
BusName=: Ця директива should be set to the D-Bus bus name that the service will attempt to acquire when using the “dbus” service type.
NotifyAccess=: This specifies access to the socket that should be used to listen for notifications when the “notify” service type is selected This can be “none”, “main”, or “all. The default, "none”, ignores all status messages. The “main” option will listen to messages from the main process and the “all” option will cause all members of the service’s control group to be processed.
So far, we have discussed some pre-requisite information, but we haven’t actually defined how to manage our services. The directives to do this are:</p></div>
<div class="paragraph"><p>ExecStart=: This specifies the full path and the arguments of the command to be executed to start the process. This may only be specified once (except for “oneshot” services). If the path to the command is preceded by a dash “-” character, non-zero exit statuses will be accepted without marking the unit activation as failed.
ExecStartPre=: This can be used to provide additional commands that should be executed before the main process is started. This can be used multiple times. Again, commands must specify a full path and they can be preceded by “-” to indicate that the failure of the command will be tolerated.
ExecStartPost=: This has the same exact qualities as ExecStartPre= except that it specifies commands that will be run after the main process is started.
ExecReload=: This optional directive indicates the command necessary to reload the configuration of the service if available.
ExecStop=: This indicates the command needed to stop the service. If this is not given, the process will be killed immediately when the service is stopped.
ExecStopPost=: This can be used to specify commands to execute following the stop command.
RestartSec=: If automatically restarting the service is enabled, this specifies the amount of time to wait before attempting to restart the service.
Restart=: This indicates the circumstances under which systemd will attempt to automatically restart the service. This can be set to values like “always”, “on-success”, “on-failure”, “on-abnormal”, “on-abort”, or “on-watchdog”. These will trigger a restart according to the way that the service was stopped.
TimeoutSec=: This configures the amount of time that systemd will wait when stopping or stopping the service before marking it as failed or forcefully killing it. You can set separate timeouts with TimeoutStartSec= and TimeoutStopSec= as well.
The [Socket] Section
Socket units are very common in systemd configurations because many services implement socket-based activation to provide better parallelization and flexibility. Each socket unit must have a matching service unit that will be activated when the socket receives activity.</p></div>
<div class="paragraph"><p>By breaking socket control outside of the service itself, sockets can be initialized early and the associated services can often be started in parallel. By default, the socket name will attempt to start the service of the same name upon receiving a connection. When the service is initialized, the socket will be passed to it, allowing it to begin processing any buffered requests.</p></div>
<div class="paragraph"><p>To specify the actual socket, these directives are common:</p></div>
<div class="paragraph"><p>ListenStream=: This defines an address for a stream socket which supports sequential, reliable communication. Services that use TCP should use this socket type.
ListenDatagram=: This defines an address for a datagram socket which supports fast, unreliable communication packets. Services that use UDP should set this socket type.
ListenSequentialPacket=: This defines an address for sequential, reliable communication with max length datagrams that preserves message boundaries. This is found most often for Unix sockets.
ListenFIFO: Along with the other listening types, you can also specify a FIFO buffer instead of a socket.
There are more types of listening directives, but the ones above are the most common.</p></div>
<div class="paragraph"><p>Other characteristics of the sockets can be controlled through additional directives:</p></div>
<div class="paragraph"><p>Accept=: This determines whether an additional instance of the service will be started for each connection. If set to false (the default), one instance will handle all connections.
SocketUser=: With a Unix socket, specifies the owner of the socket. This will be the root user if left unset.
SocketGroup=: With a Unix socket, specifies the group owner of the socket. This will be the root group if neither this or the above are set. If only the SocketUser= is set, systemd will try to find a matching group.
SocketMode=: For Unix sockets or FIFO buffers, this sets the permissions on the created entity.
Service=: If the service name does not match the .socket name, the service can be specified with Ця директива.
The [Mount] Section
Mount units allow for mount point management from within systemd. Mount points are named after the directory that they control, with a translation algorithm applied.</p></div>
<div class="paragraph"><p>For example, the leading slash is removed, all other slashes are translated into dashes “-”, and all dashes and unprintable characters are replaced with C-style escape codes. The result of this translation is used as the mount unit name. Mount units will have an implicit dependency on other mounts above it in the hierarchy.</p></div>
<div class="paragraph"><p>Mount units are often translated directly from <code>/etc/fstab</code> files during the boot process. For the unit definitions automatically created and those that you wish to define in a unit file, the following directives are useful:</p></div>
<div class="paragraph"><p>What=: The absolute path to the resource that needs to be mounted.
Where=: The absolute path of the mount point where the resource should be mounted. This should be the same as the unit file name, except using conventional filesystem notation.
Type=: The filesystem type of the mount.
Options=: Any mount options that need to be applied. This is a comma-separated list.
SloppyOptions=: A boolean that determines whether the mount will fail if there is an unrecognized mount option.
DirectoryMode=: If parent directories need to be created for the mount point, this determines the permission mode of these directories.
TimeoutSec=: Configures the amount of time the system will wait until the mount operation is marked as failed.
The [Automount] Section
This unit allows an associated <code>.mount</code> для визначення особливостей монтування As with the .mount unit, these units must be named after the translated mount point’s path.</p></div>
<div class="paragraph"><p>The [Automount] section is pretty simple, with only the following two options allowed:</p></div>
<div class="paragraph"><p>Where=: The absolute path of the automount point on the filesystem. This will match the filename except that it uses conventional path notation instead of the translation.
DirectoryMode=: If the automount point or any parent directories need to be created, this will determine the permissions settings of those path components.
The [Swap] Section
Swap units are used to configure swap space on the system. The units must be named after the swap file or the swap device, using the same filesystem translation that was discussed above.</p></div>
<div class="paragraph"><p>Like the mount options, the swap units can be automatically created from /etc/fstab entries, or can be configured through a dedicated unit file.</p></div>
<div class="paragraph"><p>The [Swap] section of a unit file can contain the following directives for configuration:</p></div>
<div class="paragraph"><p>What=: The absolute path to the location of the swap space, whether this is a file or a device.
Priority=: This takes an integer that indicates the priority of the swap being configured.
Options=: Any options that are typically set in the /etc/fstab file can be set with Ця директива instead. A comma-separated list is used.
TimeoutSec=: The amount of time that systemd waits for the swap to be activated before marking the operation as a failure.
The [Path] Section
A path unit defines a filesystem path that systmed can monitor for changes. Another unit must exist that will be be activated when certain activity is detected at the path location. Path activity is determined thorugh inotify events.</p></div>
<div class="paragraph"><p>The [Path] section of a unit file can contain the following directives:</p></div>
<div class="paragraph"><p>PathExists=: Ця директива is used to check whether the path in question exists. If it does, the associated unit is activated.
PathExistsGlob=: This is the same as the above, but supports file glob expressions for determining path existence.
PathChanged=: This watches the path location for changes. The associated unit is activated if a change is detected when the watched file is closed.
PathModified=: This watches for changes like the above directive, but it activates on file writes as well as when the file is closed.
DirectoryNotEmpty=: Ця директива allows systemd to activate the associated unit when the directory is no longer empty.
Unit=: This specifies the unit to activate when the path conditions specified above are met. If this is omitted, systemd will look for a <code>.service</code> file that shares the same base unit name as this unit.
MakeDirectory=: This determines if systemd will create the directory structure of the path in question prior to watching.
DirectoryMode=: If the above is enabled, this will set the permission mode of any path components that must be created.
The [Timer] Section
Timer units are used to schedule tasks to operate at a specific time or after a certain delay. This unit type replaces or supplements some of the functionality of the cron and at daemons. An associated unit must be provided which will be activated when the timer is reached.</p></div>
<div class="paragraph"><p>The [Timer] section of a unit file can contain some of the following directives:</p></div>
<div class="paragraph"><p>OnActiveSec=: Ця директива allows the associated unit to be activated relative to the .timer unit’s activation.
OnBootSec=: Ця директива is used to specify the amount of time after the system is booted when the associated unit should be activated.
OnStartupSec=: Ця директива is similar to the above timer, but in relation to when the systemd process itself was started.
OnUnitActiveSec=: This sets a timer according to when the associated unit was last activated.
OnUnitInactiveSec=: This sets the timer in relation to when the associated unit was last marked as inactive.
OnCalendar=: This allows you to activate the associated unit by specifying an absolute instead of relative to an event.
AccuracySec=: This unit is used to set the level of accuracy with which the timer should be adhered to. By default, the associated unit will be activated within one minute of the timer being reached. The value of Ця директива will determine the upper bounds on the window in which systemd schedules the activation to occur.
Unit=: Ця директива is used to specify the unit that should be activated when the timer elapses. If unset, systemd will look for a .service unit with a name that matches this unit.
Persistent=: If this is set, systemd will trigger the associated unit when the timer becomes active if it would have been triggered during the period in which the timer was inactive.
WakeSystem=: Setting Ця директива allows you to wake a system from suspend if the timer is reached when in that state.
The [Slice] Section
The [Slice] section of a unit file actually does not have any <code>.slice</code> асоційований з вузлами Instead, it can contain some resource management directives that are actually available to a number of the units listed above.</p></div>
<div class="paragraph"><p>Some common directives in the [Slice] section, which may also be used in other units can be found in the systemd.resource-control man page. These are valid in the following unit-specific sections:</p></div>
<div class="paragraph"><p>Creating Instance Units from Template Unit Files
We mentioned earlier in this guide the idea of template unit files being used to create multiple instances of units. In this section, we can go over this concept in more detail.</p></div>
<div class="paragraph"><p>Template unit files are, in most ways, no different than regular unit files. However, these provide flexibility in configuring units by allowing certain parts of the file to utilize dynamic information that will be available at runtime.</p></div>
<div class="paragraph"><p>Template and Instance Unit Names
Template unit files can be identified because they contain an @ symbol after the base unit name and before the unit type suffix. A template unit file name may look like this:</p></div>
<div class="paragraph"><p><a href="mailto:example@.service">example@.service</a>
When an instance is created from a template, an instance identifier is placed between the @ symbol and the period signifying the start of the unit type. For example, the above template unit file could be used to create an instance unit that looks like this:</p></div>
<div class="paragraph"><p><a href="mailto:example@instance1.service">example@instance1.service</a>
An instance file is usually created as a symbolic link to the template file, with the link name including the instance identifier. In this way, multiple links with unique identifiers can point back to a single template file. When managing an instance unit, systemd will look for a file with the exact instance name you specify on the command line to use. If it cannot find one, it will look for an associated template file.</p></div>
<div class="paragraph"><p>Template Specifiers
The power of template unit files is mainly seen through its ability to dynamically substitute appropriate information within the unit definition according to the operating environment. This is done by setting the directives in the template file as normal, but replacing certain values or parts of values with variable specifiers.</p></div>
<div class="paragraph"><p>The following are some of the more common specifiers will be replaced when an instance unit is interpreted with the relevant information:</p></div>
<div class="paragraph"><p>%n: Anywhere where this appears in a template file, the full resulting unit name will be inserted.
%N: This is the same as the above, but any escaping, such as those present in file path patterns, will be reversed.
%p: This references the unit name prefix. This is the portion of the unit name that comes before the @ symbol.
%P: This is the same as above, but with any escaping reversed.
%i: This references the instance name, which is the identifier following the @ in the instance unit. This is one of the most commonly used specifiers because it will be guaranteed to be dynamic. The use of this identifier encourages the use of configuration significant identifiers. For example, the port that the service will be run at can be used as the instance identifier and the template can use this specifier to set up the port specification.
%I: This specifier is the same as the above, but with any escaping reversed.
%f: This will be replaced with the unescaped instance name or the prefix name, prepended with a /.
%c: This will indicate the control group of the unit, with the standard parent hierarchy of /sys/fs/cgroup/ssytemd/ removed.
%u: The name of the user configured to run the unit.
%U: The same as above, but as a numeric UID instead of name.
%H: The host name of the system that is running the unit.
%%: This is used to insert a literal percentage sign.
By using the above identifiers in a template file, systemd will fill in the correct values when interpreting the template to create an instance unit.</p></div>
<div class="paragraph"><p>Conclusion
When working with systemd, understanding units and unit files can make administration simple. Unlike many other init systems, you do not have to know a scripting language to interpret the init files used to boot services or the system. The unit files use a fairly simple declarative syntax that allows you to see at a glance the purpose and effects of a unit upon activation.</p></div>
<div class="paragraph"><p>Breaking functionality such as activation logic into separate units not only allows the internal systemd processes to optimize parallel initialization, it also keeps the configuration rather simple and allows you to modify and restart some units without tearing down and rebuilding their associated connections. Leveraging these abilities can give you more flexibility and power during administration.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-12-05 04:05:38 EET
</div>
</div>
</body>
</html>
