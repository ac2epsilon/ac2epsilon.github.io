:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== Вступ до Admin Auth API

link:https://firebase.google.com/docs/auth/admin[базовий документ]

Firebase Admin SDK дозволяє вам інтегрувати ваші власні сервери з Firebase Authentication. Ви можете використовувати Firebase Admin SDK для керування вашими користувачами або користування токенами аутентифікації. Є багато причин робити це:

* *Керування користувачами* Не завжди зручно заходити в консоль Firebase для керування користувачами. API керування користувачами надає прагматичний доступ до тих самих користувачів. Він навіть дозволяє речі, що неможливі в консолі, такі, як отримання всіх даних користувача, зміна пароля, електронної адреси або телефону. Firebase Admin SDK провадить API для керування вашими Firebase користувачами з піднесеними привелеями. Це дає змогу відкликати, створювати, оновлювати та видаляти користувачів без отримання існуючих паролей користувачів та без турбот з обмеженнями клієнтського доступу.

* *Власна аутентифікація* Ви можете інтегрувати зовнішню систему користувачів з Firebase. Наприклад, ви можете вже мати базу даних користувачів, або ви бажаєте інтегрувати деякого провайдера, що природно не підтримується Firebase Authentication. Щоб зробити це, ви можете створити власні токени з довільними твердженнями, що ідентифікують користувача. Ці токени потім можуть використовуватись для входу до Firebase Authentication в клієнтському застосуванні і підтверджувати ідентичність, описану твердженнями токену. Ця ідентичність може бути застосована для доступу до сервісів Firebase, як Cloud Storage. 

Первинне використання для створення власних токенів - дозволити користувачам авторизуватись через зовнішний або застарілий механізм. Це може бути дещо під вашим контролем, як LDAP сервер, або сторонній провайдер OAuth, що природно не підтримується Firebase, як Instagram або LinkedIn. 

Firebase Admin SDK має вбудований метод для створення власних токенів. Ви також можете власноруч створювати токени в любій мові, з використанням сторонніх бібліотек JWT. Ваш сервер має створити власний токен з унікальним ідентифікатором (uid), та передати цей токен в користувацьке застосування, що буде використовуватись для входу до Firebase. Дивіться нижче щодо цього процесу.

Зауваження: якщо вам треба підключитись до Firebase Realtime Database з вашого сервера, не використовуйте власні токени. Замість цього використовуйте Firebase Admin SDK для аутентифікації з обмеженими привелеями.

* *Верифікація ідентичності* Firebase Authentication в основному застосовується для ідентифікації користувачів вашого застосування, щоб обмежити доступ до інших сервісів, як Cloud Storage. Ви також можете використати цей сервіс для ідентифікації користувачів на вашому власному сервері. Це дозволить вам безпечно виконувати серверну логіку від імені користувачів, що пройшли аутентифікацію Firebase Authentication. Для цього ви отримуєте токен від клієнтського застосування, що пройшло  Firebase Authentication, та включає токен в запиті до сервера. Ваш сервер верифікує токен, та виділяє твердження користувача (його uid, провайдер ідентифікації, тощо). Ця інформація ідентичності може застосовуватись вашим сервером для виконання дій від імені користувача.

Якщо ваш клієнт Firebase комунікує з бекендом, вам може знадобитись ідентифікувати поточного користувача, щоб виконувати дії від його імені. Ви можете робити це безпечно, використовуючи ID токени, що створені Firebase коли користувач входить в систему. ID токені відповідають спцифікації OpenID Connect, та містять дані про користувача, так само як і інші дані профілю і інформацію, пов'язану з аутентифікацією. Ви можете надсилати, перевіряти, та переглядати ці токени від ваших власних бекендів. Це дозволяє вам безпечно ідентифікувати поточного користувача, та надавати доступ до його бекенд ресурсів.

Firebase Admin SDK має вбудований метод для верифікації ID токенів. Ви також можете власноруч перевіряти ID токени в любій мові, використовуючи JWT бібліотеки. Шукайте докладну інформацію щодо верифікації деінде.

Зауваження: ця документація пояснює, як керувати токенами аутентифікації. Якщо ви, замість цього, шукаєте документацію, як аутентифікувати Admin SDK для доступу до Firebase Realtime Database, перегляньте Introduction to the Admin Database API. Firebase Admin SDK надає методи для отримання аутентифікації, перераховані вище, щоб дозволити вам керувати користувачами, генерувати власні токени та перевіряти ID токени.

Зауваження: якщо ваш сервер має емулювати користувацьки дії, як доступ до Firebase Realtime Database від імені користувача, вам слідує спершу верифікувати та декодувати ID токен для цього користувача. Потім використовуйте `databaseAuthVariableOverride` для обмеження привелеїв на сервері, як описане в Authenticate with limited privileges.

* *Власні твердження користувачів* В деяких випадках ви можете побажати реалізувати гарно налаштований контроль доступу для вже зареєстрованих користувачів через один з підтримуваних провайдерів, як Email/Password, Google, Facebook, phone, тощо. Комбінація власних користувацьких твержень та правил безпеки застосування провадить цю можливість. Наприклад, користувач, шо війшов через метод Firebase Authentication Email and Password, може отримувати контроль на основі визначених власних тверджень користувачів.

Firebase Admin SDK дозволяє вам встановити власні атрибути на користувацьких рахунках. З власними користувацькими твердженнями ви можете встановити різні рівні доступу (ролі), що потім примушує до виконання правил безпеки застосування.

Після модифікації власних тверджень на користувачеві через Firebase Admin SDK, вони просуваються до аутентифінкованих користувачів на стороні клієнта через їхні ID токени. ID токени є довірений механізм для доставлення ціх власних тверджень, та весь аутентифікований доступ має валідувати ID токен перд обробкою асоційованого запиту.

== Перевірка ID токенів

Якщо ваш клієнт Firebase комунікує з власним бекенд сервером, вам може знадобитись ідентифікувати поточного користувача на сервері. Щоб зробити це безпечно після входу в систему надішліть ID токен користувача на сервер використовуючи HTTPS. Тоді на сервері перевірте цілісність та ідентичність токену, та отримати з нього uid. Ви можете використовувати  `uid` отриманий таким шляхом для безпечної ідентифікації поточного користувача на вашому сервері.

Зауваження: багато випадків для верифікації токенів на сервері можна вирішити з використанням Security Rules для Firebase Realtime Database та Cloud Storage. Перевірте, чи не вирішить це проблему, пере тим, як перевіряти токени власноруч.

Попередження: методи верифікації токенів з Admin SDKs призначені для перевірки токенів, що надходять від клієнтських SDK, а не власних токенів, що ви створюєте за допомогую Admin SDK. Дивіться Auth tokens щодо додаткової інформація.

=== Підключення до Firebase Admin SDK

Щоб перевіряти токени через Firebase Admin SDK ви маєте створити сервісний рахунок. Admin SDK - це набір сервісних бібліотек, що дозволяють вам взаємодіяти з Firebase з привелійованого оточення для виконання наступних дій:

* Читати та писати дані Realtime Database з повними адмін привелеями.

* Програмно надсилати повідомлення Firebase Cloud Messaging через простий підхід, альтернативний протоколам Firebase Cloud Messaging.

* Генерувати та перевіряти токени аутентифікації.

* Отримувати ресурси Google Cloud як бакети Cloud Storage та бази Cloud Firestore, асоційовані з вашим проектом.

* Створювати вашу власну спрощену адмін консоль для таких речей, як перегляд даних користувачів або зміна поштової скриньки користувача для аутентифікації.

Для роботи JS версії Firebase Admin SDK вам знадобиться встановлений на сервері Node.js 10.13.0+. Детальніше щодо інших мов link::https://firebase.google.com/docs/admin/setup[дивіться тут]. Модуль додається до проекта сервера командою:

[source,bash]
----
yarn add firebase-admin
# або
npm install firebase-admin --save
----

Потім імпортуєте його в код 

[source,js]
----
var admin = require('firebase-admin');
// або
import * as admin from 'firebase-admin';
----

Також вважатимемо що ви вже маєте проект Firebase. Тепер ви можете ініціалізувати SDK стратегією авторизації, що комбінує ваш файл сервісного рахунку з Google Application Default Credentials. Проекти Firebase підтримують сервісні рахунки, які ви можете використовувати для виклику сервісних API з вашого серверу або довіреного середовища. Якщо ви розробляєте код локально або розгортаєте застосування у клієнта, для авторизації запитів сервера ви можете використовувати вірчі дані, отримані від серверного рахунку.

Щоб аутентикувати сервіснй рахунок та авторизувати його для доступу до сервісів Firebase, ви маєте згенерувати JSON файл приватного ключа.

1. В консолі Firebase відкрийте *Settings > Service Accounts*.
2. Клацніть *Generate New Private Key* і підтвердіть дію.
3. Надійно збережіть отриманий файл.

Коли ви входите до сервісного аккаунта, ви маєте два варіанти. Ви можете або встановити змінну оточення `GOOGLE_APPLICATION_CREDENTIALS`, або можете надати шлях до ключа прямо в коді. Перший метод безбечніший, і ми радимо його використання. 

[source,bash]
----
export GOOGLE_APPLICATION_CREDENTIALS="/home/ac/service-account-file.json"
----

Після ціх кроків Application Default Credentials (ADC) зможе неявно визначити довірчі дані, що дозволяє використовувати дані сервісного рахунку для тестування або роботі в не-Google оточенні.

[source,js]
----
admin.initializeApp({
    credential: admin.credential.applicationDefault(),
    databaseURL: 'https://<DATABASE_NAME>.firebaseio.com'
});
----

Зауваження: опції ініціалізації, як показана в коді `databaseURL`, не є конче потрібними для ініціалізації SDK. В залежності від оточення розгортання і цільового випадку використання ви можете вказувати тільки потрібні вам опції.

Також підтримується аутентифікація рефреш токеном Google OAuth. 

[source,js]
----
const refreshToken = '...'; // отримманя токену з потоку OAuth2

admin.initializeApp({
  credential: admin.credential.refreshToken(refreshToken),
  databaseURL: 'https://<DATABASE_NAME>.firebaseio.com'
});
----

Зауваження: рефреш токени OAuth 2.0 не підтримуються для під'єднання до  Cloud Firestore.

SDK також може бути ініціалізований без параметрів. В цьому випадку використовуються Google Application Default Credentials. Довірчі дані шукаються повністю автоматично в Google оточенні, так що це рекомендовване для Compute Engine, Kubernetes Engine, App Engine, та Cloud Functions. Для передачі додаткових параметрів ініціалізації для сервісів як Realtime Database, Cloud Storage, або Cloud Functions, використовуйте змінну оточення `FIREBASE_CONFIG`. Якщо перший символ значення є `{`, воно буде сприйматись як JSON. Інакше значення тлумачиться як шлях до JSON файлу з параметрами.

Зауваження: змінна `FIREBASE_CONFIG` включається автоматично в Cloud Functions для функцій Firebase, коли вони завантажуються через Firebase CLI.

[source,js]
----
const app = admin.initializeApp();
----


=== Отримання токенів на клієнті

Коли користувач або пристрій вдало входить до системи, Firebase створює відповідний ID токен, що унікально ідентифікує його, та гарантує доступ до ресурсів, як Firebase Realtime Database та Cloud Storage. Ви можете використати токен повторно на своєму сервері. Щоб отримати токен переконайтесь, що є поточний користувач та запитайте його токен:

[source,js]
----
firebase.auth().currentUser.getIdToken(/* forceRefresh */ true).then(function(idToken) {
  // перешліть токен на бекенд по HTTPS
  // ...
}).catch(function(error) {
  // обробка помилки
});
----

Коли ви маєте токен JWT до вашого бекенда та перевірити його через Firebase Admin SDK або сторонню бібліотеку JWT, якщо ваш сервер написаний на мові, що не підтримується природно. 

=== Перевірка ID токенів з використанням Firebase Admin SDK

Firebase Admin SDK має вбудований метод для перевірки та декодування токенів. Якщо наданий токен має коректний формат, не прострочений і відповідно підписаний, метод повертає декодований токен. З нього можна отримати `uid` користувача або пристрою.

Зауваження: це не перевіряє, чи був токен відкликаний. Дивіться link::https://firebase.google.com/docs/auth/admin/manage-sessions#detect_id_token_revocation[тут]
Detect ID token revocation.

Після ініціалізації використовуйте метод `verifyIdToken()` для верифіфкації токену:

[source,js]
----
// idToken надходить зі сторони клієнта
admin
  .auth()
  .verifyIdToken(idToken)
  .then((decodedToken) => {
    const uid = decodedToken.uid;
    // ...
  })
  .catch((error) => {
    // обробка помилки
  });
----

Верифікація ID токену потребує ID пректу. Firebase Admin SDK намагається отримати ID проекту одним з методів:

* Якщо SDK було ініціалізовано з явною опцією `projectId`, буде використане це значення.

* Якщо SDK було ініціалізовано з довірчими даними сервісного рахунку, SDK використовує поле `project_id` JSON об'єкту рахунку.

* Якщо встановлена змінна оточення `GOOGLE_CLOUD_PROJECT`, SDK використовує його значення як ID проекту. Ця змінна доступна для коду, що виконується в інфраструктурі, як App Engine та Compute Engine.

== React Apollo аутентифікація

Тільки якщо ваші дані не є повністю публічні, ваше застосування має деякий різновид користувачів, рахунків та систем дозволів. Якщо різні користувачі мають різні дозволи в вашому застосуванні, вам треба спосіб сказати серверу, який користувач асоційований з запитом. Apollo Client використовує вкрай гнучний Apollo Link, що має декілька опцій для аутентифікації.

=== Cookie
Якщо ваше застосування базується на браузері і ви використовуєте кукіз для логіну та керування сессіями на бекенді, накажіть вашому мережевому інтерфейсу надсилати кукі в кожному запиті. Передайте опцію `credentials: 'same-origin'` якщо ваш бекенд сервер в тому самому домені, як показано нижче, або `credentials: 'include'`, якщо ваш бекенд в іншому домені.

[source,js]
----
const link = createHttpLink({
  uri: '/graphql',
  `credentials: 'same-origin'`
});

const client = new ApolloClient({
  cache: new InMemoryCache(),
  link,
});
----

Ця опція передається до реалізації `fetch`, що використовується `HttpLink` при надсиланні запиту.

Зауваження: бекенд також має дозволяти довірчі дані для даного місця, або в термінах популярного пакунку `cors` в node.js, наступні налаштування мають робити в тандемі з наступними налаштуваннями клієнта `apollo`:

[source,js]
----
// enable cors
var corsOptions = {
  origin: '<insert uri of front-end domain>',
  credentials: true // <-- REQUIRED backend setting
};
app.use(cors(corsOptions));
----

=== Заголовок

Інший загальний шлях ідентифікувати себе при використанні HTTP - це надіслати заголовок `authorization` в кожному HTTP запиті, зціплюючи разом Apollo Links. В цьому прикладі ми підтягуємо токен з `localStorage` кожного разу при надсиланні запиту:

[source,js]
----
import { ApolloClient, createHttpLink, InMemoryCache } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';

const httpLink = createHttpLink({
  uri: '/graphql',
});

const authLink = setContext((_, { headers }) => {
  // отримати токен з локальнохо сховку (якщо він є)
  const token = localStorage.getItem('token');
  // повернути заголовки в контекст, так щоб httpLink міг прочитати їх
  return { headers: 
           { ...headers,
             authorization: token ? `Bearer ${token}` : "",
           }
         }
});

const client = new ApolloClient({
  link: authLink.concat(httpLink),
  cache: new InMemoryCache()
});
----

Сервер може використати цей заголовок для аутентифікації користувача та приєднання його до контексту виконання GraphQL, так що ресолвери можуть модифікувати свою поведінку на основі ролей та дозволів.

=== Скидання кешу по виходу

Оскільки Apollo кешує всі результати запитів, важливо скинути кеш при виході з системи. Найбільш прямий спосіб переконатись що UI і стан сховку відповідають дозволам користувача - це викликати `client.resetStore()` після кожного входу або виходу користувача. Це пр изведе до зачищення всіх активних запитів, та повторному перевиконанню. Якщо ви хочете тільки очистити кеш, але не виконувати перезавантаження, використовуйте `client.clearStore()`. Інша опція - перевантажити сторінку, що матиме той самий ефект.

[source,js]
----
const PROFILE_QUERY = gql`
  query CurrentUserForLayout {
    currentUser {
      login
      avatar_url
    }
  }
`;

function Profile() {
  const { client, loading, data: { currentUser } } = useQuery(
    PROFILE_QUERY,
    { fetchPolicy: "network-only" }
  );

  if (loading) {
    return <p className="navbar-text navbar-right">Loading...</p>;
  }

  if (currentUser) {
    return (
      <span>
        <p className="navbar-text navbar-right">
          {currentUser.login}
          &nbsp;
          <button
            onClick={() => {
              // call your auth logout code then reset store
              App.logout().then(() => client.resetStore());
            }}
          >
            Log out
          </button>
        </p>
      </span>
    );
  }

  return (
    <p className="navbar-text navbar-right">
      <a href="/login/github">Log in with GitHub</a>
    </p>
  );
}
----

