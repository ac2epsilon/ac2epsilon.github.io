:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

= GraphQL 101 ~by ac2~
Язык запросов:

[width="96%",cols="<l,<2"]
|====
|
# тип и имя операции
query HeroNameAndFriends
# переменная со значением по умолчанию
      ($episode: Episode  = JEDI, 
# обязательная переменная
        $withFriends: Boolean!) {
# поле с аргументом
  hero($episode: Episode) {
# поле с псевдонимом
    hero_name: name
# поле-массив и директива, включающая блок
    friends @include(if: $withFriends) {
      name
# поле с аргументом формата
      height(unit: FOOT)
    }
  }
}

|
*Тип операции*: `query`, `mutation`, `subsription`. `query` можно не указывать, но тогда нельзя присвоить имя, а имена мы по договоренности всегда присваиваем. 

*Имя операции*: осмысленный идентификатор. Имя можно не указывать, но по договоренности его лучше всегда указывать - для отладки и ссылок в документации.

*Список полей*: список скалярных или обьектных полей. Обьектньые поля содержат свои поля, и так далее. 

*Тип поля*: тип поля определяется в схеме. Если вложенное поле определено в схеме как массив - будет возвращаться массив. 

*Псевдонимы*: иногда в одном запросе нужно получить то же самое поле дважды. Другой случай - когда вы хотите дать полю более выразительное имя. Для этого перед именем можно указать `псевдоним:` - новое имя и две точки.

*Аргументы*: запросы можно параметризировать с помощью `(аргументов)` после имени поля. Любое поле может содержать аргументы для выборки или форматирования. 

*Переменные*: аргументы, кроме констант, могут принимать переменные. Имена переменных начинаюся с символа `$`. Переменные могут иметь значение по умолчанию. Переменные также служат документированию параметров запроса. Вы никогда не должны конструировать запросы с помощью интерполяции строк. Восклицательный знак в типе переменной указывает, что данный аргумент обязательный.

*Директивы*: для условного включения части запроса можно использовать директивы `@include(if: Boolean)` и `@skip(if: Boolean)`. Реализации могут добавлять свои директивы. 

*Пакетное выполнение*: одно обращение может содержать несколько запросов. Именно поэтому в ответном пакете нужен промежуточный контейнер `data`. В противном случае был бы риск получить невалидный JSON.

*Комментарии*: строка после `#` является комментарием.
|
# определение фрагмента
fragment fragAppears on Character {
  appearsIn
}
# использование фрагмента
...fragAppears

query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
# мета данные
    `__typename`
# инлайн фрагменты на основе типа контейнера
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}
|
*Фрагменты*: сложные запросы можно упростить, вынеся части запроса во фрагменты. Эти фрагменты можно использовать повторно. Фрагменты имеют доступ к переменым запроса.

*Инлайн фрагменты*: если запрашиваемое поле возвращает интерфейс или юнион, для анализа результата придется использовать инлайн фрагменты, как показано в примере.  Аналогично можно использовать именованные фрагменты, поскольку они всегда имеют тип.

*Мета данные*: в ситуации, когда клиент должен знать тип данных, когда он не определен, вы можете использовать мета поле `__typename`. Оно возвращает объектный тип в данной точке запроса. Система интроспекции предоставляет еще несколько мета полей.

|# мутация по соглашению должна иметь имя
mutation CreateReviewForEpisode

# на вход поступают скаляры или объекты
      ($ep: Episode!, $review: ReviewInput!) {
  createReview(episode: $ep, review: $review) {

# мутация также возвразает новые данные
    stars
    commentary
  }
}
| *Мутации*: позволяют модифицировать данные на сервере. Входные данные мутации могут быть как скалярами, так и объектами. Мутации возвращают поля только что модифицированных данных.

*Очередность мутаций*: как и запросы, мутации могут выполняться в пакетном режиме. Важное отличие: мутации никогда не выполняются параллельно, только последовательно. Это исключает состояние гонки.  Запросы всегда пытаются выполняться параллельно.
 
|====

= Схемы и типы

=== Система типов

[width="96%",cols="<l,<2"]
|====
|
# Тип и его имя
type Character {
# обязательное скалярное поле
  name: String!
# обязательное поле типа массив  
  appearsIn: [Episode!]!
# поле с аргументом
  height(unit: LengthUnit = METER): Float  
}
|*Объектный тип*: указывает имя типа и перечисляет поля. Поле в `[]` обозачает массив (список) значений,`!` - что поле обязательное, не может быть `null` или `undefined`. Поэтому `[Episode!]!` читается как не-null список не-null значений типа `Episode`.

*Аргументы*: могут сопровождать поля схемы. Все аргументы именованные, позиционные аргументы не поддерживаются. Аргументы бывают обязательными или опциональными - для опциональных можно задать значение по умолчанию.
|
schema {
  query: Query
  mutation: Mutation
}
type Query {
  hero(episode: Episode): Character
  droid(id: ID!): Droid
}
|*Особые типы*: любая схема обязатеньно содержит (суб-)корневой тип `query`, и опционально - `mutation`.  

*Скалярные типы*: в конце концов все иерархии типов сводятся к скаляярным типам. Скалярные типы хранят данные и не содержат суб-полей. Следующие типы доступны: `Int`, `Float`, `String`, `Boolean`. Тип `ID` представляет уникальный ключ. 

*Собственные типы*: Реализации позволяют определять собственные скалярные типы, как `scalar Date`. Вы должны сами реализовать сериализацию, десериализацию и валидацию. Клиент должен иметь доступ к этой реализации.

|
enum Episode {
  NEWHOPE
  EMPIRE
  JEDI
}
|*Энумераторы позволяют*: задавать перечислимые поля. Вместе с объектами они составляют все допустимые типы.

| interface Character {
  id: ID!
  name: String!
  friends: [Character]
  appearsIn: [Episode]!
}
type Human implements Character {
...
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
| *Интерфейсы*: служат шаблонами для собственных типов. Любой тип, который `implements` интерфейс, должен содержать те же поля и такого же типа, что и реализуемый интерфейс. При этом тип расширяет интерфейс собственными полями. Вы не можете делать запросы к частным полям, если в схеме указан интерфейс. Для этого используются инлайн фрагменты, гарантирующие нужный тип и соответствующие поля.

| union SearchResult = Human \| Droid \| Starship
|*Юнион*: напоминает интерфейсы, но без указания общих полей. Перечисленные типы должны быть конкретными, не интерфейсами. Единственный способ делать запросы к юнионам - через условные фрагменты.

|input ReviewInput {
  stars: Int!
  commentary: String
}
| В GraphQL в качестве аргументов можно передавать не только скаляры, но и объектные типы. Единственное отличие от обычных типов - использование зарезервированного слова `input` вместо `type`. Входные типы могут в свою очередь ссылаться на другие входные типы. Единственно они не могут иметь аргументы на своих полях. Также нельзя смешивать входные и выходные типы.
|====