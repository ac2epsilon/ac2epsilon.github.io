<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Функції вищих порядків</h2>
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="images/sun.png" alt="images/sun.png" />
</span>
Функції Haskell можуть приймати функції як параметри, та повертати функції як значення повернення. Функція, що робить щось з цього, називається функцією вищого порядку. Функції вищого порядку є не тільки частиною досвіду Haskell, вони в великій мірі є сам досвід Haskell. З'ясовується, що якщо ви бажаєте визначити обчислення, визначаючи що це таке, замість визначати кроки, що змінюють деякий стан та можливо роблячи цикли, функції вищих порядків незамінні. Вони дійсно є потужним способом вирішення проблем і думати про программи.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="__">Каровані функції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожна функція в Haskell офіційно приймає тільки один параметр. Так як це можливо, що ми визначили декілька функцій, що приймають більше ніж один параметр? Гаразд, це дотепний трюк! Всі функції, що приймають декілька параметрів, були карованими функціями. Що це означає? Ви краще зрозумієте це на прикладі. Давайте візьмемо нашого гарного друга, функцію <code>max</code>. Виглядає, що вона приймає два параметри, та повертає той, що більше. Виконання <code>max 4 5</code> спочатку створює функцію, що приймає параметр, і повертає або <code>4</code>, або цей параметр, в залежності що більше. Потім 5 застосовується до цієї функції, і ця функція продукує наш бажаний результат. Це виглядає як балачка, але насправді це крута концепція. Наступні два виклики еквівалентні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">max</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/curry.png" alt="images/curry.png" />
</span>
Покладання проміжка між двома речами є просто застосування функції. Проміжок є різновидом оператора, і він має найвищий преоритет. Давайте перевіримо тип <code>max</code>. Це <code>max ::( Ord a) =&gt; a -&gt; a -&gt; a</code>. Він може бути записаний як <code>max ::( Ord a) =&gt; a -&gt; (a -&gt; a)</code>. Це може бути прочитане так: <code>max</code> бере <code>a</code>, та повертає (це <code>-&gt;</code>) функцію, що бере <code>a</code> та повертає <code>a</code>. Ось чому тип повернення та параметри функцій просто розділені стрілками.</p></div>
<div class="paragraph"><p>Погляньте на цю образливо просту функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">multThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">multThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>То як це вигідно для нас? Кажучи просто, якщо ми викликаємо функцію з недостатньою кількістю параметрів, ми отримаємо назад частково застосовану функцію, що приймає стільки параметрів, скльки ми залишили. Використання часткового застосування (виклик функцій з недостатньою кількістю параметрів, якщо бажаєте), є милий спосіб створювати функції на льоту, так що ми можемо передавати їх до інших функцій, або наповнювати їх деякими даними.</p></div>
<div class="paragraph"><p>Що насправді відбувається, коли ми робимо <code>multThree 3 5 9</code> або <code>( (multThree 3) 5) 9</code>? Спочатку <code>3</code> застосовується до <code>multThree</code>, оскільки вони розділені проміжком. Це створює функцію, що приймає один параметр, та повертає функцію. Так що <code>5</code> застосовується до цього, це створює функцію, що буде брати параметр, та множити його на <code>15</code>. <code>9</code> застосовується до цієї функції, та результат буде <code>135</code>, або десь так. Пам'ятайте, що цей тип функції може бути переписаний як <code>multThree ::( Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</code>. Річ перед <code>-&gt;</code> є параметр, що приймає функція, і річ, що йде після цього є те, що вона повертає. Так що наша функція приймає <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; (a -&gt; a)</code>. Подібно до цього, ця функція бере <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; a</code>. І ця функція, нарешті, просто бере <code>a</code> і повертає <code>a</code>. Погляньте на це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multTwoWithNine</span> <span class="ow">=</span> <span class="n">multThree</span> <span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">54</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multWithEighteen</span> <span class="ow">=</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multWithEighteen</span> <span class="mi">10</span>
<span class="mi">180</span>
</pre></div></div></div>
<div class="paragraph"><p>Викликаючи функції з недостатніми параметрами, так би мовити, ми створюємо функції на льоту. Що, якщо ми бажаємо створити функцію, що приймає число, та порівнюєте його зі <code>100</code>? Ми можемо зробити щось подібне до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">compareWithHundred</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">compareWithHundred</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">compare</span> <span class="mi">100</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми викличемо її з <code>99</code>, вона поверне <code>GT</code>. Прості речі. Зауважте, що <code>x</code> зправа по обі сторони від рівності. Тепер давайте подумаємо щодо того, що повертає <code>compare 100</code>. Воно повертає функцію, що бере число, та порівнює його з <code>100</code>. Вау! Чи це не функція, яку ми бажали? Ми можемо переписати це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">compareWithHundred</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">compareWithHundred</span> <span class="ow">=</span> <span class="n">compare</span> <span class="mi">100</span>
</pre></div></div></div>
<div class="paragraph"><p>Декларація типу каже те саме, оскільки <code>compare 100</code> повертає функцію. <code>Compare</code> має тип <code>(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code>, та виклик її з <code>100</code> повертає <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. Додаткове обмеження класу присутнє, оскільки <code>100</code> також є частиною типокласу <code>Num</code>.</p></div>
<div class="paragraph"><p>Йо! Переконайтесь, що ви справді розумієте, як роблять каровані функції та робить часткове застосування, бо воні справді важливі!</p></div>
<div class="paragraph"><p>Інфіксні функції також можуть бути частково застосовані з використанням секцій. Для секції інфіксної функції просто оточите її дужками, і надайте параметр тільки з однієї сторони. Це створить функцію, що приймає один параметр, та потім застосовує його до сторони, де відсутній операнд. Образливо тривіальна функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">divideByTen</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Floating</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">divideByTen</span> <span class="ow">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик, скажімо, <code>divideByTen 200</code> еквівалентне до <code>200 / 10</code>, так само, як зробити <code>(/10) 200</code>. Функція, що перевіряє, що наданий символ є великою літерою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">isUpperAlphanum</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isUpperAlphanum</span> <span class="ow">=</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина особлива річ щодо секцій є використання <code>-</code>. З визначення секцій <code>(-4)</code> має давати результат в вигляді функції, що приймає число, та віднімає <code>4</code> з нього. Однак для зручності <code>(-4)</code> означає мінус чотири. Так що якщо ви бажаєте створити функцію, що віднімає <code>4</code> від часла як параметра, частково застосуйте функцію <code>subtract</code> таким чином: <code>(subtract 4)</code>.</p></div>
<div class="paragraph"><p>Що трапиться, якщо ми спробуємо просто зробити <code>multThree 3 4</code> в GHCI, замість прикріплення її до імені за допомогою <code>let</code>, або передачі її до іншої функції?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multThree</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">))</span>
      <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">print&#39;</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">12</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">))</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
    <span class="kt">In</span> <span class="n">a</span> <span class="n">&#39;do&#39;</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
</pre></div></div></div>
<div class="paragraph"><p>GHCI каже нам, що вираз спродукував функцію типу <code>a -&gt; a</code>, але воно не знає, як друкувати її на екрані. Функції не є членами типокласу  <code>Show</code>, так що ви не можете отримати милого рядкового представлення функції. Коли ми робимо, скажімо, <code>1 + 1</code> в підказці GHCI, воно спочатку ообчислює <code>2</code>, та потім викликає <code>show</code> на <code>2</code> для отримання текстуального представлення числа. І текстуальна репрезентація <code>2</code> є просто рядок <code>"2"</code>, що друкується на екрані.</p></div>
<div class="sect2">
<h3 id="_____">Деякий високо-порядкізм по порядку</h3>
<div class="paragraph"><p>Функції можуть приймати функції як параметри і також повертають функції. Щоб проілюстровати це, ми збираємось створити функцію, що приймає функцію, та потім застосовує її двічі до будь-чого!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">applyTwice</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">applyTwice</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bonus.png" alt="images/bonus.png" />
</span>
Для початку зауважте декларацію типу. Перед цім ми не потребували дужок, оскільки <code>-&gt;</code> є право асоціативним. Але тут воно обов'язкове. Це каже, що перший параметр є функція, що приймає дещо, та повертає ту саму річ. Другий параметр є дещо, і цього ж типу також значення повернення. Ми можемо читати цю декларацію типу, але щоб не заморочуватись ми просто скажемо, що ця функція приймає два параметри, та повертає одну річ. Перший параметр є функція (типу <code>a -&gt; a</code>) та другий те саме <code>a</code>. Функція також може бути <code>Int -&gt; Int</code> або <code>String -&gt; String</code>, або будь-що. Але потім другий параметр має також бути того самого типу.</p></div>
<div class="paragraph"><p>Note: Відтепер ми будемо казати, що функції приймають декілька параметрів, незважаючи на те, що кожна функція насправді бере тільки один параметр, та повертає частково застосовані функції, доки ми не досягнемо функцію, що повертає справжнє значення. Так що для спрощення ми кажемо, що <code>a -&gt; a -&gt; a</code> бере два параметри, навіть маючи на увазі, що це відбувається за лаштунками.</p></div>
<div class="paragraph"><p>Тіло функції досить просте. Ми просто використовуємо параметр <code>f</code> як функцію, застосовуючи <code>x</code> до неї, розділяючи їх проміжками, і потім застосовуючи результат знову до <code>f</code>. В любому випадку пограємось з функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HAHA&quot;</span><span class="p">)</span> <span class="s">&quot;HEY&quot;</span>
<span class="s">&quot;HEY HAHA HAHA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="s">&quot;HAHA &quot;</span> <span class="o">++</span><span class="p">)</span> <span class="s">&quot;HEY&quot;</span>
<span class="s">&quot;HAHA HAHA HEY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="n">multThree</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">9</span>
<span class="mi">144</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="mi">3</span><span class="kt">:</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивовижність та корисність часткових функцій є очевидною. Якщо наша функція потребує передати їй функцію, що приймає тільки один параметр, ви можете тільки частково застосувати функцію до тієї точки, коли вона прийматиме тільки один параметр, та потім передати її.</p></div>
<div class="paragraph"><p>Тепер ми збираємось використати програмування вищого порядку для реалізації насправді корисної функції, що є в стандартній бібліотеці. Вона називається <code>zipWith</code>. Вона бере функцію та два списки як параметри, та потім поєднує два списки, застосовуючи функцію між відповідними елементами. Ось як ми реалізуємо її:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">zipWith&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="nf">zipWith&#39;</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zipWith&#39;</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zipWith&#39;</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">zipWith&#39;</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивимось на декларацію типу. Перший параметр є функція, що бере дві речі і повертає третю річ. Вони не мають бути того самого типу, але вони можуть. Другий та третій параметр є списками. Результат також список. Перший має бути списком з <code>a</code>, оскікльки функція поєднання бере <code>a</code> як перший аргумент. Другий має бути списком <code>b</code>, тому що другий параметр функції поєднання має тип <code>b</code>. Результатом є список <code>c</code>. Якщо декларація типу функції каже, що вона сприймає функцію <code>a -&gt; b -&gt; c</code> як параметр, вона також сприйматиме функцію <code>a -&gt; a -&gt; a</code>, але не навпаки! Пам'ятайте, що коли в створюєте функції, особливо вищого порядку, і ви не впевнені щодо типу, ви можете просто оминути декларацію типу, та потім перевірити, що Haskell виводить щодо типу через <code>:t</code>.</p></div>
<div class="paragraph"><p>Дія в функції досить подібна до звичайного <code>zip</code>. Граничні умови ті самі, тільки є додатковий аргумент, функція поєднання, але цей аргумент не має значення в граничних умовах, так що ми використовуємо <code>_</code> щодо цього. Та тіло функції останнього шаблону подібне до <code>zip</code>, але він не робить <code>(x,y)</code>, але <code>f x y</code>. Єдина функція вищого порядку може бути використана для безлічі різних завдань, якщо вона досить загальна. Ось маленька демонстрація всьго різноманіття речей, що може робити наша функція <code>zipWith'</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="n">max</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;foo &quot;</span><span class="p">,</span> <span class="s">&quot;bar &quot;</span><span class="p">,</span> <span class="s">&quot;baz &quot;</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;fighters&quot;</span><span class="p">,</span> <span class="s">&quot;hoppers&quot;</span><span class="p">,</span> <span class="s">&quot;aldrin&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;foo fighters&quot;</span><span class="p">,</span><span class="s">&quot;bar hoppers&quot;</span><span class="p">,</span><span class="s">&quot;baz aldrin&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">*</span> <span class="p">))</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, єдина функція вищого порядку може бути використана в дуже різноманітний спосіб. Імперативне програмування зазвичай використовує речі як <code>for</code> цикли, <code>while</code> цикли, присвоєння чогось до змінної, перевірка її стану, тощо, щоб досягти певної поведінки та потім огорнути її в інтерфейс, такий як функція. Функціональне програмування використовує функції вищого порядку щоб абстрагувати загальні шаблони, як попарно екзаменувати два списки, та потім робити щось з ціма парами, або отримати набір рішень, та відкинути ті, що нам не потрібні.</p></div>
<div class="paragraph"><p>Давайте реалізуємо іншу функцію, що вже є стандартній бібліотеці, що називається <code>flip</code>. <code>Flip</code> просто бере функцію, та повертає функцію, що подібна до нашої оригінальної функції, тільки два перших аргументи обміняні місцями. Ми можемо реалізувати її таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">g</span>
    <span class="kr">where</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Читаючи декларацію типу ми кажемо, що вона бере функцію, що приймає <code>a</code> та <code>b</code>, та повертає функцію, що приймає <code>b</code> та <code>a</code>. Але оскільки функції каровані по замовчанню, друга пара дужок не є насправді потрібною, бо <code>-&gt;</code> є право асоціативним по замовчанню. <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> є те саме, що і <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, що те саме, що і <code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. Ми записуємо, що <code>g x y = f y x</code>. Якщо це так, тоді <code>f y x = g x y</code> має також дотримуватись, вірно? Маючи це на увазі, ми можемо визначити цю функцію навіть в ще простіший спосіб.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми отримуємо вигоду від факту, що функція карована. Коли ми в икликаємо <code>flip' f</code> без параметров <code>y</code> та <code>x</code>, вона буде повертати <code>f</code>, що бере ці два параметри, але переставляє їх місцями. Навіть не зважаючи на те, що функції з перестановкою звичайно передаються в інші функції, ви можете отримати перевагу від карування, та потім створювати функції вищих порядків, при цьому розмірковуючи наперед, та написання їх таким чином, щоб остаточний результат був би такий, якби вони були повністю застосовані.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flip&#39;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="s">&quot;hello&quot;</span>
<span class="p">[(</span><span class="sc">&#39;h&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="n">flip&#39;</span> <span class="n">div</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____2">Мапи та фільтри</h3>
<div class="paragraph"><p><code>map</code> приймає функцію та список, та застосовує цю функцію до кожного елементу, продукуючи новий список. Давайте подивимось, яка в неї сигнатура типу, та як вона визначена.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Сигнатура типу каже, що вона приймає функцію, що приймає <code>a</code> та повертає <code>b</code>, список <code>a</code> перетворюється на список <code>b</code>. Цікаво, що просто дивлячись на сигнатуру типу функції, ви можете інколи сказати, що вона робить. <code>map</code> одна з ціх дійсно універсальних функцій вищого порядку, що може використовуватись в мільйони різних способів. Ось вона в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;!&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;BIFF&quot;</span><span class="p">,</span> <span class="s">&quot;BANG&quot;</span><span class="p">,</span> <span class="s">&quot;POW&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BIFF!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;POW!&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">36</span><span class="p">],[</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">fst</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви, можливо, зауважили, що все це можна досягти осяжністю списків. <code>map (+3) [1,5,3,1,6]</code> те саме, що написати <code>[x+3 | x &lt;- [1,5,3,1,6]]</code>. Однак використання <code>map</code> значно краще читається для випадків, коли ви лише застосовуєте функцію до елементів списку, особливо коли ви маєте справу з мапою мап, і тоді ціла річ з багатьма дужками може стати заплутаною.</p></div>
<div class="paragraph"><p><code>filter</code> є функцією, що приймає предикат (предикат є функція, що каже, чи дещо вірно або ні, так що в нашому випадку повертає логічне значення), та список, та потім повертає список елементів, що задовільняє предикату. Сигнатура типу та реалізація виглядають так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">filter</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">filter</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">p</span> <span class="n">x</span>       <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Доволі проста річ. Якщо <code>p x</code> обчислюється до <code>True</code>, елемент буде включений в новий список. Якщо ні, елемент відкидається. Деякі приклади використання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">notNull</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">null</span> <span class="n">x</span><span class="p">)</span> <span class="kr">in</span> <span class="n">filter</span> <span class="n">notNull</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">])</span> <span class="s">&quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;</span>
<span class="s">&quot;uagameasadifeent&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;i lauGh At You BecAuse u r aLL the Same&quot;</span>
<span class="s">&quot;GAYBALLS&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Все це можна досягти за допомогою осяжності списків через використання предикатів. Немає встановленого правила для використання <code>map</code> та <code>filter</code>, проти використання осяжності списків, вам треба просто визначити, що читається краще в залежності від коду та контексту. <code>filter</code> еквівалентно до застосування декількох предикатів в осяжності списків, або фільтруючи дещо декілька раз, або поєднуючи предикати логічною функцією <code>&amp;&amp;</code>.</p></div>
<div class="paragraph"><p>Пам'ятаєте нашу функцію <code>quicksort</code> з минулої глави? Ми використовували осяжність списків для фільтрування елементів списку, що меньші (або рівні), та більше ніж переломна точка. Ми можемо досягти такої самої функціональності в більш читаємий спосіб, за допомогою <code>filter</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">quicksort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
        <span class="n">biggerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
    <span class="kr">in</span>  <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/map.png" alt="images/map.png" />
</span>
Відображення та фільтрація є хліб та масло серед інструментів кожного функціонального програміста. Так. Не має значення, чи ви робите це за допомогою функцій <code>map</code> та <code>filter</code>, або осяжністю списків. Згадайте, як ми вірішували проблема пошуку правильних трикутників в певному колі. В імперативному програмуванні ми можемо вирішити це через вкладання трьох циклів, та потім перевіряючи, чи поточна комбінація задовільняю умовам трикутника, що має заданий периметр. Якщо це так, ми можемо роздрукувати це не екрані, або зробити щось інше. В функціональному програмуванні цей шаблон досягається через відображення та фільтрацію. Ви створюєте функцію, що приймає значення та продукує деякий результат. Ми відображуємо цю функцію на списку значень, та потім ми фільтруємо результуючий список щодо результатів, які задовільняють умовам пошуку. Дякуючи лінивості Haskell, навіть якщо ви робите <code>map</code> по списку декілька разів і фільтруєте його декілька раз, він пройде по списку один раз.</p></div>
<div class="paragraph"><p>Давайте знайдемо найбільше число до <code>100,000</code> що ділиться на <code>3829</code>. Щоб зробити це, ми просто відфільтруємо набір можливостей, де за нашими підрахунками знаходяться наші рішення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">largestDivisible</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">largestDivisible</span> <span class="ow">=</span> <span class="n">head</span> <span class="p">(</span><span class="n">filter</span> <span class="n">p</span> <span class="p">[</span><span class="mi">100000</span><span class="p">,</span><span class="mi">99999</span><span class="o">..</span><span class="p">])</span>
    <span class="kr">where</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3829</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Спочатку створимо список всіх чисел, меньших <code>100,000</code> від великих до малих. Потім ми фільтруємо його по нашому предикату, і оскільки числа ідуть від великих, найбільше число за нашою умовою буде першим в списку результатів. Нам навіть не треба використовувати скінчений список для початку нашої множини. Це знову лінивість в дії. Оскільки ми закінчуємо використанням голови відфільтрованого списку, не має значення, чи ми фільтруємо скінчений список, або безкінечний. Обчислення зупиняється, коли буде знайдене перше адекватне рішення.</p></div>
<div class="paragraph"><p>Далі ми збираємось знайти суму всіх непарних квадратів, що меньше <code>10,000</code>. Але спочатку, оскільки ми використовуємо її в нашому рішенню, ми збираємось ввести функцію <code>takeWhile</code>. Вона приймає предикат і список, і потім проходить від початку списку, та повертає елемнти, доки предикат повертає істину. Як тільки знайдений елемент, для якого умова не виконується, все завершується. Якщо ви бажаєте отримати перше слово на початку рядка <code>"elephants know how to party"</code>, ми можемо зробити <code>takeWhile (/=' ') "elephants know how to party"</code>, що поверне <code>"elephants"</code>. Гаразд. Сума всіх непарних квадратів, що меньша <code>10,000</code>. Перше, ми почнемо з відображення функції <code>(^2)</code> на безкінечний список <code>[1..]</code>. Потім ми фільтруємо їх, щоб отримати лише непарні. І потім ми беремо елементи з цього списку, доки вони меньші ніж <code>10,000</code>. Нарешті ми отримуємо суму цього списку. Нам навіть немає потреби визначати для цього функцію, ми можемо зробити це в один рядок в GHCI:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">odd</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span>
<span class="mi">166650</span>
</pre></div></div></div>
<div class="paragraph"><p>Блискуче! Ми почали з деяких початкових даних (нескінчений список з усіх натуральних чисел), та потім ми робимо <code>map</code> по них, <code>filter</code> по ньому, та відсікаємо їх, доки він задовільняє нашим потребам, та потім підсумовуємо докупи. Ми можемо також переписати це, використовуючи осяжності списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">[</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">odd</span> <span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">)])</span>
<span class="mi">166650</span>
</pre></div></div></div>
<div class="paragraph"><p>Те, що ми обираємо, є лише справою смаку. І знову, властивість лінівості Haskell є те, що робить це можливим. Ми можемо робити відображення та фільтрувати по безкінечному списку, оскільки це насправді безпосередньо не робитиме <code>map</code> та <code>filter</code>, ці дії буде відкладено. Тільки коли ми змусимо Haskell показати нам суму буде викликана <code>sum</code>, що зробить <code>takeWhile</code> для отримання ціх чисел. <code>takeWhile</code> змушує виконання фільтрування та відображення, але тільки до тих пір, доки не трапиться число більше або рівне до <code>10,000</code>.</p></div>
<div class="paragraph"><p>Для нашої наступної проблеми ми будемо мати справу з послідовностями <code>Collatz</code>. Ми беремо натуральне число. Якщо число парне, ми ділимо його на два. Якщо воно непарне, ми множимо його на <code>3</code>, і потім додаємо <code>1</code>. Ми беремо результуюче число, та застосовуємо до нього ту саму річ, що продукує нове число, і так далі. В основі ми отримуємо ланцюжок чисел. Є думка, що для всіх початкових чисел ланцюжки закінчуються числом <code>1</code>. Так що якщо ми візьмемо початкове число <code>13</code>,ми отримаємо таку послідовність: <code>13</code>, <code>40</code>, <code>20</code>, <code>10</code>, <code>5</code>, <code>16</code>, <code>8</code>, <code>4</code>, <code>2</code>, <code>1</code>. <code>13*3 + 1</code> дорівнює <code>40</code>. <code>40</code> поділене на <code>2</code> є <code>20</code>, тощо. Ми бачимо, що ланцюжок має <code>10</code> термів.</p></div>
<div class="paragraph"><p>Те, що ми бажаємо знати, є наступним: для всіх початкових чисел між  <code>1</code> та <code>100</code>, як багато ланцюжків мають довжину, більшу ніж <code>15</code>? Спочатку ми напишемо функцію, що продукує ланцюжок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">chain</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">chain</span> <span class="mi">1</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">chain</span> <span class="n">n</span>
    <span class="o">|</span> <span class="n">even</span> <span class="n">n</span> <span class="ow">=</span>  <span class="n">n</span><span class="kt">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">odd</span> <span class="n">n</span>  <span class="ow">=</span>  <span class="n">n</span><span class="kt">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ланцюжки закінчуються на <code>1</code>, це буде граничний випадок. Це досить стандартна рекурсивна функція.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">10</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">30</span>
<span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">46</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">106</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mi">160</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау! Здається це робить коректно. І тепер функцію, що дає відповідь на наше запитання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">numLongChains</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">numLongChains</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="n">isLong</span> <span class="p">(</span><span class="n">map</span> <span class="n">chain</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]))</span>
    <span class="kr">where</span> <span class="n">isLong</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми відображуємо функцію <code>chain</code> до <code>[1..100]</code>, щоб отримати список ланцюжків, що самі представлені як списки. Потім ми фільтруємо їх предикатом, що тільки перевіряє, чи довжина більше ніж <code>15</code>. Як тільки ви виконали фільтрацію, ми бачимо, скільки ланцюжків залишилось в результуючому списку.</p></div>
<div class="paragraph"><p>Note: Ця функція має тип <code>numLongChains ::Int</code>, оскільки <code>length</code> повертає <code>Int</code> замість <code>Num</code> з історичних причин. Якщо ви бажаєте повертати більш загальне <code>Num</code>, ми можемо використати <code>fromIntegral</code> на результуючій довжині.</p></div>
<div class="paragraph"><p>Використовуючи <code>map</code>, ми також можемо робити речі, як <code>map (* ) [0..]</code>, якщо і не з іншої причини, ніж проілюструвати, як робить карування, та як (частково застосовані) функції є реальними значеннями, які ви можете передати по кругу до інших функцій, або покласти в списки (ви тільки не можете перетворити їх на рядки). Досі ми тільки відображали функції, що бере один параметр зі списку, як <code>map (* 2) [0..]</code> для отримання списку типу <code>(Num a) =&gt; [a]</code>, але ми також можемо робити <code>map (* ) [0..]</code> без проблем. Що трапиться тут, це те, що число в списку застосовується до функції <code>* `, що має тип `(Num a) =&gt; a -&gt; a -&gt; a</code>. Застосовуючи тільки один параметр до функції, що приймає два параметра, повертає функцію, що приймає один параметр . Якщо <code>* ` по списку `[0..]</code>, ми отримаємо список функцій, що приймають тільки один параметр, так що <code>(Num a) =&gt; [a -&gt; a]</code>. <code>map (* ) [0..]</code> продукує список, як такий, що ми отримаємо, написавши <code>[(0*),(1*),(2*),(3*),(4*),(5*)..</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">listOfFuns</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">listOfFuns</span> <span class="o">!!</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span>
<span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Отримавши елемент з індексом <code>4</code> з нашого списку повертаємо функцію, що еквівалентна до <code>(4*)</code>. Та потім ми просто застосовуємо 5 до цієї функції. Так що це як написати <code>(4*) 5</code>, або просто <code>4 * 5</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_">Лямбди</h3>
<div class="paragraph"><p><span class="image">
<img src="images/lambda.png" alt="images/lambda.png" />
</span>
Лямбда в основному анонімні функції, що використовуються, оскільки нам треба деякі функції тільки один раз. Звичайно ми створюємо лямбду з єдиним призначенням передати її в функцію вищого порядку. Щоб створити лямбду ми пишемо <code>\</code> (оскільки це виглядає дещо подібно на грецьку літеру лямбда, якщо придивитись досить сильно), та потім ми пишемо параметри, розділені проміжками. Після цього іде <code>-&gt;</code>, та потім тіло функції. Ми звичайно оточуємо їх в дужки, оскільки інакше вони розширюються весь час вправо.</p></div>
<div class="paragraph"><p>Якщо ви подивитесь на 5 дюймів вище, ви побачите, що ми використовували <code>where</code> прикріплення в нашій функції <code>numLongChains</code> для створення функції <code>isLong</code> для єдиного призначення передати її в фільтр. Гаразд, замість цього ми можемо використати лямбду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">numLongChains</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">numLongChains</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">chain</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбди є виразами, і ось чому ми тільки можемо передати їх таким чином. Вираз <code>(\xs -&gt; length xs &gt; 15)</code> повертає функцію, що каже нам, чи довжина списку, переданому до них, більше ніж <code>15</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lamb.png" alt="images/lamb.png" />
</span>
Люди, що не дуже знайомі з тим, як роблять карування та часткове застосування, часто використовують лямбди там, да цього не треба робити. Наприклад, вирази <code>map (+3) [1,6,3,2]</code> та <code>map (\x -&gt; x + 3) [1,6,3,2]</code> еквівалентні, оскільки обоє, <code>(+3)</code> та <code>(\x -&gt; x + 3)</code> є функціями, що приймають число, та додають до нього <code>3</code>. Не треба казати, що створення лямбди в цьому випадку є марним, оскільки використання часткового застосування значно більше читабельне.</p></div>
<div class="paragraph"><p>Як нормальні функції, лямбди можуть приймати любе число параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mf">153.0</span><span class="p">,</span><span class="mf">61.5</span><span class="p">,</span><span class="mf">31.0</span><span class="p">,</span><span class="mf">15.75</span><span class="p">,</span><span class="mf">6.6</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Та як це нормальна функція, ви можете робити в лямбді співпадіння шаблонів. Єдина різниця в тому, що ви не можете визначити декілька шаблонів для одного параметру, як зробити <code>[]</code> та <code>(x:xs)</code> шаблони для одного параметру, та потім мати значення, що провалюються. Якщо співпадіння шаблонів схибиться в лямбді, виникне помилка виконання, так що будьте уважні, коли порівнюєте шаблони в лямбдах!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбди зазвичай оточені дужками, якщо тільки ми не хочемо, щоб вони поширювались весь час вправо. Тут є дещо цікаве: через спосіб, як функції каровані по замовчанню, наступні два варіанти еквівівалентні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="nf">addThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">addThree</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо визначити функцію таким чином, стає зрозумілим, чому її декларація типу така, як вона є. Є три <code>-&gt;</code> в обох деклараціях типу і рівності. Але, звичайно, перший спосіб запису функції значно більш читабельний, другий є скоріше трюком для демонстрації карування.</p></div>
<div class="paragraph"><p>Однак є випадки, коли використання цієї нотації є крутим. Я думаю, що функція перестановки <code>flip</code> найбільш зрозуміла, коли записана таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть якщо це те саме, що і написати <code>flip' f x y = f y x</code>, ми робимо очевидним, що це буде використане для створення нової функції в більшості випадків. Найбільш загальний випадок використання для <code>flip</code> є виклик її з тільки однією функцією-параметром, та потім передати отриману функцію далі до <code>map</code> або <code>filter</code>. Так що в
икористовуйте лямбди в цей спосіб, коли ви бажаєте зробити явним, щваша функція здебільшого призначена бути частково застосованою та переданою до деякої функції як параметр.</p></div>
</div>
<div class="sect2">
<h3 id="____">Тільки кошари та коні</h3>
<div class="paragraph"><p><span class="image">
<img src="images/origami.png" alt="images/origami.png" />
</span>
Раніше, коли мали справу з рекурсією, ми зауважили лейтмотив в більшості рекурсивних функцій, що оперують зі списками. Зазвичай ми маємо граничний випадок для порожнього списку. Ми ввели шаблон <code>x:xs</code>, та потім ми виконували деяку дію, що включає один елемент та залишок списку. З'ясовується, що це дуже загальний шаблон, так що для його енкапсуляції були введені декілька функцій. Ці функції мають назву згорток <code>fold</code>. Вони є деяким різновидом функції <code>map</code>, тільки вони скорочують список до деякого одного значення.</p></div>
<div class="paragraph"><p><code>fold</code> бере двомісну функцію, початкове значення (мені подобається називати її аккумулятором) та список, що треба згорнути. Сама двомісна функція приймає два параметри. Двомісна функція викликається з акумулятором та першим (або останнім) елементом, та продукує новий акумулятор. Потім двомісна функція викликається знову з новим акумулятором та тепер новим першим (або останнім) елементом, і так далі. Коли ми пройшли по всьому списку, залишається лише аккумулятор, і це те, до чого ми скоротили список.</p></div>
<div class="paragraph"><p>Спочатку давайте поглянемо на функцію <code>foldl</code>, що також називають лівою згорткою. Вона згортає список з лівогоо боку. Двомісна функція застосовується між початковим значенням та головою списку. Це продукує нове значення аккумулятора, і двомісна фінкція викликається з цім значенням та наступним елементом, тощо.</p></div>
<div class="paragraph"><p>Давайте знову реалізуємо <code>sum</code>, тільки на цей рез через <code>fold</code> замість явної рекурсії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Тестуємо, раз-два-три:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/foldl.png" alt="images/foldl.png" />
</span>
Давайте глибоко розглянемо, як відбувається цей <code>fold</code>. <code>\acc x -&gt; acc + x</code> є двомісна функція. <code>0</code> є початкове значення, та <code>xs</code> є список, що згортається. Тепер спочатку <code>0</code> використовується як параметр <code>acc</code> до двомісної функції, та <code>3</code> використовується як параметр <code>x</code> (або поточний елемент). <code>0 + 3</code> продукує <code>3</code> і це стає новим значенням аккумулятора. На наступному кроці <code>3</code> використовується як значення аккумулятора та <code>5</code> як поточний елемент, після цього <code>8</code> стає новим значенням аккумулятора. Рухаючись далі, <code>8</code> є значенням аккумулятора, 2 поточним елементом, нове значення аккумулятора <code>10</code>. Нарешті, це <code>10</code> використовується як значення аккумулятора, <code>1</code> поточний елемент, що продукує <code>11</code>. Вітаємо, ви виконали згортання!</p></div>
<div class="paragraph"><p>Ця професійна діаграма зліва ілюструє як відбувається згортка, крок за кроком (день за днем!). Зеленувате коричневе число є значення аккумулятора. Ви можете бачити, як цей список свого роду споживається з лівого боку акумулятором. Ням-ням-нам! Якщо ви приймете до уваги, що функції каровані, ви можете записати цю реалізацію навіть більш скорочено, десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбда функція <code>(\acc x -&gt; acc + x)</code> є те саме, що <code>(+)</code>. Ми можемо уникнути параметра <code>xs</code>, оскільки виклик <code>foldl (+) 0</code> буде повертати функцію, яка приймає список. Загалом, якщо ви маєте функцію, як <code>foo a = bar b a</code>, ви можете переписати її як <code>foo = bar b</code> завдяки каруванню.</p></div>
<div class="paragraph"><p>Так чи інакше, давайте реалізуємо іншу функцію з лівим <code>fold</code> перед тим, як перейти до правих <code>fold</code>. Я впевнений, що ви всі знаєте, що `elem`перевіряє, чи значення є частиною списку, так що я не буду проходитись по цьому ще раз (я знову зробив це!). Давайте зробимо це за допомогою лівої згортки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">elem&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elem&#39;</span> <span class="n">y</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, гаразд, гаразд, що ми тут маємо? Початкове значення та аккумулятор тут логічні значення. Тип значення аккумулятора та результуючого значення завжди те саме, коли маємо справу зі згортками. Пам'ятайте, що якщо ви колись не знаєте, що використовувати як початкове значення, це дасть вам якусь ідею. Ми розпочинаємо з <code>False</code>. Має сенс використовувати <code>False</code> як стартове значення. Ми вважаємо, що того, що ми шукаємо, тут немає. Також якщо викличемо <code>fold</code> на порожньому списку, результатом буде просто стартове значення. Потім ми перевіряємо поточний елемент, чи є він те, що ми шукаємо. Якщо так, ми встановлюємо аккумулятор в <code>True</code>. Якщо ні, ми просто залишаємо аккумулятор незмінним. Якщо він до цього був <code>False</code>, він залишається таким самим, бо цей елемент не те, що треба. Якщо він був <code>True</code>, ми залишаємо його таким самим.</p></div>
<div class="paragraph"><p>Права згортка, <code>foldr</code>, робить в подібний спосіб як ліва, тільки аккумулятор з'їдає значення зправа. Також двомісна функція лівої згортки має акумулятор як перший параметр, та поточне значення як друге значення (так що <code>\acc x -&gt; ...</code>), двомісна функція правої згортки має поточне значення як перший параметр, та аккумулятор як другий (так що <code>\x acc -&gt; ...</code>). Це має деякий сенс, що права згортка має аккумулятор зправа, оскільки вона згортає з правого боку.</p></div>
<div class="paragraph"><p>Значення аккумулятора (і, таким чином, результат) згортки може бути любого типу. Це може бути число, логічне, або навіть новий список. Ми реалізуємо функцію <code>map</code> за допомогою правої згортки. Аккумулятором буде список, де ми будемо аккумулювати відображений список елемент за елементом. Виходячи з цього є очевидним, що початковим елементом буде порожній список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">map&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map&#39;</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми відображуемо <code>(+3)</code> до <code>[1,2,3]</code>, ми підходимо до списку з правого боку. Ми беремо останній елемент, що є <code>3</code>, та застосовуємо до нього функцію, що в результаті дає <code>6</code>. Потім ми ставимо його на початок аккумілятора, що був <code>[]</code>. <code>6:[]</code> є <code>[6]</code>, і це тепер значення аккумулятора. Ми застосовуємо <code>(+3)</code> до <code>2</code>, що є <code>5</code>, і ми ставимо його перед <code>(:)</code> аккумулятором, так що аккумулятор тепер <code>[5,6]</code>. Ми застосовуємо <code>(+3)</code> до <code>1</code>, і ставимо його в початок аккумілятора, так що останнє значення є <code>[4,5,6]</code>.</p></div>
<div class="paragraph"><p>Звичайно, ми могли б реалізувати цю функцію за допомогою лівої звертки, також. Це було б <code>map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</code>, але річ в тому, що функція <code>++</code> значно більш коштовна, ніж <code>:</code>, так що зазвичай використовуйте праву звертку коли будуєте нові спискі зі списків.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/washmachine.png" alt="images/washmachine.png" />
</span>
Якщо ви обертаєте список, ви можете робити праве згортання на ньому, так само як робите ліве, і навпаки. Іноді вам навіть не треба робити це. Функція <code>sum</code> може бути реалізована майже так само за допомогою правого або лівого <code>fold</code>. Одна велика різниця в тому, що права згортка робить на безкінечних списках, тоді як ліва ні! Кажучи просто, якщо ви берете безкінечний список в деякій точці, і ви згортаєте його зправа, ви з часом досягнете початку списку. Однак якщо ви візьмете безкінечний список в деякій точці, і спробуєте згорнути його зліва, ви ніколи не досягнете кінця!</p></div>
<div class="paragraph"><p>Згортки можуть бути використані в любій функції, де ви подорожуєте списком один раз, елемент за елементом, та потім повертаєте дещо на основі цього. Коли ви подорожуєте списком, та повертаєте дещо, є шанси, що ви бажаєте виконати згортку. Ось чому згортки, разом з мапами та фільтрами, одни з найкорисніших типів функцій в функціональному програмуванні.</p></div>
<div class="paragraph"><p>Функції <code>foldl1</code> та <code>foldr1</code> роблять в основному як <code>foldl</code> та <code>foldr</code>, тільки вам не треба провадити для них явне початкове значення. Вони вважають, що перший (або останній) елемент списку буде початковим значенням, та потім починає згортання з елемента, що іде за ним. Маючи це на увазі, функція <code>sum</code> може бути реалізована таким чином: <code>sum = foldl1 (+)</code>. Оскільки вони залежать від того, що списки, які згортаються, мають щонайменьше один елемент, вони призводять до помилок виконання, якщо викликаються з порожніми списками. <code>foldl</code> та <code>foldr</code>, з іншого боку, гарно роблять з порожніми списками. Коли робите згортку, подумайте про те, як це діє з порожнім списком. Якщо ваша функція не має сенсу, коли отримує порожній список, ви можливо можете використовувати <code>foldl1</code> або <code>foldr1</code> для її реалізації.</p></div>
<div class="paragraph"><p>Щоб показати, наскільки потужними є згортання, ми збираємось реалізувати декілька функцій зі стандартної бібліотеки з використанням :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">maximum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">maximum&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span>

<span class="nf">reverse&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">reverse&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="nf">product&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">product&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span>

<span class="nf">filter&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">filter&#39;</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">p</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">last&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last&#39;</span> <span class="ow">=</span> <span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>head</code> краще реалізується через порівняння шаблонів, але вона тут наведена тільки для демонстрації, ви також можете досягти того ж через згортку. Наше визначення <code>reverse'</code> досить розумне, як я думаю. Ми беремо порожній список в якості початкового значення, та потім проходимо наш список зліва, та ставимо елементи в початок нашого аккумулятора. В кінці кінців ми побудували обернений список. <code>\acc x -&gt; x : acc</code> виглядає як функція <code>:</code>, тільки параметри в іншому порядку. Ось чому ми також можемо записати <code>reverse</code> як <code>foldl (flip (:)) []</code>.</p></div>
<div class="paragraph"><p>Інший шлях змалювати праві і ліві згортки: скажімо, ми маємо праву згортку, двомісну функцію <code>f</code> та початкове значення є <code>z</code>. Якщо ми робимо праве згортання по списку <code>[3,4,5,6]</code>, ми в основному робимо таке: <code>f 3 (f 4 (f 5 (f 6 z)))</code>. <code>f</code> викликається по останньому елементу в списку та аккумулятором, її значення надається як аккумулятор аккумулятор до передостаннього значення, і так далі. Якщо ми в якості <code>f</code> беремо <code>+</code>, та початкове значення аккумулятора буде <code>0</code>, тобто отримуємо <code>3 + (4 + (5 + (6 + 0)))</code>. Або, якщо запишемо <code>+</code> як префіксну функцію, це буде <code>(+) 3 (( +) 4 (( +) 5 (( +) 6 0)))</code>. Подібно до цього, зробити ліве згортання по цьому списку з <code>g</code> в якості двомісної функції та <code>z</code> в якості аккумулятора еквівалентне до до <code>g (g (g (g z 3) 4) 5) 6</code>. Якщо ми використовуємо <code>flip (:)</code> як двомісну функцію, та <code>[]</code> як аккумулятор (так що ми обертаємо список),тоді це еквівалентно до <code>flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</code>. Та будьте впевнені, якщо ви обчислите цей вираз, ви отримаєте <code>[6,5,4,3]</code>.</p></div>
<div class="paragraph"><p><code>scanl</code> та <code>scanr</code> подібні до <code>foldl</code> та <code>foldr</code>, тільки вони доповідають всі проміжні стани аккумулятора в формі списка. Також існують <code>scanl1</code> та <code>scanr1</code>, що аналогічні до <code>foldl1</code> та <code>foldr1</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли використовуєте <code>scanl</code>, остаточний результат буде в останньому елементі результуючого списку, тоді як <code>scanr</code> буде покладати результат в голову.</p></div>
<div class="paragraph"><p>Сканування використовуються для моніторингу прогресву функції, що може бути реалізована як згортка. Давайте відповимо на запитання: як багато елементів зайняло б підсумок коренів всіх натуральних чисел, щоб перевищити <code>1000</code>? Щоб отримати корені всіх натуральних чисел ми просто робимо <code>map sqrt [1..]</code>. Тепер для отримання суми ми можемо зробити згортку, але оскільки ми зацікавлені в тому, як сума прогресує, ми збираємось зробити сканування. Як тільки ми зробимо сканування, ми побачимо, як багато сум до <code>1000</code>. Перша сума в списку буде 1, що є природним. Друга буде <code>1</code> плюс корінь квадратний від <code>2</code>. Третя додасть квадратний корінь від <code>3</code>. Якщо буде <code>X</code> сум до <code>1000</code>, тоді це займе <code>X+1</code> елементів, щоб сума перевищила <code>1000</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sqrtSums</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">sqrtSums</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">)</span> <span class="p">(</span><span class="n">scanl1</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sqrtSums</span>
<span class="mi">131</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">131</span><span class="p">])</span>
<span class="mf">1005.0942035344083</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">130</span><span class="p">])</span>
<span class="mf">993.6486803921487</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми використовуємо тут <code>takeWhile</code> замість <code>filter</code>, оскільки <code>filter</code> не робить з безкінечними списками. Навіть знаючи, що список зростає, фільтр цього не знає, так що ми використовуємо <code>takeWhile</code>, щоб відрізати список сканування до першого входження суми, більшої ніж <code>1000</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Застосування функції за допомогою $</h3>
<div class="paragraph"><p>Гараз, прийшов час поглянути на функцію <code>$</code>, також названою застосуванням функції. Спочатку подивимось, як вона визначена:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">f</span> <span class="o">$</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/dollar.png" alt="images/dollar.png" />
</span>
Що за біс? Що це за некорисний оператор? Це просто застосування функції! Гаразд, майже, але не зовсім! Тоді як нормальне застосування функції (покладання проміжку між двома речами) має дійсно високий преоритет, функція <code>$</code> має нижчий преоритет. Застосування функції з проміжком ліво-асоціативне (так що <code>f a b c</code> те саме, що і <code>( (f a) b) c))</code>, застосування функції з <code>$</code> є право-асоциативним.</p></div>
<div class="paragraph"><p>Все це дуже добре, але як це допоможе нам? Більшість часу це зручна функція, так що нам не треба писати стільки багато дужок. Розглянемо вираз <code>sum (map sqrt [1..130])</code>. Оскільки <code>$</code> має такий малий преоритет, ми можемо переписати вираз як  <code>sum $ map sqrt [1..130]</code>, зберігши свої коштовні натискання клавіш! Коли трапляється <code>$</code>, вираз зправа застосовується як параметр до функції зліва. Як щодо <code>sqrt 3 + 4 + 9</code>? Це додає разом <code>9</code>, <code>4</code>, та квадратний корінь від <code>3</code>. Якщо ми бажаємо отримати корінь від <code>3 + 4 + 9</code>, ми маємо записати <code>sqrt (3 + 4 + 9)</code>, або, якщо ми використовуємо <code>$</code>, ми можемо записати це як <code>sqrt $ 3 + 4 + 9</code>, оскільки <code>$</code> має найменьший преоритет відносно любого оператора. Ось чому ви можете уявляти <code>$</code> як різновид еквіваленту написання відкритих дужок, та потім написання закриваючих з самого правого краю виразу.</p></div>
<div class="paragraph"><p>Як щодо <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>? Гаразд, оскільки <code>$</code> є право-асоциативною, <code>f (g (z x))</code> еквівалентне до <code>f $ g $ z x</code>. Так що ми можемо переписати <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code> як <code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>.</p></div>
<div class="paragraph"><p>Але крім покладання краю дужкам <code>$</code> означає, що застосування функції можна розглядати просто як іншу функцію. Таким чином ми можемо, наприклад, відобразити застосування функції на список функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">$</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[(</span><span class="mi">4</span><span class="o">+</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="p">),</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">]</span>
<span class="p">[</span><span class="mf">7.0</span><span class="p">,</span><span class="mf">30.0</span><span class="p">,</span><span class="mf">9.0</span><span class="p">,</span><span class="mf">1.7320508075688772</span><span class="p">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___2">Композиція функцій</h3>
<div class="paragraph"><p>В математиці композиція (також відома як суперпозиція. прим. перекл.) функцій визначається так:  <code>(f . g)(x) = f(g(x))</code>, що означає, що композиція двох функцій продукує нову функцію, що, коли викликаєтья з параметром, скажімо <code>x</code>, є еквалентним до виклику <code>g</code> з параметром <code>x</code>, та потім виклику <code>f</code> з її результатом.</p></div>
<div class="paragraph"><p>В Haskell композиція функцій є гарною мірою те саме. Ми робимо композицію функції за допомогою функції <code>.</code>, що визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="o">.</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/notes.png" alt="images/notes.png" />
</span>
Подумайте про декларацію типу. <code>f</code> має приймати в якості параметра значення, що має той самий тип, що і тип повернення <code>g</code>. Так що результуюча функція бере параметр того самого типу, що бере <code>g</code>, та повертає значення того самого типу, що повертає <code>f</code>. Вираз <code>negate . (* 3)</code> повертає функцію, що приймає число, множить його на <code>3</code>, та потім змінює знак.</p></div>
<div class="paragraph"><p>Одне з використань композиції функцій є створення функцій на льоту, щоб передати в інші функції. Напевно для цього можливо використовувати лямбди, але в багатьох випадках композиція функцій ясніша та більш стисла. Скажімо, ви маєте список чисел, і ми бажаємо перетворити їх всі в від'ємні числа. Один зі способів буде отримати абсолютне значення кожного числа, та потім обернути його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">negate</span> <span class="p">(</span><span class="n">abs</span> <span class="n">x</span><span class="p">))</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте лямбду, і як це виглядає як результат композиції функцій, що ми запишемо таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">negate</span> <span class="o">.</span> <span class="n">abs</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивовижно! Композиція функцій право-асоциативна, так що ми можемо компонувати багато функцій одночасно. Вираз <code>f (g (z x))</code> еквівалентний до <code>(f . g . z) x</code>. Маючи це на думці, ми можемо перетворити</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">negate</span> <span class="p">(</span><span class="n">sum</span> <span class="p">(</span><span class="n">tail</span> <span class="n">xs</span><span class="p">)))</span> <span class="p">[[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">27</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>на</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">negate</span> <span class="o">.</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">tail</span><span class="p">)</span> <span class="p">[[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">27</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Але щодо функцій, що приймають декілька параметрів? Гаразд, якщо ми бажаємо використовувати їх в композиції функцій, ми маємо частково застосувати їх, тільки в тій мірі, щоб кожна функція приймала один параметр. <code>sum (replicate 5 (max 6.7 8.9))</code> може бути переписана як <code>(sum . replicate 5 . max 6.7) 8.9</code> або як <code>sum . replicate 5 . max 6.7 $ 8.9</code>. Ось що тут відбувається: створюється функція, що приймає <code>max 6.7</code> бере та застосовує <code>replicate 5</code> до цього. Потім створюється функція, що бере результат від того, та робить суму. Нарешті ця функція викликається з <code>8.9</code>. Але звичайно ви читаєте це просто так: застосувати <code>8.9</code> до <code>max 6.7</code>, потім застосувати <code>replicate 5</code> до цього, та потім застосувати <code>sum</code> до отриманого. Якщо ви бажаєте записати вираз з багатьма дужками через композицію функцій, ви можете почати з покладання останнього параметра самої внутрішньої функції після <code>$</code>, та потім скомпонувати всі інші виклики функцій, записуючи їх без останнього параметру, та ставлячи між ними крапку. Якщо ви маєте <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>, ви можете записати це як <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>. Якщо вираз завершується на три дужки, є шанси що після трансляції в композицію функцій це буде мати три оператори композиції.</p></div>
<div class="paragraph"><p>Інше загальне використання композиції функцій є визначення функцій в так званому стилі вільних крапок (також називається безглуздим стилем). Візьміть для прикладу цю функцію, що ми записали раніше :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p><code>xs</code> з'являється з обох боків. Завдяки каруванню ми можемо уникнути <code>xs</code> з обох боків, оскільки <code>foldl (+) 0</code> створює функцію, що приймає список. Запис функції як <code>sum' = foldl (+) 0</code> називається запис в стилі вільних крапок. Як ми повинні писати в цьому стилі?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fn</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">ceiling</span> <span class="p">(</span><span class="n">negate</span> <span class="p">(</span><span class="n">tan</span> <span class="p">(</span><span class="n">cos</span> <span class="p">(</span><span class="n">max</span> <span class="mi">50</span> <span class="n">x</span><span class="p">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо просто позбутись від <code>x</code> з обох боків. <code>x</code> в тілі функції має дужки за собою. <code>cos (max 50)</code> не матиме сенсу. Ви не можете взяти косінус від функції. Що ми можете зробити, це виразити <code>fn</code> як композицію функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fn</span> <span class="ow">=</span> <span class="n">ceiling</span> <span class="o">.</span> <span class="n">negate</span> <span class="o">.</span> <span class="n">tan</span> <span class="o">.</span> <span class="n">cos</span> <span class="o">.</span> <span class="n">max</span> <span class="mi">50</span>
</pre></div></div></div>
<div class="paragraph"><p>Чудово! В багатьох випадках цей стиль більш читабельний та стислий,оскікльки він дає вам мислити щодо функцій і який тип функцій компонується для отримання результату, замість того, щоб думати про дані і як вони тусуються між собою. Ви можете брати прості функції та використовувати композицію як клей, щоб формувати більш складні функції. Однак в багатьох випадках написання функції в крапках може бути меньш читабельним, якщо функція дуже складна. Ось чому робити довгі ланцюжки з композиції функцій не заохочується, але я визнаю себе винним, що іноді буваю композиціє-щасливим. Бажаний стиль є використання <code>let</code> прив'язок для отримання міток для проміжних результатів, або розділення проблеми на суб-проблеми, та потім збирання їх разом, так щоб функція мала сенс для декого, хто читає її, замість того, щоб робити гігантський ланцюг композиції.</p></div>
<div class="paragraph"><p>В розділі про мапи та фільтри ми вирішили проблему пошуку суми з усіх непарних квадратів, що меньше за <code>10000</code>. Ось як виглядає рішення, коли воно покладено в функцію.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">odd</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span>
</pre></div></div></div>
<div class="paragraph"><p>Будучи таким фанатом композиції функцій, я міг би можливо записати це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">.</span> <span class="n">filter</span> <span class="n">odd</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо є шанси, що хтось інший буде читати цей код, я б переписав це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">oddSquares</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
        <span class="n">belowLimit</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="n">oddSquares</span>
    <span class="kr">in</span>  <span class="n">sum</span> <span class="n">belowLimit</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не виграє змагання з кодового гольфу, але дехто читаючи цю функцію винайде її читання простіше, ніж ланцюжок композицій.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-08-27 22:32:46 EEST
</div>
</div>
</body>
</html>
