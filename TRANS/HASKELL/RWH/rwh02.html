<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Глава 2. Типи та функції</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Глава 2. Типи та функції</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="____">Навіщо дбати про типи?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кожний вираз та функція в Haskell має тип. Наприклад, значення <code>True</code> має тип <code>Bool</code>, тоді як значення <code>"foo"</code> має тип <code>String</code>. Тип значення вказує на те, що воно поділяє певні властивості з іншими значеннями того ж типу. Наприклад, ми можемо додавати числа, і ми можемо об'єднати списки; це властивості цих типів. Ми говоримо, що вираз "має тип X", або "є типу X".</p></div>
<div class="paragraph"><p>Перш ніж ми розпочнемо більш глибоке обговорення системи типів Haskell, давайте поговоримо про те, чому ми взагалі повинні дбати про типи: для чого вони взагалі? На найнижчому рівні комп'ютер займається байтами, майже без будь-якої додаткової структури. Що нам дає система типів - це абстракція. Тип додає значення простим байтам: він дозволяє нам говорити "ці байти - це текст", "ці байти - це резервація авіа квитків" тощо. Зазвичай система типів не обмежується цім, щоб запобігти випадковому змішанню типів: наприклад, система типів зазвичай не дозволяє нам розглядати бронювання готелів як квитанцію на прокат автомобіля.</p></div>
<div class="paragraph"><p>Перевага введення абстракції полягає в тому, що вона дозволяє нам забувати або ігнорувати деталі низького рівня. Якщо я знаю, що значення в моїй програмі - це рядок, я не повинен знати прихованих деталей того, як реалізуються рядки: я можу просто припустити, що мій рядок буде вести себе, як і всі інші рядки, з якими я працював.</p></div>
<div class="paragraph"><p>Що робить системи типів цікавими, це те, що вони не всі однакові. Насправді різні системи типу часто навіть не стосуються одних і тих же проблем. Система типів мови програмування глибоко забарвлює те, як ми думаємо і пишемо код цією мовою.</p></div>
<div class="paragraph"><p>Система типів Haskell дозволяє нам мислити на дуже абстрактному рівні: це дозволяє нам писати стислі, потужні програми.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___haskell">Система типів Haskell</h2>
<div class="sectionbody">
<div class="paragraph"><p>Існує три цікавих аспекти до типів Haskell: вони <em>сильні</em>, вони <em>статичні</em>, і вони можуть <em>виводитись</em> автоматично. Давайте поговоримо докладніше про кожну з цих ідей. Коли це можливо, ми представимо схожість між поняттями із системи типів Haskell та спорідненими ідеями в інших мовах. Ми також торкнемося сильних і слабких сторін кожної з цих властивостей.</p></div>
<div class="sect2">
<h3 id="__">Сильні типи</h3>
<div class="paragraph"><p>Коли ми говоримо, що у Haskell є сильна система типів, ми маємо на увазі, що система типу гарантує, що програма не може містити певні помилки. Ці помилки виникають при спробі запису виразів, які не мають сенсу, як використання цілого числа в якості функції. Наприклад, якщо функція розраховує працювати з цілими числами, і ми передамо їй рядок, компілятор Haskell відкине це.</p></div>
<div class="paragraph"><p>Ми називаємо вираз, який підкоряється правилам типів мови, які добре типізований. Вираз, який не дотримується правил типу, хворобливо типізований і спричинить помилку типу.</p></div>
<div class="paragraph"><p>Ще один аспект погляду Haskell на сильну типізацію полягає в тому, що він автоматично не примушує значення від одного типу до іншого. (Примус також відомий як кастинг або конверсія.) Наприклад, компілятор C автоматично і безшумно примушує значення типу <code>int</code> в <code>float</code> від нашого імені, якщо функція очікує параметр типу <code>float</code>. Але компілятор Haskell підніме помилку компіляції в подібній ситуації. Ми повинні явно перетворювати типи, застосовуючи функції конверсії.</p></div>
<div class="paragraph"><p>Сильна типізація іноді ускладнює написання певних видів коду. Наприклад, класичним способом написання коду низького рівня мовою C є надання байтового масиву та передача його для обробки байтів так, ніби вони справді є складною структурою даних. Це дуже ефективно, оскільки не вимагає від нас копіювання байтів по колу. Система типів Haskell не допускає такого роду примусу. Для того, щоб отримати однаковий структурований вигляд даних, нам потрібно було б виконати деяке копіювання, що коштувало б небагато продуктивності.</p></div>
<div class="paragraph"><p>Величезна перевага сильної типізації полягає в тому, що вона вловлює справжні помилки в нашому коді, перш ніж вони можуть викликати проблеми. Наприклад, в сильно типізованій мові ми не можемо випадково використати рядок, де очікується ціле число.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Cлабкіші та міцніші типи</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Корисно усвідомлювати, що у багатьох мовних спільнотах є свої визначення "сильного типу". Тим не менш, ми будемо говорити коротко і загалом про поняття міцності в типах систем.</td>
</tr></table>
</div>
<div class="paragraph"><p>В академічній інформатиці значення "сильний" і "слабкий" мають вузько технічне значення: сила означає те, наскільки вседозволена система типу. Система слабшого типу трактує більше виразів як дійсні, ніж система сильнішого типу.</p></div>
<div class="paragraph"><p>Наприклад, в Perl вираз <code>"foo" + 2</code> оцінюється до числа <code>2</code>, але вираз <code>"13foo" + 2</code> оцінює до числа <code>15</code>. Haskell відкидає обидва вирази як недійсні, оскільки оператор (<code>+</code>) вимагає від обох своїх операндів, щоб це були числа. Оскільки система типів Perl є більш дозвольною, ніж у Haskell, ми говоримо, що вона слабша при цій вузькій технічній інтерпретації.</p></div>
<div class="paragraph"><p>Феєрверки навколо систем типів мають своє коріння у звичайній англійській мові, де люди надають поняття цінності словам "слабкий" та "сильний": ми зазвичай думаємо про силу як кращу, ніж про слабкість. Значно більше програмістів говорять простою англійською мовою, ніж академічним жаргоном, і досить часто вчені <em>дійсно</em> кидають цеглини по будь-якому типові системи, який не відповідає їх фантазії. Результатом цього є часто популярне Інтернет-дозвілля, вогняні війни.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="___2">Статичні типи</h3>
<div class="paragraph"><p>Наявність системи <em>статичної</em> типізації означає, що компілятор знає тип кожного значення та виразу під час компіляції, перш ніж будь-який код буде виконаний. Компілятор або інтерпретатор Haskell виявить, коли ми намагаємось використовувати вирази, типи яких не відповідають один одному, і відхилить наш код із повідомленням про помилку перед тим, як запустити його.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;false&quot;</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">8</span><span class="kt">:</span>
    <span class="kt">Couldn&#39;t</span> <span class="n">match</span> <span class="n">expected</span> <span class="kr">type</span> <span class="p">`</span><span class="kt">Bool&#39;</span> <span class="n">against</span> <span class="n">inferred</span> <span class="kr">type</span> <span class="p">`[</span><span class="kt">Char</span><span class="p">]</span><span class="sc">&#39;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">second</span> <span class="n">argument</span> <span class="kr">of</span> <span class="p">`(</span><span class="o">&amp;&amp;</span><span class="p">)</span><span class="sc">&#39;</span><span class="err">, namely `&quot;false</span><span class="sc">&quot;&#39;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;false&quot;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">definition</span> <span class="kr">of</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;false&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це повідомлення про помилку є таким, яке ми бачили раніше. Компілятор зробив висновок, що тип виразу <code>"false"</code> є <code>[Char]</code>. Оператор (<code>&amp;&amp;</code>) вимагає, щоб кожен його операнд був типом <code>Bool</code>, і його лівий операнд дійсно має такий тип. Оскільки фактичний тип <code>"false"</code> не відповідає потрібному типу, компілятор відкидає цей вираз як хворобливо типізований.</p></div>
<div class="paragraph"><p>Статична типізація може інколи ускладнювати написання деяких корисних видів коду. У таких мовах, як Python, поширена "качина типізація", коли об'єкт діє достатньо подібно до іншого, щоб використовувати його як заміну.<span class="footnote"><br />["Якщо вона ходить, як качка, і хитається, як качка, тоді давайте назвемо її качкою".]<br /></span> На щастя, система типових класів Haskell, яку ми розглянемо в главі 6, <strong><em>Використовуючи типокласи</em></strong>, забезпечує майже всі переваги динамічної типізації в безпечній та зручній формі. Haskell має певну підтримку програмування з по-справжньому динамічними типами, хоча це не так просто, як у мові, яка від щирого серця сприймає це поняття.</p></div>
<div class="paragraph"><p>Поєднання в Haskell сильної та статичної типізації унеможливлює виникнення помилок типу під час виконання. Хоча це означає, що нам потрібно трохи більше подумати «наперед», але це також усуває багато простих помилок, які в іншому випадку може бути важко знайти. Загальна думка в колах спільноти Haskell: якщо вже код компілюється, шанси що він буде працювати правильно більші, ніж в інших мовах. (Можливо, більш реалістичним способом сформулювати це є те, що у коді Haskell часто менше тривіальних помилок.)</p></div>
<div class="paragraph"><p>Програми, написані на динамічно типізованих мовах, вимагають великих тестових наборів, щоб дати певну впевненість у тому, що прості помилки типу не можуть виникнути. Тестові набори не можуть забезпечити повне висвітлення: деякі поширені завдання, такі як рефакторинг програми щоб зробити її більш модульною, можуть вводити нові помилки типу, які тестовий набір може не помітити.</p></div>
<div class="paragraph"><p>У Haskell компілятор доводить відсутність помилок типу для нас: програма Haskell, яка компілюється, не постраждає від помилок типу під час її запуску. Рефакторинг, як правило, означає переміщення коду, а потім перекомпіляцію та прибирання декілька разів, поки компілятор не видасть нам "все чисто".</p></div>
<div class="paragraph"><p>Корисною аналогією, щоб зрозуміти значення статичної типізації, є дивитися на це як на складання шматочків у головоломку. У Haskell, якщо шматок має неправильну форму, він просто не поміститься. У динамічно типізованій мові всі фрагменти є квадратами 1х1 і завжди підходять, тому вам доведеться постійно вивчати отриману картинку і перевіряти (через тестування), чи все правильно.</p></div>
</div>
<div class="sect2">
<h3 id="___3">Вивід типів</h3>
<div class="paragraph"><p>Нарешті, компілятор Haskell може автоматично виводити типи майже всіх виразів програми.<span class="footnote"><br />[Інколи нам потрібно надати компілятору трохи інформації, щоб допомогти йому зробити вибір у розумінні нашого коду.]<br /></span> Цей процес відомий як вивід типу. Haskell дозволяє нам чітко оголосити тип будь-якого значення, але наявність виводу типу означає, що це майже завжди необов'язково, а не те, що нам потрібно дещо робити.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____">Чого очікувати від системи типів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Our exploration of the major capabilities and benefits of Haskell&#8217;s type system will span a number of chapters. Early on, you may find Haskell&#8217;s types to be a chore to deal with.
Наше вивчення основних можливостей та переваг системи типів Haskell охопить низку глав. На початку ви можете виявити, що типи в Haskell - це те, з чим ви матимете справу постійно.</p></div>
<div class="paragraph"><p>Наприклад, замість того, щоб просто написати якийсь код і запустити його, щоб побачити, чи він працює, як ви могли очікувати в Python або Ruby, спочатку потрібно переконатися, що ваша програма проходить перевірку типу. Навіщо дотримуватися кривої навчання?</p></div>
<div class="paragraph"><p>В той час, коли сильна статична типізація робить Haskell безпечним, вивід типу робить його стислим. Результат є потужним: ми отримуємо мову, яка є і безпечнішою, ніж популярні статично типізовані мови, і часто більш виразною, ніж динамічно типізовані мови. Це є сильною заявою, і ми підкріпимо це доказами у всій книзі.</p></div>
<div class="paragraph"><p>Виправлення помилок типу може спочатку відчуватись як більша робота, ніж коли ви використовували динамічну мову. Тут може допомогти погляд на це, як на переміщення більшої частини налагодження вперед. Компілятор показує вам багато логічних недоліків у вашому коді, а не залишає вас натрапляти на проблеми під час виконання.</p></div>
<div class="paragraph"><p>Крім того, оскільки Haskell може виводити типи ваших виразів і функцій, ви отримуєте переваги статичної типізації без додаткового тягаря "набору пальцем", що накладається менш потужними статично типізованими мовами. В інших мовах система типів обслуговує потреби компілятора. У Haskell вона обслуговує вас. Компроміс полягає в тому, що ви повинні навчитися працювати в рамках, який вона надає.</p></div>
<div class="paragraph"><p>Ми будемо вводити нові використання типів Haskell у цій книзі, щоб допомогти нам написати та перевірити практичний код. Як результат, повна картина того, чого варта система типів, з'явиться поступово. Хоча кожен крок повинен виправдовувати себе, цілий результат виявиться більшим, ніж сума його частин.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_____2">Деякі поширені основні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>У розділі «Перші кроки з типами» ми представили кілька типів. Ось ще кілька найпоширеніших базових типів.</p></div>
<div class="ulist"><ul>
<li>
<p>
Значення <code>Char</code> представляє символ Unicode.
</p>
</li>
<li>
<p>
Значення <code>Bool</code> представляє логічні значення. Можливі значення типу <code>Bool</code> є <code>True</code> та <code>False</code>.
</p>
</li>
<li>
<p>
Тип <code>Int</code> використовується для знакових цілих значень з фіксованою шириною. Точний діапазон значень, представлених як <code>Int</code>, залежить від найдовшого «рідного» цілого системи: на 32-бітній машині <code>Int</code> зазвичай становить 32 біти в ширину, тоді як на 64-бітній машині зазвичай шириною 64 біт. Стандарт Haskell гарантує лише, що <code>Int</code> ширший, ніж 28 біт. (Існують числові типи, які точно дорівнюють 8, 16 і т.п. в ширину, в знакових та беззнакових варіантах; ми дістанемося до них пізніше.)
</p>
</li>
<li>
<p>
Значення <code>Integer</code> - це знакове ціле число необмеженого розміру. Цілі <code>Integer</code> використовуються не так часто, як <code>Int</code>, оскільки вони дорожчі як за продуктивністю, так і за споживанням місця. З іншого боку, обчислення <code>Integer</code> мовчки не переповнюються, тому вони дають більш достовірні правильні відповіді.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Values of type Double are used for floating point numbers. A Double value is typically 64 bits wide, and uses the system&#8217;s native floating point representation. (A narrower type, Float, also exists, but its use is discouraged; Haskell compiler writers concentrate more on making Double efficient, so Float is much slower.)
Значення типу <code>Double</code> використовуються для чисел з плаваючою комою. Подвійне значення, як правило, шириною 64 біт і використовує нативне представлення системи з плаваючою точкою. (Більш вузький тип, <code>Float</code>, також існує, але його використання не рекомендується; автори компілятора Haskell зосереджуються більше на тому, щоб зробити ефективнішим <code>Double</code>, тому <code>Float</code> набагато повільніший.)</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
We have already briefly seen Haskell&#8217;s notation for types in the section called “First steps with types”. When we write a type explicitly, we use the notation expression :: MyType to say that expression has the type MyType. If we omit the 
</dt>
<dd>
<p>
and the type that follows, a Haskell compiler will infer the type of the expression.
Ми вже коротко бачили нотацію Haskell для типів у розділі "Перші кроки з типами". Коли ми пишемо тип явно, ми використовуємо нотацію виразу <code>::MyType</code>, щоб сказати, що вираз має тип <code>MyType</code>. Якщо опустити <code>::</code> і тип, що іде за ним, компілятор Haskell сам зробить висновок про тип виразу.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="sc">&#39;a&#39;</span>
<span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Int</span>

<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">Couldn&#39;t</span> <span class="n">match</span> <span class="n">expected</span> <span class="kr">type</span> <span class="p">`</span><span class="kt">Int&#39;</span> <span class="n">against</span> <span class="n">inferred</span> <span class="kr">type</span> <span class="p">`[</span><span class="n">a</span><span class="p">]</span><span class="sc">&#39;</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Int</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">definition</span> <span class="kr">of</span> <span class="p">`</span><span class="n">it&#39;</span><span class="kt">:</span> <span class="n">it</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>Поєднання <code>::</code> та типу після нього називається сигнатурою типу.</p></div>
<div class="sect2">
<h3 id="___4">Застосування функції</h3>
<div class="paragraph"><p>Тепер, коли ми витратили деякий час на типи даних, давайте звернемо свою увагу на роботу з деякими типами, які ми бачили, використовуючи функції.</p></div>
<div class="paragraph"><p>Щоб застосувати функцію в Haskell, ми записуємо ім'я функції, а потім її аргументи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">odd</span> <span class="mi">3</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">odd</span> <span class="mi">6</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не використовуємо дужки або коми для групування або розділення аргументів функції; достатньо лише написання назви функції з наступним кожним аргументом по черзі. Як приклад, застосуємо функцію порівняння, яка бере два аргументи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">compare</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">compare</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="kt">EQ</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">compare</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви звикли до синтаксису викликів функцій в інших мовах, може знадобитись звикання до цього позначення, але це просто і узгоджено.</p></div>
<div class="paragraph"><p>Застосування функції має більшу перевагу, ніж використання операторів, тому наступні два вирази мають те саме значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">compare</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="kt">LT</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">compare</span> <span class="mi">2</span> <span class="mi">3</span> <span class="o">==</span> <span class="kt">LT</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Вищезгадані дужки не приносять шкоди, але вони додають певного візуального шуму. Однак іноді ми повинні використовувати дужки, щоб вказати, щоб складний вираз був розібраний як ми хочемо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">compare</span> <span class="p">(</span><span class="n">sqrt</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="n">sqrt</span> <span class="mi">6</span><span class="p">)</span>
<span class="kt">LT</span>
</pre></div></div></div>
<div class="paragraph"><p>Це стосується порівняння з результатами застосування <code>sqrt 3</code> та <code>sqrt 6</code> відповідно. Якщо ми опустимо дужки, схоже, ми намагаємось порівняти чотири аргументи, замість прийнятних двох.</p></div>
</div>
<div class="sect2">
<h3 id="_______">Корисні складені типи даних: списки та кортежі</h3>
<div class="paragraph"><p>Складений тип даних будується з інших типів. Найпоширеніші складові типи даних у Haskell - це списки та кортежі.</p></div>
<div class="paragraph"><p>Ми вже бачили тип списку, згаданий у розділі «Рядки та символи», де ми виявили, що Haskell представляє текстовий рядок як список значень <code>Char</code>, а тип «список <code>Char»</code> записаний <code>[Char]</code>.</p></div>
<div class="paragraph"><p>Функція <code>head</code> повертає перший елемент списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">]</span>
<span class="sc">&#39;a&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Його протилежність, <code>tail</code>, повертає всіх, окрім голови списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="kt">False</span><span class="p">]</span>
<span class="p">[</span><span class="kt">False</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="s">&quot;list&quot;</span>
<span class="s">&quot;ist&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">tail</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
</pre></div></div></div>
<div class="paragraph"><p>Як бачите, ми можемо застосувати <code>head</code> та <code>tail</code> до списків різних типів. Застосовуючи <code>head</code> до значення <code>[Char]</code>, повертає значення <code>Char</code>, а застосовуючи її до <code>[Bool]</code>, повертає значення <code>Bool</code>. Функції <code>head</code> неважливо, яким типом списку вона займається.</p></div>
<div class="paragraph"><p>Оскільки значення у списку можуть мати будь-який тип, тип списку ми називаємо поліморфним.<span class="footnote"><br />[Ми розповімо більше про поліморфізм у розділі «Поліморфізм у Haskell».]<br /></span> Коли ми хочемо написати поліморфний тип, ми використовуємо змінну типу, яка повинна починатися з малої літери. Змінна типу - це заповнення місця, яке врешті-решт ми замінимо на реальний тип.</p></div>
<div class="paragraph"><p>Ми можемо записати тип "список <code>a</code> ", додавши змінну типу у квадратні дужки: <code>[a]</code>. Це означає: "Мені все одно, який у мене тип; Я можу скласти список цього типу".</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Визначення назв типів та змінних типів</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Тепер ми можемо зрозуміти, чому ім’я типу має починатися з великої літери: це відрізняє його від змінної типу, яка повинна починатися з малої літери.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>Коли ми говоримо про список зі значеннями певного типу, ми підміняємо цей тип нашою змінною типу. Так, наприклад, тип <code>[Int]</code> - це список значень типу <code>Int</code>, оскільки ми підставили <code>Int</code> замість <code>a</code>. Аналогічно, тип <code>[MyPersonalType]</code> - це список значень типу <code>MyPersonalType</code>. Ми також можемо виконувати цю заміну рекурсивно: <code>[[Int]]</code> - це список значень типу <code>[Int]</code>, тобто список списків <code>Int</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">[[</span><span class="kt">True</span><span class="p">],[</span><span class="kt">False</span><span class="p">,</span><span class="kt">False</span><span class="p">]]</span>
<span class="p">[[</span><span class="kt">True</span><span class="p">],[</span><span class="kt">False</span><span class="p">,</span><span class="kt">False</span><span class="p">]]</span> <span class="ow">::</span> <span class="p">[[</span><span class="kt">Bool</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип цього виразу - це список списків <code>Bool</code>.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Списки особливі</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Списки - це «хліб з маслом» колекцій Haskell. Імперативною мовою ми можемо виконати завдання для багатьох елементів, повторивши цикл. Це те, що ми часто робимо в Haskell шляхом перебігу по списку, або шляхом рекурсії, або за допомогою функції, яка містить рекурсію. Списки є найпростішим кроком до ідеї, що ми можемо використовувати дані для структурування нашої програми та її потоку управління. Ми витратимо набагато більше часу на обговорення списків у Розділі 4, <strong><em>Функціональне програмування</em></strong>.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>Кортеж - це колекція значень фіксованого розміру, де кожне значення може мати різний тип. Це відрізняє їх від списку, який може мати будь-яку довжину, але елементи якого повинні мати один і той же тип.</p></div>
<div class="paragraph"><p>Щоб допомогти зрозуміти різницю, скажімо, ми хочемо відстежити дві частини інформації про книгу. Він має рік видання, який є числом, і заголовок, який є рядком. Ми не можемо зберегти обидві ці відомості у списку, оскільки вони мають різні типи. Натомість ми використовуємо кортеж.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1964</span><span class="p">,</span> <span class="s">&quot;Labyrinths&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1964</span><span class="p">,</span><span class="s">&quot;Labyrinths&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми пишемо кортеж, додаючи його елементи в дужки і відокремлюючи їх комами. Ми використовуємо те саме позначення для написання його типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;m&#39;</span><span class="p">],</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="kt">True</span><span class="p">))</span>
<span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;am&quot;</span><span class="p">,(</span><span class="mi">16</span><span class="p">,</span><span class="kt">True</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує особливий тип, <code>()</code>, який виконує функцію кортежу з нуля елементів. Цей тип має лише одне значення, також записане <code>()</code>. І тип, і значення зазвичай вимовляються "юніт". Якщо ви знайомі з C, <code>()</code> дещо схожий на <code>void</code>.</p></div>
<div class="paragraph"><p>У Haskell немає поняття про одноелементний кортеж. Кортежі часто посилаються на використання кількості елементів як префікса. 2-кортеж має два елементи, і його зазвичай називають парою. "3-кортеж" (іноді його називають трійкою) має три елементи; 5-кортеж має п'ять; і так далі. На практиці робота з кортежами, які містять більше декількох елементів, робить код непростим, тому кортежі з більше ніж кількох елементів використовуються рідко.</p></div>
<div class="paragraph"><p>Тип кортежу представляє число, положення та типи його елементів. Це означає, що кортежі, що містять різні числа або типи елементів, мають різні типи, як і кортежі, типи яких з'явлються в різному порядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Char</span><span class="p">,</span> <span class="kt">Bool</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі вираз <code>(False, 'a')</code> має тип <code>(Bool, Char)</code>, який відрізняється від типу <code>('a', False)</code>. Незважаючи на те, що кількість елементів та їх типи однакові, ці два типи є різними, оскільки положення типів елементів є різними.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">False</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей тип <code>(Bool, Char, Char)</code> відрізняється від <code>(Bool, Char)</code>, оскільки містить три елементи, а не два.</p></div>
<div class="paragraph"><p>Ми часто використовуємо кортежі, щоб повернути кілька значень з функції. Ми також можемо використовувати їх у будь-який час, коли нам потрібна колекція значень фіксованого розміру, якщо обставини не вимагають спеціального типу контейнера.</p></div>
</div>
<div class="sect2">
<h3 id="_">Вправи</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Які типи наведених виразів?
</p>
<div class="ulist"><ul>
<li>
<p>
<code>False</code>
</p>
</li>
<li>
<p>
<code>(["foo", "bar"], 'a')</code>
</p>
</li>
<li>
<p>
<code>[(True, []), (False, [['a']])]</code>
</p>
</li>
</ul></div>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="______2">Функції над списками та кортежами</h2>
<div class="sectionbody">
<div class="paragraph"><p>У нашому обговоренні списків і кортежів згадувалося, як ми можемо їх побудувати, але мало про те, як ми з ними щось робити. Нам до цього часу були представлені лише дві функції списку, <code>head</code> та <code>tail</code>.</p></div>
<div class="paragraph"><p>A related pair of list functions, take and drop, take two arguments. Given a number n and a list, take returns the first n elements of the list, while drop returns all but the first n elements of the list. (As these functions take two arguments, notice that we separate each function and its arguments using white space.)
Пов’язана пара функцій списку: <code>take</code> і <code>drop</code>, беруть два аргументи. Маючи число <code>n</code> та список, <code>take</code> повертає перших <code>n</code> елементів списку, тоді як <code>drop</code> повертає всі, крім перших <code>n</code> елементів списку. (Оскільки ці функції беруть два аргументи, зауважте, що ми розділяємо кожну функцію та її аргументи, використовуючи пробіл).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">2</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">`</span><span class="n">drop</span><span class="p">`</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Для кортежів функції <code>fst</code> і <code>snd</code> повертають перший і другий елементи пари відповідно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="sc">&#39;a&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ваш досвід походить з деяких інших мов, все це може виглядати як застосування функції до двох аргументів. Згідно з домовленостями Haskell для застосування функції, кожен є додатком функції до однієї пари.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Haskell кортежі не є незмінними списками</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Якщо ви прийшли зі світу Python, ви, ймовірно, приймали як факт, що списки та кортежі були майже взаємозамінними. Хоча елементи кортежу Python незмінні, його можна індексувати та ітерувати, використовуючи ті самі методи, що і для списку. У Haskell це не так, тому не намагайтеся перенести цю ідею на незнайому мовну територію.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>As an illustration, take a look at the type signatures of fst and snd: they&#8217;re defined only for pairs, and can&#8217;t be used with tuples of other sizes. Haskell&#8217;s type system makes it tricky to write a generalised “get the second element from any tuple, no matter how wide” function.
Як ілюстрацію, погляньте на сигнатури типів <code>fst</code> і <code>snd</code>: вони визначені лише для пар, і їх не можна використовувати з кортежами інших розмірів. Система типу Haskell ускладнює написання узагальненої функції "отримати другий елемент з будь-якого кортежу, незалежно від його розміру".</p></div>
<div class="sect3">
<h4 id="___">Передача виразу функції</h4>
<div class="paragraph"><p>У Haskell застосування функції є ліво асоціативною. Найкраще це проілюстровано прикладом: вираз <code>a b c d</code> еквівалентно <code>(((a b) c) d)</code>. Якщо ми хочемо використовувати один вираз як аргумент в іншому, ми повинні використовувати явні дужки, щоб сказати аналізатору, що ми насправді маємо на увазі. Ось приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">(</span><span class="n">drop</span> <span class="mi">4</span> <span class="s">&quot;azerty&quot;</span><span class="p">)</span>
<span class="sc">&#39;t&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо читати це як "передайте вираз <code>drop 4 "azerty"</code> як аргумент до <code>head</code>. Якби ми не залишили дужки, вираз був б подібний до передачі трьох аргументів до <code>head</code>. Компіляція не вдалася б із помилкою типу, оскільки для <code>head</code> потрібен єдиний аргумент, список.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____3">Типи функцій та чистота</h2>
<div class="sectionbody">
<div class="paragraph"><p>Давайте розглянемо тип функції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">lines</span>
<span class="nf">lines</span> <span class="ow">::</span><span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо читати <code>-&gt;</code> вище як "до", що умовно перекладається як "повертає". Таким чином, підпис в цілому читається як "<code>“lines</code> має тип <code>String</code> до список-зі-<code>String</code>". Спробуємо застосувати функцію.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">&quot;the quick</span><span class="se">\n</span><span class="s">brown fox</span><span class="se">\n</span><span class="s">jumps&quot;</span>
<span class="p">[</span><span class="s">&quot;the quick&quot;</span><span class="p">,</span><span class="s">&quot;brown fox&quot;</span><span class="p">,</span><span class="s">&quot;jumps&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>lines</code> розбиває рядок на межі рядків. Зауважте, що її сигнатура типу надає нам підказку щодо того, що ця функція насправді може виконувати: вона приймає один рядок і повертає багато. Це неймовірно цінна властивість типів у функціональній мові.</p></div>
<div class="paragraph"><p>Побічний ефект вводить залежність між глобальним станом системи та поведінкою функції. Наприклад, давайте на мить відійдемо від Haskell і подумаємо про імперативну мову програмування. Розглянемо функцію, яка зчитує та повертає значення глобальної змінної. Якщо якийсь інший код може змінити цю глобальну змінну, то результат конкретного застосування нашої функції залежить від поточного значення глобальної змінної. Функція має побічний ефект, хоча вона ніколи не змінює саму змінну.</p></div>
<div class="paragraph"><p>Побічні ефекти - це по суті невидимі входи до функцій або виходи з них. У Haskell за замовчуванням функції не мають побічних ефектів: результат функції залежить лише від входів, які ми явно надаємо. Ці функції ми називаємо чистими; функції з побічними ефектами нечисті.</p></div>
<div class="paragraph"><p>Чи функція має побічні ефекти, ми можемо сказати, прочитавши її підпис типу: тип результату функції розпочнеться з IO.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">readFile</span>
<span class="nf">readFile</span> <span class="ow">::</span> <span class="kt">FilePath</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Система типу Haskell не дозволяє нам випадково змішати чистий і нечистий код.</p></div>
<div class="sect2">
<h3 id="___haskell____">Вихідні файли Haskell та написання простих функцій</h3>
<div class="paragraph"><p>Тепер, коли ми знаємо, як застосувати функції, саме час звернути свою увагу на їх написання. Хоча ми можемо писати функції в ghci, це не сприятливе середовище для цього. Він приймає лише сильно обмежену підмножину Haskell: і головне, що синтаксис, який він використовує для визначення функцій, не такий, як ми використовуємо у вихідному файлі Haskell.<span class="footnote"><br />[Середовище, в якому діє ghci, називається монадою IO. У розділі 7 I/O ми висвітлимо монаду IO докладно, і, здавалося б, довільні обмеження, які ghci накладає на нас, матимуть більше сенсу.]<br /></span> Натомість ми нарешті зламаємо стереотип і створимо вихідний файл.</p></div>
<div class="paragraph"><p>Вихідні файли Haskell зазвичай ототожнюються із суфіксом <strong>.hs</strong>. Ось просте визначення функції: відкрийте файл з назвою <code>add.hs</code> і додайте до нього цей вміст.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch03/add.hs</span>
<span class="nf">add</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>On the left hand side of the = is the name of the function, followed by the arguments to the function. On the right hand side is the body of the function. With our source file saved, we can load it into ghci, and use our new add function straight away. (The prompt that ghci displays will change after you load your file.)
Зліва від <code>=</code> - назва функції, за якою йдуть аргументи функції. Праворуч - тіло функції. Зберігши наш вихідний файл, ми можемо завантажити його в ghci та відразу використати нову функцію <code>add</code> для додавання. (Підказка, що відображатиметься ghci, зміниться після завантаження файлу).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">add</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">add</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">add</span> <span class="mi">1</span> <span class="mi">2</span>
<span class="mi">3</span>
</pre></div></div></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Що робити, якщо ghci не може знайти ваш вихідний файл?</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Під час запуску ghci він може не знайти ваш вихідний файл. Він буде шукати вихідні файли в будь-якій директорії, в якій він був запущений. Якщо це не той каталог, у якому насправді знаходиться ваш вихідний файл, ви можете використовувати команду ghci <code>:cd</code>, щоб змінити його робочий каталог.
<code>ghci&gt; :cd /tmp</code>
Alternatively, you can provide the path to your Haskell source file as the argument to :load. This path can be either absolute or relative to ghci&#8217;s current directory.
Крім того, ви можете надати шлях до вихідного файлу Haskell як аргумент до <code>:load</code>. Цей шлях може бути абсолютним або відносним до поточного каталогу ghci.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>Коли ми застосовуємо додавання до значень 1 і 2, змінним <code>a</code> і <code>b</code> в лівій частині нашого визначення надаються (або «прив’язані до») значення 1 і 2, тому результатом є вираз <code>1 + 2</code>.</p></div>
<div class="paragraph"><p>У Haskell немає ключового слова <code>return</code>, оскільки функція - це єдиний вираз, а не послідовність висловлювань. Значення виразу є результатом функції. (У Haskell є функція, яка називається <code>return</code>, але ми її деякий час не будемо обговорювати; вона має інше значення, ніж в імперативних мовах.)</p></div>
<div class="paragraph"><p>Коли ви бачите символ <code>=</code> у коді Haskell, він представляє "значення": ім'я зліва визначається як вираз справа.</p></div>
</div>
<div class="sect2">
<h3 id="______3">Що таке змінна кінець кінцем?</h3>
<div class="paragraph"><p>У Haskell змінна забезпечує спосіб дати ім’я виразу. Після того, як змінна прив'язана (тобто пов'язана з) певним виразом, її значення не змінюється: ми завжди можемо використовувати ім'я змінної замість того, щоб виписати вираз, і отримати той самий результат.</p></div>
<div class="paragraph"><p>Якщо ви звикли до імперативних мов програмування, ви, ймовірно, вважаєте змінну як спосіб визначення місця в пам'яті (або якогось еквівалента), який може містити різні значення в різний час. Мовою імперативів ми можемо змінити значення змінної в будь-який час, так що повторне отримання місця пам'яті може потенційно кожного разу давати різні результати.</p></div>
<div class="paragraph"><p>Критична різниця між цими двома поняттями змінної полягає в тому, що в Haskell, коли ми прив’язуємо змінну до виразу, ми знаємо, що ми завжди можемо замінити її цим виразом, оскільки вона не зміниться. В імперативній мові це поняття замінюваності не дотримується.</p></div>
<div class="paragraph"><p>Наприклад, якщо ми запустимо наступний крихітний сценарій Python, він надрукує число <code>11</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">11</span>
<span class="c1"># value of x is now 11</span>
<span class="k">print</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>На відміну від цього, еквівалентна спроба в Haskell призводить до помилки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/Assign.hs</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="mi">10</span>
<span class="nf">x</span> <span class="ow">=</span> <span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо призначити значення x два рази.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="kt">Assign</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span> <span class="p">(</span> <span class="kt">Assign</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>

<span class="kt">Assign</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">Multiple</span> <span class="n">declarations</span> <span class="kr">of</span> <span class="p">`</span><span class="kt">Main</span><span class="o">.</span><span class="n">x&#39;</span>
    <span class="kt">Declared</span> <span class="n">at</span><span class="kt">:</span> <span class="kt">Assign</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">3</span><span class="kt">:</span><span class="mi">0</span>
                 <span class="kt">Assign</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="mi">4</span><span class="kt">:</span><span class="mi">0</span>
<span class="kt">Failed</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="n">none</span><span class="o">.</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___5">Умовне обчислення</h3>
<div class="paragraph"><p>Як і багато інших мов, Haskell має вираз <code>if</code>. Давайте подивимось це в дії, потім пояснимо, що відбувається. Як приклад, ми напишемо власну версію стандартної функції <code>drop</code>. Перш ніж розпочати, давайте трохи вивчимо, як поводиться <code>drop</code>, щоб ми могли повторити її поведінку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">2</span> <span class="s">&quot;foobar&quot;</span>
<span class="s">&quot;obar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">4</span> <span class="s">&quot;foobar&quot;</span>
<span class="s">&quot;ar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">7</span> <span class="kt">[]</span>
<span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="s">&quot;foo&quot;</span>
<span class="s">&quot;foo&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>З вищесказаного, здається, що drop повертає початковий список, якщо число, яке потрібно видалити, менше або дорівнює нулю. В іншому випадку він видаляє елементи, поки не вичерпається або не досягне заданої кількості. Ось функція <code>myDrop</code>, яка має таку ж поведінку, і використовує Haskell вираз <code>if</code>, щоб вирішити, що робити. Функція <code>null</code> нижче перевіряє, чи список порожній.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/myDrop.hs</span>
<span class="nf">myDrop</span> <span class="n">n</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="n">xs</span>
              <span class="kr">then</span> <span class="n">xs</span>
              <span class="kr">else</span> <span class="n">myDrop</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tail</span> <span class="n">xs</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>У Haskell відступ важливий: він продовжує існуюче визначення, замість того, щоб починати нове. Не опускайте відступ!</p></div>
<div class="paragraph"><p>Вам може бути цікаво, звідки походить ім'я змінної <code>xs</code> у функції Haskell. Це загальна схема імен для списків: ви можете читати <code>s</code> як суфікс, тому ім'я по суті є «множиною x».</p></div>
<div class="paragraph"><p>Давайте збережемо нашу функцію Haskell у файлі з назвою <strong>myDrop.hs</strong>, а потім завантажимо її в ghci.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">load</span> <span class="n">myDrop</span><span class="o">.</span><span class="n">hs</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">myDrop</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">2</span> <span class="s">&quot;foobar&quot;</span>
<span class="s">&quot;obar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">4</span> <span class="s">&quot;foobar&quot;</span>
<span class="s">&quot;ar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">7</span> <span class="kt">[]</span>
<span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="s">&quot;foo&quot;</span>
<span class="s">&quot;foo&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли ми побачили <code>myDrop</code> в дії, повернемося до вихідного коду та розглянемо всі новинки, які ми запровадили.</p></div>
<div class="paragraph"><p>Перш за все, ми ввели <code>--</code> як початок однорядного коментаря. Цей коментар поширюється до кінця рядка.</p></div>
<div class="paragraph"><p>Далі - саме ключове слово <code>if</code>. Віно вводить вираз, який має три компоненти.</p></div>
<div class="paragraph"><p>Вираз типу <code>Bool</code>, одразу після <code>if</code>. Ми називаємо це предикатом.</p></div>
<div class="paragraph"><p>Потім ключове слово <code>then</code> з наступним виразом. Цей вираз буде використовуватися як значення виразу <code>if</code>, якщо предикат оцінюється як <code>True</code>.</p></div>
<div class="paragraph"><p>Ще одне ключове слово <code>else</code> з наступним виразом. Цей вираз буде використовуватися як значення виразу <code>if</code>, якщо предикат оцінюється як <code>False</code>.</p></div>
<div class="paragraph"><p>Ми будемо називати вирази після <code>then</code> та <code>else</code> ключових слів як "гілки". Гілки повинні мати однакові типи; вираз <code>if</code> також буде мати цей тип. Такий вираз, як <code>if True then 1 else «foo»</code> має різні типи для своїх гілок, тому він неправильно введений і буде відхилений компілятором чи інтерпретатором.</p></div>
<div class="paragraph"><p>Нагадаємо, що Haskell - мова, орієнтована на вирази. В імперативній мові може бути сенс опустити <code>else</code> гілку <code>if</code>, тому що ми працюємо з твердженнями, а не з виразами. Однак, коли ми працюємо з виразами, <code>if</code>, що не має <code>else</code>, не мав би результату ані типу, якщо предикат оцінюватиметься як <code>False</code>, і це було б безглуздо.</p></div>
<div class="paragraph"><p>Our predicate contains a few more novelties. The null function indicates whether a list is empty, while the (||) operator performs a logical “or” of its Bool-typed arguments.
Наш предикат містить ще кілька новин. Функція <code>null</code> вказує, чи список порожній, тоді як <code>(||)</code> оператор виконує логічне "або" своїх аргументів типу <code>Bool</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">null</span>
<span class="nf">null</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span>
<span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Оператори не особливі</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip" />
</td>
<td class="content">Зауважте, що нам вдалося знайти тип <code>(||)</code>, загорнувши його в дужки. Оператор <code>(||)</code> не "вбудований" у мову: це звичайна функція.</td>
</tr></table>
</div>
<div class="paragraph"><p>Оператор <code>(||)</code> "швидкий": якщо його лівий операнд оцінюється на <code>True</code>, він не оцінює його правого операнда. У більшості мов для оцінки короткого обчислення потрібна спеціальна підтримка, але не в Haskell. Незабаром ми побачимо, чому.</p></div>
</div></div>
<div class="paragraph"><p>Далі наша функція застосовується рекурсивно. Це наш перший приклад рекурсії, про який ми детально розповімо коротко.</p></div>
<div class="paragraph"><p>Нарешті, наш вираз <code>if</code> охоплює кілька рядків. Вирівнюємо <code>then</code> та <code>else</code> гілки під <code>if</code> для. Поки ми використовуємо деякі відступи, їх точна кількість не важлива. За бажанням ми можемо записати весь вираз на одному рядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/myDrop.hs</span>
<span class="nf">myDropX</span> <span class="n">n</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="n">xs</span> <span class="kr">then</span> <span class="n">xs</span> <span class="kr">else</span> <span class="n">myDropX</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tail</span> <span class="n">xs</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The length of this version makes it more difficult to read. We will usually break an if expression across several lines to keep the predicate and each of the branches easier to follow.
Довжина цієї версії ускладнює читання. Зазвичай ми розбиваємо вираз <code>if</code> у кількох рядках, щоб простіше слідувати за предикатом і кожній з гілок.</p></div>
<div class="paragraph"><p>Для порівняння, ось еквівалент Python <code>MyDrop</code> з Haskell. Обидва структуровані аналогічно: кожен зменшує лічильник, видаляючи елемент із заголовка списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">myDrop</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">elts</span><span class="p">):</span>
    <span class="k">while</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">elts</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">elts</span> <span class="o">=</span> <span class="n">elts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">elts</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____4">Розуміння обчислення на прикладі</h2>
<div class="sectionbody">
<div class="paragraph"><p>У нашому описі <code>myDrop</code> ми поки що зосередилися на зверніх особливостях. Нам потрібно заглибитись і розробити корисну ментальну модель того, як працює застосування функції. Для цього ми спочатку опрацюємо кілька простих прикладів, поки не зможемо пройти оцінку виразу <code>myDrop 2 "abcd"</code>.</p></div>
<div class="paragraph"><p>Ми кілька разів говорили про заміну виразу на змінну, і ми використаємо цю можливість тут. Наша процедура буде включати перезаписи виразів знову і знову, замінюючи вирази змінними, поки ми не досягнемо остаточного результату. Гарний час застосувати олівець та папір, щоб ви могли слідувати нашим описам, спробувавши їх самостійно.</p></div>
<div class="sect3">
<h4 id="___6">Ледаче обчислення</h4>
<div class="paragraph"><p>Почнемо з розгляду визначення простої нерекурсивної функції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/RoundToEven.hs</span>
<span class="nf">isOdd</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">mod</span> <span class="n">n</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>mod</code> є стандартною функцією модуля. Перший великий крок до розуміння того, як працює обчислення Haskell - це з'ясування того, що є результатом обчислення виразу <code>isOdd (1 + 2)</code>.</p></div>
<div class="paragraph"><p>Before we explain how evaluation proceeds in Haskell, let us recap the sort of evaluation strategy used by more familiar languages. First, evaluate the subexpression 1 + 2, to give 3. Then apply the odd function with n bound to 3. Finally, evaluate mod 3 2 to give 1, and 1 == 1 to give True.
Перш ніж ми пояснимо, як проходить обчислення в Haskell, давайте переглянемо таку стратегію обчислення, яку використовують більш звичні мови. Спочатку оцініть підвираз <code>1 + 2</code>, отримавши <code>3</code>. Потім застосуйте функцію <code>odd</code> з <code>n</code> прив’язаною до <code>3</code>. Нарешті, оцініть <code>mod 3 2</code>, щоб дати <code>1</code>, та <code>1 == 1</code> що дає <code>True</code>.</p></div>
<div class="paragraph"><p>В мові, яка використовує пряме обчислення, аргументи функції оцінюються перед застосуванням функції. Haskell вибирає інший шлях: непряме обчислення.</p></div>
<div class="paragraph"><p>У Haskell, суб-вираз <code>1 + 2</code> не зводиться до значення <code>3</code>. Натомість ми створюємо «обіцянку», що коли значення виразу <code>isOdd (1 + 2)</code> буде необхідне, ми зможемо його обчислити. Запис, який ми використовуємо для відстеження неообчисленого виразу, називається <em>гроною</em>. Це все, що відбувається: ми створюємо обіцянку і відкладаємо фактичну оцінку, поки вона дійсно не потрібна. Якщо результат цього виразу згодом ніколи не буде використаний, ми взагалі не будемо обчислювати його значення.</p></div>
<div class="paragraph"><p>Непрямі оцінки часто називають лінивою оцінкою.<span class="footnote"><br />[Терміни "непрямий" і "лінивий" мають дещо різні технічні значення, але ми не будемо вдаватися тут до деталей розрізнення.]<br /></span></p></div>
</div>
<div class="sect3">
<h4 id="____2">Більш змістовний приклад</h4>
<div class="paragraph"><p>Давайте тепер розглянемо оцінку виразу <code>myDrop 2 "abcd"</code>, де ми використовуємо <code>print</code> для того, щоб він був обчислений.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="p">(</span><span class="n">myDrop</span> <span class="mi">2</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span>
<span class="s">&quot;cd&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Нашим першим кроком є ​​спроба застосувати <code>print</code>, який потребує оцінки його аргументу. Для цього ми застосовуємо функцію <code>myDrop</code> до значень <code>2</code> та <code>"abcd"</code>. Прив'язуємо змінну <code>n</code> до значення <code>2</code>, а <code>xs</code> - <code>"abcd"</code>. Якщо ми замінимо ці значення на предикат <code>myDrop</code>, отримаємо наступний вираз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span>  <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="s">&quot;abcd&quot;</span>
<span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="s">&quot;abcd&quot;</span> <span class="ow">::</span><span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім ми достатньо оцінюємо предикат, щоб з’ясувати, у чому його значення. Це вимагає, щоб ми оцінили вираз <code>(||)</code>. Щоб визначити його значення, <code>(||)</code> оператору необхідно спочатку вивчити значення лівого операнда.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Заміна цього значення на вираз <code>(||)</code> призводить до наступного виразу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span>  <span class="kt">False</span> <span class="o">||</span> <span class="n">null</span> <span class="s">&quot;abcd&quot;</span>
<span class="kt">False</span> <span class="o">||</span> <span class="n">null</span> <span class="s">&quot;abcd&quot;</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Якби лівий операнд надає значення <code>True</code>, <code>(||)</code> не потрібно було б оцінювати його правий операнд, оскільки він не міг вплинути на результат вираження. Оскільки він оцінюється як <code>False</code>, <code>(||)</code> повинен оцінити правильний операнд.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="s">&quot;abcd&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>We now substitute this value back into the (||) expression. Since both operands evaluate to False, the (||) expression does too, and thus the predicate evaluates to False.
Тепер ми підставляємо це значення назад у вираз <code>(||)</code>. Оскільки обидва операнди оцінюються як <code>False</code>, то <code>(||)</code> вираз також, і, таким чином, предикат оцінюється як <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">False</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>This causes the if expression&#8217;s else branch to be evaluated. This branch contains a recursive application of myDrop.
Це викликає оцінку гілки <code>if</code> виразу <code>else</code>. Ця гілка містить рекурсивну програму <code>myDrop</code>.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Коротке обчислення безкоштовно</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Багато мов потребують поводження з логічним або оператором спеціально, щоб вони шли коротким шляхом, якщо його лівий операнд визначає значення <code>True</code>. У Haskell <code>(||)</code> є звичайною функцією: непряме обчислення вбудовує цю здатність у мову.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>У Haskell ми можемо легко визначити нову функцію, що іде коротким шляхом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/shortCircuit.hs</span>
<span class="nf">newOr</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="kr">then</span> <span class="n">a</span> <span class="kr">else</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми запишемо вираз, як <code>newOr True (length [1 ..]&gt; 0)</code>, він не буде оцінювати його другий аргумент. (Це так само: вираз намагається обчислити довжину нескінченного списку. Якби його обчислювали, він би підвішував ghci в нескінченому циклі, поки б ми його не вбили).</p></div>
<div class="paragraph"><p>Якби ми написали подібну функцію, скажімо, в Python, безпосереднє обчислення нас би покусало: обидва аргументи були б обчислені до того, як вони будуть передані до <code>newOr</code>, і ми не змогли б уникнути нескінченного циклу на другому аргументі.</p></div>
</div>
<div class="sect3">
<h4 id="__2">Рекурсія</h4>
<div class="paragraph"><p>When we apply myDrop recursively, n is bound to the thunk 2 - 1, and xs to tail "abcd".
Коли ми застосовуємо <code>myDrop</code> рекурсивно, <code>n</code> прив’язується до грона <code>2 - 1</code>, та <code>xs</code> до <code>tail "abcd"</code>.</p></div>
<div class="paragraph"><p>We&#8217;re now evaluating myDrop from the beginning again. We substitute the new values of n and xs into the predicate.
Зараз ми знову обчислюємо <code>myDrop</code> спочатку. Заміняємо нові значення <code>n</code> і <code>xs</code> в предикаті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось стисла версія обчислення лівого операнду.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і слід було очікувати, ми не оцінювали вираз <code>2 - 1</code>, поки нам не знадобилося його значення. Ми також ліниво оцінюємо правий операнд, відкладаючи <code>tail "abcd"</code>, поки нам не знадоб`иться його значення.
`</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span>
<span class="nf">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;bcd&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="s">&quot;bcd&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Предикат знову оцінюється як <code>False</code>, внаслідок чого ще одна гілка буде оцінена ще раз.</p></div>
<div class="paragraph"><p>Because we&#8217;ve had to evaluate the expressions for n and xs to evaluate the predicate, we now know that in this application of myDrop, n has the value 1 and xs has the value "bcd".
Оскільки нам довелося оцінити вирази для <code>n</code> та <code>xs</code>, щоб оцінити предикат, тепер ми знаємо, що в цьому застосуванні <code>myDrop</code> <code>n</code> має значення <code>1</code>, а <code>xs</code> має значення <code>"bcd"</code>.</p></div>
</div>
<div class="sect3">
<h4 id="___7">Закінчення рекурсії</h4>
<div class="paragraph"><p>In the next recursive application of myDrop, we bind n to 1 - 1 and xs to tail <code>"bcd"</code>.
У наступному рекурсивному застосуванні <code>myDrop</code> ми прив'язуємо <code>n</code> до <code>1 - 1</code> і <code>xs</code> до <code>tail "bcd"</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;bcd&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;bcd&quot;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Ще раз, <code>(||)</code> спочатку має оцінити свій лівий операнд.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span>
<span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="mi">0</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, цей вираз було оцінено як <code>True</code>!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">||</span> <span class="n">null</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;bcd&quot;</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки правий операнд не може впливати на результат <code>(||)</code>, він не обчислюється, а результат предиката - <code>True</code>. Це змушує нас обчислювати гілку <code>then</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">tail</span> <span class="s">&quot;bcd&quot;</span>
<span class="nf">tail</span> <span class="s">&quot;bcd&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="____3">Повернення з рекурсії</h4>
<div class="paragraph"><p>Пам'ятайте, що зараз ми знаходимось у нашому другому рекурсивному застосуванні <code>myDrop</code>. Це застосування обчислюється до <code>tail "bcd"</code>. Ми повертаємось із застосування функції, замінивши цей вираз на <code>myDrop (1 - 1) (tail "bcd")</code>, щоб стати результатом цього застосування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;bcd&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">tail</span> <span class="s">&quot;bcd&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Потім повертаємося з першої рекурсії, замінюючи результат другого рекурсивного застосування для <code>myDrop (2 - 1) (tail "abcd")</code>, щоб стати результатом цього застосування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">tail</span> <span class="s">&quot;abcd&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">tail</span> <span class="s">&quot;bcd&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, ми повертаємося з нашого початкового застосування, замінюючи результат першого рекурсивного застосування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">2</span> <span class="s">&quot;abcd&quot;</span> <span class="o">==</span> <span class="n">tail</span> <span class="s">&quot;bcd&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Notice that as we return from each successive recursive application, none of them needs to evaluate the expression tail "bcd": the final result of evaluating the original expression is a thunk. The thunk is only finally evaluated when ghci needs to print it.
Зауважте, що, повертаючись із кожної послідовної рекурсії, жодному з них не потрібно оцінювати вираз <code>tail "bcd"</code>: кінцевий результат оцінювання вихідного виразу - це гроно. Гроно обчислюється лише остаточно, коли ghci потребує його надрукувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">myDrop</span> <span class="mi">2</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;cd&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="s">&quot;bcd&quot;</span>
<span class="s">&quot;cd&quot;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____4">Що ми дізналися?</h3>
<div class="paragraph"><p>Тут ми встановили кілька важливих моментів.</p></div>
<div class="ulist"><ul>
<li>
<p>
Для розуміння обчислення виразу Haskell має сенс використовувати підстановку та переписування.
</p>
</li>
<li>
<p>
Лінь приводить нас до відстрочення обчислення, поки нам не знадобиться значення, і для оцінки достатньої частини виразу, щоб встановити його значення.
</p>
</li>
<li>
<p>
Результатом застосування функції може бути гроно (відкладений вираз).
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___haskell_2">Поліморфізм у Haskell</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли ми зайомились зі списками, ми згадували, що тип списку є поліморфним. Більш детально ми поговоримо про поліморфізм Haskell тут.</p></div>
<div class="paragraph"><p>Якщо ми хочемо отримати останній елемент списку, ми використовуємо функцію <code>last</code>. Значення, яке вона повертає, повинно мати той самий тип, що й елементи списку, але <code>last</code> функціонує так само, насправді незалежно від типу цих елементів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="s">&quot;baz&quot;</span>
<span class="sc">&#39;z&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб зафіксувати цю ідею, її підпис типу містить змінну типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">last</span>
<span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Here, a is the type variable. We can read the signature as “takes a list, all of whose elements have some type a, and returns a value of the same type a”.
Тут <code>a</code> - змінна типу. Ми можемо читати сигнатуру як "бере список, усі елементи якого мають певний тип <code>a</code> і повертає значення того ж типу <code>a</code>".</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Ідентифікація змінної типу</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip" />
</td>
<td class="content">Змінні типу завжди починаються з малої літери. Ви завжди можете відрізнити змінну типу від звичайної змінної за контекстом, оскільки мови типів і функцій є окремими: змінні типу живуть у сигнатурах типів, а звичайні змінні - у звичайних виразах.</td>
</tr></table>
</div>
<div class="paragraph"><p>Загальна практика Haskell - робити імена змінних типів дуже короткими. Одна буква є надзвичайно поширеною; довші назви з’являються нечасто. Сигнатури типу зазвичай короткі; ми отримуємо більше читабельності, зберігаючи короткі імена, ніж ми робимо їх описовими.</p></div>
</div></div>
<div class="paragraph"><p>Коли функція має змінні типу в своїй сигнатурі, що вказує на те, що деякі її аргументи можуть бути будь-якого типу, ми називаємо функцію поліморфною.</p></div>
<div class="paragraph"><p>Коли ми хочемо застосувати <code>last</code>, скажімо, до списку <code>Char</code>, компілятор підставляє <code>Char`</code> замість <code>a</code> в усій сигнатурі типу, який дає нам тип <code>last</code> із введенням <code>[Char]</code> як <code>[Char] -&gt; Char</code>.</p></div>
<div class="paragraph"><p>Цей вид поліморфізму називається параметричним поліморфізмом. Вибір іменування легко зрозуміти за аналогією: подібно до того, як функція може мати параметри, які ми можемо згодом прив’язувати до реальних значень, тип Haskell може мати параметри, які згодом ми можемо прив’язати до інших типів.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="title">Маленька номенклатура</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/tip.png" alt="Tip" />
</td>
<td class="content">Якщо тип містить параметри типу, ми говоримо, що це параметризований тип або поліморфний тип. Якщо тип функції або значення містить параметри типу, ми називаємо це поліморфним.</td>
</tr></table>
</div>
</div></div>
<div class="paragraph"><p>Коли ми бачимо параметризований тип, ми вже відзначали, що код не переймається тим, що таке фактичний тип. Однак ми можемо зробити більш сильне твердження: у нього немає ніякого способу з’ясувати, що таке реальний тип, або маніпулювати значенням цього типу. Він не може створити значення і він не може його перевірити. Все, що він може зробити, це трактувати це як повністю абстрактний «чорний ящик». Ми розкриємо одну причину, чому це важливо незабаром.</p></div>
<div class="paragraph"><p>Параметричний поліморфізм є найбільш помітним видом поліморфізму, який підтримує Haskell. Параметричний поліморфізм Haskell безпосередньо вплинув на розробку загальних засобів мов Java та C#. Параметризований тип в Haskell схожий на змінну типу в дженеріках Java. Шаблони C++ також нагадують параметричний поліморфізм.</p></div>
<div class="paragraph"><p>Щоб зрозуміти, чим поліморфізм Haskell відрізняється від інших мов, ось кілька форм поліморфізму, які є загальними для інших мов, але відсутні в Haskell.</p></div>
<div class="paragraph"><p>У основних об'єктно-орієнтованих мовах поліморфізм субтипів є більш поширеним, ніж параметричний поліморфізм. Механізми субкласів C++ та Java надають їм поліморфізм субтипів. Базовий клас визначає набір поведінки, який його підкласи можуть змінювати та розширювати. Оскільки Haskell не є об'єктно-орієнтованою мовою, він не забезпечує поліморфізм субтипів.</p></div>
<div class="paragraph"><p>Також поширеним є примусовий поліморфізм, який дозволяє неявно перетворювати значення одного типу у значення іншого типу. Багато мов надають певну форму поліморфізму примусу: один приклад - автоматичне перетворення між цілими числами і числами з плаваючою комою. Haskell навмисно уникає навіть такого простого автоматичного примусу.</p></div>
<div class="paragraph"><p>Це ще не вся історія поліморфізму в Haskell: ми повернемося до теми в Розділі 6, <strong><em>Використовуючи типокласи</em></strong>.</p></div>
<div class="sect3">
<h4 id="_____5">Думки про поліморфні функції</h4>
<div class="paragraph"><p>У розділі «Типи функцій та чистота» ми говорили про з'ясування поведінки функції на основі її сигнатури типу. Ми можемо застосувати такий же спосіб міркування до поліморфних функцій. Погляньмо ще раз на <code>fst</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">fst</span>
<span class="nf">fst</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Перш за все, зауважте, що його аргумент містить дві змінні типу, <code>a</code> і <code>b</code>, що означає, що елементи кортежу можуть бути різних типів.</p></div>
<div class="paragraph"><p>Типом результату <code>fst</code> є <code>a</code>. Ми вже згадували, що параметричний поліморфізм робить реальний тип недоступним: у <code>fst</code> не вистачає інформації для побудови значення типу <code>a</code>, а також не може перетворити <code>a</code> в <code>b</code>. Таким чином, єдино можлива дійсна поведінка (опускаючи нескінченні цикли або збої), які вона може мати, - це повернути перший елемент пари.</p></div>
</div>
<div class="sect2">
<h3 id="___8">Подальше читання</h3>
<div class="paragraph"><p>Існує глибокий математичний сенс, в якому будь-яка непатологічна функція типу <code>(a, b) -&gt; a</code> повинна виконувати саме те, що робить <code>fst</code>. Більше того, ці міркування поширюється на більш складні поліморфні функції. У роботі [Wadler89] глибоко висвітлюється ця процедура.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p>Було запропоновано створити «теоретичну скриньку» для обговорення глибокого матеріалу та посилань на наукові роботи.</p></div>
</div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="________2">Тип функції з більш ніж одним аргументом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поки ми не дуже придивились до сигнатур функцій, які приймають більше одного аргументу. Ми вже використали кілька таких функцій; давайте подивимось на сигнатуру однієї, <code>take</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">take</span>
<span class="nf">take</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Цілком зрозуміло, що щось відбувається з <code>Int</code> та деякими списками, але чому в сигнатурі є два символи <code>-&gt;</code>? Haskell згрупує цей ланцюжок стрілок справа наліво; тобто <code>-&gt;</code> є право-асоціативним. Якщо ми введемо круглі дужки, ми можемо зрозуміти, як трактується підпис цього типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/Take.hs</span>
<span class="nf">take</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">([</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>З цього виходить, що нам слід прочитати сигнатуру типу як функцію, яка бере один аргумент, <code>Int</code> та повертає іншу функцію. Ця інша функція також приймає один аргумент, список і повертає список того ж типу як результат.</p></div>
<div class="paragraph"><p>Це правильно, але нелегко зрозуміти, які можуть бути його наслідки. Ми повернемося до цієї теми у розділі «Часткове застосування функцій та карування», після того як витратимо трохи часу на написання функцій. На даний момент ми можемо розглядати тип після останнього <code>-&gt;</code>, як тип повернення функції, а попередні типи - як аргументи функції.</p></div>
<div class="paragraph"><p>Тепер ми можемо написати сигнатуру типу для функції <code>myDrop</code>, яку ми визначили раніше.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">-- file: ch02/myDrop.hs</span>
<span class="nf">myDrop</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="__3">Вправи</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Haskell забезпечує стандартну функцію, <code>last ::[a] -&gt; a</code>, яка повертає останній елемент списку. Читаючи лише тип, які можливі дійсні поведінки (за винятном збоїв і нескінченних циклів), що ця функція може мати? Які декілька речей, які ця функція явно не може виконати?
</p>
</li>
<li>
<p>
Напишіть функцію <code>lastButOne</code>, яка повертає елемент перед останнім.
</p>
</li>
<li>
<p>
Завантажте вашу функцію <code>lastButOne</code> в ghci та спробуйте її на списках різної довжини. Що станеться, коли ви передасте йому список, який є занадто коротким?
</p>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="______4">Чому така метушня з чистотою?</h3>
<div class="paragraph"><p>Мало мов програмування заходять так далеко як Haskell, наполягаючи, що чистота повинна бути нормою. Цей вибір має глибокі і цінні наслідки.</p></div>
<div class="paragraph"><p>Оскільки результат застосування чистої функції може залежати лише від її аргументів, ми часто можемо отримати сильний натяк на те, що робить чиста функція, просто прочитавши її ім’я та зрозумівши її сигнатуру типу. Як приклад, давайте розглянемо <code>not</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="kr">type</span> <span class="n">not</span>
<span class="nf">not</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть якби ми не знали назву цієї функції, лише її сигнатура обмежує можливі дійсні поведінки, які вона може мати.</p></div>
<div class="ulist"><ul>
<li>
<p>
Ігнорувати її аргумент і завжди повертайте <code>True</code> або <code>False</code>.
</p>
</li>
<li>
<p>
Повернути її аргумент немодифікованим.
</p>
</li>
<li>
<p>
Обернути свій аргумент.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ми також знаємо, що ця функція не може виконувати деякі речі: вона не може отримати доступ до файлів, вона не може спілкуватися з мережею, вона не може сказати, котра година.</p></div>
<div class="paragraph"><p>Чистота полегшує роботу з розумінням коду. Поведінка чистої функції не залежить від значення глобальної змінної, або від вмісту бази даних, або від стану мережевого з'єднання. Чистий код за своєю суттю є модульним: кожна функція є самодостатньою та має чітко визначений інтерфейс.</p></div>
<div class="paragraph"><p>Неочевидним наслідком чистоти, що є типовим, є те, що працювати з нечистим кодом стає простіше. Haskell заохочує стиль програмування, в якому ми відокремлюємо код, який повинен мати побічні ефекти від коду, якому вони не потрібні. У цьому стилі нечистий код, як правило, простий, з "піднняттям ваги", виконаним у чистому коді.</p></div>
<div class="paragraph"><p>Much of the risk in software lies in talking to the outside world, be it coping with bad or missing data, or handling malicious attacks. Because Haskell&#8217;s type system tells us exactly which parts of our code have side effects, we can be appropriately on our guard. Because our favoured coding style keeps impure code isolated and simple, our “attack surface” is small.
Значна частина ризику в програмному забезпеченні полягає в спілкуванні з навколишнім світом, будь то впоратися з поганими або відсутніми даними або поводжуватися зі зловмисними атаками. Оскільки система типів Haskell нам точно говорить, які частини нашого коду мають побічні ефекти, ми можемо бути належним чином захищені. Оскільки наш вподобаний стиль кодування тримає нечистий код ізольованим та простим, наша "атакована поверхня" невелика.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__4">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>У цій главі ми провели короткий огляд системи типів Haskell та значної частини її синтаксису. Ми прочитали про найпоширеніші типи та дізналися, як писати прості функції. Нас ознайомили з поліморфізмом, умовними виразами, чистотою та ледачим обчисленням.</p></div>
<div class="paragraph"><p>Все це становить багато інформації, яку потрібно засвоїти. У Розділі 3 <strong><em>Визначення типів, упорядкування функцій</em></strong> ми будемо базуватися на цих основних знаннях для подальшого розширення нашого розуміння Haskell.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-17 18:49:39 EET
</div>
</div>
</body>
</html>
