<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Глава 3. Визначення типів, упорядкування функцій</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Глава 3. Визначення типів, упорядкування функцій</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="____">Визначення нового типу даних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Although lists and tuples are useful, we&#8217;ll often want to construct new data types of our own. This allows us to add structure to the values in our programs. Instead of using an anonymous tuple, we can give a collection of related values a name and a distinct type. Defining our own types also improves the type safety of our code: Haskell will not allow us to accidentally mix values of two types that are structurally similar but have different names. 4 comments</p></div>
<div class="paragraph"><p>For motivation, we&#8217;ll consider a few kinds of data that a small online bookstore might need to manage. We won&#8217;t make any attempt at complete or realistic data definitions, but at least we&#8217;re tying them to the real world. 10 comments</p></div>
<div class="paragraph"><p>We define a new data type using the data keyword. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
data BookInfo = Book Int String [String]
                deriving (Show)
21 comments
The BookInfo after the data keyword is the name of our new type. We call BookInfo a type constructor. Once we have defined a type, we will use its type constructor to refer to it. As we&#8217;ve already mentioned, a type name, and hence a type constructor, must start with a capital letter. 14 comments</p></div>
<div class="paragraph"><p>The Book that follows is the name of the value constructor (sometimes called a data constructor). We use this to create a value of the BookInfo type. A value constructor&#8217;s name must also start with a capital letter. 11 comments</p></div>
<div class="paragraph"><p>After Book, the Int, String, and [String] that follow are the components of the type. A component serves the same purpose in Haskell as a field in a structure or class would in another language: it&#8217;s a “slot” where we keep a value. (We&#8217;ll often refer to components as fields.) 6 comments</p></div>
<div class="paragraph"><p>In this example, the Int represents a book&#8217;s identifier (e.g. in a stock database), String its title, and [String] the names of its authors. 6 comments</p></div>
<div class="paragraph"><p>To make the link to a concept we&#8217;ve already seen, the BookInfo type contains the same components as a 3-tuple of type (Int, String, [String]), but it has a distinct type. We can&#8217;t accidentally (or deliberately) use one in a context where the other is expected. For instance, a bookstore is also likely to carry magazines. 8 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
data MagazineInfo = Magazine Int String [String]
                    deriving (Show)
5 comments
Even though this MagazineInfo type has the same structure as our BookInfo type, Haskell treats the types as distinct because their type and value constructors have different names. No comments</p></div>
<div class="paragraph"><p>[Note]  Deriving what?
We&#8217;ll explain the full meaning of deriving (Show) later, in the section called “Show”. For now, it&#8217;s enough to know that we need to tack this onto a type declaration so that ghci will automatically know how to print a value of this type. 4 comments</p></div>
<div class="paragraph"><p>We can create a new value of type BookInfo by treating Book as a function, and applying it with arguments of types Int, String, and [String]. 4 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
myInfo = Book 9780135072455 "Algebra of Programming"
         ["Richard Bird", "Oege de Moor"]
10 comments
Once we have defined a type, we can experiment with it in ghci. We begin by using the :load command to load our source file. 5 comments</p></div>
<div class="paragraph"><p>ghci&gt; :load BookStore
[1 of 1] Compiling Main             ( BookStore.hs, interpreted )
Ok, modules loaded: Main.
5 comments
Remember the myInfo variable we defined in our source file? Here it is. No comments</p></div>
<div class="paragraph"><p>ghci&gt; myInfo
Book 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]
ghci&gt; :type myInfo
myInfo :: BookInfo
10 comments
We can construct new values interactively in ghci, too. No comments</p></div>
<div class="paragraph"><p>ghci&gt; Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]
Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]
5 comments
The ghci command :type lets us see what the type of an expression is. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :type Book 1 "Cosmicomics" ["Italo Calvino"]
Book 1 "Cosmicomics" ["Italo Calvino"] :: BookInfo
2 comments
Remember that if we want to define a new variable inside ghci, the syntax is slightly different from that of a Haskell source file: we need to put a let in front. 4 comments</p></div>
<div class="paragraph"><p>ghci&gt; let cities = Book 173 "Use of Weapons" ["Iain M. Banks"]
7 comments
To find out more about a type, we can use some of ghci&#8217;s browsing capabilities. The :info command gets ghci to tell us everything it knows about a name. 2 comments</p></div>
<div class="paragraph"><p>ghci&gt; :info BookInfo
data BookInfo = Book Int String [String]
       &#8201;&#8212;&#8201;Defined at BookStore.hs:4:5-12
instance Show BookInfo&#8201;&#8212;&#8201;Defined at BookStore.hs:4:5-12
1 comment
We can also find out why we use Book to construct a new value of type BookStore. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :type Book
Book :: Int &#8594; String &#8594; [String] &#8594; BookInfo
9 comments
We can treat a value constructor as just another function, one that happens to create and return a new value of the type we desire. 12 comments</p></div>
<div class="paragraph"><p>Naming types and values
When we introduced the type BookStore, we deliberately chose to give the type constructor BookStore a different name from the value constructor Book, purely to make it obvious which was which. 32 comments</p></div>
<div class="paragraph"><p>However, in Haskell, the names of types and values are independent of each other. We only use a type constructor (i.e. the type&#8217;s name) in a type declaration or a type signature. We only use a value constructor in actual code. Because these uses are distinct, there is no ambiguity if we give a type constructor and a value constructor the same name. If we are writing a type signature, we must be referring to a type constructor. If we are writing an expression, we must be using the value constructor. 7 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs&#8201;&#8212;&#8201;We will introduce the CustomerID type shortly.</p></div>
<div class="paragraph"><p>data BookReview = BookReview BookInfo CustomerID String
6 comments
This definition says that the type named BookReview has a value constructor that is also named BookReview. No comments</p></div>
<div class="paragraph"><p>Not only is it legal for a value constructor to have the same name as its type constructor, it&#8217;s normal: you&#8217;ll see this all the time in regular Haskell code. 24 comments</p></div>
<div class="paragraph"><p>Type synonyms
We can introduce a synonym for an existing type at any time, to give a type a more descriptive name. For example, the String in our BookReview type doesn&#8217;t tell us what the string is for, but we can clarify this. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
type CustomerID = Int
type ReviewBody = String</p></div>
<div class="paragraph"><p>data BetterReview = BetterReview BookInfo CustomerID ReviewBody
9 comments
The type keyword introduces a type synonym. The new name is on the left of the =, with the existing name on the right. The two names identify the same type, so type synonyms are purely for making code more readable. 9 comments</p></div>
<div class="paragraph"><p>We can also use a type synonym to create a shorter name for a verbose type. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
type BookRecord = (BookInfo, BookReview)
9 comments
This states that we can use BookRecord as a synonym for the tuple (BookInfo, BookReview). A type synonym only creates a new name that refers to an existing type[7]. We still use the same value constructors to create a value of the type. 13 comments</p></div>
<div class="paragraph"><p>Algebraic data types
The familiar Bool is the simplest common example of a category of type called an algebraic data type. An algebraic data type can have more than one value constructor. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Bool.hs
data Bool = False | True
10 comments
The Bool type has two value constructors, True and False. Each value constructor is separated in the definition by a | character, which we can read as “or”: we can construct a Bool that has the value True, or the value False. When a type has more than one value constructor, they are usually referred to as alternatives or cases. We can use any one of the alternatives to create a value of that type. No comments</p></div>
<div class="paragraph"><p>[Note]  A note about naming
Although the phrase “algebraic data type” is long, we&#8217;re being careful to avoid using the acronym “ADT”. That acronym is already widely understood to stand for “abstract data type”. Since Haskell supports both algebraic and abstract data types, we&#8217;ll be explicit and avoid the acronym entirely. 13 comments</p></div>
<div class="paragraph"><p>Each of an algebraic data type&#8217;s value constructors can take zero or more arguments. As an example, here&#8217;s one way we might represent billing information. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
type CardHolder = String
type CardNumber = String
type Address = [String]</p></div>
<div class="paragraph"><p>data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
                   deriving (Show)
13 comments
Here, we&#8217;re saying that we support three ways to bill our customers. If they want to pay by credit card, they must supply a card number, the holder&#8217;s name, and the holder&#8217;s billing address as arguments to the CreditCard value constructor. Alternatively, they can pay the person who delivers their shipment. Since we don&#8217;t need to store any extra information about this, we specify no arguments for the CashOnDelivery constructor. Finally, we can send an invoice to the specified customer, in which case we need their CustomerID as an argument to the Invoice constructor. No comments</p></div>
<div class="paragraph"><p>When we use a value constructor to create a value of type BillingInfo, we must supply the arguments that it requires. 4 comments</p></div>
<div class="paragraph"><p>ghci&gt; :type CreditCard
CreditCard :: CardNumber &#8594; CardHolder &#8594; Address &#8594; BillingInfo
ghci&gt; CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens", "England"]
CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens","England"]
ghci&gt; :type it
it :: BillingInfo
ghci&gt; Invoice</p></div>
<div class="paragraph"><p>&lt;interactive&gt;:1:0:
    No instance for (Show (CustomerID &#8594; BillingInfo))
      arising from a use of &#8216;print&#8217; at &lt;interactive&gt;:1:0-6
    Possible fix:
      add an instance declaration for (Show (CustomerID &#8594; BillingInfo))
    In the expression: print it
    In a <em>do</em> expression: print it
ghci&gt; :type it
it :: BillingInfo
15 comments
The No instance error message arose because we did not supply an argument to the Invoice constructor. As a result, we were trying to print the Invoice constructor itself. That constructor requires an argument and returns a value, so it is a function. We cannot print functions in Haskell, which is ultimately why the interpreter complained. 6 comments</p></div>
<div class="paragraph"><p>Tuples, algebraic data types, and when to use each
There is some overlap between tuples and user-defined algebraic data types. If we wanted to, we could represent our BookInfo type from earlier as an (Int, String, [String]) tuple. 2 comments</p></div>
<div class="paragraph"><p>ghci&gt; Book 2 "The Wealth of Networks" ["Yochai Benkler"]
Book 2 "The Wealth of Networks" ["Yochai Benkler"]
ghci&gt; (2, "The Wealth of Networks", ["Yochai Benkler"])
(2,"The Wealth of Networks",["Yochai Benkler"])
No comments
Algebraic data types allow us to distinguish between otherwise identical pieces of information. Two tuples with elements of the same type are structurally identical, so they have the same type. 7 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Distinction.hs
a = ("Porpoise", "Grey")
b = ("Table", "Oak")
1 comment
Since they have different names, two algebraic data types have distinct types, even if they are otherwise structurally equivalent. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Distinction.hs
data Cetacean = Cetacean String String
data Furniture = Furniture String String</p></div>
<div class="paragraph"><p>c = Cetacean "Porpoise" "Grey"
d = Furniture "Table" "Oak"
3 comments
This lets us bring the type system to bear in writing programs with fewer bugs. With the tuples we defined above, we could conveivably pass a description of a whale to a function expecting a chair, and the type system could not help us. With the algebraic data types, there is no such possibility of confusion. 8 comments</p></div>
<div class="paragraph"><p>Here is a more subtle example. Consider the following representations of a two-dimensional vector. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/AlgebraicVector.hs&#8201;&#8212;&#8201;x and y coordinates or lengths.
data Cartesian2D = Cartesian2D Double Double
                   deriving (Eq, Show)</p></div>
<div class="paragraph"><p>&#8212;&#8201;Angle and distance (magnitude).
data Polar2D = Polar2D Double Double
               deriving (Eq, Show)
4 comments
The Cartesian and polar forms use the same types for their two elements. However, the meanings of the elements are different. Because Cartesian2D and Polar2D are distinct types, the type system will not let us accidentally use a Cartesian2D value where a Polar2D is expected, or vice versa. 4 comments</p></div>
<div class="paragraph"><p>ghci&gt; Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2</p></div>
<div class="paragraph"><p>&lt;interactive&gt;:1:33:
    Couldn&#8217;t match expected type &#8216;Cartesian2D&#8217;
           against inferred type &#8216;Polar2D&#8217;
    In the second argument of &#8216;(==)<em>, namely `Polar2D (pi / 4) 2</em>
    In the expression:
          Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
    In the definition of `it&#8217;:
        it = Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
7 comments
The (==) operator requires its arguments to have the same type. 5 comments</p></div>
<div class="paragraph"><p>[Tip]   Comparing for equality
Notice that in the deriving clause for our vector types, we added another word, Eq. This causes the Haskell implementation to generate code that lets us compare the values for equality. 7 comments</p></div>
<div class="paragraph"><p>If we used tuples to represent these values, we could quickly land ourselves in hot water by mixing the two representations inappropriately. No comments</p></div>
<div class="paragraph"><p>ghci&gt; (1, 2) == (1, 2)
True
13 comments
The type system can&#8217;t rescue us here: as far as it&#8217;s concerned, we&#8217;re comparing two (Double, Double) pairs, which is a perfectly valid thing to do. Indeed, we cannot tell by inspection which of these values is supposed to be polar or Cartesian, but (1,2) has a different meaning in each representation. 3 comments</p></div>
<div class="paragraph"><p>There is no hard and fast rule for deciding when it&#8217;s better to use a tuple or a distinct data type, but here&#8217;s a rule of thumb to follow. If you&#8217;re using compound values widely in your code (as almost all non-trivial programs do), adding data declarations will benefit you in both type safety and readability. For smaller, localised uses, a tuple is usually fine. 4 comments</p></div>
<div class="paragraph"><p>Analogues to algebraic data types in other languages
Algebraic data types provide a single powerful way to describe data types. Other languages often need several different features to achieve the same degree of expressiveness. Here are some analogues from C and C++, which might make it clearer what we can do with algebraic data types, and how they relate to concepts that might be more familiar. No comments</p></div>
<div class="paragraph"><p>The structure
With just one constructor, an algebraic data type is similar to a tuple: it groups related values together into a compound value. It corresponds to a struct in C or C++, and its components correspond to the fields of a struct. Here&#8217;s a C equivalent of the BookInfo type that we defined earlier. No comments</p></div>
<div class="paragraph"><p>struct book_info {
    int id;
    char *name;
    char **authors;
};
2 comments
The main difference between the two is that the fields in the Haskell type are anonymous and positional. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
data BookInfo = Book Int String [String]
                deriving (Show)
No comments
By positional, we mean that the section number is in the first field of the Haskell type, and the title is in the second. We refer to them by location, not by name. 10 comments</p></div>
<div class="paragraph"><p>In the section called “Pattern matching”, we&#8217;ll see how to access the fields of a BookStore value. In the section called “Record syntax”, we&#8217;ll introduce an alternate syntax for defining data types that looks a little more C-like. 5 comments</p></div>
<div class="paragraph"><p>The enumeration
Algebraic data types also serve where we&#8217;d use an enum in C or C++, to represent a range of symbolic values. Such algebraic data types are sometimes referred to as enumeration types. Here&#8217;s an example from C. 1 comment</p></div>
<div class="paragraph"><p>enum roygbiv {
    red,
    orange,
    yellow,
    green,
    blue,
    indigo,
    violet,
};
6 comments
And here&#8217;s a Haskell equivalent. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Roygbiv.hs</p></div>
<div class="paragraph"><p>data Roygbiv = Red
             | Orange
             | Yellow
             | Green
             | Blue
             | Indigo
             | Violet
               deriving (Eq, Show)
9 comments
We can try these out in ghci. 1 comment</p></div>
<div class="paragraph"><p>ghci&gt; :type Yellow
Yellow :: Roygbiv
ghci&gt; :type Red
Red :: Roygbiv
ghci&gt; Red == Yellow
False
ghci&gt; Green == Green
True
No comments
In C, the elements of an enum are integers. We can use an integer in a context where an enum is expected, and vice versa: a C compiler will automatically convert values between the two types. This can be a source of nasty bugs. In Haskell, this kind of problem does not occur. For example, we cannot use a Roygbiv value where an Int is expected. 4 comments</p></div>
<div class="paragraph"><p>ghci&gt; take 3 "foobar"
"foo"
ghci&gt; take Red "foobar"</p></div>
<div class="paragraph"><p>&lt;interactive&gt;:1:5:
    Couldn&#8217;t match expected type &#8216;Int&#8217; against inferred type &#8216;Roygbiv&#8217;
    In the first argument of &#8216;take&#8217;, namely &#8216;Red&#8217;
    In the expression: take Red "foobar"
    In the definition of &#8216;it&#8217;: it = take Red "foobar"
5 comments
The discriminated union
If an algebraic data type has multiple alternatives, we can think of it as similar to a union in C or C++. A big difference between the two is that a union doesn&#8217;t tell us which alternative is actually present; we have to explicitly and manually track which alternative we&#8217;re using, usually in another field of an enclosing struct. This means that unions can be sources of nasty bugs, where our notion of which alternative we should be using is incorrect. No comments</p></div>
<div class="paragraph"><p>enum shape_type {
    shape_circle,
    shape_poly,
};</p></div>
<div class="paragraph"><p>struct circle {
    struct vector centre;
    float radius;
};</p></div>
<div class="paragraph"><p>struct poly {
    size_t num_vertices;
    struct vector *vertices;
};</p></div>
<div class="paragraph"><p>struct shape
{
    enum shape_type type;
    union {
        struct circle circle;
        struct poly poly;
    } shape;
};
15 comments
In the example above, the union can contain valid data for either a struct circle or a struct poly. We have to use the enum shape_type by hand to indicate which kind of value is currently stored in the union. No comments</p></div>
<div class="paragraph"><p>The Haskell version of this code is both dramatically shorter and safer than the C equivalent. 1 comment</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/ShapeUnion.hs
type Vector = (Double, Double)</p></div>
<div class="paragraph"><p>data Shape = Circle Vector Double
           | Poly [Vector]
17 comments
If we create a Shape value using the Circle constructor, the fact that we created a Circle is stored. When we later use a Circle, we can&#8217;t accidentally treat it as a Square. We will see why in the section called “Pattern matching” No comments</p></div>
<div class="paragraph"><p>[Tip]   A few notes
From reading the preceding sections, it should now be clear that all of the data types that we define with the data keyword are algebraic data types. Some may have just one alternative, while others have several, but they&#8217;re all using the same machinery. 15 comments</p></div>
<div class="paragraph"><p>Pattern matching
Now that we&#8217;ve seen how to construct values with algebraic data types, let&#8217;s discuss how we work with these values. If we have a value of some type, there are two things we would like to be able to do. No comments</p></div>
<div class="paragraph"><p>If the type has more than one value constructor, we need to be able to tell which value constructor was used to create the value. No comments</p></div>
<div class="paragraph"><p>If the value constructor has data components, we need to be able to extract those values. No comments</p></div>
<div class="paragraph"><p>Haskell has a simple, but tremendously useful, pattern matching facility that lets us do both of these things. 2 comments</p></div>
<div class="paragraph"><p>A pattern lets us look inside a value and bind variables to the data it contains. Here&#8217;s an example of pattern matching in action on a Bool value: we&#8217;re going to reproduce the not function. 4 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/add.hs
myNot True  = False
myNot False = True
10 comments
It might seem that we have two functions named myNot here, but Haskell lets us define a function as a series of equations: these two clauses are defining the behavior of the same function for different patterns of input. On each line, the patterns are the items following the function name, up until the = sign. 6 comments</p></div>
<div class="paragraph"><p>To understand how pattern matching works, let&#8217;s step through an example, say myNot False. 2 comments</p></div>
<div class="paragraph"><p>When we apply myNot, the Haskell runtime checks the value we supply against the value constructor in the first pattern. This does not match, so it tries against the second pattern. That match succeeds, so it uses the right hand side of that equation as the result of the function application. 5 comments</p></div>
<div class="paragraph"><p>Here is a slightly more extended example. This function adds together the elements of a list. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/add.hs
sumList (x:xs) = x + sumList xs
sumList []     = 0
19 comments
Let us step through the evaluation of sumList [1,2]. The list notation [1,2] is shorthand for the expression (1:(2:[])). We begin by trying to match the pattern in the first equation of the definition of sumList. In the (x:xs) pattern, the “:” is the familiar list constructor, (:). We are now using it to match against a value, not to construct one. The value (1:(2:[])) was constructed with (:), so the constructor in the value matches the constructor in the pattern. We say that the pattern matches, or that the match succeeds. 18 comments</p></div>
<div class="paragraph"><p>The variables x and xs are now “bound to” the constructor&#8217;s arguments, so x is given the value 1, and xs the value 2:[]. 2 comments</p></div>
<div class="paragraph"><p>The expression we are now evaluating is 1 + sumList (2:[]). We must now recursively apply sumList to the value 2:[]. Once again, this was constructed using (:), so the match succeeds. In our recursive application of sumList, x is now bound to 2, and xs to []. No comments</p></div>
<div class="paragraph"><p>We are now evaluating 1 + (2 + sumList []). In this recursive application of sumList, the value we are matching against is []. The value&#8217;s constructor does not match the constructor in the first pattern, so we skip this equation. Instead, we “fall through” to the next pattern, which matches. The right hand side of this equation is thus chosen as the result of this application. 1 comment</p></div>
<div class="paragraph"><p>The result of sumList [1,2] is thus 1 + (2 + (0)), or 3. 8 comments</p></div>
<div class="paragraph"><p>[Note]  Ordering is important
As we have already mentioned, a Haskell implementation checks patterns for matches in the order in which we specify them in our equations. Matching proceeds from top to bottom, and stops at the first success. Equations below a successful match have no effect. 12 comments</p></div>
<div class="paragraph"><p>As a final note, there already exists a standard function, sum, that performs this sum-of-a-list for us. Our sumList is purely for illustration. 7 comments</p></div>
<div class="paragraph"><p>Construction and deconstruction
Let&#8217;s step back and take a look at the relationship between constructing a value and pattern matching on it. 3 comments</p></div>
<div class="paragraph"><p>We apply a value constructor to build a value. The expression Book 9 "Close Calls" ["John Long"] applies the Book constructor to the values 9, "Close Calls", and ["John Long"] to produce a new value of type BookInfo. 3 comments</p></div>
<div class="paragraph"><p>When we pattern match against the Book constructor, we reverse the construction process. First of all, we check to see if the value was created using that constructor. If it was, we inspect it to obtain the individual values that we originally supplied to the constructor when we created the value. 1 comment</p></div>
<div class="paragraph"><p>Let&#8217;s consider what happens if we match the pattern (Book id name authors) against our example expression. 9 comments</p></div>
<div class="paragraph"><p>The match will succeed, because the constructor in the value matches the one in our pattern. No comments</p></div>
<div class="paragraph"><p>The variable id will be bound to 9. 1 comment</p></div>
<div class="paragraph"><p>The variable name will be bound to "Close Calls". No comments</p></div>
<div class="paragraph"><p>The variable authors will be bound to ["John Long"]. No comments</p></div>
<div class="paragraph"><p>Because pattern matching acts as the inverse of construction, it&#8217;s sometimes referred to as deconstruction. 5 comments</p></div>
<div class="paragraph"><p>[Note]  Deconstruction doesn&#8217;t destroy anything
If you&#8217;re steeped in object oriented programming jargon, don&#8217;t confuse deconstruction with destruction! Matching a pattern has no effect on the value we&#8217;re examining: it just lets us “look inside” it. 4 comments</p></div>
<div class="paragraph"><p>Further adventures
The syntax for pattern matching on a tuple is similar to the syntax for constructing a tuple. Here&#8217;s a function that returns the last element of a 3-tuple. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Tuple.hs
third (a, b, c) = c
5 comments
There&#8217;s no limit on how “deep” within a value a pattern can look. This definition looks both inside a tuple and inside a list within that tuple. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Tuple.hs
complicated (True, a, x:xs, 5) = (a, xs)
4 comments
We can try this out interactively. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :load Tuple.hs
[1 of 1] Compiling Main             ( Tuple.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; complicated (True, 1, [1,2,3], 5)
(1,[2,3])
12 comments
Wherever a literal value is present in a pattern (True and 5 in the tuple pattern above), that value must match exactly for the pattern match to succeed. If every pattern within a series of equations fails to match, we get a runtime error. 3 comments</p></div>
<div class="paragraph"><p>ghci&gt; complicated (False, 1, [1,2,3], 5)
<strong>*</strong> Exception: Tuple.hs:10:0-39: Non-exhaustive patterns in function complicated</p></div>
<div class="paragraph"><p>No comments
For an explanation of this error message, skip forward a little, to the section called “Exhaustive patterns and wild cards”. No comments</p></div>
<div class="paragraph"><p>We can pattern match on an algebraic data type using its value constructors. Recall the BookInfo type we defined earlier: we can extract the values from a BookInfo as follows. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
bookID      (Book id title authors) = id
bookTitle   (Book id title authors) = title
bookAuthors (Book id title authors) = authors
12 comments
Let&#8217;s see it in action. No comments</p></div>
<div class="paragraph"><p>ghci&gt; bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
3
ghci&gt; bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
"Probability Theory"
ghci&gt; bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])</p></div>
<div class="paragraph"><p>4 comments
The compiler can infer the types of the accessor functions based on the constructor we&#8217;re using in our pattern. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :type bookID
bookID :: BookInfo &#8594; Int
ghci&gt; :type bookTitle
bookTitle :: BookInfo &#8594; String
ghci&gt; :type bookAuthors
bookAuthors :: BookInfo &#8594; [String]
4 comments
If we use a literal value in a pattern, the corresponding part of the value we&#8217;re matching against must contain an identical value. For instance, the pattern (3:xs) first of all checks that a value is a non-empty list, by matching against the (:) constructor. It also ensures that the head of the list has the exact value 3. If both of these conditions hold, the tail of the list will be bound to the variable xs. No comments</p></div>
<div class="paragraph"><p>Variable naming in patterns
As you read functions that match on lists, you&#8217;ll frequently find that the names of the variables inside a pattern resemble (x:xs) or (d:ds). This is a popular naming convention. The idea is that the name xs has an “s” on the end of its name as if it&#8217;s the “plural” of x, because x contains the head of the list, and xs the remaining elements. 12 comments</p></div>
<div class="paragraph"><p>The wild card pattern
We can indicate that we don&#8217;t care what is present in part of a pattern. The notation for this is the underscore character “_”, which we call a wild card. We use it as follows. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
nicerID      (Book id _     _      ) = id
nicerTitle   (Book _  title _      ) = title
nicerAuthors (Book _  _     authors) = authors
4 comments
Here, we have tidier versions of the accessor functions we introduced earlier. Now, there&#8217;s no question about which element we&#8217;re using in each function. No comments</p></div>
<div class="paragraph"><p>In a pattern, a wild card acts similarly to a variable, but it doesn&#8217;t bind a new variable. As the examples above indicate, we can use more than one wild card in a single pattern. No comments</p></div>
<div class="paragraph"><p>Another advantage of wild cards is that a Haskell compiler can warn us if we introduce a variable name in a pattern, but do not use it in a function&#8217;s body. Defining a variable, but forgetting to use it, can often indicate the presence of a bug, so this is a helpful feature. If we use a wild card instead of a variable that we do not intend to use, the compiler won&#8217;t complain. No comments</p></div>
<div class="paragraph"><p>Exhaustive patterns and wild cards
When writing a series of patterns, it&#8217;s important to cover all of a type&#8217;s constructors. For example, if we&#8217;re inspecting a list, we should have one equation that matches the non-empty constructor (:), and one that matches the empty-list constructor []. 4 comments</p></div>
<div class="paragraph"><p>Let&#8217;s see what happens if we fail to cover all the cases. Here, we deliberately omit a check for the [] constructor. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BadPattern.hs
badExample (x:xs) = x + badExample xs
2 comments
If we apply this to a value that it cannot match, we&#8217;ll get an error at runtime: our software has a bug! 5 comments</p></div>
<div class="paragraph"><p>ghci&gt; badExample []
<strong>*</strong> Exception: BadPattern.hs:4:0-36: Non-exhaustive patterns in function badExample</p></div>
<div class="paragraph"><p>1 comment
In this example, no equation in the function&#8217;s definition matches the value []. No comments</p></div>
<div class="paragraph"><p>[Tip]   Warning about incomplete patterns
GHC provides a helpful compilation option, -fwarn-incomplete-patterns, that will cause it to print a warning during compilation if a sequence of patterns don&#8217;t match all of a type&#8217;s value constructors. 8 comments</p></div>
<div class="paragraph"><p>If we need to provide a default behavior in cases where we don&#8217;t care about specific constructors, we can use a wild card pattern. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BadPattern.hs
goodExample (x:xs) = x + goodExample xs
goodExample _      = 0
7 comments
The wild card above will match the [] constructor, so applying this function does not lead to a crash. 3 comments</p></div>
<div class="paragraph"><p>ghci&gt; goodExample []
0
ghci&gt; goodExample [1,2]
3
2 comments
Record syntax
Writing accessor functions for each of a data type&#8217;s components can be repetitive and tedious. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
nicerID      (Book id _     _      ) = id
nicerTitle   (Book _  title _      ) = title
nicerAuthors (Book _  _     authors) = authors
No comments
We call this kind of code boilerplate: necessary, but bulky and irksome. Haskell programmers don&#8217;t like boilerplate. Fortunately, the language addresses this particular boilerplate problem: we can define a data type, and accessors for each of its components, simultaneously. (The positions of the commas here is a matter of preference. If you like, put them at the end of a line instead of the beginning.) 6 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
data Customer = Customer {
      customerID      :: CustomerID
    , customerName    :: String
    , customerAddress :: Address
    } deriving (Show)
30 comments
This is almost exactly identical in meaning to the following, more familiar form. 6 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/AltCustomer.hs
data Customer = Customer Int String [String]
                deriving (Show)</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
customerID 
</dt>
<dd>
<p>
Customer &#8594; Int
customerID (Customer id _ _) = id
</p>
</dd>
<dt class="hdlist1">
customerName 
</dt>
<dd>
<p>
Customer &#8594; String
customerName (Customer _ name _) = name
</p>
</dd>
<dt class="hdlist1">
customerAddress 
</dt>
<dd>
<p>
Customer &#8594; [String]
customerAddress (Customer _ _ address) = address
15 comments
For each of the fields that we name in our type definition, Haskell creates an accessor function of that name. 3 comments
</p>
</dd>
</dl></div>
<div class="paragraph"><p>ghci&gt; :type customerID
customerID :: Customer &#8594; CustomerID
3 comments
We can still use the usual application syntax to create a value of this type. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
customer1 = Customer 271828 "J.R. Hacker"
            ["255 Syntax Ct",
             "Milpitas, CA 95134",
             "USA"]
3 comments
Record syntax adds a more verbose notation for creating a value. This can sometimes make code more readable. 1 comment</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BookStore.hs
customer2 = Customer {
              customerID = 271828
            , customerAddress = ["1048576 Disk Drive",
                                 "Milpitas, CA 95134",
                                 "USA"]
            , customerName = "Jane Q. Citizen"
            }
8 comments
If we use this form, we can vary the order in which we list fields. Here, we have moved the name and address fields from their positions in the declaration of the type. No comments</p></div>
<div class="paragraph"><p>When we define a type using record syntax, it also changes the way the type&#8217;s values are printed. 6 comments</p></div>
<div class="paragraph"><p>ghci&gt; customer1
Customer {customerID = 271828, customerName = "J.R. Hacker", customerAddress = ["255 Syntax Ct","Milpitas, CA 95134","USA"]}
5 comments
For comparison, let&#8217;s look at a BookInfo value; we defined this type without record syntax. No comments</p></div>
<div class="paragraph"><p>ghci&gt; cities
Book 173 "Use of Weapons" ["Iain M. Banks"]
2 comments
The accessor functions that we get “for free” when we use record syntax really are normal Haskell functions. 3 comments</p></div>
<div class="paragraph"><p>ghci&gt; :type customerName
customerName :: Customer &#8594; String
ghci&gt; customerName customer1
"J.R. Hacker"
2 comments
The standard System.Time module makes good use of record syntax. Here&#8217;s a type defined in that module: No comments</p></div>
<div class="paragraph"><p>data CalendarTime = CalendarTime {
  ctYear                      :: Int,
  ctMonth                     :: Month,
  ctDay, ctHour, ctMin, ctSec :: Int,
  ctPicosec                   :: Integer,
  ctWDay                      :: Day,
  ctYDay                      :: Int,
  ctTZName                    :: String,
  ctTZ                        :: Int,
  ctIsDST                     :: Bool
}</p></div>
<div class="paragraph"><p>No comments
In the absence of record syntax, it would be painful to extract specific fields from a type like this. The notation makes it easier to work with large structures. No comments</p></div>
<div class="paragraph"><p>Parameterised types
We&#8217;ve repeatedly mentioned that the list type is polymorphic: the elements of a list can be of any type. We can also add polymorphism to our own types. To do this, we introduce type variables into a type declaration. The Prelude defines a type named Maybe: we can use this to represent a value that could be either present or missing, e.g. a field in a database row that could be null. 24 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Nullable.hs
data Maybe a = Just a
             | Nothing
37 comments
Here, the variable a is not a regular variable: it&#8217;s a type variable. It indicates that the Maybe type takes another type as its parameter. This lets us use Maybe on values of any type. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Nullable.hs
someBool = Just True</p></div>
<div class="paragraph"><p>someString = Just "something"
13 comments
As usual, we can experiment with this type in ghci. No comments</p></div>
<div class="paragraph"><p>ghci&gt; Just 1.5
Just 1.5
ghci&gt; Nothing
Nothing
ghci&gt; :type Just "invisible bike"
Just "invisible bike" :: Maybe [Char]
12 comments
Maybe is a polymorphic, or generic, type. We give the Maybe type constructor a parameter to create a specific type, such as Maybe Int or Maybe [Bool]. As we might expect, these types are distinct. 3 comments</p></div>
<div class="paragraph"><p>We can nest uses of parameterised types inside each other, but when we do, we may need to use parentheses to tell the Haskell compiler how to parse our expression. 1 comment</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Nullable.hs
wrapped = Just (Just "wrapped")
9 comments
To once again extend an analogy to more familiar languages, parameterised types bear some resemblance to templates in C++, and to generics in Java. Just be aware that this is a shallow analogy. Templates and generics were added to their respective languages long after the languages were initially defined, and have an awkward feel. Haskell&#8217;s parameterised types are simpler and easier to use, as the language was designed with them from the beginning. 24 comments</p></div>
<div class="paragraph"><p>Recursive types
The familiar list type is recursive: it&#8217;s defined in terms of itself. To understand this, let&#8217;s create our own list-like type. We&#8217;ll use Cons in place of the (:) constructor, and Nil in place of []. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/ListADT.hs
data List a = Cons a (List a)
            | Nil
              deriving (Show)
11 comments
Because List a appears on both the left and the right of the = sign, the type&#8217;s definition refers to itself. If we want to use the Cons constructor to create a new value, we must supply one value of type a, and another of type List a. Let&#8217;s see where this leads us in practice. 3 comments</p></div>
<div class="paragraph"><p>The simplest value of type List a that we can create is Nil. Save the type definition in a file, then load it into ghci. 1 comment</p></div>
<div class="paragraph"><p>ghci&gt; Nil
Nil
2 comments
Because Nil has a List type, we can use it as a parameter to Cons. 2 comments</p></div>
<div class="paragraph"><p>ghci&gt; Cons 0 Nil
Cons 0 Nil
No comments
And because Cons 0 Nil has the type List a, we can use this as a parameter to Cons. 1 comment</p></div>
<div class="paragraph"><p>ghci&gt; Cons 1 it
Cons 1 (Cons 0 Nil)
ghci&gt; Cons 2 it
Cons 2 (Cons 1 (Cons 0 Nil))
ghci&gt; Cons 3 it
Cons 3 (Cons 2 (Cons 1 (Cons 0 Nil)))
6 comments
We could continue in this fashion indefinitely, creating ever longer Cons chains, each with a single Nil at the end. 3 comments</p></div>
<div class="paragraph"><p>[Tip]   Is List an acceptable list?
We can easily prove to ourselves that our List a type has the same shape as the built-in list type [a]. To do this, we write a function that takes any value of type [a], and produces a value of type List a. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/ListADT.hs
fromList (x:xs) = Cons x (fromList xs)
fromList []     = Nil
5 comments
By inspection, this clearly substitutes a Cons for every (:), and a Nil for each []. This covers both of the built-in list type&#8217;s constructors. The two types are isomorphic; they have the same shape. 9 comments</p></div>
<div class="paragraph"><p>ghci&gt; fromList "durian"
Cons <em>d</em> (Cons <em>u</em> (Cons <em>r</em> (Cons <em>i</em> (Cons <em>a</em> (Cons <em>n</em> Nil)))))
ghci&gt; fromList [Just True, Nothing, Just False]
Cons (Just True) (Cons Nothing (Cons (Just False) Nil))
8 comments
For a third example of what a recursive type is, here is a definition of a binary tree type. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Tree.hs
data Tree a = Node a (Tree a) (Tree a)
            | Empty
              deriving (Show)
7 comments
A binary tree is either a node with two children, which are themselves binary trees, or an empty value. No comments</p></div>
<div class="paragraph"><p>This time, let&#8217;s search for insight by comparing our definition with one from a more familiar language. Here&#8217;s a similar class definition in Java. 7 comments</p></div>
<div class="paragraph"><p>class Tree&lt;A&gt;
{
    A value;
    Tree&lt;A&gt; left;
    Tree&lt;A&gt; right;</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    public Tree(A v, Tree&lt;A&gt; l, Tree&lt;A&gt; r)
    {
        value = v;
        left = l;
        right = r;
    }
}
4 comments
The one significant difference is that Java lets us use the special value null anywhere to indicate “nothing”, so we can use null to indicate that a node is missing a left or right child. Here's a small function that constructs a tree with two leaves (a leaf, by convention, has no children). 4 comments</code></pre>
</div></div>
<div class="paragraph"><p>class Example
{
    static Tree&lt;String&gt; simpleTree()
    {
        return new Tree&lt;String&gt;(
            "parent",
            new Tree&lt;String&gt;("left leaf", null, null),
            new Tree&lt;String&gt;("right leaf", null, null));
    }
}
1 comment
In Haskell, we don&#8217;t have an equivalent of null. We could use the Maybe type to provide a similar effect, but that bloats the pattern matching. Instead, we&#8217;ve decided to use a no-argument Empty constructor. Where the Java example provides null to the Tree constructor, we supply Empty in Haskell. 16 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Tree.hs
simpleTree = Node "parent" (Node "left child" Empty Empty)
                           (Node "right child" Empty Empty)
1 comment
Exercises
1.</p></div>
<div class="paragraph"><p>Write the converse of fromList for the List type: a function that takes a List a and generates a [a]. 31 comments</p></div>
<div class="paragraph"><p>2.</p></div>
<div class="paragraph"><p>Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node&#8217;s children. 43 comments</p></div>
<div class="paragraph"><p>Reporting errors
Haskell provides a standard function, error :: String &#8594; a, that we can call when something has gone terribly wrong in our code. We give it a string parameter, which is the error message to display. Its type signature looks peculiar: how can it produce a value of any type a given only a string? 9 comments</p></div>
<div class="paragraph"><p>It has a result type of a so that we can call it anywhere and it will always have the right type. However, it does not return a value like a normal function: instead, it immediately aborts evaluation, and prints the error message we give it. 6 comments</p></div>
<div class="paragraph"><p>The mySecond function returns the second element of its input list, but fails if its input list isn&#8217;t long enough. 1 comment</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/MySecond.hs
mySecond :: [a] &#8594; a</p></div>
<div class="paragraph"><p>mySecond xs = if null (tail xs)
              then error "list too short"
              else head (tail xs)
12 comments
As usual, we can see how this works in practice in ghci. No comments</p></div>
<div class="paragraph"><p>ghci&gt; mySecond "xi"
<em>i</em>
ghci&gt; mySecond [2]
<strong>* Exception: list too short
ghci&gt; head (mySecond <a id="9"></a>)
</strong>* Exception: list too short
5 comments
Notice the third case above, where we try to use the result of the call to mySecond as the argument to another function. Evaluation still terminates and drops us back to the ghci prompt. This is the major weakness of using error: it doesn&#8217;t let our caller distinguish between a recoverable error and a problem so severe that it really should terminate our program. 6 comments</p></div>
<div class="paragraph"><p>As we have already seen, a pattern matching failure causes a similar unrecoverable error. No comments</p></div>
<div class="paragraph"><p>ghci&gt; mySecond []
<strong>*</strong> Exception: Prelude.tail: empty list
3 comments
A more controlled approach
We can use the Maybe type to represent the possibility of an error. No comments</p></div>
<div class="paragraph"><p>If we want to indicate that an operation has failed, we can use the Nothing constructor. Otherwise, we wrap our value with the Just constructor. 5 comments</p></div>
<div class="paragraph"><p>Let&#8217;s see how our mySecond function changes if we return a Maybe value instead of calling error. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/MySecond.hs
safeSecond :: [a] &#8594; Maybe a</p></div>
<div class="paragraph"><p>safeSecond [] = Nothing
safeSecond xs = if null (tail xs)
                then Nothing
                else Just (head (tail xs))
16 comments
If the list we&#8217;re passed is too short, we return Nothing to our caller. This lets them decide what to do, where a call to error would force a crash. No comments</p></div>
<div class="paragraph"><p>ghci&gt; safeSecond []
Nothing
ghci&gt; safeSecond [1]
Nothing
ghci&gt; safeSecond [1,2]
Just 2
ghci&gt; safeSecond [1,2,3]
Just 2
1 comment
To return to an earlier topic, we can further improve the readability of this function with pattern matching. 4 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/MySecond.hs
tidySecond :: [a] &#8594; Maybe a</p></div>
<div class="paragraph"><p>tidySecond (<em>:x:</em>) = Just x
tidySecond _       = Nothing
8 comments
The first pattern only matches if the list is at least two elements long (it contains two list constructors), and it binds the variable x to the list&#8217;s second element. The second pattern is matched if the first fails. 21 comments</p></div>
<div class="paragraph"><p>Introducing local variables
Within the body of a function, we can introduce new local variables whenever we need them, using a let expression. Here is a simple function that determines whether we should lend some money to a customer. We meet a money reserve of at least 100, we return our new balance after subtracting the amount we have loaned. 12 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Lending.hs
lend amount balance = let reserve    = 100
                          newBalance = balance - amount
                      in if balance &lt; reserve
                         then Nothing
                         else Just newBalance
12 comments
The keywords to look out for here are let, which starts a block of variable declarations, and in, which ends it. Each line introduces a new variable. The name is on the left of the =, and the expression to which it is bound is on the right. No comments</p></div>
<div class="paragraph"><p>[Note]  Special notes
Let us re-emphasise our wording: a name in a let block is bound to an expression, not to a value. Because Haskell is a lazy language, the expression associated with a name won&#8217;t actually be evaluated until it&#8217;s needed. In the above example, we will not compute the value of newBalance if we do not meet our reserve. 3 comments</p></div>
<div class="paragraph"><p>When we define a variable in a let block, we refer to it as a let-bound variable. This simply means what it says: we have bound the variable in a let block. No comments</p></div>
<div class="paragraph"><p>Also, our use of white space here is important. We&#8217;ll talk in more detail about the layout rules in the section called “The offside rule and white space in an expression”. 2 comments</p></div>
<div class="paragraph"><p>We can use the names of a variable in a let block both within the block of declarations and in the expression that follows the in keyword. 3 comments</p></div>
<div class="paragraph"><p>In general, we&#8217;ll refer to the places within our code where we can use a name as the name&#8217;s scope. If we can use a name, it&#8217;s in scope, otherwise it&#8217;s out of scope. If a name is visible throughout a source file, we say it&#8217;s at the top level. 2 comments</p></div>
<div class="paragraph"><p>Shadowing
We can “nest” multiple let blocks inside each other in an expression. 3 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/NestedLets.hs
foo = let a = 1
      in let b = 2
         in a + b
4 comments
It&#8217;s perfectly legal, but not exactly wise, to repeat a variable name in a nested let expression. 5 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/NestedLets.hs
bar = let x = 1
      in ((let x = "foo" in x), x)
7 comments
Here, the inner x is hiding, or shadowing, the outer x. It has the same name, but a different type and value. 1 comment</p></div>
<div class="paragraph"><p>ghci&gt; bar
("foo",1)
No comments
We can also shadow a function&#8217;s parameters, leading to even stranger results. What is the type of this function? No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/NestedLets.hs
quux a = let a = "foo"
         in a ++ "eek!"
6 comments
Because the function&#8217;s argument a is never used in the body of the function, due to being shadowed by the let-bound a, the argument can have any type at all. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :type quux
quux :: t &#8594; [Char]
5 comments
[Tip]   Compiler warnings are your friends
Shadowing can obviously lead to confusion and nasty bugs, so GHC has a helpful -fwarn-name-shadowing option. When enabled, GHC will print a warning message any time we shadow a name. No comments</p></div>
<div class="paragraph"><p>The where clause
We can use another mechanism to introduce local variables: the where clause. The definitions in a where clause apply to the code that precedes it. Here&#8217;s a similar function to lend, using where instead of let. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Lending.hs
lend2 amount balance = if amount &lt; reserve * 0.5
                       then Just newBalance
                       else Nothing
    where reserve    = 100
          newBalance = balance - amount
9 comments
While a where clause may initially seem weird, it offers a wonderful aid to readability. It lets us direct our reader&#8217;s focus to the important details of an expression, with the supporting definitions following afterwards. After a while, you may find yourself missing where clauses in languages that lack them. No comments</p></div>
<div class="paragraph"><p>As with let expressions, white space is significant in where clauses. We will talk more about the layout rules shortly, in the section called “The offside rule and white space in an expression”. 6 comments</p></div>
<div class="paragraph"><p>Local functions, global variables
You&#8217;ll have noticed that Haskell&#8217;s syntax for defining a variable looks very similar to its syntax for defining a function. This symmetry is preserved in let and where blocks: we can define local functions just as easily as local variables. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/LocalFunction.hs
pluralise :: String &#8594; [Int] &#8594; [String]
pluralise word counts = map plural counts
    where plural 0 = "no " <code> word </code> "s"
          plural 1 = "one " <code> word
          plural n = show n </code> " " <code> word </code> "s"
23 comments
We have defined a local function, plural, that consists of several equations. Local functions can freely use variables from the scopes that enclose them: here, we use word from the definition of the outer function pluralise. In the definition of pluralise, the map function (which we&#8217;ll be revisiting in the next chapter) applies the local function plural to every element of the counts list. No comments</p></div>
<div class="paragraph"><p>We can also define variables, as well as functions, at the top level of a source file. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/GlobalVariable.hs
itemName = "Weighted Companion Cube"
13 comments
The offside rule and white space in an expression
In our definitions of lend and lend2, the left margin of our text wandered around quite a bit. This was not an accident: in Haskell, white space has meaning. 2 comments</p></div>
<div class="paragraph"><p>Haskell uses indentation as a cue to parse sections of code. This use of layout to convey structure is sometimes called the offside rule. At the beginning of a source file, the first top level declaration or definition can start in any column, and the Haskell compiler or interpreter remembers that indentation level. Every subsequent top level declaration must have the same indentation. 5 comments</p></div>
<div class="paragraph"><p>Here&#8217;s an illustration of the top level indentation rule. Our first file, GoodIndent.hs, is well behaved. 1 comment</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/GoodIndent.hs&#8201;&#8212;&#8201;This is the leftmost column.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>-- It's fine for top-level declarations to start in any column...
firstGoodIndentation = 1</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  -- ...provided all subsequent declarations do, too!
  secondGoodIndentation = 2
No comments
Our second, BadIndent.hs, doesn't play by the rules. No comments</code></pre>
</div></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BadIndent.hs&#8201;&#8212;&#8201;This is the leftmost column.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>-- Our first declaration is in column 4.
firstBadIndentation = 1</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  -- Our second is left of the first, which is illegal!
  secondBadIndentation = 2
2 comments
Here's what happens when we try to load the two files into ghci. 3 comments</code></pre>
</div></div>
<div class="paragraph"><p>ghci&gt; :load GoodIndent.hs
[1 of 1] Compiling Main             ( GoodIndent.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; :load BadIndent.hs
[1 of 1] Compiling Main             ( BadIndent.hs, interpreted )</p></div>
<div class="paragraph"><p>BadIndent.hs:8:2: parse error on input &#8216;secondBadIndentation&#8217;
Failed, modules loaded: none.
3 comments
An empty following line is treated as a continuation of the current item, as is a following line indented further to the right. 1 comment</p></div>
<div class="paragraph"><p>The rules for let expressions and where clauses are similar. After a let or where keyword, the Haskell compiler or interpreter remembers the indentation of the next token it sees. If the line that follows is empty, or its indentation is further to the right, it is considered to continue the previous line. If the indentation is the same as the start of the preceding item, this is treated as beginning a new item in the same block. 4 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Indentation.hs
foo = let firstDefinition = blah blah
         &#8201;&#8212;&#8201;a comment-only line is treated as empty
                              continuation blah</p></div>
<div class="literalblock">
<div class="content">
<pre><code>-- we reduce the indentation, so this is a new definition
secondDefinition = yada yada</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>                             continuation yada
      in whatever
10 comments
Here are nested uses of let and where. No comments</code></pre>
</div></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/letwhere.hs
bar = let b = 2
          c = True
      in let a = b
         in (a, c)
4 comments
The name a is only visible within the inner let expression. It&#8217;s not visible in the outer let. If we try to use the name a there, we&#8217;ll get a compilation error. The indentation gives both us and the compiler a visual cue as to what is currently in scope. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/letwhere.hs
foo = x
    where x = y
              where y = 2
5 comments
Similarly, the scope of the first where clause is the definition of foo, but the scope of the second is just the first where clause. No comments</p></div>
<div class="paragraph"><p>The indentation we use for the let and where clauses makes our intentions easy to figure out. No comments</p></div>
<div class="paragraph"><p>A note about tabs versus spaces
If you use a Haskell-aware text editor (e.g. Emacs), it is probably already configured to use space characters for all white space when you edit Haskell source files. If your editor is not Haskell-aware, you should configure it to only use space characters. 11 comments</p></div>
<div class="paragraph"><p>The reason for this is portability. In an editor that uses a fixed-width font, tab stops are by convention placed at different intervals on Unix-like systems (every eight characters) than on Windows (every four characters). This means that no matter what your personal beliefs are about where tabs belong, you can&#8217;t rely on someone else&#8217;s editor honouring your preferences. Any indentation that uses tabs is going to look broken under someone&#8217;s configuration. In fact, this could lead to compilation problems, as the Haskell language standard requires implementations to use the Unix tab width convention. Using space characters avoids this problem entirely. 26 comments</p></div>
<div class="paragraph"><p>The offside rule is not mandatory
We can use explicit structuring instead of layout to indicate what we mean. To do so, we start a block of equations with an opening curly brace; separate each item with a semicolon; and finish the block with a closing curly brace. The following two uses of let have the same meanings. 2 comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Braces.hs
bar = let a = 1
          b = 2
          c = 3
      in a + b + c</p></div>
<div class="paragraph"><p>foo = let { a = 1;  b = 2;
        c = 3 }
      in a + b + c
5 comments
When we use explicit structuring, the normal layout rules don&#8217;t apply, which is why we can get away with unusual indentation in the second let expression. No comments</p></div>
<div class="paragraph"><p>We can use explicit structuring anywhere that we&#8217;d normally use layout. It&#8217;s valid for where clauses, and even top-level declarations. Just remember that although the facility exists, explicit structuring is hardly ever actually used in Haskell programs. 22 comments</p></div>
<div class="paragraph"><p>The case expression
Function definitions are not the only place where we can use pattern matching. The case construct lets us match patterns within an expression. Here&#8217;s what it looks like. This function (defined for us in Data.Maybe) unwraps a Maybe value, using a default if the value is Nothing. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Guard.hs
fromMaybe defval wrapped =
    case wrapped of
      Nothing     &#8594; defval
      Just value  &#8594; value
18 comments
The case keyword is followed by an arbitrary expression: the pattern match is performed against the result of this expression. The of keyword signifies the end of the expression and the beginning of the block of patterns and expressions. 2 comments</p></div>
<div class="paragraph"><p>Each item in the block consists of a pattern, followed by an arrow &#8594;, followed by an expression to evaluate if that pattern matches. These expressions must all have the same type. The result of the case expression is the result of the expression associated with the first pattern to match. Matches are attempted from top to bottom. 2 comments</p></div>
<div class="paragraph"><p>To express “here&#8217;s the expression to evaluate if none of the other patterns match”, we just use the wild card pattern _ as the last in our list of patterns. If a pattern match fails, we will get the same kind of runtime error as we saw earlier. 4 comments</p></div>
<div class="paragraph"><p>Common beginner mistakes with patterns
There are a few ways in which new Haskell programmers can misunderstand or misuse patterns. Here are some attempts at pattern matching gone awry. Depending on what you expect one of these examples to do, it might contain a surprise. No comments</p></div>
<div class="paragraph"><p>Incorrectly matching against a variable&#8201;&#8212;&#8201;file: ch03/BogusPattern.hs
data Fruit = Apple | Orange</p></div>
<div class="paragraph"><p>apple = "apple"</p></div>
<div class="paragraph"><p>orange = "orange"</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
whichFruit 
</dt>
<dd>
<p>
String &#8594; Fruit
</p>
</dd>
</dl></div>
<div class="paragraph"><p>whichFruit f = case f of
                 apple  &#8594; Apple
                 orange &#8594; Orange
10 comments
A naive glance suggests that this code is trying to check the value f to see whether it matches the value apple or orange. No comments</p></div>
<div class="paragraph"><p>It is easier to spot the mistake if we rewrite the code in an equational style. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BogusPattern.hs
equational apple = Apple
equational orange = Orange
12 comments
Now can you see the problem? Here, it is more obvious apple does not refer to the top level value named apple: it is a local pattern variable. No comments</p></div>
<div class="paragraph"><p>[Note]  Irrefutable patterns
We refer to a pattern that always succeeds as irrefutable. Plain variable names and the wild card _ are examples of irrefutable patterns. 5 comments</p></div>
<div class="paragraph"><p>Here&#8217;s a corrected version of this function. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BogusPattern.hs
betterFruit f = case f of
                  "apple"  &#8594; Apple
                  "orange" &#8594; Orange
4 comments
We fixed the problem by matching against the literal values "apple" and "orange". No comments</p></div>
<div class="paragraph"><p>Incorrectly trying to compare for equality
What if we want to compare the values stored in two nodes of type Tree, and return one of them if they&#8217;re equal? Here&#8217;s an attempt. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BadTree.hs
bad_nodesAreSame (Node a _ _) (Node a _ _) = Just a
bad_nodesAreSame _            _            = Nothing
3 comments
A name can only appear once in a set of pattern bindings. We cannot place a variable in multiple positions to express the notion “this value and that should be identical”. Instead, we&#8217;ll solve this problem using guards, another invaluable Haskell feature. No comments</p></div>
<div class="paragraph"><p>Conditional evaluation with guards
Pattern matching limites us to performing fixed tests of a value&#8217;s shape. Although this is useful, we will often want to make a more expressive check before evaluating a function&#8217;s body. Haskell provides a feature, guards, that give us this ability. We&#8217;ll introduce the idea with a modification of the function we wrote to compare two nodes of a tree. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/BadTree.hs
nodesAreSame (Node a _ _) (Node b _ _)
    | a == b     = Just a
nodesAreSame _ _ = Nothing
11 comments
In this example, we use pattern matching to ensure that we are looking at values of the right shape, and a guard to compare pieces of them. No comments</p></div>
<div class="paragraph"><p>A pattern can be followed by zero or more guards, each an expression of type Bool. A guard is introduced by a | symbol. This is followed by the guard expression, then an = symbol (or &#8594; if we&#8217;re in a case expression), then the body to use if the guard expression evaluates to True. If a pattern matches, each guard associated with that pattern is evaluated, in the order in which they are written. If a guard succeeds, the body affiliated with it is used as the result of the function. If no guard succeeds, pattern matching moves on to the next pattern. No comments</p></div>
<div class="paragraph"><p>When a guard expression is evaluated, all of the variables mentioned in the pattern with which it is associated are bound and can be used. No comments</p></div>
<div class="paragraph"><p>Here is a reworked version of our lend function that uses guards. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Lending.hs
lend3 amount balance
     | amount &#8656; 0            = Nothing
     | amount &gt; reserve * 0.5 = Nothing
     | otherwise              = Just newBalance
    where reserve    = 100
          newBalance = balance - amount
6 comments
The special-looking guard expression otherwise is simply a variable bound to the value True, to aid readability. No comments</p></div>
<div class="paragraph"><p>We can use guards anywhere that we can use patterns. Writing a function as a series of equations using pattern matching and guards can make it much clearer. Remember the myDrop function we defined in the section called “Conditional evaluation”? No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch02/myDrop.hs
myDrop n xs = if n &#8656; 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)
No comments
Here is a reformulation that uses patterns and guards. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch02/myDrop.hs
niceDrop n xs | n &#8656; 0 = xs
niceDrop _ []          = []
niceDrop n (_:xs)      = niceDrop (n - 1) xs
8 comments
This change in style lets us enumerate up front the cases in which we expect a function to behave differently. If we bury the decisions inside a function as if expressions, the code becomes harder to read. No comments</p></div>
<div class="paragraph"><p>Exercises
1.</p></div>
<div class="paragraph"><p>Write a function that computes the number of elements in a list. To test it, ensure that it gives the same answers as the standard length function. No comments</p></div>
<div class="paragraph"><p>2.</p></div>
<div class="paragraph"><p>Add a type signature for your function to your source file. To test it, load the source file into ghci again. No comments</p></div>
<div class="paragraph"><p>3.</p></div>
<div class="paragraph"><p>Write a function that computes the mean of a list, i.e. the sum of all elements in the list divided by its length. (You may need to use the fromIntegral function to convert the length of the list from an integer into a floating point number.) No comments</p></div>
<div class="paragraph"><p>4.</p></div>
<div class="paragraph"><p>Turn a list into a palindrome, i.e. it should read the same both backwards and forwards. For example, given the list [1,2,3], your function should return [1,2,3,3,2,1]. No comments</p></div>
<div class="paragraph"><p>5.</p></div>
<div class="paragraph"><p>Write a function that determines whether its input list is a palindrome. No comments</p></div>
<div class="paragraph"><p>6.</p></div>
<div class="paragraph"><p>Create a function that sorts a list of lists based on the length of each sublist. (You may want to look at the sortBy function from the Data.List module.) No comments</p></div>
<div class="paragraph"><p>7.</p></div>
<div class="paragraph"><p>Define a function that joins a list of lists together using a separator value. No comments</p></div>
<div class="paragraph"><p>&#8212;&#8201;file: ch03/Intersperse.hs
intersperse :: a &#8594; <a id="a"></a> &#8594; [a]
5 comments
The separator should appear between elements of the list, but should not follow the last element. Your function should behave as follows. No comments</p></div>
<div class="paragraph"><p>ghci&gt; :load Intersperse
[1 of 1] Compiling Main             ( Intersperse.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; intersperse <em>,</em> []
""
ghci&gt; intersperse <em>,</em> ["foo"]
"foo"
ghci&gt; intersperse <em>,</em> ["foo","bar","baz","quux"]
"foo,bar,baz,quux"
41 comments
8.</p></div>
<div class="paragraph"><p>Using the binary tree type that we defined earlier in this chapter, write a function that will determine the height of the tree. The height is the largest number of hops from the root to an Empty. For example, the tree Empty has height zero; Node "x" Empty Empty has height one; Node "x" Empty (Node "y" Empty Empty) has height two; and so on. No comments</p></div>
<div class="paragraph"><p>9.</p></div>
<div class="paragraph"><p>Consider three two-dimensional points a, b, and c. If we look at the angle formed by the line segment from a to b and the line segment from b to c, it either turns left, turns right, or forms a straight line. Define a Direction data type that lets you represent these possibilities. No comments</p></div>
<div class="paragraph"><p>10.</p></div>
<div class="paragraph"><p>Write a function that calculates the turn made by three 2D points and returns a Direction. No comments</p></div>
<div class="paragraph"><p>11.</p></div>
<div class="paragraph"><p>Define a function that takes a list of 2D points and computes the direction of each successive triple. Given a list of points [a,b,c,d,e], it should begin by computing the turn made by [a,b,c], then the turn made by [b,c,d], then [c,d,e]. Your function should return a list of Direction. No comments</p></div>
<div class="paragraph"><p>12.</p></div>
<div class="paragraph"><p>Using the code from the preceding three exercises, implement Graham&#8217;s scan algorithm for the convex hull of a set of 2D points. You can find good description of what a convex hull. is, and how the Graham scan</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-28 07:29:05 EET
</div>
</div>
</body>
</html>
