include::header.adoc[]

= Глава 3. Визначення типів, упорядкування функцій

== Визначення нового типу даних

Хоча списки та кортежі корисні, ми часто хочемо створити нові власні типи даних. Це дозволяє нам додати структуру до значень у наших програмах. Замість використання анонімного кортежу ми можемо дати колекції споріднених значень ім'я та виразний тип. Визначення власних типів також покращує безпеку типу нашого коду: Haskell не дозволить нам випадково змішати значення двох типів, які структурно схожі, але мають різні назви.

Для мотивації ми розглянемо кілька видів даних, якими може знадобитися керувати у невеликій інтернет-книгарні. Ми не будемо робити жодних спроб повних чи реалістичних визначень даних, але принаймні прив'язуємо їх до реального світу.

Ми визначаємо новий тип даних за допомогою ключового слова `data`.

[source,haskell]
----
-- file: ch03/BookStore.hs
data BookInfo = Book Int String [String]
                deriving (Show)
----

`BookInfo` після ключового слова `data` - це ім'я нашого нового типу. Ми називаємо `BookInfo` конструктором типу. Після того, як ми визначили тип, ми будемо використовувати його конструктор типів для посилання на нього. Як ми вже згадували, ім'я типу, та, отже, конструктор типу, повинні починатися з великої літери.

Далі слідує `Book` - це ім'я конструктора значень (іноді його називають конструктором даних). Ми використовуємо його для створення значення типу `BookInfo`. Ім’я конструктора значень також має починатися з великої літери.

Після `Book` ідуть `Int`, `String` і `[String]`, що випливають, є компонентами цього типу. Компонент служить тій самій цілі в Haskell, як і поле в структурі або класі іншою мовою: це "слот", де ми зберігаємо значення. (Ми часто називаємо компоненти як поля).

У цьому прикладі `Int` представляє ідентифікатор книги (наприклад, у фондовій базі даних), `String` його заголовок та `[String]` імена його авторів.

Щоб зробити посилання на концепцію, яку ми вже бачили, тип `BookInfo` містить ті самі компоненти, що і 3-місний кортеж типу `(Int, String, [String])`, але він має виразний тип. Ми не можемо випадково (або навмисно) використовувати один у контексті, коли очікується інший. Наприклад, книгарня також вірогідно має журнали.

[source,haskell]
----
-- file: ch03/BookStore.hs
data MagazineInfo = Magazine Int String [String]
                    deriving (Show)
----

Незважаючи на те, що цей тип `MagazineInfo` має таку ж структуру, як і наш тип BookInfo, Haskell розглядає типи як окремі, оскільки конструктори їх типу та значення мають різні назви.

.Виведення чого?
****
[NOTE]
Повний сенс `deriving (Show)` ми пояснимо пізніше, у розділі "Show". Наразі достатньо знати, що нам потрібно позначити це на декларації типу, щоб *ghci* автоматично знав, як друкувати значення цього типу.
****

Ми можемо створити нове значення типу `BookInfo`, трактуючи `Book` як функцію та застосувавши її до аргументів типів `Int`, `String` та `[String]`.

[source,haskell]
----
-- file: ch03/BookStore.hs
myInfo = Book 9780135072455 "Algebra of Programming"
         ["Richard Bird", "Oege de Moor"]
----

Після того, як ми визначили тип, ми можемо експериментувати з ним у *ghci*. Почнемо з команди `:load` для завантаження нашого вихідного файлу.

[source,haskell]
----
ghci> :load BookStore
[1 of 1] Compiling Main             ( BookStore.hs, interpreted )
Ok, modules loaded: Main.
----

Пам'ятаєте змінну `myInfo`, яку ми визначили у нашому вихідному файлі? Ось де вона.

[source,haskell]
----
ghci> myInfo
Book 9780135072455 "Algebra of Programming" ["Richard Bird","Oege de Moor"]
ghci> :type myInfo
myInfo :: BookInfo
----

Ми також можемо інтерактивно конструювати нові значення в *ghci*.

[source,haskell]
----
ghci> Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]
Book 0 "The Book of Imaginary Beings" ["Jorge Luis Borges"]
----

Команда *ghci* `:type` дозволяє нам побачити, яким є тип виразу.

[source,haskell]
----
ghci> :type Book 1 "Cosmicomics" ["Italo Calvino"]
Book 1 "Cosmicomics" ["Italo Calvino"] :: BookInfo
----

Пам’ятайте, що якщо ми хочемо визначити нову змінну всередині *ghci*, синтаксис трохи відрізняється від вихідного файлу Haskell: нам потрібно поставити попереду `let`.

[source,haskell]
----
ghci> let cities = Book 173 "Use of Weapons" ["Iain M. Banks"]
----

Щоб дізнатися більше про тип, ми можемо використовувати деякі можливості перегляду *ghci*. Команда `:info` змушує *ghci* повідомити нам усе, що знає про ім’я.

[source,haskell]
----
ghci> :info BookInfo
data BookInfo = Book Int String [String]
  	-- Defined at BookStore.hs:4:5-12
instance Show BookInfo -- Defined at BookStore.hs:4:5-12
----

Ми також можемо дізнатися, чому ми використовуємо `Book` для побудови нового значення типу `BookStore`.

[source,haskell]
----
ghci> :type Book
Book :: Int -> String -> [String] -> BookInfo
----

Ми можемо ставитися до конструктора значень як просто до іншої функції, яка може створювати та повертати нове значення типу, який ми бажаємо.

=== Назви типів та значень

Коли ми ввели тип `BookStore`, ми свідомо вирішили дати конструктору типу `BookStore` інше ім'я від конструктора значень `Book`, єдине щоб дати зрозуміти, що є що.

Однак у Haskell назви типів та значень не залежать один від одного. Ми використовуємо лише конструктор типів (тобто ім'я типу) у декларації типу або в сигнатурі типу. Ми використовуємо лише конструктор значень у фактичному коді. Оскільки ці способи використання неоднакові, немає двозначності, якщо ми дамо конструктору типів та конструктору значень те саме ім’я. Якщо ми пишемо тип сигнатури, ми повинні посилатись на конструктор типів. Якщо ми пишемо вираз, ми повинні використовувати конструктор значень.

[source,haskell]
----
-- file: ch03/BookStore.hs
-- Незабаром ми введемо тип CustomerID.

data BookReview = BookReview BookInfo CustomerID String
----

Це визначення говорить про те, що тип з назвою `BookReview` має конструктор значення, який також називається `BookReview`.

Мало того, що є _законним_, щоб конструктор значень мав те саме ім'я, що і його конструктор типів, це нормально: це ви будете бачити весь час у звичайному коді Haskell.

=== Синоніми типів

Ми можемо ввести синонім існуючого типу в будь-який час, щоб дати типу більш описову назву. Наприклад, `String` у нашому типі `BookReview` не говорить нам, для чого цей рядок, але ми можемо уточнити це.

[source,haskell]
----
-- file: ch03/BookStore.hs
type CustomerID = Int
type ReviewBody = String

data BetterReview = BetterReview BookInfo CustomerID ReviewBody
----

Ключове слово `type` вводить синонім типу. Нове ім’я знаходиться зліва від `=`, а існуюче ім'я праворуч. Два імені ототожнюють один і той же тип, тому синоніми типу є виключно для того, щоб зробити код читабельнішим.

Ми також можемо використовувати синонім типу, щоб створити коротше ім’я для балакучого типу.

[source,haskell]
----
-- file: ch03/BookStore.hs
type BookRecord = (BookInfo, BookReview)
----

Це говорить про те, що ми можемо використовувати `BookRecord` як синонім кортежу `(BookInfo, BookReview)`. Синонім типу створює лише нову назву, яка посилається на існуючий тип.footnote:[Якщо ви знайомі з C або C++, це аналогічно до typedef.] Ми все ще використовуємо однакові конструктори значень, щоб створити значення типу.

=== Алгебраїчні типи даних

Знайомий  нам `Bool` - найпростіший загальний приклад категорії типу, яка називається алгебраїчним типом даних. Алгебраїчний тип даних може мати більше одного конструктора значень.

[source,haskell]
----
-- file: ch03/Bool.hs
data Bool = False | True
----

Тип `Bool` має два конструктори значень, `True` та `False`. Кожен конструктор значення відокремлений у визначенні символом `|`, який ми можемо прочитати як "або": ми можемо побудувати `Bool`, який має значення `True`, або значення `False`. Коли тип має більше одного конструктора значень, вони зазвичай називаються альтернативами або випадками. Ми можемо використовувати будь-яку з альтернатив, щоб створити значення цього типу.

.Зауваження щодо іменування
****
[NOTE]	
Хоча словосполучення "тип алгебраїчних даних" є довгим, ми обережно уникаємо використання абревіатури "ADT". Ця абревіатура вже широко сприймається як «абстрактний тип даних». Оскільки Haskell підтримує як алгебраїчні, так і абстрактні типи даних, ми будемо чіткими і повністю уникатимемо абревіатур.
****

Кожен з конструкторів значеньалгебраїчного  типу даних може приймати нуль або більше аргументів. Наприклад, ось один із способів подання платіжної інформації.

[source,haskell]
----
-- file: ch03/BookStore.hs
type CardHolder = String
type CardNumber = String
type Address = [String]

data BillingInfo = CreditCard CardNumber CardHolder Address
                 | CashOnDelivery
                 | Invoice CustomerID
                   deriving (Show)
----

Тут ми говоримо, що ми підтримуємо три способи виставити рахунок своїм клієнтам. Якщо вони хочуть платити кредитною карткою, вони повинні надати номер картки, ім'я власника та адресу виставлення рахунку власника як аргументи конструктора значень `CreditCard`. Крім того, вони можуть оплатити готівкою кур'єру при доставці посилки. Оскільки нам не потрібно зберігати додаткову інформацію з цього приводу, ми не вказуємо аргументів для конструктора `CashOnDelivery`. Нарешті, ми можемо надіслати рахунок вказаному клієнту, і в цьому випадку нам потрібен його `CustomerID` як аргумент конструктору `Invoice`.

Коли ми використовуємо конструктор значень для створення значення типу `BillingInfo`, ми повинні надати аргументи, які воно вимагає.

[source,haskell]
----
ghci> :type CreditCard
CreditCard :: CardNumber -> CardHolder -> Address -> BillingInfo
ghci> CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens", "England"]
CreditCard "2901650221064486" "Thomas Gradgrind" ["Dickens","England"]
ghci> :type it
it :: BillingInfo
ghci> Invoice

<interactive>:1:0:
    No instance for (Show (CustomerID -> BillingInfo))
      arising from a use of `print' at <interactive>:1:0-6
    Possible fix:
      add an instance declaration for (Show (CustomerID -> BillingInfo))
    In the expression: print it
    In a 'do' expression: print it
ghci> :type it
it :: BillingInfo
----

Повідомлення про помилку примірника виникло, оскільки ми не подали аргумент конструктору `Invoice`. Як результат, ми намагалися надрукувати сам конструктор `Invoice`. Цей конструктор вимагає аргументу і повертає значення, тому це функція. Ми не можемо друкувати функції в Haskell, тому в кінцевому підсумку інтерпретатор поскаржився.

==== Кортежі, алгебраїчні типи даних та коли їх використовувати

Існує деякій збіг між кортежами та визначеними користувачем алгебраїчними типами даних. Якби ми цього хотіли, ми могли б представити наш тип `BookInfo` як кортеж `(Int, String, [String])`.

[source,haskell]
----
ghci> Book 2 "The Wealth of Networks" ["Yochai Benkler"]
Book 2 "The Wealth of Networks" ["Yochai Benkler"]
ghci> (2, "The Wealth of Networks", ["Yochai Benkler"])
(2,"The Wealth of Networks",["Yochai Benkler"])
----

Алгебраїчні типи даних дозволяють нам розрізняти інакше однакові фрагменти інформації. Два кортежі з елементами одного типу структурно однакові, тому вони мають однаковий тип.

[source,haskell]
----
-- file: ch03/Distinction.hs
a = ("Porpoise", "Grey")
b = ("Table", "Oak")
----

Оскільки вони мають різні назви, два типи алгебраїчних даних мають різні типи, навіть якщо вони в іншому випадку структурно еквівалентні.

[source,haskell]
----
-- file: ch03/Distinction.hs
data Cetacean = Cetacean String String
data Furniture = Furniture String String

c = Cetacean "Porpoise" "Grey"
d = Furniture "Table" "Oak"
----

Це дозволяє нам привести систему типів до роботи в програмах з меншою кількістю помилок. За допомогою визначених вище кортежів ми могли б передати опис кита функції, яка очікує стілець, і система типів нам не змогла б допомогти. З алгебраїчними типами даних немаєможливості для такої плутанини.

Ось більш тонкий приклад. Розглянемо наступні подання двовимірного вектора.

[source,haskell]
----
-- file: ch03/AlgebraicVector.hs
--  x і y координати або довжини.
data Cartesian2D = Cartesian2D Double Double
                   deriving (Eq, Show)

-- Кут і відстань (магнітуда).
data Polar2D = Polar2D Double Double
               deriving (Eq, Show)
----

Декартові та полярні форми використовують однакові типи для своїх двох елементів. Однак значення елементів різні. Оскільки `Cartesian2D` і `Polar2D` є різними типами, система типів не дозволить нам випадково використовувати декартові `Cartesian2D`, де очікується `Polar2D`, або навпаки.

[source,haskell]
----
ghci> Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2

<interactive>:1:33:
    Couldn't match expected type `Cartesian2D'
           against inferred type `Polar2D'
    In the second argument of `(==)', namely `Polar2D (pi / 4) 2'
    In the expression:
          Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
    In the definition of `it':
        it = Cartesian2D (sqrt 2) (sqrt 2) == Polar2D (pi / 4) 2
----

Оператор `(==)` вимагає, щоб його аргументи були одного типу.

.Порівняння на рівність
****
[TIP]
Зауважте, що у `deriving` для наших типів векторів ми додали ще одне слово, `Eq`. Це змушує реалізацію Haskell генерувати код, який дозволяє нам порівнювати значення на рівність.
****

Якби ми використали кортежі для представлення цих значень, ми могли б швидко приземлитися в гарячу воду, недоречно змішавши ці два представлення.

[source,haskell]
----
ghci> (1, 2) == (1, 2)
True
----

Система типів не може нас тут врятувати: наскільки можливо здогадатись, ми порівнюємо дві пари `(Double, Double)`, що цілком можливо зробити. Дійсно, ми не можемо перевірити і сказати, яке з цих значень має бути полярним чи декартовим, але `(1,2)` має різне значення в кожному випадку.

Немає жорсткого і швидкого правила для вирішення питання про те, коли краще використовувати кортеж або окремий тип даних, але ось головне правило, якого слід дотримуватися. Якщо ви широко використовуєте у своєму коді складені значення (як це роблять майже всі нетривіальні програми), додавання декларацій даних принесе вам користь як у безпеці, так і в читанні. Для менших локалізованих застосувань - кортеж, як правило, досить добрий.

==== Аналоги алгебраїчним типам даних в інших мовах

Алгебраїчні типи даних забезпечують єдиний потужний спосіб опису типів даних. Інші мови часто потребують декількох різних властивостей, щоб досягти того самого ступеня виразності. Ось кілька аналогів C та C ++, які допоможуть зрозуміти, що ми можемо зробити з алгебраїчними типами даних та як вони співвідносяться до понять, які можуть бути більш звичними.

=== Структури

Лише з одним конструктором алгебраїчний тип даних схожий на кортеж: він об'єднує пов'язані значення разом у складене значення. Він відповідає структурі в С або С ++, а його компоненти відповідають полям структури. Ось C-еквівалент типу `BookInfo`, який ми визначили раніше.

[source,c]
----
struct book_info {
    int id;
    char *name;
    char **authors;
};
----

Основна відмінність між ними полягає в тому, що поля типу Haskell є анонімними та позиційними.

[source,haskell]
----
-- file: ch03/BookStore.hs
data BookInfo = Book Int String [String]
                deriving (Show)
----

Під позиційністю ми маємо на увазі, що номер розділу знаходиться в першому полі типу Haskell, а заголовок - у другому. Ми посилаємось на них за місцем розташування, а не за назвою.

У розділі під назвою "Зіставлення шаблонів" ми побачимо, як отримати доступ до полів значення `BookStore`. У розділі «Синтаксис запису» ми введемо альтернативний синтаксис для визначення типів даних, який виглядає трохи більше подібним до С.

=== Перерахування

Алгебраїчні типи даних також служать там, де ми будемо використовувати `enum` в C або C ++, щоб представити діапазон символічних значень. Такі типи алгебраїчних даних іноді називають типами перерахування. Ось приклад із C.

[source,c]
----
enum roygbiv {
    red,
    orange,
    yellow,
    green,
    blue,
    indigo,
    violet,
};
----

А ось еквівалент Haskell

[source,haskell]
----
-- file: ch03/Roygbiv.hs
data Roygbiv = Red
             | Orange
             | Yellow
             | Green
             | Blue
             | Indigo
             | Violet
               deriving (Eq, Show)
----

Ми можемо спробувати їх у *ghci*.

[source,haskell]
----
ghci> :type Yellow
Yellow :: Roygbiv
ghci> :type Red
Red :: Roygbiv
ghci> Red == Yellow
False
ghci> Green == Green
True
----

У C елементами `enum` є цілі числа. Ми можемо використовувати ціле число в контексті, де очікується перерахунок, і навпаки: компілятор C автоматично перетворить значення між двома типами. Це може стати джерелом неприємних помилок. У Haskell подібного роду проблеми не виникає. Наприклад, ми не можемо використовувати значення `Roygbiv` там, де очікується `Int`.

[source,haskell]
----
ghci> take 3 "foobar"
"foo"
ghci> take Red "foobar"

<interactive>:1:5:
    Couldn't match expected type `Int' against inferred type `Roygbiv'
    In the first argument of `take', namely `Red'
    In the expression: take Red "foobar"
    In the definition of `it': it = take Red "foobar"
----

=== Дискриміновані об'єднання

Якщо алгебраїчний тип даних має декілька альтернатив, ми можемо вважати це подібним до об'єднання в C або C ++. Велика різниця між ними полягає в тому, що об'єднання не говорить нам, яка альтернатива є насправді; ми повинні чітко і вручну відстежувати, яку альтернативу ми використовуємо, як правило, в іншому полі оточуючої структури. Це означає, що об'єднання можуть бути джерелами неприємних помилок, де наше уявлення про альтернативу, яку ми маємо використовувати, неправильне.

[source,c]
----
enum shape_type {
    shape_circle,
    shape_poly,
};

struct circle {
    struct vector centre;
    float radius;
};

struct poly {
    size_t num_vertices;
    struct vector *vertices;
};

struct shape 
{
    enum shape_type type;
    union {
	struct circle circle;
	struct poly poly;
    } shape;
};
----

У наведеному вище прикладі `union` може містити дійсні дані або для `struct circle` або `struct poly`. Нам потрібно використовувати `enum shape_type` вручну, щоб вказати, яке значення в даний час зберігається в об'єднанні.

Версія цього коду в Haskell суттєво коротша та безпечніша, ніж еквівалент C.

[source,haskell]
----
-- file: ch03/ShapeUnion.hs
type Vector = (Double, Double)

data Shape = Circle Vector Double
           | Poly [Vector]
----

Якщо ми створюємо значення `Shape` за допомогою конструктора `Circle`, зберігається факт, що ми створили `Circle`. Коли ми пізніше використовуємо `Circle`, ми не можемо випадково трактувати його як `Square`. Ми побачимо, чому в розділі "Зіставлення шаблонів".

.Декілька зауважень
****
[TIP]
Прочитавши попередні розділи, тепер повинно бути зрозуміло, що всі типи даних, які ми визначаємо за допомогою ключового слова `data`, є алгебраїчними типами даних. Деякі можуть мати лише одну альтернативу, а інші - кілька, але всі вони використовують однакові механізми.
****

=== Зіставлення шаблонів

Тепер, коли ми побачили, як будувати значення з алгебраїчними типами даних, давайте обговоримо, як ми працюємо з цими значеннями. Якщо у нас є значення якогось типу, ми хочемо зробити дві речі.

* Якщо тип має більше одного конструктора значень, ми повинні мати можливість сказати, який конструктор значень використовувався для створення значення.
* Якщо в конструкторі значень є компоненти даних, нам потрібно мати можливість витягувати ці значення.

У Haskell є простий, але надзвичайно корисний інструмент зіставлення шаблонів, який дозволяє нам робити обидві речі.

A pattern lets us look inside a value and bind variables to the data it contains. Here's an example of pattern matching in action on a Bool value: we're going to reproduce the not function.
Шаблон дозволяє нам зазирнути всередину значення і прив'язувати змінні до даних, які він містить. Ось приклад зіставлення шаблону в дії на значенні `Bool`: ми будемо відтворювати функцію `not`.

[source,haskell]
----
-- file: ch03/add.hs
myNot True  = False
myNot False = True
----

Може здатися, що у нас є дві функції з ім'ям `myNot`, але Haskell дозволяє нам визначити функцію як ряд рівнянь: ці дві пропозиції визначають поведінку тієї ж функції для різних шаблонів на вході. У кожному рядку шаблони - це елементи, що відповідають імені функції, аж до знака `=`.

Щоб зрозуміти, як працює зіставлення шаблонів, давайте переглянемо приклад, скажімо, `myNot False`.

Коли ми застосовуємо `myNot`, середовище виконання Haskell перевіряє значення, яке ми надаємо, у конструкторі значень у першому шаблоні. Це не співпадає, тому воно намагається застосватись до другого шаблону. Цей збіг є успішним, тому він використовує праву частину цього рівняння як результат застосування функції.

Ось трохи більш розширений приклад. Ця функція поєднує елементи списку.

[source,haskell]
----
-- file: ch03/add.hs
sumList (x:xs) = x + sumList xs
sumList []     = 0
----

Дозвольте нам пройти обчислення `sumList [1,2]`. Позначення списку `[1,2]` є скороченням для виразу `(1: (2: []))`. Почнемо зі спроби зіставити шаблон у першому рівнянні визначення `sumList`. У шаблоні `(x: xs)` ":" є знайомим конструктором списку `(:)`. Зараз ми використовуємо це для співставлення зі значенням, а не для його побудови. Значення `(1: (2: []))` було побудоване з `(:)`, тому конструктор у значенні відповідає конструктору за шаблоном. Ми кажемо, що шаблон збігається, або що збіг вдалий.

Змінні `x` і `xs` тепер "прив'язані" до аргументів конструктора, тому `x` дається значення `1`, а `xs` значення `2: []`.

Вираз, який ми зараз оцінюємо, становить `1 + sumList (2: [])`. Тепер ми повинні рекурсивно застосовувати `sumList` до значення `2: []`. Знову ж таки, це було побудовано за допомогою `(:)`, так що співпадіння вдається. У нашому рекурсивному застосуванні `sumList` `x` тепер прив’язаний до `2`, а `xs` до `[]`.

Зараз ми оцінюємо `1 + (2 + sumList [])`. У цьому рекурсивному застосуванні `sumList` значення, з яким ми співставляємо, є `[]`. Конструктор значення не відповідає конструктору в першому шаблоні, тому ми пропускаємо це рівняння. Натомість ми “провалюємось” до наступного шаблону, який співпадає. Таким чином, як результат цієї програми вибирається права частина цього рівняння.

Таким чином, результат `SumList [1,2]` дорівнює `1 + (2 + (0))`, або `3`.

.Порядок важливий
****
[NOTE]
Як ми вже згадували, реалізація Haskell перевіряє шаблони відповідності в тому порядку, в якому ми їх визначаємо в наших рівняннях. Збіг триває зверху вниз і зупиняється на першому успіху. Рівняння нижче успішного співпадіння ні на що не впливають.
****

На завершення, вже існує стандартна функція, `sum`, яка виконує цю операцію для нас. Наш `sumList` суто для ілюстрації.

==== Конструкція та деконструкція

Давайте відступимо назад і подивимось на зв’язок між побудовою значення та співпадінням шаблону на ньому.

Ми застосовуємо конструктор значення для побудови значення. Вираз `Book 9 "Close Calls" ["John Long"]` застосовує конструктор `Book` до значень `9`, `"Close Calls"` та `["John Long"]`, щоб створити нове значення типу `BookInfo`.

Коли ми співставляємо шаблон з конструктором `Book`, ми обертаємо процес побудови. Перш за все, ми перевіряємо, чи було створено значення за допомогою цього конструктора. Якщо це так, ми досліджуємо його, щоб отримати індивідуальні значення, які ми спочатку постачали конструктору, коли ми створювали значення.

Розглянемо, що станеться, якщо ми співставимо шаблон `(Book id name authors)` з нашим прикладом виразу.

* Збіг буде успішним, оскільки конструктор за значенням відповідає тому, що є в нашому шаблоні.
* Змінна `id` буде прив’язана до 9.
* Змінна `name` буде прив’язана до `"Close Calls"`.
* Змінна `authors` буде прив’язана до `["John Long"]`.

Оскільки відповідність шаблону виступає як зворотна конструкція, його іноді називають деконструкцією.

.Деконструкція нічого не знищує
****
[NOTE]	
Якщо ви заглиблені в об'єктно-орієнтований жаргон програмування, не плутайте деконструкцію з деструкцією! Відповідність шаблону не впливає на значення, яке ми вивчаємо: воно лише дозволяє нам “заглянути всередину”.
****

==== Подальші пригоди

Синтаксис відповідності шаблону на кортежі аналогічний синтаксису для побудови кортежу. Ось функція, яка повертає останній елемент 3-кортежа.

[source,haskell]
----
-- file: ch03/Tuple.hs
third (a, b, c) = c
----

Немає обмежень щодо того, як "глибоко" всередині значення може виглядати шаблон. Це визначення виглядає як усередині кортежу, так і всередині списку всередині цього кортежу.

[source,haskell]
----
-- file: ch03/Tuple.hs
complicated (True, a, x:xs, 5) = (a, xs)
----

Ми можемо спробувати це інтерактивно.

[source,haskell]
----
ghci> :load Tuple.hs
[1 of 1] Compiling Main             ( Tuple.hs, interpreted )
Ok, modules loaded: Main.
ghci> complicated (True, 1, [1,2,3], 5)
(1,[2,3])
----

Там, де в шаблоні присутнє буквальне значення (`True` і `5` в шаблоні кортежу вище), це значення повинно відповідати точно для успішного збігу шаблонів. Якщо кожен шаблон у ряді рівнянь не збігається, ми отримуємо помилку виконання.

[source,haskell]
----
ghci> complicated (False, 1, [1,2,3], 5)
*** Exception: Tuple.hs:10:0-39: Non-exhaustive patterns in function complicated
----

Для пояснення цього повідомлення про помилку пропустіть трохи вперед, до розділу під назвою «Вичерпні шаблони та підстановки».

Ми можемо співставляти шаблони на алгебраїчних типах даних, використовуючиїх конструктори значень. Згадайте тип `BookInfo`, який ми визначили раніше: ми можемо витягувати значення з `BookInfo` наступним чином.

[source,haskell]
----
-- file: ch03/BookStore.hs
bookID      (Book id title authors) = id
bookTitle   (Book id title authors) = title
bookAuthors (Book id title authors) = authors
----

Let's see it in action.

ghci> bookID (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
3
ghci> bookTitle (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
"Probability Theory"
ghci> bookAuthors (Book 3 "Probability Theory" ["E.T.H. Jaynes"])
["E.T.H. Jaynes"]

The compiler can infer the types of the accessor functions based on the constructor we're using in our pattern.

ghci> :type bookID
bookID :: BookInfo -> Int
ghci> :type bookTitle
bookTitle :: BookInfo -> String
ghci> :type bookAuthors
bookAuthors :: BookInfo -> [String]

If we use a literal value in a pattern, the corresponding part of the value we're matching against must contain an identical value. For instance, the pattern (3:xs) first of all checks that a value is a non-empty list, by matching against the (:) constructor. It also ensures that the head of the list has the exact value 3. If both of these conditions hold, the tail of the list will be bound to the variable xs.

Variable naming in patterns
As you read functions that match on lists, you'll frequently find that the names of the variables inside a pattern resemble (x:xs) or (d:ds). This is a popular naming convention. The idea is that the name xs has an “s” on the end of its name as if it's the “plural” of x, because x contains the head of the list, and xs the remaining elements.

The wild card pattern
We can indicate that we don't care what is present in part of a pattern. The notation for this is the underscore character “_”, which we call a wild card. We use it as follows.

-- file: ch03/BookStore.hs
nicerID      (Book id _     _      ) = id
nicerTitle   (Book _  title _      ) = title
nicerAuthors (Book _  _     authors) = authors

Here, we have tidier versions of the accessor functions we introduced earlier. Now, there's no question about which element we're using in each function.

In a pattern, a wild card acts similarly to a variable, but it doesn't bind a new variable. As the examples above indicate, we can use more than one wild card in a single pattern.

Another advantage of wild cards is that a Haskell compiler can warn us if we introduce a variable name in a pattern, but do not use it in a function's body. Defining a variable, but forgetting to use it, can often indicate the presence of a bug, so this is a helpful feature. If we use a wild card instead of a variable that we do not intend to use, the compiler won't complain.

Exhaustive patterns and wild cards
When writing a series of patterns, it's important to cover all of a type's constructors. For example, if we're inspecting a list, we should have one equation that matches the non-empty constructor (:), and one that matches the empty-list constructor [].

Let's see what happens if we fail to cover all the cases. Here, we deliberately omit a check for the [] constructor.

-- file: ch03/BadPattern.hs
badExample (x:xs) = x + badExample xs

If we apply this to a value that it cannot match, we'll get an error at runtime: our software has a bug!

ghci> badExample []
*** Exception: BadPattern.hs:4:0-36: Non-exhaustive patterns in function badExample


In this example, no equation in the function's definition matches the value [].

[Tip]	Warning about incomplete patterns
GHC provides a helpful compilation option, -fwarn-incomplete-patterns, that will cause it to print a warning during compilation if a sequence of patterns don't match all of a type's value constructors.

If we need to provide a default behavior in cases where we don't care about specific constructors, we can use a wild card pattern.

-- file: ch03/BadPattern.hs
goodExample (x:xs) = x + goodExample xs
goodExample _      = 0

The wild card above will match the [] constructor, so applying this function does not lead to a crash.

ghci> goodExample []
0
ghci> goodExample [1,2]
3

=== Синтаксис запису
Writing accessor functions for each of a data type's components can be repetitive and tedious.

-- file: ch03/BookStore.hs
nicerID      (Book id _     _      ) = id
nicerTitle   (Book _  title _      ) = title
nicerAuthors (Book _  _     authors) = authors

We call this kind of code boilerplate: necessary, but bulky and irksome. Haskell programmers don't like boilerplate. Fortunately, the language addresses this particular boilerplate problem: we can define a data type, and accessors for each of its components, simultaneously. (The positions of the commas here is a matter of preference. If you like, put them at the end of a line instead of the beginning.)

-- file: ch03/BookStore.hs
data Customer = Customer {
      customerID      :: CustomerID
    , customerName    :: String
    , customerAddress :: Address
    } deriving (Show)

This is almost exactly identical in meaning to the following, more familiar form.

-- file: ch03/AltCustomer.hs
data Customer = Customer Int String [String]
                deriving (Show)

customerID :: Customer -> Int
customerID (Customer id _ _) = id

customerName :: Customer -> String
customerName (Customer _ name _) = name

customerAddress :: Customer -> [String]
customerAddress (Customer _ _ address) = address

For each of the fields that we name in our type definition, Haskell creates an accessor function of that name.

ghci> :type customerID
customerID :: Customer -> CustomerID

We can still use the usual application syntax to create a value of this type.

-- file: ch03/BookStore.hs
customer1 = Customer 271828 "J.R. Hacker"
            ["255 Syntax Ct",
             "Milpitas, CA 95134",
             "USA"]

Record syntax adds a more verbose notation for creating a value. This can sometimes make code more readable. 

-- file: ch03/BookStore.hs
customer2 = Customer {
              customerID = 271828
            , customerAddress = ["1048576 Disk Drive",
                                 "Milpitas, CA 95134",
                                 "USA"]
            , customerName = "Jane Q. Citizen"
            }

If we use this form, we can vary the order in which we list fields. Here, we have moved the name and address fields from their positions in the declaration of the type.

When we define a type using record syntax, it also changes the way the type's values are printed.

ghci> customer1
Customer {customerID = 271828, customerName = "J.R. Hacker", customerAddress = ["255 Syntax Ct","Milpitas, CA 95134","USA"]}

For comparison, let's look at a BookInfo value; we defined this type without record syntax.

ghci> cities
Book 173 "Use of Weapons" ["Iain M. Banks"]

The accessor functions that we get “for free” when we use record syntax really are normal Haskell functions.

ghci> :type customerName
customerName :: Customer -> String
ghci> customerName customer1
"J.R. Hacker"

The standard System.Time module makes good use of record syntax. Here's a type defined in that module:

data CalendarTime = CalendarTime {
  ctYear                      :: Int,
  ctMonth                     :: Month,
  ctDay, ctHour, ctMin, ctSec :: Int,
  ctPicosec                   :: Integer,
  ctWDay                      :: Day,
  ctYDay                      :: Int,
  ctTZName                    :: String,
  ctTZ                        :: Int,
  ctIsDST                     :: Bool
}
    

In the absence of record syntax, it would be painful to extract specific fields from a type like this. The notation makes it easier to work with large structures.

Parameterised types
We've repeatedly mentioned that the list type is polymorphic: the elements of a list can be of any type. We can also add polymorphism to our own types. To do this, we introduce type variables into a type declaration. The Prelude defines a type named Maybe: we can use this to represent a value that could be either present or missing, e.g. a field in a database row that could be null.

-- file: ch03/Nullable.hs
data Maybe a = Just a
             | Nothing

Here, the variable a is not a regular variable: it's a type variable. It indicates that the Maybe type takes another type as its parameter. This lets us use Maybe on values of any type.

-- file: ch03/Nullable.hs
someBool = Just True

someString = Just "something"

As usual, we can experiment with this type in *ghci*.

ghci> Just 1.5
Just 1.5
ghci> Nothing
Nothing
ghci> :type Just "invisible bike"
Just "invisible bike" :: Maybe [Char]

Maybe is a polymorphic, or generic, type. We give the Maybe type constructor a parameter to create a specific type, such as Maybe Int or Maybe [Bool]. As we might expect, these types are distinct.

We can nest uses of parameterised types inside each other, but when we do, we may need to use parentheses to tell the Haskell compiler how to parse our expression. 

-- file: ch03/Nullable.hs
wrapped = Just (Just "wrapped")

To once again extend an analogy to more familiar languages, parameterised types bear some resemblance to templates in C++, and to generics in Java. Just be aware that this is a shallow analogy. Templates and generics were added to their respective languages long after the languages were initially defined, and have an awkward feel. Haskell's parameterised types are simpler and easier to use, as the language was designed with them from the beginning.

Recursive types
The familiar list type is recursive: it's defined in terms of itself. To understand this, let's create our own list-like type. We'll use Cons in place of the (:) constructor, and Nil in place of [].

-- file: ch03/ListADT.hs
data List a = Cons a (List a)
            | Nil
              deriving (Show)

Because List a appears on both the left and the right of the = sign, the type's definition refers to itself. If we want to use the Cons constructor to create a new value, we must supply one value of type a, and another of type List a. Let's see where this leads us in practice.

The simplest value of type List a that we can create is Nil. Save the type definition in a file, then load it into *ghci*. 

ghci> Nil
Nil

Because Nil has a List type, we can use it as a parameter to Cons.

ghci> Cons 0 Nil
Cons 0 Nil

And because Cons 0 Nil has the type List a, we can use this as a parameter to Cons. 

ghci> Cons 1 it
Cons 1 (Cons 0 Nil)
ghci> Cons 2 it
Cons 2 (Cons 1 (Cons 0 Nil))
ghci> Cons 3 it
Cons 3 (Cons 2 (Cons 1 (Cons 0 Nil)))

We could continue in this fashion indefinitely, creating ever longer Cons chains, each with a single Nil at the end.

[Tip]	Is List an acceptable list?
We can easily prove to ourselves that our List a type has the same shape as the built-in list type [a]. To do this, we write a function that takes any value of type [a], and produces a value of type List a.

-- file: ch03/ListADT.hs
fromList (x:xs) = Cons x (fromList xs)
fromList []     = Nil

By inspection, this clearly substitutes a Cons for every (:), and a Nil for each []. This covers both of the built-in list type's constructors. The two types are isomorphic; they have the same shape.

ghci> fromList "durian"
Cons 'd' (Cons 'u' (Cons 'r' (Cons 'i' (Cons 'a' (Cons 'n' Nil)))))
ghci> fromList [Just True, Nothing, Just False]
Cons (Just True) (Cons Nothing (Cons (Just False) Nil))

For a third example of what a recursive type is, here is a definition of a binary tree type.

-- file: ch03/Tree.hs
data Tree a = Node a (Tree a) (Tree a)
            | Empty
              deriving (Show)

A binary tree is either a node with two children, which are themselves binary trees, or an empty value.

This time, let's search for insight by comparing our definition with one from a more familiar language. Here's a similar class definition in Java.

class Tree<A>
{
    A value;
    Tree<A> left;
    Tree<A> right;

    public Tree(A v, Tree<A> l, Tree<A> r)
    {
	value = v;
	left = l;
	right = r;
    }
}

The one significant difference is that Java lets us use the special value null anywhere to indicate “nothing”, so we can use null to indicate that a node is missing a left or right child. Here's a small function that constructs a tree with two leaves (a leaf, by convention, has no children).

class Example 
{
    static Tree<String> simpleTree()
    {
	return new Tree<String>(
            "parent",
	    new Tree<String>("left leaf", null, null),
	    new Tree<String>("right leaf", null, null));
    }
}

In Haskell, we don't have an equivalent of null. We could use the Maybe type to provide a similar effect, but that bloats the pattern matching. Instead, we've decided to use a no-argument Empty constructor. Where the Java example provides null to the Tree constructor, we supply Empty in Haskell.

-- file: ch03/Tree.hs
simpleTree = Node "parent" (Node "left child" Empty Empty)
                           (Node "right child" Empty Empty)

Exercises
1.

Write the converse of fromList for the List type: a function that takes a List a and generates a [a].

2.

Define a tree type that has only one constructor, like our Java example. Instead of the Empty constructor, use the Maybe type to refer to a node's children.

Reporting errors
Haskell provides a standard function, error :: String -> a, that we can call when something has gone terribly wrong in our code. We give it a string parameter, which is the error message to display. Its type signature looks peculiar: how can it produce a value of any type a given only a string?

It has a result type of a so that we can call it anywhere and it will always have the right type. However, it does not return a value like a normal function: instead, it immediately aborts evaluation, and prints the error message we give it.

The mySecond function returns the second element of its input list, but fails if its input list isn't long enough. 

-- file: ch03/MySecond.hs
mySecond :: [a] -> a

mySecond xs = if null (tail xs)
              then error "list too short"
              else head (tail xs)

As usual, we can see how this works in practice in *ghci*.

ghci> mySecond "xi"
'i'
ghci> mySecond [2]
*** Exception: list too short
ghci> head (mySecond [[9]])
*** Exception: list too short

Notice the third case above, where we try to use the result of the call to mySecond as the argument to another function. Evaluation still terminates and drops us back to the *ghci* prompt. This is the major weakness of using error: it doesn't let our caller distinguish between a recoverable error and a problem so severe that it really should terminate our program.

As we have already seen, a pattern matching failure causes a similar unrecoverable error.

ghci> mySecond []
*** Exception: Prelude.tail: empty list

A more controlled approach
We can use the Maybe type to represent the possibility of an error.

If we want to indicate that an operation has failed, we can use the Nothing constructor. Otherwise, we wrap our value with the Just constructor.

Let's see how our mySecond function changes if we return a Maybe value instead of calling error.

-- file: ch03/MySecond.hs
safeSecond :: [a] -> Maybe a

safeSecond [] = Nothing
safeSecond xs = if null (tail xs)
                then Nothing
                else Just (head (tail xs))

If the list we're passed is too short, we return Nothing to our caller. This lets them decide what to do, where a call to error would force a crash.

ghci> safeSecond []
Nothing
ghci> safeSecond [1]
Nothing
ghci> safeSecond [1,2]
Just 2
ghci> safeSecond [1,2,3]
Just 2

To return to an earlier topic, we can further improve the readability of this function with pattern matching.

-- file: ch03/MySecond.hs
tidySecond :: [a] -> Maybe a

tidySecond (_:x:_) = Just x
tidySecond _       = Nothing

The first pattern only matches if the list is at least two elements long (it contains two list constructors), and it binds the variable x to the list's second element. The second pattern is matched if the first fails.

Introducing local variables
Within the body of a function, we can introduce new local variables whenever we need them, using a let expression. Here is a simple function that determines whether we should lend some money to a customer. We meet a money reserve of at least 100, we return our new balance after subtracting the amount we have loaned.

-- file: ch03/Lending.hs
lend amount balance = let reserve    = 100
                          newBalance = balance - amount
                      in if balance < reserve
                         then Nothing
                         else Just newBalance

The keywords to look out for here are let, which starts a block of variable declarations, and in, which ends it. Each line introduces a new variable. The name is on the left of the =, and the expression to which it is bound is on the right.

[Note]	Special notes
Let us re-emphasise our wording: a name in a let block is bound to an expression, not to a value. Because Haskell is a lazy language, the expression associated with a name won't actually be evaluated until it's needed. In the above example, we will not compute the value of newBalance if we do not meet our reserve.

When we define a variable in a let block, we refer to it as a let-bound variable. This simply means what it says: we have bound the variable in a let block.

Also, our use of white space here is important. We'll talk in more detail about the layout rules in the section called “The offside rule and white space in an expression”.

We can use the names of a variable in a let block both within the block of declarations and in the expression that follows the in keyword.

In general, we'll refer to the places within our code where we can use a name as the name's scope. If we can use a name, it's in scope, otherwise it's out of scope. If a name is visible throughout a source file, we say it's at the top level.

Shadowing
We can “nest” multiple let blocks inside each other in an expression.

-- file: ch03/NestedLets.hs
foo = let a = 1
      in let b = 2
         in a + b

It's perfectly legal, but not exactly wise, to repeat a variable name in a nested let expression.

-- file: ch03/NestedLets.hs
bar = let x = 1
      in ((let x = "foo" in x), x)

Here, the inner x is hiding, or shadowing, the outer x. It has the same name, but a different type and value. 

ghci> bar
("foo",1)

We can also shadow a function's parameters, leading to even stranger results. What is the type of this function?

-- file: ch03/NestedLets.hs
quux a = let a = "foo"
         in a ++ "eek!"

Because the function's argument a is never used in the body of the function, due to being shadowed by the let-bound a, the argument can have any type at all.

ghci> :type quux
quux :: t -> [Char]

[Tip]	Compiler warnings are your friends
Shadowing can obviously lead to confusion and nasty bugs, so GHC has a helpful -fwarn-name-shadowing option. When enabled, GHC will print a warning message any time we shadow a name.

The where clause
We can use another mechanism to introduce local variables: the where clause. The definitions in a where clause apply to the code that precedes it. Here's a similar function to lend, using where instead of let.

-- file: ch03/Lending.hs
lend2 amount balance = if amount < reserve * 0.5
                       then Just newBalance
                       else Nothing
    where reserve    = 100
          newBalance = balance - amount

While a where clause may initially seem weird, it offers a wonderful aid to readability. It lets us direct our reader's focus to the important details of an expression, with the supporting definitions following afterwards. After a while, you may find yourself missing where clauses in languages that lack them.

As with let expressions, white space is significant in where clauses. We will talk more about the layout rules shortly, in the section called “The offside rule and white space in an expression”.

Local functions, global variables
You'll have noticed that Haskell's syntax for defining a variable looks very similar to its syntax for defining a function. This symmetry is preserved in let and where blocks: we can define local functions just as easily as local variables.

-- file: ch03/LocalFunction.hs
pluralise :: String -> [Int] -> [String]
pluralise word counts = map plural counts
    where plural 0 = "no " ++ word ++ "s"
          plural 1 = "one " ++ word
          plural n = show n ++ " " ++ word ++ "s"

We have defined a local function, plural, that consists of several equations. Local functions can freely use variables from the scopes that enclose them: here, we use word from the definition of the outer function pluralise. In the definition of pluralise, the map function (which we'll be revisiting in the next chapter) applies the local function plural to every element of the counts list.

We can also define variables, as well as functions, at the top level of a source file.

-- file: ch03/GlobalVariable.hs
itemName = "Weighted Companion Cube"

The offside rule and white space in an expression
In our definitions of lend and lend2, the left margin of our text wandered around quite a bit. This was not an accident: in Haskell, white space has meaning.

Haskell uses indentation as a cue to parse sections of code. This use of layout to convey structure is sometimes called the offside rule. At the beginning of a source file, the first top level declaration or definition can start in any column, and the Haskell compiler or interpreter remembers that indentation level. Every subsequent top level declaration must have the same indentation.

Here's an illustration of the top level indentation rule. Our first file, GoodIndent.hs, is well behaved. 

-- file: ch03/GoodIndent.hs
-- This is the leftmost column.

  -- It's fine for top-level declarations to start in any column...
  firstGoodIndentation = 1

  -- ...provided all subsequent declarations do, too!
  secondGoodIndentation = 2

Our second, BadIndent.hs, doesn't play by the rules.

-- file: ch03/BadIndent.hs
-- This is the leftmost column.

    -- Our first declaration is in column 4.
    firstBadIndentation = 1

  -- Our second is left of the first, which is illegal!
  secondBadIndentation = 2

Here's what happens when we try to load the two files into *ghci*.

ghci> :load GoodIndent.hs
[1 of 1] Compiling Main             ( GoodIndent.hs, interpreted )
Ok, modules loaded: Main.
ghci> :load BadIndent.hs
[1 of 1] Compiling Main             ( BadIndent.hs, interpreted )

BadIndent.hs:8:2: parse error on input `secondBadIndentation'
Failed, modules loaded: none.

An empty following line is treated as a continuation of the current item, as is a following line indented further to the right. 

The rules for let expressions and where clauses are similar. After a let or where keyword, the Haskell compiler or interpreter remembers the indentation of the next token it sees. If the line that follows is empty, or its indentation is further to the right, it is considered to continue the previous line. If the indentation is the same as the start of the preceding item, this is treated as beginning a new item in the same block.

-- file: ch03/Indentation.hs
foo = let firstDefinition = blah blah
          -- a-only line is treated as empty
                              continuation blah

          -- we reduce the indentation, so this is a new definition
          secondDefinition = yada yada

                             continuation yada
      in whatever

Here are nested uses of let and where.

-- file: ch03/letwhere.hs
bar = let b = 2
          c = True
      in let a = b
         in (a, c)

The name a is only visible within the inner let expression. It's not visible in the outer let. If we try to use the name a there, we'll get a compilation error. The indentation gives both us and the compiler a visual cue as to what is currently in scope.

-- file: ch03/letwhere.hs
foo = x
    where x = y
              where y = 2

Similarly, the scope of the first where clause is the definition of foo, but the scope of the second is just the first where clause.

The indentation we use for the let and where clauses makes our intentions easy to figure out.

A note about tabs versus spaces
If you use a Haskell-aware text editor (e.g. Emacs), it is probably already configured to use space characters for all white space when you edit Haskell source files. If your editor is not Haskell-aware, you should configure it to only use space characters.

The reason for this is portability. In an editor that uses a fixed-width font, tab stops are by convention placed at different intervals on Unix-like systems (every eight characters) than on Windows (every four characters). This means that no matter what your personal beliefs are about where tabs belong, you can't rely on someone else's editor honouring your preferences. Any indentation that uses tabs is going to look broken under someone's configuration. In fact, this could lead to compilation problems, as the Haskell language standard requires implementations to use the Unix tab width convention. Using space characters avoids this problem entirely.

The offside rule is not mandatory
We can use explicit structuring instead of layout to indicate what we mean. To do so, we start a block of equations with an opening curly brace; separate each item with a semicolon; and finish the block with a closing curly brace. The following two uses of let have the same meanings.

-- file: ch03/Braces.hs
bar = let a = 1
          b = 2
          c = 3
      in a + b + c

foo = let { a = 1;  b = 2;
        c = 3 }
      in a + b + c

When we use explicit structuring, the normal layout rules don't apply, which is why we can get away with unusual indentation in the second let expression.

We can use explicit structuring anywhere that we'd normally use layout. It's valid for where clauses, and even top-level declarations. Just remember that although the facility exists, explicit structuring is hardly ever actually used in Haskell programs.

The case expression
Function definitions are not the only place where we can use pattern matching. The case construct lets us match patterns within an expression. Here's what it looks like. This function (defined for us in Data.Maybe) unwraps a Maybe value, using a default if the value is Nothing.

-- file: ch03/Guard.hs
fromMaybe defval wrapped =
    case wrapped of
      Nothing     -> defval
      Just value  -> value

The case keyword is followed by an arbitrary expression: the pattern match is performed against the result of this expression. The of keyword signifies the end of the expression and the beginning of the block of patterns and expressions.

Each item in the block consists of a pattern, followed by an arrow ->, followed by an expression to evaluate if that pattern matches. These expressions must all have the same type. The result of the case expression is the result of the expression associated with the first pattern to match. Matches are attempted from top to bottom.

To express “here's the expression to evaluate if none of the other patterns match”, we just use the wild card pattern _ as the last in our list of patterns. If a pattern match fails, we will get the same kind of runtime error as we saw earlier.

Common beginner mistakes with patterns
There are a few ways in which new Haskell programmers can misunderstand or misuse patterns. Here are some attempts at pattern matching gone awry. Depending on what you expect one of these examples to do, it might contain a surprise.

Incorrectly matching against a variable
-- file: ch03/BogusPattern.hs
data Fruit = Apple | Orange

apple = "apple"

orange = "orange"        

whichFruit :: String -> Fruit

whichFruit f = case f of
                 apple  -> Apple
                 orange -> Orange

A naive glance suggests that this code is trying to check the value f to see whether it matches the value apple or orange.

It is easier to spot the mistake if we rewrite the code in an equational style.

-- file: ch03/BogusPattern.hs
equational apple = Apple
equational orange = Orange

Now can you see the problem? Here, it is more obvious apple does not refer to the top level value named apple: it is a local pattern variable.

[Note]	Irrefutable patterns
We refer to a pattern that always succeeds as irrefutable. Plain variable names and the wild card _ are examples of irrefutable patterns.

Here's a corrected version of this function.

-- file: ch03/BogusPattern.hs
betterFruit f = case f of
                  "apple"  -> Apple
                  "orange" -> Orange

We fixed the problem by matching against the literal values "apple" and "orange".

Incorrectly trying to compare for equality
What if we want to compare the values stored in two nodes of type Tree, and return one of them if they're equal? Here's an attempt.

-- file: ch03/BadTree.hs
bad_nodesAreSame (Node a _ _) (Node a _ _) = Just a
bad_nodesAreSame _            _            = Nothing

A name can only appear once in a set of pattern bindings. We cannot place a variable in multiple positions to express the notion “this value and that should be identical”. Instead, we'll solve this problem using guards, another invaluable Haskell feature.

Conditional evaluation with guards
Pattern matching limites us to performing fixed tests of a value's shape. Although this is useful, we will often want to make a more expressive check before evaluating a function's body. Haskell provides a feature, guards, that give us this ability. We'll introduce the idea with a modification of the function we wrote to compare two nodes of a tree.

-- file: ch03/BadTree.hs
nodesAreSame (Node a _ _) (Node b _ _)
    | a == b     = Just a
nodesAreSame _ _ = Nothing

In this example, we use pattern matching to ensure that we are looking at values of the right shape, and a guard to compare pieces of them.

A pattern can be followed by zero or more guards, each an expression of type Bool. A guard is introduced by a | symbol. This is followed by the guard expression, then an = symbol (or -> if we're in a case expression), then the body to use if the guard expression evaluates to True. If a pattern matches, each guard associated with that pattern is evaluated, in the order in which they are written. If a guard succeeds, the body affiliated with it is used as the result of the function. If no guard succeeds, pattern matching moves on to the next pattern.

When a guard expression is evaluated, all of the variables mentioned in the pattern with which it is associated are bound and can be used.

Here is a reworked version of our lend function that uses guards.

-- file: ch03/Lending.hs
lend3 amount balance
     | amount <= 0            = Nothing
     | amount > reserve * 0.5 = Nothing
     | otherwise              = Just newBalance
    where reserve    = 100
          newBalance = balance - amount

The special-looking guard expression otherwise is simply a variable bound to the value True, to aid readability.

We can use guards anywhere that we can use patterns. Writing a function as a series of equations using pattern matching and guards can make it much clearer. Remember the myDrop function we defined in the section called “Conditional evaluation”?

-- file: ch02/myDrop.hs
myDrop n xs = if n <= 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)

Here is a reformulation that uses patterns and guards.

-- file: ch02/myDrop.hs
niceDrop n xs | n <= 0 = xs
niceDrop _ []          = []
niceDrop n (_:xs)      = niceDrop (n - 1) xs

This change in style lets us enumerate up front the cases in which we expect a function to behave differently. If we bury the decisions inside a function as if expressions, the code becomes harder to read.

Exercises
1.

Write a function that computes the number of elements in a list. To test it, ensure that it gives the same answers as the standard length function.

2.

Add a type signature for your function to your source file. To test it, load the source file into *ghci* again.

3.

Write a function that computes the mean of a list, i.e. the sum of all elements in the list divided by its length. (You may need to use the fromIntegral function to convert the length of the list from an integer into a floating point number.)

4.

Turn a list into a palindrome, i.e. it should read the same both backwards and forwards. For example, given the list [1,2,3], your function should return [1,2,3,3,2,1].

5.

Write a function that determines whether its input list is a palindrome.

6.

Create a function that sorts a list of lists based on the length of each sublist. (You may want to look at the sortBy function from the Data.List module.)

7.

Define a function that joins a list of lists together using a separator value.

-- file: ch03/Intersperse.hs
intersperse :: a -> [[a]] -> [a]

The separator should appear between elements of the list, but should not follow the last element. Your function should behave as follows.

ghci> :load Intersperse
[1 of 1] Compiling Main             ( Intersperse.hs, interpreted )
Ok, modules loaded: Main.
ghci> intersperse ',' []
""
ghci> intersperse ',' ["foo"]
"foo"
ghci> intersperse ',' ["foo","bar","baz","quux"]
"foo,bar,baz,quux"

8.

Using the binary tree type that we defined earlier in this chapter, write a function that will determine the height of the tree. The height is the largest number of hops from the root to an Empty. For example, the tree Empty has height zero; Node "x" Empty Empty has height one; Node "x" Empty (Node "y" Empty Empty) has height two; and so on.

9.

Consider three two-dimensional points a, b, and c. If we look at the angle formed by the line segment from a to b and the line segment from b to c, it either turns left, turns right, or forms a straight line. Define a Direction data type that lets you represent these possibilities.

10.

Write a function that calculates the turn made by three 2D points and returns a Direction.

11.

Define a function that takes a list of 2D points and computes the direction of each successive triple. Given a list of points [a,b,c,d,e], it should begin by computing the turn made by [a,b,c], then the turn made by [b,c,d], then [c,d,e]. Your function should return a list of Direction.

12.

Using the code from the preceding three exercises, implement Graham's scan algorithm for the convex hull of a set of 2D points. You can find good description of what a convex hull. is, and how the Graham scan 