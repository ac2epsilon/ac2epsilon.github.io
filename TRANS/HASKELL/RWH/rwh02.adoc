include::header.adoc[]

= Глава 2. Типи та функції

== Навіщо дбати про типи?

Кожний вираз та функція в Haskell має тип. Наприклад, значення `True` має тип `Bool`, тоді як значення `"foo"` має тип `String`. Тип значення вказує на те, що воно поділяє певні властивості з іншими значеннями того ж типу. Наприклад, ми можемо додавати числа, і ми можемо об'єднати списки; це властивості цих типів. Ми говоримо, що вираз "має тип X", або "є типу X".

Перш ніж ми розпочнемо більш глибоке обговорення системи типів Haskell, давайте поговоримо про те, чому ми взагалі повинні дбати про типи: для чого вони взагалі? На найнижчому рівні комп'ютер займається байтами, майже без будь-якої додаткової структури. Що нам дає система типів - це абстракція. Тип додає значення простим байтам: він дозволяє нам говорити "ці байти - це текст", "ці байти - це резервація авіа квитків" тощо. Зазвичай система типів не обмежується цім, щоб запобігти випадковому змішанню типів: наприклад, система типів зазвичай не дозволяє нам розглядати бронювання готелів як квитанцію на прокат автомобіля.

Перевага введення абстракції полягає в тому, що вона дозволяє нам забувати або ігнорувати деталі низького рівня. Якщо я знаю, що значення в моїй програмі - це рядок, я не повинен знати прихованих деталей того, як реалізуються рядки: я можу просто припустити, що мій рядок буде вести себе, як і всі інші рядки, з якими я працював.

Що робить системи типів цікавими, це те, що вони не всі однакові. Насправді різні системи типу часто навіть не стосуються одних і тих же проблем. Система типів мови програмування глибоко забарвлює те, як ми думаємо і пишемо код цією мовою. 

Система типів Haskell дозволяє нам мислити на дуже абстрактному рівні: це дозволяє нам писати стислі, потужні програми.

== Система типів Haskell

Існує три цікавих аспекти до типів Haskell: вони _сильні_, вони _статичні_, і вони можуть _виводитись_ автоматично. Давайте поговоримо докладніше про кожну з цих ідей. Коли це можливо, ми представимо схожість між поняттями із системи типів Haskell та спорідненими ідеями в інших мовах. Ми також торкнемося сильних і слабких сторін кожної з цих властивостей.

=== Сильні типи

Коли ми говоримо, що у Haskell є сильна система типів, ми маємо на увазі, що система типу гарантує, що програма не може містити певні помилки. Ці помилки виникають при спробі запису виразів, які не мають сенсу, як використання цілого числа в якості функції. Наприклад, якщо функція розраховує працювати з цілими числами, і ми передамо їй рядок, компілятор Haskell відкине це.

Ми називаємо вираз, який підкоряється правилам типів мови, які добре типізований. Вираз, який не дотримується правил типу, хворобливо типізований і спричинить помилку типу.

Ще один аспект погляду Haskell на сильну типізацію полягає в тому, що він автоматично не примушує значення від одного типу до іншого. (Примус також відомий як кастинг або конверсія.) Наприклад, компілятор C автоматично і безшумно примушує значення типу `int` в `float` від нашого імені, якщо функція очікує параметр типу `float`. Але компілятор Haskell підніме помилку компіляції в подібній ситуації. Ми повинні явно перетворювати типи, застосовуючи функції конверсії.

Сильна типізація іноді ускладнює написання певних видів коду. Наприклад, класичним способом написання коду низького рівня мовою C є надання байтового масиву та передача його для обробки байтів так, ніби вони справді є складною структурою даних. Це дуже ефективно, оскільки не вимагає від нас копіювання байтів по колу. Система типів Haskell не допускає такого роду примусу. Для того, щоб отримати однаковий структурований вигляд даних, нам потрібно було б виконати деяке копіювання, що коштувало б небагато продуктивності.

Величезна перевага сильної типізації полягає в тому, що вона вловлює справжні помилки в нашому коді, перш ніж вони можуть викликати проблеми. Наприклад, в сильно типізованій мові ми не можемо випадково використати рядок, де очікується ціле число.

.Cлабкіші та міцніші типи
****
[NOTE]
Корисно усвідомлювати, що у багатьох мовних спільнотах є свої визначення "сильного типу". Тим не менш, ми будемо говорити коротко і загалом про поняття міцності в типах систем.

В академічній інформатиці значення "сильний" і "слабкий" мають вузько технічне значення: сила означає те, наскільки вседозволена система типу. Система слабшого типу трактує більше виразів як дійсні, ніж система сильнішого типу.

Наприклад, в Perl вираз `"foo" + 2` оцінюється до числа `2`, але вираз `"13foo" + 2` оцінює до числа `15`. Haskell відкидає обидва вирази як недійсні, оскільки оператор (`+`) вимагає від обох своїх операндів, щоб це були числа. Оскільки система типів Perl є більш дозвольною, ніж у Haskell, ми говоримо, що вона слабша при цій вузькій технічній інтерпретації.

Феєрверки навколо систем типів мають своє коріння у звичайній англійській мові, де люди надають поняття цінності словам "слабкий" та "сильний": ми зазвичай думаємо про силу як кращу, ніж про слабкість. Значно більше програмістів говорять простою англійською мовою, ніж академічним жаргоном, і досить часто вчені _дійсно_ кидають цеглини по будь-якому типові системи, який не відповідає їх фантазії. Результатом цього є часто популярне Інтернет-дозвілля, вогняні війни.
****

=== Статичні типи

Наявність системи _статичної_ типізації означає, що компілятор знає тип кожного значення та виразу під час компіляції, перш ніж будь-який код буде виконаний. Компілятор або інтерпретатор Haskell виявить, коли ми намагаємось використовувати вирази, типи яких не відповідають один одному, і відхилить наш код із повідомленням про помилку перед тим, як запустити його.

[source,haskell]
----
ghci> True && "false"

<interactive>:1:8:
    Couldn't match expected type `Bool' against inferred type `[Char]'
    In the second argument of `(&&)', namely `"false"'
    In the expression: True && "false"
    In the definition of `it': it = True && "false"

----

Це повідомлення про помилку є таким, яке ми бачили раніше. Компілятор зробив висновок, що тип виразу `"false"` є `[Char]`. Оператор (`&&`) вимагає, щоб кожен його операнд був типом `Bool`, і його лівий операнд дійсно має такий тип. Оскільки фактичний тип `"false"` не відповідає потрібному типу, компілятор відкидає цей вираз як хворобливо типізований.

Статична типізація може інколи ускладнювати написання деяких корисних видів коду. У таких мовах, як Python, поширена "качина типізація", коли об'єкт діє достатньо подібно до іншого, щоб використовувати його як заміну.footnote:["Якщо вона ходить, як качка, і хитається, як качка, тоді давайте назвемо її качкою".] На щастя, система типових класів Haskell, яку ми розглянемо в главі 6, *_Використовуючи типокласи_*, забезпечує майже всі переваги динамічної типізації в безпечній та зручній формі. Haskell має певну підтримку програмування з по-справжньому динамічними типами, хоча це не так просто, як у мові, яка від щирого серця сприймає це поняття.

Поєднання в Haskell сильної та статичної типізації унеможливлює виникнення помилок типу під час виконання. Хоча це означає, що нам потрібно трохи більше подумати «наперед», але це також усуває багато простих помилок, які в іншому випадку може бути важко знайти. Загальна думка в колах спільноти Haskell: якщо вже код компілюється, шанси що він буде працювати правильно більші, ніж в інших мовах. (Можливо, більш реалістичним способом сформулювати це є те, що у коді Haskell часто менше тривіальних помилок.)

Програми, написані на динамічно типізованих мовах, вимагають великих тестових наборів, щоб дати певну впевненість у тому, що прості помилки типу не можуть виникнути. Тестові набори не можуть забезпечити повне висвітлення: деякі поширені завдання, такі як рефакторинг програми щоб зробити її більш модульною, можуть вводити нові помилки типу, які тестовий набір може не помітити.

У Haskell компілятор доводить відсутність помилок типу для нас: програма Haskell, яка компілюється, не постраждає від помилок типу під час її запуску. Рефакторинг, як правило, означає переміщення коду, а потім перекомпіляцію та прибирання декілька разів, поки компілятор не видасть нам "все чисто".

Корисною аналогією, щоб зрозуміти значення статичної типізації, є дивитися на це як на складання шматочків у головоломку. У Haskell, якщо шматок має неправильну форму, він просто не поміститься. У динамічно типізованій мові всі фрагменти є квадратами 1х1 і завжди підходять, тому вам доведеться постійно вивчати отриману картинку і перевіряти (через тестування), чи все правильно.

=== Вивід типів

Нарешті, компілятор Haskell може автоматично виводити типи майже всіх виразів програми.footnote:[Інколи нам потрібно надати компілятору трохи інформації, щоб допомогти йому зробити вибір у розумінні нашого коду.] Цей процес відомий як вивід типу. Haskell дозволяє нам чітко оголосити тип будь-якого значення, але наявність виводу типу означає, що це майже завжди необов'язково, а не те, що нам потрібно дещо робити.

== Чого очікувати від системи типів

Our exploration of the major capabilities and benefits of Haskell's type system will span a number of chapters. Early on, you may find Haskell's types to be a chore to deal with. 
Наше вивчення основних можливостей та переваг системи типів Haskell охопить низку глав. На початку ви можете виявити, що типи в Haskell - це те, з чим ви матимете справу постійно.

Наприклад, замість того, щоб просто написати якийсь код і запустити його, щоб побачити, чи він працює, як ви могли очікувати в Python або Ruby, спочатку потрібно переконатися, що ваша програма проходить перевірку типу. Навіщо дотримуватися кривої навчання?

В той час, коли сильна статична типізація робить Haskell безпечним, вивід типу робить його стислим. Результат є потужним: ми отримуємо мову, яка є і безпечнішою, ніж популярні статично типізовані мови, і часто більш виразною, ніж динамічно типізовані мови. Це є сильною заявою, і ми підкріпимо це доказами у всій книзі.

Виправлення помилок типу може спочатку відчуватись як більша робота, ніж коли ви використовували динамічну мову. Тут може допомогти погляд на це, як на переміщення більшої частини налагодження вперед. Компілятор показує вам багато логічних недоліків у вашому коді, а не залишає вас натрапляти на проблеми під час виконання.

Крім того, оскільки Haskell може виводити типи ваших виразів і функцій, ви отримуєте переваги статичної типізації без додаткового тягаря "набору пальцем", що накладається менш потужними статично типізованими мовами. В інших мовах система типів обслуговує потреби компілятора. У Haskell вона обслуговує вас. Компроміс полягає в тому, що ви повинні навчитися працювати в рамках, який вона надає.

Ми будемо вводити нові використання типів Haskell у цій книзі, щоб допомогти нам написати та перевірити практичний код. Як результат, повна картина того, чого варта система типів, з'явиться поступово. Хоча кожен крок повинен виправдовувати себе, цілий результат виявиться більшим, ніж сума його частин.

== Деякі поширені основні типи

У розділі «Перші кроки з типами» ми представили кілька типів. Ось ще кілька найпоширеніших базових типів.

* Значення `Char` представляє символ Unicode.
* Значення `Bool` представляє логічні значення. Можливі значення типу `Bool` є `True` та `False`.
* Тип `Int` використовується для знакових цілих значень з фіксованою шириною. Точний діапазон значень, представлених як `Int`, залежить від найдовшого «рідного» цілого системи: на 32-бітній машині `Int` зазвичай становить 32 біти в ширину, тоді як на 64-бітній машині зазвичай шириною 64 біт. Стандарт Haskell гарантує лише, що `Int` ширший, ніж 28 біт. (Існують числові типи, які точно дорівнюють 8, 16 і т.п. в ширину, в знакових та беззнакових варіантах; ми дістанемося до них пізніше.)
* Значення `Integer` - це знакове ціле число необмеженого розміру. Цілі `Integer` використовуються не так часто, як `Int`, оскільки вони дорожчі як за продуктивністю, так і за споживанням місця. З іншого боку, обчислення `Integer` мовчки не переповнюються, тому вони дають більш достовірні правильні відповіді.

Values of type Double are used for floating point numbers. A Double value is typically 64 bits wide, and uses the system's native floating point representation. (A narrower type, Float, also exists, but its use is discouraged; Haskell compiler writers concentrate more on making Double efficient, so Float is much slower.) 
Значення типу `Double` використовуються для чисел з плаваючою комою. Подвійне значення, як правило, шириною 64 біт і використовує нативне представлення системи з плаваючою точкою. (Більш вузький тип, `Float`, також існує, але його використання не рекомендується; автори компілятора Haskell зосереджуються більше на тому, щоб зробити ефективнішим `Double`, тому `Float` набагато повільніший.)

We have already briefly seen Haskell's notation for types in the section called “First steps with types”. When we write a type explicitly, we use the notation expression :: MyType to say that expression has the type MyType. If we omit the :: and the type that follows, a Haskell compiler will infer the type of the expression. 
Ми вже коротко бачили нотацію Haskell для типів у розділі "Перші кроки з типами". Коли ми пишемо тип явно, ми використовуємо нотацію виразу `::MyType`, щоб сказати, що вираз має тип `MyType`. Якщо опустити `::` і тип, що іде за ним, компілятор Haskell сам зробить висновок про тип виразу.

[source,haskell]
----
ghci> :type 'a'
'a' :: Char
ghci> 'a' :: Char
'a'
ghci> [1,2,3] :: Int

<interactive>:1:0:
    Couldn't match expected type `Int' against inferred type `[a]'
    In the expression: [1, 2, 3] :: Int
    In the definition of `it': it = [1, 2, 3] :: Int
----

Поєднання `::` та типу після нього називається сигнатурою типу.

=== Застосування функції

Тепер, коли ми витратили деякий час на типи даних, давайте звернемо свою увагу на роботу з деякими типами, які ми бачили, використовуючи функції.

Щоб застосувати функцію в Haskell, ми записуємо ім'я функції, а потім її аргументи.

[source,haskell]
----
ghci> odd 3
True
ghci> odd 6
False
----

Ми не використовуємо дужки або коми для групування або розділення аргументів функції; достатньо лише написання назви функції з наступним кожним аргументом по черзі. Як приклад, застосуємо функцію порівняння, яка бере два аргументи.

[source,haskell]
----
ghci> compare 2 3
LT
ghci> compare 3 3
EQ
ghci> compare 3 2
GT
----

Якщо ви звикли до синтаксису викликів функцій в інших мовах, може знадобитись звикання до цього позначення, але це просто і узгоджено.

Застосування функції має більшу перевагу, ніж використання операторів, тому наступні два вирази мають те саме значення.

[source,haskell]
----
ghci> (compare 2 3) == LT
True
ghci> compare 2 3 == LT
True
----

Вищезгадані дужки не приносять шкоди, але вони додають певного візуального шуму. Однак іноді ми повинні використовувати дужки, щоб вказати, щоб складний вираз був розібраний як ми хочемо.

[source,haskell]
----
ghci> compare (sqrt 3) (sqrt 6)
LT
----

Це стосується порівняння з результатами застосування `sqrt 3` та `sqrt 6` відповідно. Якщо ми опустимо дужки, схоже, ми намагаємось порівняти чотири аргументи, замість прийнятних двох.

=== Корисні складені типи даних: списки та кортежі

Складений тип даних будується з інших типів. Найпоширеніші складові типи даних у Haskell - це списки та кортежі.

Ми вже бачили тип списку, згаданий у розділі «Рядки та символи», де ми виявили, що Haskell представляє текстовий рядок як список значень `Char`, а тип «список `Char»` записаний `[Char]`.

Функція `head` повертає перший елемент списку.

[source,haskell]
----
ghci> head [1,2,3,4]
1
ghci> head ['a','b','c']
'a'
----

Його протилежність, `tail`, повертає всіх, окрім голови списку.

[source,haskell]
----
ghci> tail [1,2,3,4]
[2,3,4]
ghci> tail [2,3,4]
[3,4]
ghci> tail [True,False]
[False]
ghci> tail "list"
"ist"
ghci> tail []
*** Exception: Prelude.tail: empty list
----

Як бачите, ми можемо застосувати `head` та `tail` до списків різних типів. Застосовуючи `head` до значення `[Char]`, повертає значення `Char`, а застосовуючи її до `[Bool]`, повертає значення `Bool`. Функції `head` неважливо, яким типом списку вона займається.

Оскільки значення у списку можуть мати будь-який тип, тип списку ми називаємо поліморфним.footnote:[Ми розповімо більше про поліморфізм у розділі «Поліморфізм у Haskell».] Коли ми хочемо написати поліморфний тип, ми використовуємо змінну типу, яка повинна починатися з малої літери. Змінна типу - це заповнення місця, яке врешті-решт ми замінимо на реальний тип.

Ми можемо записати тип "список `a` ", додавши змінну типу у квадратні дужки: `[a]`. Це означає: "Мені все одно, який у мене тип; Я можу скласти список цього типу".

.Визначення назв типів та змінних типів
****
[NOTE]
Тепер ми можемо зрозуміти, чому ім’я типу має починатися з великої літери: це відрізняє його від змінної типу, яка повинна починатися з малої літери.
****

Коли ми говоримо про список зі значеннями певного типу, ми підміняємо цей тип нашою змінною типу. Так, наприклад, тип `[Int]` - це список значень типу `Int`, оскільки ми підставили `Int` замість `a`. Аналогічно, тип `[MyPersonalType]` - це список значень типу `MyPersonalType`. Ми також можемо виконувати цю заміну рекурсивно: `[[Int]]` - це список значень типу `[Int]`, тобто список списків `Int`.

[source,haskell]
----
ghci> :type [[True],[False,False]]
[[True],[False,False]] :: [[Bool]]
----

Тип цього виразу - це список списків `Bool`.

.Списки особливі
****
[NOTE]	
Списки - це «хліб з маслом» колекцій Haskell. Імперативною мовою ми можемо виконати завдання для багатьох елементів, повторивши цикл. Це те, що ми часто робимо в Haskell шляхом перебігу по списку, або шляхом рекурсії, або за допомогою функції, яка містить рекурсію. Списки є найпростішим кроком до ідеї, що ми можемо використовувати дані для структурування нашої програми та її потоку управління. Ми витратимо набагато більше часу на обговорення списків у Розділі 4, *_Функціональне програмування_*.
****

Кортеж - це колекція значень фіксованого розміру, де кожне значення може мати різний тип. Це відрізняє їх від списку, який може мати будь-яку довжину, але елементи якого повинні мати один і той же тип.

Щоб допомогти зрозуміти різницю, скажімо, ми хочемо відстежити дві частини інформації про книгу. Він має рік видання, який є числом, і заголовок, який є рядком. Ми не можемо зберегти обидві ці відомості у списку, оскільки вони мають різні типи. Натомість ми використовуємо кортеж.

[source,haskell]
----
ghci> (1964, "Labyrinths")
(1964,"Labyrinths")
----

Ми пишемо кортеж, додаючи його елементи в дужки і відокремлюючи їх комами. Ми використовуємо те саме позначення для написання його типу.

[source,haskell]
----
ghci> :type (True, "hello")
(True, "hello") :: (Bool, [Char])
ghci> (4, ['a', 'm'], (16, True))
(4,"am",(16,True))
----

Існує особливий тип, `()`, який виконує функцію кортежу з нуля елементів. Цей тип має лише одне значення, також записане `()`. І тип, і значення зазвичай вимовляються "юніт". Якщо ви знайомі з C, `()` дещо схожий на `void`.

У Haskell немає поняття про одноелементний кортеж. Кортежі часто посилаються на використання кількості елементів як префікса. 2-кортеж має два елементи, і його зазвичай називають парою. "3-кортеж" (іноді його називають трійкою) має три елементи; 5-кортеж має п'ять; і так далі. На практиці робота з кортежами, які містять більше декількох елементів, робить код непростим, тому кортежі з більше ніж кількох елементів використовуються рідко.

Тип кортежу представляє число, положення та типи його елементів. Це означає, що кортежі, що містять різні числа або типи елементів, мають різні типи, як і кортежі, типи яких з'явлються в різному порядку.

[source,haskell]
----
ghci> :type (False, 'a')
(False, 'a') :: (Bool, Char)
ghci> :type ('a', False)
('a', False) :: (Char, Bool)
----

У цьому прикладі вираз `(False, 'a')` має тип `(Bool, Char)`, який відрізняється від типу `('a', False)`. Незважаючи на те, що кількість елементів та їх типи однакові, ці два типи є різними, оскільки положення типів елементів є різними.

[source,haskell]
----
ghci> :type (False, 'a', 'b')
(False, 'a', 'b') :: (Bool, Char, Char)
----

Цей тип `(Bool, Char, Char)` відрізняється від `(Bool, Char)`, оскільки містить три елементи, а не два.

Ми часто використовуємо кортежі, щоб повернути кілька значень з функції. Ми також можемо використовувати їх у будь-який час, коли нам потрібна колекція значень фіксованого розміру, якщо обставини не вимагають спеціального типу контейнера.

=== Вправи

1. Які типи наведених виразів?

* `False` 
* `(["foo", "bar"], 'a')`
* `[(True, []), (False, [['a']])]` 

== Функції над списками та кортежами

У нашому обговоренні списків і кортежів згадувалося, як ми можемо їх побудувати, але мало про те, як ми з ними щось робити. Нам до цього часу були представлені лише дві функції списку, `head` та `tail`.

A related pair of list functions, take and drop, take two arguments. Given a number n and a list, take returns the first n elements of the list, while drop returns all but the first n elements of the list. (As these functions take two arguments, notice that we separate each function and its arguments using white space.) 
Пов’язана пара функцій списку: `take` і `drop`, беруть два аргументи. Маючи число `n` та список, `take` повертає перших `n` елементів списку, тоді як `drop` повертає всі, крім перших `n` елементів списку. (Оскільки ці функції беруть два аргументи, зауважте, що ми розділяємо кожну функцію та її аргументи, використовуючи пробіл).

[source,haskell]
----
ghci> take 2 [1,2,3,4,5]
[1,2]
ghci> `drop` 3 [1,2,3,4,5]
[4,5]
----

Для кортежів функції `fst` і `snd` повертають перший і другий елементи пари відповідно.

[source,haskell]
----
ghci> fst (1,'a')
1
ghci> snd (1,'a')
'a'
----

Якщо ваш досвід походить з деяких інших мов, все це може виглядати як застосування функції до двох аргументів. Згідно з домовленостями Haskell для застосування функції, кожен є додатком функції до однієї пари.

.Haskell кортежі не є незмінними списками
****
[NOTE]
Якщо ви прийшли зі світу Python, ви, ймовірно, приймали як факт, що списки та кортежі були майже взаємозамінними. Хоча елементи кортежу Python незмінні, його можна індексувати та ітерувати, використовуючи ті самі методи, що і для списку. У Haskell це не так, тому не намагайтеся перенести цю ідею на незнайому мовну територію.
****

As an illustration, take a look at the type signatures of fst and snd: they're defined only for pairs, and can't be used with tuples of other sizes. Haskell's type system makes it tricky to write a generalised “get the second element from any tuple, no matter how wide” function. 
Як ілюстрацію, погляньте на сигнатури типів `fst` і `snd`: вони визначені лише для пар, і їх не можна використовувати з кортежами інших розмірів. Система типу Haskell ускладнює написання узагальненої функції "отримати другий елемент з будь-якого кортежу, незалежно від його розміру".

==== Передача виразу функції

У Haskell застосування функції є ліво асоціативною. Найкраще це проілюстровано прикладом: вираз `a b c d` еквівалентно `(((a b) c) d)`. Якщо ми хочемо використовувати один вираз як аргумент в іншому, ми повинні використовувати явні дужки, щоб сказати аналізатору, що ми насправді маємо на увазі. Ось приклад.

[source,haskell]
----
ghci> head (drop 4 "azerty")
't'
----

Ми можемо читати це як "передайте вираз `drop 4 "azerty"` як аргумент до `head`. Якби ми не залишили дужки, вираз був б подібний до передачі трьох аргументів до `head`. Компіляція не вдалася б із помилкою типу, оскільки для `head` потрібен єдиний аргумент, список.

== Типи функцій та чистота

Давайте розглянемо тип функції.

[source,haskell]
----
ghci> :type lines
lines ::String -> [String]
----

Ми можемо читати `->` вище як "до", що умовно перекладається як "повертає". Таким чином, підпис в цілому читається як "`“lines` має тип `String` до список-зі-`String`". Спробуємо застосувати функцію.

[source,haskell]
----
ghci> lines "the quick\nbrown fox\njumps"
["the quick","brown fox","jumps"]
----

Функція `lines` розбиває рядок на межі рядків. Зауважте, що її сигнатура типу надає нам підказку щодо того, що ця функція насправді може виконувати: вона приймає один рядок і повертає багато. Це неймовірно цінна властивість типів у функціональній мові.

Побічний ефект вводить залежність між глобальним станом системи та поведінкою функції. Наприклад, давайте на мить відійдемо від Haskell і подумаємо про імперативну мову програмування. Розглянемо функцію, яка зчитує та повертає значення глобальної змінної. Якщо якийсь інший код може змінити цю глобальну змінну, то результат конкретного застосування нашої функції залежить від поточного значення глобальної змінної. Функція має побічний ефект, хоча вона ніколи не змінює саму змінну.

Побічні ефекти - це по суті невидимі входи до функцій або виходи з них. У Haskell за замовчуванням функції не мають побічних ефектів: результат функції залежить лише від входів, які ми явно надаємо. Ці функції ми називаємо чистими; функції з побічними ефектами нечисті.

Чи функція має побічні ефекти, ми можемо сказати, прочитавши її підпис типу: тип результату функції розпочнеться з IO.

[source,haskell]
----
ghci> :type readFile
readFile :: FilePath -> IO String
----

Система типу Haskell не дозволяє нам випадково змішати чистий і нечистий код.

=== Вихідні файли Haskell та написання простих функцій

Тепер, коли ми знаємо, як застосувати функції, саме час звернути свою увагу на їх написання. Хоча ми можемо писати функції в ghci, це не сприятливе середовище для цього. Він приймає лише сильно обмежену підмножину Haskell: і головне, що синтаксис, який він використовує для визначення функцій, не такий, як ми використовуємо у вихідному файлі Haskell.footnote:[Середовище, в якому діє ghci, називається монадою IO. У розділі 7 I/O ми висвітлимо монаду IO докладно, і, здавалося б, довільні обмеження, які ghci накладає на нас, матимуть більше сенсу.] Натомість ми нарешті зламаємо стереотип і створимо вихідний файл.

Вихідні файли Haskell зазвичай ототожнюються із суфіксом *.hs*. Ось просте визначення функції: відкрийте файл з назвою `add.hs` і додайте до нього цей вміст.

[source,haskell]
----
-- file: ch03/add.hs
add a b = a + b
----

On the left hand side of the = is the name of the function, followed by the arguments to the function. On the right hand side is the body of the function. With our source file saved, we can load it into ghci, and use our new add function straight away. (The prompt that ghci displays will change after you load your file.)
Зліва від `=` - назва функції, за якою йдуть аргументи функції. Праворуч - тіло функції. Зберігши наш вихідний файл, ми можемо завантажити його в ghci та відразу використати нову функцію `add` для додавання. (Підказка, що відображатиметься ghci, зміниться після завантаження файлу).

[source,haskell]
----
ghci> :load add.hs
[1 of 1] Compiling Main             ( add.hs, interpreted )
Ok, modules loaded: Main.
ghci> add 1 2
3
----

.Що робити, якщо ghci не може знайти ваш вихідний файл?
****
[NOTE]	
Під час запуску ghci він може не знайти ваш вихідний файл. Він буде шукати вихідні файли в будь-якій директорії, в якій він був запущений. Якщо це не той каталог, у якому насправді знаходиться ваш вихідний файл, ви можете використовувати команду ghci `:cd`, щоб змінити його робочий каталог.
`ghci> :cd /tmp`
Alternatively, you can provide the path to your Haskell source file as the argument to :load. This path can be either absolute or relative to ghci's current directory. 
Крім того, ви можете надати шлях до вихідного файлу Haskell як аргумент до `:load`. Цей шлях може бути абсолютним або відносним до поточного каталогу ghci.
****

Коли ми застосовуємо додавання до значень 1 і 2, змінним `a` і `b` в лівій частині нашого визначення надаються (або «прив’язані до») значення 1 і 2, тому результатом є вираз `1 + 2`.

У Haskell немає ключового слова `return`, оскільки функція - це єдиний вираз, а не послідовність висловлювань. Значення виразу є результатом функції. (У Haskell є функція, яка називається `return`, але ми її деякий час не будемо обговорювати; вона має інше значення, ніж в імперативних мовах.)

Коли ви бачите символ `=` у коді Haskell, він представляє "значення": ім'я зліва визначається як вираз справа.

=== Що таке змінна кінець кінцем?

У Haskell змінна забезпечує спосіб дати ім’я виразу. Після того, як змінна прив'язана (тобто пов'язана з) певним виразом, її значення не змінюється: ми завжди можемо використовувати ім'я змінної замість того, щоб виписати вираз, і отримати той самий результат.

Якщо ви звикли до імперативних мов програмування, ви, ймовірно, вважаєте змінну як спосіб визначення місця в пам'яті (або якогось еквівалента), який може містити різні значення в різний час. Мовою імперативів ми можемо змінити значення змінної в будь-який час, так що повторне отримання місця пам'яті може потенційно кожного разу давати різні результати.

Критична різниця між цими двома поняттями змінної полягає в тому, що в Haskell, коли ми прив’язуємо змінну до виразу, ми знаємо, що ми завжди можемо замінити її цим виразом, оскільки вона не зміниться. В імперативній мові це поняття замінюваності не дотримується.

Наприклад, якщо ми запустимо наступний крихітний сценарій Python, він надрукує число `11`.

[source,python]
----
x = 10
x = 11
# value of x is now 11
print x
----

На відміну від цього, еквівалентна спроба в Haskell призводить до помилки.

[source,haskell]
----
-- file: ch02/Assign.hs
x = 10
x = 11
----

Ми не можемо призначити значення x два рази.

[source,haskell]
----
ghci> :load Assign
[1 of 1] Compiling Main ( Assign.hs, interpreted )

Assign.hs:4:0:
    Multiple declarations of `Main.x'
    Declared at: Assign.hs:3:0
                 Assign.hs:4:0
Failed, modules loaded: none.
----

=== Умовне обчислення

Як і багато інших мов, Haskell має вираз `if`. Давайте подивимось це в дії, потім пояснимо, що відбувається. Як приклад, ми напишемо власну версію стандартної функції `drop`. Перш ніж розпочати, давайте трохи вивчимо, як поводиться `drop`, щоб ми могли повторити її поведінку.

[source,haskell]
----
ghci> drop 2 "foobar"
"obar"
ghci> drop 4 "foobar"
"ar"
ghci> drop 4 [1,2]
[]
ghci> drop 0 [1,2]
[1,2]
ghci> drop 7 []
[]
ghci> drop (-2) "foo"
"foo"
----

З вищесказаного, здається, що drop повертає початковий список, якщо число, яке потрібно видалити, менше або дорівнює нулю. В іншому випадку він видаляє елементи, поки не вичерпається або не досягне заданої кількості. Ось функція `myDrop`, яка має таку ж поведінку, і використовує Haskell вираз `if`, щоб вирішити, що робити. Функція `null` нижче перевіряє, чи список порожній.

[source,haskell]
----
-- file: ch02/myDrop.hs
myDrop n xs = if n <= 0 || null xs
              then xs
              else myDrop (n - 1) (tail xs)
----

У Haskell відступ важливий: він продовжує існуюче визначення, замість того, щоб починати нове. Не опускайте відступ!

Вам може бути цікаво, звідки походить ім'я змінної `xs` у функції Haskell. Це загальна схема імен для списків: ви можете читати `s` як суфікс, тому ім'я по суті є «множиною x».

Давайте збережемо нашу функцію Haskell у файлі з назвою *myDrop.hs*, а потім завантажимо її в ghci.

[source,haskell]
----
ghci> :load myDrop.hs
[1 of 1] Compiling Main             ( myDrop.hs, interpreted )
Ok, modules loaded: Main.
ghci> myDrop 2 "foobar"
"obar"
ghci> myDrop 4 "foobar"
"ar"
ghci> myDrop 4 [1,2]
[]
ghci> myDrop 0 [1,2]
[1,2]
ghci> myDrop 7 []
[]
ghci> myDrop (-2) "foo"
"foo"
----

Тепер, коли ми побачили `myDrop` в дії, повернемося до вихідного коду та розглянемо всі новинки, які ми запровадили.

Перш за все, ми ввели `--` як початок однорядного коментаря. Цей коментар поширюється до кінця рядка.

Далі - саме ключове слово `if`. Віно вводить вираз, який має три компоненти.

Вираз типу `Bool`, одразу після `if`. Ми називаємо це предикатом.

Потім ключове слово `then` з наступним виразом. Цей вираз буде використовуватися як значення виразу `if`, якщо предикат оцінюється як `True`.

Ще одне ключове слово `else` з наступним виразом. Цей вираз буде використовуватися як значення виразу `if`, якщо предикат оцінюється як `False`.

Ми будемо називати вирази після `then` та `else` ключових слів як "гілки". Гілки повинні мати однакові типи; вираз `if` також буде мати цей тип. Такий вираз, як `if True then 1 else «foo»` має різні типи для своїх гілок, тому він неправильно введений і буде відхилений компілятором чи інтерпретатором.

Нагадаємо, що Haskell - мова, орієнтована на вирази. В імперативній мові може бути сенс опустити `else` гілку `if`, тому що ми працюємо з твердженнями, а не з виразами. Однак, коли ми працюємо з виразами, `if`, що не має `else`, не мав би результату ані типу, якщо предикат оцінюватиметься як `False`, і це було б безглуздо.

Our predicate contains a few more novelties. The null function indicates whether a list is empty, while the (||) operator performs a logical “or” of its Bool-typed arguments. 
Наш предикат містить ще кілька новин. Функція `null` вказує, чи список порожній, тоді як `(||)` оператор виконує логічне "або" своїх аргументів типу `Bool`.

[source,haskell]
----
ghci> :type null
null :: [a] -> Bool
ghci> :type (||)
(||) :: Bool -> Bool -> Bool
----

.Оператори не особливі
****
[TIP]	
Зауважте, що нам вдалося знайти тип `(||)`, загорнувши його в дужки. Оператор `(||)` не "вбудований" у мову: це звичайна функція.

Оператор `(||)` "швидкий": якщо його лівий операнд оцінюється на `True`, він не оцінює його правого операнда. У більшості мов для оцінки короткого обчислення потрібна спеціальна підтримка, але не в Haskell. Незабаром ми побачимо, чому.
****

Далі наша функція застосовується рекурсивно. Це наш перший приклад рекурсії, про який ми детально розповімо коротко.

Нарешті, наш вираз `if` охоплює кілька рядків. Вирівнюємо `then` та `else` гілки під `if` для. Поки ми використовуємо деякі відступи, їх точна кількість не важлива. За бажанням ми можемо записати весь вираз на одному рядку.

[source,haskell]
----
-- file: ch02/myDrop.hs
myDropX n xs = if n <= 0 || null xs then xs else myDropX (n - 1) (tail xs)
----

The length of this version makes it more difficult to read. We will usually break an if expression across several lines to keep the predicate and each of the branches easier to follow.
Довжина цієї версії ускладнює читання. Зазвичай ми розбиваємо вираз `if` у кількох рядках, щоб простіше слідувати за предикатом і кожній з гілок.

Для порівняння, ось еквівалент Python `MyDrop` з Haskell. Обидва структуровані аналогічно: кожен зменшує лічильник, видаляючи елемент із заголовка списку.

[source,python]
----
def myDrop(n, elts):
    while n > 0 and elts:
        n = n - 1
        elts = elts[1:]
    return elts
----

== Розуміння обчислення на прикладі

У нашому описі `myDrop` ми поки що зосередилися на зверніх особливостях. Нам потрібно заглибитись і розробити корисну ментальну модель того, як працює застосування функції. Для цього ми спочатку опрацюємо кілька простих прикладів, поки не зможемо пройти оцінку виразу `myDrop 2 "abcd"`.

Ми кілька разів говорили про заміну виразу на змінну, і ми використаємо цю можливість тут. Наша процедура буде включати перезаписи виразів знову і знову, замінюючи вирази змінними, поки ми не досягнемо остаточного результату. Гарний час застосувати олівець та папір, щоб ви могли слідувати нашим описам, спробувавши їх самостійно.

==== Ледаче обчислення

Почнемо з розгляду визначення простої нерекурсивної функції.

[source,haskell]
----
-- file: ch02/RoundToEven.hs
isOdd n = mod n 2 == 1
----

Тут `mod` є стандартною функцією модуля. Перший великий крок до розуміння того, як працює обчислення Haskell - це з'ясування того, що є результатом обчислення виразу `isOdd (1 + 2)`.

Before we explain how evaluation proceeds in Haskell, let us recap the sort of evaluation strategy used by more familiar languages. First, evaluate the subexpression 1 + 2, to give 3. Then apply the odd function with n bound to 3. Finally, evaluate mod 3 2 to give 1, and 1 == 1 to give True. 
Перш ніж ми пояснимо, як проходить обчислення в Haskell, давайте переглянемо таку стратегію обчислення, яку використовують більш звичні мови. Спочатку оцініть підвираз `1 + 2`, отримавши `3`. Потім застосуйте функцію `odd` з `n` прив’язаною до `3`. Нарешті, оцініть `mod 3 2`, щоб дати `1`, та `1 == 1` що дає `True`.

В мові, яка використовує пряме обчислення, аргументи функції оцінюються перед застосуванням функції. Haskell вибирає інший шлях: непряме обчислення.

У Haskell, суб-вираз `1 + 2` не зводиться до значення `3`. Натомість ми створюємо «обіцянку», що коли значення виразу `isOdd (1 + 2)` буде необхідне, ми зможемо його обчислити. Запис, який ми використовуємо для відстеження неообчисленого виразу, називається _гроною_. Це все, що відбувається: ми створюємо обіцянку і відкладаємо фактичну оцінку, поки вона дійсно не потрібна. Якщо результат цього виразу згодом ніколи не буде використаний, ми взагалі не будемо обчислювати його значення.

Непрямі оцінки часто називають лінивою оцінкою.footnote:[Терміни "непрямий" і "лінивий" мають дещо різні технічні значення, але ми не будемо вдаватися тут до деталей розрізнення.]

==== Більш змістовний приклад

Давайте тепер розглянемо оцінку виразу `myDrop 2 "abcd"`, де ми використовуємо `print` для того, щоб він був обчислений.

[source,haskell]
----
ghci> print (myDrop 2 "abcd")
"cd"
----

Нашим першим кроком є ​​спроба застосувати `print`, який потребує оцінки його аргументу. Для цього ми застосовуємо функцію `myDrop` до значень `2` та `"abcd"`. Прив'язуємо змінну `n` до значення `2`, а `xs` - `"abcd"`. Якщо ми замінимо ці значення на предикат `myDrop`, отримаємо наступний вираз.

[source,haskell]
----
ghci> :type  2 <= 0 || null "abcd"
2 <= 0 || null "abcd" ::Bool
----

Потім ми достатньо оцінюємо предикат, щоб з’ясувати, у чому його значення. Це вимагає, щоб ми оцінили вираз `(||)`. Щоб визначити його значення, `(||)` оператору необхідно спочатку вивчити значення лівого операнда.

[source,haskell]
----
ghci> 2 <= 0
False
----

Заміна цього значення на вираз `(||)` призводить до наступного виразу.

[source,haskell]
----
ghci> :type  False || null "abcd"
False || null "abcd" :: Bool
----

Якби лівий операнд надає значення `True`, `(||)` не потрібно було б оцінювати його правий операнд, оскільки він не міг вплинути на результат вираження. Оскільки він оцінюється як `False`, `(||)` повинен оцінити правильний операнд.

[source,haskell]
----
ghci> null "abcd"
False
----

We now substitute this value back into the (||) expression. Since both operands evaluate to False, the (||) expression does too, and thus the predicate evaluates to False. 
Тепер ми підставляємо це значення назад у вираз `(||)`. Оскільки обидва операнди оцінюються як `False`, то `(||)` вираз також, і, таким чином, предикат оцінюється як `False`.

[source,haskell]
----
ghci> False || False
False
----

This causes the if expression's else branch to be evaluated. This branch contains a recursive application of myDrop. 
Це викликає оцінку гілки `if` виразу `else`. Ця гілка містить рекурсивну програму `myDrop`.

.Коротке обчислення безкоштовно
****
[NOTE]
Багато мов потребують поводження з логічним або оператором спеціально, щоб вони шли коротким шляхом, якщо його лівий операнд визначає значення `True`. У Haskell `(||)` є звичайною функцією: непряме обчислення вбудовує цю здатність у мову.
****
У Haskell ми можемо легко визначити нову функцію, що іде коротким шляхом.

[source,haskell]
----
-- file: ch02/shortCircuit.hs
newOr a b = if a then a else b
----

Якщо ми запишемо вираз, як `newOr True (length [1 ..]> 0)`, він не буде оцінювати його другий аргумент. (Це так само: вираз намагається обчислити довжину нескінченного списку. Якби його обчислювали, він би підвішував ghci в нескінченому циклі, поки б ми його не вбили).

Якби ми написали подібну функцію, скажімо, в Python, безпосереднє обчислення нас би покусало: обидва аргументи були б обчислені до того, як вони будуть передані до `newOr`, і ми не змогли б уникнути нескінченного циклу на другому аргументі.

==== Рекурсія

When we apply myDrop recursively, n is bound to the thunk 2 - 1, and xs to tail "abcd". 
Коли ми застосовуємо `myDrop` рекурсивно, `n` прив’язується до грона `2 - 1`, та `xs` до `tail "abcd"`.

We're now evaluating myDrop from the beginning again. We substitute the new values of n and xs into the predicate. 
Зараз ми знову обчислюємо `myDrop` спочатку. Заміняємо нові значення `n` і `xs` в предикаті.

[source,haskell]
----
ghci> :type (2 - 1) <= 0 || null (tail "abcd")
(2 - 1) <= 0 || null (tail "abcd") :: Bool
----

Ось стисла версія обчислення лівого операнду.

[source,haskell]
----
ghci> :type (2 - 1) <= 0
(2 - 1) <= 0 :: Bool
ghci> 2 - 1
1
ghci> 1 <= 0
False
----

Як і слід було очікувати, ми не оцінювали вираз `2 - 1`, поки нам не знадобилося його значення. Ми також ліниво оцінюємо правий операнд, відкладаючи `tail "abcd"`, поки нам не знадоб`иться його значення.
`
[source,haskell]
----
ghci> :type null (tail "abcd")
null (tail "abcd") :: Bool
ghci> tail "abcd"
"bcd"
ghci> null "bcd"
False
----

Предикат знову оцінюється як `False`, внаслідок чого ще одна гілка буде оцінена ще раз.

Because we've had to evaluate the expressions for n and xs to evaluate the predicate, we now know that in this application of myDrop, n has the value 1 and xs has the value "bcd". 
Оскільки нам довелося оцінити вирази для `n` та `xs`, щоб оцінити предикат, тепер ми знаємо, що в цьому застосуванні `myDrop` `n` має значення `1`, а `xs` має значення `"bcd"`.

==== Закінчення рекурсії

In the next recursive application of myDrop, we bind n to 1 - 1 and xs to tail `"bcd"`. 
У наступному рекурсивному застосуванні `myDrop` ми прив'язуємо `n` до `1 - 1` і `xs` до `tail "bcd"`.

[source,haskell]
----
ghci> :type (1 - 1) <= 0 || null (tail "bcd")
(1 - 1) <= 0 || null (tail "bcd") :: Bool
----

Ще раз, `(||)` спочатку має оцінити свій лівий операнд.

[source,haskell]
----
ghci> :type (1 - 1) <= 0
(1 - 1) <= 0 :: Bool
ghci> 1 - 1
0
ghci> 0 <= 0
True
----

Нарешті, цей вираз було оцінено як `True`!

[source,haskell]
----
ghci> True || null (tail "bcd")
True
----

Оскільки правий операнд не може впливати на результат `(||)`, він не обчислюється, а результат предиката - `True`. Це змушує нас обчислювати гілку `then`.

[source,haskell]
----
ghci> :type tail "bcd"
tail "bcd" :: [Char]
----

==== Повернення з рекурсії

Пам'ятайте, що зараз ми знаходимось у нашому другому рекурсивному застосуванні `myDrop`. Це застосування обчислюється до `tail "bcd"`. Ми повертаємось із застосування функції, замінивши цей вираз на `myDrop (1 - 1) (tail "bcd")`, щоб стати результатом цього застосування.

[source,haskell]
----
ghci> myDrop (1 - 1) (tail "bcd") == tail "bcd"
True
----

Потім повертаємося з першої рекурсії, замінюючи результат другого рекурсивного застосування для `myDrop (2 - 1) (tail "abcd")`, щоб стати результатом цього застосування.

[source,haskell]
----
ghci> myDrop (2 - 1) (tail "abcd") == tail "bcd"
True
----

Нарешті, ми повертаємося з нашого початкового застосування, замінюючи результат першого рекурсивного застосування.

[source,haskell]
----
ghci> myDrop 2 "abcd" == tail "bcd"
True
----

Notice that as we return from each successive recursive application, none of them needs to evaluate the expression tail "bcd": the final result of evaluating the original expression is a thunk. The thunk is only finally evaluated when ghci needs to print it. 
Зауважте, що, повертаючись із кожної послідовної рекурсії, жодному з них не потрібно оцінювати вираз `tail "bcd"`: кінцевий результат оцінювання вихідного виразу - це гроно. Гроно обчислюється лише остаточно, коли ghci потребує його надрукувати.

[source,haskell]
----
ghci> myDrop 2 "abcd"
"cd"
ghci> tail "bcd"
"cd"
----

=== Що ми дізналися?

Тут ми встановили кілька важливих моментів.

* Для розуміння обчислення виразу Haskell має сенс використовувати підстановку та переписування.
* Лінь приводить нас до відстрочення обчислення, поки нам не знадобиться значення, і для оцінки достатньої частини виразу, щоб встановити його значення.
* Результатом застосування функції може бути гроно (відкладений вираз).

== Поліморфізм у Haskell

Коли ми зайомились зі списками, ми згадували, що тип списку є поліморфним. Більш детально ми поговоримо про поліморфізм Haskell тут.

Якщо ми хочемо отримати останній елемент списку, ми використовуємо функцію `last`. Значення, яке вона повертає, повинно мати той самий тип, що й елементи списку, але `last` функціонує так само, насправді незалежно від типу цих елементів.

[source,haskell]
----
ghci> last [1,2,3,4,5]
5
ghci> last "baz"
'z'
----

Щоб зафіксувати цю ідею, її підпис типу містить змінну типу.

[source,haskell]
----
ghci> :type last
last :: [a] -> a
----

Here, a is the type variable. We can read the signature as “takes a list, all of whose elements have some type a, and returns a value of the same type a”. 
Тут `a` - змінна типу. Ми можемо читати сигнатуру як "бере список, усі елементи якого мають певний тип `a` і повертає значення того ж типу `a`".

.Ідентифікація змінної типу
****
[TIP]	
Змінні типу завжди починаються з малої літери. Ви завжди можете відрізнити змінну типу від звичайної змінної за контекстом, оскільки мови типів і функцій є окремими: змінні типу живуть у сигнатурах типів, а звичайні змінні - у звичайних виразах.

Загальна практика Haskell - робити імена змінних типів дуже короткими. Одна буква є надзвичайно поширеною; довші назви з’являються нечасто. Сигнатури типу зазвичай короткі; ми отримуємо більше читабельності, зберігаючи короткі імена, ніж ми робимо їх описовими.
****

Коли функція має змінні типу в своїй сигнатурі, що вказує на те, що деякі її аргументи можуть бути будь-якого типу, ми називаємо функцію поліморфною.

Коли ми хочемо застосувати `last`, скажімо, до списку `Char`, компілятор підставляє `Char`` замість `a` в усій сигнатурі типу, який дає нам тип `last` із введенням `[Char]` як `[Char] -> Char`.

Цей вид поліморфізму називається параметричним поліморфізмом. Вибір іменування легко зрозуміти за аналогією: подібно до того, як функція може мати параметри, які ми можемо згодом прив’язувати до реальних значень, тип Haskell може мати параметри, які згодом ми можемо прив’язати до інших типів.

.Маленька номенклатура
****
[TIP]	
Якщо тип містить параметри типу, ми говоримо, що це параметризований тип або поліморфний тип. Якщо тип функції або значення містить параметри типу, ми називаємо це поліморфним.
****

Коли ми бачимо параметризований тип, ми вже відзначали, що код не переймається тим, що таке фактичний тип. Однак ми можемо зробити більш сильне твердження: у нього немає ніякого способу з’ясувати, що таке реальний тип, або маніпулювати значенням цього типу. Він не може створити значення і він не може його перевірити. Все, що він може зробити, це трактувати це як повністю абстрактний «чорний ящик». Ми розкриємо одну причину, чому це важливо незабаром.

Параметричний поліморфізм є найбільш помітним видом поліморфізму, який підтримує Haskell. Параметричний поліморфізм Haskell безпосередньо вплинув на розробку загальних засобів мов Java та C#. Параметризований тип в Haskell схожий на змінну типу в дженеріках Java. Шаблони C++ також нагадують параметричний поліморфізм.

Щоб зрозуміти, чим поліморфізм Haskell відрізняється від інших мов, ось кілька форм поліморфізму, які є загальними для інших мов, але відсутні в Haskell.

У основних об'єктно-орієнтованих мовах поліморфізм субтипів є більш поширеним, ніж параметричний поліморфізм. Механізми субкласів C++ та Java надають їм поліморфізм субтипів. Базовий клас визначає набір поведінки, який його підкласи можуть змінювати та розширювати. Оскільки Haskell не є об'єктно-орієнтованою мовою, він не забезпечує поліморфізм субтипів.

Також поширеним є примусовий поліморфізм, який дозволяє неявно перетворювати значення одного типу у значення іншого типу. Багато мов надають певну форму поліморфізму примусу: один приклад - автоматичне перетворення між цілими числами і числами з плаваючою комою. Haskell навмисно уникає навіть такого простого автоматичного примусу.

Це ще не вся історія поліморфізму в Haskell: ми повернемося до теми в Розділі 6, *_Використовуючи типокласи_*.

==== Думки про поліморфні функції

У розділі «Типи функцій та чистота» ми говорили про з'ясування поведінки функції на основі її сигнатури типу. Ми можемо застосувати такий же спосіб міркування до поліморфних функцій. Погляньмо ще раз на `fst`.

[source,haskell]
----
ghci> :type fst
fst :: (a, b) -> a
----

Перш за все, зауважте, що його аргумент містить дві змінні типу, `a` і `b`, що означає, що елементи кортежу можуть бути різних типів.

Типом результату `fst` є `a`. Ми вже згадували, що параметричний поліморфізм робить реальний тип недоступним: у `fst` не вистачає інформації для побудови значення типу `a`, а також не може перетворити `a` в `b`. Таким чином, єдино можлива дійсна поведінка (опускаючи нескінченні цикли або збої), які вона може мати, - це повернути перший елемент пари.

=== Подальше читання

Існує глибокий математичний сенс, в якому будь-яка непатологічна функція типу `(a, b) -> a` повинна виконувати саме те, що робить `fst`. Більше того, ці міркування поширюється на більш складні поліморфні функції. У роботі [Wadler89] глибоко висвітлюється ця процедура.

****
Було запропоновано створити «теоретичну скриньку» для обговорення глибокого матеріалу та посилань на наукові роботи.
****

== Тип функції з більш ніж одним аргументом

Поки ми не дуже придивились до сигнатур функцій, які приймають більше одного аргументу. Ми вже використали кілька таких функцій; давайте подивимось на сигнатуру однієї, `take`.

[source,haskell]
----
ghci> :type take
take :: Int -> [a] -> [a]
----

Цілком зрозуміло, що щось відбувається з `Int` та деякими списками, але чому в сигнатурі є два символи `->`? Haskell згрупує цей ланцюжок стрілок справа наліво; тобто `->` є право-асоціативним. Якщо ми введемо круглі дужки, ми можемо зрозуміти, як трактується підпис цього типу.

[source,haskell]
----
-- file: ch02/Take.hs
take :: Int -> ([a] -> [a])
----

З цього виходить, що нам слід прочитати сигнатуру типу як функцію, яка бере один аргумент, `Int` та повертає іншу функцію. Ця інша функція також приймає один аргумент, список і повертає список того ж типу як результат.

Це правильно, але нелегко зрозуміти, які можуть бути його наслідки. Ми повернемося до цієї теми у розділі «Часткове застосування функцій та карування», після того як витратимо трохи часу на написання функцій. На даний момент ми можемо розглядати тип після останнього `->`, як тип повернення функції, а попередні типи - як аргументи функції.

Тепер ми можемо написати сигнатуру типу для функції `myDrop`, яку ми визначили раніше.

[source,haskell]
----
-- file: ch02/myDrop.hs
myDrop :: Int -> [a] -> [a]
----

=== Вправи

1. Haskell забезпечує стандартну функцію, `last ::[a] -> a`, яка повертає останній елемент списку. Читаючи лише тип, які можливі дійсні поведінки (за винятном збоїв і нескінченних циклів), що ця функція може мати? Які декілька речей, які ця функція явно не може виконати?
2. Напишіть функцію `lastButOne`, яка повертає елемент перед останнім.
3. Завантажте вашу функцію `lastButOne` в ghci та спробуйте її на списках різної довжини. Що станеться, коли ви передасте йому список, який є занадто коротким?

=== Чому така метушня з чистотою?

Мало мов програмування заходять так далеко як Haskell, наполягаючи, що чистота повинна бути нормою. Цей вибір має глибокі і цінні наслідки.

Оскільки результат застосування чистої функції може залежати лише від її аргументів, ми часто можемо отримати сильний натяк на те, що робить чиста функція, просто прочитавши її ім’я та зрозумівши її сигнатуру типу. Як приклад, давайте розглянемо `not`.

[source,haskell]
----
ghci> :type not
not :: Bool -> Bool
----

Навіть якби ми не знали назву цієї функції, лише її сигнатура обмежує можливі дійсні поведінки, які вона може мати.

* Ігнорувати її аргумент і завжди повертайте `True` або `False`.
* Повернути її аргумент немодифікованим.
* Обернути свій аргумент.

Ми також знаємо, що ця функція не може виконувати деякі речі: вона не може отримати доступ до файлів, вона не може спілкуватися з мережею, вона не може сказати, котра година.

Чистота полегшує роботу з розумінням коду. Поведінка чистої функції не залежить від значення глобальної змінної, або від вмісту бази даних, або від стану мережевого з'єднання. Чистий код за своєю суттю є модульним: кожна функція є самодостатньою та має чітко визначений інтерфейс.

Неочевидним наслідком чистоти, що є типовим, є те, що працювати з нечистим кодом стає простіше. Haskell заохочує стиль програмування, в якому ми відокремлюємо код, який повинен мати побічні ефекти від коду, якому вони не потрібні. У цьому стилі нечистий код, як правило, простий, з "піднняттям ваги", виконаним у чистому коді.

Much of the risk in software lies in talking to the outside world, be it coping with bad or missing data, or handling malicious attacks. Because Haskell's type system tells us exactly which parts of our code have side effects, we can be appropriately on our guard. Because our favoured coding style keeps impure code isolated and simple, our “attack surface” is small. 
Значна частина ризику в програмному забезпеченні полягає в спілкуванні з навколишнім світом, будь то впоратися з поганими або відсутніми даними або поводжуватися зі зловмисними атаками. Оскільки система типів Haskell нам точно говорить, які частини нашого коду мають побічні ефекти, ми можемо бути належним чином захищені. Оскільки наш вподобаний стиль кодування тримає нечистий код ізольованим та простим, наша "атакована поверхня" невелика.

== Висновок

У цій главі ми провели короткий огляд системи типів Haskell та значної частини її синтаксису. Ми прочитали про найпоширеніші типи та дізналися, як писати прості функції. Нас ознайомили з поліморфізмом, умовними виразами, чистотою та ледачим обчисленням.

Все це становить багато інформації, яку потрібно засвоїти. У Розділі 3 *_Визначення типів, упорядкування функцій_* ми будемо базуватися на цих основних знаннях для подальшого розширення нашого розуміння Haskell.