<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Функціональне вирішення проблем</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми поглянемо на деякі цікаві проблеми, і як мислити функціонально, щоб вирішувати їх настільки елегантно, наскільки це можливо. Можливо ми не будемо вводити нові концепції, ми будемо тільки розминати наші тільки що отримані м'язи Haskell і попрактикуємось в навичках кодування. Кожний розділ буде представляти іншу проблему. Спочатку ми опишемо проблему, потім ми спробуємо знайти, який є кращий (або найменьш поганий) шлях для його вирішення.</p></div>
<div class="sect2">
<h3 id="____">Калькулятор зворотньої польської нотації</h3>
<div class="paragraph"><p>Звичайно, коли ви пишете математичний вираз в школі, ми пишемо його в інфіксній манері. Наприклад, ми пишемо <code>10 - (4 + 3) * 2</code>. <code>+</code>, <code>*</code> та <code>-</code> є інфіксні оператори, так само як інфіксні функції, які ми зустрічали в Haskell (<code>+</code>, <code>\`elem</code>, тощо.). Це робить все зручним, оскількі ми, як люди, можемо це легко розібрати подумки, дивлячись на такий різновид виразів. Недолік цього в тому, що нам треба використовувати дужки для позначення преоритетів.</p></div>
<div class="paragraph"><p>Зворотня польська нотація є іншим способом записувати математичні вирази. Спочатку вона виглядає дещо схибленою, але насправді її досить легко зрозуміти і використовувати, бо немає потреби в дужках, і її дуже легко вбити в калькулятор. Хоча більшість сучасних калькуляторів використовують інфіксну нотацію, деякі користувачі досі віддані RPN калькуляторам. Ось як виглядає попередній інфіксний вираз в RPN: <code>10 4 3 + 2 * -</code>. Як ми обчислюємо результат, що буде отриманий? Гаразд, уявіть собі стек. Ви ідете по виразу зліва направо. Кожного разу коли трапляється число, заштовхуємо його в стек. Коли нам трапляється оператор, беремо два числа, що знаходяться нагорі стеку (ми кажемо, що також виштовхуємой їх), застосовуємо оператор для ціх двох, та потім заштовхуємо результуюче число назад в стек. Коли ви дійдете до кінця виразу, ви повинні залишитись з одним числом, якщо вираз був гарно сформований, і це число представляє результат.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/rpn.png" alt="images/rpn.png" />
</span>
Давайте пройдемо по виразу <code>10 4 3 + 2 * -</code> разом! Спочатку ми заштовхуємо <code>10</code> в стек, і тепер стек <code>10</code>. Наступний елемент є <code>4</code>, так що ми заштовхуємо його в стек також. Тепер стек <code>10, 4</code>. Ми робимо те саме з <code>3</code>, і тепер стек <code>10, 4, 3</code>. І тепер ми натрапили на оператор, а саме <code>+</code>! Ми виштовхуємо два числа зі стеку (так що в стеку лише <code>10</code>), додаємо ці числа разом і заштовхуємо цей результат в стек. Тепер стек <code>10, 7</code>. Ми заштовхуємо <code>2</code> до стеку, стек тепер стає <code>10, 7, 2</code>. Ми знову натрапляємо на оператор, так що ми виштовхуємо <code>7</code> та <code>2</code> зі стеку, перемножуємо їх і заштовхуємо результат в стек. Множення <code>7</code> та <code>2</code> продукує <code>14</code>, так що тепер ми маємо в стеку <code>10, 14</code>. Нарешті маємо <code>-</code>. Ми виштовхуємо <code>10</code> та <code>14</code> зі стеку, віднімаємо <code>14</code> з <code>10</code>, і заштовхуємо його назад. Число в стеку тепер <code>-4</code>, і оскільки більше немає чисел або операторів в нашому виразі, це і є результат!</p></div>
<div class="paragraph"><p>Тепер, коли ми знаємо як обчислити любий RPN вираз вручну, давайте подумаємо, як ми можемо створити функцію Haskell, що приймає в якості свого параметру рядок, що містить RPN вираз, як <code>"10 4 3 + 2 * -"</code> і видає назад його результат.</p></div>
<div class="paragraph"><p>Який буде результат цієї функції? Ми хотіли б, що би вона брала рядок як параметр, і продукувала число в якості результата. Так що буде щось подібне до <code>solveRPN ::(Num a) =&gt; String -&gt; a</code>.</p></div>
<div class="paragraph"><p>Підказка: це дійсно допомагає спочатку подумати, який має бути тип декларації функції, перед тим як обтяжувати себе реалізацією, та потім записати її. В Haskell декларація типу функції каже нам повну інформацію про функцію через дуже жорстку систему типів.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/calculator.png" alt="images/calculator.png" />
</span>
Круто. Коли реалізується рішення проблеми в Haskell, також є гарним подумати, як це робиться вручну, і моживо спробувати подивитись, чи можливо отримати з цього якесь прозріння. Тут ми бачимо, що ми розглядаємо кожне число або оператор, що були розділені проміжками, як окремий елемент. Так що нам може стати в нагоді, якщо ми почнемо з розбиття рядка як <code>"10 4 3 + 2 * -"</code> в список елементів <code>["10","4","3","+","2","*","-"]</code>.</p></div>
<div class="paragraph"><p>Далі що ми робили з цім списком елементів в нашій голові? Ми проходили по ньому зліва направо, і по ходу цього підтримували стек. Чи попереднє речення не нагадує вам щось? Пам'ятаєте, в розділі про згортки ми казали, що майже кожну функцію, що проходить по списку зліва направо або зправа наліво елемент за елементом, і будує (акумулює) деякий результат (чи число, чи список, стек або будь-що) може бути реалізована як згортка.</p></div>
<div class="paragraph"><p>В цьому випадку ми збираємось використовувати ліву згортку, оскільки ми йдемо по списку зліва направо. Значення аккумулятора буде наш стек, і такм чином результат згортки також буде стек, який, як ми бачили, буде мати лише один елемент.</p></div>
<div class="paragraph"><p>Одна річ, про яку нам треба подумати, гаразд, як ми збираємось представляти стек? Я пропоную використовувати список. Також я пропоную, щоб ми тримали верхівку нашого стеку в голові нашого списку. Це тому що додавання в голову (початок) списку значно швидше, ніж додавання в його кінець. Так що якщо ми маємо стек, скажімо, <code>10, 4, 3</code>, ми представлятимо його як список <code>[3,4,10]</code>.</p></div>
<div class="paragraph"><p>Тепер ми маємо досить інформації щоб грубо накидати нашу функцію. Вона буде приймати рядок, як <code>"10 4 3 + 2 * -"</code> та розбивати його на список елементів за допомогою <code>words</code>, щоб отримати <code>["10","4","3","+","2","*","-"]</code>. Далі ми робитимемо ліву згортку та скінчимо зі стеком, що має один елемент, <code>[-4]</code>. Ми отримуємо цей поодинокий елмент зі списку, і це є наш фінальний результат!</p></div>
<div class="paragraph"><p>Так що ось ескіз цієї функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">solveRPN</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">solveRPN</span> <span class="n">expression</span> <span class="k">=</span> <span class="n">head</span> <span class="o">(</span><span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="o">[]</span> <span class="o">(</span><span class="n">words</span> <span class="n">expression</span><span class="o">))</span>
    <span class="n">where</span>   <span class="n">foldingFunction</span> <span class="n">stack</span> <span class="n">item</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми беремо вираз і перетворюємо його на список елементів. Потім ми робимо згортання по цьому списку елементів за допомогою функції згортки. Подумайте про <code>[]</code>, що представляє початковий аккумулятор. Аккумулятором є наш стек, так що <code>[]</code> представляє порожній стек, що є те з чого ми починаємо. Після отримання фінального стеку з одним елементом ми викликаємо <code>head</code> на цьому списку, щоб отримати елемент і потім застосовуємо <code>read</code>.</p></div>
<div class="paragraph"><p>Так що все, що тепер залишилось, це реалізувати функцію згортки, що буде приймати стек, як <code>[4,10]</code> та елемент, як <code>"3"</code>, та повертає новмй стек <code>[3,4,10]</code>. Якщо стек був <code>[4,10]</code> і елемент <code>"*"</code>, тоді пона має повертати <code>[40]</code>. Але перед цім давайте перетворимо нашу функцію в крапковому стилі, оскільки вона має багато дужок, що ніби дещо лякають мене:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">solveRPN</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">solveRPN</span> <span class="k">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="o">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="n">where</span>   <span class="n">foldingFunction</span> <span class="n">stack</span> <span class="n">item</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Отак. Значно краще. Так що функція згортки буде приймати стек і елемент і повертати новий стек. Ми будемо використовувати співпадіння шаблонів для отримання верхніх елементів стеку та співпадіння шаблонів для операторів як <code>"*"</code> та <code>"-"</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">solveRPN</span> <span class="o">::(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Read</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">solveRPN</span> <span class="k">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="o">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="n">where</span>   <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;*&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;+&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;-&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="k">:</span><span class="kt">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми розклали це як чотири шаблони. Шаблони будуть випробовуватись згори донизу. Спочатку функція згортки буде дивитись, чи поточний елемент є <code>"* "</code>. Якщо так, тоді вона братиме список як <code>[3,4,9,3]</code> та позначатиме перші два елементи <code>x</code> та <code>y</code> відповідно. Так що в цьому випадку <code>x</code> буде <code>3</code> і <code>y</code> буде <code>4</code>. <code>ys</code> буде <code>[9,3]</code>. Вона повертатиме список, що подібний до <code>ys</code>, тільки він матиме перемножені <code>x</code> та <code>y</code> в якості голови. Так що маючи це ми виштовхуємо два верхні числа зі списку, множимо їх і заштовхуємо результат назад в стек. Якщо елемент не <code>"*"</code>, співпадіння шаблону провалиться далі і буде перевірятись <code>"+"</code>, і так далі.</p></div>
<div class="paragraph"><p>Якщо елемент не один з операторів, тоді ми вважаємо що це рядок, що представляє число. Якщо це число ми просто викликаємо <code>read</code> на цьому рядку, щоб отримати з нього число, і повертаємо попередній стек, але з цім числом, покладеним зверху.</p></div>
<div class="paragraph"><p>І це все! Також зауважте, що ми додали додаткове обмеження класу <code>Read a</code> до декларації функції, бо ми викликаємо <code>read</code> на нашому рядку для отримання числа. Так що ця декларація означає, що результат може бути любого типу, що є частиною типокласів <code>Num</code> та <code>Read</code> (як <code>Int</code>, <code>Float</code>, etc.).</p></div>
<div class="paragraph"><p>Для списку елементів <code>["2","3","+"]</code> наша функція почне згортати зліва. Початковий стек буде <code>[]</code>. Вона буде викликати функцію згортки з <code>[]</code> в якості стека (аккумулятора) і <code>"2"</code> в якості елемента. Оскільки цей елемент не оператор, він буде прочитаний <code>read</code> і доданий в початок <code>[]</code>. Так що новий стек тепер <code>[2]</code> і функція згортання буде викликана з <code>[2]</code> та <code>"3"</code> в якості елемента, продукуючи новий стек <code>[3,2]</code>. Тоді вона буде викликана третій раз з  <code>[3,2]</code> як стек і <code>"+"</code> як елемент. Це призеде до того що ці два числа будуть виштовхнуті зі стеку, додані разом і заштовхнуті назад. Фінальний стек є <code>[5]</code>, що є числом яке ми повертаємо.</p></div>
<div class="paragraph"><p>Давайте пограємось з нашею функцією:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ghci&gt; solveRPN "10 4 3 + 2 * -"
-4
ghci&gt; solveRPN "2 3 +"
5
ghci&gt; solveRPN "90 34 12 33 55 66 + * - +"
-3947
ghci&gt; solveRPN "90 34 12 33 55 66 + * - + -"
4037
ghci&gt; solveRPN "90 34 12 33 55 66 + * - + -"
4037
ghci&gt; solveRPN "90 3 -"
87</code></pre>
</div></div>
<div class="paragraph"><p>Круто, вона робить! Одна гарна річ щодо цієї функції, що вона може бути просто модифікована для підтримки різних інших операторів. Вони навіть не мають бути двомісними операціями. Наприклад ми можемо створити оператор <code>"log"</code> що просто бере одне число зі стеку, та заштовхує назад його логарифм. Ми також можемо створити тримісну операцію, що виштовхує три числа зі стеку і заштовхує назад результат, або оператори як <code>"sum"</code>, що виштовхують всі числа і повертають назад їх суму.</p></div>
<div class="paragraph"><p>Давайте модифікуємо нашу функцію, щоб вона сприймала ще декілька операторів. Для спрощення ми змінимо її декларацію типу, щоб вона повертала число типу <code>Float</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">solveRPN</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">Float</span>
<span class="n">solveRPN</span> <span class="k">=</span> <span class="n">head</span> <span class="o">.</span> <span class="n">foldl</span> <span class="n">foldingFunction</span> <span class="o">[]</span> <span class="o">.</span> <span class="n">words</span>
    <span class="n">where</span>   <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;*&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;+&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;-&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;/&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:ys</span><span class="o">)</span> <span class="s">&quot;^&quot;</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span> <span class="o">**</span> <span class="n">x</span><span class="o">)</span><span class="k">:</span><span class="kt">ys</span>
            <span class="n">foldingFunction</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">xs</span><span class="o">)</span> <span class="s">&quot;ln&quot;</span> <span class="k">=</span> <span class="n">log</span> <span class="n">x</span><span class="k">:</span><span class="kt">xs</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="s">&quot;sum&quot;</span> <span class="k">=</span> <span class="o">[</span><span class="kt">sum</span> <span class="kt">xs</span><span class="o">]</span>
            <span class="n">foldingFunction</span> <span class="n">xs</span> <span class="n">numberString</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span><span class="k">:</span><span class="kt">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Це йо, це чудово! <code>/</code> це звичайно ділення, та <code>**</code> є експонента з плаваючою крапкою. З оператором логарифму ми робимо співпадіння шаблону тільки для одного елементу і решти списку, бо нам треба лише один елемент для обчислення натурального логарифму. З оператором <code>sum</code> ми повертаємо стек, що містить всього один елемент, що є сумою всіх елементів, які були в стеку до цього.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ghci&gt; solveRPN "2.7 ln"
0.9932518
ghci&gt; solveRPN "10 10 10 10 sum 4 /"
10.0
ghci&gt; solveRPN "10 10 10 10 10 sum 4 /"
12.5
ghci&gt; solveRPN "10 2 ^"
100.0</code></pre>
</div></div>
<div class="paragraph"><p>Зуважте, що ми можемо включати в наш вираз числа з плаваючою крапкою, оскільки <code>read</code> знає як їх читати.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ghci&gt; solveRPN "43.2425 0.5 ^"
6.575903</code></pre>
</div></div>
<div class="paragraph"><p>Я думаю що створити функцію, яка може обчислювати довільні RPN вирази з плаваючою крапкою, і що може бути просто розширеня в десяти рядках, є повністю неймовірним.</p></div>
<div class="paragraph"><p>Одна річ, що треба відмітити, це те, що ця функція не є насправді стійкою до збоїв. Коли надається ввод що не має сенсу, це просто все зруйнує. Ми створимо захищену версію з декларацією типу <code>solveRPN ::String -&gt; Maybe Float</code> як тільки дізнаємось про монади (вони не страшні, вірте мені!). Ми можемо зробити це прямо зараз, але це буде трохи обтяжливо, оскільки це включатиме багато перевірок на <code>Nothing</code> на кожному кроку. Однак якщо ви відчуваєте себе готовим до виклику, ви можете спробувати зробити це! Підказка: ви можете використовувати <code>reads</code> щоб побачити, чи <code>read</code> був вдалим чи ні.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">З Хітроу до Лондона</h3>
<div class="paragraph"><p>Наступна наша проблема така: ваш літак щойно приземлився в Англії, і ви орендуєте машину. У вас незабаром зустріч, і ви повинні дістатися з аеропорту Хітроу до Лондона якнайшвидше (але безпечно!).</p></div>
<div class="paragraph"><p>Є дві головні дороги, що йдуть від Хітроу до Лондона, і їх перетинає ряд регіональних доріг. Щоб подорожувати з одного перехрестя на інший, вам знадобиться певний час. Вам належить знайти оптимальний шлях, щоб пройти до Лондона якнайшвидше! Ви починаєте з лівого боку і можете переходити на іншу головну дорогу або їхати вперед.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/roads.png" alt="images/roads.png" />
</span>
Як ви бачите на малюнку, найкоротший шлях від Хітроу до Лондона в цьому випадку - починати на головній дорозі B, переходити, їхати вперед по А, переходити знову і потім двічі йти по Б. Якщо ми підемо цим шляхом, це займає у нас 75 хвилин. Якби ми обрали будь-який інший шлях, це зайняло б більше.</p></div>
<div class="paragraph"><p>Our job is to make a program that takes input that represents a road system and print out what the shortest path across it is. Here&#8217;s what the input would look like for this case:
Наша робота полягає в тому, щоб зробити програму, яка бере вхід, що представляє дорожню систему, і роздрукувує найкоротший шлях. Ось як буде виглядати вхід для цього випадку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>50
10
30
5
90
20
40
2
25
10
8
0</code></pre>
</div></div>
<div class="paragraph"><p>Щоб подумки розібрати вхідний файл, прочитайте його по трійках, і подумки розділіть дорожню систему на ділянки. Кожна ділянка складається з дороги А, дороги Б та перехресної дороги. Щоб воно було акуратно вписане в трійки, ми говоримо, що є остання секція перетину, на яку потрібно їхати 0 хвилин. Це тому, що нам байдуже, куди ми приїдемо в Лондон, якщо ми вже в Лондоні.</p></div>
<div class="paragraph"><p>Так само, як ми вирішували проблему з калькулятором RPN, ми вирішимо цю проблему в три етапи:</p></div>
<div class="ulist"><ul>
<li>
<p>
Забудьте на хвилину Haskell і подумайте, як би ми вирішили проблему вручну
</p>
</li>
<li>
<p>
Подумайте, як ми будемо представляти наші дані в Haskell
</p>
</li>
<li>
<p>
З’ясуйте, як оперувати цими даними в Haskell, щоб ми виробляли рішення
</p>
</li>
</ul></div>
<div class="paragraph"><p>У розділі калькулятора RPN ми спершу з’ясували, що, обчислюючи вираз вручну, ми зберігаємо свого роду уявний стек, а потім проходимо по виразу по одному кроку за раз. Ми вирішили використати список рядків для представлення нашого виразу. Нарешті, ми використали ліву згортку, щоб перейти до списку рядків, зберігаючи стек для рішення.</p></div>
<div class="paragraph"><p>Okay, so how would we figure out the shortest path from Heathrow to London by hand? Well, we can just sort of look at the whole picture and try to guess what the shortest path is and hopefully we&#8217;ll make a guess that&#8217;s right. That solution works for very small inputs, but what if we have a road that has 10,000 sections? Yikes! We also won&#8217;t be able to say for certain that our solution is the optimal one, we can just sort of say that we&#8217;re pretty sure.
Гаразд, то як би ми вручну визначили найкоротший шлях з Хітроу до Лондона? Що ж, ми можемо просто поглянути на всю картину і спробувати вгадати, який шлях найкоротший, сподіваючись, що наша здогадка вірна. Це рішення працює для дуже малих входів, але що робити, якщо у нас є дорога, яка має 10 000 ділянок? Джізус! Ми також не зможемо точно сказати, що наше рішення є оптимальним, ми можемо просто сказати, що ми досить впевнені.</p></div>
<div class="paragraph"><p>Тоді це не гарне рішення. Ось спрощена картина нашої дорожньої системи:</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/roads_simple.png" alt="images/roads_simple.png" />
</span>
Добре, чи можете ви зрозуміти, який найкоротший шлях до першого перехрестя (перша синя крапка на A, позначена A1) на дорозі A? Це досить банально. Ми просто бачимо, чи коротше йти прямо вперед по А, чи коротше йти вперед по В, а потім повертати. Очевидно, що дешевше їхати вперед через B, а потім повертати: на це потрібно 40 хвилин, тоді як на шлях через A потрібно 50 хвилин. Що з перехрестям B1? Те ж саме. Ми бачимо, що набагато дешевше просто поїхати прямо через B (затрати 10 хвилин), тому що переїзд через A і потім переправлення зайняв би нам цілих 80 хвилин!</p></div>
<div class="paragraph"><p>Тепер ми знаємо, що найдешевший шлях до А1 (піти через В, а потім перетнути, тому ми скажімо, що це B, C із вартістю 40), і ми знаємо, що найдешевший шлях до B1 (йти безпосередньо по B, так що це просто B, стане в 10). Чи допомагають нам ці знання взагалі, якщо ми хочемо знати найдешевший шлях до наступного перехрестя на обох головних дорогах? Боже, це саме так!</p></div>
<div class="paragraph"><p>Подивимось, яким був би найкоротший шлях до A2. Щоб дістатися до A2, ми або перейдемо безпосередньо до A2 від A1, або підемо вперед від B1, а потім перетнемось (пам’ятайте, ми можемо рухатись лише вперед або переходити на інший бік). А оскільки ми знаємо вартість A1 та B1, ми можемо легко зрозуміти, який найкращий шлях до A2. Щоб дістатися до А1, коштує 40, а потім - від А1 до А2, тож B, C, A коштує 45. Щоб дістатися до B1, коштує лише 10, але тоді знадобиться додаткові 110 хвилин до В2, а потім перетнути! Очевидно, найдешевший шлях до A2 - це B, C, A. Таким же чином, найдешевший шлях до B2 - це йти вперед від А1, а потім перетнутись.</p></div>
<div class="paragraph"><p>Можливо, ви запитуєте себе: а як же дістатися до A2, спочатку перейшовши на B1, а потім продовжуючи вперед? Ну, ми вже охопили перетин від B1 до A1, коли шукали найкращий шлях до A1, тому нам не доведеться також враховувати це на наступному кроці.
Тепер, коли у нас найкращий шлях до A2 та B2, ми можемо повторювати це нескінченно, поки не досягнемо кінця. Після того, як ми знайшли найкращі шляхи для A4 та B4, той, що дешевший - оптимальний шлях!</p></div>
<div class="paragraph"><p>Отже, по суті, для другого розділу ми просто повторюємо крок, який ми зробили спочатку, тільки ми враховуємо, які попередні найкращі шляхи на А і В. Ми могли б сказати, що ми також врахували найкращі шляхи на А і на B на першому кроці, тільки вони обидва були порожніми шляхами вартістю 0.</p></div>
<div class="paragraph"><p>Ось підсумок. Для того, щоб пройти найменший шлях від Хітроу до Лондона, ми робимо таке: спочатку ми бачимо, який найкращий шлях до наступного перехрестя на головній дорозі А. Два варіанти - йти прямо вперед або почати з протилежної дороги, вперед і потім перетнутись. Ми пам’ятаємо вартість і шлях. Ми використовуємо той самий метод, щоб побачити, який найкращий шлях до наступного перехрестя на головній дорозі B, і пам’ятаємо про це. Тоді ми бачимо, чи шлях до наступного перехрестя на А дешевший, якщо ми переходимо з попереднього перехрестя А або переходимо від попереднього перехрестя В, а потім переходимо. Ми пам’ятаємо про дешевший шлях, а потім робимо те ж саме для перехрестя, навпроти нього. Ми робимо це для кожного розділу, поки не дістанемось кінця. Як тільки ми дійшли до кінця, найдешевший з двох шляхів - це наш оптимальний шлях!</p></div>
<div class="paragraph"><p>Отже, по суті, ми тримаємо один найкоротший шлях на дорозі А і один найкоротший шлях на дорозі В. І коли ми досягнемо кінця, то коротший з цих двох - наш шлях. Тепер ми знаємо, як вручну визначити найкоротший шлях. Якщо у вас було достатньо часу, паперу та олівців, ви могли б визначити найкоротший шлях через дорожню систему з будь-якою кількістю ділянок.</p></div>
<div class="paragraph"><p>Next step! How do we represent this road system with Haskell&#8217;s data types? One way is to think of the starting points and crossroads as nodes of a graph that point to other crossroads. If we imagine that the starting points actually point to each other with a road that has a length of one, we see that every crossroads (or node) points to the node on the other side and also to the next one on its side. Except for the last nodes, they just point to the other side.
Наступний крок! Як ми представляємо цю дорожню систему в типах даних Haskell? Один із способів - мислити вихідні точки та перехрестя як вузли графа, які вказують на інші перехрестя. Якщо ми уявляємо, що вихідні точки насправді вказують один на одного дорогою, яка має довжину одиниці, ми бачимо, що кожне перехрестя (або вузол) вказує на вузол з іншого боку, а також на наступне з його боку. За винятком останніх вузлів, вони просто вказують на іншу сторону.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Node</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Road</span> <span class="kt">Road</span> <span class="o">|</span> <span class="kt">EndNode</span> <span class="kt">Road</span>
<span class="kr">data</span> <span class="kt">Road</span> <span class="ow">=</span> <span class="kt">Road</span> <span class="kt">Int</span> <span class="kt">Node</span>
</pre></div></div></div>
<div class="paragraph"><p>Вузол є або звичайним вузлом і має інформацію про дорогу, яка веде до іншої головної дороги, і дорогу, яка веде до наступного вузла, або кінцевий вузол, який містить лише інформацію про дорогу до іншої головної дороги. Дорога зберігає інформацію про те, як довго вона знаходиться і на який вузол вона вказує. Наприклад, першою частиною дороги на головній дорозі A буде <code>Road 50 a1</code>, де <code>a1</code> буде вузлом <code>Node x y</code>, де <code>x</code> і <code>y</code> - дороги, які вказують на B1 і A2.</p></div>
<div class="paragraph"><p>Іншим способом було б використання <code>Maybe</code> для частин дороги, які спрямовані вперед. Кожен вузол має частину дороги, яка вказує на протилежну дорогу, але лише ті вузли, які не є кінцевими, мають частини, які спрямовані вперед.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Node</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="kt">Road</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="kt">Road</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Road</span> <span class="ow">=</span> <span class="kt">Road</span> <span class="kt">Int</span> <span class="kt">Node</span>
</pre></div></div></div>
<div class="paragraph"><p>Це добрий спосіб представити дорожню систему в Haskell, і ми, звичайно, могли б вирішити цю проблему з нею, але, можливо, ми могли б придумати щось простіше? Якщо ми повертаємося до нашого рішення вручну, ми завжди просто перевіряли довжину трьох дорожніх частин одразу: дорожню частину на дорозі А, її протилежну частину на дорозі Б та частину С, яка торкається цих двох частин і з'єднує їх . Коли ми шукали найкоротший шлях до А1 та В1, нам залишалося лише розібратися з довжинами перших трьох частин, що мають довжини 50, 10 та 30. Ми назвемо цей один розділ. Тож дорожню систему, яку ми використовуємо для цього прикладу, можна легко представити у вигляді чотирьох секцій: (50, 10, 30), (5, 90, 20), (40, 2, 25) та (10, 8, 0).</p></div>
<div class="paragraph"><p>Завжди добре зберігати наші типи даних максимально простими, хоча не простіше!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Section</span> <span class="ow">=</span> <span class="kt">Section</span> <span class="p">{</span> <span class="n">getA</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">getB</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span> <span class="n">getC</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">RoadSystem</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Section</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це майже ідеально! Це так просто, як на мене, і я маю відчуття, що це буде ідеально працювати для втілення нашого рішення. <code>Section</code> - простий алгебраїчний тип даних, який містить три цілі числа на довжину трьох його дорожніх частин. Ми також вводимо синонім типу, кажучи, що <code>RoadSystem</code> - це список розділів.</p></div>
<div class="paragraph"><p>Ми також могли б використати трійку <code>(Int, Int, Int)</code>, щоб представити ділянку дороги. Використання кортежів замість створення власних алгебраїчних типів даних добре для деяких невеликих локалізованих речей, але зазвичай краще  цього створити новий тип. Це дає типовій системі більше інформації про те, що робити. Ми можемо використовувати <code>(Int, Int, Int)</code> для відображення ділянки дороги або вектора в тривимірному просторі, і ми можемо оперувати цими двома, але це дозволяє нам їх змішати. Якщо ми використовуємо типи даних <code>Section</code> та <code>Vector</code>, ми не можемо випадково додати вектор до ділянки дорожньої системи.</p></div>
<div class="paragraph"><p>Нашу дорожню систему від Хітроу до Лондона тепер можна представити так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">heathrowToLondon</span> <span class="ow">::</span> <span class="kt">RoadSystem</span>
<span class="nf">heathrowToLondon</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Section</span> <span class="mi">50</span> <span class="mi">10</span> <span class="mi">30</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">5</span> <span class="mi">90</span> <span class="mi">20</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">40</span> <span class="mi">2</span> <span class="mi">25</span><span class="p">,</span> <span class="kt">Section</span> <span class="mi">10</span> <span class="mi">8</span> <span class="mi">0</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Все, що нам зараз потрібно зробити - це реалізувати рішення, яке ми придумали раніше в Haskell. Яким має бути оголошення типу для функції, яка обчислює найкоротший шлях для будь-якої дорожньої системи? Він повинен приймати дорожню систему як параметр і повертати шлях. Ми також будемо представляти шлях як список. Давайте введемо тип <code>Label</code>, який є лише перерахуванням або <code>A</code>, <code>B</code> або <code>C</code>. Ми також зробимо синонім типу: <code>Path</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Label</span> <span class="ow">=</span> <span class="kt">A</span> <span class="o">|</span> <span class="kt">B</span> <span class="o">|</span> <span class="kt">C</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">type</span> <span class="kt">Path</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Label</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, наша функція, яку ми називаємо <code>optimalPath</code>, повинна мати типове оголошення <code>optimalPath ::RoadSystem -&gt; Path</code>. Якщо викликається з дорожньою системою <code>heathrowToLondon</code>, вона повинна повернути такий шлях:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">A</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">8</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам доведеться переглядати список з розділами зліва направо і дотримуватись оптимального шляху на A та оптимального шляху на B під час руху. Ми накопичуємо найкращий шлях, коли ми будемо проходити по списку, зліва направо. Як це звучить? Дінь, дінь, дінь! Правильно, ЛІВА ЗГОРТКА!</p></div>
<div class="paragraph"><p>Роблячи рішення вручну, був крок, який ми повторювали знову і знову. Він включав перевірку поточних оптимальних шляхів на A і B, і поточний розділ для створення нових оптимальних шляхів на A і B. Наприклад, на початку оптимальними шляхами були <code>[]</code> і <code>[]</code> для A і B відповідно. Ми розглянули розділ <code>Section 50 10 30</code> і дійшли висновку, що новий оптимальний шлях до А1 є <code>[(B, 10), (C, 30)]</code>, а оптимальний шлях до B1 - <code>[(B, 10)]</code>. Якщо ви дивитесь на цей крок як на функцію, вона приймає пару шляхів та ділянку, та створює нову пару шляхів. Тип - <code>(Path, Path) -&gt; Section -&gt; (Path, Path)</code>. Давайте підемо далі та реалізовуватимемо цю функцію, бо вона обов'язково буде корисною.</p></div>
<div class="paragraph"><p>Підказка: це буде корисно, оскільки <code>(Path, Path) -&gt; Section -&gt; (Path, Path)</code> можна використовувати як бінарну функцію для лівої згортки, яка повинна мати тип <code>a -&gt; b -&gt; a</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">roadStep</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Path</span><span class="p">,</span> <span class="kt">Path</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Section</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Path</span><span class="p">,</span> <span class="kt">Path</span><span class="p">)</span>
<span class="nf">roadStep</span> <span class="p">(</span><span class="n">pathA</span><span class="p">,</span> <span class="n">pathB</span><span class="p">)</span> <span class="p">(</span><span class="kt">Section</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">priceA</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">pathA</span>
        <span class="n">priceB</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">pathB</span>
        <span class="n">forwardPriceToA</span> <span class="ow">=</span> <span class="n">priceA</span> <span class="o">+</span> <span class="n">a</span>
        <span class="n">crossPriceToA</span> <span class="ow">=</span> <span class="n">priceB</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">forwardPriceToB</span> <span class="ow">=</span> <span class="n">priceB</span> <span class="o">+</span> <span class="n">b</span>
        <span class="n">crossPriceToB</span> <span class="ow">=</span> <span class="n">priceA</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span>
        <span class="n">newPathToA</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">forwardPriceToA</span> <span class="o">&lt;=</span> <span class="n">crossPriceToA</span>
                        <span class="kr">then</span> <span class="p">(</span><span class="kt">A</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="kt">:</span><span class="n">pathA</span>
                        <span class="kr">else</span> <span class="p">(</span><span class="kt">C</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="kt">B</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="kt">:</span><span class="n">pathB</span>
        <span class="n">newPathToB</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">forwardPriceToB</span> <span class="o">&lt;=</span> <span class="n">crossPriceToB</span>
                        <span class="kr">then</span> <span class="p">(</span><span class="kt">B</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="kt">:</span><span class="n">pathB</span>
                        <span class="kr">else</span> <span class="p">(</span><span class="kt">C</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="kt">:</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="kt">:</span><span class="n">pathA</span>
    <span class="kr">in</span>  <span class="p">(</span><span class="n">newPathToA</span><span class="p">,</span> <span class="n">newPathToB</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/guycar.png" alt="images/guycar.png" />
</span>
Що тут відбувається? Спочатку обчислюємо оптимальну ціну на дорозі A на основі найкращої на даний момент на A і зробимо те саме для B. Ми зробимо <code>sum $ map snd pathA</code>, тож якщо <code>pathA</code> є чимось на зразок <code>[(A, 100), (C, 20 )]</code>, <code>priceA</code> стає <code>120</code>. <code>forwardPriceToA</code> - це ціна, яку ми заплатимо, якби ми перейшли до наступного перехрестя на A, якби ми їхали туди безпосередньо з попереднього перехрестя на A. Це дорівнює найкращій ціні нашої попередньої A плюс довжина поточного розділу. <code>crossPriceToA</code> - це ціна, яку ми заплатимо, якби ми перейшли до наступного A, рухаючись вперед від попереднього B, а потім перетинаючи. Це найкраща ціна попереднього B досі плюс довжина B секції плюс C довжина секції. Ми визначаємо <code>forwardPriceToB</code> та <code>crossPriceToB</code> подібним чином.</p></div>
<div class="paragraph"><p>Тепер, коли ми знаємо, що найкращий шлях до A і B, нам просто потрібно зробити нові шляхи до A і B на основі цього. Якщо дешевше перейти до A, просто йдучи вперед, ми встановимо <code>newPathToA</code>, щоб бути <code>(A, a): pathA</code>. В основному ми ставимо мітку <code>Label A</code> і довжину відрізка <code>a</code> до оптимального шляху шляху A на даний момент. В основному, ми говоримо, що найкращий шлях до наступного перехрестя A - це шлях до попереднього перехрестя A, а потім один відрізок вперед по A. Пам'ятайте, A - це лише мітка, тоді як <code>a</code> має тип <code>Int</code>. Чому ми ставимо наперед замість того, щоб робити <code>pathA ++ [(A, a)]</code>? Добре, додавання елемента до початку списку (також відомого як <em>консинг</em>) набагато швидше, ніж додавання його в кінець. Це означає, що шлях буде невірним, коли ми складемо список із цією функцією, але просто обернути список пізніше. Якщо дешевше дістатися до наступного перехрестя А, рухаючись вперед від дороги В і потім перетинаючи, то <code>newPathToA</code> - це стара дорога до В, яка потім йде вперед і переходить на A. Ми робимо те ж саме для <code>newPathToB</code>, тільки все дзеркально відображено.</p></div>
<div class="paragraph"><p>Нарешті, ми повертаємо <code>newPathToA</code> та <code>newPathToB</code> в парі.</p></div>
<div class="paragraph"><p>Давайте запустимо цю функцію на першому розділі <code>heathrowToLondon</code>. Оскільки це перший розділ, найкращими шляхами для параметра A і B буде пара порожніх списків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">roadStep</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span> <span class="kt">[]</span><span class="p">)</span> <span class="p">(</span><span class="n">head</span> <span class="n">heathrowToLondon</span><span class="p">)</span>
<span class="p">([(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">)],[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">)])</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам’ятайте, шляхи зворотні, тому читайте їх справа наліво. З цього ми можемо прочитати, що найкращий шлях до наступного A - це починати на B, а потім переходити на A і що найкращий шлях до наступного B - це просто йти прямо вперед від початкової точки на B.</p></div>
<div class="paragraph"><p>Порада з оптимізації: коли ми робимо <code>priceA = sum $ map snd pathA</code>, ми обчислюємо ціну з шляху на кожному кроці. Нам би цього не довелося робити, якби ми реалізували <code>roadStep</code> як функцію <code>(Path, Path, Int, Int) -&gt; Section -&gt; (Path, Path, Int, Int)</code>, де цілі числа представляють найкращу ціну на A і B.
Тепер, коли у нас є функція, яка приймає пару шляхів і розділ і створює новий оптимальний шлях, ми можемо просто і легко виконати ліву згортку над списком розділів. <code>roadStep</code> викликається з <code>([], [])</code> і першим розділом і повертає пару оптимальних шляхів до цього розділу. Потім він визивається з цією парою шляхів і наступним розділом тощо. Коли ми пройшли всі розділи, нам залишається пара оптимальних шляхів, і коротший з них - наша відповідь. Маючи це на увазі, ми можемо реалізувати <code>optimalPath</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">optimalPath</span> <span class="ow">::</span> <span class="kt">RoadSystem</span> <span class="ow">-&gt;</span> <span class="kt">Path</span>
<span class="nf">optimalPath</span> <span class="n">roadSystem</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="p">(</span><span class="n">bestAPath</span><span class="p">,</span> <span class="n">bestBPath</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="n">roadStep</span> <span class="p">(</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">)</span> <span class="n">roadSystem</span>
    <span class="kr">in</span>  <span class="kr">if</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">snd</span> <span class="n">bestAPath</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">snd</span> <span class="n">bestBPath</span><span class="p">)</span>
            <span class="kr">then</span> <span class="n">reverse</span> <span class="n">bestAPath</span>
            <span class="kr">else</span> <span class="n">reverse</span> <span class="n">bestBPath</span>
</pre></div></div></div>
<div class="paragraph"><p>We left fold over roadSystem (remember, it&#8217;s a list of sections) with the starting accumulator being a pair of empty paths. The result of that fold is a pair of paths, so we pattern match on the pair to get the paths themselves. Then, we check which one of these was cheaper and return it. Before returning it, we also reverse it, because the optimal paths so far were reversed due to us choosing consing over appending.
Ми виконали згортку по <code>roadSystem</code> (пам'ятайте, це список розділів), при цьому початковим акумулятором є пара порожніх шляхів. Результатом цієї згортки є пара шляхів, тому ми робимо співпадіння шаблонів для отримання самих шляхів. Потім ми перевіряємо, який з них був дешевшим, і повертаємо його. Перш ніж повернути ми також обертаємо його, тому що оптимальні шляхи до цього часу були обернені через те, що ми обирали <code>cons</code>-інг над додаванням.</p></div>
<div class="paragraph"><p>Давайте перевіримо це!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">optimalPath</span> <span class="n">heathrowToLondon</span>
<span class="p">[(</span><span class="kt">B</span><span class="p">,</span><span class="mi">10</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">30</span><span class="p">),(</span><span class="kt">A</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">20</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="kt">B</span><span class="p">,</span><span class="mi">8</span><span class="p">),(</span><span class="kt">C</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це результат, який ми мали отримати! Дивовижно! Він трохи відрізняється від нашого очікуваного результату тим, що в кінці є крок <code>(C, 0)</code>, що означає, що ми переходимо на іншу дорогу, коли ми перебуваємо в Лондоні, але тому що цей переїзд нічого не коштує, це все-таки правильний результат.</p></div>
<div class="paragraph"><p>У нас є функція, яка знаходить оптимальний шлях на основі, тепер нам просто потрібно прочитати текстове подання дорожньої системи зі стандартного вводу, перетворити її у тип <code>RoadSystem</code>, виконати її через нашу функцію <code>optimalPath</code> і надрукувати шлях.</p></div>
<div class="paragraph"><p>Спочатку давайте зробимо функцію, яка бере список і розбиває його на групи однакового розміру. Ми назовемо її <code>groupsOf</code>. Для параметра <code>[1..10]</code> <code>groupsOf 3</code> має повернути <code>[[1,2,3], [4,5,6], [7,8,9], [10]]</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">groupsOf</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[[</span><span class="n">a</span><span class="p">]]</span>
<span class="nf">groupsOf</span> <span class="mi">0</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">undefined</span>
<span class="nf">groupsOf</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">groupsOf</span> <span class="n">n</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">take</span> <span class="n">n</span> <span class="n">xs</span> <span class="kt">:</span> <span class="n">groupsOf</span> <span class="n">n</span> <span class="p">(</span><span class="n">drop</span> <span class="n">n</span> <span class="n">xs</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Стандартна рекурсивна функція. Для <code>xs [1..10]</code> та <code>n 3</code> це дорівнює <code>[1,2,3] : groupsOf 3 [4,5,6,7,8,9,10]</code>. Коли рекурсія виконана, ми отримуємо наш список у три групи. Ось наша основна функція, яка читає зі стандартного вводу, робить <code>RoadSystem</code> з нього і виводить найкоротший шлях:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">contents</span> <span class="ow">&lt;-</span> <span class="n">getContents</span>
    <span class="kr">let</span> <span class="n">threes</span> <span class="ow">=</span> <span class="n">groupsOf</span> <span class="mi">3</span> <span class="p">(</span><span class="n">map</span> <span class="n">read</span> <span class="o">$</span> <span class="n">lines</span> <span class="n">contents</span><span class="p">)</span>
        <span class="n">roadSystem</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Section</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span><span class="p">)</span> <span class="n">threes</span>
        <span class="n">path</span> <span class="ow">=</span> <span class="n">optimalPath</span> <span class="n">roadSystem</span>
        <span class="n">pathString</span> <span class="ow">=</span> <span class="n">concat</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="n">show</span> <span class="o">.</span> <span class="n">fst</span><span class="p">)</span> <span class="n">path</span>
        <span class="n">pathPrice</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">map</span> <span class="n">snd</span> <span class="n">path</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The best path to take is: &quot;</span> <span class="o">++</span> <span class="n">pathString</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The price is: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">pathPrice</span>
</pre></div></div></div>
<div class="paragraph"><p>Спочатку ми отримуємо весь вміст зі стандартного вводу. Потім ми визиваємо <code>lines</code> з нашим вмістом, щоб перетворити щось на кшталт <code>"50\n10\n30\n</code> &#8230; в <code>["50","10","30"..</code>, а потім ми перечитуємо прочитане, щоб перетворити його в список чисел. Ми визиваємо <code>groupsOf 3</code> на ньому, щоб перетворити його на список списків довжиною 3. Ми відображаємо лямбда <code>(\[a, b, c] -&gt; Section a b c)</code> над цим списком списків. Як ви можете бачити, лямбда просто бере список довжиною 3 і перетворює його на розділ. Отже, <code>roadSystem</code> є нашою системою доріг і навіть має правильний тип, а саме <code>RoadSystem</code> (або <code>[Section]</code>). Ми визиваємо <code>OptimPath</code> з ним і потім отримуємо шлях і ціну в приємному текстовому вигляді та друкує його.</p></div>
<div class="paragraph"><p>Ми зберігаємо наступний текст</p></div>
<div class="listingblock">
<div class="content">
<pre><code>50
10
30
5
90
20
40
2
25
10
8
0</code></pre>
</div></div>
<div class="paragraph"><p>у файлі під назвою <em>paths.txt</em>, а потім подаємо його до нашої програми.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ cat paths.txt | runhaskell heathrow.hs
The best path to take is: BCACBBC
The price is: 75</code></pre>
</div></div>
<div class="paragraph"><p>Працює чудово! Ви можете використовувати свої знання модуля <code>Data.Random</code>, щоб створити набагато довшу систему доріг, яку ви зможете подати до того, що ми написали. Якщо у вас є переповнення стека, спробуйте використовувати <code>foldl'</code> замість <code>foldl</code>, оскільки <code>foldl'</code> є суворим.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-18 02:23:30 EET
</div>
</div>
</body>
</html>
