<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Ввод та вивод</h2>
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="images/dognap.png" alt="images/dognap.png" />
</span>
Ми вже казали, що Haskell є чисто функціональною мовою. В той час, коли в імперативних мовах ви зазвичай отримуєте речі надаючи копм'ютеру серії кроків для виконання, функціональне програмування більше щодо визначення того, чим є речі. В Haskell функція не може змінити деякий стан, як змінити вміст змінної (коли функція змінює стан ми кажемо, що функція має побічні ефекти). Єдина річ, яку може робити функція в Haskell, це дати нам деякий результат на основі параметрів, які ми надаємо їй. Якщо функція викликається два рази з тими самими параметрами, вона має повертати той самий результат. Хоча це може виглядати дещо обмежувальним, якщо ви прийшли з імперативного світу, ми бачили, що насправді це круто. В імперативній мові ви не маєте гарантії, що проста функція, що має лише пожонглювати деякими числами, не спалить вашу хату, не викраде вашого пса і не пошкрябає вашу машину помідором, при маніпуляції ціма числами. Наприклад, коли ви шукаєте в двійниковому дереві, ми не вставляли елемент в дерево, модифікуючи дерево на місці. Наша функція для вставки в двійникове дерево насправді повертає нове дерево, бо воно не може змінити старе дерево.</p></div>
<div class="paragraph"><p>Хоча функції, що не можуть змінювати стан, є гарним, бо дозволяє нам промислювати наші програми, з цім є одна проблема. Якщо функція не може зробити дещо в світі, як вона зможе повідомити нам, що вона нарахувала? Щоб сказати нам, що обчислено, вона має змінити стан вихідного пристрою (звичайно стан екрану), що потім виділяє фотони, які подорожують до нашого мозку, та змінюють стан наших думок, чоловіче.</p></div>
<div class="paragraph"><p>Не втрачайте надію, не все втрачено. З'ясовується, що насправді Haskell має дійсно розумну систему для справ з функціями, що мають побічні ефекти, яка мило відокремлює частину програми, що є чистою, та частину що є нечистою і робить всю брудну роботу, як розмови з клавіатурою та екраном. Маючи ці дві частини розділеними ми все ще можемо промислювати нашу чисту програму і отримувати переваги від всіх речей, що надає чистота, як лінивість, надійність та модульність, при цьому ефективно комунікуючи з зовнішним світом.</p></div>
<div class="sect2">
<h3 id="_hello_world">Hello, world!</h3>
<div class="paragraph"><p><span class="image">
<img src="images/helloworld.png" alt="images/helloworld.png" />
</span>
До цього часу ми завжди завантажували наші функції в GHCI для їх тестування та забавок з ними. Ми також дослідили функції стандартної бібліотеки, проміж справ. Але тепер, після восьми або десь так глав, ми нарешті збираємось написати нашу першу справжню програму Haskell! Вау! І будьте впевнені, що ми збираємось зробити стару добру штуку "hello, world".</p></div>
<div class="paragraph"><p>Хей! Для цілей цієї глави я буду вважати, що ми використовуємо  unix-подібне середовище для вивчення Haskell. Якщо ви в Windows, я б порадив завантажити Cygwin, що є Linux-подібне оточення для Windows, тобто те що нам треба.</p></div>
<div class="paragraph"><p>І так, для початку, забийте наступне в вашому улюбленому текстовому редакторі:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми тільки що визначили ім'я <code>main</code>, і в ньому ми викликаємо функцію з назвою <code>putStrLn</code> з параметром <code>"hello, world"</code>. Виглядає як робота млина, але ні, ми побачимо це через мить. Збережіть це в файлі <code>helloworld.hs</code>.</p></div>
<div class="paragraph"><p>Але зараз ми збираємось зробити дещо, чого не робили досі. Насправді ми збираємось скомпілювати нашу програму! Я в захопленні! Відкрийте ваш термінал і перейдіть в каталог, де розміщений <code>helloworld.hs</code>, та виконайте таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Okay! With any luck, you got something like this and now you can run your program by doing ./helloworld.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І ось де ми є, наша перша скомпільована програма, що друкує дещо на терміналі. Неймовірно нудно!</p></div>
<div class="paragraph"><p>Давайте перевіримо, що ми написали. Спочатку давайте подивимось на тип функції <code>putStrLn</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми можемо прочитати тип <code>putStrLn</code> таким чином: <code>putStrLn</code> бере рядок та повертає I/O дію, що має тип результата <code>()</code> (тобто порожній тапл, також відомий як юніт). I/O дія є дещо, що коли виконується буде нести дію з побічним ефектом (це зазвичай або читання з входу або друкування дечого на екрані), і буде також містити деякий різновид значення повернення в собі. Друкування рядка на термінал насправді не має жодного осмисленого типу повернення, так що використовується фіктивне значення <code>()</code>.</p></div>
<div class="paragraph"><p>Порожній типл є значенням <code>()</code>, і він має також тип <code>()</code>.</p></div>
<div class="paragraph"><p>То коли буде виконана I/O дія? Гаразд, ось де з'являється <code>main</code>. I/O дія буде виконана коли ми дамо їй ім'я <code>main</code>, і потім виконаємо програму.</p></div>
<div class="paragraph"><p>Маючи всю вашу програму тільки в вигляді однієї I/O дії виглядає дещо обмежувальним. Ось чому ми можемо використовувати синтаксис <code>do</code> для зклеювання разом декількох I/O дій в одну. Погляньте на наступний приклад:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>А, цікаво, новий синтаксис! І це читається майже так само як імперативна програма. Якщо ви скомпілюєте це і спробуєте в дії, це буде поводитись так само, як ми цього очікуємо. Зауважте, що ми тільки но сказали <code>do</code> і потім поклали серію кроків, як би ми зробили в імперативній програмі. Кожний з ціх кроків є I/O дією. Збираючи їх докупи за допомогою синтаксису <code>do</code>, ми зліпили їх в одну I/O дію. Дія, яку ми отримали, має тип <code>IO ()</code>, оскільки це тип останньої I/O дії всередині.</p></div>
<div class="paragraph"><p>Через це <code>main</code> завжди має сигнатуру типу <code>main ::IO something</code>, де <code>something</code> є деякий конкретний тип. За домовленістю ми звичайно не вказуємо декларацію типу для <code>main</code>.</p></div>
<div class="paragraph"><p>Цікава річ, з якою ми досі не зустрічались, це третій рядок, що вказує <code>name &lt;- getLine</code>. Виглядає що воно читає рядок з входу, та зберігає його в змінній на ім'я <code>name</code>. Чи так насправді? Гаразд, давайте перевіримо тип <code>getLine</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/luggage.png" alt="images/luggage.png" />
</span>
Так, це є. <code>getLine</code> є I/O дією, що містить тип результату <code>String</code>. Це має сенс, оскільки це буде очікувати користувача, докі він введе дещо в терміналі, і потім це дещо буде представлене як рядок. То що відбувається в <code>name &lt;- getLine</code>? Ви можете читати цей шматок коду таким чином: виконати I/O дію <code>getLine</code>, та потім прив'язати значення результату до <code>name</code>. <code>getLine</code> має тип <code>IO String</code>, так що <code>name</code> буде мати тип <code>String</code>. Ви можете думати про I/O дію як бокс на маленьких ніжках, що виходитиме в реальний світ і робитиме там дещо (як малювати графіті на стінах), або приносити назад деякі дані. Коли ці дані були підтягрутя до вас, єдиним способом відкрити бокс і отримати дані всередині є використання конструкції <code>&lt;-</code>. І коли ми беремо дані з I/O дії, ми можемо дістати їх лише коли ми всередині іншої I/O. Ось як діє Haskell для гарного поділу кода на чисту і нечисту частину. <code>getLine</code> в деякому сенсі є нечистим, бо його значення результату не буде гарантовано тим самим, якщо його виконати двічі. Ось чому він дещо заплямований конструктором типу IO, і ми можемо отримати ці дані лише від I/O коду. І оскільки I/O код також заплямований, любі обчислення, що залежать від заплямованих I/O даних, будуть мати заплямований результат.</p></div>
<div class="paragraph"><p>Коли я кажу заплямований, я не маю на увазі це в такий спосіб, що ми ніколи не зможемо використовувати результат в I/O дії, будь-коли в чистому коді. Ні, ми тимчасово роз-плямовуємо дані в I/O дії, коли ми прикріплюємо її до <code>name</code>. Коли ми робимо <code>name &lt;- getLine</code>, <code>name</code> є просто звичайний рядок, оскільки він представляє те, що знаходиться в боксі. Ми можемо мати дійсно складну функцію, що скажімо бере ваше ім'я (звичайний рядок) як параметр, і каже вам всю вашу вдачу і майбутнє всього вашого життя, базуючись на вашому імені. Ми можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>і <code>tellFortune</code> (або жодна функція, куди вона передає <code>name</code>) не має знати нічого про I/O, це просто нормальна функція <code>String -&gt; String</code>!</p></div>
<div class="paragraph"><p>Подивіться на цей шматок коду, чи він валідний?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ви відповіли ні - пійдіть з'їжте періжок. Якщо ви сказали так - випийте ковшик розпеченої лави. Я пошуткував, не робіть цього! Причина, з якої це не робить, в тому, що <code>++</code> потребує обоє свої параметри як спискаи того самого типу. Лівий параметр має тип <code>String</code> (або <code>[Char]</code> якщо бажаєте), тоді як <code>getLine</code> має тип <code>IO String</code>. Ви не можете приєднати рядок та I/O дію. Спочатку ми маємо отримати результат від I/O дії, щоб отримати тип <code>String</code>, і це єдиний спосіб зробити це в тому, щоб сказати щось як <code>name &lt;- getLine</code> всередині іншої I/O дії. Якщо ми бажаємо мати справу з нечистими даними, ми маємо робити це в нечистому оточенні. Так що прокляття нечистості розповсюджується навкруги як бич нечесті, так що в наших кращих інтересах утримувати I/O частини коду такими малими, як це можливо.</p></div>
<div class="paragraph"><p>Кожна I/O дія, що виконується, має заточений в собі результат. Ось чому наш попередній приклад програми може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак <code>foo</code> буде мати лише значення <code>()</code>, так що робити таке буде лише  різновидом балачок. Зауважте, що ми не прив'язали останній <code>putStrLn</code> до будь-чого. Це через те, що в блоці <code>do</code> остання дія не може бути прив'язана до імені, як це було з першими двома. Ми побачимо чому це так трохи пізніше, коли ми поринемо в світ монад. Зараз ви можете думати про це в спосіб, що блок <code>do</code> автоматично виділяє значення з останньої дії, і прикріпляє його до свого власного результату.</p></div>
<div class="paragraph"><p>За винятком цього останнього рядка, кожний рядок, що не прикріплений, може бути записаний як прикріплення. Так що <code>putStrLn "BLAH"</code> може бути записане як <code>_ &lt;- putStrLn "BLAH"</code>. Але це не має користі, так що ми не будемо використовувати <code>&lt;-</code> для I/O дій, що не мають корисних результатів, як <code>putStrLn something</code>.</p></div>
<div class="paragraph"><p>Початківці іноді думають, що роблячи</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>буде читати з входу, та потім прикріпляти значення до <code>name</code>. Гаразд, так не буде, все що тут робиться це надання дії <code>getLine</code> іншого імені, а саме <code>name</code>. Пам'ятайте, щоб отримати значення від I/O дії, ми маємо виконати її в середині іншої I/O дії, через прикріплення її до імені за допомогою <code>&lt;-</code>.</p></div>
<div class="paragraph"><p>I/O дії будуть виконані лише тоді, якщо їм надано ім'я <code>main</code>, або коли вони всередині більшої I/O дії, що компонується за допомогою блоку <code>do</code>. Ми також можемо використати блок <code>do</code> для склеювання разом декількох I/O дій, і потім ми можемо використовувати цю I/O дію в іншому <code>do</code> блоці, і так далі. З іншого боку, всі вони будуть виконані тільки якщо вони з часом дійдуть до <code>main</code>.</p></div>
<div class="paragraph"><p>О, гаразд, існує ще один випадок, коли будуть виконані I/O дії. Коли ми набираємо I/O дію в GHCI та натискаємо <code>return</code>, це також буде виконане.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Хоч коли ми вводимо число або викликаємо функцію в GHCI і натискаємо <code>return</code>, це буде обчислене (здебільшого як це нам і треба), і потім викликає <code>show</code> на цьому, і потім це друкує рядок на терміналі, неявно викликаючи <code>putStrLn</code>.</p></div>
<div class="paragraph"><p>Пам'ятаєте прикріплення <code>let</code>? Якщо ні, оновіть вашу пам'ять щодо них в цьому розділі. Вони мають бути в формі <code>let</code> прикріплень в виразах, де прикріалення є іменами що будуть надані виразам, та вираз є вираз, що буде обчислений коли хтось бачить його. Ми також бачили його в осяжностях списків, де частина <code>in</code> непотрібна. Гаразд, ви можете використовувати їх в <code>do</code> блоках, майже так само, як ми використовуємо їх в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Бачите, як підрівняні I/O дії в блоці <code>do</code>? Також зауважте, як <code>let</code> вирівняне разом з I/O діями і іменами <code>let</code>, вирівняними один з одним? Це гарна практика, бо відступи важливі в Haskell. Тепер: ми зробили <code>toUpper firstName</code>, що перетворює якесь <code>"John"</code> в значно крутіший рядок як <code>"JOHN"</code>. Ми прикріплюємо цей збільшений рядок до <code>name</code>, та потім використовуємо його в рядку нижче, коли друкуємо на термінал.</p></div>
<div class="paragraph"><p>Ви можете поцікавитись, коли використавувати <code>&lt;-</code>, та коли використовувати прикріплення <code>let</code>? Гаразд, пам'ятайте, що <code>&lt;-</code> є (поки що) для виконання I/O дій та прикріплення їх результатів до імен. Однак <code>map toUpper firstName</code> не є I/O дією. Це чистий вираз в Haskell. Так що використовуйте <code>&lt;-</code>, коли ви бажаєте прикріпити результати I/O дій до імен, і ви можете використовувати <code>let</code> для прикріалень чистих виразів до імен. Так що коли ми робимо дещо як <code>let firstName = getLine</code>, ми отримаємо лише нове ім'я для I/O дії <code>getLine</code>, і ми все ще маємо запустити її через <code>&lt;-</code>, щоб вона виконалась.</p></div>
<div class="paragraph"><p>Тепер ми збираємось зробити програму, що постійно читає рядок і друкує той самий рядок зі словами в зворотньому порядку. Виконання програми буде припинено, коли ми введемо порожній рядок. Ось програма:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Щоб отримати відчуття того, що вона робить, ви можете виконати її перед тим, як ми пройдемось по коду.</p></div>
<div class="paragraph"><p>Protip: Щоб виконати програму ви можете або скомпілювати її, та потім виконати отримий виконавчий файл, роблячи <code>ghc --make helloworld</code> та потім <code>./helloworld</code>, або ви можете використовувати команду <code>runhaskell</code> ось так: <code>runhaskell helloworld.hs</code> і ваша програма буде виконана на льоту.</p></div>
<div class="paragraph"><p>Спочатку давайте поглянемо на функцію <code>reverseWords</code>. Це тільки звичайна функція, що приймає рядок як <code>"hey there man"</code>, та потім викликає <code>words</code> для продукування списку слів як <code>["hey","there","man"]</code>. Потім ми <code>map reverse</code> на списку, отримуючи <code>["yeh","ereht","nam"]</code>, і потім ми знову покладаємо все це в один рядок, використовуючи <code>unwords</code>, і фінальний результат буде <code>"yeh ereht nam"</code>. Дивітья, як ми використовували композицію функцій. Без композиції функцій ми б мали написати щось як <code>reverseWords st = unwords (map reverse (words st))</code>.</p></div>
<div class="paragraph"><p>Що відносно <code>main</code>? Спершу ми отримуємо рядок з термінала, виконуючи виклик <code>getLine</code> що повертається в <code>line</code>. І тепер ми маємо условний вираз. Пам'ятайте, що в Haskell кожний <code>if</code> повинен мати відповідний <code>else</code>, оскільки кожний вираз повинен мати деякий різновид значення. Ми робимо <code>if</code>, так що коли умова <code>true</code> (в нашому випадку введений нами рядок порожній), ми виконуємо одну I/O дію, та коли ні - буде виконана інша I/O дія для <code>else</code>. Ось чому в блоці <code>I/O do</code>, <code>if</code> повинні мати форму <code>if умова then I/O дія else I/O дія</code>.</p></div>
<div class="paragraph"><p>Давайте спочатку поглянемо на те, що відбувається в частині <code>else</code>. Оскільки ми повинні мати саме одну I/O дію після <code>else</code>, ми використовуємо блок <code>do</code> для склеювання разом двох I/O дій в одну. Ви також можете записати цю частину таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це робить більш наочним, що блок <code>do</code> має розгядатись як одна I/O дія, але це огидніше. В любому разі в блоці <code>do</code> ми викликаємо  <code>reverseWords</code> на рядку, що ми отрумуємо від <code>getLine</code>, та потім друкуємо це на терміналі. Після цього ми просто виконуємо <code>main</code>. Вона виключається рекурсивно і це гаразд, оскільки <code>main</code> сама є I/O дією. Так що в деякому сенсі ми повертаємось на початок програми.</p></div>
<div class="paragraph"><p>Тепер, що трапляється коли <code>null line</code> стає <code>true</code>? Це те, що в данному випадку виконується після <code>then</code>. Якщо ми подивимось, ми побачимо що виконується <code>then return ()</code>. Якщо ви візьмете імперативні мови, як C, Java або Python, ви можливо думаєте, що знаєте що робить цей <code>return</code>, так що є шанси, що ви перестрибнули цей доволі довгий параграф. Гаразд, ось як вам таке: <code>return</code> в Haskell насправді нічого подібного до <code>return</code> в більшості мов! Воно має те саме ім'я, що бентежить багато людей, але в реальності це досить інше. В імперативних мовах <code>return</code> звичайно закінчує виконання метода або процедури, і повідомляє про це деяким разновидом значення до викликаючої сторони. В Haskell (точніше в I/O діях), це виробляє I/O дію з чистого значення. Якщо ви подумаєте про аналогію бокса з попередніх розділів, це приймає значення і огортає його в бокс. Отримана I/O дія насправді нічого не робить, це просто це значення, оточене як його результат. Так що в контексті I/O <code>return "haha"</code> буде мати тип <code>IO String</code>. Який сенс в простому перетворенні чистого значення в I/O дію, що нічого не робить? Навіщо заплямовувати нашу програму в IO більше, ніж це мало би бути? Гаразд, нам треба деяка I/O дія, що треба видати в випадку порожнього вхідного рядка. Ось чому ми просто створили фіктивну I/O дію, дію що нічого не робить, написавши <code>return ()</code>.</p></div>
<div class="paragraph"><p>Використання <code>return</code> не спричиняє закінчення блоку <code>I/O do</code> в плані виконання, або будь чого подібного. Наприклад, ця програма буде досить щасливо продовжуватись весь час до останнього рядка:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Всі ці <code>return</code> роблять те, що вони створюють I/O дії, що насправді нічого не роблять, крім інкапсуляції результату, і цей результат відкидається геть, оскільки він не прив'язаний до імені. Ми можемо використовувати <code>return</code> в комбінації з <code>&lt;-</code> для прив'язки речей до імен.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви бачите, <code>return</code> є різновидом протилежності до <code>&lt;-</code>. Тоді як  <code>return</code> бере значення і огортає його в бокс, <code>&lt;-</code> бере бокс (та виконує його), та отримує з нього значення, прикріплюючи його до імені. Але робити це є дещо надлишковим, особливо коли ви можете використовувати <code>let</code> прикріпленнях в <code>do</code> блоках до імен, десь так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли маємо справу з блоками <code>I/O do</code>, ми в основному використовуємо <code>return</code> оба тому що нам треба створити I/O дію, що не робить нічого, або якщо ми не бажаємо, щоб I/O дія, створена з <code>do</code> блока, мала значення результата в своїй останній дії, але ми бажаємо, щоб він мав інше значення результата, так що ми використовуємо <code>return</code> для створення I/O дії, що завжди має заточеним наш бажаний результат, і ми покладаємо його в кінці.</p></div>
<div class="paragraph"><p>Блок <code>do</code> також може мати лише одну I/O дію. В цьому випадку це те саме, що просто записати I/O дію. Деякі люди можуть обрати запис <code>then do return ()</code> в цьому випадку, оскільки <code>else</code> також має <code>do</code>.</p></div>
<div class="paragraph"><p>Оскільки ми просуваємось до файлів, давайте поглянемо на деякі функції, що будуть корисні при справах з I/O.</p></div>
<div class="paragraph"><p><code>putStr</code> здебільшого як <code>putStrLn</code> в тому, що він бере рядок як параметр і повертає I/O дію, що буде друкувати цей рядок на терміналі, тільки <code>putStr</code> не перестрибує на новий рядок після друкування рядка, тоді як <code>putStrLn</code> робить це.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Її сигнатура типу є `putStr 
</dt>
<dd>
<p>
String &#8594; IO () `, так що результат заточений в результуючій I/O дії є юніт. Дурне значення, так що немає сенсу прикріплювати його.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>putChar</code> бере символ та повертає I/O дію, що буде роздруковувати його на термінал.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>putStr</code> насправді визначена рекурсивно за допомогою <code>putChar</code>. Гранична умова <code>putStr</code> є порожній рядок, так що якщо ми друкуємо порожній рядок, просто повертаємо I/O дію, що нічого не робить, використовуючи <code>return ()</code>. Якщо він не порожній, тоді друкуємо перший символ рядка, роблячи <code>putChar</code>, і потім друкуємо всі інші з використанням <code>putStr</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Дивіться, як ми можемо використовувати рекурсію в I/O, так само як ми можемо робити це в чистому коді. Так само як в чистому коді, ми визначаємо граничний випадок, і потім думаємо, чим насправді є результат. Це дія, що спочатку виводить перший символ, і потім виводить залишок рядка.</p></div>
<div class="paragraph"><p><code>print</code> бере значення любого типу, що є примірником <code>Show</code> (що означає, що ми знаємо як представляти його як рядок), викликає <code>show</code> з цім значенням для перетворення на рядок, і потім виводить цей рядок на термінал. В основному це просто <code>putStrLn . show</code>. Це спочатку виконує <code>show</code> на значенні, і потім подає його до <code>putStrLn</code>, що повертає I/O дію, що буде роздруковувати наше значення.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, це дуже зручна функція. Згадайте, як ми казали про те, як I/O дії виконуються тільки коли вони підпадають до <code>main</code>, або коли ми намагаємось обчислити їх в підказці GHCI. Коли ми друкуємо значення (як <code>3</code> або <code>[1,2,3]</code>), та натискаємо клавішу <code>return</code>, GHCI насправді використовує <code>print</code> на цьому значенні для відображення його на терміналі!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми бажаємо роздрукувати рядки, зазвичай ми використовуємо <code>putStrLn</code>, оскільки ми не бажаємо лапки навкруги, але для друку наших значень інших типів на термінал здебільшого використовується <code>print</code>.</p></div>
<div class="paragraph"><p><code>getChar</code> є I/O дією, що читає символ зі входу. Таким чином її сигнатура типу є <code>getChar ::IO Char</code>, оскільки результат, що міститься в I/O дії є <code>Char</code>. Зауважте, що через буферізацію читання символів насправді не буде відбуватись, доки користувач не начавить на клавішу вводу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ця програма виглядає так, що вона повинна читати символ, та перевіряти чи це проміжок. Якщо це так, виконання припиняється, та якщо ні - друкуємо його на терміналі, і потім робимо те саме спочатку і так далі. Гаразд, це робить щось подібне, тільки не в спосіб як ви можете це очікувати. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Другий рядок є ввод. Ми вводимо <code>hello sir</code> і потім натискаємо ввод. Через буферізацію виконання програми буде починатись тільки після того, як ми натиснемо <code>return</code>, і не після кожного введеного символу. Але коли ми натиснемо ввод, це діє на тому, що було введено до цього. Спробуйте погратись з цією програмою щоб отримати відчуття як вона робить!</p></div>
<div class="paragraph"><p>Функцію <code>when</code> можна знайти в <code>Control.Monad</code> (щоб отримати до неї доступ зробіть <code>import Control.Monad</code>). Це цікаво, бо в блоці <code>do</code> це виглядає як твердження керування виконанням, але насправді це звичайна функція. Вона приймає логічне значення та I/O дію. Якщо це логічне значення є <code>True</code>, це повертає ту саму I/O дію, що ми надали туди. Однак якщо це <code>False</code>, вона повертає <code>return ()</code>, дію, так що  I/O дія нічого не робить. Ось як ми можемо переписати попередній шмат коду, де ми демонструємо <code>getChar</code> через використання <code>when</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так що, як ви можете бачити, це корисно для інкапсуляції шаблона <code>if something then do some I/O action else return ()</code>.</p></div>
<div class="paragraph"><p><code>sequence</code> бере список I/O дій і повертає I/O дії, що будуть виконувати ці дії, одна за одною. Результат, що міститься в цій I/O дії. буде списком результатів всіх I/O дій, що виконуються. Його сигнатура типу є <code>sequence ::[IO a] -&gt; IO [a]</code>. Роблячи це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>є те саме, що і наступне:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так що <code>sequence [getLine, getLine, getLine]</code> створює I/O дію, що буде виконувати <code>getLine</code> три рази. Якщо ви прикріпите цю дію до імені, результатом є список з усіх результатів, так що в нашому випадку це список з трьох речей, які користувач вводить на підказку консолі.</p></div>
<div class="paragraph"><p>Загальний шаблон з <code>sequence</code> це коли ми відображуємо функції як  <code>print</code> або <code>putStrLn</code> на списки. Виконання <code>map print [1,2,3,4]</code> не створить I/O дію. Це створить сипсок I/O дій, оскільки це як написати <code>[print 1, print 2, print 3, print 4]</code>. Якщо ми бажаємо трансформувати цей список I/O дій в одну I/O дію, ми маємо створити послідовність.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що це за <code>[(),(),(),(),()]</code> в самому кінці? Гаразд, коли ми обчислюємо I/O дію в GHCI, вона виконується і потім друкується його результат, якщо результат не <code>()</code>, в якому випадку нічого не друкується. Ось чому обчислення <code>putStrLn "hehe"</code> в GHCI просто друкує <code>hehe</code> (оскільки результат що міститься в результаті <code>putStrLn "hehe"</code> в <code>()</code>). Але коли ми робимо <code>getLine</code> в GHCI, результат цієї I/O дії друкується, оскільки <code>getLine</code> має тип <code>IO String</code>.</p></div>
<div class="paragraph"><p>Оскільки відображення функції, що повертає I/O дію до списку, та потім створення послідовності по цьому, є таким загальним, що були введені функції <code>mapM</code> та <code>mapM_</code>. <code>mapM</code> бере функцію та список, відображує функцію на списку, та потім створює послідовність. <code>mapM_</code> робить те саме, тільки пізніше він закидає результат. Ми звичайно використовуємо <code>mapM_</code>, коли нам байдуже, який результат має наша послідовність I/O дій.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>forever</code> бере I/O дію і повертає I/O дію, що просто повторює отриману I/O дію постійно. Вона розташована в <code>Control.Monad</code>. Ця невелика програма буде безкінечно запитувати користувача щодо деякого вводу, і віддавати його назад, ВЕЛИКИМИ ЛІТЕРАМИ:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>forM</code> (розташована в <code>Control.Monad</code>) як <code>mapM</code>, тільки з переміненими параметрами. Перший параметр є списком, та другий є функція, по якій треба відображувати цей список, що потім перетворюється на послідовність. Чому це корисне? Гаразд, з деяким креативним застосуванням лямбди та <code>do</code> нотації ми можемо робити такі речі:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>(\a -&gt; do ... )</code> є функцією, що бере число і повертає I/O дію. Ми маємо оточити її в дужки, інакше лямбда подумає, що останні дві I/O дії належать до неї. Зауважте, що ми робимо <code>return color</code> всередині <code>do</code> блока. Ми робимо так, щоб I/O дія, яку визначає <code>do</code> блок, мала б результат кольору, що міститься в ній. Ми насправді не маємо робити це, оскільки <code>getLine</code> вже має те, що міститься в ній. Роблячи <code>color &lt;- getLine</code> та потім <code>return color</code> є проста розпаковка результату від <code>getLine</code>, та потім знову його розпаковка, так що це як просто зробити <code>getLine</code>. <code>forM</code> (викликана з її двома параметрами) продукує I/O дію, результат якої ми прикріплюємо до <code>colors</code>. <code>colors</code> є лише звичайний список, що містить рядки. В кінці ми друкуємо всі ці кольори, роблячи <code>mapM putStrLn colors</code>.</p></div>
<div class="paragraph"><p>Ви можете думати про <code>forM</code> в такому сенсі: створити I/O для кожного елементу в цьому списку. Що кожна I/O дія буде робити залежить від елемента, що була використана для створення дії. Нарешті виконаємо ці дії та прикріпимо результат до чогось. Ми не маємо прикріплювати будь-що, так що ми можемо також відкинути це геть.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Насправді ми можемо зробити це без <code>forM</code>, але з <code>forM</code> це більш читабельне. Звичайно ми пишемо <code>forM</code> коли ми бажаємо зробити <code>map</code> та <code>sequence</code> деяких дій, що ми визначили тут на місці за допомогою <code>do</code> нотації. В тому ж ключі ми можемо замінити останній рядок на <code>forM colors putStrLn</code>.</p></div>
<div class="paragraph"><p>В цьому розділі ми навчились основам вводу та виводу. Ми також з'ясували що таке I/O дії, як вони дозволяють нам вводити та виводити рядки, та коли вони насправді виконуються. Для повтору: I/O дії є значення, здебільшого як любі інші значення в Haskell. Ми можемо передавати їх як параметри до функцій, та функції можуть повертати I/O дії як результати. Що особливе щодо них, це якщо вони підпадають в функцію <code>main</code> (або є результат в рядку GHCI), вони виконуються. І ось тоді вони починають писати дещо на вашому екрані, або грають Yakety Sax в ваших гучномовцях. Кожна I/O дія також може інкапсулювати результат з тим, що ви бажаєте отримати від зовнішнього світу.</p></div>
<div class="paragraph"><p>Не думайте про функцію як <code>putStrLn</code> як про функцію, що бере рядок і друкує його на екрані. Думайте про це, як про функцію, що бере рядок та повертає I/O дію. Ця I/O дія буде, коли виконана, друкувати прекрасні вірші на вашому терміналі.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Файли та потоки</h3>
<div class="paragraph"><p><span class="image">
<img src="images/streams.png" alt="images/streams.png" />
</span>
<code>getChar</code> є I/O дія, що читає поодинокий символ з терміналу. <code>getLine</code> є I/O дія, що читає рядок з терміналу. Вони обоє досить прямолінійні, і більшість мов програмування мають деякі функції або твердження, що відповідають до них. Але тепер давайте познайомимось з <code>getContents</code>. <code>getContents</code> є I/O дія, що читає все зі стандартного вводу, доки не зустріне символ кінця файлу. Її тип <code>getContents ::IO String</code>. Що круте щодо <code>getContents</code>, це те що вона робить ліниве I/O. Коли ми робимо <code>foo &lt;- getContents</code>, вона не читає все і одразу, зберігає в пам'яті і потім прикріплює до <code>foo</code>. Ні, вона лінива! Вона каже: "Так так, я прочитаю вхідні дані з терміналу пізніше як ми дійдемо до цього, коли нам це дійсно знадобиться!".</p></div>
<div class="paragraph"><p><code>getContents</code> є дійсно корисним, коли ми перенаправляємо вихід однієї програми на вхід нашої програми. В випадку, якщо ви не знаєте, як робить перенаправлення в юнікс системах, ось швидке пояснення. Давайте створимо текстовий файл, що містить наступне маленьке хайку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless</code></pre>
</div></div>
<div class="paragraph"><p>Так, хайку поганеньке, що з ним таке? Якщо хтось знає гарні туторіали по хайку - дайте мені знати.</p></div>
<div class="paragraph"><p>Тепер згадайте маленьку програму, яку ми писали коли вводили функцію <code>forever</code>. Якщо запитати користувача ввести рядок, він повертається ВЕЛИКИМИ ЛІТЕРАМИ, і потім все починається спочатку, без кінця. Тільки ви не маєте прогортати весь час назад, ось те саме ще раз:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми зберіжемо цю програму як <code>capslocker.hs</code> або якось інакше, і скомпілюємо її. І потім ми збираємось використати юнікс конвеєр, щоб скормити наш текстовий файл напряму в нашу маленьку програму. Ми збираємось використати допомогу програми GNU <code>cat</code>, що роздруковує файл, переданий їй як аргумент. Перевір це!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, перенаправлення виходу однієї програми (в нашому випадку це була <code>cat</code>) на вхід іншої (<code>capslocker</code>) робиться символом <code>|</code>. Те що ми зробили доволі еквівалентне до простого виконання <code>capslocker</code>, друкування нашого хайку на терміналі і потім ввод символа кінця файла (це звичайно робиться натисканням <code>Ctrl-D</code>). Це як виконати <code>cat haiku.txt</code> і сказати: “Зачекай, не друкуй це на термінал, замість цього скажи це <code>capslocker</code>!”.</p></div>
<div class="paragraph"><p>Те, що ми в основному робимо за допомогою <code>forever</code>, це прийняти вхід і перетворити його в деякий вихід. Ось чому ми можемо використати <code>getContents</code>, щоб зробити нашу програму навіть коротше та краще:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми виконуємо I/O дію <code>getContents</code>, і називаємо рядок, який вона продукує, <code>contents</code>. Потім ми робимо <code>map toUpper</code> по цьому рядку і друкуємо це на термінал. Майте на увазі, що оскільки рядки в основному списки, що є лінивими, і <code>getContents</code> є лінивим I/O, вона не буде читати весь вміст одночасно, і зберігати його в пам'яті перед роздруковки збільшенної версії. Скоріше вона буде роздруковувати збільшену версію по мірі читання, оскільки вона буде читати лише один рядок з входу, коли це буде дійсно треба.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Круто, це робить. Що коли ми просто виконаємо <code>capslocker</code> і спробуємо набрати рядки самотужки?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми виходимо з цього натискаючи <code>Ctrl-D</code>. Доволі мило! Як ви можете бачити, це друкує наш збільшений вхід, рядок за рядком. Коли результат <code>getContents</code> прикріплений до <code>contents</code>, він не представлений в пам'яті як справжній рядок, але більше як проміс, що з часом спродукує рядок. Коли ми робимо <code>map toUpper</code> на <code>contents</code>, це також проміс відобразити цю функцію по колись створеному  <code>contents</code>. І нарешті коли трапляється <code>putStr</code>, він каже попередньому промісу: "Хей, мені треба збільшений рядок!". Це все ще не має рядків, так що він каже до <code>contents</code>: "Хей, як щодо дійсно отримати рядок з терміналу?". І вже тоді <code>getContents</code> насправді читає з терміналу, і повертає рядок до коду, що запитував його, що спродукувати дещо цікаве. Цей код потім відображує <code>toUpper</code> по цьому рядку та видає це до <code>putStr</code>, що друкує його. І потім <code>putStr</code> каже: "Хей, мені треба наступний рядок, ворушись!", і це повторюється доки не буде більше вводу, що втілюється в вигляді символу кінця файла.</p></div>
<div class="paragraph"><p>Давайте створимо програму, що бере деякий ввод, і друкує тільки ті рядки, що коротше десяти символів. Дослідимо:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми створили нашу I/O частину нашої програми такою короткою, як це можливо. Оскільки наша програма передбачає прийняття деякого вводу і друк деякого виводу на основі цього вводу, ми можемо реалізувати її через читання вмісту вводу, виконання функції на ньому, та потім друк того, що повертає функція.</p></div>
<div class="paragraph"><p>Функція <code>shortLinesOnly</code> робить саме так: вона приймає рядок, як <code>"short\nlooooooooooooooong\nshort again"</code>. Цей рядок має три рядка, два з них короткі, і середня довга. Вона виконує на цьому рядку функцію <code>lines</code>, що конвертує її на <code>["short", "looooooooooooooong", "short again"]</code>, що потім прикріплюється до імені <code>allLines</code>. Цей список рядків потім фільтрується, так що в списку залишаються лише рядки коротші десяти символів, продукуючи <code>["short", "short again"]</code>. І нарешті <code>unlines</code> поєднує список в єдиний рядок, обмежений  <code>newline</code>, даючи <code>"short\nshort again"</code>. Давайте дамо цьому хід.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short</code></pre>
</div></div>
<div class="paragraph"><p>Ми перенаправляємо вміст <code>shortlines.txt</code> на вихід <code>shortlinesonly</code>, так що на виході ми отримуємо лише короткі рядки.</p></div>
<div class="paragraph"><p>Цей шаблон отримання деякого рядка на вході, трансформація його за допомогою функції, та потім вивід його, є настільки загальним, що існує функція, що робить це навіть простішим, з назвою <code>interact</code>. <code>interact</code> бере функцію типу <code>String -&gt; String</code> в якості параметра, та повертає I/O дію, що буде сприймати деякий вхід, виконувати цю функцію на ньому, та потім друкувати результат функції. Давайте модифікуємо нашу програму для її використання.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тільки щоб показати, як багато можливо досягти в такому стислому коді (хоча це буде менш читабельне), та щоб продемонструвати здатності ношої функції до композиції, ми збираємось переробити її ще більше.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вау, ми насправді скоротили все до одного рядка, що насправді круто!</p></div>
<div class="paragraph"><p><code>interact</code> може бути використаний для створення програм, до яких пересилаються деякі дані, та потім накопичення результатів, або вона може бути використана для створення програм, що поводиться як отримує рядок від користувача, видаючи деякий результат на основі цього рядка, потім бере інший рядок і так далі. Насправді немає різниці між двома, все залежить тільки від того як користувач збирається використовувати їх.</p></div>
<div class="paragraph"><p>Давайте створимо програму що постійно читає рядок та потім каже нам, чи рядок є паліндромом або ні. Ми можемо просто використовувати <code>getLine</code> для читання рядка, каже користувачу чи це паліндром, і потім виконує <code>main</code> ще раз. Але буде простіше, якщо ми використаємо  <code>interact</code>. При використанні <code>interact</code>, думайте про те, що вам треба трансформувати деякий вхід в бажаний вихід. В нашому випадку ми маємо замінити кожний рядок на вході або на <code>"palindrome"</code> або на <code>"not a palindrome"</code>. Так що ми пишемо функцію, що трансформує дещо як <code>"elephant\nABCBA\nwhatever"</code> в <code>"not a palindrome\npalindrome\nnot a palindrome"</code>. Давайте зробимо це!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте запишемо це без крапок.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить прямолінійно. Спершу це перетворює дещо накшталт <code>"elephant\nABCBA\nwhatever"</code> на <code>["elephant", "ABCBA", "whatever"]</code>, та потім відображує цю лямбду по цьому, даючи <code>["not a palindrome", "palindrome", "not a palindrome"]</code>, та потім використовує поєднання в єдиний рядок, розділений <code>newline</code>. Тепер ми можемо робити</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте протестуємо це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Навіть якщо ми створили програму, що трансформує один великий рядок в інший, це робить так, якби ми створили програму, що робить це рядок за рядком. Це тому що Haskell лінивий,і він бажає друкувати перший рядок результуючого рядка, але він не може, бо він все ще не має першого рядка на вході. Так що так швидко, як ми отримаємо перший рядок на вході, він друкує перший рядок на виході. Ми отримаємо результат від програми, коли надамо символ кінця рядка.</p></div>
<div class="paragraph"><p>Ми також можемо використати цю програму через переправлення їй файлу. Скажімо, ми маємо такий файл:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>dogaroo
radar
rotor
madam</code></pre>
</div></div>
<div class="paragraph"><p>та ми зберігаємо його як <code>words.txt</code>. Ось що ми отримаємо, направивши його в програму:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І знову ми отримали той самий вихід, так якби ми виконали нашу програму та надали слова один за одним в стандартний вхід. Ми просто не бачимо вводу до <code>palindromes.hs</code>, оскільки вхід надходить з файлу, а не від того що ми набираємо слова.</p></div>
<div class="paragraph"><p>Так що тепер ви можливо бачите, як робить ліниве I/O, та як ми можемо використовувати його з вигодою. Ви можете просто думати в термінах того, як має виглядати вихід для деякого нашого вводу, і писати функцію для виконання цієї трансформації. В лінивому I/O нічого не береться з входу, доки це не буде абсолютно потрібне, оскільки те, що ми бажаємо друкувати прямо зараз залежить від цього вводу.</p></div>
<div class="paragraph"><p>Досі ми робили з I/O, друкуючи речі на терміналі та читаючи з нього. Але як щодо читання та запису до файлів? Гаразд, в деякому сенсі ми вже мали робити це. Один шлях думати про читання з терміналу є уявити, що це як читання з (дещо особливого) файла. Те саме вірне і для запису на терміналЮ це так само як писати в файл. Ми можемо називати ці два файли <code>stdout</code> та <code>stdin</code>, маючи на увазі стандартний вивід та вхід, відповідно. Маючи це на увазі ми бачимо, що запис та читання з файлів максимально подібне до писання в стандартний вивід і читання зі стандартного вводу.</p></div>
<div class="paragraph"><p>Ми почнемо з насправді простої програми, що відкриває файл з назвою <code>girlfriend.txt</code>, що містить текст хіта Avril Lavigne <code>Girlfriend</code>, і просто друкує його на термінал. Ось <code>girlfriend.txt</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!</code></pre>
</div></div>
<div class="paragraph"><p>І ось наша програма:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Виконуючи це ми отримуємо очікуваний результат:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте пройдемо рядок за рядком. Перший рядок лише заклики, що привертають нашу увагу. В другому рядку Avril каже нам, що їй не подобається її поточний романтичний партнер. Третій рядок служить для наголосу цього твердження, а четвертий рядок каже, що нам треба шукати нову дівчину.</p></div>
<div class="paragraph"><p>Тепер пройдемо програму рядок з рядком! Наша програма є декілька I/O дій, склеєних разом за допомогою блоку <code>do</code>. В першому рядку блоку <code>do</code> ми помічаємо нову функцію на ім'я <code>openFile</code>. Ось її сигнатура типу: <code>openFile ::FilePath -&gt; IOMode -&gt; IO Handle</code>. ЯКщо ми прочитаємо це вголос, це означає: <code>openFile</code> бере шлях до файлу та <code>IOMode</code>, і повертає I/O дію, що буде відкривати файл, і буде мати асоційований хендлер інкапсульований як результат.</p></div>
<div class="paragraph"><p><code>FilePath</code> є просто синонім типу для <code>String</code>, визначений просто як:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>IOMode</code> є визначений таким чином тип:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/file.png" alt="images/file.png" />
</span>
Так само як наш тип, що представляє сім можливих значень для днів тижня, цей тип перелічує представлення того, що ми бажаємо робити з нашим відкритим файлом. Дуже просто. Просто зауважте, що цей тип <code>IOMode</code>, а не <code>IO Mode</code>. <code>IO Mode</code> має бути типом I/O дії, що має значення деякого типу <code>Mode</code> в якості результату, але <code>IOMode</code> є простий перелік.</p></div>
<div class="paragraph"><p>Нарешті це повертає I/O дію, що повертає вказаний файл у вказаному режимі. Якщо ми прикріпимо дію до будь-чого, ми отримаємо <code>Handle</code>. Значення типу <code>Handle</code> представляє де є наш файл. Ми будемо використовувати цей хендлер, так що ми знатимемо з якого файлу треба читати. Це було б дурним читати файл, але не прикріпити це читання до хендлера, бо ми не були б в змозі робити будь-що з файлом. Так що в нашому випадку ми прикріпили хендлер до <code>handle</code>.</p></div>
<div class="paragraph"><p>В наступному рядку ми бачимо функцію з назвою <code>hGetContents</code>. Вона приймає <code>Handle</code>, так що вона знає, з якого файла треба отримати вміст, та повертає <code>IO String</code> — I/O дію, що в якості результата зберігає вміст файлу. Ця функція доволі подібна до <code>getContents</code>. Єдина відмінність в тому, що <code>getContents</code> буде автоматично читати зі стандартного входу (тобто з терміналу), тоді як <code>hGetContents</code> бере хендлер файла, що каже з якого файла має відбуватись читання. У всіх інших відношеннях вони роблять однаково. І так само як <code>getContents</code>, <code>hGetContents</code> не буде читати файл за один раз та зберігати його в пам'яті, але буде читати його по мірі потреби. Це насправді круто, оскільки ми можемо розглядати <code>contents</code> як повний вміст файла, але він насправді не є завантаженим в пам'ять. Так що якщо це дійсно величезний файл, виконання <code>hGetContents</code> не буде поїдати нашу пам'ять, але вона лише буде читати з файла тільки те, що потрібно, і коли це потрібно.</p></div>
<div class="paragraph"><p>Зауважте різницю між хендлером, використаним для ідентифікації файла і вмістом цього файла, прикріплені в нашій програмі до <code>handle</code> та <code>contents</code>. <code>handle</code> є лише дещо, по чому ми знаємо, що є нашим файлом. Якщо ви уявляєте вашу файлову систему як насправді велику книгу, і кожний файл є глава цієї книги, <code>handle</code> є закладкою, що показує, де ви зараз читаєте (або) главу, тоді як <code>contents</code> є саме главою.</p></div>
<div class="paragraph"><p>За допомогою <code>putStr contents</code> ми просто друкуємо вміст на стандартний вихід, і потім ми робимо <code>hClose</code>, що бере <code>handle</code> і повертає I/O дію, що зачиняє файл. Ви маєте самі зачиняти файл після відкриття його через <code>openFile</code>!</p></div>
<div class="paragraph"><p>Інший спосіб зробити те саме, що ми тільки що зробили, це використання функцію <code>withFile</code>, що має сигнатуру типу <code>withFile ::FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</code>. Вона приймає шлях до файлу, <code>IOMode</code>, і потім вона бере функцію, яка приймає хендлер і повертає деяку I/O дію. Те що вона повертає є I/O дія, що буде відкривати файл, робити те що ви бажаєте зробити, і потім зачиняє його. Результат, інкапсульований в фінальній I/O дії, є той самий, що і результат I/O дії від функції, яку ми надаємо. Це може виглядати як дещо ускладнене, але це насправді просто, особливо з лямбдами, і ось як виглядає наш попередній, переписаний для використання <code>withFile</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, це дуже подібно до попереднього шматка коду. <code>(\handle -&gt; ... )</code> є функцією, що бере <code>handle</code> та повертає I/O дію, і це звичайно виконується саме так, за допомогою лямбди. Причина того, що тут очікується функція, що повертає I/O дію, замість просто сприйняття I/O дії до виконання, та наступне закриття файлу, є в тому, що I/O дія, яку ми передаємо, не мала б знати, з яким файлом треба оперувати. Таким чином <code>withFile</code> відкриває файл, і потім передає <code>handle</code> до функції, яку ми надали. Вона отримує назад I/O дію від цієї функції, і потім створює I/O дію, що така сама, але зачиняє файл після себе. Ось як ми можемо створити свою власну функцію <code>withFile</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/edd.png" alt="images/edd.png" />
</span>
Ми знаємо, що результатом буде I/O дія, так що ми можемо розпочати з <code>do</code>. Спочатку ми відкриваємо файл і отримуємо від нього <code>handle</code>. Потім ми застосовуємо <code>handle</code> до нашої функції, що отримати назад I/O дію, що робить всю нашу роботу. Ми прикріплюємо цю дію до <code>result</code>, зачиняємо <code>handle</code>, і потім повертаємо <code>result</code>. Через повернення результату, огорнутому в I/O дію, що ми отримали від <code>f</code>, ми зробили так, що наша I/O дія інкапсулює той самий результат, що ми отримали від <code>f handle</code>. Так що коли <code>f handle</code> повертає дію, що буде читати число рядків зі стандартного входу, і писати їх до файлу, та мати інкапсульованим результат числа рядків для читання, якби ми використовували цю <code>withFile'</code>, результуюча I/O дія також мала б своїм результатом число прочитаних рядків.</p></div>
<div class="paragraph"><p>Так само, як ми маємо <code>hGetContents</code>, що робить як <code>getContents</code> для специфічного файлу, також є <code>hGetLine</code>, <code>hPutStr</code>, <code>hPutStrLn</code>, <code>hGetChar</code>, etc. Вони роблять як їх колеги без <code>h</code>, тільки вони беруть хендлно як параметр, та оперують на специфічному файлі замість стандартного вводу та стандартного виходу. Приклад: <code>putStrLn</code> є функція, що приймає рядок та повертає I/O дію, що буде записувати цей рядок на терміналі та новий рядок після цього. <code>hPutStrLn</code> приймає хендлер та рядок, і повертає I/O дію, що буде писати писати рядок в файл, асоційований з хендлером. В тому ж дусі <code>hGetLine</code> бере хендлер та повертає I/O дію, що читає рядок з файла.</p></div>
<div class="paragraph"><p>Завантаження файлів і потім трактування їх вмісту як рядків є настільки загальним, що ми маємо ці три чудові невеличкі функції, щоб зробити нашу роботу ще простішою:</p></div>
<div class="paragraph"><p><code>readFile</code> має сигнатуру типу <code>readFile ::FilePath -&gt; IO String</code>. Пам'ятайте, <code>FilePath</code> це просто інша назва для <code>String</code>. <code>readFile</code> бере шлях до файлу і повертає I/O дію, що буде читати файл (ліниво, звичайно), та прикріплює його вміст до дечого як рядок. Це зазвичай більш зручно, ніж робити <code>openFile</code> та прикріплення його до хендлера, і потім робити <code>hGetContents</code>. Ось як ми можемо записати наш попередній приклад з <code>readFile</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки ми не отримали хендлера, з яким ми можемо ідентифікувати наш файл, ми не можемо зачинити його вручну, так що Haskell робить це за нас, коли ми використовуємо <code>readFile</code>.</p></div>
<div class="paragraph"><p><code>writeFile</code> має тип <code>writeFile ::FilePath -&gt; String -&gt; IO ()</code>. Вона бере шлях до файлу і рядок, що треба записати до цього файлу, і повертає I/O дію, що буде виконувати запис. Якщо такий файл вже існує він буде усічений до нульової довжини, перед тим як буде перезаписаний. Ось як перетворити <code>girlfriend.txt</code> на <code>CAPSLOCKED</code> версію, і записати її до <code>girlfriendcaps.txt</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>appendFile</code> має сигнатуру типу таку саму як <code>writeFile</code>, тільки <code>appendFile</code> не відсікає файл до нульової довжини, якщо він вже існує, але додає дещо до нього.</p></div>
<div class="paragraph"><p>Скажімо, ми маємо файл <code>todo.txt</code> що має по одному завданню на рядок, що нам треба робити. Тепер давайте створимо програму, що бере рядок зі стандартного вводу і додає його до нашого списку <code>to-do</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Нам треба додати <code>"\n"</code> в кінець кожного рядка, оскільки <code>getLine</code> не видає нам символ нового рядка в кінці.</p></div>
<div class="paragraph"><p>О, ще одна річ. Ми казали як виконання <code>contents &lt;- hGetContents handle</code> не призводить до читання всього файлу за один раз, та розміщення його в пам'яті. Це I/O ліниве, так що виконання цього:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>те саме що під'єднати трубку від файла до виходу. Так само як ви можете думати про списки як про потоки, так само ви можете думати про файли як про потоки. Це буде читати один рядок за раз і друкувати його на термінал по мірі надходження. Так що ви можете запитати, якою довгою є ця труба? Як часто буде відбуватись доступ до диску? Гаразд, для текстових файлів буферизація по замовчанню зазвичай обмежується рядком. Це означає, що найменьша частина файлу, що буде прочитана за раз, є рядок. Ось чому в цьому випадку воно дійсно читає рядок, друкує вивід, читає наступний рядок, друкує його, і так далі. Для двійникових файлів звичайна буферизація зазвичай блочна. Це означає, що вона буде читати файл частина за частиною. Розмір цього блока є саме такий, який вважає за найкраще ваша операційна система.</p></div>
<div class="paragraph"><p>Ви можете контролювати як саме відбувається буферизація через використання функції <code>hSetBuffering</code>. Вона приймає хендлер та <code>BufferMode</code>, і повертає I/O дію, що встановлює буферизацію. <code>BufferMode</code> є простим типом даних переліку і можливими значеннями є: <code>NoBuffering</code>, <code>LineBuffering</code> або <code>BlockBuffering (Maybe Int)</code>. <code>Maybe Int</code> для завдання того, наскільки великим має бути фрагмент, в байтах. Якщо це <code>Nothing</code>, тоді розмір буфера визначить операційна система. <code>NoBuffering</code> означає, що буде читатись один символ за раз. <code>NoBuffering</code> зазвичай програє як режим буферизації, оскільки він має дуже багато доступу до диску.</p></div>
<div class="paragraph"><p>Ось наш попередній фрагмент коду, тільки він не читає файл рядок за рядком, але замість цього читає цілий файл шматками по 2048 байт.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Читання файлів в більших шматках може допомогти, якщо ви бажаєте мінімізувати доступ до диску, або коли наш файл є насправді повільним мережевим ресурсом.</p></div>
<div class="paragraph"><p>Ми також можемо використовувати <code>hFlush</code>, що є функцією, що приймає хендлер та повертає I/O дію, що буде скидати буфер для файла, асоційованого з хендлером. Коли ми робимо буферізацію рядків, буфер скидається після кожного рядка. Коли ми робимо блочну буферизацію, це відбувається після читання фрегменту. Він також скидається після закриття хендлера. Це означає, що коли ми досягли символ нового рядка, механізм читання (або запису) повідомляє що данні скинчились. Але коли ми використовуємо <code>hFlush</code> це змушує повідомити що данні для читання скінчились. Після скидання дані доступні для інших програм, що виконуються в той самий час.</p></div>
<div class="paragraph"><p>Думайте про читання блочно буферизованого файлу таким чином: ваш туалетний бачок налаштований таким чином, щоб зливатись після набору одного галону води. Так що ви починаєте запускати воду, і коли мітка галону досягнута, вода автоматично зливається, і дані в воді, що ви назбирали, може бути прочитані. Але ви можете змити туалет вручну також, натиснувши кнопку на бачку. Це змиє туалет і вся вода (дані) можуть бути прочитані. В випадку якщо ви не помітили, змивання туалету вручну є метафорою для <code>hFlush</code>. Це не дуже гарна аналогія по стандартам програмних аналогій, але я бажав використати об'єкт з реального світу, що може бути злитий для гумору.</p></div>
<div class="paragraph"><p>Ми вже створювали програму для додавання нового елементу до нашого <code>to-do</code> списку в <code>todo.txt</code>, тепер давайте створимо програму для видалення елементу. Я просто вставлю код і потім ми пройдемо по програмі разом, так що ви побачите що вона насправді проста. Ми будемо використовувати нові функції з <code>System.Directory</code> і одну нову функцію з <code>System.IO</code>, але вони всі будуть пояснені.</p></div>
<div class="paragraph"><p>Так чи інакше, ось програма для видалення елемента з <code>todo.txt</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Для початку ми просто відкриваємо <code>todo.txt</code> в режимі читання, і прикріплюємо його хендлер до <code>handle</code>.</p></div>
<div class="paragraph"><p>Далі ми використовуємо функцію, яку ми досі не зустрічали, і що походить з <code>System.IO</code> — <code>openTempFile</code>. Її ім'я досить пояснює само себе. Вона бере шлях до тимчасового каталогу і шаблон імені для файлу, і відериває тимчасовий файл. Ми використали <code>"."</code> для тимчасової директорії, оскільки <code>.</code> означає поточну директорію майже на кожній OS. Ми використали <code>"temp"</code> як ім'я шаблону для тимчасового файлу, що означає, що тимчасовий файл буде названий <code>temp</code>, плюс деякі випадкові символи. Він повертає I/O дію, що створює тимчасовий файл і результат цієї I/O дії буде пара значень: ім'я тимчасового файлу і хендлер. Ми можемо просто відкрити звичайний файл з назвою <code>todo2.txt</code>, або щось біля того, але краща практика використовувати <code>openTempFile</code>, так що ви знаєте, що ви можливо нічого не переписуєте.</p></div>
<div class="paragraph"><p>Причина, з якої ми не використовуємо <code>getCurrentDirectory</code> для отримання поточної директорії, та потім передачі її до <code>openTempFile</code>, але замість просто використання <code>"."</code> до <code>openTempFile</code> це тому, що <code>.</code> посилається на поточну директорію на unix-подібних системах та Windows.</p></div>
<div class="paragraph"><p>Наступним кроком ми прикріплюємо вміст <code>todo.txt</code> до <code>contents</code>. Потім розбиваємо цей рядок на список рядків, кожний рядок в одному рядку. Так що <code>todoTasks</code> депер щось подібне до <code>["Iron the dishes", "Dust the dog", "Take salad out of the oven"]</code>. Ми зціплюємо з числами від <code>0</code> і далі цей список з функцією, що приймає число, як <code>3</code>, та рядок, як <code>"hey"</code>, і повертає <code>"3 - hey"</code>, так що <code>numberedTasks</code> буде <code>["0 - Iron the dishes", "1 - Dust the dog"</code> &#8230;. Ми поєднуємо цей список рядків в один рядок розділений новими рядками за допомогою <code>unlines</code>, і друкуємо цей рядок на термінал. Зауважте, що замість робити це ми можемо також зробити <code>mapM putStrLn numberedTasks</code>.</p></div>
<div class="paragraph"><p>Ми питаємо користувача який елемент він бажає видалити, і очікуємо доки він введе число. Скажімо він бажає видалити номер <code>1</code>, що є <code>Dust the dog</code>, так що він натискає <code>1</code>. <code>numberString</code> тепер <code>"1"</code>, і оскільки ми бажаємо число а не рядок, ми запускаємо <code>read</code> на цьому числі для отримання <code>1</code>, і прикріплюємо його до <code>number</code>.</p></div>
<div class="paragraph"><p>Згадайте функції <code>delete</code> та <code>!!</code> з <code>Data.List</code>. <code>!!</code> повертає елемент зі списку з деяким індексом, і <code>delete</code> видаляє перше входження елементу в списку, і повертає новий список без цього входження. <code>(todoTasks !! number)</code> (<code>number</code> тепер <code>1</code>) повертає <code>"Dust the dog"</code>. Ми прикріплюємо <code>todoTasks</code> без першого входження <code>"Dust the dog"</code> до <code>newTodoItems</code>, і потім поєднуємо це в один рядок за допомогою <code>unlines</code> перед записом його в тимчасовий файл, який ми відкрили. Старий файл тепер незмінний, і тимчасовий файл містить всі рядки що містив старий, крім того що ми видалили.</p></div>
<div class="paragraph"><p>Після цього ми зачиняємо обоє, оригінальний та тимчасовий файли, та потім ми видаляємо оригінальній за допомогою <code>removeFile</code>, що, як ви можете бачити, бере шлях до файлу та видаляє його. Після видалення старого <code>todo.txt</code>, ми використовуємо <code>renameFile</code> для переіменування тимчасового файлу на <code>todo.txt</code>. Будьте обережні, <code>removeFile</code> та <code>renameFile</code> (що обоє, до речі, в <code>System.Directory</code>), приймають шляхі в якості параметрів, не хендлери.</p></div>
<div class="paragraph"><p>І це все! Ми можемо зробити це навіть за меньше рядків, але ми будемо дуже обережні не переписати жодних існуючих файлів, і чемно попросимо операційну систему сказати нам, де можна розташувати наш тимчасовий файл. Надамо цьому руху!</p></div>
<div class="listingblock">
<div class="content"></div></div>
</div>
<div class="sect2">
<h3 id="____3">Аргументи командного рядка</h3>
<div class="paragraph"><p><span class="image">
<img src="images/arguments.png" alt="images/arguments.png" />
</span>
Мати справу з аргументами командного рядка майже необхідність, якщо ви бажаєте створити скрипт або застосування, що робить в терміналі. На щастя стандартна бібліотека Haskell має гарний спосіб отримання аргументів командного рядка в програмі.</p></div>
<div class="paragraph"><p>В попередньому розділі ми створили одну програму для додавання елемента <code>to-do</code> до нашого <code>to-do</code>, і одну програму для видалення елемента. Існує дві проблеми з обраним нами підходом. Перше в тому що ми жорстко закодували ім'я нашого файла <code>to-do</code> в нашому коді. Ми просто вирішили, що файл буде називатись <code>todo.txt</code>, і що користувач ніколи не матиме потреби керувати декількома списками <code>to-do</code>.</p></div>
<div class="paragraph"><p>Один шлях вирішити це є завжди запитувати користувача, який файл він бажає використовувати для списку <code>to-do</code>. Ми використовували цей підхід, коли хотіли знати, який елемент користувач бажає видалити. Це робить, але це не так добре, оскільки це вимагає від користувача запустити програму, дочекатись доки програма запитає дещо, і потім сказати це програмі. Це називається інтерактивною програмою, і складна частина з інтерактивними програмами командного рядка така — що коли ми бажаємо автоматизувати роботу цієї програми, як це робиться в пакетних скриптах? Складніше скласти пакетний скрипт, що взаємодіє з програмою, ніж скрипт, що просто викликає одну програму або декілька з них.</p></div>
<div class="paragraph"><p>Ось чому іноді краще щоб користувач сказав програмі що він хоче під час запуску програми, замість щоб програма запитувала користувача під час роботи. І найкращий шлях користувачеві сказати програмі, що він бажає що вона робила, це через аргументи командного рядка!</p></div>
<div class="paragraph"><p>Модуль <code>System.Environment</code> також має круті I/O дії. Одна це <code>getArgs</code>, що має тип <code>getArgs ::IO [String]</code>, і є I/O дією, що буде отримувати аргументи, з якими програма була запущена, і має свій результат в вигляді списку з ціма аргументами. <code>getProgName</code> має тип <code>getProgName ::IO String</code>, і є I/O дією, що містить ім'я програми.</p></div>
<div class="paragraph"><p>Ось невелика програма, що демонструє як роблять ці дві функції:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми прикріпили <code>getArgs</code> та <code>progName</code> до <code>args</code> та <code>progName</code>. Ми кажемо <code>The arguments are:</code>, і потім для кожного аргумента в <code>args</code> ми робимо <code>putStrLn</code>. Нарешті ми також друкуємо ім'я нашої програми. Давайте завершимо цей <code>arg-test</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гарно. Обзброєні цім знанням ви можете створити деякі круті застосування командного рядка. Фактично давайте пійдемо далі і самі створимо таке. В попередньому розділі ми створили окрему прогруму для додавання завдань і окрему програму для для їх видалення. Тепер ми збираємось поєднати це в одну програму, і що вона робитиме від аргументів командного рядка. Ми також збираємось створити її так, що ми зможемо оперувати з разними файлами , не тільки з <code>todo.txt</code>.</p></div>
<div class="paragraph"><p>Ми назвемо її просто <code>todo</code> і вона зможе робити (хаха!) три різні речі:</p></div>
<div class="ulist"><ul>
<li>
<p>
Переглядати завдання
</p>
</li>
<li>
<p>
Додавати завдання
</p>
</li>
<li>
<p>
Видаляти завдання
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ми не збираємось обтяжувати себе можливим поганим вводом дуже сильно і прямо зараз.</p></div>
<div class="paragraph"><p>Наша програма буде зроблена таким чином, що якщо ми бажаємо додати завдання <code>Find the magic sword of power</code> до файлу <code>todo.txt</code>, нам треба набрати <code>todo add todo.txt "Find the magic sword of power"</code> в нашому терміналі. Щоб подивитись завдання, нам треба зробити тільки <code>todo view todo.txt</code>, і щоб видалити завдання з індексом 2 ми робимо <code>todo remove todo.txt 2</code>.</p></div>
<div class="paragraph"><p>Ми почнемо зі створення асоціативного списку диспечеризації. Це буде простий асоціативний список, що матиме аргументи командного рядка в якості ключів, і функції як відповідні значення. Всі ці функції будуть типу <code>[String] -&gt; IO ()</code>. Вони будуть приймати список аргументів як параметр, і повертають I/O дію, що робить перегляд, додавання, видалення, тощо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми все де маємо визначити <code>main</code>, <code>add</code>, <code>view</code> та <code>remove</code>, так що почнемо <code>main</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Спочатку ми отримуємо аргументи, і прикріплюємо їх до <code>(command:args)</code>. Якщо ви пам'ятаєте ваше співпадіння шаблонів, це означає, що перший аргумент буде прив'язаний до <code>command</code> та решта аргументів буде прив'язана до <code>args</code>. Якщо ми викличемо нашу програму як <code>todo add todo.txt "Spank the monkey"</code>, команда буде <code>"add"</code>, і <code>args</code> буде <code>["todo.xt", "Spank the monkey"]</code>.</p></div>
<div class="paragraph"><p>В наступному рядку ми шукаємо нашу команду в списку диспечеризації. Оскільки <code>"add"</code> вказує на <code>add</code>, ми отримуємо <code>Just add</code> в якості результату. Ми використовуємо порівняння шаблонів для виділення наших функцій з <code>Maybe</code>. Що станеться, якщо нашої <code>command</code> немає в списку диспечеризації? Гаразд, тоді пошук буде повертати <code>Nothing</code>, але ми казали, що не будемо дуже сильно заморочувати себе на збої, так що наше порівняння дасть збій, і наша програма втратить придатність.</p></div>
<div class="paragraph"><p>Нарешті ми викликаємо функцію нашої дії з рештою списку аргументів. Це повертатиме I/O дію, що або додає елемент, або відображує список елементів, або видаляє елемент. І оскільки ця дія є частиною блоку <code>main do</code>, вона буде виконана. Якщо ми прослідимо наш приклад далі, і наша функція дії є <code>add</code>, вона буде викликана з <code>args</code> (тобто <code>["todo.txt", "Spank the monkey"]</code>), і повертає I/O дію, що додає <code>Spank the monkey</code> до <code>todo.txt</code>.</p></div>
<div class="paragraph"><p>Чудово! Все що нам залишилось, це реалізувати <code>add</code>, <code>view</code> та <code>remove</code>. Давайте почнемо з <code>add</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми викличемо нашу програму як <code>todo add todo.txt "Spank the monkey"</code>, <code>"add"</code> буде прикріплене до <code>command</code> в першому співпадінні шаблонів в блоці <code>main</code>, тоді як <code>["todo.txt", "Spank the monkey"]</code> буде передане до функції, що ми отримали зі списку диспачеризації. Так що, оскільки ми не маємо справу з поганим вводом прямо зараз, ми просто робимо співпадіння шаблону по списку з ціма двома елементами, і повертаємо I/O дію, що додає цей рядок до кінця файлу, разом з символом нового рядка.</p></div>
<div class="paragraph"><p>Далі давайте реалізуємо функціональність перегляду списку. Якщо ми бажаємо переглянути елементи в файлі, ми робимо <code>todo view todo.txt</code>. Так що в першому порівнянні шаблонів <code>command</code> буде <code>"view"</code>, і <code>args</code> буде <code>["todo.txt"]</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми вже робили майже таку саму річ в програмі, що тільки видаляла завдання, де ми відображували завдання, так що користувач міг обрати одне для видаляння. Але тут ми просто відображуємо завдання.</p></div>
<div class="paragraph"><p>І, нарешті, ми збираємось реалізувати <code>remove</code>. Вона буде дуже подібна до програми, що тільки видаляє завдання, так що якщо ви не розумієте, як тут робить видалення елементів, перевірте пояснення для тієї програми. Головна різниця в тому, що ми не жорстко кодуємо <code>todo.txt</code>, але отримуємо його як аргумент. Ми також не видаємо підказку користувачеві для введення номеру завдання для видалення, ми отримуємо його як аргумент.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми відкрили файл на основі <code>fileName</code> і відкрили тимчасовий файл, видалили рядок з індексом, який користувач бажає видалити, записали це в тимчасовий файл, видалили оригінальний файл і переіменували тимчасовий файл назад в <code>fileName</code>.</p></div>
<div class="paragraph"><p>Ось вся програма разом, у всій своїй славі!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/salad.png" alt="images/salad.png" />
</span>
Щоб підсумувати наше рішення: ми створили асоціативну диспечеризацію, що відображує команди на функції, які приймають деякі аргументи командного рядка, та повертають I/O дію. Ми дивимось, що таке <code>command</code>, і на цій основі отримуємо функцію с асоціативного списку. Ми викликаємо цю функцію з залишком аргументів командного рядка, щоб отримати назад I/O дію, що буде робити відповідні речі, і потім просто виконуємо цю дію!</p></div>
<div class="paragraph"><p>В інших мовах ми б могли реалізувати це за допомогою великого твердження <code>switch case</code> або ще якось, але використання функцій вищого порядку дозволяє нам лише сказати списку диспечеризації дати нам відповідну функцію, і потім сказати функції дати нам I/O дію для деяких аргументів командного рядка.</p></div>
<div class="paragraph"><p>Давайте спробуємо наше застосування!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Інша крута річ щодо цього в тому, що легко можна додати додаткову функціональність. Просто дадайте елемент в асоциативний список диспечеризації, Просто додайте елемент в асоціативний список і реалізуйте відповідну функцію - і ви вже щасливі! В якості завдання ви можете спробувати реалізувати функцію <code>bump</code>, що буде брати файл і номер завдання, і повертати I/O дію, що буде проштовхувати завдання нагору списку to-do.</p></div>
<div class="paragraph"><p>Ви можете зробити, щоб ця програма падала більш витончено в випадку поганого вводу (наприклад, якщо хтось виконає <code>todo UP YOURS HAHAHAHA</code>), створивши I/O дію, яка тільки повідомляє, що була помилка (скажімо, <code>errorExit ::IO ()</code>), і потім перевіряти на потенційно помилковий ввод. Якщо ввод помилковий - виконуємо I/O дію, що повідомляє про подію. Інший шлях є використання виключень, з чим ми скоро зустрінемось.</p></div>
</div>
<div class="sect2">
<h3 id="_">Випадковість</h3>
<div class="paragraph"><p><span class="image">
<img src="images/random.png" alt="images/random.png" />
</span>
Багато разів під час програмування вам треба отримати деякі випадкові дані. Можливо ви створюєте гру, де треба кинути на вдачу, або вам треба згенерувати деякі тестові дані для перевірки вашої програми. В програмуванні є багато використань випадкових даних. Гаразд, насправді псевдо-випадкових, бо всі ми знаємо, що єдине справжнє джерело випадковості є мавпа на моно-колесі, з сиром в одній руці і задом в іншій. В цьому розділі ми поглянемо як змусити Haskell генерувати на-вигляд випадкові дані.</p></div>
<div class="paragraph"><p>В більшості інших мов програмування ви маєте функції, що повертають вам деяке випадкове число. Кожного разу, коли ви викликаєте цю функцію, ви отримуєте (маємо надію) інше випадкове число. Як щодо Haskell? Гарад, пам'ятаємо, Haskell є чисто функціональною мовою. Що означає, що він має посилкову прозорість. Що, В СВОЮ ЧЕРГУ, означає, що функція, двічі обчислена з тими самими параметрами, має двічі продукувати той самий результат. Це дійсно круто, оскільки це дозволяє нам по-іншому продумувати програми, і це дозволяє нам відкладувати виконання до того часу, коли це насправді потрібно. Якщо я викликаю функцію, я можу бути певний, що вона не буде робити жодні веселі речі перед надання мені результатів. Все що важливе, це її результат. Однак це робить отримання випадкових чисел трохи заплутаним. Наприклад, я маю таку функцію:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вона не дуже корисна, як функція випадкових чисел, бо вона завжди буде повертати 4. Навіть якщо я вважатиму що це 4 повністю випадкове, бо я використав кості щоб визначити його.</p></div>
<div class="paragraph"><p>Як інші мови виробляють на вигляд випадкові числа? Гаразд, вони беруть різну інформацію з вашого комп'ютера, як поточний час, як сильно та де ви пересували мишу, та який різновид шумів ви створювали за комп'ютером. І базуючись на цьому видають число, що виглядає досить випадковим. Комбінація ціх факторів (їх випадковість) можливо є різною в кожний окремий момент часу, так що ви отримуєте інше випадкове число.</p></div>
<div class="paragraph"><p>Ага. То в Haskell ми можемо отримати випадкове число, коли ми створимо функцію, що приймає свій параметр, що є випадковістю, і на основі цього повертає деяке число (або інший тип даних).</p></div>
<div class="paragraph"><p>Входить модуль <code>System.Random</code>. Він має всі функціЇ, що задовільняють наші потреби в випадковості. Давайте просто зануримось в одну з функцій, які він експортує, а саме <code>random</code>. Ось її тип: <code>random ::(RandomGen g, Random a) =&gt; g -&gt; (a, g)</code>. Отакої! В цьому типі з'являються деякі нові типокласи! Типоклас <code>RandomGen</code> існує для типів, що можуть діяти як джерело випадковості. Типоклас <code>Random</code> існує для речей, що можуть приймати випадкові значення. Логічне значення може приймати випадкові значення, а саме <code>True</code> або <code>False</code>. Число також може приймати безліч різних випадкових значень. Чи може функція приймати випадкове значення? Я так не думаю, напеве ні! Якщо ми спробуємо перекласти декларацію <code>random</code> на людську мову, ми отримаємое: вона приймає випадковий генервтор (що є нашим джерелом випадковості), та повертає випадкове значення і новий випадковий генератор. Чому вона також повертає новий генератор разом з випадковим значенням? Гараз, через мить ми це побачимо.</p></div>
<div class="paragraph"><p>Щоб використати випадкову функцію, ми маємо взятись за один із цих випадкових генераторів. Модуль <code>System.Random</code> експортує крутий тип, <code>StdGen</code>, що є примірником типокласу <code>RandomGen</code>. Ми можемо або створити <code>StdGen</code> вручну, або ми можемо сказати системі дати нам готовий, що базується на різних типах випадкових речей.</p></div>
<div class="paragraph"><p>Щоб створити випадковий генератор, використовуйте функцію <code>mkStdGen</code>. Він має тип <code>mkStdGen ::Int -&gt; StdGen</code>. Вона приймає ціле, і базуючись на цьому видає випадковий генератор. Гаразд, давайте спробуємо використати <code>random</code> та <code>mkStdGen</code> в тандемі, для отримання (навряд чи випадкового) числа.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що таке? Ага, вірно, випадкова функція може повертати значення любого типу, що є частиною типокласу <code>Random</code>, так що ми маємо інформувати Haskell, який різновид типу ми бажаємо. Також не забуваємо, що він повертає випадкове значення, в парі з випадковим генератором.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Нарешті! Число, що виглядає випадковим! Перший компонент тапла є наше число, а ось другий є текстуальне представлення нашого нового випадковогоо генератора. Що трапиться,якщо ми знову викличемо <code>random</code> з тим самим випадковим генератором?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Звичайно. Той самий результат для тих самих параметрів. Так що давайте спробуємо надати інший випадковий генератор як параметр.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Все гаразд, круто, чудово, інше число. Ми можемо використати анотацію типу, щоб отримати інші типи від функції.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте створимо функцію, що симулює кидання монети три рази поспіль. Якщо <code>random</code> не повертав би новий генератор разом зі значенням, ми б мали зробити щоб ця функція приймала три випадкові генератори як параметри, і потім повертала результат кидання для кожного з них. Але це звучить погано, бо якщо генератор може створити значення типу <code>Int</code> (який може взяти на себе навантаження різних значень), вона має бути в змозі створити три кидка монети (що може приймати рівно вісім комбінацій). Тому ось де <code>random</code> зі своїм поверненням випадкового генератора разом зі значенням стає в нагоді.</p></div>
<div class="paragraph"><p>Ми представимо монету як просте <code>Bool</code>. <code>True</code> є орел, <code>False</code> решка.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми викликаємо <code>random</code> з генератором, що ми отримали як параметр, щоб отримати монету та новий генератор. Потім ми викликаємо його знову, тільки цього разу з новим генератором, щоб отримати другу монету. Ми робимо те саме для отримання тертьої монети. Коли б ми викликали його з тим самим генератором кожного разу, всі монети мали б те саме значення, і ми б могли отримати лише <code>(False, False, False)</code> або <code>(True, True, True)</code> в якості результата.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, що нам не треба робити <code>random gen ::(Bool, StdGen)</code>. Це тому, що ми вже вказали, що ми бажаємо логічні в декларації типу функції. Ось чому Haskell може вивести, що ми бажаємо отримати логічне в цьому випадку.</p></div>
<div class="paragraph"><p>То що, коли ми бажаємо кинути чотири монети? Або п'ять? Гаразд, існує функція з назвою <code>randoms</code>, що приймає генератор, та повертає безкінечну послідовність значень на основі цього генератора.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Чому <code>randoms</code> не повертає новий генератор разом зі списком? Ми можемо реалізувати функцію <code>randoms</code> дуже просто, ось так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Рекурсивне визначення. Ми отримуємо випадкове значення і новий генератор від поточного генератора, і потім створюємо список, що має значення в якості голови, і випадкові числа на основі нового генератора в якості хвоста. Оскільки ми повинні бути в змозі генерувати безкінечну кількість чисел, ми не повертаємо новий генератор назад.</p></div>
<div class="paragraph"><p>Ми можемо створити функцію, що генерує скінчений потік чисел і новий генератор таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Знову це рекурсивне визначення. Ми кажемо, що якщо ми бажаємо 0 чисел, ми просто повертаємо порожній список і генератор, що був нам наданий. Для любого іншого числа випадкових значень ми спочатку отримуємо одно випадкове значення і новий генератор. Це буде голова. Потім ми кажемо, що хвіст буде <code>n - 1</code> чисел, згенерованих новим генератором. Потім ми повертаємо голову і залишок списку поєднані, і фінальний генератор, що ми маємо від отримання <code>n - 1</code> випадкових чисел.</p></div>
<div class="paragraph"><p>Що, коли ми бажаємо випадкове значення в деякому різновиді диапазону? Всі випадкові цілі до ціх пір були надмірно великі або малі. Що, коли ми бажаємо кинути кості? Гаразд, для ціх цілей ми використовуємо <code>randomR</code>. Вона має тип <code>randomR ::(RandomGen g, Random a) ::(a, a) -&gt; g -&gt; (a, g)</code>, що означає, що це різновид <code>random</code>, тільки вона приймає в якості першого параметру пару значень, що встановлюють нижню та верхню межу, та фінальне вироблене значення буде в ціх межах.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Також існує <code>randomRs</code>, що продукує потік випадкових значень в визначених межах. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гарно, виглядає як супер секретний пароль або щось таке.</p></div>
<div class="paragraph"><p>Можливо ви питаєте себе, що цей розділ взагалі має назагал з I/O? Досі ми не зробили нічого, що має відношення до I/O. Гаразд, досі ми завжди створювали наші генератори випадкових чисел вручну, створюючи їх за допомогою довільних цілих. Пробелма в тому, що якщо ми робитимемо це в справжніх програмах, вони будуть завжди повертати ті самі випадкові числа, що буде недобре для нас. Ось чому <code>System.Random</code> пропонує I/O дію <code>getStdGen</code>, що має тип <code>IO StdGen</code>. Коли ваша програма починає роботу, вона питає систему щодо гарного генератора випадкових чисел, і зберігає його в так званому глобальному генераторі. <code>getStdGen</code> отримує цей глобальний випадковий генератор, коли ви прикріплюєте його до будь-чого.</p></div>
<div class="paragraph"><p>Ось проста програма, що генерує випадковий рядок.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак будьте обережні, просте виконання <code>getStdGen</code> двічі буде запитувати систему про той самий глобальний генератор два рази. Якщо ви зробите таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>ви отрмаєте той самий рядок, надрукований двічі! Один спосіб отримати два різні рядка довжиною 20 символів є встановити безкінечний потік, і потім взяти перші 20 символів, та роздрукувати їх як один рядок, потім взяти інший набір з 20 символів та роздрукувати їх як другий рядок. Для цього ми можемо використати функцію <code>splitAt</code> з <code>Data.List</code>, що розділяє список по деякому індексу і повертає тапл, що має першу частину як перший компонент, і другу частину як другий компонент.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Інший шлях є використовувати дію <code>newStdGen</code>, що розділяє наш поточний випадковий генератор на два генератори. Вона оновлює глобальний випадковий генератор за допомогою одного з них, і інкапсулює інший як свій результат.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми не тільки отримуємо новий випадковий генератор, коли ми прикріплюємо <code>newStdGen</code> до будь-чого, глобальний також оновлюється, так що якщо ми робимо <code>getStdGen</code>, і прикріпляємо його до будь-чого, ми отримаємо генератор, що не є той самий що <code>gen</code>.</p></div>
<div class="paragraph"><p>Ось невеличка програма, що змушує користувача здогадуватись, яке число вона загадала4.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/jackofdiamonds.png" alt="images/jackofdiamonds.png" />
</span>
Ми ствоорюємо функцію <code>askForNumber</code>, що приймає генератор випадкових чисел і повертає  I/O дію, що буде запитувати користувача ввести число, та потім каже, чи була його здогадка вірною. І цій функції ми спочатку генеруємо випадкове число і новий генератор на основі генератора, що ми отримали як параметр, і викликаємо <code>randNumber</code> та <code>newGen</code>. Давайте скажімо, що зенероване число є <code>7</code>. Потім ми кажемо користувачеві ввести число зі своєю здогадкою. Ми виконуємо <code>getLine</code>, та прикріплюємо результат до <code>numberString</code>. Тоді, якщо користувач вводить <code>7</code>, <code>numberString</code> стає <code>"7"</code>. Далі ми використовуєте  <code>when</code> для перевірки, чи рядок, що ввів користувач, є порожнім рядком. Якщо це так, виконується порожня I/O дія <code>return ()</code>, що ефективно завершує програму. Якщо це не так, виконується дія, що складається з блоу <code>do</code>. Ми використовуємо <code>read</code> на <code>numberString</code> для перетворення його на число, так що <code>number</code> тепер <code>7</code>.</p></div>
<div class="paragraph"><p>Пробачте мені! Якщо користувач надає нам деякий ввод, що <code>read</code> на може прочитати (як <code>"haha"</code>), наша програма буде падати з незграбним повідомленням про помилку. Якщо ви не бажаєте, щоб ваша програма падала по помилковому вводу, використовуйте <code>reads</code>, що повертає порожній список, коли вона схибить в читанні рядка. Коли вона успішна, вона повертає список синглтон з таплом, що має наше бажане значення в якості одного компоненту, і рядок з тим що ми не спожили в якості іншого.</p></div>
<div class="paragraph"><p>Ми перевіряємо, чи число що ми ввели дорівнює до того, що згенероване випадково, і видає відповідне повідомлення. І потім ми викликаємо <code>askForNumber</code> рекурсивно, тільки на цей раз з новим генератором, що ми отримали, що дає нам I/O дію, що просто така сама, яку ми виконали, тільки вона залежить від іншого генератора, і ми виконуємо її.</p></div>
<div class="paragraph"><p><code>main</code> складається з простого отримання випадкового генератора від системи, і виклика <code>askForNumber</code> з ним для отримання початкової дії.</p></div>
<div class="paragraph"><p>Ось наша програма в дії!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Інший спосіб зробити цю програму наступний:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це дуже подібно до попередньої версії, тільки замість створення функції, що приймає генератор, і потім викликає себе рекурсивно з новим оновленим генератором, ми робимо всю роботу в <code>main</code>. Після повідомлення користувача, чи був він правий чи ні, ми оновлюємо глобальний генератор, і потім знову викликаємо <code>main</code>. Обоє підхода гідні, але перший подобається мені більше, бо він робить меньше справ в <code>main</code>, і також провадить нам функцію, яку ми можемо легко використовувати ще раз.</p></div>
</div>
<div class="sect2">
<h3 id="__">Рядки байтів</h3>
<div class="paragraph"><p><span class="image">
<img src="images/chainchomp.png" alt="images/chainchomp.png" />
</span>
Списки круті і корисні структури даних. Досі ми використовували їх майже весь час. Існують різноманітні функції, що оперують з ними, і лінивість Haskell дозволяє нам замінити цикли <code>for</code> та <code>while</code> на фільтрування та відображення для списків, оскільки обчислення буде відбуватись тільки коли це дійсно знадобиться, так що такі речі, як безкінечні списки (і навіть безкінечні списки безкінечних списків!) не є для нас проблемою. Ось чому списки також можуть бути використані для представлення потоків, або при читанні з зі стандартного входу, або при читанні з файлів. Ми можемо просто відкрити файл, і читати його як рядок, навіть якщо доступ до нього буде здійснено за виникнення потреби.</p></div>
<div class="paragraph"><p>Однак обробка файлів як рядків має один недолік: він має схильність бути повільним. Як ви знаєте, <code>String</code> є синонімом типу для <code>[Char]</code>. <code>Char</code> не має фіксованого розміру, бо він має декілька байтів щоб представляти символи зі, скажімо, Unicode. Більше того, списки дійсно ліниві. Якщо ви маєте список, як <code>[1,2,3,4]</code>, він буде обчислений тільки за кончої потреби. Так що весь список є щось як обіцянка списку. Пам'ятайте, що цей <code>[1,2,3,4]</code> є синтаксичним цукром для <code>1:2:3:4:[]</code>. Коли перший елемент списку буде вимушений обчислитись (скажімо, для свого друку), залишок списку, <code>2:3:4:[]</code>, все ще залишається обіцянкою списку, і так далі. Так що ви можете думати про списки як про обіцянки, що наступний елемент буде доставлений, як тільки це дійсно має відбутись, і разом з цім обіцянка щодо елементу після нього. Не треба робити великі розумові зусилля,щоб дійти висновку, що обробка простого списку чисел як послідовності обіцянок не є сама ефективна річ в світі.</p></div>
<div class="paragraph"><p>Це навантаження не дуже нас турбує більшісь часу, але це виявляється відповідальним при читанні великих файлів та їх обробці. Ось чому Haskell має байтові рядки. Байтові рядки є дещо як списки, тільки кожний елемент має один байт (або 8 біт) розміром. Спосіб, як вони обробляють лінивість, також відрізняється.</p></div>
<div class="paragraph"><p>Байтові рядки мають два різновиди: суворі та ліниві. Суворі байтові рядки знаходятся в  <code>Data.ByteString</code>, і вони зовсім відходять від лінивості. Не задіяні жодні обіцянки; суворий байтовий рядок представляє послідовність байтів в массиві. Ви не можете мати таких речей, як безкінечні суворі байтові рядки. Якщо ви обчислите перший байт в суворому байтовому рядку, ви маєте обчислити його як ціле. Гарною стороною є те, що це меньш обтяжливо, бо немає задіяних грон (технічний термін для обіцянок). Недоліком є те, що це займе вашу пам'ять швидше, бо ці рядку читаються в пам'ять одночасно.</p></div>
<div class="paragraph"><p>Інший різновид байтових рядків знаходиться в <code>Data.ByteString.Lazy</code>. Вони ліниві, але не такі ліниві, як списки. Як ми казали раніше, в списку стільки грон, скільки елементів. Це те, що робить їх повільними для наших цілей. Ліниві байтові рядки обирають інший підхід — вони зберігаються в шматках (не плутати з гронами!), кожний шматок має розмір 64K. Так що коли ви обчислюєте байт в лінивому байтовому рядку (друкуючи його, або ще щось), будуть обчислень перші 64K. Після цього це просто обіцянка для залишку шматків. Ліниві байтові рядки є різновид списків суворих байтових рядків розміром 64K. Коли ми обробляємо файл за допомогою лінивих байтових рядків, він буде читатись рядок за рядком. Це круто, бо це не призводить до стрімкого злету використання пам'яті, і 64K можливо гарно розміститься в вашому L2 кеші.</p></div>
<div class="paragraph"><p>Якщо ви продивитесь документацію по <code>Data.ByteString.Lazy</code>, ви побачите, що він має багато функцій, що мають ті самі назви, що і такі самі з <code>Data.List</code>, тільки сингатури типу мають <code>ByteString</code> замість <code>[a]</code>, і <code>Word8</code> замість <code>a</code> в них. Функції з тими самими назвами здебільшого діють так само, як ті, що роблять зі списками. Оскільки імена ті самі, ми збираємось зробити кваліфікований імпорт в скрипті, і потім завантажити цей скрипт в GHCI, щоб погратись з байтовими рядками.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>B</code> має ліниві типи і функції для байтових рядків, тоді як <code>S</code> має суворі. Ми в основному будемо використовувати ліниві версії.</p></div>
<div class="paragraph"><p>Функція <code>pack</code> має сигнатуру типу <code>pack ::[Word8] -&gt; ByteString</code>. Це означає те, що вона бере список байтів типу <code>Word8</code> і повертає <code>ByteString</code>. Ви можете думати про це як взяти список, що є лінивим, і зробити його менш лінивим, так що він лінивий тільки з інтервалами 64K.</p></div>
<div class="paragraph"><p>Що за справи з цім типом <code>Word8</code>? Гаразд, це як <code>Int</code>, тільки він має значно меньший диапазон, а саме <code>0-255</code>. Він представляє 8-бітне число. І так само як <code>Int</code>, він в типокласі <code>Num</code>. Наприклад, ми знаємо, що значення <code>5</code> є поліморфним в тому, що може діяти як любий числовий тип. Гаразд, воно також може прийняти тип <code>Word8</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, ви звичайно не повинні турбуватись про <code>Word8</code> дуже сильно, оскількли система типів може дати числам обирати свій тип. Якщо ви спробуєте використати велике число, як <code>336</code> як <code>Word8</code>, воно буде огорнене по колу до <code>80</code>.</p></div>
<div class="paragraph"><p>Ми запакували тільки декілька значень до <code>ByteString</code>, так що вони в одному шматку.  <code>Empty</code> таке як <code>[]</code> для списків.</p></div>
<div class="paragraph"><p><code>unpack</code> є зворотня функція до <code>pack</code>. Вона приймає байтовий рядок і обертає його на список байтів.</p></div>
<div class="paragraph"><p>fromChunks takes a list of strict bytestrings and converts it to a lazy bytestring. toChunks takes a lazy bytestring and converts it to a list of strict ones.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це гарно, якщо ви маєте багато малих суворих байтових рядків, і ви бажаєте обробляти їх ефективно, без поєднання їх перед цім в один великий суворий байтовий рядок.</p></div>
<div class="paragraph"><p>Байтова версія <code>:</code> має назву <code>cons</code>. Вона бере байт і байтовий рядок, і ставить байт на початок. Вона тим не менш лінива, так що вона створюватиме новий шматок, навіть якщо перший шматок в байтовому рядку не повний. Ось чому краще використовувати сувору версію  <code>cons</code>, <code>cons'</code>, якщо ви збираєтесь вставляти багато байтів на початок рядка.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, <code>empty</code> створює порожній байтовий рядок. Бачите різницю між <code>cons</code> та <code>cons'</code>? За допомогою <code>foldr</code>, ми почали з порожнього байтового рядка, і потім пройшись по списку чисел справа, додаючи кожне число до початку байтового рядка. Коли ми використовуємо <code>cons</code>, ми скінчили одним шматком для кожного байту, що дещо перемагає мету.</p></div>
<div class="paragraph"><p>В іншому модулі байтових рядків мають кіпу функцій, що аналогічні до таких в <code>Data.List</code>, включаючи але не обмежуючись до: <code>head</code>, <code>tail</code>, <code>init</code>, <code>null</code>, <code>length</code>, <code>map</code>, <code>reverse</code>, <code>foldl</code>, <code>foldr</code>, <code>concat</code>, <code>takeWhile</code>, <code>filter</code>, тощо.</p></div>
<div class="paragraph"><p>Він також має функції, що мають ті самі імена і поводяться так само, як деякі функції, які можна знайти в <code>System.IO</code>, тільки <code>String</code> замінені на <code>ByteStrings</code>. Наприлад, функція <code>readFile</code> в <code>System.IO</code> має тип <code>readFile ::FilePath -&gt; IO String</code>, коли <code>readFile</code> з модулів байтових рядків мають тип <code>readFile ::FilePath -&gt; IO ByteString</code>. Начувайтесь, якщо ви використовуєте суворі байтові рядки, і ви намагаєтесь прочитати файл, він прочитає файл в пам'ять за один раз! З лінивими байтовами рядками читання буде відбуватись по милих шматках.</p></div>
<div class="paragraph"><p>Давайте створимо невелику програму, що приймає два імені файлів як аргументи командного рядка, і копіює перший файл в другий файл. Зауважте, що <code>System.Directory</code> вже має функцію з назвою <code>copyFile</code>, але ми все одно збираємось реалізувати власну функцію і програму копіювання файлів.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми створюємо нашу власну функцію, що приймає два <code>FilePath</code> (пам'ятайте, що <code>FilePath</code> є просто синонім до <code>String</code>), і повертає I/O дію, що буде копіювати один файл в інший з використанням байтових рядків. В функції <code>main</code> ми просто отримуємо аргументи і викликаємо нашу функцію з ними, щоб отримати I/O дію, яка потім виконується.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ runhaskell bytestringcopy.hs something.txt ../../something.txt</code></pre>
</div></div>
<div class="paragraph"><p>Зауважте, що програма, що не використовує байтові рядки, може виглядати майже так само, з тією різницею, що ми використали <code>B.readFile</code> та <code>B.writeFile</code> замість <code>readFile</code> та <code>writeFile</code>. В багатьох випадках ви можете перетворити програму, що використовує звичайні рядки, на програму, що використовує байтові рядки, тільки зробивши потрібні імпорти, і потім поклавши кваліфіковані імена модулів перед деякими функціями. Іноді ви маєте конвертувати функції, що ви пишете для роботи з рядками, так, щоб вони робили з байтовими рядками, але це не складно.</p></div>
<div class="paragraph"><p>Кожного разу, коли вам потрібна краща продуктивність в програмі, що читає багато даних в рядки, дайте спробувати байтовим рядкам - є шанси що вони прискорять справи з дуже невеликими зусиллями з вашого боку. Звичайно я пишу програми, використовуючи звичайні рядки, і потім конвертую їх для використання байтових рядків, якщо продуктивність є незадовільною.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Виключення</h3>
<div class="paragraph"><p><span class="image">
<img src="images/timber.png" alt="images/timber.png" />
</span>
Всі мови мають процедури, функції та частини коду, що можуть схибити в деякий спосіб. Це просто життєвий факт. Різні мови мають різні шляхи обробки ціх збоїв. В C ми зазвичай використовуємо деяке незвичайне значення повернення (як <code>-1</code> або вказівник <code>null</code>), щоб вказати, що те, що повернула функція, не може розглядатись як звичайне значення. З іншого боку, Java та C# схиляються до використання виключень для обробки збоїв. Коли закидається виключення, контроль виконання перестрибує на деякий визначений вами код, що робить деяке очищення, і можливо пере-закидає виключення, так що інший код обробки помилок зможе потурбуватись про деякі інші речі.</p></div>
<div class="paragraph"><p>Haskell має дуже гарну систему типів. Алгебраїчні типи даних дозволяють такі типи, як <code>Maybe</code> та <code>Either</code>, і ми можемо використовувати значення ціх типів для представлення результатів, що можуть або бути, або ні. Повернення в C, скажімо, <code>-1</code> в разі збою, повністю є предметом домовленості. Це також має особливе значення для людини. Якщо ми не будемо обережні, ми можемо розглядати ці незвичайні значення як звичайні, і потім вони можуть наробити безлад і жах в нашому коді. Система типів Haskell дає нам деяку таку-необхідну безпеку в цьому аспекті. Функція <code>a -&gt; Maybe b</code> ясно вказує, що вона може продукувати <code>b</code> огорнуте в <code>Just</code>, або що вона може повернути <code>Nothing</code>. Це тип, відмінний від простого <code>a -&gt; b</code>, і якщо ми спробуємо використати ці дві функції одну замість іншої, копілятор буде скаржитись на нас.</p></div>
<div class="paragraph"><p>Не зважаючи на присутність виразних типів, що підтримують збійні обчислення, Haskell все ще має підтримку для виключень, оскільки вони мають більше сенсу в I/O контекстах. Багато речей можуть пійти не так, коли ви маєте справу з зовнішнім світом, тому що він такий ненадійний. Наприклад, коли відкривається файл, ціла кіпа речей може пійти не так. Файл може бути заблокований, він може взагалі бути відсутній, або може бути відсутній взагалі весь жорстуий диск, або будь-що ще. Так що це гарно бути в змозі перестрибнути на деяку частину обробки помилок в вашому коді, коли такі помилки трапляються.</p></div>
<div class="paragraph"><p>Гаразд, так що I/O код (тобто нечистий код) може закидати виключення. Це має сенс. То що щодо чистого коду? Гаразд, він також може закидати виключення. Подумайте про функції <code>div</code> та <code>head</code>. Вони мають типи <code>(Integral a) =&gt; a -&gt; a -&gt; a</code> та <code>[a] -&gt; a</code>, відповідно. Ні <code>Maybe</code> або <code>Either</code> в їх типах повернення, і вони обоє можуть схибити! <code>div</code> вибухне вам в обличчя, коли ви спробуєте поділити на ноль, та <code>head</code> впадає в істеріку, коли ви передасте їй порожній список.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/police.png" alt="images/police.png" />
</span>
Чистий код може закидати виключення, але вони можуть бути перехоплені в I/O частині нашого кода (коли ми всередині блока <code>do</code>, що іде в <code>main</code>). Це тому, що ви не знаєте коли (та взагалі чи) будь-що буде виконане в чистому коді, оскільки він лінивий, та не має гарно визначеного порядку виконання, тоді як I/O код має.</p></div>
<div class="paragraph"><p>Раніше ми казали про те, що нам слідує проводити щонайменьше часу в  I/O частині нашої програми. Логіка нашої програми повинна здебільшого залишатись в наших чистих функціях, оскільки їх результати залежать лише від параметрів, з якими викликаються функції. Коли ми маємо справи з чистими функціями, ви маєте думати лише про те, що повертає функція, оскільки вона не може робити будь-що інше. Це робить ваше життя простіше. Навіть якщо і робити деяку логіку в I/O необхідно (як відкривати файли і подібні речі), повинно утримувати її на мінімумі. Чисті функції ліниві по замовчанню, що означає, що ми не знаємо, коли вони будуть обчислені, і що це насправді не повинно мати значення. Однак як тільки чисті функції починають закидати виключення, стає важливим, коли вони обчислюються. Ось чому ми лише можемо перехоплювати виключення, закинуті в чистому коді, в I/O частині нашого кода. І це погано, оскільки ми бажаємо утримувати I/O частину малою, наскільки це можливо. Однак якщо ми не перехоплюємо їх в I/O частині нашого коду, наша програма падає. Яке рішення? Не змішуйте виключення і чистий код. Отримуйте перевагу від потужної системи типів Haskell, і використовуйте типи як <code>Either</code> та <code>Maybe</code> для представлення результатів, що можуть схибити.</p></div>
<div class="paragraph"><p>Ось чому поки що ми тільки подивимось, як використовувати I/O виключення. I/O виключення є виключення, що виникають коли щось іде не так при взаємодії з зовнішнім світом в I/O дії, що є частиною <code>main</code>. Наприклад, ми можемо спробувати відкрити файл, і потім з'ясовується, що файл був видалений або ще щось. Погляньте на цю програму, яка відкриває файл, чиє ім'я надається в аргументі командного рядка, і каже, скільки рядків має цей файл.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Дуже проста програма. Ми виконуємо I/O дію <code>getArgs</code>, і прикріплюємо перший рядок в списку, що вона видає, до <code>fileName</code>. Потім ми викликаємо <code>contents</code> файла з вмістом цього ім'я. Нарешті ми застосовуємо рядки цього <code>contents</code>, щоб отримати список рядків, і потім ми отримуємо довжину списка щоб надати її до <code>show</code>, щоб отримати рядкове представлення цього числа. Це робить як очікується, але що трапиться, коли ми дамо йому ім'я файла, що не існує?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ага, ми отримали помилку від GHC, яке каже нам, що файл не існує. Наша програма падає. Що, коли ми бажаємо надрукувати краще повідомлення якщо файл не існує? Один спосіб зробити це є перевірити, чи файл існує, перед спробою відкрити його, використовуючи функцію <code>doesFileExist</code> з <code>System.Directory</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ми зробили <code>fileExists &lt;- doesFileExist fileName</code>, оскільки <code>doesFileExist</code> має тип `doesFileExist 
</dt>
<dd>
<p>
FilePath &#8594; IO Bool`, що означає, що вона повертає I/O дію, що має як результат логічне значення, яке каже нам чи файл існує. Ми не можемо просто використовувати <code>doesFileExist</code> в <code>if</code> виразі напряму.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Іншим рішенням тут може бути використання виключень. Це чудово припустиме використовувати їх в цьому контексті. Неіснуючий файл є виключенням, що походить від I/O, так що перехоплення його в I/O є гарним і пристойним.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Щоб впоратись з цім через використання виключень ми збираємось скористатись перевагами від функції <code>catch</code> з <code>System.IO.Error</code>. Її тип є `catch 
</dt>
<dd>
<p>
IO a &#8594; (IOError &#8594; IO a) &#8594; IO a`. Вона приймає два параметри. Перший є I/O дією. Наприклад це може бути I/O дією, що намагається виконати файл. Другий є так званим обробником. Якщо перша I/O дія, парадана до <code>catch</code>, закидає I/O виключення, це виключення передається в обробник, який вирішує що робити далі. Так що фінальний результат є I/O дія, що буде діяти або як перший параметр, або буде робити те що каже обробник, якщо перша I/O дія закидає виключення.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><span class="image">
<img src="images/puppy.png" alt="images/puppy.png" />
</span>
Якщо ви знайомі з <code>try-catch</code> блоками в мовах як Java або Python, функція <code>catch</code> подібна до них. Перший параметр є річ, що треба спробувати, як щось таке в блоці <code>try</code> в інших, імперативних мовах. Другий параметр є обробником, що приймає виключення, як більшість  <code>catch</code> блоків приймають виключення, що ви потім можете перевіряти, щоб побачити, що трапилось. Обробник викликається, якщо виключення було закинуте.</p></div>
<div class="paragraph"><p>Обробник бере значення типу <code>IOError</code>, що є значенням, яке вказує, що трапилось I/O виключення. Воно також несе інформацію відносно типу виключення, що було закинуте. Як цей тип реалізований залежить від реалізації самої мови, що означає, що ми не можемо досліджувати значення типу <code>IOError</code> через співпадіння шаблону, так само як ми не можемо порівнювати шаблони до значень типу <code>IO something</code>. Ми можемо використовувати декілька корисних предикатів, щоб отримувати корисну інформацію щодо значень типу <code>IOError</code>, які ми вивчино через мить.</p></div>
<div class="paragraph"><p>Так що давайте застосуємо нового друга <code>catch</code>!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Для початку ви бачите, що ми поклали зворотні апострофи кругом нього, так що ми можемо використовувати його як інфіксну функцію, бо він приймає два параметри. Його використання як інфіксної функції робить його більш читабельним. Так що <code>toTry ``catch`</code> handler` є те саме,що і <code>catch toTry handler</code>, що гарно пасує до його типу. <code>toTry</code> є I/O дія, яку ми намагаємось використати, і <code>handler</code> є функція, що приймає <code>IOError</code>, та повертає дію, яка виконується в випадку виключення.</p></div>
<div class="paragraph"><p>Давайте надамо цьому руху:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В обробнику ми не перевіряли, який тип <code>IOError</code> ми отримали. Ми просто кажемо <code>"Whoops, had some trouble!"</code> для любого типу помилок. Просте перехоплення всіх типів виключень в обробнику є поганою практикою в Haskell, так само як в більшості інших мов. Що коли трапляться деякі інші виключення, які ми не бажаємо перехоплювати, як переривання програми або щось інше? Ось чому ми бажаємо зробити ту саму річ, яку ми звичайно робимо також в інших мовах: ми перевіримо, який саме тип виключення ми отримали. Якщо це різновид виключення, який ми бажаємо перехопити, ми робимо наші речі. Якщо ні - ми знову перезапускаємо виключення. Давайте модифікуємо нашу програму для перехоплення тільки виключень, викликаних відсутністю файла.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Все залишається тим самим, крім обробника, який ми модифікували для перехоплення тільки певної групи I/O виключень. Тут ми використали дві нові функції з <code>System.IO.Error</code> — <code>isDoesNotExistError</code> та <code>ioError</code>. <code>isDoesNotExistError</code> є предикатом на <code>IOErrors</code>, що означає, що це функція, що приймає <code>IOError</code> і повертає <code>True</code> або <code>False</code>, що означає що вона має тип <code>isDoesNotExistError :: IOError -&gt; Bool</code>. Ми використовуємо його на виключенні, що передано в наш обробник, щоб побачити, чи це помилка спричинена неіснуванням файла. Тут ми використали синтаксис охоронців, але також можна застосувати  <code>if else</code>. Якщо це не спричинено неіснуванням файла, ми пере-закидаєм виключення, що було передане в обробник за допомогою функції <code>ioError</code>. Вона має тип `ioError 
</dt>
<dd>
<p>
IOException &#8594; IO a`, так що вона приймає <code>IOError</code> і продукує I/O дію, що буде закидати її. I/O має тип <code>IO a</code>, оскільки вона насправді ніколи не видає результат, так що вона може діяти як <code>IO anything</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Так що якщо виключення, закинуте в I/O дії <code>toTry</code>, що ми склеїли разом в блок <code>do</code>, не спричинене неіснуванням файла, <code>toTry ``catch`</code> handler` буде перехоплювати, та потім пере-закидати його. Досить круто, так?</p></div>
<div class="paragraph"><p>Існують декілька предикатів, що діють на <code>IOError</code>, і якщо охоронець не обчислюється до <code>True</code>, обчислення провалюється до наступного охоронця. Предикати, що діють на <code>IOError</code>, такі:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Більшість з цього є досить самоописовим. <code>isUserError</code> обислюється до <code>True</code>, коли ми використовуємо функцію <code>userError</code> для створення виключення, що використовується для створення виключень в нашому коді, і оснащення його рядком. Наприклад, ви можете зробити <code>ioError $ userError "remote computer unplugged!"</code>, хоча бажано щоб ви використовували типи як <code>Either</code> та <code>Maybe</code> для представлення можливого збою, замість закидання виключень самому за допомогою <code>userError</code>.</p></div>
<div class="paragraph"><p>Так що ви можете мати обробник, що виглядає дещо подібно до наступного:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>де <code>notifyCops</code> та <code>freeSomeSpace</code> є деякі визначені вами I/O дії. Переконайтесь, що перезакинули виключення, якщо воно не співпало з жодною з ваших критерій, інакше ви спричините мовчазний крах вашого застосування в деяких випадках, де це не мало б статись.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>System.IO.Error</code> також експортує функції, що дозволяють опитувати наші виключення щодо деяких атрибутів, як що за вказівник файлу, який спричинив помилку, або яке ім'я файлу. Вони починаються на <code>ioe</code>, і ви можете побачити їх повний список в документації. Скажімо ми бажаємо надрукувати ім'я файлу, що спричинив нашу помилку. Ми не можемо надрукувати <code>fileName</code>, яке ми отримали від <code>getArgs</code>, оскільки в обробник надійшло тільки <code>IOError</code>, і обробник не знає більше нічого іншого. Функція залежить тільки від параметрів, з якими вона викликана. Ось чому ми можемо використати фуункцію <code>ioeGetFileName</code>, що має тип `ioeGetFileName 
</dt>
<dd>
<p>
IOError &#8594; Maybe FilePath`. Вона приймає <code>IOError</code> як параметр і можливо повертає <code>FilePath</code> (що є тільки синонімом типу для <code>String</code>, пам'ятаємо, так що це різновид тієї самої речі). Те що вона в основному робить, це виділяє шлях файлу з <code>IOError</code>, якщо зможе. Давайте модифікуємо нашу програму для роздрукування нашого шляху файла, відповідального за виникле виключення.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В охоронці, коли <code>isDoesNotExistError</code> є <code>True</code>, ми використали  <code>case</code> вираз для виклику <code>ioeGetFileName</code> з <code>e</code>, та потім порівняли шаблон щодо значення <code>Maybe</code>, яке він повертає. Застосування виразів <code>case</code> загально використовується коли ви бажаєте порівняти шаблон з дечим, не привносячи нову функцію.</p></div>
<div class="paragraph"><p>Ви не маєте використовувати один обробник для перехоплення виключень у всій вашій частині I/O. Ви можете просто охопити певну частину вашого I/O коду в <code>catch</code>, або ви можете охопити деякі з ни в <code>catch</code>, та використовувати різні обробники для них, десь так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут <code>toTry</code> використовує <code>handler1</code> як обробник, та <code>thenTryThis</code> використовує <code>handler2</code>. <code>launchRockets</code> не є параметром для <code>catch</code>,так що якщо воно може закинути виключення, це має занапастити нашу програму, хіба що <code>launchRockets</code> використовує перехоплення внутрішньо для обробки своїх власних виключень. Звичайно, <code>toTry</code>, <code>thenTryThis</code> та <code>launchRockets</code> є I/O дії що мають бути склеєні разом з використанням синтаксису <code>do</code>, і гіпотетично визначені деінде в іншому місці. Це дещо подібно до блоків <code>try-catch</code> в інших мовах, де ви можете оточити всю вашу програму в єдиний <code>try-catch</code>, або ви можете використати більш поміркований підхід, та використовувати різні блоки в різних частинах вашого коду, щоб контролювати, який тип обробки помилок відбувається.</p></div>
<div class="paragraph"><p>Тепер ви знаєте, як мати справи з I/O виключеннями! Закидання виключень з чистого коду та справи з ними тут не були розглянуті, здебільшого через те, що, як ми казали, Haskell пропонує значно кращий спосіб вказувати на помилки, ніж звертатись до I/O для їх відловлення. Навіть при склеюванні разом I/O дій що можуть схибити, я схиляюсь мати їх тип дещо на кшталт <code>IO (Either a b)</code>, що означає, що вони є нормальними I/O діями, але результат, що вони видають після виконання, матиме тип <code>Either a b</code>, що означає або <code>Left a</code>, або <code>Right b</code>.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-11-18 07:12:44 EET
</div>
</div>
</body>
</html>
