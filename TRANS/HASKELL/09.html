<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Ввод та вивод</h2>
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="images/dognap.png" alt="images/dognap.png" />
</span>
Ми вже казали, що Haskell є чисто функціональною мовою. В той час, коли в імперативних мовах ви зазвичай отримуєте речі надаючи копм'ютеру серії кроків для виконання, функціональне програмування більше щодо визначення того, чим є речі. В Haskell функція не може змінити деякий стан, як змінити вміст змінної (коли функція змінює стан ми кажемо, що функція має побічні ефекти). Єдина річ, яку може робити функція в Haskell, це дати нам деякий результат на основі параметрів, які ми надаємо їй. Якщо функція викликається два рази з тими самими параметрами, вона має повертати той самий результат. Хоча це може виглядати дещо обмежувальним, якщо ви прийшли з імперативного світу, ми бачили, що насправді це круто. В імперативній мові ви не маєте гарантії, що проста функція, що має лише пожонглювати деякими числами, не спалить вашу хату, не викраде вашого пса і не пошкрябає вашу машину помідором, при маніпуляції ціма числами. Наприклад, коли ви шукаєте в двійниковому дереві, ми не вставляли елемент в дерево, модифікуючи дерево на місці. Наша функція для вставки в двійникове дерево насправді повертає нове дерево, бо воно не може змінити старе дерево.</p></div>
<div class="paragraph"><p>Хоча функції, що не можуть змінювати стан, є гарним, бо дозволяє нам промислювати наші програми, з цім є одна проблема. Якщо функція не може зробити дещо в світі, як вона зможе повідомити нам, що вона нарахувала? Щоб сказати нам, що обчислено, вона має змінити стан вихідного пристрою (звичайно стан екрану), що потім виділяє фотони, які подорожують до нашого мозку, та змінюють стан наших думок, чоловіче.</p></div>
<div class="paragraph"><p>Не втрачайте надію, не все втрачено. З'ясовується, що насправді Haskell має дійсно розумну систему для справ з функціями, що мають побічні ефекти, яка мило відокремлює частину програми, що є чистою, та частину що є нечистою і робить всю брудну роботу, як розмови з клавіатурою та екраном. Маючи ці дві частини розділеними ми все ще можемо промислювати нашу чисту програму і отримувати переваги від всіх речей, що надає чистота, як лінивість, надійність та модульність, при цьому ефективно комунікуючи з зовнішним світом.</p></div>
<div class="sect2">
<h3 id="_hello_world">Hello, world!</h3>
<div class="paragraph"><p><span class="image">
<img src="images/helloworld.png" alt="images/helloworld.png" />
</span>
До цього часу ми завжди завантажували наші функції в GHCI для їх тестування та забавок з ними. Ми також дослідили функції стандартної бібліотеки, проміж справ. Але тепер, після восьми або десь так глав, ми нарешті збираємось написати нашу першу справжню програму Haskell! Вау! І будьте впевнені, що ми збираємось зробити стару добру штуку "hello, world".</p></div>
<div class="paragraph"><p>Хей! Для цілей цієї глави я буду вважати, що ми використовуємо  unix-подібне середовище для вивчення Haskell. Якщо ви в Windows, я б порадив завантажити Cygwin, що є Linux-подібне оточення для Windows, тобто те що нам треба.</p></div>
<div class="paragraph"><p>І так, для початку, забийте наступне в вашому улюбленому текстовому редакторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="n">putStrLn</span> <span class="s">&quot;hello, world&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми тільки що визначили ім'я <code>main</code>, і в ньому ми викликаємо функцію з назвою <code>putStrLn</code> з параметром <code>"hello, world"</code>. Виглядає як робота млина, але ні, ми побачимо це через мить. Збережіть це в файлі <code>helloworld.hs</code>.</p></div>
<div class="paragraph"><p>Але зараз ми збираємось зробити дещо, чого не робили досі. Насправді ми збираємось скомпілювати нашу програму! Я в захопленні! Відкрийте ваш термінал і перейдіть в каталог, де розміщений <code>helloworld.hs</code>, та виконайте таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ghc --make helloworld
<span class="o">[</span><span class="m">1</span> of <span class="m">1</span><span class="o">]</span> Compiling Main             <span class="o">(</span> helloworld.hs, helloworld.o <span class="o">)</span>
Linking helloworld ...
</pre></div></div></div>
<div class="paragraph"><p>Okay! With any luck, you got something like this and now you can run your program by doing ./helloworld.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./helloworld
hello, world
</pre></div></div></div>
<div class="paragraph"><p>І ось де ми є, наша перша скомпільована програма, що друкує дещо на терміналі. Неймовірно нудно!</p></div>
<div class="paragraph"><p>Давайте перевіримо, що ми написали. Спочатку давайте подивимось на тип функції <code>putStrLn</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">t</span> <span class="kt">putStrLn</span>
<span class="n">putStrLn</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">t</span> <span class="kt">putStrLn</span> <span class="err">&quot;</span><span class="kt">hello</span><span class="o">,</span> <span class="n">world</span><span class="s">&quot;</span>
<span class="s">putStrLn &quot;</span><span class="n">hello</span><span class="o">,</span> <span class="n">world</span><span class="err">&quot;</span> <span class="o">::</span> <span class="nc">IO</span> <span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо прочитати тип <code>putStrLn</code> таким чином: <code>putStrLn</code> бере рядок та повертає I/O дію, що має тип результата <code>()</code> (тобто порожній тапл, також відомий як юніт). I/O дія є дещо, що коли виконується буде нести дію з побічним ефектом (це зазвичай або читання з входу або друкування дечого на екрані), і буде також містити деякий різновид значення повернення в собі. Друкування рядка на термінал насправді не має жодного осмисленого типу повернення, так що використовується фіктивне значення <code>()</code>.</p></div>
<div class="paragraph"><p>Порожній типл є значенням <code>()</code>, і він має також тип <code>()</code>.</p></div>
<div class="paragraph"><p>То коли буде виконана I/O дія? Гаразд, ось де з'являється <code>main</code>. I/O дія буде виконана коли ми дамо їй ім'я <code>main</code>, і потім виконаємо програму.</p></div>
<div class="paragraph"><p>Маючи всю вашу програму тільки в вигляді однієї I/O дії виглядає дещо обмежувальним. Ось чому ми можемо використовувати синтаксис <code>do</code> для зклеювання разом декількох I/O дій в одну. Погляньте на наступний приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">(</span><span class="s">&quot;Hey &quot;</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">&quot;, you rock!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>А, цікаво, новий синтаксис! І це читається майже так само як імперативна програма. Якщо ви скомпілюєте це і спробуєте в дії, це буде поводитись так само, як ми цього очікуємо. Зауважте, що ми тільки но сказали <code>do</code> і потім поклали серію кроків, як би ми зробили в імперативній програмі. Кожний з ціх кроків є I/O дією. Збираючи їх докупи за допомогою синтаксису <code>do</code>, ми зліпили їх в одну I/O дію. Дія, яку ми отримали, має тип <code>IO ()</code>, оскільки це тип останньої I/O дії всередині.</p></div>
<div class="paragraph"><p>Через це <code>main</code> завжди має сигнатуру типу <code>main ::IO something</code>, де <code>something</code> є деякий конкретний тип. За домовленістю ми звичайно не вказуємо декларацію типу для <code>main</code>.</p></div>
<div class="paragraph"><p>Цікава річ, з якою ми досі не зустрічались, це третій рядок, що вказує <code>name &lt;- getLine</code>. Виглядає що воно читає рядок з входу, та зберігає його в змінній на ім'я <code>name</code>. Чи так насправді? Гаразд, давайте перевіримо тип <code>getLine</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="k">:</span><span class="kt">t</span> <span class="kt">getLine</span>
<span class="n">getLine</span> <span class="o">::</span> <span class="nc">IO</span> <span class="nc">String</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/luggage.png" alt="images/luggage.png" />
</span>
Так, це є. <code>getLine</code> є I/O дією, що містить тип результату <code>String</code>. Це має сенс, оскільки це буде очікувати користувача, докі він введе дещо в терміналі, і потім це дещо буде представлене як рядок. То що відбувається в <code>name &lt;- getLine</code>? Ви можете читати цей шматок коду таким чином: виконати I/O дію <code>getLine</code>, та потім прив'язати значення результату до <code>name</code>. <code>getLine</code> має тип <code>IO String</code>, так що <code>name</code> буде мати тип <code>String</code>. Ви можете думати про I/O дію як бокс на маленьких ніжках, що виходитиме в реальний світ і робитиме там дещо (як малювати графіті на стінах), або приносити назад деякі дані. Коли ці дані були підтягрутя до вас, єдиним способом відкрити бокс і отримати дані всередині є використання конструкції <code>&lt;-</code>. І коли ми беремо дані з I/O дії, ми можемо дістати їх лише коли ми всередині іншої I/O. Ось як діє Haskell для гарного поділу кода на чисту і нечисту частину. <code>getLine</code> в деякому сенсі є нечистим, бо його значення результату не буде гарантовано тим самим, якщо його виконати двічі. Ось чому він дещо заплямований конструктором типу IO, і ми можемо отримати ці дані лише від I/O коду. І оскільки I/O код також заплямований, любі обчислення, що залежать від заплямованих I/O даних, будуть мати заплямований результат.</p></div>
<div class="paragraph"><p>Коли я кажу заплямований, я не маю на увазі це в такий спосіб, що ми ніколи не зможемо використовувати результат в I/O дії, будь-коли в чистому коді. Ні, ми тимчасово роз-плямовуємо дані в I/O дії, коли ми прикріплюємо її до <code>name</code>. Коли ми робимо <code>name &lt;- getLine</code>, <code>name</code> є просто звичайний рядок, оскільки він представляє те, що знаходиться в боксі. Ми можемо мати дійсно складну функцію, що скажімо бере ваше ім'я (звичайний рядок) як параметр, і каже вам всю вашу вдачу і майбутнє всього вашого життя, базуючись на вашому імені. Ми можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;Read this carefully, because this is your future: &quot;</span> <span class="o">++</span> <span class="n">tellFortune</span> <span class="n">name</span>
</pre></div></div></div>
<div class="paragraph"><p>і <code>tellFortune</code> (або жодна функція, куди вона передає <code>name</code>) не має знати нічого про I/O, це просто нормальна функція <code>String -&gt; String</code>!</p></div>
<div class="paragraph"><p>Подивіться на цей шматок коду, чи він валідний?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">nameTag</span> <span class="k">=</span> <span class="s">&quot;Hello, my name is &quot;</span> <span class="o">++</span> <span class="n">getLine</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви відповіли ні - пійдіть з'їжте періжок. Якщо ви сказали так - випийте ковшик розпеченої лави. Я пошуткував, не робіть цього! Причина, з якої це не робить, в тому, що <code>++</code> потребує обоє свої параметри як спискаи того самого типу. Лівий параметр має тип <code>String</code> (або <code>[Char]</code> якщо бажаєте), тоді як <code>getLine</code> має тип <code>IO String</code>. Ви не можете приєднати рядок та I/O дію. Спочатку ми маємо отримати результат від I/O дії, щоб отримати тип <code>String</code>, і це єдиний спосіб зробити це в тому, щоб сказати щось як <code>name &lt;- getLine</code> всередині іншої I/O дії. Якщо ми бажаємо мати справу з нечистими даними, ми маємо робити це в нечистому оточенні. Так що прокляття нечистості розповсюджується навкруги як бич нечесті, так що в наших кращих інтересах утримувати I/O частини коду такими малими, як це можливо.</p></div>
<div class="paragraph"><p>Кожна I/O дія, що виконується, має заточений в собі результат. Ось чому наш попередній приклад програми може бути записаний таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">foo</span> <span class="k">&lt;-</span> <span class="n">putStrLn</span> <span class="s">&quot;Hello, what&#39;s your name?&quot;</span>
    <span class="n">name</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">(</span><span class="s">&quot;Hey &quot;</span> <span class="o">++</span> <span class="n">name</span> <span class="o">++</span> <span class="s">&quot;, you rock!&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак <code>foo</code> буде мати лише значення <code>()</code>, так що робити таке буде лише  різновидом балачок. Зауважте, що ми не прив'язали останній <code>putStrLn</code> до будь-чого. Це через те, що в блоці <code>do</code> остання дія не може бути прив'язана до імені, як це було з першими двома. Ми побачимо чому це так трохи пізніше, коли ми поринемо в світ монад. Зараз ви можете думати про це в спосіб, що блок <code>do</code> автоматично виділяє значення з останньої дії, і прикріпляє його до свого власного результату.</p></div>
<div class="paragraph"><p>За винятком цього останнього рядка, кожний рядок, що не прикріплений, може бути записаний як прикріплення. Так що <code>putStrLn "BLAH"</code> може бути записане як <code>_ &lt;- putStrLn "BLAH"</code>. Але це не має користі, так що ми не будемо використовувати <code>&lt;-</code> для I/O дій, що не мають корисних результатів, як <code>putStrLn something</code>.</p></div>
<div class="paragraph"><p>Початківці іноді думають, що роблячи</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">name</span> <span class="k">=</span> <span class="n">getLine</span>
</pre></div></div></div>
<div class="paragraph"><p>буде читати з входу, та потім прикріпляти значення до <code>name</code>. Гаразд, так не буде, все що тут робиться це надання дії <code>getLine</code> іншого імені, а саме <code>name</code>. Пам'ятайте, щоб отримати значення від I/O дії, ми маємо виконати її в середині іншої I/O дії, через прикріплення її до імені за допомогою <code>&lt;-</code>.</p></div>
<div class="paragraph"><p>I/O дії будуть виконані лише тоді, якщо їм надано ім'я <code>main</code>, або коли вони всередині більшої I/O дії, що компонується за допомогою блоку <code>do</code>. Ми також можемо використати блок <code>do</code> для склеювання разом декількох I/O дій, і потім ми можемо використовувати цю I/O дію в іншому <code>do</code> блоці, і так далі. З іншого боку, всі вони будуть виконані тільки якщо вони з часом дійдуть до <code>main</code>.</p></div>
<div class="paragraph"><p>О, гаразд, існує ще один випадок, коли будуть виконані I/O дії. Коли ми набираємо I/O дію в GHCI та натискаємо <code>return</code>, це також буде виконане.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;HEEY&quot;</span>
<span class="nc">HEEY</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоч коли ми вводимо число або викликаємо функцію в GHCI і натискаємо <code>return</code>, це буде обчислене (здебільшого як це нам і треба), і потім викликає <code>show</code> на цьому, і потім це друкує рядок на терміналі, неявно викликаючи <code>putStrLn</code>.</p></div>
<div class="paragraph"><p>Пам'ятаєте прикріплення <code>let</code>? Якщо ні, оновіть вашу пам'ять щодо них в цьому розділі. Вони мають бути в формі <code>let</code> прикріплень в виразах, де прикріалення є іменами що будуть надані виразам, та вираз є вираз, що буде обчислений коли хтось бачить його. Ми також бачили його в осяжностях списків, де частина <code>in</code> непотрібна. Гаразд, ви можете використовувати їх в <code>do</code> блоках, майже так само, як ми використовуємо їх в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Data.Char</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">putStrLn</span> <span class="s">&quot;What&#39;s your first name?&quot;</span>
    <span class="n">firstName</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="s">&quot;What&#39;s your last name?&quot;</span>
    <span class="n">lastName</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">let</span> <span class="n">bigFirstName</span> <span class="k">=</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">firstName</span>
        <span class="n">bigLastName</span> <span class="k">=</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">lastName</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;hey &quot;</span> <span class="o">++</span> <span class="n">bigFirstName</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">bigLastName</span> <span class="o">++</span> <span class="s">&quot;, how are you?&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите, як підрівняні I/O дії в блоці <code>do</code>? Також зауважте, як <code>let</code> вирівняне разом з I/O діями і іменами <code>let</code>, вирівняними один з одним? Це гарна практика, бо відступи важливі в Haskell. Тепер: ми зробили <code>toUpper firstName</code>, що перетворює якесь <code>"John"</code> в значно крутіший рядок як <code>"JOHN"</code>. Ми прикріплюємо цей збільшений рядок до <code>name</code>, та потім використовуємо його в рядку нижче, коли друкуємо на термінал.</p></div>
<div class="paragraph"><p>Ви можете поцікавитись, коли використавувати <code>&lt;-</code>, та коли використовувати прикріплення <code>let</code>? Гаразд, пам'ятайте, що <code>&lt;-</code> є (поки що) для виконання I/O дій та прикріплення їх результатів до імен. Однак <code>map toUpper firstName</code> не є I/O дією. Це чистий вираз в Haskell. Так що використовуйте <code>&lt;-</code>, коли ви бажаєте прикріпити результати I/O дій до імен, і ви можете використовувати <code>let</code> для прикріалень чистих виразів до імен. Так що коли ми робимо дещо як <code>let firstName = getLine</code>, ми отримаємо лише нове ім'я для I/O дії <code>getLine</code>, і ми все ще маємо запустити її через <code>&lt;-</code>, щоб вона виконалась.</p></div>
<div class="paragraph"><p>Тепер ми збираємось зробити програму, що постійно читає рядок і друкує той самий рядок зі словами в зворотньому порядку. Виконання програми буде припинено, коли ми введемо порожній рядок. Ось програма:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="k">if</span> <span class="kc">null</span> <span class="n">line</span>
        <span class="n">then</span> <span class="k">return</span> <span class="o">()</span>
        <span class="k">else</span> <span class="k">do</span>
            <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">reverseWords</span> <span class="n">line</span>
            <span class="n">main</span>

<span class="n">reverseWords</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">reverseWords</span> <span class="k">=</span> <span class="n">unwords</span> <span class="o">.</span> <span class="n">map</span> <span class="n">reverse</span> <span class="o">.</span> <span class="n">words</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб отримати відчуття того, що вона робить, ви можете виконати її перед тим, як ми пройдемось по коду.</p></div>
<div class="paragraph"><p>Protip: Щоб виконати програму ви можете або скомпілювати її, та потім виконати отримий виконавчий файл, роблячи <code>ghc --make helloworld</code> та потім <code>./helloworld</code>, або ви можете використовувати команду <code>runhaskell</code> ось так: <code>runhaskell helloworld.hs</code> і ваша програма буде виконана на льоту.</p></div>
<div class="paragraph"><p>Спочатку давайте поглянемо на функцію <code>reverseWords</code>. Це тільки звичайна функція, що приймає рядок як <code>"hey there man"</code>, та потім викликає <code>words</code> для продукування списку слів як <code>["hey","there","man"]</code>. Потім ми <code>map reverse</code> на списку, отримуючи <code>["yeh","ereht","nam"]</code>, і потім ми знову покладаємо все це в один рядок, використовуючи <code>unwords</code>, і фінальний результат буде <code>"yeh ereht nam"</code>. Дивітья, як ми використовували композицію функцій. Без композиції функцій ми б мали написати щось як <code>reverseWords st = unwords (map reverse (words st))</code>.</p></div>
<div class="paragraph"><p>Що відносно <code>main</code>? Спершу ми отримуємо рядок з термінала, виконуючи виклик <code>getLine</code> що повертається в <code>line</code>. І тепер ми маємо условний вираз. Пам'ятайте, що в Haskell кожний <code>if</code> повинен мати відповідний <code>else</code>, оскільки кожний вираз повинен мати деякий різновид значення. Ми робимо <code>if</code>, так що коли умова <code>true</code> (в нашому випадку введений нами рядок порожній), ми виконуємо одну I/O дію, та коли ні - буде виконана інша I/O дія для <code>else</code>. Ось чому в блоці <code>I/O do</code>, <code>if</code> повинні мати форму <code>if умова then I/O дія else I/O дія</code>.</p></div>
<div class="paragraph"><p>Давайте спочатку поглянемо на те, що відбувається в частині <code>else</code>. Оскільки ми повинні мати саме одну I/O дію після <code>else</code>, ми використовуємо блок <code>do</code> для склеювання разом двох I/O дій в одну. Ви також можете записати цю частину таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">else</span> <span class="o">(</span><span class="k">do</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">reverseWords</span> <span class="n">line</span>
    <span class="n">main</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить більш наочним, що блок <code>do</code> має розгядатись як одна I/O дія, але це огидніше. В любому разі в блоці <code>do</code> ми викликаємо  <code>reverseWords</code> на рядку, що ми отрумуємо від <code>getLine</code>, та потім друкуємо це на терміналі. Після цього ми просто виконуємо <code>main</code>. Вона виключається рекурсивно і це гаразд, оскільки <code>main</code> сама є I/O дією. Так що в деякому сенсі ми повертаємось на початок програми.</p></div>
<div class="paragraph"><p>Тепер, що трапляється коли <code>null line</code> стає <code>true</code>? Це те, що в данному випадку виконується після <code>then</code>. Якщо ми подивимось, ми побачимо що виконується <code>then return ()</code>. Якщо ви візьмете імперативні мови, як C, Java або Python, ви можливо думаєте, що знаєте що робить цей <code>return</code>, так що є шанси, що ви перестрибнули цей доволі довгий параграф. Гаразд, ось як вам таке: <code>return</code> в Haskell насправді нічого подібного до <code>return</code> в більшості мов! Воно має те саме ім'я, що бентежить багато людей, але в реальності це досить інше. В імперативних мовах <code>return</code> звичайно закінчує виконання метода або процедури, і повідомляє про це деяким разновидом значення до викликаючої сторони. В Haskell (точніше в I/O діях), це виробляє I/O дію з чистого значення. Якщо ви подумаєте про аналогію бокса з попередніх розділів, це приймає значення і огортає його в бокс. Отримана I/O дія насправді нічого не робить, це просто це значення, оточене як його результат. Так що в контексті I/O <code>return "haha"</code> буде мати тип <code>IO String</code>. Який сенс в простому перетворенні чистого значення в I/O дію, що нічого не робить? Навіщо заплямовувати нашу програму в IO більше, ніж це мало би бути? Гаразд, нам треба деяка I/O дія, що треба видати в випадку порожнього вхідного рядка. Ось чому ми просто створили фіктивну I/O дію, дію що нічого не робить, написавши <code>return ()</code>.</p></div>
<div class="paragraph"><p>Використання <code>return</code> не спричиняє закінчення блоку <code>I/O do</code> в плані виконання, або будь чого подібного. Наприклад, ця програма буде досить щасливо продовжуватись весь час до останнього рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="k">return</span> <span class="o">()</span>
    <span class="k">return</span> <span class="s">&quot;HAHAHA&quot;</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="k">return</span> <span class="s">&quot;BLAH BLAH BLAH&quot;</span>
    <span class="k">return</span> <span class="mi">4</span>
    <span class="n">putStrLn</span> <span class="n">line</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі ці <code>return</code> роблять те, що вони створюють I/O дії, що насправді нічого не роблять, крім інкапсуляції результату, і цей результат відкидається геть, оскільки він не прив'язаний до імені. Ми можемо використовувати <code>return</code> в комбінації з <code>&lt;-</code> для прив'язки речей до імен.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="k">return</span> <span class="s">&quot;hell&quot;</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="k">return</span> <span class="s">&quot;yeah!&quot;</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите, <code>return</code> є різновидом протилежності до <code>&lt;-</code>. Тоді як  <code>return</code> бере значення і огортає його в бокс, <code>&lt;-</code> бере бокс (та виконує його), та отримує з нього значення, прикріплюючи його до імені. Але робити це є дещо надлишковим, особливо коли ви можете використовувати <code>let</code> прикріпленнях в <code>do</code> блоках до імен, десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">let</span> <span class="n">a</span> <span class="k">=</span> <span class="s">&quot;hell&quot;</span>
        <span class="n">b</span> <span class="k">=</span> <span class="s">&quot;yeah&quot;</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли маємо справу з блоками <code>I/O do</code>, ми в основному використовуємо <code>return</code> оба тому що нам треба створити I/O дію, що не робить нічого, або якщо ми не бажаємо, щоб I/O дія, створена з <code>do</code> блока, мала значення результата в своїй останній дії, але ми бажаємо, щоб він мав інше значення результата, так що ми використовуємо <code>return</code> для створення I/O дії, що завжди має заточеним наш бажаний результат, і ми покладаємо його в кінці.</p></div>
<div class="paragraph"><p>Блок <code>do</code> також може мати лише одну I/O дію. В цьому випадку це те саме, що просто записати I/O дію. Деякі люди можуть обрати запис <code>then do return ()</code> в цьому випадку, оскільки <code>else</code> також має <code>do</code>.</p></div>
<div class="paragraph"><p>Оскільки ми просуваємось до файлів, давайте поглянемо на деякі функції, що будуть корисні при справах з I/O.</p></div>
<div class="paragraph"><p><code>putStr</code> здебільшого як <code>putStrLn</code> в тому, що він бере рядок як параметр і повертає I/O дію, що буде друкувати цей рядок на терміналі, тільки <code>putStr</code> не перестрибує на новий рядок після друкування рядка, тоді як <code>putStrLn</code> робить це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>   <span class="n">putStr</span> <span class="s">&quot;Hey, &quot;</span>
            <span class="n">putStr</span> <span class="s">&quot;I&#39;m &quot;</span>
            <span class="n">putStrLn</span> <span class="s">&quot;Andy!&quot;</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">putstr_test</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Hey</span><span class="o">,</span> <span class="n">I</span><span class=" -Symbol">&#39;m</span> <span class="nc">Andy</span><span class="o">!</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Її сигнатура типу є `putStr 
</dt>
<dd>
<p>
String &#8594; IO () `, так що результат заточений в результуючій I/O дії є юніт. Дурне значення, так що немає сенсу прикріплювати його.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>putChar</code> бере символ та повертає I/O дію, що буде роздруковувати його на термінал.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>   <span class="n">putChar</span> <span class="sc">&#39;t&#39;</span>
            <span class="n">putChar</span> <span class="sc">&#39;e&#39;</span>
            <span class="n">putChar</span> <span class="sc">&#39;h&#39;</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">putchar_test</span><span class="o">.</span><span class="n">hs</span>
<span class="n">teh</span>
</pre></div></div></div>
<div class="paragraph"><p><code>putStr</code> насправді визначена рекурсивно за допомогою <code>putChar</code>. Гранична умова <code>putStr</code> є порожній рядок, так що якщо ми друкуємо порожній рядок, просто повертаємо I/O дію, що нічого не робить, використовуючи <code>return ()</code>. Якщо він не порожній, тоді друкуємо перший символ рядка, роблячи <code>putChar</code>, і потім друкуємо всі інші з використанням <code>putStr</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">putStr</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">putStr</span> <span class="o">[]</span> <span class="k">=</span> <span class="k">return</span> <span class="o">()</span>
<span class="n">putStr</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">xs</span><span class="o">)</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">putChar</span> <span class="n">x</span>
    <span class="n">putStr</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивіться, як ми можемо використовувати рекурсію в I/O, так само як ми можемо робити це в чистому коді. Так само як в чистому коді, ми визначаємо граничний випадок, і потім думаємо, чим насправді є результат. Це дія, що спочатку виводить перший символ, і потім виводить залишок рядка.</p></div>
<div class="paragraph"><p><code>print</code> бере значення любого типу, що є примірником <code>Show</code> (що означає, що ми знаємо як представляти його як рядок), викликає <code>show</code> з цім значенням для перетворення на рядок, і потім виводить цей рядок на термінал. В основному це просто <code>putStrLn . show</code>. Це спочатку виконує <code>show</code> на значенні, і потім подає його до <code>putStrLn</code>, що повертає I/O дію, що буде роздруковувати наше значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>   <span class="n">print</span> <span class="nc">True</span>
            <span class="n">print</span> <span class="mi">2</span>
            <span class="n">print</span> <span class="s">&quot;haha&quot;</span>
            <span class="n">print</span> <span class="mf">3.2</span>
            <span class="n">print</span> <span class="o">[</span><span class="err">3</span>,<span class="err">4</span>,<span class="err">3</span><span class="o">]</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">print_test</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">True</span>
<span class="mi">2</span>
<span class="s">&quot;haha&quot;</span>
<span class="mf">3.2</span>
<span class="o">[</span><span class="err">3</span>,<span class="err">4</span>,<span class="err">3</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, це дуже зручна функція. Згадайте, як ми казали про те, як I/O дії виконуються тільки коли вони підпадають до <code>main</code>, або коли ми намагаємось обчислити їх в підказці GHCI. Коли ми друкуємо значення (як <code>3</code> або <code>[1,2,3]</code>), та натискаємо клавішу <code>return</code>, GHCI насправді використовує <code>print</code> на цьому значенні для відображення його на терміналі!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">3</span>
<span class="mi">3</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="mi">3</span>
<span class="mi">3</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="o">(++</span><span class="s">&quot;!&quot;</span><span class="o">)</span> <span class="o">[</span><span class="err">&quot;</span><span class="kt">hey</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">ho</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">woo</span><span class="err">&quot;</span><span class="o">]</span>
<span class="o">[</span><span class="err">&quot;</span><span class="kt">hey!</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">ho!</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">woo!</span><span class="err">&quot;</span><span class="o">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">print</span> <span class="o">(</span><span class="n">map</span> <span class="o">(++</span><span class="s">&quot;!&quot;</span><span class="o">)</span> <span class="o">[</span><span class="err">&quot;</span><span class="kt">hey</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">ho</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">woo</span><span class="err">&quot;</span><span class="o">])</span>
<span class="o">[</span><span class="err">&quot;</span><span class="kt">hey!</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">ho!</span><span class="err">&quot;</span>,<span class="err">&quot;</span><span class="kt">woo!</span><span class="err">&quot;</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми бажаємо роздрукувати рядки, зазвичай ми використовуємо <code>putStrLn</code>, оскільки ми не бажаємо лапки навкруги, але для друку наших значень інших типів на термінал здебільшого використовується <code>print</code>.</p></div>
<div class="paragraph"><p><code>getChar</code> є I/O дією, що читає символ зі входу. Таким чином її сигнатура типу є <code>getChar ::IO Char</code>, оскільки результат, що міститься в I/O дії є <code>Char</code>. Зауважте, що через буферізацію читання символів насправді не буде відбуватись, доки користувач не начавить на клавішу вводу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">getChar</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">/=</span> <span class="sc">&#39; &#39;</span>
        <span class="n">then</span> <span class="k">do</span>
            <span class="n">putChar</span> <span class="n">c</span>
            <span class="n">main</span>
        <span class="k">else</span> <span class="k">return</span> <span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця програма виглядає так, що вона повинна читати символ, та перевіряти чи це проміжок. Якщо це так, виконання припиняється, та якщо ні - друкуємо його на терміналі, і потім робимо те саме спочатку і так далі. Гаразд, це робить щось подібне, тільки не в спосіб як ви можете це очікувати. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">runhaskell</span> <span class="n">getchar_test</span><span class="o">.</span><span class="n">hs</span>
<span class="n">hello</span> <span class="n">sir</span>
<span class="n">hello</span>
</pre></div></div></div>
<div class="paragraph"><p>Другий рядок є ввод. Ми вводимо <code>hello sir</code> і потім натискаємо ввод. Через буферізацію виконання програми буде починатись тільки після того, як ми натиснемо <code>return</code>, і не після кожного введеного символу. Але коли ми натиснемо ввод, це діє на тому, що було введено до цього. Спробуйте погратись з цією програмою щоб отримати відчуття як вона робить!</p></div>
<div class="paragraph"><p>Функцію <code>when</code> можна знайти в <code>Control.Monad</code> (щоб отримати до неї доступ зробіть <code>import Control.Monad</code>). Це цікаво, бо в блоці <code>do</code> це виглядає як твердження керування виконанням, але насправді це звичайна функція. Вона приймає логічне значення та I/O дію. Якщо це логічне значення є <code>True</code>, це повертає ту саму I/O дію, що ми надали туди. Однак якщо це <code>False</code>, вона повертає <code>return ()</code>, дію, так що  I/O дія нічого не робить. Ось як ми можемо переписати попередній шмат коду, де ми демонструємо <code>getChar</code> через використання <code>when</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Control.Monad</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">getChar</span>
    <span class="n">when</span> <span class="o">(</span><span class="n">c</span> <span class="o">/=</span> <span class="sc">&#39; &#39;</span><span class="o">)</span> <span class="n">$</span> <span class="k">do</span>
        <span class="n">putChar</span> <span class="n">c</span>
        <span class="n">main</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що, як ви можете бачити, це корисно для інкапсуляції шаблона <code>if something then do some I/O action else return ()</code>.</p></div>
<div class="paragraph"><p><code>sequence</code> бере список I/O дій і повертає I/O дії, що будуть виконувати ці дії, одна за одною. Результат, що міститься в цій I/O дії. буде списком результатів всіх I/O дій, що виконуються. Його сигнатура типу є <code>sequence ::[IO a] -&gt; IO [a]</code>. Роблячи це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">b</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">c</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">print</span> <span class="o">[</span><span class="kt">a</span>,<span class="kt">b</span>,<span class="kt">c</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>є те саме, що і наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">rs</span> <span class="k">&lt;-</span> <span class="n">sequence</span> <span class="o">[</span><span class="kt">getLine</span>, <span class="kt">getLine</span>, <span class="kt">getLine</span><span class="o">]</span>
    <span class="n">print</span> <span class="n">rs</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що <code>sequence [getLine, getLine, getLine]</code> створює I/O дію, що буде виконувати <code>getLine</code> три рази. Якщо ви прикріпите цю дію до імені, результатом є список з усіх результатів, так що в нашому випадку це список з трьох речей, які користувач вводить на підказку консолі.</p></div>
<div class="paragraph"><p>Загальний шаблон з <code>sequence</code> це коли ми відображуємо функції як  <code>print</code> або <code>putStrLn</code> на списки. Виконання <code>map print [1,2,3,4]</code> не створить I/O дію. Це створить сипсок I/O дій, оскільки це як написати <code>[print 1, print 2, print 3, print 4]</code>. Якщо ми бажаємо трансформувати цей список I/O дій в одну I/O дію, ми маємо створити послідовність.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">sequence</span> <span class="o">(</span><span class="n">map</span> <span class="n">print</span> <span class="o">[</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span>,<span class="err">4</span>,<span class="err">5</span><span class="o">])</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="mi">4</span>
<span class="mi">5</span>
<span class="o">[()</span>,<span class="o">()</span>,<span class="o">()</span>,<span class="o">()</span>,<span class="o">()]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що це за <code>[(),(),(),(),()]</code> в самому кінці? Гаразд, коли ми обчислюємо I/O дію в GHCI, вона виконується і потім друкується його результат, якщо результат не <code>()</code>, в якому випадку нічого не друкується. Ось чому обчислення <code>putStrLn "hehe"</code> в GHCI просто друкує <code>hehe</code> (оскільки результат що міститься в результаті <code>putStrLn "hehe"</code> в <code>()</code>). Але коли ми робимо <code>getLine</code> в GHCI, результат цієї I/O дії друкується, оскільки <code>getLine</code> має тип <code>IO String</code>.</p></div>
<div class="paragraph"><p>Оскільки відображення функції, що повертає I/O дію до списку, та потім створення послідовності по цьому, є таким загальним, що були введені функції <code>mapM</code> та <code>mapM_</code>. <code>mapM</code> бере функцію та список, відображує функцію на списку, та потім створює послідовність. <code>mapM_</code> робить те саме, тільки пізніше він закидає результат. Ми звичайно використовуємо <code>mapM_</code>, коли нам байдуже, який результат має наша послідовність I/O дій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">mapM</span> <span class="n">print</span> <span class="o">[</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span><span class="o">]</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
<span class="o">[()</span>,<span class="o">()</span>,<span class="o">()]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">mapM_</span> <span class="n">print</span> <span class="o">[</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span><span class="o">]</span>
<span class="mi">1</span>
<span class="mi">2</span>
<span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p><code>forever</code> бере I/O дію і повертає I/O дію, що просто повторює отриману I/O дію постійно. Вона розташована в <code>Control.Monad</code>. Ця невелика програма буде безкінечно запитувати користувача щодо деякого вводу, і віддавати його назад, ВЕЛИКИМИ ЛІТЕРАМИ:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Control.Monad</span>
<span class="k">import</span> <span class="nn">Data.Char</span>

<span class="n">main</span> <span class="k">=</span> <span class="n">forever</span> <span class="n">$</span> <span class="k">do</span>
    <span class="n">putStr</span> <span class="s">&quot;Give me some input: &quot;</span>
    <span class="n">l</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">l</span>
</pre></div></div></div>
<div class="paragraph"><p><code>forM</code> (розташована в <code>Control.Monad</code>) як <code>mapM</code>, тільки з переміненими параметрами. Перший параметр є списком, та другий є функція, по якій треба відображувати цей список, що потім перетворюється на послідовність. Чому це корисне? Гаразд, з деяким креативним застосуванням лямбди та <code>do</code> нотації ми можемо робити такі речі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Control.Monad</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">colors</span> <span class="k">&lt;-</span> <span class="n">forM</span> <span class="o">[</span><span class="err">1</span>,<span class="err">2</span>,<span class="err">3</span>,<span class="err">4</span><span class="o">]</span> <span class="o">(\</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="k">do</span>
        <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;Which color do you associate with the number &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;?&quot;</span>
        <span class="n">color</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
        <span class="k">return</span> <span class="n">color</span><span class="o">)</span>
    <span class="n">putStrLn</span> <span class="s">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>
    <span class="n">mapM</span> <span class="n">putStrLn</span> <span class="n">colors</span>
</pre></div></div></div>
<div class="paragraph"><p><code>(\a -&gt; do ... )</code> є функцією, що бере число і повертає I/O дію. Ми маємо оточити її в дужки, інакше лямбда подумає, що останні дві I/O дії належать до неї. Зауважте, що ми робимо <code>return color</code> всередині <code>do</code> блока. Ми робимо так, щоб I/O дія, яку визначає <code>do</code> блок, мала б результат кольору, що міститься в ній. Ми насправді не маємо робити це, оскільки <code>getLine</code> вже має те, що міститься в ній. Роблячи <code>color &lt;- getLine</code> та потім <code>return color</code> є проста розпаковка результату від <code>getLine</code>, та потім знову його розпаковка, так що це як просто зробити <code>getLine</code>. <code>forM</code> (викликана з її двома параметрами) продукує I/O дію, результат якої ми прикріплюємо до <code>colors</code>. <code>colors</code> є лише звичайний список, що містить рядки. В кінці ми друкуємо всі ці кольори, роблячи <code>mapM putStrLn colors</code>.</p></div>
<div class="paragraph"><p>Ви можете думати про <code>forM</code> в такому сенсі: створити I/O для кожного елементу в цьому списку. Що кожна I/O дія буде робити залежить від елемента, що була використана для створення дії. Нарешті виконаємо ці дії та прикріпимо результат до чогось. Ми не маємо прикріплювати будь-що, так що ми можемо також відкинути це геть.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">runhaskell</span> <span class="n">form_test</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Which</span> <span class="n">color</span> <span class="k">do</span> <span class="n">you</span> <span class="n">associate</span> <span class="k">with</span> <span class="n">the</span> <span class="n">number</span> <span class="mi">1</span><span class="o">?</span>
<span class="n">white</span>
<span class="nc">Which</span> <span class="n">color</span> <span class="k">do</span> <span class="n">you</span> <span class="n">associate</span> <span class="k">with</span> <span class="n">the</span> <span class="n">number</span> <span class="mi">2</span><span class="o">?</span>
<span class="n">blue</span>
<span class="nc">Which</span> <span class="n">color</span> <span class="k">do</span> <span class="n">you</span> <span class="n">associate</span> <span class="k">with</span> <span class="n">the</span> <span class="n">number</span> <span class="mi">3</span><span class="o">?</span>
<span class="n">red</span>
<span class="nc">Which</span> <span class="n">color</span> <span class="k">do</span> <span class="n">you</span> <span class="n">associate</span> <span class="k">with</span> <span class="n">the</span> <span class="n">number</span> <span class="mi">4</span><span class="o">?</span>
<span class="n">orange</span>
<span class="nc">The</span> <span class="n">colors</span> <span class="n">that</span> <span class="n">you</span> <span class="n">associate</span> <span class="k">with</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span> <span class="n">and</span> <span class="mi">4</span> <span class="n">are</span><span class="k">:</span>
<span class="kt">white</span>
<span class="n">blue</span>
<span class="n">red</span>
<span class="n">orange</span>
</pre></div></div></div>
<div class="paragraph"><p>Насправді ми можемо зробити це без <code>forM</code>, але з <code>forM</code> це більш читабельне. Звичайно ми пишемо <code>forM</code> коли ми бажаємо зробити <code>map</code> та <code>sequence</code> деяких дій, що ми визначили тут на місці за допомогою <code>do</code> нотації. В тому ж ключі ми можемо замінити останній рядок на <code>forM colors putStrLn</code>.</p></div>
<div class="paragraph"><p>В цьому розділі ми навчились основам вводу та виводу. Ми також з'ясували що таке I/O дії, як вони дозволяють нам вводити та виводити рядки, та коли вони насправді виконуються. Для повтору: I/O дії є значення, здебільшого як любі інші значення в Haskell. Ми можемо передавати їх як параметри до функцій, та функції можуть повертати I/O дії як результати. Що особливе щодо них, це якщо вони підпадають в функцію <code>main</code> (або є результат в рядку GHCI), вони виконуються. І ось тоді вони починають писати дещо на вашому екрані, або грають Yakety Sax в ваших гучномовцях. Кожна I/O дія також може інкапсулювати результат з тим, що ви бажаєте отримати від зовнішнього світу.</p></div>
<div class="paragraph"><p>Не думайте про функцію як <code>putStrLn</code> як про функцію, що бере рядок і друкує його на екрані. Думайте про це, як про функцію, що бере рядок та повертає I/O дію. Ця I/O дія буде, коли виконана, друкувати прекрасні вірші на вашому терміналі.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Файли та потоки</h3>
<div class="paragraph"><p><span class="image">
<img src="images/streams.png" alt="images/streams.png" />
</span>
<code>getChar</code> є I/O дія, що читає поодинокий символ з терміналу. <code>getLine</code> є I/O дія, що читає рядок з терміналу. Вони обоє досить прямолінійні, і більшість мов програмування мають деякі функції або твердження, що відповідають до них. Але тепер давайте познайомимось з <code>getContents</code>. <code>getContents</code> є I/O дія, що читає все зі стандартного вводу, доки не зустріне символ кінця файлу. Її тип <code>getContents ::IO String</code>. Що круте щодо <code>getContents</code>, це те що вона робить ліниве I/O. Коли ми робимо <code>foo &lt;- getContents</code>, вона не читає все і одразу, зберігає в пам'яті і потім прикріплює до <code>foo</code>. Ні, вона лінива! Вона каже: "Так так, я прочитаю вхідні дані з терміналу пізніше як ми дійдемо до цього, коли нам це дійсно знадобиться!".</p></div>
<div class="paragraph"><p><code>getContents</code> є дійсно корисним, коли ми перенаправляємо вихід однієї програми на вхід нашої програми. В випадку, якщо ви не знаєте, як робить перенаправлення в юнікс системах, ось швидке пояснення. Давайте створимо текстовий файл, що містить наступне маленьке хайку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>I'm a lil' teapot
What's with that airplane food, huh?
It's so small, tasteless</code></pre>
</div></div>
<div class="paragraph"><p>Так, хайку поганеньке, що з того? Якщо хтось знає гарні туторіали по хайку - дайте мені знати.</p></div>
<div class="paragraph"><p>Тепер згадайте маленьку програму, яку ми писали коли вводили функцію <code>forever</code>. Якщо запитати користувача ввести рядок, він повертається ВЕЛИКИМИ ЛІТЕРАМИ, і потім все починається спочатку, без кінця. Тільки ви не маєте прогортати весь час назад, ось те саме ще раз:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Control.Monad</span>
<span class="k">import</span> <span class="nn">Data.Char</span>

<span class="n">main</span> <span class="k">=</span> <span class="n">forever</span> <span class="n">$</span> <span class="k">do</span>
    <span class="n">putStr</span> <span class="s">&quot;Give me some input: &quot;</span>
    <span class="n">l</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">map</span> <span class="n">toUpper</span> <span class="n">l</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми зберіжемо цю програму як <code>capslocker.hs</code> або якось інакше, і скомпілюємо її. І потім ми збираємось використати юнікс конвеєр, щоб скормити наш текстовий файл напряму в нашу маленьку програму. Ми збираємось використати допомогу програми GNU <code>cat</code>, що роздруковує файл, переданий їй як аргумент. Перевір це!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ghc --make capslocker
<span class="o">[</span><span class="m">1</span> of <span class="m">1</span><span class="o">]</span> Compiling Main             <span class="o">(</span> capslocker.hs, capslocker.o <span class="o">)</span>
Linking capslocker ...
$ cat haiku.txt
I<span class="s1">&#39;m a lil&#39;</span> teapot
What<span class="s1">&#39;s with that airplane food, huh?</span>
<span class="s1">It&#39;</span>s so small, tasteless
$ cat haiku.txt <span class="p">|</span> ./capslocker
I<span class="s1">&#39;M A LIL&#39;</span> TEAPOT
WHAT<span class="s1">&#39;S WITH THAT AIRPLANE FOOD, HUH?</span>
<span class="s1">IT&#39;</span>S SO SMALL, TASTELESS
capslocker &lt;stdin&gt;: hGetLine: end of file
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, перенаправлення виходу однієї програми (в нашому випадку це була <code>cat</code>) на вхід іншої (<code>capslocker</code>) робиться символом <code>|</code>. Те що ми зробили доволі еквівалентне до простого виконання <code>capslocker</code>, друкування нашого хайку на терміналі і потім ввод символа кінця файла (це звичайно робиться натисканням <code>Ctrl-D</code>). Це як виконати <code>cat haiku.txt</code> і сказати: “Зачекай, не друкуй це на термінал, замість цього скажи це <code>capslocker</code>!”.</p></div>
<div class="paragraph"><p>Те, що ми в основному робимо за допомогою <code>forever</code>, це прийняти вхід і перетворити його в деякий вихід. Ось чому ми можемо використати <code>getContents</code>, щоб зробити нашу програму навіть коротше та краще:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">Data.Char</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">getContents</span>
    <span class="n">putStr</span> <span class="o">(</span><span class="n">map</span> <span class="n">toUpper</span> <span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми виконуємо I/O дію <code>getContents</code>, і називаємо рядок, який вона продукує, <code>contents</code>. Потім ми робимо <code>map toUpper</code> по цьому рядку і друкуємо це на термінал. Майте на увазі, що оскільки рядки в основному списки, що є лінивими, і <code>getContents</code> є лінивим I/O, вона не буде читати весь вміст одночасно, і зберігати його в пам'яті перед роздруковки збільшенної версії. Скоріше вона буде роздруковувати збільшену версію по мірі читання, оскільки вона буде читати лише один рядок з входу, коли це буде дійсно треба.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ cat haiku.txt <span class="p">|</span> ./capslocker
I<span class="s1">&#39;M A LIL&#39;</span> TEAPOT
WHAT<span class="s1">&#39;S WITH THAT AIRPLANE FOOD, HUH?</span>
<span class="s1">IT&#39;</span>S SO SMALL, TASTELESS
</pre></div></div></div>
<div class="paragraph"><p>Круто, це робить. Що коли ми просто виконаємо <code>capslocker</code> і спробуємо набрати рядки самотужки?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="o">./</span><span class="n">capslocker</span>
<span class="n">hey</span> <span class="n">ho</span>
<span class="nc">HEY</span> <span class="nc">HO</span>
<span class="n">lets</span> <span class="n">go</span>
<span class="nc">LETS</span> <span class="nc">GO</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми виходимо з цього натискаючи <code>Ctrl-D</code>. Доволі мило! Як ви можете бачити, це друкує наш збільшений вхід, рядок за рядком. Коли результат <code>getContents</code> прикріплений до <code>contents</code>, він не представлений в пам'яті як справжній рядок, але більше як проміс, що з часом спродукує рядок. Коли ми робимо <code>map toUpper</code> на <code>contents</code>, це також проміс відобразити цю функцію по колись створеному  <code>contents</code>. І нарешті коли трапляється <code>putStr</code>, він каже попередньому промісу: "Хей, мені треба збільшений рядок!". Це все ще не має рядків, так що він каже до <code>contents</code>: "Хей, як щодо дійсно отримати рядок з терміналу?". І вже тоді <code>getContents</code> насправді читає з терміналу, і повертає рядок до коду, що запитував його, що спродукувати дещо цікаве. Цей код потім відображує <code>toUpper</code> по цьому рядку та видає це до <code>putStr</code>, що друкує його. І потім <code>putStr</code> каже: "Хей, мені треба наступний рядок, ворушись!", і це повторюється доки не буде більше вводу, що втілюється в вигляді символу кінця файла.</p></div>
<div class="paragraph"><p>Давайте створимо програму, що бере деякий ввод, і друкує тільки ті рядки, що коротше десяти символів. Дослідимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">getContents</span>
    <span class="n">putStr</span> <span class="o">(</span><span class="n">shortLinesOnly</span> <span class="n">contents</span><span class="o">)</span>

<span class="n">shortLinesOnly</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">shortLinesOnly</span> <span class="n">input</span> <span class="k">=</span>
    <span class="n">let</span> <span class="n">allLines</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">input</span>
        <span class="n">shortLines</span> <span class="k">=</span> <span class="n">filter</span> <span class="o">(\</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="n">allLines</span>
        <span class="n">result</span> <span class="k">=</span> <span class="n">unlines</span> <span class="n">shortLines</span>
    <span class="n">in</span>  <span class="n">result</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми створили нашу I/O частину нашої програми такою короткою, як це можливо. Оскільки наша програма передбачає прийняття деякого вводу і друк деякого виводу на основі цього вводу, ми можемо реалізувати її через читання вмісту вводу, виконання функції на ньому, та потім друк того, що повертає функція.</p></div>
<div class="paragraph"><p>Функція <code>shortLinesOnly</code> робить саме так: вона приймає рядок, як <code>"short\nlooooooooooooooong\nshort again"</code>. Цей рядок має три рядка, два з них короткі, і середня довга. Вона виконує на цьому рядку функцію <code>lines</code>, що конвертує її на <code>["short", "looooooooooooooong", "short again"]</code>, що потім прикріплюється до імені <code>allLines</code>. Цей список рядків потім фільтрується, так що в списку залишаються лише рядки коротші десяти символів, продукуючи <code>["short", "short again"]</code>. І нарешті <code>unlines</code> поєднує список в єдиний рядок обмежений  <code>newline</code>, даючи <code>"short\nshort again"</code>. Давайте дамо цьому ход.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>i'm short
so am i
i am a loooooooooong line!!!
yeah i'm long so what hahahaha!!!!!!
short line
loooooooooooooooooooooooooooong
short
$ ghc --make shortlinesonly
[1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
Linking shortlinesonly ...
$ cat shortlines.txt | ./shortlinesonly
i'm short
so am i
short</code></pre>
</div></div>
<div class="paragraph"><p>We pipe the contents of shortlines.txt into the output of shortlinesonly and as the output, we only get the short lines.</p></div>
<div class="paragraph"><p>This pattern of getting some string from the input, transforming it with a function and then outputting that is so common that there exists a function which makes that even easier, called interact. interact takes a function of type String &#8594; String as a parameter and returns an I/O action that will take some input, run that function on it and then print out the function&#8217;s result. Let&#8217;s modify our program to use that.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="n">interact</span> <span class="n">shortLinesOnly</span>

<span class="n">shortLinesOnly</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">shortLinesOnly</span> <span class="n">input</span> <span class="k">=</span>
    <span class="n">let</span> <span class="n">allLines</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">input</span>
        <span class="n">shortLines</span> <span class="k">=</span> <span class="n">filter</span> <span class="o">(\</span><span class="n">line</span> <span class="o">-&gt;</span> <span class="n">length</span> <span class="n">line</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span> <span class="n">allLines</span>
        <span class="n">result</span> <span class="k">=</span> <span class="n">unlines</span> <span class="n">shortLines</span>
    <span class="n">in</span>  <span class="n">result</span>
</pre></div></div></div>
<div class="paragraph"><p>Just to show that this can be achieved in much less code (even though it will be less readable) and to demonstrate our function composition skill, we&#8217;re going to rework that a bit further.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="n">interact</span> <span class="n">$</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">filter</span> <span class="o">((&lt;</span><span class="mi">10</span><span class="o">)</span> <span class="o">.</span> <span class="n">length</span><span class="o">)</span> <span class="o">.</span> <span class="n">lines</span>
</pre></div></div></div>
<div class="paragraph"><p>Wow, we actually reduced that to just one line, which is pretty cool!</p></div>
<div class="paragraph"><p><code>interact</code> can be used to make programs that are piped some contents into them and then dump some result out or it can be used to make programs that appear to take a line of input from the user, give back some result based on that line and then take another line and so on. There isn&#8217;t actually a real distinction between the two, it just depends on how the user is supposed to use them.</p></div>
<div class="paragraph"><p>Let&#8217;s make a program that continuously reads a line and then tells us if the line is a palindrome or not. We could just use getLine to read a line, tell the user if it&#8217;s a palindrome and then run main all over again. But it&#8217;s simpler if we use interact. When using interact, think about what you need to do to transform some input into the desired output. In our case, we have to replace each line of the input with either "palindrome" or "not a palindrome". So we have to write a function that transforms something like "elephant\nABCBA\nwhatever" into "not a palindrome\npalindrome\nnot a palindrome". Let&#8217;s do this!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">respondPalindromes</span> <span class="n">contents</span> <span class="k">=</span> <span class="n">unlines</span> <span class="o">(</span><span class="n">map</span> <span class="o">(\</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="n">then</span> <span class="s">&quot;palindrome&quot;</span> <span class="k">else</span> <span class="s">&quot;not a palindrome&quot;</span><span class="o">)</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span>
    <span class="n">where</span>   <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="k">=</span> <span class="n">xs</span> <span class="o">==</span> <span class="n">reverse</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Let&#8217;s write this in point-free.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">respondPalindromes</span> <span class="k">=</span> <span class="n">unlines</span> <span class="o">.</span> <span class="n">map</span> <span class="o">(\</span><span class="n">xs</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="n">then</span> <span class="s">&quot;palindrome&quot;</span> <span class="k">else</span> <span class="s">&quot;not a palindrome&quot;</span><span class="o">)</span> <span class="o">.</span> <span class="n">lines</span>
    <span class="n">where</span>   <span class="n">isPalindrome</span> <span class="n">xs</span> <span class="k">=</span> <span class="n">xs</span> <span class="o">==</span> <span class="n">reverse</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Pretty straightforward. First it turns something like <code>"elephant\nABCBA\nwhatever"</code> into ["elephant", "ABCBA", "whatever"] and then it maps that lambda over it, giving ["not a palindrome", "palindrome", "not a palindrome"] and then unlines joins that list into a single, newline delimited string. Now we can do</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="n">interact</span> <span class="n">respondPalindromes</span>
</pre></div></div></div>
<div class="paragraph"><p>Let&#8217;s test this out:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ runhaskell palindromes.hs
hehe
not a palindrome
ABCBA
palindrome
cookie
not a palindrome
</pre></div></div></div>
<div class="paragraph"><p>Even though we made a program that transforms one big string of input into another, it acts like we made a program that does it line by line. That&#8217;s because Haskell is lazy and it wants to print the first line of the result string, but it can&#8217;t because it doesn&#8217;t have the first line of the input yet. So as soon as we give it the first line of input, it prints the first line of the output. We get out of the program by issuing an end-of-line character.</p></div>
<div class="paragraph"><p>We can also use this program by just piping a file into it. Let&#8217;s say we have this file:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>dogaroo
radar
rotor
madam</code></pre>
</div></div>
<div class="paragraph"><p>and we save it as words.txt. This is what we get by piping it into our program:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ cat words.txt <span class="p">|</span> runhaskell palindromes.hs
not a palindrome
palindrome
palindrome
palindrome
</pre></div></div></div>
<div class="paragraph"><p>Again, we get the same output as if we had run our program and put in the words ourselves at the standard input. We just don&#8217;t see the input that palindromes.hs because the input came from the file and not from us typing the words in.</p></div>
<div class="paragraph"><p>So now you probably see how lazy I/O works and how we can use it to our advantage. You can just think in terms of what the output is supposed to be for some given input and write a function to do that transformation. In lazy I/O, nothing is eaten from the input until it absolutely has to be because what we want to print right now depends on that input.</p></div>
<div class="paragraph"><p>So far, we&#8217;ve worked with I/O by printing out stuff to the terminal and reading from it. But what about reading and writing files? Well, in a way, we&#8217;ve already been doing that. One way to think about reading from the terminal is to imagine that it&#8217;s like reading from a (somewhat special) file. Same goes for writing to the terminal, it&#8217;s kind of like writing to a file. We can call these two files stdout and stdin, meaning standard output and standard input, respectively. Keeping that in mind, we&#8217;ll see that writing to and reading from files is very much like writing to the standard output and reading from the standard input.</p></div>
<div class="paragraph"><p>We&#8217;ll start off with a really simple program that opens a file called girlfriend.txt, which contains a verse from Avril Lavigne&#8217;s #1 hit Girlfriend, and just prints out out to the terminal. Here&#8217;s girlfriend.txt:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hey! Hey! You! You!
I don't like your girlfriend!
No way! No way!
I think you need a new one!</code></pre>
</div></div>
<div class="paragraph"><p>And here&#8217;s our program:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">handle</span> <span class="k">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;girlfriend.txt&quot;</span> <span class="nc">ReadMode</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="n">putStr</span> <span class="n">contents</span>
    <span class="n">hClose</span> <span class="n">handle</span>
</pre></div></div></div>
<div class="paragraph"><p>Running it, we get the expected result:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ runhaskell girlfriend.hs
Hey! Hey! You! You!
I don<span class="err">&#39;</span>t like your girlfriend!
No way! No way!
I think you need a new one!
</pre></div></div></div>
<div class="paragraph"><p>Let&#8217;s go over this line by line. The first line is just four exclamations, to get our attention. In the second line, Avril tells us that she doesn&#8217;t like our current romantic partner. The third line serves to emphasize that disapproval, whereas the fourth line suggests we should seek out a new girlfriend.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Let&#8217;s also go over the program line by line! Our program is several I/O actions glued together with a do block. In the first line of the do block, we notice a new function called openFile. This is its type signature: openFile 
</dt>
<dd>
<p>
FilePath &#8594; IOMode &#8594; IO Handle. If you read that out loud, it states: openFile takes a file path and an IOMode and returns an I/O action that will open a file and have the file&#8217;s associated handle encapsulated as its result.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>FilePath is just a type synonym for String, simply defined as:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">type</span> <span class="kt">FilePath</span> <span class="o">=</span> <span class="nc">String</span>
<span class="nc">IOMode</span> <span class="n">is</span> <span class="n">a</span> <span class="k">type</span> <span class="kt">that</span><span class="err">&#39;</span><span class="kt">s</span> <span class="kt">defined</span> <span class="kt">like</span> <span class="kt">this:</span>

<span class="n">data</span> <span class="nc">IOMode</span> <span class="k">=</span> <span class="nc">ReadMode</span> <span class="o">|</span> <span class="nc">WriteMode</span> <span class="o">|</span> <span class="nc">AppendMode</span> <span class="o">|</span> <span class="nc">ReadWriteMode</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/file.png" alt="images/file.png" />
</span>
Just like our type that represents the seven possible values for the days of the week, this type is an enumeration that represents what we want to do with our opened file. Very simple. Just note that this type is IOMode and not IO Mode. IO Mode would be the type of an I/O action that has a value of some type Mode as its result, but IOMode is just a simple enumeration.</p></div>
<div class="paragraph"><p>Finally, it returns an I/O action that will open the specified file in the specified mode. If we bind that action to something we get a Handle. A value of type Handle represents where our file is. We&#8217;ll use that handle so we know which file to read from. It would be stupid to read a file but not bind that read to a handle because we wouldn&#8217;t be able to do anything with the file. So in our case, we bound the handle to handle.</p></div>
<div class="paragraph"><p>In the next line, we see a function called hGetContents. It takes a Handle, so it knows which file to get the contents from and returns an IO String — an I/O action that holds as its result the contents of the file. This function is pretty much like getContents. The only difference is that getContents will automatically read from the standard input (that is from the terminal), whereas hGetContents takes a file handle which tells it which file to read from. In all other respects, they work the same. And just like getContents, hGetContents won&#8217;t attempt to read the file at once and store it in memory, but it will read it as needed. That&#8217;s really cool because we can treat contents as the whole contents of the file, but it&#8217;s not really loaded in memory. So if this were a really huge file, doing hGetContents wouldn&#8217;t choke up our memory, but it would read only what it needed to from the file, when it needed to.</p></div>
<div class="paragraph"><p>Note the difference between the handle used to identify a file and the contents of the file, bound in our program to handle and contents. The handle is just something by which we know what our file is. If you imagine your whole file system to be a really big book and each file is a chapter in the book, the handle is a bookmark that shows where you&#8217;re currently reading (or writing) a chapter, whereas the contents are the actual chapter.</p></div>
<div class="paragraph"><p>With putStr contents we just print the contents out to the standard output and then we do hClose, which takes a handle and returns an I/O action that closes the file. You have to close the file yourself after opening it with openFile!</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Another way of doing what we just did is to use the withFile function, which has a type signature of withFile 
</dt>
<dd>
<p>
FilePath &#8594; IOMode &#8594; (Handle &#8594; IO a) &#8594; IO a. It takes a path to a file, an IOMode and then it takes a function that takes a handle and returns some I/O action. What it returns is an I/O action that will open that file, do something we want with the file and then close it. The result encapsulated in the final I/O action that&#8217;s returned is the same as the result of the I/O action that the function we give it returns. This might sound a bit complicated, but it&#8217;s really simple, especially with lambdas, here&#8217;s our previous example rewritten to use withFile:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">withFile</span> <span class="s">&quot;girlfriend.txt&quot;</span> <span class="nc">ReadMode</span> <span class="o">(\</span><span class="n">handle</span> <span class="o">-&gt;</span> <span class="k">do</span>
        <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>As you can see, it&#8217;s very similar to the previous piece of code. (\handle &#8594; &#8230; ) is the function that takes a handle and returns an I/O action and it&#8217;s usually done like this, with a lambda. The reason it has to take a function that returns an I/O action instead of just taking an I/O action to do and then close the file is because the I/O action that we&#8217;d pass to it wouldn&#8217;t know on which file to operate. This way, withFile opens the file and then passes the handle to the function we gave it. It gets an I/O action back from that function and then makes an I/O action that&#8217;s just like it, only it closes the file afterwards. Here&#8217;s how we can make our own withFile function:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">withFile</span><span class="err">&#39;</span> <span class="o">::</span> <span class="nc">FilePath</span> <span class="o">-&gt;</span> <span class="nc">IOMode</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Handle</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="n">a</span>
<span class="n">withFile</span><span class="err">&#39;</span> <span class="n">path</span> <span class="n">mode</span> <span class="n">f</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">handle</span> <span class="k">&lt;-</span> <span class="n">openFile</span> <span class="n">path</span> <span class="n">mode</span>
    <span class="n">result</span> <span class="k">&lt;-</span> <span class="n">f</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="n">butter</span> <span class="n">toast</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/edd.png" alt="images/edd.png" />
</span>
We know the result will be an I/O action so we can just start off with a do. First we open the file and get a handle from it. Then, we apply handle to our function to get back the I/O action that does all the work. We bind that action to result, close the handle and then do return result. By returning the result encapsulated in the I/O action that we got from f, we make it so that our I/O action encapsulates the same result as the one we got from f handle. So if f handle returns an action that will read a number of lines from the standard input and write them to a file and have as its result encapsulated the number of lines it read, if we used that with withFile', the resulting I/O action would also have as its result the number of lines read.</p></div>
<div class="paragraph"><p>Just like we have hGetContents that works like getContents but for a specific file, there&#8217;s also hGetLine, hPutStr, hPutStrLn, hGetChar, etc. They work just like their counterparts without the h, only they take a handle as a parameter and operate on that specific file instead of operating on standard input or standard output. Example: putStrLn is a function that takes a string and returns an I/O action that will print out that string to the terminal and a newline after it. hPutStrLn takes a handle and a string and returns an I/O action that will write that string to the file associated with the handle and then put a newline after it. In the same vein, hGetLine takes a handle and returns an I/O action that reads a line from its file.</p></div>
<div class="paragraph"><p>Loading files and then treating their contents as strings is so common that we have these three nice little functions to make our work even easier:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
readFile has a type signature of readFile 
</dt>
<dd>
<p>
FilePath &#8594; IO String. Remember, FilePath is just a fancy name for String. readFile takes a path to a file and returns an I/O action that will read that file (lazily, of course) and bind its contents to something as a string. It&#8217;s usually more handy than doing openFile and binding it to a handle and then doing hGetContents. Here&#8217;s how we could have written our previous example with readFile:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;girlfriend.txt&quot;</span>
    <span class="n">putStr</span> <span class="n">contents</span>
</pre></div></div></div>
<div class="paragraph"><p>Because we don&#8217;t get a handle with which to identify our file, we can&#8217;t close it manually, so Haskell does that for us when we use readFile.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
writeFile has a type of writeFile 
</dt>
<dd>
<p>
FilePath &#8594; String &#8594; IO (). It takes a path to a file and a string to write to that file and returns an I/O action that will do the writing. If such a file already exists, it will be stomped down to zero length before being written on. Here&#8217;s how to turn girlfriend.txt into a CAPSLOCKED version and write it to girlfriendcaps.txt:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">Data.Char</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="s">&quot;girlfriend.txt&quot;</span>
    <span class="n">writeFile</span> <span class="s">&quot;girlfriendcaps.txt&quot;</span> <span class="o">(</span><span class="n">map</span> <span class="n">toUpper</span> <span class="n">contents</span><span class="o">)</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">girlfriendtocaps</span><span class="o">.</span><span class="n">hs</span>
<span class="n">$</span> <span class="n">cat</span> <span class="n">girlfriendcaps</span><span class="o">.</span><span class="n">txt</span>
<span class="nc">HEY</span><span class="o">!</span> <span class="nc">HEY</span><span class="o">!</span> <span class="nc">YOU</span><span class="o">!</span> <span class="nc">YOU</span><span class="o">!</span>
<span class="n">I</span> <span class="nc">DON</span><span class=" -Symbol">&#39;T</span> <span class="nc">LIKE</span> <span class="nc">YOUR</span> <span class="nc">GIRLFRIEND</span><span class="o">!</span>
<span class="nc">NO</span> <span class="nc">WAY</span><span class="o">!</span> <span class="nc">NO</span> <span class="nc">WAY</span><span class="o">!</span>
<span class="n">I</span> <span class="nc">THINK</span> <span class="nc">YOU</span> <span class="nc">NEED</span> <span class="n">A</span> <span class="nc">NEW</span> <span class="nc">ONE</span><span class="o">!</span>
</pre></div></div></div>
<div class="paragraph"><p><code>appendFile</code> has a type signature that&#8217;s just like writeFile, only appendFile doesn&#8217;t truncate the file to zero length if it already exists but it appends stuff to it.</p></div>
<div class="paragraph"><p>Let&#8217;s say we have a file todo.txt that has one task per line that we have to do. Now let&#8217;s make a program that takes a line from the standard input and adds that to our to-do list.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">todoItem</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">appendFile</span> <span class="s">&quot;todo.txt&quot;</span> <span class="o">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;\n&quot;</span><span class="o">)</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">appendtodo</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Iron</span> <span class="n">the</span> <span class="n">dishes</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">appendtodo</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Dust</span> <span class="n">the</span> <span class="n">dog</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">appendtodo</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>
<span class="n">$</span> <span class="n">cat</span> <span class="n">todo</span><span class="o">.</span><span class="n">txt</span>
<span class="nc">Iron</span> <span class="n">the</span> <span class="n">dishes</span>
<span class="nc">Dust</span> <span class="n">the</span> <span class="n">dog</span>
<span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>
</pre></div></div></div>
<div class="paragraph"><p>We needed to add the "\n" to the end of each line because getLine doesn&#8217;t give us a newline character at the end.</p></div>
<div class="paragraph"><p>Ooh, one more thing. We talked about how doing contents &#8592; hGetContents handle doesn&#8217;t cause the whole file to be read at once and stored in-memory. It&#8217;s I/O lazy, so doing this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">withFile</span> <span class="s">&quot;something.txt&quot;</span> <span class="nc">ReadMode</span> <span class="o">(\</span><span class="n">handle</span> <span class="o">-&gt;</span> <span class="k">do</span>
        <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>is actually like connecting a pipe from the file to the output. Just like you can think of lists as streams, you can also think of files as streams. This will read one line at a time and print it out to the terminal as it goes along. So you may be asking, how wide is this pipe then? How often will the disk be accessed? Well, for text files, the default buffering is line-buffering usually. That means that the smallest part of the file to be read at once is one line. That&#8217;s why in this case it actually reads a line, prints it to the output, reads the next line, prints it, etc. For binary files, the default buffering is usually block-buffering. That means that it will read the file chunk by chunk. The chunk size is some size that your operating system thinks is cool.</p></div>
<div class="paragraph"><p>You can control how exactly buffering is done by using the hSetBuffering function. It takes a handle and a BufferMode and returns an I/O action that sets the buffering. BufferMode is a simple enumeration data type and the possible values it can hold are: NoBuffering, LineBuffering or BlockBuffering (Maybe Int). The Maybe Int is for how big the chunk should be, in bytes. If it&#8217;s Nothing, then the operating system determines the chunk size. NoBuffering means that it will be read one character at a time. NoBuffering usually sucks as a buffering mode because it has to access the disk so much.</p></div>
<div class="paragraph"><p>Here&#8217;s our previous piece of code, only it doesn&#8217;t read it line by line but reads the whole file in chunks of 2048 bytes.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">withFile</span> <span class="s">&quot;something.txt&quot;</span> <span class="nc">ReadMode</span> <span class="o">(\</span><span class="n">handle</span> <span class="o">-&gt;</span> <span class="k">do</span>
        <span class="n">hSetBuffering</span> <span class="n">handle</span> <span class="n">$</span> <span class="nc">BlockBuffering</span> <span class="o">(</span><span class="nc">Just</span> <span class="mi">2048</span><span class="o">)</span>
        <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
        <span class="n">putStr</span> <span class="n">contents</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Reading files in bigger chunks can help if we want to minimize disk access or when our file is actually a slow network resource.</p></div>
<div class="paragraph"><p>We can also use hFlush, which is a function that takes a handle and returns an I/O action that will flush the buffer of the file associated with the handle. When we&#8217;re doing line-buffering, the buffer is flushed after every line. When we&#8217;re doing block-buffering, it&#8217;s after we&#8217;ve read a chunk. It&#8217;s also flushed after closing a handle. That means that when we&#8217;ve reached a newline character, the reading (or writing) mechanism reports all the data so far. But we can use hFlush to force that reporting of data that has been read so far. After flushing, the data is available to other programs that are running at the same time.</p></div>
<div class="paragraph"><p>Think of reading a block-buffered file like this: your toilet bowl is set to flush itself after it has one gallon of water inside it. So you start pouring in water and once the gallon mark is reached, that water is automatically flushed and the data in the water that you&#8217;ve poured in so far is read. But you can flush the toilet manually too by pressing the button on the toilet. This makes the toilet flush and all the water (data) inside the toilet is read. In case you haven&#8217;t noticed, flushing the toilet manually is a metaphor for hFlush. This is not a very great analogy by programming analogy standards, but I wanted a real world object that can be flushed for the punchline.</p></div>
<div class="paragraph"><p>We already made a program to add a new item to our to-do list in todo.txt, now let&#8217;s make a program to remove an item. I&#8217;ll just paste the code and then we&#8217;ll go over the program together so you see that it&#8217;s really easy. We&#8217;ll be using a few new functions from System.Directory and one new function from System.IO, but they&#8217;ll all be explained.</p></div>
<div class="paragraph"><p>Anyway, here&#8217;s the program for removing an item from todo.txt:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">System.Directory</span>
<span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">handle</span> <span class="k">&lt;-</span> <span class="n">openFile</span> <span class="s">&quot;todo.txt&quot;</span> <span class="nc">ReadMode</span>
    <span class="o">(</span><span class="n">tempName</span><span class="o">,</span> <span class="n">tempHandle</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="n">let</span> <span class="n">todoTasks</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="k">=</span> <span class="n">zipWith</span> <span class="o">(\</span><span class="n">n</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="o">)</span> <span class="o">[</span><span class="err">0</span><span class="kt">..</span><span class="o">]</span> <span class="n">todoTasks</span>
    <span class="n">putStrLn</span> <span class="s">&quot;These are your TO-DO items:&quot;</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>
    <span class="n">putStrLn</span> <span class="s">&quot;Which one do you want to delete?&quot;</span>
    <span class="n">numberString</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">let</span> <span class="n">number</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">newTodoItems</span> <span class="k">=</span> <span class="n">delete</span> <span class="o">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="o">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="s">&quot;todo.txt&quot;</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="s">&quot;todo.txt&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>At first, we just open todo.txt in read mode and bind its handle to handle.</p></div>
<div class="paragraph"><p>Next up, we use a function that we haven&#8217;t met before which is from System.IO — openTempFile. Its name is pretty self-explanatory. It takes a path to a temporary directory and a template name for a file and opens a temporary file. We used "." for the temporary directory, because . denotes the current directory on just about any OS. We used "temp" as the template name for the temporary file, which means that the temporary file will be named temp plus some random characters. It returns an I/O action that makes the temporary file and the result in that I/O action is a pair of values: the name of the temporary file and a handle. We could just open a normal file called todo2.txt or something like that but it&#8217;s better practice to use openTempFile so you know you&#8217;re probably not overwriting anything.</p></div>
<div class="paragraph"><p>The reason we didn&#8217;t use getCurrentDirectory to get the current directory and then pass it to openTempFile but instead just passed "." to openTempFile is because . refers to the current directory on unix-like system and Windows</p></div>
<div class="paragraph"><p>Next up, we bind the contents of todo.txt to contents. Then, split that string into a list of strings, each string one line. So todoTasks is now something like ["Iron the dishes", "Dust the dog", "Take salad out of the oven"]. We zip the numbers from 0 onwards and that list with a function that takes a number, like 3, and a string, like "hey" and returns "3 - hey", so numberedTasks is ["0 - Iron the dishes", "1 - Dust the dog" &#8230;. We join that list of strings into a single newline delimited string with unlines and print that string out to the terminal. Note that instead of doing that, we could have also done mapM putStrLn numberedTasks</p></div>
<div class="paragraph"><p>We ask the user which one they want to delete and wait for them to enter a number. Let&#8217;s say they want to delete number 1, which is Dust the dog, so they punch in 1. numberString is now "1" and because we want a number, not a string, we run read on that to get 1 and bind that to number.</p></div>
<div class="paragraph"><p>Remember the delete and !! functions from Data.List. !! returns an element from a list with some index and delete deletes the first occurence of an element in a list and returns a new list without that occurence. (todoTasks !! number) (number is now 1) returns "Dust the dog". We bind todoTasks without the first occurence of "Dust the dog" to newTodoItems and then join that into a single string with unlines before writing it to the temporary file that we opened. The old file is now unchanged and the temporary file contains all the lines that the old one does, except the one we deleted.</p></div>
<div class="paragraph"><p>After that we close both the original and the temporary files and then we remove the original one with removeFile, which, as you can see, takes a path to a file and deletes it. After deleting the old todo.txt, we use renameFile to rename the temporary file to todo.txt. Be careful, removeFile and renameFile (which are both in System.Directory by the way) take file paths as their parameters, not handles.</p></div>
<div class="paragraph"><p>And that&#8217;s that! We could have done this in even fewer lines, but we were very careful not to overwrite any existing files and politely asked the operating system to tell us where we can put our temporary file. Let&#8217;s give this a go!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">runhaskell</span> <span class="n">deletetodo</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">These</span> <span class="n">are</span> <span class="n">your</span> <span class="nc">TO</span><span class="o">-</span><span class="nc">DO</span> <span class="n">items</span><span class="k">:</span>
<span class="err">0</span> <span class="kt">-</span> <span class="kt">Iron</span> <span class="kt">the</span> <span class="kt">dishes</span>
<span class="mi">1</span> <span class="o">-</span> <span class="nc">Dust</span> <span class="n">the</span> <span class="n">dog</span>
<span class="mi">2</span> <span class="o">-</span> <span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>
<span class="nc">Which</span> <span class="n">one</span> <span class="k">do</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">delete</span><span class="o">?</span>
<span class="mi">1</span>

<span class="n">$</span> <span class="n">cat</span> <span class="n">todo</span><span class="o">.</span><span class="n">txt</span>
<span class="nc">Iron</span> <span class="n">the</span> <span class="n">dishes</span>
<span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>

<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">deletetodo</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">These</span> <span class="n">are</span> <span class="n">your</span> <span class="nc">TO</span><span class="o">-</span><span class="nc">DO</span> <span class="n">items</span><span class="k">:</span>
<span class="err">0</span> <span class="kt">-</span> <span class="kt">Iron</span> <span class="kt">the</span> <span class="kt">dishes</span>
<span class="mi">1</span> <span class="o">-</span> <span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>
<span class="nc">Which</span> <span class="n">one</span> <span class="k">do</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">delete</span><span class="o">?</span>
<span class="mi">0</span>

<span class="n">$</span> <span class="n">cat</span> <span class="n">todo</span><span class="o">.</span><span class="n">txt</span>
<span class="nc">Take</span> <span class="n">salad</span> <span class="n">out</span> <span class="n">of</span> <span class="n">the</span> <span class="n">oven</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_command_line_arguments">Command line arguments</h3>
<div class="paragraph"><p><span class="image">
<img src="images/arguments.png" alt="images/arguments.png" />
</span>
Dealing with command line arguments is pretty much a necessity if you want to make a script or application that runs on a terminal. Luckily, Haskell&#8217;s standard library has a nice way of getting command line arguments of a program.</p></div>
<div class="paragraph"><p>In the previous section, we made one program for adding a to-do item to our to-do list and one program for removing an item. There are two problems with the approach we took. The first one is that we just hardcoded the name of our to-do file in our code. We just decided that the file will be named todo.txt and that the user will never have a need for managing several to-do lists.</p></div>
<div class="paragraph"><p>One way to solve that is to always ask the user which file they want to use as their to-do list. We used that approach when we wanted to know which item the user wants to delete. It works, but it&#8217;s not so good, because it requires the user to run the program, wait for the program to ask something and then tell that to the program. That&#8217;s called an interactive program and the difficult bit with interactive command line programs is this — what if you want to automate the execution of that program, like with a batch script? It&#8217;s harder to make a batch script that interacts with a program than a batch script that just calls one program or several of them.</p></div>
<div class="paragraph"><p>That&#8217;s why it&#8217;s sometimes better to have the user tell the program what they want when they run the program, instead of having the program ask the user once it&#8217;s run. And what better way to have the user tell the program what they want it to do when they run it than via command line arguments!</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
The System.Environment module has two cool I/O actions. One is getArgs, which has a type of getArgs :: IO [String] and is an I/O action that will get the arguments that the program was run with and have as its contained result a list with the arguments. getProgName has a type of getProgName 
</dt>
<dd>
<p>
IO String and is an I/O action that contains the program name.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Here&#8217;s a small program that demonstrates how these two work:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
   <span class="n">args</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
   <span class="n">progName</span> <span class="k">&lt;-</span> <span class="n">getProgName</span>
   <span class="n">putStrLn</span> <span class="s">&quot;The arguments are:&quot;</span>
   <span class="n">mapM</span> <span class="n">putStrLn</span> <span class="n">args</span>
   <span class="n">putStrLn</span> <span class="s">&quot;The program name is:&quot;</span>
   <span class="n">putStrLn</span> <span class="n">progName</span>
</pre></div></div></div>
<div class="paragraph"><p>We bind getArgs and progName to args and progName. We say The arguments are: and then for every argument in args, we do putStrLn. Finally, we also print out the program name. Let&#8217;s compile this as arg-test.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./arg-test first second w00t <span class="s2">&quot;multi word arg&quot;</span>
The arguments are:
first
second
w00t
multi word arg
The program name is:
arg-test
</pre></div></div></div>
<div class="paragraph"><p>Nice. Armed with this knowledge you could create some cool command line apps. In fact, let&#8217;s go ahead and make one. In the previous section, we made a separate program for adding tasks and a separate program for deleting them. Now, we&#8217;re going to join that into one program, what it does will depend on the command line arguments. We&#8217;re also going to make it so it can operate on different files, not just todo.txt.</p></div>
<div class="paragraph"><p>We&#8217;ll call it simply todo and it&#8217;ll be able to do (haha!) three different things:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>View tasks
Add tasks
Delete tasks</code></pre>
</div></div>
<div class="paragraph"><p>We&#8217;re not going to concern ourselves with possible bad input too much right now.</p></div>
<div class="paragraph"><p>Our program will be made so that if we want to add the task Find the magic sword of power to the file todo.txt, we have to punch in todo add todo.txt "Find the magic sword of power" in our terminal. To view the tasks we&#8217;ll just do todo view todo.txt and to remove the task with the index of 2, we&#8217;ll do todo remove todo.txt 2.</p></div>
<div class="paragraph"><p>We&#8217;ll start by making a dispatch association list. It&#8217;s going to be a simple association list that has command line arguments as keys and functions as their corresponding values. All these functions will be of type [String] &#8594; IO (). They&#8217;re going to take the argument list as a parameter and return an I/O action that does the viewing, adding, deleting, etc.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.Directory</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">dispatch</span> <span class="o">::</span> <span class="o">[(</span><span class="kt">String</span>, <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="kt">-&gt;</span> <span class="kt">IO</span> <span class="o">())]</span>
<span class="n">dispatch</span> <span class="k">=</span>  <span class="o">[</span> <span class="o">(</span><span class="err">&quot;</span><span class="kt">add</span><span class="err">&quot;</span>, <span class="kt">add</span><span class="o">)</span>
            , <span class="o">(</span><span class="err">&quot;</span><span class="kt">view</span><span class="err">&quot;</span>, <span class="kt">view</span><span class="o">)</span>
            , <span class="o">(</span><span class="err">&quot;</span><span class="kt">remove</span><span class="err">&quot;</span>, <span class="kt">remove</span><span class="o">)</span>
            <span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>We have yet to define main, add, view and remove, so let&#8217;s start with main:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">command</span><span class="k">:</span><span class="kt">args</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">let</span> <span class="o">(</span><span class="nc">Just</span> <span class="n">action</span><span class="o">)</span> <span class="k">=</span> <span class="n">lookup</span> <span class="n">command</span> <span class="n">dispatch</span>
    <span class="n">action</span> <span class="n">args</span>
</pre></div></div></div>
<div class="paragraph"><p>First, we get the arguments and bind them to (command:args). If you remember your pattern matching, this means that the first argument will get bound to command and the rest of them will get bound to args. If we call our program like todo add todo.txt "Spank the monkey", command will be "add" and args will be ["todo.xt", "Spank the monkey"].</p></div>
<div class="paragraph"><p>In the next line, we look up our command in the dispatch list. Because "add" points to add, we get Just add as a result. We use pattern matching again to extract our function out of the Maybe. What happens if our command isn&#8217;t in the dispatch list? Well then the lookup will return Nothing, but we said we won&#8217;t concern ourselves with failing gracefully too much, so the pattern matching will fail and our program will throw a fit.</p></div>
<div class="paragraph"><p>Finally, we call our action function with the rest of the argument list. That will return an I/O action that either adds an item, displays a list of items or deletes an item and because that action is part of the main do block, it will get performed. If we follow our concrete example so far and our action function is add, it will get called with args (so ["todo.txt", "Spank the monkey"]) and return an I/O action that adds Spank the monkey to todo.txt.</p></div>
<div class="paragraph"><p>Great! All that&#8217;s left now is to implement add, view and remove. Let&#8217;s start with add:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">add</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">add</span> <span class="o">[</span><span class="kt">fileName</span>, <span class="kt">todoItem</span><span class="o">]</span> <span class="k">=</span> <span class="n">appendFile</span> <span class="n">fileName</span> <span class="o">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;\n&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>If we call our program like todo add todo.txt "Spank the monkey", the "add" will get bound to command in the first pattern match in the main block, whereas ["todo.txt", "Spank the monkey"] will get passed to the function that we get from the dispatch list. So, because we&#8217;re not dealing with bad input right now, we just pattern match against a list with those two elements right away and return an I/O action that appends that line to the end of the file, along with a newline character.</p></div>
<div class="paragraph"><p>Next, let&#8217;s implement the list viewing functionality. If we want to view the items in a file, we do todo view todo.txt. So in the first pattern match, command will be "view" and args will be ["todo.txt"].</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">view</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">view</span> <span class="o">[</span><span class="kt">fileName</span><span class="o">]</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
    <span class="n">let</span> <span class="n">todoTasks</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="k">=</span> <span class="n">zipWith</span> <span class="o">(\</span><span class="n">n</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="o">)</span> <span class="o">[</span><span class="err">0</span><span class="kt">..</span><span class="o">]</span> <span class="n">todoTasks</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>
</pre></div></div></div>
<div class="paragraph"><p>We already did pretty much the same thing in the program that only deleted tasks when we were displaying the tasks so that the user can choose one for deletion, only here we just display the tasks.</p></div>
<div class="paragraph"><p>And finally, we&#8217;re going to implement remove. It&#8217;s going to be very similar to the program that only deleted the tasks, so if you don&#8217;t understand how deleting an item here works, check out the explanation under that program. The main difference is that we&#8217;re not hardcoding todo.txt but getting it as an argument. We&#8217;re also not prompting the user for the task number to delete, we&#8217;re getting it as an argument.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">remove</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">remove</span> <span class="o">[</span><span class="kt">fileName</span>, <span class="kt">numberString</span><span class="o">]</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">handle</span> <span class="k">&lt;-</span> <span class="n">openFile</span> <span class="n">fileName</span> <span class="nc">ReadMode</span>
    <span class="o">(</span><span class="n">tempName</span><span class="o">,</span> <span class="n">tempHandle</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="n">let</span> <span class="n">number</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">todoTasks</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">newTodoItems</span> <span class="k">=</span> <span class="n">delete</span> <span class="o">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="o">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="n">fileName</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="n">fileName</span>
</pre></div></div></div>
<div class="paragraph"><p>We opened up the file based on fileName and opened a temporary file, deleted the line with the index that the user wants to delete, wrote that to the temporary file, removed the original file and renamed the temporary file back to fileName.</p></div>
<div class="paragraph"><p>Here&#8217;s the whole program at once, in all its glory!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.Directory</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">dispatch</span> <span class="o">::</span> <span class="o">[(</span><span class="kt">String</span>, <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="kt">-&gt;</span> <span class="kt">IO</span> <span class="o">())]</span>
<span class="n">dispatch</span> <span class="k">=</span>  <span class="o">[</span> <span class="o">(</span><span class="err">&quot;</span><span class="kt">add</span><span class="err">&quot;</span>, <span class="kt">add</span><span class="o">)</span>
            , <span class="o">(</span><span class="err">&quot;</span><span class="kt">view</span><span class="err">&quot;</span>, <span class="kt">view</span><span class="o">)</span>
            , <span class="o">(</span><span class="err">&quot;</span><span class="kt">remove</span><span class="err">&quot;</span>, <span class="kt">remove</span><span class="o">)</span>
            <span class="o">]</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">command</span><span class="k">:</span><span class="kt">args</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">let</span> <span class="o">(</span><span class="nc">Just</span> <span class="n">action</span><span class="o">)</span> <span class="k">=</span> <span class="n">lookup</span> <span class="n">command</span> <span class="n">dispatch</span>
    <span class="n">action</span> <span class="n">args</span>

<span class="n">add</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">add</span> <span class="o">[</span><span class="kt">fileName</span>, <span class="kt">todoItem</span><span class="o">]</span> <span class="k">=</span> <span class="n">appendFile</span> <span class="n">fileName</span> <span class="o">(</span><span class="n">todoItem</span> <span class="o">++</span> <span class="s">&quot;\n&quot;</span><span class="o">)</span>

<span class="n">view</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">view</span> <span class="o">[</span><span class="kt">fileName</span><span class="o">]</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
    <span class="n">let</span> <span class="n">todoTasks</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">numberedTasks</span> <span class="k">=</span> <span class="n">zipWith</span> <span class="o">(\</span><span class="n">n</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="s">&quot; - &quot;</span> <span class="o">++</span> <span class="n">line</span><span class="o">)</span> <span class="o">[</span><span class="err">0</span><span class="kt">..</span><span class="o">]</span> <span class="n">todoTasks</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">numberedTasks</span>

<span class="n">remove</span> <span class="o">::</span> <span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">remove</span> <span class="o">[</span><span class="kt">fileName</span>, <span class="kt">numberString</span><span class="o">]</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">handle</span> <span class="k">&lt;-</span> <span class="n">openFile</span> <span class="n">fileName</span> <span class="nc">ReadMode</span>
    <span class="o">(</span><span class="n">tempName</span><span class="o">,</span> <span class="n">tempHandle</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">openTempFile</span> <span class="s">&quot;.&quot;</span> <span class="s">&quot;temp&quot;</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">hGetContents</span> <span class="n">handle</span>
    <span class="n">let</span> <span class="n">number</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="n">todoTasks</span> <span class="k">=</span> <span class="n">lines</span> <span class="n">contents</span>
        <span class="n">newTodoItems</span> <span class="k">=</span> <span class="n">delete</span> <span class="o">(</span><span class="n">todoTasks</span> <span class="o">!!</span> <span class="n">number</span><span class="o">)</span> <span class="n">todoTasks</span>
    <span class="n">hPutStr</span> <span class="n">tempHandle</span> <span class="n">$</span> <span class="n">unlines</span> <span class="n">newTodoItems</span>
    <span class="n">hClose</span> <span class="n">handle</span>
    <span class="n">hClose</span> <span class="n">tempHandle</span>
    <span class="n">removeFile</span> <span class="n">fileName</span>
    <span class="n">renameFile</span> <span class="n">tempName</span> <span class="n">fileName</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/salad.png" alt="images/salad.png" />
</span>
To summarize our solution: we made a dispatch association that maps from commands to functions that take some command line arguments and return an I/O action. We see what the command is and based on that we get the appropriate function from the dispatch list. We call that function with the rest of the command line arguments to get back an I/O action that will do the appropriate thing and then just perform that action!</p></div>
<div class="paragraph"><p>In other languages, we might have implemented this with a big switch case statement or whatever, but using higher order functions allows us to just tell the dispatch list to give us the appropriate function and then tell that function to give us an I/O action for some command line arguments.</p></div>
<div class="paragraph"><p>Let&#8217;s try our app out!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./todo view todo.txt
<span class="m">0</span> - Iron the dishes
<span class="m">1</span> - Dust the dog
<span class="m">2</span> - Take salad out of the oven

$ ./todo add todo.txt <span class="s2">&quot;Pick up children from drycleaners&quot;</span>

$ ./todo view todo.txt
<span class="m">0</span> - Iron the dishes
<span class="m">1</span> - Dust the dog
<span class="m">2</span> - Take salad out of the oven
<span class="m">3</span> - Pick up children from drycleaners

$ ./todo remove todo.txt <span class="m">2</span>

$ ./todo view todo.txt
<span class="m">0</span> - Iron the dishes
<span class="m">1</span> - Dust the dog
<span class="m">2</span> - Pick up children from drycleaners
</pre></div></div></div>
<div class="paragraph"><p>Another cool thing about this is that it&#8217;s easy to add extra functionality. Just add an entry in the dispatch association list and implement the corresponding function and you&#8217;re laughing! As an exercise, you can try implementing a bump function that will take a file and a task number and return an I/O action that bumps that task to the top of the to-do list.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
You could make this program fail a bit more gracefully in case of bad input (for example, if someone runs todo UP YOURS HAHAHAHA) by making an I/O action that just reports there has been an error (say, errorExit 
</dt>
<dd>
<p>
IO ()) and then check for possible erronous input and if there is erronous input, perform the error reporting I/O action. Another way is to use exceptions, which we will meet soon.
</p>
</dd>
</dl></div>
</div>
<div class="sect2">
<h3 id="_randomness">Randomness</h3>
<div class="paragraph"><p><span class="image">
<img src="images/random.png" alt="images/random.png" />
</span>
this picture is the ultimate source of randomness and wackiness
Many times while programming, you need to get some random data. Maybe you&#8217;re making a game where a die needs to be thrown or you need to generate some test data to test out your program. There are a lot of uses for random data when programming. Well, actually, pseudo-random, because we all know that the only true source of randomness is a monkey on a unicycle with a cheese in one hand and its butt in the other. In this section, we&#8217;ll take a look at how to make Haskell generate seemingly random data.</p></div>
<div class="paragraph"><p>In most other programming languages, you have functions that give you back some random number. Each time you call that function, you get back a (hopefully) different random number. How about Haskell? Well, remember, Haskell is a pure functional language. What that means is that it has referential transparency. What THAT means is that a function, if given the same parameters twice, must produce the same result twice. That&#8217;s really cool because it allows us to reason differently about programs and it enables us to defer evaluation until we really need it. If I call a function, I can be sure that it won&#8217;t do any funny stuff before giving me the results. All that matters are its results. However, this makes it a bit tricky for getting random numbers. If I have a function like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">randomNumber</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span>
<span class="n">randomNumber</span> <span class="k">=</span> <span class="mi">4</span>
</pre></div></div></div>
<div class="paragraph"><p>It&#8217;s not very useful as a random number function because it will always return 4, even though I can assure you that the 4 is completely random, because I used a die to determine it.</p></div>
<div class="paragraph"><p>How do other languages make seemingly random numbers? Well, they take various info from your computer, like the current time, how much and where you moved your mouse and what kind of noises you made behind your computer and based on that, give a number that looks really random. The combination of those factors (that randomness) is probably different in any given moment in time, so you get a different random number.</p></div>
<div class="paragraph"><p>Ah. So in Haskell, we can make a random number then if we make a function that takes as its parameter that randomness and based on that returns some number (or other data type).</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Enter the System.Random module. It has all the functions that satisfy our need for randomness. Let&#8217;s just dive into one of the functions it exports then, namely random. Here&#8217;s its type: random 
</dt>
<dd>
<p>
(RandomGen g, Random a) &#8658; g &#8594; (a, g). Whoa! Some new typeclasses in this type declaration up in here! The RandomGen typeclass is for types that can act as sources of randomness. The Random typeclass is for things that can take on random values. A boolean value can take on a random value, namely True or False. A number can also take up a plethora of different random values. Can a function take on a random value? I don&#8217;t think so, probably not! If we try to translate the type declaration of random to English, we get something like: it takes a random generator (that&#8217;s our source of randomness) and returns a random value and a new random generator. Why does it also return a new generator as well as a random value? Well, we&#8217;ll see in a moment.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>To use our random function, we have to get our hands on one of those random generators. The System.Random module exports a cool type, namely StdGen that is an instance of the RandomGen typeclass. We can either make a StdGen manually or we can tell the system to give us one based on a multitude of sort of random stuff.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
To manually make a random generator, use the mkStdGen function. It has a type of mkStdGen 
</dt>
<dd>
<p>
Int &#8594; StdGen. It takes an integer and based on that, gives us a random generator. Okay then, let&#8217;s try using random and mkStdGen in tandem to get a (hardly random) number.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">100</span><span class="o">)</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="k">&gt;:</span><span class="mi">1</span><span class="k">:</span><span class="err">0</span><span class="kt">:</span>
    <span class="nc">Ambiguous</span> <span class="k">type</span> <span class="kt">variable</span> <span class="kt">`a&#39; in the constraint:</span>
<span class="kt">      `Random</span> <span class="kt">a</span><span class="err">&#39;</span> <span class="kt">arising</span> <span class="kt">from</span> <span class="kt">a</span> <span class="kt">use</span> <span class="kt">of</span> <span class="err">`</span><span class="kt">random</span><span class="err">&#39;</span> <span class="kt">at</span> <span class="kt">&lt;interactive</span><span class="k">&gt;:</span><span class="err">1</span><span class="kt">:</span><span class="err">0</span><span class="kt">-</span><span class="err">20</span>
    <span class="kt">Probable</span> <span class="kt">fix:</span> <span class="kt">add</span> <span class="kt">a</span> <span class="k">type</span> <span class="kt">signature</span> <span class="kt">that</span> <span class="kt">fixes</span> <span class="kt">these</span> <span class="k">type</span> <span class="kt">variable</span><span class="o">(</span><span class="kt">s</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>What&#8217;s this? Ah, right, the random function can return a value of any type that&#8217;s part of the Random typeclass, so we have to inform Haskell what kind of type we want. Also let&#8217;s not forget that it returns a random value and a random generator in a pair.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">100</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(-</span><span class="mi">1352021624</span><span class="o">,</span><span class="mi">651872571</span> <span class="mi">1655838864</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Finally! A number that looks kind of random! The first component of the tuple is our number whereas the second component is a textual representation of our new random generator. What happens if we call random with the same random generator again?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">100</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(-</span><span class="mi">1352021624</span><span class="o">,</span><span class="mi">651872571</span> <span class="mi">1655838864</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Of course. The same result for the same parameters. So let&#8217;s try giving it a different random generator as a parameter.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">949494</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(</span><span class="mi">539963926</span><span class="o">,</span><span class="mi">466647808</span> <span class="mi">1655838864</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Alright, cool, great, a different number. We can use the type annotation to get different types back from that function.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">949488</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Float</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(</span><span class="mf">0.8938442</span><span class="o">,</span><span class="mi">1597344447</span> <span class="mi">1655838864</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">949488</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Bool</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(</span><span class="nc">False</span><span class="o">,</span><span class="mi">1485632275</span> <span class="mi">40692</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">random</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">949488</span><span class="o">)</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Integer</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
<span class="o">(</span><span class="mi">1691547873</span><span class="o">,</span><span class="mi">1597344447</span> <span class="mi">1655838864</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Let&#8217;s make a function that simulates tossing a coin three times. If random didn&#8217;t return a new generator along with a random value, we&#8217;d have to make this function take three random generators as a parameter and then return coin tosses for each of them. But that sounds wrong because if one generator can make a random value of type Int (which can take on a load of different values), it should be able to make three coin tosses (which can take on precisely eight combinations). So this is where random returning a new generator along with a value really comes in handy.</p></div>
<div class="paragraph"><p>We&#8217;ll represent a coin with a simple Bool. True is tails, False is heads.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">threeCoins</span> <span class="o">::</span> <span class="nc">StdGen</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Bool</span><span class="o">,</span> <span class="nc">Bool</span><span class="o">,</span> <span class="nc">Bool</span><span class="o">)</span>
<span class="n">threeCoins</span> <span class="n">gen</span> <span class="k">=</span>
    <span class="n">let</span> <span class="o">(</span><span class="n">firstCoin</span><span class="o">,</span> <span class="n">newGen</span><span class="o">)</span> <span class="k">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="o">(</span><span class="n">secondCoin</span><span class="o">,</span> <span class="n">newGen</span><span class="err">&#39;</span><span class="o">)</span> <span class="k">=</span> <span class="n">random</span> <span class="n">newGen</span>
        <span class="o">(</span><span class="n">thirdCoin</span><span class="o">,</span> <span class="n">newGen</span><span class="err">&#39;&#39;</span><span class="o">)</span> <span class="k">=</span> <span class="n">random</span> <span class="n">newGen</span><span class="err">&#39;</span>
    <span class="n">in</span>  <span class="o">(</span><span class="n">firstCoin</span><span class="o">,</span> <span class="n">secondCoin</span><span class="o">,</span> <span class="n">thirdCoin</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>We call random with the generator we got as a parameter to get a coin and a new generator. Then we call it again, only this time with our new generator, to get the second coin. We do the same for the third coin. Had we called it with the same generator every time, all the coins would have had the same value and we&#8217;d only be able to get (False, False, False) or (True, True, True) as a result.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">threeCoins</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">21</span><span class="o">)</span>
<span class="o">(</span><span class="nc">True</span><span class="o">,</span><span class="nc">True</span><span class="o">,</span><span class="nc">True</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">threeCoins</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">22</span><span class="o">)</span>
<span class="o">(</span><span class="nc">True</span><span class="o">,</span><span class="nc">False</span><span class="o">,</span><span class="nc">True</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">threeCoins</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">943</span><span class="o">)</span>
<span class="o">(</span><span class="nc">True</span><span class="o">,</span><span class="nc">False</span><span class="o">,</span><span class="nc">True</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">threeCoins</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">944</span><span class="o">)</span>
<span class="o">(</span><span class="nc">True</span><span class="o">,</span><span class="nc">True</span><span class="o">,</span><span class="nc">True</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Notice that we didn&#8217;t have to do random gen 
</dt>
<dd>
<p>
(Bool, StdGen). That&#8217;s because we already specified that we want booleans in the type declaration of the function. That&#8217;s why Haskell can infer that we want a boolean value in this case.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>So what if we want to flip four coins? Or five? Well, there&#8217;s a function called randoms that takes a generator and returns an infinite sequence of values based on that generator.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">$</span> <span class="n">randoms</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">11</span><span class="o">)</span> <span class="o">::</span> <span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="o">[</span><span class="kt">-</span><span class="err">1807975507</span>,<span class="err">545074951</span>,<span class="kt">-</span><span class="err">1015194702</span>,<span class="kt">-</span><span class="err">1622477312</span>,<span class="kt">-</span><span class="err">502893664</span><span class="o">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">$</span> <span class="n">randoms</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">11</span><span class="o">)</span> <span class="o">::</span> <span class="o">[</span><span class="kt">Bool</span><span class="o">]</span>
<span class="o">[</span><span class="kt">True</span>,<span class="kt">True</span>,<span class="kt">True</span>,<span class="kt">True</span>,<span class="kt">False</span><span class="o">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="n">$</span> <span class="n">randoms</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">11</span><span class="o">)</span> <span class="o">::</span> <span class="o">[</span><span class="kt">Float</span><span class="o">]</span>
<span class="o">[</span><span class="err">7</span><span class="kt">.</span><span class="err">904789</span><span class="kt">e-</span><span class="err">2</span>,<span class="err">0</span><span class="kt">.</span><span class="err">62691015</span>,<span class="err">0</span><span class="kt">.</span><span class="err">26363158</span>,<span class="err">0</span><span class="kt">.</span><span class="err">12223756</span>,<span class="err">0</span><span class="kt">.</span><span class="err">38291094</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Why doesn&#8217;t randoms return a new generator as well as a list? We could implement the randoms function very easily like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">randoms</span><span class="err">&#39;</span> <span class="o">::</span> <span class="o">(</span><span class="nc">RandomGen</span> <span class="n">g</span><span class="o">,</span> <span class="nc">Random</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">a</span><span class="o">]</span>
<span class="n">randoms</span><span class="err">&#39;</span> <span class="n">gen</span> <span class="k">=</span> <span class="n">let</span> <span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">newGen</span><span class="o">)</span> <span class="k">=</span> <span class="n">random</span> <span class="n">gen</span> <span class="n">in</span> <span class="n">value</span><span class="k">:</span><span class="kt">randoms</span><span class="err">&#39;</span> <span class="kt">newGen</span>
</pre></div></div></div>
<div class="paragraph"><p>A recursive definition. We get a random value and a new generator from the current generator and then make a list that has the value as its head and random numbers based on the new generator as its tail. Because we have to be able to potentially generate an infinite amount of numbers, we can&#8217;t give the new random generator back.</p></div>
<div class="paragraph"><p>We could make a function that generates a finite stream of numbers and a new generator like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">finiteRandoms</span> <span class="o">::</span> <span class="o">(</span><span class="nc">RandomGen</span> <span class="n">g</span><span class="o">,</span> <span class="nc">Random</span> <span class="n">a</span><span class="o">,</span> <span class="nc">Num</span> <span class="n">n</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">-&gt;</span> <span class="n">g</span> <span class="o">-&gt;</span> <span class="o">([</span><span class="kt">a</span><span class="o">],</span> <span class="n">g</span><span class="o">)</span>
<span class="n">finiteRandoms</span> <span class="mi">0</span> <span class="n">gen</span> <span class="k">=</span> <span class="o">([],</span> <span class="n">gen</span><span class="o">)</span>
<span class="n">finiteRandoms</span> <span class="n">n</span> <span class="n">gen</span> <span class="k">=</span>
    <span class="n">let</span> <span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">newGen</span><span class="o">)</span> <span class="k">=</span> <span class="n">random</span> <span class="n">gen</span>
        <span class="o">(</span><span class="n">restOfList</span><span class="o">,</span> <span class="n">finalGen</span><span class="o">)</span> <span class="k">=</span> <span class="n">finiteRandoms</span> <span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="n">newGen</span>
    <span class="n">in</span>  <span class="o">(</span><span class="n">value</span><span class="k">:</span><span class="kt">restOfList</span><span class="o">,</span> <span class="n">finalGen</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Again, a recursive definition. We say that if we want 0 numbers, we just return an empty list and the generator that was given to us. For any other number of random values, we first get one random number and a new generator. That will be the head. Then we say that the tail will be n - 1 numbers generated with the new generator. Then we return the head and the rest of the list joined and the final generator that we got from getting the n - 1 random numbers.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
What if we want a random value in some sort of range? All the random integers so far were outrageously big or small. What if we want to to throw a die? Well, we use randomR for that purpose. It has a type of randomR :: (RandomGen g, Random a) 
</dt>
<dd>
<p>
(a, a) &#8594; g &#8594; (a, g), meaning that it&#8217;s kind of like random, only it takes as its first parameter a pair of values that set the lower and upper bounds and the final value produced will be within those bounds.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">randomR</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">359353</span><span class="o">)</span>
<span class="o">(</span><span class="mi">6</span><span class="o">,</span><span class="mi">1494289578</span> <span class="mi">40692</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">randomR</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">35935335</span><span class="o">)</span>
<span class="o">(</span><span class="mi">3</span><span class="o">,</span><span class="mi">1250031057</span> <span class="mi">40692</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>There&#8217;s also randomRs, which produces a stream of random values within our defined ranges. Check this out:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="n">$</span> <span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="o">(</span><span class="n">mkStdGen</span> <span class="mi">3</span><span class="o">)</span> <span class="o">::</span> <span class="o">[</span><span class="kt">Char</span><span class="o">]</span>
<span class="s">&quot;ndkxbvmomg&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Nice, looks like a super secret password or something.</p></div>
<div class="paragraph"><p>You may be asking yourself, what does this section have to do with I/O anyway? We haven&#8217;t done anything concerning I/O so far. Well, so far we&#8217;ve always made our random number generator manually by making it with some arbitrary integer. The problem is, if we do that in our real programs, they will always return the same random numbers, which is no good for us. That&#8217;s why System.Random offers the getStdGen I/O action, which has a type of IO StdGen. When your program starts, it asks the system for a good random number generator and stores that in a so called global generator. getStdGen fetches you that global random generator when you bind it to something.</p></div>
<div class="paragraph"><p>Here&#8217;s a simple program that generates a random string.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">(</span><span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen</span><span class="o">)</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">random_string</span><span class="o">.</span><span class="n">hs</span>
<span class="n">pybphhzzhuepknbykxhe</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">random_string</span><span class="o">.</span><span class="n">hs</span>
<span class="n">eiqgcxykivpudlsvvjpg</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">random_string</span><span class="o">.</span><span class="n">hs</span>
<span class="n">nzdceoconysdgcyqjruo</span>
<span class="n">$</span> <span class="n">runhaskell</span> <span class="n">random_string</span><span class="o">.</span><span class="n">hs</span>
<span class="n">bakzhnnuzrkgvesqplrx</span>
</pre></div></div></div>
<div class="paragraph"><p>Be careful though, just performing getStdGen twice will ask the system for the same global generator twice. If you do this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">(</span><span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen</span><span class="o">)</span>
    <span class="n">gen2</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">(</span><span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>you will get the same string printed out twice! One way to get two different strings of length 20 is to set up an infinite stream and then take the first 20 characters and print them out in one line and then take the second set of 20 characters and print them out in the second line. For this, we can use the splitAt function from Data.List, which splits a list at some index and returns a tuple that has the first part as the first component and the second part as the second component.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>
<span class="k">import</span> <span class="nn">Data.List</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">let</span> <span class="n">randomChars</span> <span class="k">=</span> <span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen</span>
        <span class="o">(</span><span class="n">first20</span><span class="o">,</span> <span class="n">rest</span><span class="o">)</span> <span class="k">=</span> <span class="n">splitAt</span> <span class="mi">20</span> <span class="n">randomChars</span>
        <span class="o">(</span><span class="n">second20</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">splitAt</span> <span class="mi">20</span> <span class="n">rest</span>
    <span class="n">putStrLn</span> <span class="n">first20</span>
    <span class="n">putStr</span> <span class="n">second20</span>
</pre></div></div></div>
<div class="paragraph"><p>Another way is to use the newStdGen action, which splits our current random generator into two generators. It updates the global random generator with one of them and encapsulates the other as its result.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">putStrLn</span> <span class="n">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">(</span><span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen</span><span class="o">)</span>
    <span class="n">gen</span><span class="err">&#39;</span> <span class="k">&lt;-</span> <span class="n">newStdGen</span>
    <span class="n">putStr</span> <span class="n">$</span> <span class="n">take</span> <span class="mi">20</span> <span class="o">(</span><span class="n">randomRs</span> <span class="o">(</span><span class="sc">&#39;a&#39;</span><span class="o">,</span><span class="sc">&#39;z&#39;</span><span class="o">)</span> <span class="n">gen</span><span class="err">&#39;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Not only do we get a new random generator when we bind newStdGen to something, the global one gets updated as well, so if we do getStdGen again and bind it to something, we&#8217;ll get a generator that&#8217;s not the same as gen.</p></div>
<div class="paragraph"><p>Here&#8217;s a little program that will make the user guess which number it&#8217;s thinking of.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>
<span class="k">import</span> <span class="nn">Control.Monad</span><span class="o">(</span><span class="n">when</span><span class="o">)</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">askForNumber</span> <span class="n">gen</span>

<span class="n">askForNumber</span> <span class="o">::</span> <span class="nc">StdGen</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">askForNumber</span> <span class="n">gen</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">let</span> <span class="o">(</span><span class="n">randNumber</span><span class="o">,</span> <span class="n">newGen</span><span class="o">)</span> <span class="k">=</span> <span class="n">randomR</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">)</span> <span class="n">gen</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
    <span class="n">putStr</span> <span class="s">&quot;Which number in the range from 1 to 10 am I thinking of? &quot;</span>
    <span class="n">numberString</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">when</span> <span class="o">(</span><span class="n">not</span> <span class="n">$</span> <span class="kc">null</span> <span class="n">numberString</span><span class="o">)</span> <span class="n">$</span> <span class="k">do</span>
        <span class="n">let</span> <span class="n">number</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="k">if</span> <span class="n">randNumber</span> <span class="o">==</span> <span class="n">number</span>
            <span class="n">then</span> <span class="n">putStrLn</span> <span class="s">&quot;You are correct!&quot;</span>
            <span class="k">else</span> <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;Sorry, it was &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">randNumber</span>
        <span class="n">askForNumber</span> <span class="n">newGen</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/jackofdiamonds.png" alt="images/jackofdiamonds.png" />
</span>
We make a function askForNumber, which takes a random number generator and returns an I/O action that will prompt the user for a number and tell him if he guessed it right. In that function, we first generate a random number and a new generator based on the generator that we got as a parameter and call them randNumber and newGen. Let&#8217;s say that the number generated was 7. Then we tell the user to guess which number we&#8217;re thinking of. We perform getLine and bind its result to numberString. When the user enters 7, numberString becomes "7". Next, we use when to check if the string the user entered is an empty string. If it is, an empty I/O action of return () is performed, which effectively ends the program. If it isn&#8217;t, the action consisting of that do block right there gets performed. We use read on numberString to convert it to a number, so number is now 7.</p></div>
<div class="paragraph"><p>Excuse me! If the user gives us some input here that read can&#8217;t read (like "haha"), our program will crash with an ugly error message. If you don&#8217;t want your program to crash on erronous input, use reads, which returns an empty list when it fails to read a string. When it succeeds, it returns a singleton list with a tuple that has our desired value as one component and a string with what it didn&#8217;t consume as the other.</p></div>
<div class="paragraph"><p>We check if the number that we entered is equal to the one generated randomly and give the user the appropriate message. And then we call askForNumber recursively, only this time with the new generator that we got, which gives us an I/O action that&#8217;s just like the one we performed, only it depends on a different generator and we perform it.</p></div>
<div class="paragraph"><p>main consists of just getting a random generator from the system and calling askForNumber with it to get the initial action.</p></div>
<div class="paragraph"><p>Here&#8217;s our program in action!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">runhaskell</span> <span class="n">guess_the_number</span><span class="o">.</span><span class="n">hs</span>
<span class="nc">Which</span> <span class="n">number</span> <span class="n">in</span> <span class="n">the</span> <span class="n">range</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">am</span> <span class="n">I</span> <span class="n">thinking</span> <span class="n">of</span><span class="o">?</span> <span class="mi">4</span>
<span class="nc">Sorry</span><span class="o">,</span> <span class="n">it</span> <span class="n">was</span> <span class="mi">3</span>
<span class="nc">Which</span> <span class="n">number</span> <span class="n">in</span> <span class="n">the</span> <span class="n">range</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">am</span> <span class="n">I</span> <span class="n">thinking</span> <span class="n">of</span><span class="o">?</span> <span class="mi">10</span>
<span class="nc">You</span> <span class="n">are</span> <span class="n">correct</span><span class="o">!</span>
<span class="nc">Which</span> <span class="n">number</span> <span class="n">in</span> <span class="n">the</span> <span class="n">range</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">am</span> <span class="n">I</span> <span class="n">thinking</span> <span class="n">of</span><span class="o">?</span> <span class="mi">2</span>
<span class="nc">Sorry</span><span class="o">,</span> <span class="n">it</span> <span class="n">was</span> <span class="mi">4</span>
<span class="nc">Which</span> <span class="n">number</span> <span class="n">in</span> <span class="n">the</span> <span class="n">range</span> <span class="n">from</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">10</span> <span class="n">am</span> <span class="n">I</span> <span class="n">thinking</span> <span class="n">of</span><span class="o">?</span> <span class="mi">5</span>
<span class="nc">Sorry</span><span class="o">,</span> <span class="n">it</span> <span class="n">was</span> <span class="mi">10</span>
</pre></div></div></div>
<div class="paragraph"><p>Which number in the range from 1 to 10 am I thinking of?
Another way to make this same program is like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Random</span>
<span class="k">import</span> <span class="nn">Control.Monad</span><span class="o">(</span><span class="n">when</span><span class="o">)</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">gen</span> <span class="k">&lt;-</span> <span class="n">getStdGen</span>
    <span class="n">let</span> <span class="o">(</span><span class="n">randNumber</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">randomR</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">10</span><span class="o">)</span> <span class="n">gen</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Int</span><span class="o">,</span> <span class="nc">StdGen</span><span class="o">)</span>
    <span class="n">putStr</span> <span class="s">&quot;Which number in the range from 1 to 10 am I thinking of? &quot;</span>
    <span class="n">numberString</span> <span class="k">&lt;-</span> <span class="n">getLine</span>
    <span class="n">when</span> <span class="o">(</span><span class="n">not</span> <span class="n">$</span> <span class="kc">null</span> <span class="n">numberString</span><span class="o">)</span> <span class="n">$</span> <span class="k">do</span>
        <span class="n">let</span> <span class="n">number</span> <span class="k">=</span> <span class="n">read</span> <span class="n">numberString</span>
        <span class="k">if</span> <span class="n">randNumber</span> <span class="o">==</span> <span class="n">number</span>
            <span class="n">then</span> <span class="n">putStrLn</span> <span class="s">&quot;You are correct!&quot;</span>
            <span class="k">else</span> <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;Sorry, it was &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">randNumber</span>
        <span class="n">newStdGen</span>
        <span class="n">main</span>
</pre></div></div></div>
<div class="paragraph"><p>It&#8217;s very similar to the previous version, only instead of making a function that takes a generator and then calls itself recursively with the new updated generator, we do all the work in main. After telling the user whether they were correct in their guess or not, we update the global generator and then call main again. Both approaches are valid but I like the first one more since it does less stuff in main and also provides us with a function that we can reuse easily.</p></div>
</div>
<div class="sect2">
<h3 id="_bytestrings">Bytestrings</h3>
<div class="paragraph"><p>like normal string, only they byte &#8230; what a pedestrian pun this is
Lists are a cool and useful data structure. So far, we&#8217;ve used them pretty much everywhere. There are a multitude of functions that operate on them and Haskell&#8217;s laziness allows us to exchange the for and while loops of other languages for filtering and mapping over lists, because evaluation will only happen once it really needs to, so things like infinite lists (and even infinite lists of infinite lists!) are no problem for us. That&#8217;s why lists can also be used to represent streams, either when reading from the standard input or when reading from files. We can just open a file and read it as a string, even though it will only be accessed when the need arises.</p></div>
<div class="paragraph"><p>However, processing files as strings has one drawback: it tends to be slow. As you know, String is a type synonym for [Char]. Chars don&#8217;t have a fixed size, because it takes several bytes to represent a character from, say, Unicode. Furthemore, lists are really lazy. If you have a list like [1,2,3,4], it will be evaluated only when completely necessary. So the whole list is sort of a promise of a list. Remember that [1,2,3,4] is syntactic sugar for 1:2:3:4:[]. When the first element of the list is forcibly evaluated (say by printing it), the rest of the list 2:3:4:[] is still just a promise of a list, and so on. So you can think of lists as promises that the next element will be delivered once it really has to and along with it, the promise of the element after it. It doesn&#8217;t take a big mental leap to conclude that processing a simple list of numbers as a series of promises might not be the most efficient thing in the world.</p></div>
<div class="paragraph"><p>That overhead doesn&#8217;t bother us so much most of the time, but it turns out to be a liability when reading big files and manipulating them. That&#8217;s why Haskell has bytestrings. Bytestrings are sort of like lists, only each element is one byte (or 8 bits) in size. The way they handle laziness is also different.</p></div>
<div class="paragraph"><p>Bytestrings come in two flavors: strict and lazy ones. Strict bytestrings reside in Data.ByteString and they do away with the laziness completely. There are no promises involved; a strict bytestring represents a series of bytes in an array. You can&#8217;t have things like infinite strict bytestrings. If you evaluate the first byte of a strict bytestring, you have to evaluate it whole. The upside is that there&#8217;s less overhead because there are no thunks (the technical term for promise) involved. The downside is that they&#8217;re likely to fill your memory up faster because they&#8217;re read into memory at once.</p></div>
<div class="paragraph"><p>The other variety of bytestrings resides in Data.ByteString.Lazy. They&#8217;re lazy, but not quite as lazy as lists. Like we said before, there are as many thunks in a list as there are elements. That&#8217;s what makes them kind of slow for some purposes. Lazy bytestrings take a different approach — they are stored in chunks (not to be confused with thunks!), each chunk has a size of 64K. So if you evaluate a byte in a lazy bytestring (by printing it or something), the first 64K will be evaluated. After that, it&#8217;s just a promise for the rest of the chunks. Lazy bytestrings are kind of like lists of strict bytestrings with a size of 64K. When you process a file with lazy bytestrings, it will be read chunk by chunk. This is cool because it won&#8217;t cause the memory usage to skyrocket and the 64K probably fits neatly into your CPU&#8217;s L2 cache.</p></div>
<div class="paragraph"><p>If you look through the documentation for Data.ByteString.Lazy, you&#8217;ll see that it has a lot of functions that have the same names as the ones from Data.List, only the type signatures have ByteString instead of [a] and Word8 instead of a in them. The functions with the same names mostly act the same as the ones that work on lists. Because the names are the same, we&#8217;re going to do a qualified import in a script and then load that script into GHCI to play with bytestrings.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">qualified</span> <span class="nc">Data</span><span class="o">.</span><span class="nc">ByteString</span><span class="o">.</span><span class="nc">Lazy</span> <span class="n">as</span> <span class="n">B</span>
<span class="k">import</span> <span class="nn">qualified</span> <span class="nc">Data</span><span class="o">.</span><span class="nc">ByteString</span> <span class="n">as</span> <span class="n">S</span>
</pre></div></div></div>
<div class="paragraph"><p>B has lazy bytestring types and functions, whereas S has strict ones. We&#8217;ll mostly be using the lazy version.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
The function pack has the type signature pack 
</dt>
<dd>
<p>
[Word8] &#8594; ByteString. What that means is that it takes a list of bytes of type Word8 and returns a ByteString. You can think of it as taking a list, which is lazy, and making it less lazy, so that it&#8217;s lazy only at 64K intervals.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>What&#8217;s the deal with that Word8 type? Well, it&#8217;s like Int, only that it has a much smaller range, namely 0-255. It represents an 8-bit number. And just like Int, it&#8217;s in the Num typeclass. For instance, we know that the value 5 is polymorphic in that it can act like any numeral type. Well, it can also take the type of Word8.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">pack</span> <span class="o">[</span><span class="err">99</span>,<span class="err">97</span>,<span class="err">110</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;can&quot;</span> <span class="nc">Empty</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">pack</span> <span class="o">[</span><span class="err">98</span><span class="kt">..</span><span class="err">120</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;bcdefghijklmnopqrstuvwx&quot;</span> <span class="nc">Empty</span>
</pre></div></div></div>
<div class="paragraph"><p>As you can see, you usually don&#8217;t have to worry about the Word8 too much, because the type system can makes the numbers choose that type. If you try to use a big number, like 336 as a Word8, it will just wrap around to 80.</p></div>
<div class="paragraph"><p>We packed only a handful of values into a ByteString, so they fit inside one chunk. The Empty is like the [] for lists.</p></div>
<div class="paragraph"><p>unpack is the inverse function of pack. It takes a bytestring and turns it into a list of bytes.</p></div>
<div class="paragraph"><p>fromChunks takes a list of strict bytestrings and converts it to a lazy bytestring. toChunks takes a lazy bytestring and converts it to a list of strict ones.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">fromChunks</span> <span class="o">[</span><span class="kt">S.pack</span> <span class="o">[</span><span class="err">40</span>,<span class="err">41</span>,<span class="err">42</span><span class="o">]</span>, <span class="kt">S.pack</span> <span class="o">[</span><span class="err">43</span>,<span class="err">44</span>,<span class="err">45</span><span class="o">]</span>, <span class="kt">S.pack</span> <span class="o">[</span><span class="err">46</span>,<span class="err">47</span>,<span class="err">48</span><span class="o">]]</span>
<span class="nc">Chunk</span> <span class="s">&quot;()*&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;+,-&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;./0&quot;</span> <span class="nc">Empty</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>This is good if you have a lot of small strict bytestrings and you want to process them efficiently without joining them into one big strict bytestring in memory first.</p></div>
<div class="paragraph"><p>The bytestring version of : is called cons It takes a byte and a bytestring and puts the byte at the beginning. It&#8217;s lazy though, so it will make a new chunk even if the first chunk in the bytestring isn&#8217;t full. That&#8217;s why it&#8217;s better to use the strict version of cons, cons' if you&#8217;re going to be inserting a lot of bytes at the beginning of a bytestring.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">cons</span> <span class="mi">85</span> <span class="n">$</span> <span class="n">B</span><span class="o">.</span><span class="n">pack</span> <span class="o">[</span><span class="err">80</span>,<span class="err">81</span>,<span class="err">82</span>,<span class="err">84</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;U&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;PQRT&quot;</span> <span class="nc">Empty</span><span class="o">)</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">B</span><span class="o">.</span><span class="n">cons</span><span class="err">&#39;</span> <span class="mi">85</span> <span class="n">$</span> <span class="n">B</span><span class="o">.</span><span class="n">pack</span> <span class="o">[</span><span class="err">80</span>,<span class="err">81</span>,<span class="err">82</span>,<span class="err">84</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;UPQRT&quot;</span> <span class="nc">Empty</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">foldr</span> <span class="n">B</span><span class="o">.</span><span class="n">cons</span> <span class="n">B</span><span class="o">.</span><span class="n">empty</span> <span class="o">[</span><span class="err">50</span><span class="kt">..</span><span class="err">60</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;2&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;3&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;4&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;5&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;6&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;7&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;8&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;9&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;:&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;;&quot;</span> <span class="o">(</span><span class="nc">Chunk</span> <span class="s">&quot;&lt;&quot;</span>
<span class="nc">Empty</span><span class="o">))))))))))</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">foldr</span> <span class="n">B</span><span class="o">.</span><span class="n">cons</span><span class="err">&#39;</span> <span class="n">B</span><span class="o">.</span><span class="n">empty</span> <span class="o">[</span><span class="err">50</span><span class="kt">..</span><span class="err">60</span><span class="o">]</span>
<span class="nc">Chunk</span> <span class="s">&quot;23456789:;&lt;&quot;</span> <span class="nc">Empty</span>
</pre></div></div></div>
<div class="paragraph"><p>As you can see empty makes an empty bytestring. See the difference between cons and cons'? With the foldr, we started with an empty bytestring and then went over the list of numbers from the right, adding each number to the beginning of the bytestring. When we used cons, we ended up with one chunk for every byte, which kind of defeats the purpose.</p></div>
<div class="paragraph"><p>Otherwise, the bytestring modules have a load of functions that are analogous to those in Data.List, including, but not limited to, head, tail, init, null, length, map, reverse, foldl, foldr, concat, takeWhile, filter, etc.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
It also has functions that have the same name and behave the same as some functions found in System.IO, only Strings are replaced with ByteStrings. For instance, the readFile function in System.IO has a type of readFile :: FilePath &#8594; IO String, while the readFile from the bytestring modules has a type of readFile 
</dt>
<dd>
<p>
FilePath &#8594; IO ByteString. Watch out, if you&#8217;re using strict bytestrings and you attempt to read a file, it will read it into memory at once! With lazy bytestrings, it will read it into neat chunks.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Let&#8217;s make a simple program that takes two filenames as command-line arguments and copies the first file into the second file. Note that System.Directory already has a function called copyFile, but we&#8217;re going to implement our own file copying function and program anyway.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">qualified</span> <span class="nc">Data</span><span class="o">.</span><span class="nc">ByteString</span><span class="o">.</span><span class="nc">Lazy</span> <span class="n">as</span> <span class="n">B</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">fileName1</span><span class="k">:</span><span class="kt">fileName2:</span><span class="k">_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
    <span class="n">copyFile</span> <span class="n">fileName1</span> <span class="n">fileName2</span>

<span class="n">copyFile</span> <span class="o">::</span> <span class="nc">FilePath</span> <span class="o">-&gt;</span> <span class="nc">FilePath</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">copyFile</span> <span class="n">source</span> <span class="n">dest</span> <span class="k">=</span> <span class="k">do</span>
    <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">B</span><span class="o">.</span><span class="n">readFile</span> <span class="n">source</span>
    <span class="n">B</span><span class="o">.</span><span class="n">writeFile</span> <span class="n">dest</span> <span class="n">contents</span>
</pre></div></div></div>
<div class="paragraph"><p>We make our own function that takes two FilePaths (remember, FilePath is just a synonym for String) and returns an I/O action that will copy one file into another using bytestring. In the main function, we just get the arguments and call our function with them to get the I/O action, which is then performed.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ runhaskell bytestringcopy.hs something.txt ../../something.txt</code></pre>
</div></div>
<div class="paragraph"><p>Notice that a program that doesn&#8217;t use bytestrings could look just like this, the only difference is that we used B.readFile and B.writeFile instead of readFile and writeFile. Many times, you can convert a program that uses normal strings to a program that uses bytestrings by just doing the necessary imports and then putting the qualified module names in front of some functions. Sometimes, you have to convert functions that you wrote to work on strings so that they work on bytestrings, but that&#8217;s not hard.</p></div>
<div class="paragraph"><p>Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try, chances are you&#8217;ll get some good performance boosts with very little effort on your part. I usually write programs by using normal strings and then convert them to use bytestrings if the performance is not satisfactory.</p></div>
</div>
<div class="sect2">
<h3 id="_">Виключення</h3>
<div class="paragraph"><p><span class="image">
<img src="images/timber.png" alt="images/timber.png" />
</span>
Всі мови мають процедури, функції та частини коду, що можуть схибити в деякий спосіб. Це просто життєвий факт. Різні мови мають різні шляхи обробки ціх збоїв. В C ми зазвичай використовуємо деяке незвичайне значення повернення (як <code>-1</code> або вказівник <code>null</code>), щоб вказати, що те, що повернула функція, не може розглядатись як звичайне значення. З іншого боку, Java та C# схиляються до використання виключень для обробки збоїв. Коли закидається виключення, контроль виконання перестрибує на деякий визначений вами код, що робить деяке очищення, і можливо пере-закидає виключення, так що інший код обробки помилок зможе потурбуватись про деякі інші речі.</p></div>
<div class="paragraph"><p>Haskell має дуже гарну систему типів. Алгебраїчні типи даних дозволяють такі типи, як <code>Maybe</code> та <code>Either</code>, і ми можемо використовувати значення ціх типів для представлення результатів, що можуть бути, або ні. Повернення в C, скажімо, <code>-1</code> в разі збою, повністю є предметом домовленості. Це також має особливе значення для людини. Якщо ми не будемо обережні, ми можемо розглядати ці незвичайні значення як звичайні, і потім вони можуть наробити безлад і жах в нашому коді. Система типів Haskell дає нам деяку таку-необхідну безпеку в цьому аспекті. Функція <code>a -&gt; Maybe b</code> ясно вказує, що вона може продукувати <code>b</code> огорнуте в <code>Just</code>, або що вона може повернути <code>Nothing</code>. Тип відмінний від простого <code>a -&gt; b</code>, і якщо ми спробуємо використати ці дві функції одну замість іншої, копілятор буде скаржитись на нас.</p></div>
<div class="paragraph"><p>Не зважаючи на присутність виразних типів, що підтримують збійні обчислення, Haskell все ще має підтримку для виключень, оскільки вони мають більше сенсу в I/O контекстах. Багато речей можуть пійти не так, коли ви маєте справу з зовнішнім світом, тому що він такий ненадійний. Наприклад, коли відкривається файл, ціла кіпа речей може пійти не так. Файл може бути заблокований, він може взагалі бути відсутній, або може бути відсутній взагалі весь жорстуий диск, або будь-що ще. Так що це гарно бути в змозі перестрибнути на деяку частину обробки помилок в вашому коді, коли такі помилки трапляються.</p></div>
<div class="paragraph"><p>Гаразд, так що I/O код (тобто нечистий код) може закидати виключення. Це має сенс. То що щодо чистого коду? Гаразд, він також може закидати виключення. Подумайте про функції <code>div</code> та <code>head</code>. Вони мають типи <code>(Integral a) =&gt; a -&gt; a -&gt; a</code> та <code>[a] -&gt; a</code>, відповідно. Ні <code>Maybe</code> або <code>Either</code> в їх типах повернення, і вони обоє можуть схибити! <code>div</code> вибухне вам в обличчя, коли ви спробуєте поділити на ноль, та <code>head</code> впадає в істеріку, коли ви передасте їй порожній список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="n">`div`</span> <span class="mi">0</span>
<span class="o">***</span> <span class="nc">Exception</span><span class="k">:</span> <span class="kt">divide</span> <span class="kt">by</span> <span class="kt">zero</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="o">[]</span>
<span class="o">***</span> <span class="nc">Exception</span><span class="k">:</span> <span class="kt">Prelude.head:</span> <span class="kt">empty</span> <span class="kt">list</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/police.png" alt="images/police.png" />
</span>
Чистий код може закидати виключення, але вони можуть бути перехоплені в I/O частині нашого кода (коли ми всередині блока <code>do</code>, що іде в <code>main</code>). Це тому, що ви не знаєте коли (та взагалі чи) будь-що буде виконане в чистому коді, оскільки він лінивий, та не має гарно визначеного порядку виконання, тоді як I/O код має.</p></div>
<div class="paragraph"><p>Раніше ми казали про те, що нам слідує проводити щонайменьше часу в  I/O частині нашої програми. Логіка нашої програми повинна здебільшого залишатись в наших чистих функціях, оскільки їх результати залежать лише від параметрів, з якими викликаються функції. Коли ми маємо справи з чистими функціями, ви маєте думати лише про те, що повертає функція, оскільки вона не може робити будь-що інше. Це робить ваше життя простіше. Навіть якщо і робити деяку логіку в I/O необхідно (як відкривати файли і подібні речі), повинно утримувати її на мінімумі. Чисті функції ліниві по замовчанню, що означає, що ми не знаємо, коли вони будуть обчислені, і що це насправді не повинно мати значення. Однак як тільки чисті функції починають закидати виключення, стає важливим, коли вони обчислюються. Ось чому ми лише можемо перехоплювати виключення, закинуті в чистому коді, в I/O частині нашого кода. І це погано, оскільки ми бажаємо утримувати I/O частину малою, наскільки це можливо. Однак якщо ми не перехоплюємо їх в I/O частині нашого коду, наша програма падає. Яке рішення? Не змішуйте виключення і чистий код. Отримуйте перевагу від потужної системи типів Haskell, і використовуйте типи як <code>Either</code> та <code>Maybe</code> для представлення результатів, що можуть схибити.</p></div>
<div class="paragraph"><p>Ось чому поки що ми тільки подивимось, як використовувати I/O виключення. I/O виключення є виключення, що виникають коли щось іде не так при взаємодії з зовнішнім світом в I/O дії, що є частиною <code>main</code>. Наприклад, ми можемо спробувати відкрити файл, і потім з'ясовується, що файл був видалений або ще щось. Погляньте на цю програму, яка відкриває файл, чиє ім'я надається в аргументі командного рядка, і каже, скільки рядків має цей файл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.IO</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
          <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
          <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Дуже проста програма. Ми виконуємо I/O дію <code>getArgs</code>, і прикріплюємо перший рядок в списку, що вона видає, до <code>fileName</code>. Потім ми викликаємо <code>contents</code> файла з вмістом цього ім'я. Нарешті ми застосовуємо рядки цього <code>contents</code>, щоб отримати список рядків, і потім ми отримуємо довжину списка щоб надати її до <code>show</code>, щоб отримати рядкове представлення цього числа. Це робить як очікується, але що трапиться, коли ми дамо йому ім'я файла, що не існує?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ runhaskell linecount.hs i_dont_exist.txt
linecount.hs: i_dont_exist.txt: openFile: does not exist <span class="o">(</span>No such file or directory<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ага, ми отримали помилку від GHC, яке каже нам, що файл не існує. Наша програма падає. Що, коли ми бажаємо надрукувати краще повідомлення якщо файл не існує? Один спосіб зробити це є перевірити, чи файл існує, перед спробою відкрити його, використовуючи функцію <code>doesFileExist</code> з <code>System.Directory</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">System.Directory</span>

<span class="n">main</span> <span class="k">=</span> <span class="k">do</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
          <span class="n">fileExists</span> <span class="k">&lt;-</span> <span class="n">doesFileExist</span> <span class="n">fileName</span>
          <span class="k">if</span> <span class="n">fileExists</span>
              <span class="n">then</span> <span class="k">do</span> <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
                      <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>
              <span class="k">else</span> <span class="k">do</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ми зробили <code>fileExists &lt;- doesFileExist fileName</code>, оскільки <code>doesFileExist</code> має тип `doesFileExist 
</dt>
<dd>
<p>
FilePath &#8594; IO Bool`, що означає, що вона повертає I/O дію, що має як результат логічне значення, яке каже нам чи файл існує. Ми не можемо просто використовувати <code>doesFileExist</code> в <code>if</code> виразі напряму.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Іншим рішенням тут може бути використання виключень. Це чудово припустиме використовувати їх в цьому контексті. Неіснуючий файл є виключенням, що походить від I/O, так що перехоплення його в I/O є гарним і пристойним.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Щоб впоратись з цім через використання виключень ми збираємось скористатись перевагами від функції <code>catch</code> з <code>System.IO.Error</code>. Її тип є `catch 
</dt>
<dd>
<p>
IO a &#8594; (IOError &#8594; IO a) &#8594; IO a`. Вона приймає два параметри. Перший є I/O дією. Наприклад це може бути I/O дією, що намагається виконати файл. Другий є так званим обробником. Якщо перша I/O дія, парадана до <code>catch</code>, закидає I/O виключення, це виключення передається в обробник, який вирішує що робити далі. Так що фінальний результат є I/O дія, що буде діяти або як перший параметр, або буде робити те що каже обробник, якщо перша I/O дія закидає виключення.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><span class="image">
<img src="images/puppy.png" alt="images/puppy.png" />
</span>
Якщо ви знайомі з <code>try-catch</code> блоками в мовах як Java або Python, функція <code>catch</code> подібна до них. Перший параметр є річ, що треба спробувати, як щось таке в блоці <code>try</code> в інших, імперативних мовах. Другий параметр є обробником, що приймає виключення, як більшість  <code>catch</code> блоків приймають виключення, що ви потім можете перевіряти, щоб побачити, що трапилось. Обробник викликається, якщо виключення було закинуте.</p></div>
<div class="paragraph"><p>Обробник бере значення типу <code>IOError</code>, що є значенням, яке вказує, що трапилось I/O виключення. Воно також несе інформацію відносно типу виключення, що було закинуте. Як цей тип реалізований залежить від реалізації самої мови, що означає, що ми не можемо досліджувати значення типу <code>IOError</code> через співпадіння шаблону, так само як ми не можемо порівнювати шаблони до значень типу <code>IO something</code>. Ми можемо використовувати декілька корисних предикатів, щоб отримувати корисну інформацію щодо значень типу <code>IOError</code>, які ми вивчино через мить.</p></div>
<div class="paragraph"><p>Так що давайте застосуємо нового друга <code>catch</code>!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">System.IO.Error</span>

<span class="n">main</span> <span class="k">=</span> <span class="n">toTry</span> <span class="n">`catch`</span> <span class="n">handler</span>

<span class="n">toTry</span> <span class="o">::</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">toTry</span> <span class="k">=</span> <span class="k">do</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="n">handler</span> <span class="o">::</span> <span class="nc">IOError</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">handler</span> <span class="n">e</span> <span class="k">=</span> <span class="n">putStrLn</span> <span class="s">&quot;Whoops, had some trouble!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Для початку ви бачите, що ми поклали зворотні апострофи кругом нього, так що ми можемо використовувати його як інфіксну функцію, бо він приймає два параметри. Його використання як інфіксної функції робить його більш читабельним. Так що <code>toTry ``catch`</code> handler` є те саме,що і <code>catch toTry handler</code>, що гарно пасує до його типу. <code>toTry</code> є I/O дія, яку ми намагаємось використати, і <code>handler</code> є функція, що приймає <code>IOError</code>, та повертає дію, яка виконується в випадку виключення.</p></div>
<div class="paragraph"><p>Давайте надамо цьому руху:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ runhaskell count_lines.hs i_exist.txt
The file has <span class="m">3</span> lines!
$ runhaskell count_lines.hs i_dont_exist.txt
Whoops, had some trouble!
</pre></div></div></div>
<div class="paragraph"><p>В обробнику ми не перевіряли, який тип <code>IOError</code> ми отримали. Ми просто кажемо <code>"Whoops, had some trouble!"</code> для любого типу помилок. Просте перехоплення всіх типів виключень в обробнику є поганою практикою в Haskell, так само як в більшості інших мов. Що коли трапляться деякі інші виключення, які ми не бажаємо перехоплювати, як переривання програми або щось інше? Ось чому ми бажаємо зробити ту саму річ, яку ми звичайно робимо також в інших мовах: ми перевіримо, який саме тип виключення ми отримали. Якщо це різновид виключення, який ми бажаємо перехопити, ми робимо наші речі. Якщо ні - ми знову перезапускаємо виключення. Давайте модифікуємо нашу програму для перехоплення тільки виключень, викликаних відсутністю файла.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">System.IO.Error</span>

<span class="n">main</span> <span class="k">=</span> <span class="n">toTry</span> <span class="n">`catch`</span> <span class="n">handler</span>

<span class="n">toTry</span> <span class="o">::</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">toTry</span> <span class="k">=</span> <span class="k">do</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="n">handler</span> <span class="o">::</span> <span class="nc">IOError</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="k">=</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="k">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Все залишається тим самим, крім обробника, який ми модифікували для перехоплення тільки певної групи I/O виключень. Тут ми використали дві нові функції з <code>System.IO.Error</code> — <code>isDoesNotExistError</code> та <code>ioError</code>. <code>isDoesNotExistError</code> є предикатом на <code>IOErrors</code>, що означає, що це функція, що приймає <code>IOError</code> і повертає <code>True</code> або <code>False</code>, що означає що вона має тип <code>isDoesNotExistError :: IOError -&gt; Bool</code>. Ми використовуємо його на виключенні, що передано в наш обробник, щоб побачити, чи це помилка спричинена неіснуванням файла. Тут ми використали синтаксис охоронців, але також можна застосувати  <code>if else</code>. Якщо це не спричинено неіснуванням файла, ми пере-закидаєм виключення, що було передане в обробник за допомогою функції <code>ioError</code>. Вона має тип `ioError 
</dt>
<dd>
<p>
IOException &#8594; IO a`, так що вона приймає <code>IOError</code> і продукує I/O дію, що буде закидати її. I/O має тип <code>IO a</code>, оскільки вона насправді ніколи не видає результат, так що вона може діяти як <code>IO anything</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Так що якщо виключення, закинуте в I/O дії <code>toTry</code>, що ми склеїли разом в блок <code>do</code>, не спричинене неіснуванням файла, <code>toTry ``catch`</code> handler` буде перехоплювати, та потім пере-закидати його. Досить круто, так?</p></div>
<div class="paragraph"><p>Існують декілька предикатів, що діють на <code>IOError</code>, і якщо охоронець не обчислюється до <code>True</code>, обчислення провалюється до наступного охоронця. Предикати, що діють на <code>IOError</code>, такі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">isAlreadyExistsError</span>
<span class="n">isDoesNotExistError</span>
<span class="n">isAlreadyInUseError</span>
<span class="n">isFullError</span>
<span class="n">isEOFError</span>
<span class="n">isIllegalOperation</span>
<span class="n">isPermissionError</span>
<span class="n">isUserError</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість з цього є досить самоописовим. <code>isUserError</code> обислюється до <code>True</code>, коли ми використовуємо функцію <code>userError</code> для створення виключення, що використовується для створення виключень в нашому коді, і оснащення його рядком. Наприклад, ви можете зробити <code>ioError $ userError "remote computer unplugged!"</code>, хоча бажано щоб ви використовували типи як <code>Either</code> та <code>Maybe</code> для представлення можливого збою, замість закидання виключень самому за допомогою <code>userError</code>.</p></div>
<div class="paragraph"><p>Так що ви можете мати обробник, що виглядає дещо подібно до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">handler</span> <span class="o">::</span> <span class="nc">IOError</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="k">=</span> <span class="n">putStrLn</span> <span class="s">&quot;The file doesn&#39;t exist!&quot;</span>
    <span class="o">|</span> <span class="n">isFullError</span> <span class="n">e</span> <span class="k">=</span> <span class="n">freeSomeSpace</span>
    <span class="o">|</span> <span class="n">isIllegalOperation</span> <span class="n">e</span> <span class="k">=</span> <span class="n">notifyCops</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="k">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div></div></div>
<div class="paragraph"><p>де <code>notifyCops</code> та <code>freeSomeSpace</code> є деякі визначені вами I/O дії. Переконайтесь, що перезакинули виключення, якщо воно не співпало з жодною з ваших критерій, інакше ви спричините мовчазний крах вашого застосування в деяких випадках, де це не мало б статись.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<code>System.IO.Error</code> також експортує функції, що дозволяють опитувати наші виключення щодо деяких атрибутів, як що за вказівник файлу, який спричинив помилку, або яке ім'я файлу. Вони починаються на <code>ioe</code>, і ви можете побачити їх повний список в документації. Скажімо ми бажаємо надрукувати ім'я файлу, що спричинив нашу помилку. Ми не можемо надрукувати <code>fileName</code>, яке ми отримали від <code>getArgs</code>, оскільки в обробник надійшло тільки <code>IOError</code>, і обробник не знає більше нічого іншого. Функція залежить тільки від параметрів, з якими вона викликана. Ось чому ми можемо використати фуункцію <code>ioeGetFileName</code>, що має тип `ioeGetFileName 
</dt>
<dd>
<p>
IOError &#8594; Maybe FilePath`. Вона приймає <code>IOError</code> як параметр і можливо повертає <code>FilePath</code> (що є тільки синонімом типу для <code>String</code>, пам'ятаємо, так що це різновид тієї самої речі). Те що вона в основному робить, це виділяє шлях файлу з <code>IOError</code>, якщо зможе. Давайте модифікуємо нашу програму для роздрукування нашого шляху файла, відповідального за виникле виключення.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">System.Environment</span>
<span class="k">import</span> <span class="nn">System.IO</span>
<span class="k">import</span> <span class="nn">System.IO.Error</span>

<span class="n">main</span> <span class="k">=</span> <span class="n">toTry</span> <span class="n">`catch`</span> <span class="n">handler</span>

<span class="n">toTry</span> <span class="o">::</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">toTry</span> <span class="k">=</span> <span class="k">do</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:_</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">getArgs</span>
           <span class="n">contents</span> <span class="k">&lt;-</span> <span class="n">readFile</span> <span class="n">fileName</span>
           <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;The file has &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="o">(</span><span class="n">length</span> <span class="o">(</span><span class="n">lines</span> <span class="n">contents</span><span class="o">))</span> <span class="o">++</span> <span class="s">&quot; lines!&quot;</span>

<span class="n">handler</span> <span class="o">::</span> <span class="nc">IOError</span> <span class="o">-&gt;</span> <span class="nc">IO</span> <span class="o">()</span>
<span class="n">handler</span> <span class="n">e</span>
    <span class="o">|</span> <span class="n">isDoesNotExistError</span> <span class="n">e</span> <span class="k">=</span>
        <span class="k">case</span> <span class="n">ioeGetFileName</span> <span class="n">e</span> <span class="n">of</span> <span class="nc">Just</span> <span class="n">path</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="n">$</span> <span class="s">&quot;Whoops! File does not exist at: &quot;</span> <span class="o">++</span> <span class="n">path</span>
                                 <span class="nc">Nothing</span> <span class="o">-&gt;</span> <span class="n">putStrLn</span> <span class="s">&quot;Whoops! File does not exist at unknown location!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="k">=</span> <span class="n">ioError</span> <span class="n">e</span>
</pre></div></div></div>
<div class="paragraph"><p>В охоронці, коли <code>isDoesNotExistError</code> є <code>True</code>, ми використали  <code>case</code> вираз для виклику <code>ioeGetFileName</code> з <code>e</code>, та потім порівняли шаблон щодо значення <code>Maybe</code>, яке він повертає. Застосування виразів <code>case</code> загально використовується коли ви бажаєте порівняти шаблон з дечим, не привносячи нову функцію.</p></div>
<div class="paragraph"><p>Ви не маєте використовувати один обробник для перехоплення виключень у всій вашій частині I/O. Ви можете просто охопити певну частину вашого I/O коду в <code>catch</code>, або ви можете охопити деякі з ни в <code>catch</code>, та використовувати різні обробники для них, десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">main</span> <span class="k">=</span> <span class="k">do</span> <span class="n">toTry</span> <span class="n">`catch`</span> <span class="n">handler1</span>
          <span class="n">thenTryThis</span> <span class="n">`catch`</span> <span class="n">handler2</span>
          <span class="n">launchRockets</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>toTry</code> використовує <code>handler1</code> як обробник, та <code>thenTryThis</code> використовує <code>handler2</code>. <code>launchRockets</code> не є параметром для <code>catch</code>,так що якщо воно може закинути виключення, це має занапастити нашу програму, хіба що <code>launchRockets</code> використовує перехоплення внутрішньо для обробки своїх власних виключень. Звичайно, <code>toTry</code>, <code>thenTryThis</code> та <code>launchRockets</code> є I/O дії що мають бути склеєні разом з використанням синтаксису <code>do</code>, і гіпотетично визначені деінде в іншому місці. Це дещо подібно до блоків <code>try-catch</code> в інших мовах, де ви можете оточити всю вашу програму в єдиний <code>try-catch</code>, або ви можете використати більш поміркований підхід, та використовувати різні блоки в різних частинах вашого коду, щоб контролювати, який тип обробки помилок відбувається.</p></div>
<div class="paragraph"><p>Тепер ви знаєте, як мати справи з I/O виключеннями! Закидання виключень з чистого коду та справи з ними тут не були розглянуті, здебільшого через те, що, як ми казали, Haskell пропонує значно кращий спосіб вказувати на помилки, ніж звертатись до I/O для їх відловлення. Навіть при склеюванні разом I/O дій що можуть схибити, я схиляюсь мати їх тип дещо на кшталт <code>IO (Either a b)</code>, що означає, що вони є нормальними I/O діями, але результат, що вони видають після виконання, матиме тип <code>Either a b</code>, що означає або <code>Left a</code>, або <code>Right b</code>.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-10-22 22:50:51 EEST
</div>
</div>
</body>
</html>
