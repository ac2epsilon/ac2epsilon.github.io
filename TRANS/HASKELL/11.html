<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="____">Функтори, аплікативні функтори, моноїди</h2>
<div class="sectionbody">
<div class="paragraph"><p>Поєднання в Haskell чистоти, функцій вищого порядку, параметризованих типів даних алгебраїки та класів типів дозволяє нам реалізувати поліморфізм на набагато вищому рівні, ніж це можливо в інших мовах. Нам не потрібно думати про типи, що належать до великої ієрархії типів. Натомість ми думаємо про те, як можуть діяти типи, а потім з'єднуємо їх з відповідними класами. <code>Int</code> може діяти як багато речей. Він може діяти як рівнозначна річ, як впорядкована річ, як численна річ тощо.</p></div>
<div class="paragraph"><p>Класи типу відкриті, це означає, що ми можемо визначити свій власний тип даних, подумати про те, як він може діяти, і пов’язати це з типовими класами, що визначають його поведінку. Через це і завдяки чудовій системі Haskell, яка дозволяє нам багато чого знати про функцію, лише знаючи її декларацію типу, ми можемо визначити типи класів, які визначають поведінку, яка є дуже загальною та абстрактною. Ми зустрічалися з класами типів, які визначають операції, щоб перевірити, чи дві речі рівні, або порівняти дві речі за деяким упорядкуванням. Це дуже абстрактна та елегантна поведінка, але ми просто не вважаємо їх за щось особливе, тому що ми маємо справу з ними більшу частину свого життя. Нещодавно ми зустріли функтори, які, в основному, позначають речі які можуть відображатись. Це приклад корисної і все ще досить абстрактної властивості, яку можуть описати типокласи. В цьому розділі ми детальніше розглянемо функтори, а також дещо сильніші та корисніші версії функторів, які називаються аплікативними функторами. Ми також поглянемо на моноїди, які схожі на шкарпетки.</p></div>
<div class="sect2">
<h3 id="__">Редукційні функтори</h3>
<div class="paragraph"><p><span class="image">
<img src="images/frogtor.png" alt="images/frogtor.png" />
</span>
Про функтори ми вже говорили у своєму маленькому розділі. Якщо ви ще його не прочитали, вам, ймовірно, варто поглянути на нього прямо зараз, а може, пізніше, коли у вас буде більше часу. Або ви можете просто зробити вигляд, що ви його прочитали.</p></div>
<div class="paragraph"><p>Але ось швидка підказка: функтори - це речі, по яких можна зробити відображення, наприклад, списки, <code>Maybe</code>, дерева тощо. У Haskell вони описуються типокласом <code>Functor</code>, який має лише один метод типокласу, а саме <code>fmap</code>, який має тип <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>. Він говорить: дайте мені функцію, яка приймає <code>a</code>, і повертає <code>b</code> і коробку з <code>a</code> (або декількома з них) всередині, і я дам вам коробку з <code>b</code> (або декількома з них) всередині неї. Це свого роду застосовує функцію до елемента всередині коробки.</p></div>
<div class="paragraph"><p>Слово поради. Багато разів використовується аналогія коробки, щоб допомогти вам зрозуміти, як функціонують функтори, і пізніше, ймовірно, ми будемо використовувати ту саму аналогію для аплікативних функторів і монад. Це нормальна аналогія, яка допомагає людям спочатку зрозуміти функтори, просто не сприймайте це занадто буквально, тому що для деяких функторів аналогія коробки повинна бути розтягнута дуже тонко, щоб все-таки зберігати деяку правду. Більш правильним терміном для того, що таке функтор, буде обчислювальний контекст. Контекст може полягати в тому, що обчислення може мати значення або воно може бути невдалим (<code>Maybe</code> та <code>Either a</code>), або що може бути більше значень (списків).</p></div>
<div class="paragraph"><p>Якщо ми хочемо зробити конструктор типу екземпляром <code>Functor</code>, він повинен мати вид <code>* -&gt; *</code>, що означає, що він повинен приймати рівно один конкретний тип як параметр типу. Наприклад, можна зробити екземпляр, оскільки для створення конкретного типу потрібен параметр одного типу, наприклад, <code>Int</code> або <code>Maybe String</code>. Якщо конструктор типів приймає два параметри, як, наприклад, <code>Either</code>, нам доведеться частково застосувати конструктор типу, поки він не прийме лише один параметр типу. Таким чином, ми не можемо писати <code>instance Functor Either where</code>, але ми можемо записати <code>instance Functor (Either a) where</code>, і тоді, якщо ми уявимо що <code>fmap</code> призначена лише для <code>Either a</code>, вона мала би декларацію типу <code>map ::(b -&gt; c) -&gt; Either a b -&gt; Either a c</code>. Як бачимо, частина <code>Either a</code> є виправленою, тому що Either a приймає лише один тип параметра, тоді як просто <code>Either</code> бере два, тому <code>fmap ::(b -&gt; c) -&gt; Either b -&gt; Either c</code> справді не має сенсу .</p></div>
<div class="paragraph"><p>We&#8217;ve learned by now how a lot of types (well, type constructors really) are instances of Functor, like [], Maybe, Either a and a Tree type that we made on our own. We saw how we can map functions over them for great good. In this section, we&#8217;ll take a look at two more instances of functor, namely IO and (&#8594;) r.
Ми вже дізналися, як багато типів (гаразд, насправді конструктори типів) є екземплярами <code>Functor</code>, як <code>[]</code>, <code>Maybe</code>, <code>Either a</code>, або тип <code>Tree</code>, який ми створили самостійно. Ми бачили, як чудово ми можемо відображати функції над ними. У цьому розділі ми розглянемо ще два екземпляри функтора, а саме <code>IO</code> та <code>(-&gt;) r</code>.</p></div>
<div class="paragraph"><p>Якщо якесь значення має тип, скажімо, <code>IO String</code>, це означає, що це дія вводу/виводу, яка, виконуючись, вийде в реальний світ і отримає для нас деяку строку, яка в результаті надійде як результат. Ми можемо використовувати <code>&lt;-</code> in <code>do</code> синтаксисі, щоб прив'язати результат до імені. Ми згадували, що дії вводу/виводу - це як коробки з маленькими ніжками, які виходять назовні і приносять для нас деяке значення із зовнішнього світу. Ми можемо перевірити, що вони отримали, але після перевірки нам доведеться обернути значення назад в <code>IO</code>. Роздумуючи про цю коробку з аналогією маленьких ніжок, ми можемо побачити, як <code>IO</code> діє як функтор.</p></div>
<div class="paragraph"><p>Подивимося, як <code>IO</code> є екземпляром <code>Functor</code>. Коли ми <code>fmap</code> функцію над дією вводу-виводу, ми хочемо повернути дію вводу-виводу, яка робить те саме, але наша функція застосовується до значення результату.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">IO</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">action</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">result</span> <span class="ow">&lt;-</span> <span class="n">action</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">result</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Результатом відображення чогось на дії вводу-виводу буде дія вводу-виводу, тому мимоволі використовуємо синтаксис, щоб склеїти дві дії та зробити нову. У реалізації для <code>fmap</code> ми робимо нову дію вводу-виводу, яка спочатку виконує оригінальну дію вводу-виводу та викликає її <code>result</code> результату. Потім робимо <code>return (f result)</code>. Як відомо, <code>return</code> це функція, яка виконує дію вводу-виводу, яка нічого не робить, а лише щось представляє як результат. Дія, яку виробляє блок <code>do</code>, завжди матиме значення результату останньої дії. Ось чому ми використовуємо <code>return</code> для того, щоб зробити дію вводу-виводу, яка насправді нічого не робить. Вона просто представляє <code>f result</code> як результат нової дії вводу-виводу.</p></div>
<div class="paragraph"><p>Ми можемо пограти з цим, щоб отримати деяку інтуїцію. Насправді це дуже просто. Ознайомтеся з цим кодом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
          <span class="kr">let</span> <span class="n">line&#39;</span> <span class="ow">=</span> <span class="n">reverse</span> <span class="n">line</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;You said &quot;</span> <span class="o">++</span> <span class="n">line&#39;</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Yes, you really said&quot;</span> <span class="o">++</span> <span class="n">line&#39;</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Користувачеві пропонується ввести рядок, і ми повертаємо його назад, лише обернувши його. Ось як це переписати за допомогою <code>fmap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="n">reverse</span> <span class="n">getLine</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;You said &quot;</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
          <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Yes, you really said&quot;</span> <span class="o">++</span> <span class="n">line</span> <span class="o">++</span> <span class="s">&quot; backwards!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/alien.png" alt="images/alien.png" />
</span>
Так само, як коли ми робимо <code>fmap reverse Just "blah"</code>, щоб отримати <code>Just "halb"</code>, ми можемо <code>fmap reverse getLine</code>. <code>getLine</code> - це введення-виведення, яке має тип <code>IO String</code> та <code>reverse</code> відображення по ньому, дає нам дію вводу-виводу, яка вийде у реальний світ та отримає рядок, а потім застосує <code>reverse</code> до її результату. Так само, як ми можемо застосувати функцію до чогось, що знаходиться у вікні <code>Maybe</code>, ми можемо застосувати функцію до того, що знаходиться всередині <code>IO</code> вікна, лише воно повинне вийти у реальний світ, щоб щось отримати. Тоді, коли ми прив’яжемо його до імені використовуючи <code>&lt;-</code>, ім'я відображатиме результат, до якого вже застосовано <code>reverse</code>.</p></div>
<div class="paragraph"><p>Дія вводу-виводу <code>fmap (++ "!") getLine</code> поводиться так само, як і <code>getLine</code>, тільки щоб її результат завжди мав доданий <code>"!"</code>!</p></div>
<div class="paragraph"><p>Якщо ми подивимось, який би тип <code>fmap</code> був, якби він обмежився <code>IO</code>, це буде <code>fmap ::(a -&gt; b) -&gt; IO a -&gt; IO b</code>. <code>fmap</code> приймає функцію та дію вводу-виводу та повертає нову дію вводу-виводу, подібно до старої, за винятком того, що до її результату застосовується функція.</p></div>
<div class="paragraph"><p>Якщо ви коли-небудь виявляєте, що зв'язуєте результат дії вводу-виводу з іменем, лише щоб застосувати до нього функцію і викликати щось інше, подумайте про використання <code>fmap</code>, оскільки це виглядає краще. Якщо ви хочете застосувати кілька перетворень до деяких даних всередині функтора, ви можете оголосити власну функцію на верхньому рівні, зробити лямбда функцію або в ідеалі використовувати композицію функцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Char</span>
<span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">line</span> <span class="ow">&lt;-</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">intersperse</span> <span class="sc">&#39;-&#39;</span> <span class="o">.</span> <span class="n">reverse</span> <span class="o">.</span> <span class="n">map</span> <span class="n">toUpper</span><span class="p">)</span> <span class="n">getLine</span>
          <span class="n">putStrLn</span> <span class="n">line</span>
<span class="o">$</span> <span class="n">runhaskell</span> <span class="n">fmapping_io</span><span class="o">.</span><span class="n">hs</span>
<span class="nf">hello</span> <span class="n">there</span>
<span class="kt">E</span><span class="o">-</span><span class="kt">R</span><span class="o">-</span><span class="kt">E</span><span class="o">-</span><span class="kt">H</span><span class="o">-</span><span class="kt">T</span><span class="o">-</span> <span class="o">-</span><span class="kt">O</span><span class="o">-</span><span class="kt">L</span><span class="o">-</span><span class="kt">L</span><span class="o">-</span><span class="kt">E</span><span class="o">-</span><span class="kt">H</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви, напевно, знаєте, <code>intersperse '-' . reverse . map toUpper</code> - це функція, яка приймає рядок, <code>map toUpper</code> по ній, застосовує <code>reverse</code> до результату, а потім застосовує <code>intersperse '-'</code> до цього результату. Це як записати <code>(\ xs -&gt; intersperse '-' (reverse(map toUpper xs)))</code>, тільки красивіше.</p></div>
<div class="paragraph"><p>Інший екземпляр <code>Functor</code>, з яким ми весь час мали справу, але не знали, що це <code>Functor</code>, є <code>(-&gt;) r</code>. Ви, мабуть, трохи розгублені, адже що набіса значить це <code>(-&gt;) r</code>? Тип функції <code>r -&gt; a</code> можна переписати як <code>(-&gt;) r a</code>, так само, як ми можемо записати <code>2 + 3</code> як <code>(+) 2 3</code>. Коли ми дивимось на це як <code>(-&gt;) r a</code>, ми можемо побачити <code>(-&gt;)</code> у дещо іншому світлі, оскільки ми бачимо, що це просто тип конструктора, який приймає два параметри типу, як в <code>Either</code>. Але пам’ятайте, ми говорили, що конструктор типу повинен приймати рівно один параметр типу, щоб він міг зробити екземпляр <code>Functor</code>. Тому ми не можемо зробити <code>(-&gt;)</code> екземпляром <code>Functor</code>. Але якщо ми частково застосуємо його до <code>(-&gt;) r</code>, це не створює проблем. Якщо синтаксис дозволив конструкторам типів частково застосувати з розділами (як ми можемо частково застосувати <code>+</code>, зробивши <code>(2+)</code>, що те саме, що <code>(+) 2</code>), ви можете написати <code>(-&gt;) r</code> як <code>(r -&gt;)</code>. Як функціонують функтори? Що ж, давайте подивимось на реалізацію, яка лежить в <code>Control.Monad.Insances</code></p></div>
<div class="paragraph"><p>Зазвичай ми позначаємо функції, які беруть що завгодно, і повертають що-небудь як <code>a -&gt; b</code>. <code>r -&gt; a</code> - те саме, ми просто використали інші літери для змінних типів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо синтаксис дозволяв би це, він міг бути записаний як</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="n">r</span> <span class="ow">-&gt;</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="n">g</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Але це не так, тому ми повинні писати це попереднім способом.</p></div>
<div class="paragraph"><p>Перш за все, давайте подумаємо про тип <code>fmap</code>. Це <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>. Тепер ми подумки замінимо всі <code>f</code>, що є роллю, що грає наш примірник функтора, на <code>(-&gt;) r</code>. Ми зробимо це, щоб побачити, як повинен поводитися <code>fmap</code> для цього конкретного екземпляра. Отримуємо <code>fmap ::(a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)</code>. Тепер, що ми можемо зробити, - записати типи <code>(-&gt;) r a</code> і <code>(-&gt;) r b</code> як інфікс <code>r -&gt; a</code> і <code>r -&gt; b</code>, як це зазвичай робимо з функціями. Тепер ми отримуємо <code>fmap ::(a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.</p></div>
<div class="paragraph"><p>Хммм добре. Відображення однієї функції над функцією повинно створювати функцію, подібно до відображення функції над <code>Maybe</code> має створити <code>Maybe</code>, а відображення функції над списком має створити список. Що говорить нам тип <code>fmap ::(a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code> для цього примірника? Що ж, ми бачимо, що вона приймає функцію від <code>a</code> до <code>b</code> і функцію від <code>r</code> до <code>a</code> і повертає функцію від <code>r</code> до <code>b</code>. Це вам щось нагадує? Так! Функціональну композицію! Ми вводимо вихід <code>r -&gt; a</code> на вхід <code>a -&gt; b</code>, щоб отримати функцію <code>r -&gt; b</code>, яка саме полягає у композиції функцй. Якщо ви подивитеся на те, як визначений екземпляр вище, ви побачите, що це лише композиція функції. Ще один спосіб написання цього примірника:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>This makes the revelation that using fmap over functions is just composition sort of obvious. Do :m + Control.Monad.Instances, since that&#8217;s where the instance is defined and then try playing with mapping over functions.
Це визнає очевидним факт, що використання <code>fmap</code> над функціями просто композиція. Зробіть <code>:m + Control.Monad.Insances</code>, оскільки там визначено екземпляр, а потім спробуйте грати з відображенням функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span> <span class="mi">1</span>
<span class="mi">303</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="p">(</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="mi">1</span>
<span class="mi">303</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">)</span> <span class="o">.</span> <span class="p">(</span><span class="o">+</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="mi">1</span>
<span class="mi">303</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">show</span> <span class="o">.</span> <span class="p">(</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="mi">1</span>
<span class="s">&quot;300&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо викликати <code>fmap</code> як інфіксну функцію, так що схожість з <code>.</code> прозора. У другому рядку ми відображаємо <code>(* 3)</code> над <code>(+100)</code>, що призводить до функції, яка буде приймати вхід, викликати на ньому <code>(+100)</code>, а потім викликати <code>(* 3)</code> на результаті. Ми викликаємо цю функцію для 1.</p></div>
<div class="paragraph"><p>Як тут дотримується аналогія коробки? Добре, якщо ви розтягнете її, це має місце. Коли ми використовуємо <code>fmap (+3)</code> над <code>Just 3</code>, легко уявити <code>Maybe</code> як коробку, яке містить деякий вміст, до якого ми застосовуємо функцію <code>(+3)</code>. Але що коли ми робимо <code>fmap (* 3) (+100)</code>? Ну, ви можете розглядати функцію <code>(+100)</code> як коробку, що містить її кінцевий результат. На кшталт того, як дії вводу/виводу можна розглядати як вікно, яке вийде в реальний світ і отримає певний результат. Використання <code>fmap (* 3)</code> на <code>(+100)</code> створить іншу функцію, яка діє на зразок <code>(+100)</code>, але перед тим, як створити результат, буде застосовано <code>(* 3)</code> до цього результату. Тепер ми можемо побачити, як <code>fmap</code> діє як <code>.</code> для функцій.</p></div>
<div class="paragraph"><p>Те, що <code>fmap</code> - це функціональна композиція при використанні функцій, зараз не дуже корисно, але принаймні дуже цікаво. Це також трохи згинає наш розум і давайте подивимось, як речі, які діють більше як обчислення, ніж коробки (<code>IO</code> та <code>(-&gt;) r</code>), можуть бути функторами. Функція, яка відображається через обчислення, призводить до того ж обчислення, але результат цього обчислення модифікується з функцією.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lifter.png" alt="images/lifter.png" />
</span>
Перш ніж ми перейдемо до правил, яких слід дотримуватися <code>fmap</code>, давайте ще раз подумаємо про тип <code>fmap</code>. Її тип <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>. Нам не вистачає обмеження класу <code>(Functor f) =&gt;</code>, але ми його пропустили тут для стислості. Оскільки ми так чи інакше говоримо про функтори, тому ми знаємо, що означає <code>f</code>. Коли ми вперше дізналися про <em>каровані</em> функції, ми сказали, що всі функції Haskell насправді приймають один параметр. Функція <code>a -&gt; b -&gt; c</code> насправді приймає лише один параметр типу <code>a</code>, а потім повертає функцію <code>b -&gt; c</code>, яка приймає один параметр і повертає <code>c</code>. Ось так, якщо ми викличемо функцію з занадто малою кількістю параметрів (тобто частково застосуємо її), ми повернемо функцію, яка приймає кількість параметрів, які ми залишили (якщо ми думаємо про функції, як знову приймати кілька параметрів). Отже, <code>a -&gt; b -&gt; c</code> можна записати як <code>a -&gt; (b -&gt; c)</code>, щоб зробити вигляд більш наочним.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
In the same vein, if we write fmap 
</dt>
<dd>
<p>
(a &#8594; b) &#8594; (f a &#8594; f b), we can think of fmap not as a function that takes one function and a functor and returns a functor, but as a function that takes a function and returns a new function that&#8217;s just like the old one, only it takes a functor as a parameter and returns a functor as the result. It takes an a &#8594; b function and returns a function f a &#8594; f b. This is called lifting a function. Let&#8217;s play around with that idea by using GHCI&#8217;s :t command:
У такому ж ключі, якщо ми пишемо <code>fmap ::(a -&gt; b) -&gt; (fa -&gt; fb)</code>, ми можемо думати про <code>fmap</code> не як про функцію, яка бере одну функцію та функтор і повертає функтор, а як функцію, яка приймає функцію і повертає нову функцію, подібно до старої, лише вона приймає функтор як параметр і повертає функтор як результат. Вона бере функцію <code>a -&gt; b</code> і повертає функцію <code>f a -&gt; f b</code>. Це називається підйомом функції. Давайте пограємо з цією ідеєю, використовуючи команду GHCI: <code>t:</code>
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Вираз <code>fmap (* 2)</code>- це функція, яка приймає функтор <code>f</code> над числами і повертає функтор над числами. Цей функтор може бути списком, <code>Maybe</code>, <code>Either String</code> або будь чим. Вираз <code>fmap (replicate 3)</code> візьме функтор над будь-яким типом і поверне функтор над списком елементів цього типу.</p></div>
<div class="paragraph"><p>Коли ми говоримо функтор над числами, ви можете думати про це як про функтор, який має в собі числа. Перший варіант трохи химерніший і технічніше правильний, але останній зазвичай простіше зрозуміти.</p></div>
<div class="paragraph"><p>Це ще більш очевидно, якщо ми частково застосуємо, скажімо, <code>fmap (++ "!")</code>, і потім прив’яжемо його до імені в GHCI.</p></div>
<div class="paragraph"><p>Ви можете вважати <code>fmap</code> або функцією, яка приймає функцію і функтор, а потім відображає цю функцію над функтором, або ви можете вважати це функцією, яка приймає функцію і піднімає цю функцію, щоб вона працювала на функторах. Обидва погляди правильні та в Haskell рівнозначні.</p></div>
<div class="paragraph"><p>Тип <code>fmap (replicate 3) ::(Functor f) =&gt; f a -&gt; f [a]</code> означає, що функція буде працювати на будь-якому функторі. Що саме воно буде робити, залежить від того, на якому функторі ми його будемо використовувати. Якщо ми використовуємо <code>fmap (replicate 3)</code> на списку, буде обрана реалізація списку для <code>fmap</code>, яка є лише <code>map</code>. Якщо ми будемо використовувати його на <code>Maybe a</code>, вона застосує <code>replicate 3</code> до значення всередині <code>Just</code>, або якщо це <code>Nothing</code>, то воно залишається <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Right</span> <span class="s">&quot;blah&quot;</span><span class="p">)</span>
<span class="kt">Right</span> <span class="p">[</span><span class="s">&quot;blah&quot;</span><span class="p">,</span><span class="s">&quot;blah&quot;</span><span class="p">,</span><span class="s">&quot;blah&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Left</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>
<span class="kt">Left</span> <span class="s">&quot;foo&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Далі ми розглянемо закони функтора. Для того, щоб щось було функтором, воно повинно задовольняти деяким законам. Очікується, що всі функтори проявлятимуть певні типи функціональних властивостей та поведінки. Вони повинні надійно вести себе як речі, які можна відображувати. Виклик <code>fmap</code> на функторі повинен просто відображати функцію над функтором, не більше того. Така поведінка описана в законах функтора. Є два з них, якими повинні дотримуватися всі екземпляри <code>Functor</code>. Вони не застосовуються Haskell автоматично, тому вам доведеться перевірити їх самостійно.</p></div>
<div class="paragraph"><p>Перший закон функторів зазначає, що якщо ми будемо відображати функцію <code>id</code> на функторі, той, який ми повернемо, повинен бути таким же, як і вихідний. Якщо ми напишемо це трохи формальніше, це означає, що <code>fmap id = id</code>. По суті це говорить про те, що якщо ми робимо <code>fmap id</code> над функтором, він повинен бути таким же, як просто виклик ідентичності на функторі. Пам'ятайте, <code>id</code> - це функція ідентичності, яка просто повертає немодифікований параметр. Його також можна записати як <code>\x -&gt; x</code>. Якщо ми розглядаємо функтор як щось, що можна відобразити, закон <code>fmap id = id</code> видається тривіальним або очевидним.</p></div>
<div class="paragraph"><p>Давайте подивимось, чи справедливий цей закон для кількох значень функторів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">id</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">id</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="kt">[]</span>
<span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми подивимось на реалізацію <code>fmap</code> для, скажімо, <code>Maybe</code>, ми можемо зрозуміти, чому існує перший закон функтора.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми уявляємо, що <code>id</code> відіграє роль параметра <code>f</code> у реалізації. Ми бачимо, що якщо ми <code>fmap id</code> над <code>Just x</code>, результатом буде <code>Just (id x)</code>, і оскільки <code>id</code> просто повертає його параметр, ми можемо зробити висновок, що <code>Just (id x)</code> дорівнює <code>Just x</code>. Отже, тепер ми знаємо, що якщо відобразити ідентичність на значення <code>Maybe</code> з конструктором <code>Just</code>, ми повернемо це саме значення.</p></div>
<div class="paragraph"><p>Бачити, що <code>id</code> відображення на значення <code>Nothing</code> повертає те саме значення, є тривіальним. Отже, з цих двох рівнянь у реалізації для <code>fmap</code> ми бачимо, що закон <code>fmap id = id</code> виконується.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/justice.png" alt="images/justice.png" />
</span>
Другий закон говорить, що композиція двох функцій, а потім відображення отриманої функції через функтор має бути таким же, як спочатку відображення однієї функції над функтором, а потім відображення іншої. Формально це означає, що <code>fmap (f. G) = fmap f. fmap g</code>. Або, щоб записати це іншим способом, для будь-якого функтора <code>F</code> має дотримуватись таке: <code>fmap (f. G) F = fmap f (fmap g F)</code>.</p></div>
<div class="paragraph"><p>Якщо ми можемо показати, що якийсь тип підкоряється обом законам функторів, ми можемо розраховувати на те, що він має ті ж основні поведінки, що й інші функтори, коли справа стосується відображення. Ми можемо знати, що коли ми використовуємо <code>fmap</code> на ній, не буде нічого, крім відображення, що відбувається за лаштунками, і що вона буде діяти як річ, яку можна відобразити, тобто функтор. Ви з'ясовуєте, як другий закон дотримується для певного типу, переглядаючи реалізацію <code>fmap</code> для цього типу, а потім використовуючи метод, який використовували ми, щоб перевірити, чи дотримується перший закон.</p></div>
<div class="paragraph"><p>Якщо ви хочете, ми можемо перевірити, як діє закон другого функтора для <code>Maybe</code>. Якщо ми робимо <code>fmap (f. G)</code> над <code>Nothing</code>, ми отримуємо <code>Nothing</code>, тому що якщо виконати <code>fmap</code> з будь-якою функцією над <code>Nothing</code>, нічого не повертається. Якщо ми робимо <code>fmap f (fmap g Nothing)</code>, з тієї ж причини ми отримуємо <code>Nothing</code>. Гаразд, бачити, як діє другий закон на <code>Maybe</code> якщо це значення <code>Nothing</code>, це досить легко, майже тривіально.</p></div>
<div class="paragraph"><p>Як щодо того, якщо це просто якесь <code>Just</code> значення? Що ж, якщо ми робимо <code>fmap (f . G) (Just x)</code>, то з реалізації ми бачимо, що воно реалізоване як <code>Just ( (f . G) x)</code>, що, звичайно, <code>Just (f (g x))</code>. Якщо ми робимо <code>fmap f (fmap g (Just x))</code>, то з реалізації бачимо, що <code>fmap g (Just x)</code> - це <code>Just (g x)</code>. Ergo, <code>fmap f (fmap g (Just x))</code> дорівнює <code>fmap f (Just (g x))</code>, і з реалізації ми бачимо, що це дорівнює <code>Just (f (g x))</code>.</p></div>
<div class="paragraph"><p>Якщо вас трохи бентежить цей доказ, не хвилюйтесь. Будьте впевнені, що ви розумієте, як працює композиція функцій. Багато разів можна інтуїтивно побачити, як дотримуються ці закони, оскільки типи діють як контейнери або функції. Ви також можете просто спробувати їх на купі різних значень типу і мати можливість з певністю сказати, що тип дійсно підкоряється законам.</p></div>
<div class="paragraph"><p>Давайте подивимося на патологічний приклад конструктора типу, який є екземпляром типу класу <code>Functor</code>, але насправді не є функтором, оскільки він не відповідає законам. Скажімо, у нас є тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">CMaybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">CNothing</span> <span class="o">|</span> <span class="kt">CJust</span> <span class="kt">Int</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>The C here stands for counter. It&#8217;s a data type that looks much like Maybe a, only the Just part holds two fields instead of one. The first field in the CJust value constructor will always have a type of Int, and it will be some sort of counter and the second field is of type a, which comes from the type parameter and its type will, of course, depend on the concrete type that we choose for CMaybe a. Let&#8217;s play with our new type to get some intuition for it.
<code>C</code> тут означає лічильник. Це тип даних, який схожий на <code>Maybe a</code>, лише частина <code>Just</code> містить два поля замість одного. Перше поле в конструкторі значень <code>CJust</code> завжди матиме тип <code>Int</code>, і це буде якийсь лічильник, а друге поле типу <code>a</code>, яке походить від параметра типу, і його тип буде, звичайно, залежати від конкретного типу, який ми обираємо для <code>CMaybe a</code>. Давайте пограємо з нашим новим типом, щоб отримати певну інтуїцію.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CNothing</span>
<span class="kt">CNothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span>
<span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">CNothing</span>
<span class="kt">CNothing</span> <span class="ow">::</span> <span class="kt">CMaybe</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span>
<span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span> <span class="ow">::</span> <span class="kt">CMaybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CJust</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">CJust</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми використовуємо конструктор <code>CNothing</code>, поля немає, і якщо ми використовуємо конструктор <code>CJust</code>, перше поле є цілим числом, а друге поле може бути будь-якого типу. Давайте зробимо це екземпляром <code>Functor</code> так, що кожного разу, коли ми використовуємо <code>fmap</code>, функція застосовується до другого поля, тоді як перше поле збільшується на 1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">CMaybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">CNothing</span> <span class="ow">=</span> <span class="kt">CNothing</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">CJust</span> <span class="n">counter</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">CJust</span> <span class="p">(</span><span class="n">counter</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це на зразок реалізації екземпляра для <code>Maybe</code>, за винятком того, що коли ми робимо <code>fmap</code> над значенням, яке не являє собою порожнє поле (значення <code>CJust</code>), ми не просто застосовуємо функцію до вмісту, ми також збільшуємо лічильник на 1. Все поки здається крутим, ми навіть можемо трохи пограти з цим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;ha&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;ho&quot;</span><span class="p">)</span>
<span class="kt">CJust</span> <span class="mi">1</span> <span class="s">&quot;hoha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;he&quot;</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;ha&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;ho&quot;</span><span class="p">))</span>
<span class="kt">CJust</span> <span class="mi">2</span> <span class="s">&quot;hohahe&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;blah&quot;</span><span class="p">)</span> <span class="kt">CNothing</span>
<span class="kt">CNothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дотримується законів функтора? Для того, щоб побачити, що щось не підкоряється закону, достатньо знайти лише один суперечливий приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="n">id</span> <span class="p">(</span><span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span>
<span class="kt">CJust</span> <span class="mi">1</span> <span class="s">&quot;haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">id</span> <span class="p">(</span><span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span>
<span class="kt">CJust</span> <span class="mi">0</span> <span class="s">&quot;haha&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ах! Ми знаємо, що перший закон функторів говорить, що якщо ми відображаємо <code>id</code> над функтором, він повинен бути таким самим, як просто виклик <code>id</code> тим самим функтором. Але, як ми бачили з цього прикладу, це не вірно для нашого функтора <code>CMaybe</code>. Незважаючи на те, що він є частиною типокласу <code>Functor</code>, він не підпорядковується законам функтора і тому не є функтором. Якщо би хтось використовував наш тип <code>CMaybe</code> як функтор, він би сподівався, що він виконує закони функтора, як хороший функтор. Але <code>CMaybe</code> не в змозі бути функтором, навіть якщо він видає себе за такий, тому використання його як функтора може призвести до дефектного коду. Коли ми використовуємо функтор, це не має значення, спочатку складемо кілька функцій, а потім відобразимо їх через функтор або якщо ми просто відображаємо кожну функцію над функтором послідовно. Але для <code>CMaybe</code> це важливо, тому що він відслідковує, скільки разів його відображали. Не круто! Якби ми хотіли, щоб <code>CMaybe</code> підкорявся законам функтора, нам довелося б зробити так, щоб поле <code>Int</code> залишалося таким же, коли ми використовуємо <code>fmap</code>.</p></div>
<div class="paragraph"><p>Спочатку закони функтора можуть здатися трохи заплутаними та непотрібними, але потім ми бачимо, що якщо ми знаємо, що тип підкоряється обом законам, ми можемо зробити певні припущення щодо того, як він буде діяти. Якщо тип підкоряється законам функтора, ми знаємо, що виклик <code>fmap</code> у значенні цього типу буде відображати лише функцію над ним, не більше того. Це призводить до більш абстрактного та розширюваного коду, оскільки ми можемо використовувати закони, щоб міркувати про поведінку, яку повинен мати будь-який функтор, і робити функції, які надійно працюють на будь-якому функторі.</p></div>
<div class="paragraph"><p>Усі екземпляри <code>Functor</code> у стандартній бібліотеці підкоряються цим законам, але ви можете перевірити, якщо ви мені не вірите. І наступного разу, коли ви введете екземпляр <code>Functor</code>, знайдіть хвилину, щоб переконатися, що він виконує закони функтора. Після того, як ви розібралися з достатньою кількістю функторів, ви начебто інтуїтивно бачите властивості та поведінку, які вони мають спільні, і не важко інтуїтивно зрозуміти, чи підпорядковується якийсь закон законам функтора. Але навіть не маючи інтуїції, ви завжди можете просто переходити по рядках реалізації та бачити, чи існують закони чи намагатися знайти контр приклад.</p></div>
<div class="paragraph"><p>Ми також можемо розглядати функтори як речі, які виводять значення в контекст. Наприклад, <code>Just 3</code> виводить значення 3 у контексті того, що воно може взагалі не виводити будь-які значення. <code>[1,2,3]</code> виводить три значення - 1, 2 і 3, контекст полягає в тому, що може бути кілька значень або немає значень. Функція <code>(+3)</code> виведе значення залежно від того, який параметр буде заданий.</p></div>
<div class="paragraph"><p>Якщо ви вважаєте функтори як речі, що виводять значення, ви можете вважати відображення функторів як приєднання перетворення до виходу функтора, що змінює значення. Коли ми робимо <code>fmap (+3) [1,2,3]</code>, ми додаємо перетворення <code>(+3)</code> до виводу <code>[1,2,3]</code>. Тому кожен раз, коли ми дивимося на число, яке виводить список, <code>(+ 3)</code> буде застосовано до нього. Інший приклад - відображення функцій. Коли ми робимо <code>fmap (+3) (* 3)</code>, ми додаємо перетворення <code>(+3)</code> до можливого виходу <code>(* 3)</code>. Дивлячись на це таким чином, ми даємо деяку інтуїцію, чому використання <code>fmap</code> для функцій є просто композицією <code>(fmap (+3) (* 3)</code> дорівнює <code>(+3). (* 3)</code>, що дорівнює <code>\ x -&gt; ( (x * 3) +3))</code>. Оскільки ми беремо таку функцію, як <code>(* 3)</code>, тоді ми приєднуємо перетворення <code>(+3</code>) до її виводу. Результат все ще є функцією, лише коли ми дамо йому число, воно помножиться на три, а потім воно пройде через додане перетворення, де воно буде додане до трьох. Це те, що відбувається з композицією.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Аплікативні функтори</h3>
<div class="paragraph"><p><span class="image">
<img src="images/present.png" alt="images/present.png" />
</span>
У цьому розділі ми розглянемо аплікативні функтори, які є зведеними функторами, представлені в Haskell типокласом Applicative, знайденим у модулі <code>Control.Applicative</code>.</p></div>
<div class="paragraph"><p>Як відомо, у Haskell функції за замовчуванням каруються. Це означає, що функція, яка, здається, приймає декілька параметрів, насправді приймає лише один параметр і повертає функцію, яка приймає наступний параметр тощо. Якщо функція типу <code>a -&gt; b -&gt; c</code>, ми зазвичай кажемо, що вона бере два параметри і повертає <code>c</code>, але насправді вона займає <code>a</code> і повертає функцію <code>b -&gt; c</code>. Ось чому ми можемо називати функцію як <code>f x y</code> або як <code>(f x) y</code>. Цей механізм дозволяє нам частково застосовувати функції, просто викликаючи їх із занадто малою кількістю параметрів, що призводить до функцій, які ми можемо потім передати іншим функціям.</p></div>
<div class="paragraph"><p>Поки, коли ми відображували функції над функторами, ми зазвичай відображали функції, що приймають лише один параметр. Але що відбувається, коли ми відобразимо функцію типу * , яка приймає два параметри, над функтором? Давайте розглянемо пару конкретних прикладів цього. Якщо у нас є <code>Just 3</code> і ми робимо <code>fmap (* ) (Just 3)</code>, що ми отримуємо? З реалізації екземпляра <code>Maybe</code> для <code>Functor</code> ми знаємо, що якщо це значення <code>Just something</code>, воно застосує функцію до чогось усередині <code>Just</code>. Тому виконання <code>fmap (* ) (Just 3)</code> призводить до <code>Just ((* ) 3)</code>, який також може бути записаний як <code>Just (* 3)</code>, якщо ми використовуємо розділи. Цікаво! Ми отримуємо функцію, загорнуту в <code>Just</code>!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;hey&quot;</span><span class="p">)</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;hey&quot;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">([</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="n">compare</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="nf">fmap</span> <span class="n">compare</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="n">compare</span> <span class="s">&quot;A LIST OF CHARS&quot;</span>
<span class="nf">fmap</span> <span class="n">compare</span> <span class="s">&quot;A LIST OF CHARS&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">/</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Fractional</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми робимо <code>map compare</code>, яка має тип <code>(Ord a) =&gt; a -&gt; a -&gt; Ordering</code> над списком символів, ми отримаємо список функцій типу <code>Char -&gt; Ordering</code>, оскільки функція <code>compare</code> частково застосовується з символами у списку. Це не список <code>(Ord a) =&gt; a -&gt; Ordering</code>, тому що перший <code>a</code>, який застосовано, був <code>Char</code>, тому другий <code>a</code> повинен мати тип <code>Char</code>.</p></div>
<div class="paragraph"><p>Ми бачимо, як відображаючи "багатопараметричні" функції над функторами, ми отримуємо функтори, що містять функції всередині них. То тепер, що ми можемо з ними зробити? Ну, по перше ми можемо відобразити функції, які приймають ці функції як параметри над ними, тому що все, що знаходиться всередині функтора, буде надано функції, яку ми відображаємо через нього як параметр.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">a</span>
<span class="nf">a</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="mi">9</span><span class="p">)</span> <span class="n">a</span>
<span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">27</span><span class="p">,</span><span class="mi">36</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Але що робити, якщо у нас є значення функтора <code>Just (3 *)</code> і значення функтора <code>Just 5</code>, і ми хочемо вийняти функцію з <code>Just (3 *)</code> і відобразити її на <code>Just 5</code>? З нормальними функторами нам не пощастило, адже все, що вони підтримують, - це лише відображення нормальних функцій на існуючі функтори. Навіть коли ми відображали <code>\f -&gt; f 9</code> через функтор, який містив функції всередині нього, ми просто відображали нормальну функцію над ним. Але ми не можемо відобразити функцію, яка знаходиться у функторі, над іншим функтором із тим, що пропонує нам <code>fmap</code>. Ми могли б порівняти шаблон до конструктора <code>Just</code>, щоб отримати функцію з неї, а потім відобразити її на <code>Just 5</code>. Але ми шукаємо більш загальний та абстрактний спосіб зробити це, який працює у функторах.</p></div>
<div class="paragraph"><p>Знайомтесь з типокласом <code>Applicative</code>. Він лежить у модулі <code>Control.Applicative</code>, і він визначає два способи, <code>pure</code> та <code>&lt;*&gt;</code>. Він не забезпечує реалізацію за замовчуванням для будь-якого з них, тому ми повинні визначати обидва, якщо ми хочемо, щоб щось було аплікативним функтором. Клас визначається так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Applicative</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span>
    <span class="p">(</span><span class="o">&lt;*&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="n">f</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Це просте визначення класу з трьох рядків нам багато чого говорить! Почнемо з першого рядка. Він починає визначення класу <code>Applicative</code>, а також вводить обмеження для класу. Це говорить про те, що якщо ми хочемо зробити конструктор типів частиною класу <code>Applicative</code>, він повинен бути спочатку у <code>Functor</code>. Ось чому, якщо ми знаємо, що якщо конструктор типу є частиною класу <code>Applicative</code>, він також знаходиться у <code>Functor</code>, і тому ми можемо використовувати на ньому <code>fmap</code>.</p></div>
<div class="paragraph"><p>Перший метод, який він визначає, називається <code>pure</code>. Декларація типу є <code>pure ::a -&gt; f a</code>. <code>f</code> тут відіграє роль нашого аплікативного функтора. Оскільки Haskell має дуже гарну систему типів і тому, що все, що функція може зробити, це взяти деякі параметри і повернути деяке значення, ми можемо багато сказати з декларації типу, і це не є винятком. <code>pure</code> повинен приймати значення будь-якого типу та повертати аплікативний функтор із цим значенням всередині. Коли ми говоримо всередині, ми знову використовуємо аналогію коробки, хоча ми бачили, що вона не завжди витримує критику. Але декларація типу <code>a -&gt; f</code> все ще є досить описовою. Ми беремо значення і загортаємо його в аплікативний функтор, який має це значення як результат всередині.</p></div>
<div class="paragraph"><p>Кращим способом мислення про <code>pure</code> було б сказати, що він приймає значення і ставить його в якийсь контекст за замовчуванням (або чистий) - мінімальний контекст, який все ще дає це значення.</p></div>
<div class="paragraph"><p>Функція <code>&lt;* &gt;</code> дійсно цікава. Вона має декларацію типу <code>f (a -&gt; b) -&gt; f a -&gt; f b</code>. Це вам щось нагадує? Звичайно, <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>. Це свого роду розгодований <code>fmap</code>. Тоді як <code>fmap</code> приймає функцію і функтор і застосовує функцію всередині функтора, <code>&lt;*&gt;</code> приймає функтор, який має в ньому функцію та інший функтор, і свого роду витягає цю функцію з першого функтора, а потім відображає його на другому. Коли я кажу витягає, я фактично маю на на увазі виконати, а потім витягнути, можливо навіть послідовність. Чому ми побачимо незабаром.</p></div>
<div class="paragraph"><p>Давайте розглянемо реалізацію екземпляра <code>Applicative</code> для <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="kt">Just</span>
    <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="p">(</span><span class="kt">Just</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">something</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">something</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову з визначення класу ми бачимо, що <code>f</code>, що грає роль аплікативного функтора, повинен брати один параметр конкретного типу, тому ми пишемо <code>instance Applicative Maybe where</code>,  замість того, щоб писати <code>instance Applicative (Maybe а) where</code>.</p></div>
<div class="paragraph"><p>По-перше <code>pure</code>. Раніше ми говорили, що його призначення щось взяти і загорнути в аплікативний функтор. Ми написали <code>pure = Just</code>, тому що конструктори значень як <code>Just</code> є нормальними функціями. Ми могли також написати <code>pure x = Just x</code>.</p></div>
<div class="paragraph"><p>Далі ми маємо визначення для <code>&lt;* &gt;</code>. Ми не можемо витягти функцію з <code>Nothing</code>, оскільки воно не має функції всередині. Тому ми кажемо, що якщо ми намагаємося витягти функцію з <code>Nothing</code>, результат - <code>Nothing</code>. Якщо ви подивитесь на визначення класу для <code>Applicative</code>, ви побачите, що існує обмеження класу <code>Functor</code>, а це означає, що ми можемо припустити, що обидва параметра <code>&lt;*&gt;</code> є функторами. Якщо перший параметр - це не <code>Nothing</code>, а <code>Just</code> з деякою функцією всередині, ми говоримо, що потім хочемо відобразити цю функцію над другим параметром. Це також враховує випадок, коли другим параметром є <code>Nothing</code>, тому що виконання <code>fmap</code> з будь-якою функцією над <code>Nothing</code> поверне <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Тож для <code>Maybe</code> <code>&lt;*&gt;</code> витягує функцію з лівого значення, якщо це <code>Just</code>, і відображає його над правим значенням. Якщо будь-який з параметрів є <code>Nothing</code>, результат буде <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Добре круто чудово. Дамо цьому вир.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">9</span>
<span class="kt">Just</span> <span class="mi">12</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">10</span>
<span class="kt">Just</span> <span class="mi">13</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">9</span>
<span class="kt">Just</span> <span class="mi">12</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">++</span><span class="s">&quot;hahah&quot;</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="s">&quot;woot&quot;</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми бачимо, як <code>pure (+3)</code> і <code>Just (+3)</code> те саме в цьому випадку. Використовуйте <code>pure</code>, якщо ви маєте справу зі значеннями <code>Maybe</code> в аплікативному контексті (тобто, використовуючи їх з <code>&lt;*&gt;</code>), інакше дотримуйтесь <code>Just</code>. Перші чотири вхідні рядки демонструють, як функція витягується та потім відображається, але в цьому випадку їх можна було досягти, просто зіставивши розгорнуті функції по функторам. Останній рядок цікавий тим, що ми намагаємося витягти функцію з <code>Nothing</code>, а потім відобразити її через щось, що, звичайно, призводить до <code>Nothing</code>.</p></div>
<div class="paragraph"><p>З нормальними функторами ви можете просто зіставити функцію над функтором, і тоді ви не зможете отримати результат жодним загальним способом, навіть якщо результат є частково застосованою функцією. З іншого боку, аплікативні функтори дозволяють керувати кількома функторами з однією функцією. Ознайомтеся з цим кодом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>
<span class="kt">Just</span> <span class="mi">8</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="mi">5</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/whale.png" alt="images/whale.png" />
</span>
Що тут відбувається? Давайте подивимось, крок за кроком. <code>&lt;* &gt;</code> є ліво-асоціативним, що означає, що <code>pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5</code> - це те саме, що <code>(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5</code>. По-перше, функція <code>+</code>  розміщується у функторі, що в цьому випадку є значення <code>Maybe</code>, яке містить функцію. Отже, спочатку у нас є <code>pure (+)</code>, а це <code>Just (+)</code>. Далі трапляється <code>Just (+) &lt;* &gt; Just 3</code>. Результат цього - <code>Just (3+)</code>. Це відбувається через часткове застосування. Лише застосування <code>3</code> до функції <code>+</code> призводить до функції, яка бере один параметр і додає до нього <code>3</code>. Нарешті, виконується <code>Just (3+) &lt;*&gt; Just 5</code>, що призводить до отримання <code>Just 8</code>.</p></div>
<div class="paragraph"><p>Хіба це не дивовижно ?! Аплікативні функтори та аплікативний стиль виконання <code>pure f &lt;* &gt; x &lt;*&gt; y &lt;*&gt;</code> &#8230; дозволяють нам взяти функцію, яка очікує параметри, які не обов'язково загорнуті у функтори, і використовувати цю функцію для роботи на кількох значеннях які є у контекстах функтора. Функція може приймати стільки параметрів, скільки ми хочемо, оскільки вона завжди частково застосовується крок за кроком між зустрічними <code>&lt;*&gt;</code>.</p></div>
<div class="paragraph"><p>This becomes even more handy and apparent if we consider the fact that pure f &lt;*&gt; x equals fmap f x. This is one of the applicative laws. We&#8217;ll take a closer look at them later, but for now, we can sort of intuitively see that this is so. Think about it, it makes sense. Like we said before, pure puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, we did the same as just mapping that function over that applicative functor. Instead of writing pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; &#8230;, we can write fmap f x &lt;*&gt; y &lt;*&gt; &#8230;. This is why Control.Applicative exports a function called &lt;$&gt;, which is just fmap as an infix operator. Here&#8217;s how it&#8217;s defined:
Це стає ще більш зручним і очевидним, якщо врахувати той факт, що <code>pure f &lt;* &gt; x</code> дорівнює <code>fmap f x</code>. Це один із аплікативних законів. Ми детальніше розглянемо їх пізніше, але наразі ми можемо якось інтуїтивно побачити, що це так. Подумайте про це, воно має сенс. Як ми говорили раніше, <code>pure</code> ставить значення в контексті за замовчуванням. Якщо ми просто помістимо функцію в контекст за замовчуванням, а потім витягнемо і застосуємо її до значення всередині іншого аплікативного функтора, ми зробили те саме, що просто відобразили цю функцію над цим аплікативним функтором. Замість того, щоб писати <code>pure f &lt;* &gt; x &lt;*&gt; y &lt;*&gt;</code> &#8230;, ми можемо написати <code>fmap fx &lt;*&gt; y &lt;*&gt;</code> &#8230;. Ось чому <code>Control.Applicative</code> експортує функцію під назвою <code>&lt;$&gt;</code>, яка є просто <code>fmap</code> як інфіксний оператор. Ось як вона визначена:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">&lt;$&gt;</span><span class="p">)</span> <span class="ow">::</span><span class="p">(</span><span class="kt">Functor</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
<span class="nf">f</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">fmap</span> <span class="n">f</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Йо! Швидке нагадування: змінні типу не залежать від імен параметрів чи інших імен значень. Тут <code>f</code> в декларції функції - це змінна типу з обмеженням класу, яка говорить про те, що будь-який конструктор типу, який замінює <code>f</code>, повинен бути в типокласі <code>Functor</code>. <code>f</code> в тілі функції позначає функцію, яку ми відображаємо через <code>x</code>. Те, що ми використовували <code>f</code> для представлення обох, не означає, що вони якимось чином представляють те саме.</p></div>
<div class="paragraph"><p>Використовуючи <code>&lt;$&gt;</code>, аплікативний стиль дійсно сяє, тому що тепер, якщо ми хочемо застосувати функцію <code>f</code> між трьома прикладними функторами, ми можемо записати <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. Якби параметри були не аплікативними функторами, а нормальними значеннями, ми б записали <code>f x y z</code>.</p></div>
<div class="paragraph"><p>Давайте докладніше розглянемо, як це працює. У нас є значення <code>Just "johntra"</code> і значення <code>Just "volta"</code>, і ми хочемо об'єднати їх в один рядок всередині <code>Maybe</code> функтора. Ми робимо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">Just</span> <span class="s">&quot;johntra&quot;</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="s">&quot;volta&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;johntravolta&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Перш ніж ми побачимо, як це відбувається, порівняйте наведений рядок із цим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="s">&quot;johntra&quot;</span> <span class="s">&quot;volta&quot;</span>
<span class="s">&quot;johntravolta&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивовижно! Щоб використовувати звичайну функцію на аплікативних функторах, просто посипте кілька <code>&lt;$&gt;</code> і <code>&lt;*&gt;</code>, і функція буде працювати над аплікативах та повертати аплікатив. Наскільки це круто?</p></div>
<div class="paragraph"><p>У будь-якому разі, коли ми робимо <code>(++) &lt;$&gt; Just "johntra" &lt;* &gt; Just "volta"</code>, перший <code>(++)</code>, який має тип <code>(++) ::[a] -&gt; [a] - &gt; [a]</code> відображається на просто <code>"johntra"</code>, в результаті чого значення є таким же, як <code>Just ("johntra" ++)</code> і має тип <code>Maybe ([Char] -&gt; [Char])</code>. Зверніть увагу, як перший параметр <code>(++)</code> був з'їдений та як перетворився на <code>Chars</code>. І тепер відбувається <code>Just ("johntra" ++) &lt;*&gt; Just "volta"</code>, яка виймає функцію з <code>Just</code> і відображає її на <code>Just "volta"</code>, в результаті чого отримуємо <code>Just "johntravolta"</code>. Якби будь-яке з двох значень було <code>Nothing</code>, результат також був би <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Поки що ми використовували тільки <code>Maybe</code> в наших прикладах, і ви можете думати, що аплікативні функтори - це все про <code>Maybe</code>. Але існує маса інших примірників <code>Applicative</code>, тому підемо і познайомимось з ними!</p></div>
<div class="paragraph"><p>Списки (власне конструктор типу списку, <code>[]</code>) - це аплікативні функтори. Який сюрприз! Ось як <code>[]</code> є екземпляром <code>Applicative</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span> <span class="n">x</span> <span class="o">|</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">fs</span><span class="p">,</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Раніше ми говорили, що <code>pure</code> приймає значення і ставить його в контекст за замовчуванням. Або іншими словами, мінімальний контекст, який все-таки приносить це значення. Мінімальним контекстом для списків буде порожній список, <code>[]</code>, але порожній список представляє відсутність значення, тому він не може утримувати в собі значення, для якого ми використовували <code>pure</code>. Ось чому <code>pure</code> приймає значення і ставить його в одиночний список. Аналогічним чином, мінімальний контекст для аплікативного функтора <code>Maybe</code> був би <code>Nothing</code>, але він представляє відсутність значення замість значення. Так що <code>pure</code> реалізується як <code>Just</code> в реалізації екземпляра для <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="s">&quot;Hey&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;Hey&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="s">&quot;Hey&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">String</span>
<span class="kt">Just</span> <span class="s">&quot;Hey&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Що до <code>&lt;*&gt;</code>? Якщо ми подивимось на тип <code>&lt;*&gt;</code>, якби він був обмежений лише списками, це було б <code>(&lt;*&gt;) ::[a -&gt; b] -&gt; [a] -&gt; [b]</code>. Він реалізований за допомогою осяжності списку. <code>&lt;*&gt;</code> має якось витягнути функцію з лівого параметра, а потім відобразити її через правий параметр. Але справа в тому, що лівий список може мати нуль функцій, одну функцію або кілька функцій всередині. Правий список також може містити кілька значень. Ось чому ми використовуємо осяжність списку, щоб зписувати з обох списків. Ми застосовуємо всі можливі функції з лівого списку до кожного можливого значення з правого списку. Отриманий список має всі можливі поєднання застосування функції з лівого списку до значеннь у правому.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[(</span><span class="o">*</span><span class="mi">0</span><span class="p">),(</span><span class="o">+</span><span class="mi">100</span><span class="p">),(</span><span class="o">^</span><span class="mi">2</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>У лівому списку є три функції, а в правому - три значення, тому в отриманому списку буде дев'ять елементів. Кожна функція у лівому списку застосовується до кожної функції у правій. Якщо у нас є список функцій, які приймають два параметри, ми можемо застосувати ці функції між двома списками.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[(</span><span class="o">+</span><span class="p">),(</span><span class="o">*</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>&lt;* &gt;`є ліво-асоціативним, `[(+), (*)] &lt;*&gt; [1,2]</code> відбувається спочатку, в результаті виходить список, такий же як <code>[(1 +), (2 +), (1 *), (2 *)]</code>, оскільки кожна функція зліва застосовується до кожного значення праворуч. Потім відбувається <code>[(1 +), (2 +), (1 *), (2 *)] &lt;*&gt; [3,4]</code>, що дає кінцевий результат.</p></div>
<div class="paragraph"><p>Використання додаткового стилю зі списками - це цікаво! Дивитися:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="s">&quot;ha&quot;</span><span class="p">,</span><span class="s">&quot;heh&quot;</span><span class="p">,</span><span class="s">&quot;hmm&quot;</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="s">&quot;?&quot;</span><span class="p">,</span><span class="s">&quot;!&quot;</span><span class="p">,</span><span class="s">&quot;.&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;ha?&quot;</span><span class="p">,</span><span class="s">&quot;ha!&quot;</span><span class="p">,</span><span class="s">&quot;ha.&quot;</span><span class="p">,</span><span class="s">&quot;heh?&quot;</span><span class="p">,</span><span class="s">&quot;heh!&quot;</span><span class="p">,</span><span class="s">&quot;heh.&quot;</span><span class="p">,</span><span class="s">&quot;hmm?&quot;</span><span class="p">,</span><span class="s">&quot;hmm!&quot;</span><span class="p">,</span><span class="s">&quot;hmm.&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову, подивіться, як ми використовували звичайну функцію, яка приймає два рядки між двома аплікативними функторами рядків, просто вставивши відповідні аплікативні оператори.</p></div>
<div class="paragraph"><p>Ви можете розглядати списки як недетерміновані обчислення. Значення типу <code>100</code> або <code>"what"</code> можна розглядати як детерміновані обчислення, які мають лише один результат, тоді як список типу <code>[1,2,3]</code> можна розглядати як обчислення, яке не може визначити, який результат він хоче мати , тож це дає нам усі можливі результати. Отже, коли ви робите щось на кшталт <code>(+) &lt;$&gt; [1,2,3] &lt;*&gt; [4,5,6]</code>, ви можете вважати це як додавання двох недетермінованих обчислень за допомогою <code>+</code> для створення іншого недетерміновані обчислення, і навіть менше впевнені в його результаті.</p></div>
<div class="paragraph"><p>Використання аплікативного стилю на списках часто є хорошою заміною для осяжності списків. У другому розділі ми хотіли побачити всі можливі добутки <code>[2,5,10]</code> та <code>[8,10,11]</code>, тому ми робили таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми просто списуємо з двох списків і застосовуємо функцію між кожною комбінацією елементів. Це також можна зробити в аплікативному стилі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Мені це здається прозорішим, оскільки простіше зрозуміти, що ми просто викликаємо <code>*</code> між двома недетермінованими обчисленнями. Якби б ми хотіли отримати усі можливі добутки з цих двох списків, що більше 50, ми просто зробили:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">50</span><span class="p">)</span> <span class="o">$</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Неважко зрозуміти, що чистий для списків <code>f &lt;* &gt; xs</code> дорівнює <code>fmap f xs</code>. <code>pure f</code> - це просто <code>[f]</code> і <code>[f] &lt;*&gt; xs</code> застосує кожну функцію у лівому списку до кожного значення у правому, але в лівому списку є лише одна функція, тож це як відображення.</p></div>
<div class="paragraph"><p>Ще один екземпляр <code>Applicative</code>, з яким ми вже стикалися, - це <code>IO</code>. Ось як реалізується екземпляр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">IO</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="ow">=</span> <span class="n">return</span>
    <span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">a</span>
        <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">b</span>
        <span class="n">return</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/knight.png" alt="images/knight.png" />
</span>
Оскільки <code>pure</code> полягає лише у тому, щоб поставити значення в мінімальний контекст, який все-таки вважає його результатом, має сенс, що <code>pure</code> - це просто <code>return</code>, оскільки <code>return</code> робить саме це; вона робить дію вводу-виводу, яка нічого не робить. Вона дає лише деяке значення як результат, але насправді не виконує жодних операцій вводу-виводу, таких як друк до терміналу або зчитування з файлу.</p></div>
<div class="paragraph"><p>Якби <code>&lt;* &gt;</code> були спеціалізовані для <code>IO</code>, він мав би тип <code>(&lt;*&gt;) ::IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>. Воно братиме дію вводу-виводу, що видає функцію як результат, іншу дію вводу-виводу і створить нову дію вводу-виводу з тих двох, які, виконуючись, спочатку виконують першу для отримання функції, потім виконують другу - отримати значення. І тоді отримуємо функцію, застосовану до значення як результат. Ми використовували для реалізації <code>do</code> синтаксис. Пам'ятайте, що <code>do</code> синтаксис - це взяти кілька дій вводу-виводу та склеїти їх в одне, саме це ми тут і робимо.</p></div>
<div class="paragraph"><p>З <code>Maybe</code> і <code>[]</code> ми могли б вважати <code>&lt;*&gt;</code> просто вилученням функції з її лівого параметра, а потім свого роду застосуванням її над правим. З <code>IO</code> вилучення все ще в грі, але тепер ми також маємо поняття послідовності, тому що ми робимо дві дії вводу-виводу і ми впорядковуємо або склеюємо їх в одну. Ми повинні дістати функцію з першої дії вводу-виводу, але для отримання результату дії вводу-виводу вона повинна бути виконана.</p></div>
<div class="paragraph"><p>Розглянемо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">myAction</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">myAction</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">b</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
    <span class="n">return</span> <span class="o">$</span> <span class="n">a</span> <span class="o">++</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дія вводу-виводу, яка запитує користувача ввести два рядки і результатом має поєднання ціх рядків. Ми досягли цього, склеївши дві <code>I/O</code> дії <code>getLineта</code> та <code>return</code>, тому що ми хотіли, щоб наша нова зклеєна дія мала результат <code>a ++ b</code>. Ще одним способом написання цього було б використання аплікативного стилю.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">myAction</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">myAction</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">getLine</span> <span class="o">&lt;*&gt;</span> <span class="n">getLine</span>
</pre></div></div></div>
<div class="paragraph"><p>Те, що ми робили раніше, створювало дію вводу-виводу, яка застосовувала функцію між результатами двох інших дій вводу-виводу, і це те саме. Пам'ятайте, <code>getLine</code> - це введення-виведення з типом <code>getLine ::IO String</code>. Коли ми використовуємо <code>&lt;*&gt;</code> між двома аплікативними функторами, результат є аплікативним функтором, тому все це має сенс.</p></div>
<div class="paragraph"><p>Якщо ми повернемось до аналогії коробки, ми можемо уявити <code>getLine</code> як коробку, яка вийде в реальний світ і підтягне нам рядок. Виконання <code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> створює нову, більшу скриньку, яка надсилає ці дві скриньки для отримання рядків з терміналу, а потім представляє конкатенацію цих двох рядків як результат.</p></div>
<div class="paragraph"><p>Тип виразу <code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> - це <code>IO String</code>, а це означає, що це вираз є абсолютно нормальною дією вводу/виводу, як і будь-яка інша, яка також містить значення результату всередині, як і інші дії вводу/виводу. Ось чому ми можемо робити такі речі, як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">getLine</span> <span class="o">&lt;*&gt;</span> <span class="n">getLine</span>
    <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;The two lines concatenated turn out to be: &quot;</span> <span class="o">++</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви коли-небудь виявляєте, що пов’язуєте деякі дії вводу-виводу з іменами, а потім викликаєте якусь функцію на них і представляєте це як результат, використовуючи <code>return</code>, подумайте про використання аплікативного стилю, тому що це, можливо, трохи більш стисло і коротко.</p></div>
<div class="paragraph"><p>Ще один екземпляр <code>Applicative</code> - <code>(-&gt;) r</code>, тобто функції. Вони рідко використовуються у застосувальному стилі поза кодовим гольфом, але вони все ще цікаві як аплікативи, тому давайте подивимось на те, як реалізується екземпляр функції.</p></div>
<div class="paragraph"><p>If you&#8217;re confused about what (&#8594;) r means, check out the previous section where we explain how (&#8594;) r is a functor.
Якщо вас бентежить питання про те, що означає <code>(-&gt;) r</code>, перегляньте попередній розділ, де ми пояснюємо, як <code>(-&gt;) r</code> може бути функтором.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми перетворюємо значення в аплікативний функтор за допомогою <code>pure</code>, результат, який він отримує, завжди повинен бути таким значенням. Мінімальний контекст за замовчуванням, який як і раніше дає це значення. Ось чому в реалізації екземпляра функції <code>pure</code> приймає значення і створює функцію, яка ігнорує його параметр і завжди повертає це значення. Якщо ми подивимось на тип для <code>pure</code>, але спеціалізованого для екземпляра (&#8594;) r, це <code>pure ::a -&gt; (r -&gt; a)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">pure</span> <span class="mi">3</span><span class="p">)</span> <span class="s">&quot;blah&quot;</span>
<span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Через карування застосування функції є ліво-асоціативним, тому ми можемо опустити дужки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pure</span> <span class="mi">3</span> <span class="s">&quot;blah&quot;</span>
<span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація екземпляра для <code>&lt;*&gt;</code> трохи зашифрована, тому найкраще, якщо ми просто подивимось на те, як використовувати функції в якості аплікативних функторів в аплікативному стилі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
<span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="mi">5</span>
<span class="mi">508</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик <code>&lt;* &gt;</code> на двох аплікативних функторах призводить до отримання аплікативного функтора, тому, якщо ми будемо використовувати його на двох функціях, ми повернемо функцію. То що тут відбувається? Коли ми робимо <code>(+) &lt;$&gt; (+3) &lt;*&gt; (* 100)</code>, ми створюємо функцію, яка використовуватиме <code>+</code> на результатах <code>(+3)</code> і <code>(* 100)</code> і повертаємо її. Щоб продемонструвати на реальному прикладі, коли ми зробили <code>(+) &lt;$&gt; (+3) &lt;*&gt; (* 100) $ 5</code>, 5 спочатку застосували до <code>(+3)</code> та <code>(* 100)</code>, в результаті чого отримали <code>8</code> та <code>500</code>. Потім <code>+</code> визивається з <code>8</code> і <code>500</code>, в результаті чого стає <code>508</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="mi">5</span>
<span class="p">[</span><span class="mf">8.0</span><span class="p">,</span><span class="mf">10.0</span><span class="p">,</span><span class="mf">2.5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/jazzb.png" alt="images/jazzb.png" />
</span>
Тут те ж саме. Ми створюємо функцію, яка буде викликати функцію <code>\x y z -&gt; [x, y, z]</code> з можливими результатами з <code>(+3)</code>, <code>(* 2)</code> і <code>(/ 2)</code>. <code>5</code> подається до кожної з трьох функцій, а потім <code>\ x y z -&gt; [x, y, z]</code> викликається з ціма результатами.</p></div>
<div class="paragraph"><p>Ви можете розглядати функції як коробки, що містять їх кінцеві результати, тому виконання <code>k &lt;$&gt; f &lt;* &gt; g</code> створює функцію, яка буде викликати <code>k</code> з кінцевими результатами з <code>f</code> і <code>g</code>. Коли ми робимо щось на зразок <code>(+) &lt;$&gt; Just 3 &lt;* &gt; Just 5</code>, ми використовуємо <code>+</code> на значеннях, які можуть бути або не бути там, що також призводить до значення, яке може бути або не бути там. Коли ми робимо <code>(+) &lt;$&gt; (+10) &lt;*&gt; (+5)</code>, ми використовуємо <code>+</code> на майбутніх повернених значеннях <code>(+10)</code> і <code>(+5)</code>, і результат також буде чимось, що буде продукувати значення тільки якщо викликано з параметром.</p></div>
<div class="paragraph"><p>Ми часто не використовуємо функції як аплікативи, але це все одно цікаво. Не дуже важливо зрозуміти, як працює екземпляр <code>(-&gt;) r</code> для <code>Applicative</code>, тому не впадайте у відчай, якщо ви зараз не отримуєте цього. Спробуйте пограти з аплікативним стилем і функціями, щоб створити інтуїцію щодо функціональних анлікативів.</p></div>
<div class="paragraph"><p>Екземпляр <code>Applicative</code>, з яким ми ще не стикалися, - це <code>ZipList</code>, і він живе в <code>Control.Applicative</code>.</p></div>
<div class="paragraph"><p>Виявляється, насправді існує більше способів, щоб списки були аплікативними функторами. Один із способів - це вже описаний нами, який говорить про те, що виклик <code>&lt;* &gt;</code> зі списком функцій та списком значень призводить до списку, який містить усі можливі комбінації застосування функцій з лівого списку до значень у правому списку . Якщо у нас <code>[(+3), (* 2)] &lt;* &gt; [1,2]</code>, <code>(+3)</code> буде застосовано як до <code>1</code> і до <code>2</code>, <code>(* 2)</code> також буде застосовано до <code>1</code> і до <code>2</code>, в результаті виходить список, який містить чотири елементи, а саме <code>[4,5,2,4]</code>.</p></div>
<div class="paragraph"><p>Однак <code>[(+3), (* 2)] &lt;*&gt; [1,2]</code> також може працювати таким чином, що перша функція в лівому списку буде застосована до першого значення в правому, друга функція застосовується до другого значення тощо. Це призвело б до списку з двома значеннями, а саме <code>[4,4]</code>. Ви можете розглядати це як <code>[1 + 3, 2 * 2]</code>.</p></div>
<div class="paragraph"><p>Оскільки один тип не може мати два екземпляри для одного класу, введено тип <code>ZipList</code>, який має один конструктор <code>ZipList</code>, який має лише одне поле, і це поле є списком. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="kt">ZipList</span> <span class="kr">where</span>
        <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">repeat</span> <span class="n">x</span><span class="p">)</span>
        <span class="kt">ZipList</span> <span class="n">fs</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">(</span><span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">fs</span> <span class="n">xs</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>&lt;*&gt;</code> робить саме те, що ми сказали. Він застосовує першу функцію до першого значення, другу функцію до другого значення тощо. Це робиться за допомогою zipWith <code>(\ f x -&gt; f x) fs xs</code>. Через те, як працює <code>zipWith</code>, отриманий список буде в довжину як коротший з двох списків.</p></div>
<div class="paragraph"><p>Тут також цікавий <code>pure</code>. Він приймає значення і вносить його до списку, який просто повторює це значення без кінця. <code>pure "haha"</code> призводить до <code>ZipList (["haha", "haha", "haha"</code> &#8230;. Це може дещо спантеличити, оскільки ми говорили, що <code>pure</code> повинен ставити значення в мінімальний контекст, який все ще дає це значення. І ви можете думати, що нескінченний перелік чогось навряд чи мінімальний, але це має сенс у zip-списках, оскільки він повинен створювати значення для кожної позиції. Це також задовольняє закону, що <code>pure f &lt;* &gt; xs</code> повинен дорівнювати <code>fmap f xs</code> Якщо <code>pure 3</code> щойно повернув <code>ZipList [3]</code>, <code>pure (* 2) &lt;*&gt; ZipList [1,5,10]</code> призведе до отримання <code>ZipList [2]</code>, тому що результуючий список двох спарованих списків має довжину меншого з двох. Якщо ми поєднаємо скінчений список з нескінченним списком, довжина результуючого списку завжди буде дорівнює довжині скінченого списку.</p></div>
<div class="paragraph"><p>Отже, як zip списки працюють арлікативному стилі? Подивимось. Ага, тип <code>ZipList</code> не має екземпляра <code>Show</code>, тому нам потрібно використовувати функцію <code>getZipList</code> для вилучення сирого списку зі списку zip.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="p">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="o">..</span><span class="p">]</span>
<span class="p">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="n">max</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(,,)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="s">&quot;dog&quot;</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="s">&quot;cat&quot;</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="s">&quot;rat&quot;</span>
<span class="p">[(</span><span class="sc">&#39;d&#39;</span><span class="p">,</span><span class="sc">&#39;c&#39;</span><span class="p">,</span><span class="sc">&#39;r&#39;</span><span class="p">),(</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="sc">&#39;g&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>(,,)</code> така сама, як <code>\x y z -&gt; (x, y, z)</code>. Також функція <code>(,)</code> така сама, як <code>\x y -&gt; (x, y)</code>.</p></div>
<div class="paragraph"><p>Окрім <code>zipWith</code>, стандартна бібліотека має такі функції, як <code>zipWith3</code>, <code>zipWith4</code>, аж до 7. <code>zipWith</code> приймає функцію, яка приймає два параметри та поєднує два списки в свій спосіб. <code>zipWith3</code> приймає функцію, яка приймає три параметри і пов'язує три списки тощо. Використовуючи zip списки в аплікативному стилі, нам не потрібно мати окрему функцію zip для кожного числа списків, які ми хочемо зібрати разом. Ми просто використовуємо аплікативний стиль, щоб зібрати довільну кількість списків функцією, і це дуже круто.</p></div>
<div class="paragraph"><p><code>Control.Applicative</code> визначає функцію з назвою <code>liftA2</code>, яка має тип <code>liftA2 ::(Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</code>. Це визначено так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">liftA2</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">c</span>
<span class="nf">liftA2</span> <span class="n">f</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">a</span> <span class="o">&lt;*&gt;</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Нічого особливого, вона просто застосовує функцію між двома аплікативами, приховуючи знайомий нам аплікативний стиль. Причина, з якої ми її розглядаємо, полягає в тому, що це чітко демонструє, чому аплікативні функтори є потужнішими, ніж просто звичайні. За допомогою звичайних функторів ми можемо просто відображати функції над одним функтором. Але за допомогою аплікативних функторів ми можемо застосувати функцію між кількома функторами. Також цікаво подивитися на тип цієї функції як <code>(a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</code>. Якщо ми подивимось на це таким чином, то можна сказати, що <code>liftA2</code> приймає нормальну двомісну функцію і перетворює її на функцію, яка працює на двох функторах.</p></div>
<div class="paragraph"><p>Ось цікава концепція: ми можемо взяти два аплікативних функтора і об'єднати їх в один аплікативний функтор, який має в ньому результати цих двох функторів у списку. Наприклад, у нас є <code>Just 3</code> і <code>Just 4</code>. Припустимо, що другий має в своєму розпорядженні список синглтон, тому що цього дуже легко досягти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Добре, тож скажімо, у нас <code>Just 3</code> і <code>Just [4]</code>. Як ми отримуємо <code>Just [3,4]</code>? Легко.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="p">[</span><span class="mi">4</span><span class="p">])</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="o">&lt;*&gt;</span> <span class="kt">Just</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам'ятайте, <code>:</code> це функція, яка бере елемент і список і повертає новий список з цим елементом на початку. Тепер, коли у нас є <code>Just [3,4]</code>, чи могли б ми поєднати це з <code>Just 2</code> для отримання <code>Just [2,3,4]</code>? Звичайно, ми могли. Здається, що ми можемо поєднати будь-яку кількість аплікативів в один, який містить в собі список результатів цих аплікативів. Спробуємо реалізувати функцію, яка бере список аплікативів і повертає аплікатив, який має список як значення результату. Ми будемо називати її <code>sequenceA</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sequenceA</span> <span class="ow">::</span><span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sequenceA</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="n">pure</span> <span class="kt">[]</span>
<span class="nf">sequenceA</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">:</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">x</span> <span class="o">&lt;*&gt;</span> <span class="n">sequenceA</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Так, рекурсія! Спочатку подивимось на тип. Це перетворить список аплікативів в аплікатив зі списком. Виходячи з цього, ми можемо закласти деякі основи для крайових умов. Якщо ми хочемо перетворити порожній список у апликатив із переліком результатів, ми просто поставимо порожній список у контекст за замовчуванням. Зараз настає рекурсія. Якщо у нас є список з головою і хвостом (пам’ятайте, <code>x</code> - аплікатив, а <code>xs</code> - список з них), ми викликаємо <code>sequenceA</code> на хвості, в результаті матимемо аплікатив із списком. Тоді ми просто додаємо значення всередині аплікатива <code>x</code> до цього аплікатива зі списком, і це все!</p></div>
<div class="paragraph"><p>Отже, якщо ми робимо <code>sequenceA [Just 1, Just 2]</code>, це <code>(:) &lt;$&gt; Just 1 &lt;* &gt;  sequenceA [Just 2]</code>. Це дорівнює <code>(:) &lt;$&gt; Just 1 &lt;* &gt; ((:) &lt;$&gt; Just 2 &lt;* &gt; sequenceA [])</code>. А! Ми знаємо, що <code>sequenceA []</code> закінчується як <code>Just []</code>, тому цей вираз зараз <code>(:) &lt;$&gt; Just 1 &lt;* &gt; ((:) &lt;$&gt; Just 2 &lt;* &gt; Just [])</code>, що є <code>((:) &lt;$&gt; Just 1 &lt;*&gt; Just [2]</code>, що <code>Just [1,2]</code>!</p></div>
<div class="paragraph"><p>Інший спосіб реалізації <code>sequenceA</code> - це <code>fold</code>. Пам'ятайте, що майже будь-яка функція, де ми переходимо елементами списку і накопичуємо по дорозі результат, може бути реалізована через <code>fold</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sequenceA</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Applicative</span> <span class="n">f</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">f</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">sequenceA</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="n">liftA2</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="p">(</span><span class="n">pure</span> <span class="kt">[]</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми підходимо до списку праворуч і починаємо з акумуляторного значення <code>pure []</code>. Ми робимо <code>liftA2 (:)</code> між акумулятором і останнім елементом списку, що призводить до аплікатива з синглтоном всередині. Потім робимо <code>liftA2 (:)</code> з останнім елементом і поточним акумулятором тощо), поки ми не залишимося лише з акумулятором, який містить список результатів усіх аплікативів.</p></div>
<div class="paragraph"><p>Дамо нашим функціям крутитись на деяких аплікативів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">1</span><span class="p">]</span>
<span class="kt">Just</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">1</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[(</span><span class="o">+</span><span class="mi">3</span><span class="p">),(</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="mi">3</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="kt">[]</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ах! Дуже гарно. При використанні значень <code>Maybe</code>, <code>sequenceA</code> створює значення <code>Maybe</code> з усіма результатами всередині нього як список. Якщо одним із значень було <code>Nothing</code>, то результат також є <code>Nothing</code>. Це здорово, коли у вас є список значень <code>Maybe</code>, і ви цікавитесь значеннями, якщо жодне з них не є <code>Nothing</code>.</p></div>
<div class="paragraph"><p>При використанні з функціями <code>sequenceA</code> приймає список функцій і повертає функцію, яка повертає список. У нашому прикладі ми створили функцію, яка приймає число як параметр і застосувала його до кожної функції у списку, а потім повернула список результатів. <code>sequenceA [(+3), (+ 2), (+ 1)] 3</code> викличе <code>(+3)</code> з <code>3</code>, <code>(+2)</code> з <code>3</code> і <code>(+1)</code> з <code>3</code> і представить усі ці результати у списку.</p></div>
<div class="paragraph"><p>Виконання <code>(+) &lt;$&gt; (+3) &lt;*&gt; (* 2)</code> створить функцію, яка приймає параметр, подає його в обидва <code>(+3)</code> і <code>(* 2)</code>, а потім викликає <code>+</code> з цими двома результатами. У цьому ж дусі є сенс, що <code>sequenceA [(+3), (* 2)]</code> створює функцію, яка приймає параметр і подає його на всі функції у списку. Замість виклику <code>+</code> з результатами функцій використовується комбінація <code>:</code> і <code>pure []</code> для збору цих результатів у список, який є результатом цієї функції.</p></div>
<div class="paragraph"><p>Використання <code>sequenceA</code> це здорово, коли у нас є список функцій, і ми хочемо подати один і той же вхід для всіх, а потім переглянути список результатів. Наприклад, у нас є число, і нам цікаво, чи задовольняє воно всім предикатам в списку. Один із способів зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="mi">7</span><span class="p">)</span> <span class="p">[(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">),(</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">),</span><span class="n">odd</span><span class="p">]</span>
<span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="kt">True</span><span class="p">,</span><span class="kt">True</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">f</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="mi">7</span><span class="p">)</span> <span class="p">[(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">),(</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">),</span><span class="n">odd</span><span class="p">]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам'ятайте, <code>and</code> бере список логічних і повертає <code>True</code>, якщо вони всі <code>True</code>. Ще один спосіб досягти того ж, що було б із <code>sequenceA</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">),(</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">),</span><span class="n">odd</span><span class="p">]</span> <span class="mi">7</span>
<span class="p">[</span><span class="kt">True</span><span class="p">,</span><span class="kt">True</span><span class="p">,</span><span class="kt">True</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">sequenceA</span> <span class="p">[(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">),(</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">),</span><span class="n">odd</span><span class="p">]</span> <span class="mi">7</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>sequenceA [(&gt; 4), (&lt;10), odd]</code> створює функцію, яка буде приймати число і подавати його всім предикатам у <code>[(&gt; 4), (&lt;10), odd]</code> і повертає список логічних значень. Це перетворює список із типом <code>(Num a) =&gt; [a -&gt; Bool]</code> у функцію з типом <code>(Num a) =&gt; a -&gt; [Bool]</code>. Досить акуратно, так?</p></div>
<div class="paragraph"><p>Оскільки списки є однорідними, звичайно, всі функції у списку повинні бути функціями одного типу. У вас не може бути списку типу <code>[ord, (+3)]</code>, оскільки <code>ord</code> приймає символ і повертає число, тоді як <code>(+3)</code> бере число і повертає число.</p></div>
<div class="paragraph"><p>Якщо використовується з <code>[]</code>, <code>sequenceA</code> приймає список списків і повертає список списків. Хм, це цікаво. Він фактично створює списки, у яких є всі можливі комбінації їх елементів. Для ілюстрації, ось описане вище, зроблене за допомогою <code>sequenceA</code>, а потім зроблене із осяжністю списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">z</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це може бути трохи важко зрозуміти, але якщо ви пограєте з ним деякий час, ви побачите, як це працює. Скажімо, ми робимо <code>sequenceA [[1,2], [3,4]]</code>. Щоб побачити, як це відбувається, давайте скористаємося визначенням <code>sequenceA (x: xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</code> та граничною умовою <code>sequenceA [] = pure []</code>. Вам не доведеться слідувати цьому обчисленню, але це може допомогти вам, якщо у вас виникнуть проблеми уявити, як <code>sequenceA</code> працює на списках списків.</p></div>
<div class="ulist"><ul>
<li>
<p>
Почнемо з <code>sequenceA [[1,2], [3,4]]</code>
</p>
</li>
<li>
<p>
Це обчислюється до <code>(:) &lt;$&gt; [1,2] &lt;*&gt; sequenceA [[3,4]]</code>
</p>
</li>
<li>
<p>
Далі оцінюючи внутрішню <code>sequenceA</code>, отримуємо <code>(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; sequenceA [])</code>
</p>
</li>
<li>
<p>
Ми досягли граничної умови, тому це зараз <code>(:) &lt;$&gt; [1,2] &lt;* &gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; [[]])</code>
Now, we evaluate the (:) &lt;$&gt; [3,4] &lt;*&gt; [[]] part, which will use : with every possible value in the left list (possible values are 3 and 4) with every possible value on the right list (only possible value is []), which results in [3:[], 4:[]], which is <a id="3]"></a>. So now we have (:) &lt;$&gt; [1,2] &lt;*&gt; <a id="3]"></a>
</p>
</li>
<li>
<p>
Тепер ми оцінюємо частину <code>(:) &lt;$&gt; [3,4] &lt;* &gt; [[]]</code>, яка використовуватиме <code>:</code> з кожним можливим значенням у лівому списку (можливі значення <code>3</code> та <code>4</code>) з кожним можливим значенням на правий список (можливе лише значення <code>[]</code>), в результаті якого виходять <code>[3: [], 4: []]</code>, що є <code>[[3], [4]]</code>. Отже, тепер у нас є <code>(:) &lt;$&gt; [1,2] &lt;*&gt; [[3], [4]]</code>
Now, : is used with every possible value from the left list (1 and 2) with every possible value in the right list ([3] and [4]), which results in [1:[3], 1:[4], 2:[3], 2:[4]], which is [[1,3],[1,4],[2,3],[2,4]
Тепер <code>:</code> використовується з усіма можливими значеннями з лівого списку (<code>1</code> і <code>2</code>) з кожним можливим значенням у правому списку (<code>[3]</code> та <code>[4]</code>), що призводить до <code>[1: [3], 1: [4 ], 2: [3], 2: [4]]</code>, що є <code>[[1,3], [1,4], [2,3], [2,4]</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Виконання <code>(+) &lt;$&gt; [1,2] &lt;*&gt; [4,5,6]</code> призводить до недетермінованого обчислення <code>x + y</code>, де <code>x</code> приймає кожне значення від <code>[1,2]</code>, а y приймає кожне значення від <code>[4,5,6]</code>. Ми представляємо це як список, який містить усі можливі результати. Аналогічно, коли ми робимо послідовності <code>[[1,2], [3,4], [5,6], [7,8]]</code>, результат - недетерміновані обчислення <code>[x, y, z, w]</code>, де <code>x</code> приймає кожне значення від <code>[1,2]</code>, <code>y</code> приймає кожне значення від <code>[3,4]</code> тощо. Щоб представити результат цього недетермінованого обчислення, ми використовуємо список, де кожен елемент у списку - один можливий список. Ось чому результат - це список списків.</p></div>
<div class="paragraph"><p>Якщо використовується з I/O діями, <code>sequenceA</code> - це те саме, що і послідовність! Він приймає список дій вводу-виводу та повертає дію вводу-виводу, яка буде виконувати кожну з цих дій і матиме як результат перелік результатів цих дій вводу-виводу. Це тому, що щоб перетворити значення <code>[IO a]</code> у значення <code>IO [a]</code>, щоб зробити дію вводу/виводу, яка дає список результатів, коли вони виконуються, всі ці дії вводу/виводу повинні бути послідовними, щоб вони потім були виконується одна за одною, коли оцінювання вимушене. Ви не можете отримати результат дії вводу-виводу, не виконавши його.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sequenceA</span> <span class="p">[</span><span class="n">getLine</span><span class="p">,</span> <span class="n">getLine</span><span class="p">,</span> <span class="n">getLine</span><span class="p">]</span>
<span class="nf">heyh</span>
<span class="nf">ho</span>
<span class="nf">woo</span>
<span class="p">[</span><span class="s">&quot;heyh&quot;</span><span class="p">,</span><span class="s">&quot;ho&quot;</span><span class="p">,</span><span class="s">&quot;woo&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і звичайні функтори, аплікативні фуктори мають кілька законів. Найважливішим є той, про який ми вже згадували, а саме - має дотримуватись <code>pure f &lt;*&gt; x = fmap f x</code>. В якості вправи ви можете довести цей закон для деяких аплікативних функторів, з якими ми зустрілися в цій главі. Іншими законами функторів є:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">pure</span> <span class="n">id</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">v</span>
<span class="nf">pure</span> <span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span> <span class="ow">=</span> <span class="n">u</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="n">v</span> <span class="o">&lt;*&gt;</span> <span class="n">w</span><span class="p">)</span>
<span class="nf">pure</span> <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
<span class="nf">u</span> <span class="o">&lt;*&gt;</span> <span class="n">pure</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">pure</span> <span class="p">(</span><span class="o">$</span> <span class="n">y</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">u</span>
</pre></div></div></div>
<div class="paragraph"><p>Зараз ми не будемо детально їх обговорювати, тому що це займе багато сторінок, і, мабуть, це буде дуже нудно. Але якщо ви вирішите подолати це завдання, ви можете більш детально розглянути їх і подивитися, чи вони дотримуються для деяких примірників.</p></div>
<div class="paragraph"><p>На закінчення, аплікативні функтори не просто цікаві, вони також корисні, оскільки вони дозволяють поєднувати різні обчислення, такі як обчислення вводу/виводу, недетерміновані обчислення, обчислення, які могли бути невдалими тощо, використовуючи аплікативний стиль. Тільки за допомогою <code>&lt;$&gt;</code> і <code>&lt;*&gt;</code> ми можемо використовувати звичайні функції для одноманітного оперування на будь-якій кількості аплікативних функторів і використовувати переваги семантики кожного з них.</p></div>
</div>
<div class="sect2">
<h3 id="___newtype">Ключове слово newtype</h3>
<div class="paragraph"><p><span class="image">
<img src="images/maoi.png" alt="images/maoi.png" />
</span>
Поки ми дізналися, як зробити власні алгебраїчні типи даних за допомогою ключового слова <code>data</code>. Ми також дізналися, як давати існуючим типам синоніми за допомогою ключового слова <code>type</code>. У цьому розділі ми розглянемо, як зробити нові типи з існуючих типів даних за допомогою ключового слова <code>newtype</code> і чому ми хотіли б це зробити в першу чергу.</p></div>
<div class="paragraph"><p>У попередньому розділі ми бачили, що існує фактично більше способів для типу списку бути аплікативним функтором. Один із способів - це за допомогою <code>&lt;*&gt;</code> вийняти кожну функцію зі списку, що є її лівим параметром, і застосувати її до кожного значення у списку, який знаходиться праворуч, в результаті чого можливе поєднання застосування функції з лівого списку до значення в правому списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="o">*</span><span class="mi">100</span><span class="p">),(</span><span class="o">*</span><span class="mi">5</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">300</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Другий спосіб - взяти першу функцію з лівого боку <code>&lt;*&gt;</code> та застосувати її до першого значення праворуч, потім взяти другу функцію зі списку зліва та застосувати її до другого значення праворуч , і так далі. Зрештою, це схоже на зшивання двох списків разом. Але списки вже є екземпляром <code>Applicative</code>, тож як ми також зробили списки екземпляром <code>Applicative</code> цим другим способом? Якщо ви пам’ятаєте, ми говорили, що з цієї причини був введений тип <code>ZipList</code>, який має один конструктор значень, <code>ZipList</code>, який має лише одне поле. Ми поміщаємо список, який ми огортаємо в це поле. Потім, <code>ZipList</code> був зроблений екземпляр <code>Applicative</code>, так що коли ми хочемо використовувати списки як аплікативи в zip стилі, ми просто огортаємо їх конструктором <code>ZipList</code>, а потім, як тільки ми закінчимо, розгортаємо їх за допомогою <code>getZipList</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="kt">ZipList</span> <span class="p">[(</span><span class="o">+</span><span class="mi">1</span><span class="p">),(</span><span class="o">*</span><span class="mi">100</span><span class="p">),(</span><span class="o">*</span><span class="mi">5</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">200</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Отже, як це стосується цього ключового слова <code>newtype</code>? Гаразд, подумайте, як ми могли б написати декларацію даних для нашого типу <code>ZipList</code>. Один із способів - це зробити так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип, у якого є лише один конструктор значень, і у цього конструктора значень є лише одне поле, яке є переліком речей. Ми також можемо використовувати синтаксис запису, щоб ми автоматично отримували функцію, яка витягує список із <code>ZipList</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це виглядає чудово і насправді спрацює досить добре. У нас було два способи зробити існуючий тип екземпляром типокласу, тому ми використовували ключове слово <code>data</code>, щоб просто перетворити цей тип в інший тип, а другий тип - екземпляр другим способом.</p></div>
<div class="paragraph"><p>Ключове слово <code>newtype</code> в Haskell створено саме для цих випадків, коли ми хочемо просто взяти один тип і обгорнути його в щось, щоб представити його як інший тип. У справжніх бібліотеках <code>ZipList a</code> визначається так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість ключового слова <code>data</code> використовується ключове слово <code>newtype</code>. Чому це? Одна з причин, <code>newtype</code> швидше. Якщо ви використовуєте ключове слово <code>data</code> для огорнення типу, коли програма працює є деякі накладні витрати на все, що обгортає та розгортає. Але якщо ви використовуєте <code>newtype</code>, Haskell знає, що ви просто використовуєте його, щоб перетворити наявний тип у новий тип (звідси і назва), оскільки ви хочете, щоб він був таким же всередині, але мав інший тип. Зважаючи на це, Haskell може позбутися обгортання та розгортання, як тільки вирішить, який тип має значення.</p></div>
<div class="paragraph"><p>То чому б тоді просто не використовувати <code>newtype</code> весь час замість <code>data</code>? Добре, коли ви створюєте новий тип із наявного типу за допомогою ключового слова <code>newtype</code>, у вас може бути лише один конструктор значень, і цей конструктор значень може мати лише одне поле. Але за допомогою даних можна створювати типи даних, які мають кілька конструкторів значень, і кожен конструктор може мати нуль або більше полів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Profession</span> <span class="ow">=</span> <span class="kt">Fighter</span> <span class="o">|</span> <span class="kt">Archer</span> <span class="o">|</span> <span class="kt">Accountant</span>

<span class="kr">data</span> <span class="kt">Race</span> <span class="ow">=</span> <span class="kt">Human</span> <span class="o">|</span> <span class="kt">Elf</span> <span class="o">|</span> <span class="kt">Orc</span> <span class="o">|</span> <span class="kt">Goblin</span>

<span class="kr">data</span> <span class="kt">PlayerCharacter</span> <span class="ow">=</span> <span class="kt">PlayerCharacter</span> <span class="kt">Race</span> <span class="kt">Profession</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи <code>newtype</code>, ви обмежуєтесь лише одним конструктором з одним полем.</p></div>
<div class="paragraph"><p>Ми також можемо використовувати ключове слово <code>deriving</code> з <code>newtype</code> так само, як і з <code>data</code>. Ми можемо отримати екземпляри для <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code> і <code>Read</code>. Якщо ми отримуємо екземпляр для типокласу, для початку тип, який ми обертаємо, повинен бути у цьому типокласі. Це має сенс, оскільки новий тип просто обгортає існуючий тип. Отже, якщо ми зробимо наступне, ми можемо друкувати та порівнювати значення нового типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CharList</span> <span class="ow">=</span> <span class="kt">CharList</span> <span class="p">{</span> <span class="n">getCharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте спробуємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CharList</span> <span class="s">&quot;this will be shown!&quot;</span>
<span class="kt">CharList</span> <span class="p">{</span><span class="n">getCharList</span> <span class="ow">=</span> <span class="s">&quot;this will be shown!&quot;</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CharList</span> <span class="s">&quot;benny&quot;</span> <span class="o">==</span> <span class="kt">CharList</span> <span class="s">&quot;benny&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">CharList</span> <span class="s">&quot;benny&quot;</span> <span class="o">==</span> <span class="kt">CharList</span> <span class="s">&quot;oisters&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому конкретному <code>newtype</code> конструктор значення має такий тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">CharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">CharList</span>
</pre></div></div></div>
<div class="paragraph"><p>Він приймає значення <code>[Char]</code>, наприклад <code>"my sharona"</code> і повертає значення <code>CharList</code>. З наведених вище прикладів, де ми використовували конструктор значень <code>CharList</code>, ми бачимо, що це дійсно так. І навпаки, функція <code>getCharList</code>, яка була створена для нас, оскільки ми використовували синтаксис запису в нашому <code>newtype</code>, має такий тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">getCharList</span> <span class="ow">::</span> <span class="kt">CharList</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Він приймає значення <code>CharList</code> і перетворює його у значення <code>[Char]</code>. Ви можете вважати це обгортанням і розгортанням, але ви можете також вважати це перетворенням значень одного типу в інший.</p></div>
<div class="sect3">
<h4 id="__newtype____">Використання newtype для створення екземплярів типокласа</h4>
<div class="paragraph"><p>Many times, we want to make our types instances of certain type classes, but the type parameters just don&#8217;t match up for what we want to do. It&#8217;s easy to make Maybe an instance of Functor, because the Functor type class is defined like this:
Часто ми хочемо зробити наші типи екземплярами певних типокласів, але параметри типу просто не відповідають тому, що ми хочемо зробити. Легко зробити <code>Maybe</code> екземпляром <code>Functor</code>, тому що клас типу <code>Functor</code> визначений так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що ми починаємо прямо з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
</pre></div></div></div>
<div class="paragraph"><p>And then implement fmap. All the type parameters add up because the Maybe takes the place of f in the definition of the Functor type class and so if we look at fmap like it only worked on Maybe, it ends up behaving like:
Та потім реалізуйте <code>fmap</code>. Всі параметри типу згортуваються, тому що <code>Maybe</code> займає місце <code>f</code> у визначенні типокласу <code>Functor</code>, і тому, якщо ми подивимось на <code>fmap</code>, якби він працював лише на <code>Maybe</code>, кінець кінцем він би працював так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/krakatoa.png" alt="images/krakatoa.png" />
</span>
Хіба це не просто персик? А що робити, якщо ми захотіли би зробити кортеж екземпляром <code>Functor</code> таким чином, що коли ми <code>fmap</code> функції над кортежем, вона б застосовувалась до першого компонента кортежу? Таким чином, виконання <code>fmap (+3) (1,1)</code> призведе до <code>(4,1)</code>. Виглядає так, що написати екземпляр для цього начебто важко. З <code>Maybe</code>, ми просто говоримо <code>instance Functor Maybe</code>, тому що лише конструктори типу, які беруть точно один параметр, можуть бути зроблені екземпляром <code>Functor</code>. Але здається, що немає ніякого способу зробити щось подібне з <code>(a, b)</code>, щоб параметр типу <code>a</code> кінець кінцем був тим, який змінюється, коли ми використовуємо <code>fmap</code>. Щоб обійти це, ми можемо <code>newtype</code> наш кортеж таким чином, що другий параметр типу представляв тип першого компонента в кортежі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Pair</span> <span class="n">b</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="p">{</span> <span class="n">getPair</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>А тепер ми можемо зробити його екземпляром <code>Functor</code>, щоб функція була відображена на перший компонент:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Pair</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">))</span> <span class="ow">=</span> <span class="kt">Pair</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як бачимо, ми можемо робити співпадіння на типах, визначених <code>newtype</code>. Ми порівнюємо шаблон, щоб підлеглий кортеж, потім застосовуємо функцію <code>f</code> до першого компонента кортежу, а потім використовуємо конструктор значень <code>Pair</code> для перетворення кортежу назад у нашу <code>Pair b a</code>. Якщо ми уявимо, яким би був тип <code>fmap</code>, якби він працював лише на наших нових парах, це було б:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Pair</span> <span class="n">c</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Знову ж таки, ми сказали <code>instance Functor (Pair c) where</code>,і так <code>Pair c</code> зайняв місце <code>f</code> у визначенні типокласу для <code>Functor</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Отже, якщо ми перетворимо кортеж у <code>Pair b a</code>, ми можемо використовувати <code>fmap</code> над ним, і функція буде відображена на перший компонент:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getPair</span> <span class="o">$</span> <span class="p">`</span><span class="n">fmap</span><span class="p">`</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">200</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getPair</span> <span class="o">$</span> <span class="n">fmap</span> <span class="n">reverse</span> <span class="p">(</span><span class="kt">Pair</span> <span class="p">(</span><span class="s">&quot;london calling&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="s">&quot;gnillac nodnol&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="___newtype_2">Про лінивісь newtype</h4>
<div class="paragraph"><p>Ми згадували, що <code>newtype</code> зазвичай швидший, ніж <code>data</code>. Єдине, що можна зробити з <code>newtype</code> - це перетворити існуючий тип у новий тип, тому внутрішньо Haskell може представляти значення типів, визначених <code>newtype</code> так само, як оригінали, лише слід пам’ятати, що їх типи є тепер різні. Цей факт означає, що не тільки новий тип швидше, але і лазулінивіше. Давайте розберемося, що це означає.</p></div>
<div class="paragraph"><p>Як ми вже говорили раніше, Haskell за замовчуванням лінивий. Це означає, що будь-які обчислення відбуватимуться лише тоді, коли ми намагатимемося надрукувати результати наших функцій. Крім того, будуть проведені лише ті обчислення, необхідні для того, щоб наша функція повідомила нам результат. Невизначене значення <code>undefined</code> в Haskell представляє помилкові обчислення. Якщо ми спробуємо оцінити його (тобто змусити Haskell насправді обчислити його), надрукувавши його до терміналу, Haskell видасть істерику (технічно називається винятком):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">undefined</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">undefined</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак, якщо ми складемо список, у якому є деякі невизначені значення, але запитаємо лише голову списку, що є визначеною, все пройде гладко, оскільки Haskell насправді не потребує оцінювання будь-яких інших елементів у списку, якщо ми лише хочемо подивитися на перший елемент:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="n">undefined</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">undefined</span><span class="p">]</span>
<span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер розглянемо такий тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">CoolBool</span> <span class="ow">=</span> <span class="kt">CoolBool</span> <span class="p">{</span> <span class="n">getCoolBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>It&#8217;s your run-of-the-mill algebraic data type that was defined with the data keyword. It has one value constructor, which has one field whose type is Bool. Let&#8217;s make a function that pattern matches on a CoolBool and returns the value "hello" regardless of whether the Bool inside the CoolBool was True or False:
Це ваш алгебраїчний тип даних,визначений за допомогою ключового слова <code>data</code>. Він має один конструктор значення, який має одне поле, тип якого - <code>Bool</code>. Давайте зробимо функцію, яка відповідає шаблону на <code>CoolBool</code> і повертає значення <code>"hello"</code> незалежно від того, був <code>Bool</code> всередині CoolBool <code>True</code> чи <code>False</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">helloMe</span> <span class="ow">::</span> <span class="kt">CoolBool</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">helloMe</span> <span class="p">(</span><span class="kt">CoolBool</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;hello&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Instead of applying this function to a normal CoolBool, let&#8217;s throw it a curveball and apply it to undefined!
Замість того, щоб застосовувати цю функцію до звичайного <code>CoolBool</code>, давайте кинемо їй кручений і застосуємо її до <code>undefined</code>!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">helloMe</span> <span class="n">undefined</span>
<span class="s">&quot;*** Exception: Prelude.undefined</span>
</pre></div></div></div>
<div class="paragraph"><p>Йо! Виняток! Тепер чому стався такий виняток? Типи, визначені за допомогою ключового слова <code>data</code>, можуть мати конструктори декількох значень (навіть якщо у <code>CoolBool</code> є лише один). Тож для того, щоб переконатися, що значення, яке надається нашій функції, відповідає шаблону <code>(CoolBool _)</code>, Haskell повинен оцінити значення достатньо, щоб побачити, який конструктор значень використовувався, коли ми робили це значення. І коли ми намагаємось оцінити невизначене значення, навіть трохи, закидається виняток.</p></div>
<div class="paragraph"><p>Замість використання ключового слова <code>data</code> для <code>CoolBool</code>, давайте спробуємо використати <code>newtype</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CoolBool</span> <span class="ow">=</span> <span class="kt">CoolBool</span> <span class="p">{</span> <span class="n">getCoolBool</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам не потрібно змінювати нашу функцію <code>helloMe</code>, оскільки синтаксис узгодження шаблонів однаковий, якщо ви використовуєте <code>newtype</code> або <code>data</code> для визначення свого типу. Зробимо тут те ж саме і застосуємо <code>helloMe</code> до невизначеного значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">helloMe</span> <span class="n">undefined</span>
<span class="s">&quot;hello&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/shamrock.png" alt="images/shamrock.png" />
</span>
Це спрацювало! Хммм, чому це? Ну, як ми вже говорили, коли ми використовуємо <code>newtype</code>, Haskell може внутрішньо представляти значення нового типу так само, як і оригінальні значення. Він не повинен додавати ще одне поле навколо них, він просто повинен знати про значення різних типів. Оскільки Haskell знає, що типи, створені за допомогою ключового слова <code>newtype</code>, можуть мати лише один конструктор, йому не потрібно оцінювати значення, передане функції, щоб переконатися, що воно відповідає шаблону <code>(CoolBool _)</code>, оскільки типи <code>newtype</code> можуть мати лише один можливий конструктор значень і одне поле!</p></div>
<div class="paragraph"><p>Ця різниця в поведінці може здатися тривіальною, але насправді є досить важливою, оскільки допомагає нам усвідомити, що хоча типи, визначені <code>data</code> та <code>newtype</code>, поводяться аналогічно з точки зору програміста, оскільки вони обоє мають конструктори значень та поля, вони насправді є двома різними механізмами . Якщо <code>data</code> можуть бути використані для створення власних типів з нуля, <code>newtype</code> призначений для створення абсолютно нового типу з існуючого типу. Співставлення шаблонів для значень <code>newtype</code> не схоже на те, щоб вийняти щось із коробки (як це є з <code>data</code>), це більше про пряме перетворення з одного типу в інший.</p></div>
</div>
<div class="sect3">
<h4 id="_type_vs_newtype_vs_data">type vs. newtype vs. data</h4>
<div class="paragraph"><p>На даний момент ви можете трохи заплутатися в тому, в чому полягає різниця між <code>типом</code>, <code>data</code> та <code>newtype</code>, тож давайте трохи освіжимо нашу пам’ять.</p></div>
<div class="paragraph"><p>Ключове слово <code>type</code> призначене для створення синонімів типу. Це означає, що ми просто даємо інше ім’я вже існуючому типу, щоб на його було легше посилатися. Скажімо, ми зробили наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntList</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що це робить, що ми можемо називати тип <code>[Int]</code> як <code>IntList</code>. Їх можна використовувати взаємозамінно. Ми не отримуємо конструктор значень <code>IntList</code> або щось подібне. Оскільки <code>[Int]</code> та <code>IntList</code> - це лише два способи посилання на один і той же тип, не має значення, яке ім'я ми використовуємо в анотаціях типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">IntList</span><span class="p">)</span> <span class="o">++</span> <span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми використовуємо синоніми типів, коли хочемо зробити сигнатури типів більш описовими, надаючи імена типів, які розповідають щось про їх призначення в контексті функцій, де вони використовуються. Наприклад, коли ми використовували список асоціацій типу <code>[(String, String)]</code> для представлення телефонної книги, ми дали йому синонім типу <code>PhoneBook</code>, щоб сигнатури типів наших функцій було легше читати.</p></div>
<div class="paragraph"><p>Ключове слово <code>newtype</code> призначене для прийняття існуючих типів та загортання їх у нові типи, здебільшого, щоб було простіше зробити їх примірниками певних типокласів. Коли ми використовуємо <code>newtype</code>, щоб обернути існуючий тип, тип, який ми отримуємо, є окремим від початкового типу. Якщо ми зробимо наступний новий тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">CharList</span> <span class="ow">=</span> <span class="kt">CharList</span> <span class="p">{</span> <span class="n">getCharList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо використовувати <code>++</code> для згортування <code>CharList</code> та списку типу <code>[Char]</code>. Ми навіть не можемо використовувати <code>++</code> для згортування двох <code>CharList</code>, оскільки <code>++</code> працює лише у списках, а тип <code>CharList</code> - це не список, хоча можна сказати, що він містить список. Однак ми можемо конвертувати два <code>CharLists</code> у списки, <code>++</code> їх, а потім перетворити їх назад у <code>CharList</code>.</p></div>
<div class="paragraph"><p>Коли ми використовуємо синтаксис запису в наших деклараціях <code>newtype</code>, ми отримуємо функції для перетворення між новим типом і оригінальним типом: а саме конструктор значень нашого нового типу та функцію вилучення значення в його полі. Новий тип також автоматично не робиться екземпляром типокласів, до яких належить оригінальний тип, тому нам потрібно вивести або записати їх вручну.</p></div>
<div class="paragraph"><p>На практиці ви можете вважати декларації <code>newtype</code> як декларації <code>data</code>, які можуть мати лише один конструктор і одне поле. Якщо ви зловили себе за написанням такої <code>data</code> декларації, подумайте про використання <code>newtype</code>.</p></div>
<div class="paragraph"><p>Ключове слово <code>data</code> призначене для створення власних типів даних, і тут ви можете дати собі волю. Вони можуть мати стільки конструкторів і полів, скільки бажаєте, і їх можна використовувати для самостійного впровадження будь-якого алгебраїчного типу даних. Все - від списків та типів, схожих на <code>Maybe</code>, до дерев.</p></div>
<div class="paragraph"><p>Якщо ви просто хочете, щоб сигнатури вашого типу виглядали більш чистими та описовими, ви, мабуть, хочете ввести синоніми <code>type</code>. Якщо ви хочете взяти існуючий тип і перетворити його в новий тип, щоб зробити його екземпляром типокласу, швидше за все, ви шукаєте <code>newtype</code>. І якщо ви хочете зробити щось абсолютно нове, хороші шанси, що ви шукаєте ключове слово <code>data</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_">Моноїди</h3>
<div class="paragraph"><p><span class="image">
<img src="images/pirateship.png" alt="images/pirateship.png" />
</span>
Типокласи в Haskell використовуються для представлення інтерфейсу для типів, які мають певну загальну поведінку. Ми розпочали з простих класів типів, таких як <code>Eq</code>, який призначений для типів, значення яких можна прирівняти, і <code>Ord</code>, для речей, які можна впорядкувати, а потім перейти до більш цікавих, таких як <code>Functor</code> та <code>Applicative</code>.</p></div>
<div class="paragraph"><p>Коли ми робимо тип, ми думаємо про те, яку поведінку він підтримує, тобто, як він може діяти. А потім, виходячи з цього, ми вирішуємо, примірником яких типокласів  його зробити. Якщо має сенс рівняти значення нашого типу, ми робимо його екземпляром типокласу <code>Eq</code>. Якщо ми бачимо, що наш тип є якимось функтором, ми робимо його екземпляром <code>Functor</code> тощо.</p></div>
<div class="paragraph"><p>Тепер розглянемо наступне: <code>*</code> - це функція, яка приймає два числа і премножує їх. Якщо множимо якесь число на <code>1</code>, результат завжди дорівнює цьому числу. Не має значення, якщо ми робимо <code>1 * x</code> або <code>x * 1</code>, результат завжди <code>x</code>. Аналогічно, <code>++</code> також є функцією, яка приймає дві речі, а повертає третю. Тільки замість множення чисел він бере два списки і з'єднує їх. І так само, як <code>*</code>, він також має певне значення, яке не змінює іншого при використанні з <code>++</code>. Це значення - порожній список: <code>[]</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="mi">1</span>
<span class="mi">4</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">9</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">++</span> <span class="kt">[]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">[]</span> <span class="o">++</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Схоже, що обидва <code>*</code> разом з <code>1</code> і <code>++</code> разом із <code>[]</code> мають спільні властивості:</p></div>
<div class="ulist"><ul>
<li>
<p>
Функція приймає два параметри.
</p>
</li>
<li>
<p>
Параметри та значення результату мають один і той же тип.
</p>
</li>
<li>
<p>
Існує таке значення, яке не змінює інших значень при використанні з двомісною функцією.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Є ще одна річ, що ці дві операції мають назагал, що може бути не настільки очевидно, як наші попередні спостереження: коли у нас є три і більше значень, і ми хочемо використати двомісну функцію, щоб звести їх до єдиного результату, порядок, в якому ми застосовуємо функцію не має значення. Не має значення, чи робимо ми <code>(3 * 4) * 5</code> або <code>3 * (4 * 5)</code>. У будь-якому випадку результат - <code>60</code>. Те саме стосується <code>++</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">240</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="mi">5</span><span class="p">))</span>
<span class="mi">240</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;la&quot;</span> <span class="o">++</span> <span class="p">(</span><span class="s">&quot;di&quot;</span> <span class="o">++</span> <span class="s">&quot;da&quot;</span><span class="p">)</span>
<span class="s">&quot;ladida&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">&quot;la&quot;</span> <span class="o">++</span> <span class="s">&quot;di&quot;</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;da&quot;</span>
<span class="s">&quot;ladida&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми називаємо цю властивість <em>асоціативністю</em>. <code>*</code> є асоціативним, так само є <code>++</code>, але <code>-</code> наприклад, не є. Вирази <code>(5 - 3) - 4</code> і <code>5 - (3 - 4)</code> призводять до різних результатів.</p></div>
<div class="paragraph"><p>By noticing and writing down these properties, we have chanced upon monoids! A monoid is when you have an associative binary function and a value which acts as an identity with respect to that function. When something acts as an identity with respect to a function, it means that when called with that function and some other value, the result is always equal to that other value. 1 is the identity with respect to * and [] is the identity with respect to ++. There are a lot of other monoids to be found in the world of Haskell, which is why the Monoid type class exists. It&#8217;s for types which can act like monoids. Let&#8217;s see how the type class is defined:
Помітивши та записавши ці властивості, ми поставили перед собою моноїди! Моноїд - це коли у вас є асоціативна двомісна функція та значення, яке виступає як тотожність щодо цієї функції. Коли щось виступає як ідентичність відносно функції, це означає, що коли викликається з цією функцією та іншим значенням, результат завжди дорівнює цьому іншому значенню. <code>1</code> - тотожність відносно <code>*</code>, а <code>[]</code> - тотожність відносно <code>++</code>. У світі Haskell можна знайти багато інших моноїдів, саме тому існує типоклас <code>Monoid</code>. Це для типів, які можуть діяти як моноїди. Давайте подивимось, як визначається цей типоклас типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">::</span> <span class="n">m</span>
    <span class="n">mappend</span> <span class="ow">::</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span>
    <span class="n">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span>
    <span class="n">mconcat</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">mappend</span> <span class="n">mempty</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/balloondog.png" alt="images/balloondog.png" />
</span>
Типоклас <code>Monoid</code> визначений у <code>import Data.Monoid</code>. Давайте витратимо трохи часу і познайомимося належним чином з цим.</p></div>
<div class="paragraph"><p>Перш за все, ми бачимо, що лише конкретні типи можуть бути зроблені екземплярами <code>Monoid</code>, оскільки <code>m</code> у визначенні класу типу не приймає жодних параметрів типу. Це відрізняється від <code>Functor</code> та <code>Applicative</code>, які вимагають, щоб їх екземпляри були конструкторами типу, які приймають один параметр.</p></div>
<div class="paragraph"><p>Перша функція <code>mempty</code>. Це насправді не функція, оскільки вона не приймає параметрів, тому це поліморфна константа, на зразок <code>minBound</code> від <code>Bounded</code>. <code>mempty</code> являє значення ідентичності для певного моноїда.</p></div>
<div class="paragraph"><p>Далі ми маємо <code>mappend</code>, що, як ви, напевно, здогадалися, є двомісною функцією. Вона приймає два значення одного типу і також повертає значення цього типу. Варто зазначити, що рішення назвати <code>mappend</code> так, як воно було назване, було якось невдалим, оскільки це означає, що ми певним чином додаємо дві речі. Хоча <code>++</code> приймає два списки і додає один до іншого, <code>*</code> насправді нічого не додає, він просто перемножує два числа разом. Коли ми зустрінемося з іншими екземплярами <code>Monoid</code>, ми побачимо, що більшість з них також не додає значення, тому уникайте думки з точки зору додавання, а просто думайте з точки зору <code>mappend</code> як двомісної функції, яка приймає два моноїдні значення і повертає третє.</p></div>
<div class="paragraph"><p>Остання функція визначення цього типокласу - <code>mconcat</code>. Вона бере список моноїдних значень і зводить їх до єдиного значення, виконуючи відображення між елементами списку. У ньому є реалізація за замовчуванням, яка просто приймає порожній як початкове значення і складе список праворуч з <code>mappend</code>. Оскільки реалізація за замовчуванням для більшості випадків прекрасна, ми відтепер не будемо занадто сильно цікавитись <code>mconcat</code>. Створюючи тип екземпляр <code>Monoid</code>, достатньо просто реалізувати <code>mempty</code> і <code>mappend</code>. Причина, з якої <code>mconcat</code> взагалі існує, в тому, що для деяких випадків може бути більш ефективні способи реалізації <code>mconcat</code>, але для більшості випадків реалізація за замовчуванням просто чудова.</p></div>
<div class="paragraph"><p>Перш ніж перейти до конкретних екземплярів <code>Monoid</code>, давайте коротко розглянемо закони моноїдів. Ми згадували, що повинно бути значення, яке виступає як тотожність щодо двомісної функції і що двомісна функція повинна бути асоціативною. Можна зробити екземпляри <code>Monoid</code>, які не відповідають цим правилам, але такі екземпляри нікому не приносять користі, оскільки, використовуючи типоклас <code>Monoid</code>, ми покладаємось на його екземпляри, що діють як моноїди. Інакше в чому сенс? Ось чому, створюючи екземпляри, ми повинні переконатися, що вони відповідають цим законам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">mempty</span> <span class="ow">=</span> <span class="n">x</span>
<span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">(</span><span class="n">y</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">z</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перші два встановлюють, що <code>mempty</code> повинна діяти як тотожність щодо <code>mappend</code>, а третій говорить, що <code>mappend</code> має бути асоціативним, тобто, порядок, у якому ми використовуємо <code>mappend</code>, щоб змішати кілька моноїдних значень в одне, не має значення. Haskell не примушує виконувати ці закони, тому ми, як програмісти, повинні бути обережними, щоб наші екземпляри дійсно їм підкорялися.</p></div>
</div>
<div class="sect2">
<h3 id="___">Списки - це моноїди</h3>
<div class="paragraph"><p>Так, списки - моноїди! Як ми бачили, функція <code>++</code> та порожній список <code>[]</code> утворюють моноїд. Екземпляр дуже простий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">[]</span>
    <span class="n">mappend</span> <span class="ow">=</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки - це екземпляр типокласу <code>Monoid</code> незалежно від типу елементів, які вони містять. Зауважте, що ми писали <code>instance Monoid [a]</code>, а не <code>instance Monoid []</code>, оскільки <code>Monoid</code> вимагає конкретного типу для екземпляра.</p></div>
<div class="paragraph"><p>Проводячи тестовий прогон ми не стикаємось із сюрпризами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="s">&quot;one&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;two&quot;</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;tree&quot;</span>
<span class="s">&quot;onetwotree&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;one&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="p">(</span><span class="s">&quot;two&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;tree&quot;</span><span class="p">)</span>
<span class="s">&quot;onetwotree&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;one&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;two&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;tree&quot;</span>
<span class="s">&quot;onetwotree&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;pang&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">mempty</span>
<span class="s">&quot;pang&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mconcat</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mempty</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/smug.png" alt="images/smug.png" />
</span>
Зауважте, що в останньому рядку нам довелося написати явну анотацію типу, бо якби ми просто вказали порожні дужки, GHCi не знав би, який екземпляр використовувати. Тому ми повинні були сказати, що хочемо екземпляр списку. Ми змогли використовувати загальний тип <code>[a]</code> (на відміну від вказання <code>[Int]</code> або <code>[String]</code>), оскільки порожній список може діяти так, ніби він містить будь-який тип.</p></div>
<div class="paragraph"><p>Оскільки <code>mconcat</code> має реалізацію за замовчуванням, ми отримуємо її безкоштовно, коли робимо щось екземпляром <code>Monoid</code>. Що стосується списку, <code>mconcat</code> виявляється просто <code>concat</code>. Він бере список списків і сплющує його, тому що це еквівалент робити <code>++</code> над усіма суміжними списками списків.</p></div>
<div class="paragraph"><p>Закони для моноїдів дійсно дотримуються для екземпляру списку. Коли у нас є кілька списків і ми відображуємо їх (або робимо <code>++</code>) разом, не має значення, які з них ми зробимо спочатку, оскільки вони все одно просто з'єднані на кінцях. Також порожній список виступає як тотожність, тому все добре. Зауважте, що моноїди не вимагають, щоб <code>b mappend b</code> дорівнювало <code>a mappend a</code>. Що стосується списку, це, вочевидь, не так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;one&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;two&quot;</span>
<span class="s">&quot;onetwo&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;two&quot;</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="s">&quot;one&quot;</span>
<span class="s">&quot;twoone&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>І це нормально. Той факт, що для множення <code>3 * 5</code> і <code>5 * 3</code> однакові, є лише властивістю множення, але це не стосується всіх (і справді більшості) моноїдів.</p></div>
<div class="sect3">
<h4 id="_product__sum">Product і Sum</h4>
<div class="paragraph"><p>Ми вже вивчили один із способів, щоб числа вважалися моноїдами. Треба тільки взяти операцію <code>*</code>, а значення тотожності <code>1</code>. Виявляється, це не єдиний спосіб, щоб числа були моноїдами. Інший спосіб полягає у тому, щоб двомісна функція була <code>+</code>, а значення тотожності <code>0</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">4</span>
<span class="mi">4</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">0</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">5</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>Закони моноїдів дотримуються, тому що якщо ви додасте <code>0</code> до будь-якого числа, то результат - це саме число. І додаток також асоціативний, тому ми не маємо там ніяких проблем. Отже, тепер, коли є два однаково дійсні способи числа бути моноїдами, який спосіб вибрати? Ну, нам не треба саме обирати. Пам'ятайте, що коли існує декілька способів для того, щоб якийсь тип був екземпляром одного типокласу, ми можемо огорнути цей тип у <code>newtype</code>, а потім зробити новий тип примірником типокласу по-іншому. Ми можемо і мати свій торт, і при цьому з'їсти його.</p></div>
<div class="paragraph"><p>Модуль <code>Data.Monoid</code> експортує для цього два типи, а саме <code>Product</code> and <code>Sum</code>. <code>Product</code> визначається так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Product</span> <span class="n">a</span> <span class="ow">=</span>  <span class="kt">Product</span> <span class="p">{</span> <span class="n">getProduct</span> <span class="ow">::</span> <span class="n">a</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Simple, just a newtype wrapper with one type parameter along with some derived instances. Its instance for Monoid goes a little something like this:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Num</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Product</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="mi">1</span>
    <span class="kt">Product</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Product</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Product</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>mempty</code> - це лише <code>1</code> загорнутий у конструктор <code>Product</code>. <code>mappend</code> робить відповідність шаблону на конструкторі <code>Product</code>, помножить два числа і потім повертає отримане число назад. Як бачите, існує обмеження класу <code>Num</code>. Отже, це означає, що <code>Product a</code> є екземпляром <code>Monoid</code> для всіх <code>a</code>, які вже є екземпляром <code>Num</code>. Щоб використовувати <code>Producta a</code> як моноїд, нам потрібно зробити деяке загортання та розгортання <code>newtype</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getProduct</span> <span class="o">$</span> <span class="kt">Product</span> <span class="mi">3</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Product</span> <span class="mi">9</span>
<span class="mi">27</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getProduct</span> <span class="o">$</span> <span class="kt">Product</span> <span class="mi">3</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">mempty</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getProduct</span> <span class="o">$</span> <span class="kt">Product</span> <span class="mi">3</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Product</span> <span class="mi">4</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Product</span> <span class="mi">2</span>
<span class="mi">24</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getProduct</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">Product</span> <span class="o">$</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">24</span>
</pre></div></div></div>
<div class="paragraph"><p>Це добре, як демонстрація типокласу <code>Monoid</code>. Та ніхто у власному розумі не використовує цей спосіб множення чисел, а просто записує <code>3 * 9</code> і <code>3 * 1</code>. Але трохи пізніше ми побачимо, як ці екземпляри <code>Monoid</code> випадки, які зараз можуть здатися тривіальними, можуть стати в нагоді.</p></div>
<div class="paragraph"><p><code>Sum</code> визначається як <code>Product</code>, і екземпляр також подібний. Ми використовуємо його так само:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getSum</span> <span class="o">$</span> <span class="kt">Sum</span> <span class="mi">2</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Sum</span> <span class="mi">9</span>
<span class="mi">11</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getSum</span> <span class="o">$</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Sum</span> <span class="mi">3</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getSum</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">Sum</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">6</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="_any__all">Any та All</h4>
<div class="paragraph"><p>Інший тип, який може діяти як моноїд двома різними, але однаково справедливими способами - це <code>Bool</code>. Перший спосіб - щоб <code>or</code> функція <code>||</code> виступала як двомісна функція, з <code>False</code> як значення ідентичності. Логічне  <code>or</code> працює так, що якщо будь-який з двох його параметрів є <code>True</code>, він повертає <code>True</code>, інакше повертає <code>False</code>. Отже, якщо ми використовуємо <code>False</code> як значення ідентичності, воно повертає <code>False</code>, коли робиться <code>or</code> із <code>False</code>, та <code>True</code>, коли <code>or</code> з <code>True</code>. Таким чином, конструктор <code>newtype Any</code> є примірником <code>Monoid</code>. Це визначено так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">Any</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">{</span> <span class="n">getAny</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Його екземпляр виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Any</span> <span class="kr">where</span>
        <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="kt">False</span>
        <span class="kt">Any</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">Any</span> <span class="p">(</span><span class="n">x</span> <span class="o">||</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Причина, чому це називається <code>Any</code> - це те, що <code>x mappend y</code> буде <code>True</code>, якщо будь-який з цих двох є <code>True</code>. Навіть якщо три або більше будь-яких огорнутих <code>Bool</code> відображаються разом, результат буде <code>True</code>, якщо будь-який з них <code>True</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="kt">Any</span> <span class="kt">True</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Any</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">Any</span> <span class="o">$</span> <span class="p">[</span><span class="kt">False</span><span class="p">,</span> <span class="kt">False</span><span class="p">,</span> <span class="kt">False</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">mempty</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший спосіб для <code>Bool</code> бути екземпляром <code>Monoid</code> - це зробити щось протилежне: обрати <code>&amp;&amp;</code> двомісною функцією, а потім зробити <code>True</code> значенням ідентичності. Логічно, і поверне <code>True</code> лише в тому випадку, якщо обидва його параметра є <code>True</code>. Це декларація <code>newtype</code>, нічого захмарного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">All</span> <span class="ow">=</span> <span class="kt">All</span> <span class="p">{</span> <span class="n">getAll</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="p">}</span>
        <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>І ось екземпляр:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">All</span> <span class="kr">where</span>
        <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">All</span> <span class="kt">True</span>
        <span class="kt">All</span> <span class="n">x</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">All</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">All</span> <span class="p">(</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми будемо відображати значення типу <code>All</code>, результат буде <code>True</code>, лише якщо всі значення, використані в операціях є <code>True</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAll</span> <span class="o">$</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">All</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAll</span> <span class="o">$</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">All</span> <span class="kt">False</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAll</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">All</span> <span class="o">$</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAll</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">All</span> <span class="o">$</span> <span class="p">[</span><span class="kt">True</span><span class="p">,</span> <span class="kt">True</span><span class="p">,</span> <span class="kt">False</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і у випадку множення та додавання, ми, як правило, явно констатуємо двомісні функції замість того, щоб загортати їх у нові типи, а потім використовуючи <code>mappend</code> та <code>mempty</code>. <code>mconcat</code> здається корисним для <code>Any</code> та <code>All</code>, але зазвичай простіше використовувати функції <code>or</code> та <code>and</code>, які беруть списки <code>Bool</code> та повертають <code>True</code>, якщо будь-який з них є <code>True</code> або, якщо всі вони <code>True</code>, відповідно.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__ordering">Моноїд Ordering</h3>
<div class="paragraph"><p>Гей, пам'ятаєте тип замовлення? Він використовується як результат при порівнянні речей, і він може мати три значення: <code>LT</code>, <code>EQ</code> і <code>GT</code>, які означають менше, рівне і більше, ніж відповідно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">2</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">2</span>
<span class="kt">EQ</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">2</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Зі списків, чисел та логігчних значень пошук моноїдів був лише питанням перегляду вже існуючих загальновживаних функцій та з'ясування, чи виявляють вони певну поведінку моноїдів. З <code>Ordering</code> нам потрібно трохи важче розпізнати моноїд, але виявляється, що його екземпляр <code>Monoid</code> такий же інтуїтивний, як і ті, з якими ми зустрічалися дотепер, а також досить корисний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="kt">Ordering</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">EQ</span>
    <span class="kt">LT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">LT</span>
    <span class="kt">EQ</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">y</span>
    <span class="kt">GT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bear.png" alt="images/bear.png" />
</span>
Екземпляр налаштовано так: коли ми відображаємо два значення <code>Ordering</code>, якщо значення зліва не є <code>EQ</code> - зберігається те що зліва, в іншошму випадку правий результат. Тотожність - <code>EQ</code>. Спочатку це може здатися вигадкою, але насправді це нагадує те, як ми в алфавітному порядку порівнюємо слова. Ми порівнюємо перші дві літери, і якщо вони відрізняються, ми вже можемо вирішити, яке слово піде першим у словнику. Однак якщо перші дві літери рівні, то переходимо до порівняння наступної пари літер і повторюємо процес.</p></div>
<div class="paragraph"><p>Наприклад, якби ми порівнювали слова <code>"ox"</code> і <code>"on"</code> за алфавітом, ми спочатку порівняємо перші дві літери кожного слова, побачимо, що вони рівні, а потім перейдемо до порівняння другої літери кожного слова. Ми бачимо, що <code>"x"</code> в алфавітному порядку більше, ніж <code>"n"</code>, і тому ми знаємо, як порівняти. Щоб отримати певну інтуїцію того, що <code>EQ</code> є тотожністю, ми можемо помітити, що якби ми описували одну й ту саму букву в одному положенні обома словами, це не змінило б їх алфавітне впорядкування. <code>"oix"</code> як і раніше в алфавітному порядку більше, ніж <code>"oin"</code>.</p></div>
<div class="paragraph"><p>Важливо зазначити, що в екземплярі <code>Monoid</code> для <code>Ordering</code> вираз <code>x ``mappend`</code> y` не дорівнює <code>y ``mappend`</code> x`. Оскільки перший параметр зберігається, якщо це не <code>EQ</code>, <code>LT `mappend</code> GT` призведе до LT, тоді як <code>GT ``mappend`</code> LT` призведе до <code>GT</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">LT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">GT</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">GT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">LT</span>
<span class="kt">GT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">LT</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mempty</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">GT</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, так чим корисний цей моноїд? Скажімо, ви писали функцію, яка приймає два рядки, порівнює їх довжину та повертає <code>Ordering</code>. Але якщо рядки однакової довжини, то замість повернення <code>EQ</code> відразу, ми хочемо порівняти їх за алфавітом. Один із способів написати це було б так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span>
                        <span class="n">b</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span>
                    <span class="kr">in</span>  <span class="kr">if</span> <span class="n">a</span> <span class="o">==</span> <span class="kt">EQ</span> <span class="kr">then</span> <span class="n">b</span> <span class="kr">else</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми називаємо результат порівняння довжин <code>a</code> і результат алфавітного порівняння <code>b</code>, а потім, якщо виявиться, що довжини були рівними, повертаємо їх алфавітне впорядкування.</p></div>
<div class="paragraph"><p>Але використовуючи розуміння того, як <code>Ordering</code> є моноїдом, ми можемо переписати цю функцію набагато простіше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо спробувати це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lengthCompare</span> <span class="s">&quot;zen&quot;</span> <span class="s">&quot;ants&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lengthCompare</span> <span class="s">&quot;zen&quot;</span> <span class="s">&quot;ant&quot;</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Пам'ятайте, що коли ми використовуємо <code>mappend</code>, його лівий параметр завжди зберігається, якщо це не <code>EQ</code>, в цьому випадку зберігається правий. Ось чому ми ставимо першим параметром порівняння, яке ми вважаємо першим, більш важливим критерієм. Якщо ми хочемо розширити цю функцію і порівняти за кількістю голосних і встановити це другим найважливішим критерієм для порівняння, ми просто змінимо її так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.Monoid</span>

<span class="nf">lengthCompare</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">lengthCompare</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="p">(</span><span class="n">length</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">length</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">vowels</span> <span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">vowels</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                    <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span>
    <span class="kr">where</span> <span class="n">vowels</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="s">&quot;aeiou&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми зробили допоміжну функцію, яка приймає рядок і повідомляє нам, скільки с ньому голосних, спочатку відфільтрувавши лише літери, що знаходяться в рядку <code>"aeiou"</code>, а потім застосувавши до цього <code>length</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lengthCompare</span> <span class="s">&quot;zen&quot;</span> <span class="s">&quot;anna&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lengthCompare</span> <span class="s">&quot;zen&quot;</span> <span class="s">&quot;ana&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lengthCompare</span> <span class="s">&quot;zen&quot;</span> <span class="s">&quot;ann&quot;</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Дуже круто. Тут ми бачимо, як у першому прикладі довжини виявляються різними, і тому повертається <code>LT</code>, оскільки довжина <code>"zen"</code> менша, ніж довжина <code>"anna"</code>. У другому прикладі довжини однакові, але другий рядок має більше голосних, тому <code>LT</code> повертається знову. У третьому прикладі вони обидві мають однакову довжину і однакову кількість голосних, тому їх порівнюють за алфавітом і <code>"zen"</code> перемагає.</p></div>
<div class="paragraph"><p>Моноїд <code>Ordering</code> дуже класний, оскільки дозволяє легко порівнювати речі за багатьма різними критеріями та встановлювати ці критерії в самому порядку, починаючи від найважливішого до найменш важливого.</p></div>
<div class="sect3">
<h4 id="__maybe">Монада Maybe</h4>
<div class="paragraph"><p>Давайте розглянемо різні способи того, можна <code>Maybe</code> зробити екземпляром <code>Monoid</code> і для чого ці екземпляри корисні.</p></div>
<div class="paragraph"><p>One way is to treat Maybe a as a monoid only if its type parameter a is a monoid as well and then implement mappend in such a way that it uses the mappend operation of the values that are wrapped with Just. We use Nothing as the identity, and so if one of the two values that we&#8217;re mappending is Nothing, we keep the other value. Here&#8217;s the instance declaration:
Одним із способів є трактування <code>Maybe</code> як моноїд лише у тому випадку, якщо його параметр типу <code>a</code> є також моноїдом, а потім реалізувати <code>mappend</code> таким чином, щоб він використовував операцію відображення значень, які обернуті <code>Just</code>. Ми використовуємо <code>Nothing</code> як тотожність, і тому, якщо одне з двох значень, які ми відображаємо, - <code>Nothing</code>, ми зберігаємо інше значення. Ось декларація екземпляра:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">Nothing</span>
    <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">m</span>
    <span class="n">m</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="n">m</span>
    <span class="kt">Just</span> <span class="n">m1</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Just</span> <span class="n">m2</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">m1</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">m2</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте обмеження класу. Це говорить про те, що <code>Maybe a</code> є екземпляром <code>Monoid</code>, лише якщо <code>a</code> є екземпляром <code>Monoid</code>. Якщо ми відображаємо щось з <code>Nothing</code>, результат - це щось. Якщо ми відображаємо два значення <code>Just</code>, вміст ціх <code>Just</code> отримують <code>mappend</code>, а потім загортають у <code>Just</code>. Ми можемо це зробити, тому що обмеження класу гарантує, що тип того, що знаходиться всередині <code>Just</code>, є примірником <code>Monoid</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Just</span> <span class="s">&quot;andy&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;andy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="kt">LT</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Nothing</span>
<span class="kt">Just</span> <span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Sum</span> <span class="mi">3</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Just</span> <span class="p">(</span><span class="kt">Sum</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Just</span> <span class="p">(</span><span class="kt">Sum</span> <span class="p">{</span><span class="n">getSum</span> <span class="ow">=</span> <span class="mi">7</span><span class="p">})</span>
</pre></div></div></div>
<div class="paragraph"><p>Це застосовується, коли ви маєте справу з моноїдами як результати обчислень, які, можливо, не вдалися. Через цей екземпляр нам не потрібно перевіряти, чи не вдалося здійснити обчислення, побачивши, чи є вони значенням <code>Nothing</code> чи <code>Just</code>; ми можемо просто продовжувати ставитися до них як до звичайних моноїдів.</p></div>
<div class="paragraph"><p>Але що робити, якщо тип вмісту <code>Maybe</code> не є екземпляром <code>Monoid</code>? Зауважте, що в попередній декларації екземпляра єдиний випадок, коли нам доводиться розраховувати на те, що вміст є моноїдами, це коли обидва параметри відображення є <code>Just</code> значеннями. Але якщо ми не знаємо, чи вміст є моноїдами, ми не можемо використовувати <code>mappend</code> між ними, і що робити? Ну, одне, що ми можемо зробити, - це просто відкинути друге значення і зберегти перше. Для цього існує тип <code>First</code>, і це його визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">First</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">First</span> <span class="p">{</span> <span class="n">getFirst</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="p">}</span>
    <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми беремо <code>Maybe</code> і огортаємо його новим типом. Екземпляр <code>Monoid</code> такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">First</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">=</span> <span class="kt">First</span> <span class="kt">Nothing</span>
    <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span>
    <span class="kt">First</span> <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Саме так, як ми казали. <code>mempty</code> - це просто <code>Nothing</code>, обгорнуте <code>newtype</code> конструктором <code>First</code>. Якщо перший параметр <code>mappend</code> - це значення <code>Just</code>, ми ігноруємо другий. Якщо перший - це <code>Nothing</code>, то в результаті ми представляємо другий параметр, незалежно від того, чи це <code>Just</code> чи <code>Nothing</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getFirst</span> <span class="o">$</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getFirst</span> <span class="o">$</span> <span class="kt">First</span> <span class="kt">Nothing</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;b&#39;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="sc">&#39;b&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getFirst</span> <span class="o">$</span> <span class="kt">First</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">First</span> <span class="kt">Nothing</span>
<span class="kt">Just</span> <span class="sc">&#39;a&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>First</code> корисний, коли у нас є кіпа значень <code>Maybe</code>, і ми просто хочемо знати, чи є якась із них <code>Just</code>. Стає в нагоді функція <code>mconcat</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getFirst</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">First</span> <span class="o">$</span> <span class="p">[</span><span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">9</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">10</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми хочемо моноїд на <code>Maybe</code> такий, щоб зберігався другий параметр, якщо обидва параметри відображення є <code>Just</code> значеннями, <code>Data.Monoid</code> надає тип <code>Last</code>, який працює як <code>First a</code>, але при використанні <code>mconcat</code> зберігається лише останнє не-<code>Nothing</code> значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getLast</span> <span class="o">.</span> <span class="n">mconcat</span> <span class="o">.</span> <span class="n">map</span> <span class="kt">Last</span> <span class="o">$</span> <span class="p">[</span><span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">9</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">10</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">10</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getLast</span> <span class="o">$</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;one&quot;</span><span class="p">)</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span> <span class="kt">Last</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;two&quot;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="s">&quot;two&quot;</span>
</pre></div></div></div>
</div>
</div>
<div class="sect2">
<h3 id="______">Використання моноїдів для згортання структур даних</h3>
<div class="paragraph"><p>Один з найбільш цікавих способів примусити моноїди працювати - це зробити так, щоб вони допомагали нам визначати згортки різних структур даних. Поки що ми робили лише згортки над списками, але списки - не єдина структура даних, яку можна згорнути. Ми можемо визначити згортку майже будь-якої структури даних. Дерева особливо добре піддаються згортанню.</p></div>
<div class="paragraph"><p>Оскільки існує стільки структур даних, які добре працюють зі згортками, було введено типоклас <code>Foldable</code>. Настільки ж, як <code>Functor</code> - для речей, по яких можна зробити відображення, <code>Foldable</code> - для речей, які можна згорнути! Його можна знайти в <code>Data.Foldable</code>, і тому що він імпортує функції, імена яких суперечать тим, що знаходяться в <code>Prelude</code>, його краще імпортувати кваліфікованим (і подавати з базиліком):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Foldable</span> <span class="k">as</span> <span class="n">F</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб заощадити собі дорогоцінні натискання клавіш, ми вирішили імпортувати його кваліфікований як <code>F</code>. Добре, тож які функції, які визначає цей тип класу? Ну, серед них є <code>foldr</code>, <code>foldl</code>, <code>foldr1</code> і <code>foldl1</code>. Так? Але ми вже знаємо ці функції, що тут нового у цьому? Порівняємо типи <code>Foldable foldr</code> та <code>foldr</code> з <code>Prelude</code>, щоб побачити, як вони відрізняються:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">foldr</span>
<span class="nf">foldr</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldr</span>
<span class="kt">F</span><span class="o">.</span><span class="n">foldr</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">F</span><span class="o">.</span><span class="kt">Foldable</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Ah! So whereas foldr takes a list and folds it up, the foldr from Data.Foldable accepts any type that can be folded up, not just lists! As expected, both foldr functions do the same for lists:
Ах! Тоді як <code>foldr</code> бере список і згортає його, то <code>foldr</code> від <code>Data.Foldable</code> приймає будь-який тип, який можна згорнути, а не лише списки! Як і очікувалося, обидві функції <code>foldr</code> роблять те саме для списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">6</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldr</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="mi">6</span>
</pre></div></div></div>
<div class="paragraph"><p>Добре, тоді які ще структури даних підтримують згортання? Що ж, <code>Maybe</code>, яку ми всі знаємо і любимо!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">2</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">9</span><span class="p">)</span>
<span class="mi">11</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldr</span> <span class="p">(</span><span class="o">||</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="kt">Just</span> <span class="kt">True</span><span class="p">)</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Але згортування значень <code>Maybe</code> не дуже цікаве, тому що, коли мова йде про згортання, воно просто діє як список з одним елементом, якщо це значення <code>Just</code>, і як порожній список, якщо це <code>Nothing</code>. Тож тоді давайте вивчимо структуру даних, яка трохи складніша.</p></div>
<div class="paragraph"><p>Пам'ятаєте структуру даних дерево з розділу "Створення власних типів та класів типів"? Ми визначили її так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми казали, що дерево - це порожнє дерево, яке не містить жодних значень, або це вузол, який містить одне значення, а також два інші дерева. Визначивши, ми зробили його екземпляром <code>Functor</code> і завдяки цьому ми отримали можливість <code>fmap</code> функцій над ним. Тепер ми зробимо його екземпляром <code>Foldable</code>, щоб ми отримали можливість згортати її. Один із способів зробити конструктор типу екземпляром <code>Foldable</code> - це просто безпосередньо реалізувати <code>foldr</code> для нього. Але ще один, часто набагато простіший спосіб - реалізувати функцію <code>foldMap</code>, яка також є частиною класу типу <code>Foldable</code>. Функція <code>foldMap</code> має такий тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">foldMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Monoid</span> <span class="n">m</span><span class="p">,</span> <span class="kt">Foldable</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">m</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший її параметр - це функція, яка приймає значення типу, що містить наша згорнувана структура (позначена тут <code>а</code>) і повертає моноїдне значення. Другий його параметр - структура, яка містить значення типу <code>a</code>. Він відображає функції, що функціонують над згортуваною структурою, створюючи таким чином згортувану структуру, яка містить моноїдні значення. Потім, зробивши відображення між цими моноїдними значеннями, він об'єднує їх усі в єдине моноїдне значення. Наразі ця функція може здатися дивною, але ми побачимо, що це дуже легко здійснити. Що також приємно - це те, що реалізація цієї функції - це все, що потрібно для нашого типу, щоб зробити екземпляр <code>Foldable</code>. Отже, якщо ми просто реалізуємо <code>foldMap</code> для певного типу, ми отримуємо <code>foldr</code> та <code>foldl</code> цього типу безкоштовно!</p></div>
<div class="paragraph"><p>Ось як ми робимо <code>Tree</code> екземпляром <code>Foldable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">F</span><span class="o">.</span><span class="kt">Foldable</span> <span class="kt">Tree</span> <span class="kr">where</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="kt">Empty</span> <span class="ow">=</span> <span class="n">mempty</span>
    <span class="n">foldMap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">l</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="n">f</span> <span class="n">l</span> <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                             <span class="n">f</span> <span class="n">x</span>           <span class="p">`</span><span class="n">mappend</span><span class="p">`</span>
                             <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="n">f</span> <span class="n">r</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/accordion.png" alt="images/accordion.png" />
</span>
Ми думаємо так: якщо нам надають функцію, яка бере елемент нашого дерева і повертає моноїдне значення, як ми зменшимо все наше дерево до одного моноїдного значення? Коли ми робили <code>fmap</code> над своїм деревом, ми застосували функцію, яку ми відображали у вузол, а потім рекурсивно відобразили функцію як на лівому піддереві, так і на правому. Тут ми маємо завдання не тільки відобразити функцію, але і об'єднати результати в єдине моноїдне значення за допомогою <code>mappend</code>. Спочатку ми розглянемо випадок порожнього дерева - сумного і самотнього дерева, яке не має жодних значень чи піддерев. Воно не має жодного значення, яке ми можемо надати нашій функції створення моноїдів, тому ми просто кажемо, що якщо наше дерево порожнє, значення моноїда, яким воно стає, є <code>mempty</code>.</p></div>
<div class="paragraph"><p>Випадок непорожнього вузла трохи цікавіший. Він містить два піддерева, а також значення. У цьому випадку ми рекурсивно <code>foldMap</code> однакову функцію <code>f</code> над лівим та правим під деревами. Пам’ятайте, наш <code>foldMap</code> приводить до єдиного моноїдного значення. Ми також застосовуємо нашу функцію <code>f</code> до значення у вузлі. Тепер у нас є три моноїдні значення (два з наших під-дерев і одне із застосування <code>f</code> до значення у вузлі), і нам просто потрібно об'єднати їх в одне значення. Для цієї мети ми використовуємо <code>mappend</code>, і, природно, спочатку приходить ліве піддерево, потім значення вузла, а потім праве піддерево.</p></div>
<div class="paragraph"><p>Зауважте, що нам не довелося надавати функцію, яка приймає значення і повертає моноїдне значення. Ми отримуємо цю функцію як параметр <code>foldMap</code>, і все, що нам потрібно вирішити, це де застосувати цю функцію та як з'єднати отримані з нею моноїди.</p></div>
<div class="paragraph"><p>Тепер, коли у нас є <code>Foldable</code> екземпляр для нашого типу дерева, ми отримуємо <code>foldr</code> і <code>foldl</code> безкоштовно! Розглянемо це дерево:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">testTree</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="mi">5</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="p">(</span><span class="kt">Node</span> <span class="mi">9</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
                <span class="p">(</span><span class="kt">Node</span> <span class="mi">10</span> <span class="kt">Empty</span> <span class="kt">Empty</span><span class="p">)</span>
            <span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>У його корені 5, а потім лівий вузол має 3, 1 зліва та 6 праворуч. Правий вузол кореня має 9, а потім 8 зліва та 10 на крайній правій стороні. За допомогою згортуваного екземпляра ми можемо виконати всі згортки, які ми можемо зробити у списках:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">testTree</span>
<span class="mi">42</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldl</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="mi">1</span> <span class="n">testTree</span>
<span class="mi">64800</span>
</pre></div></div></div>
<div class="paragraph"><p>Крім того, <code>foldMap</code> корисний не лише для створення нових примірників <code>Foldable</code>; він стане в нагоді для редукції нашої структури до єдиного моноїдного значення. Наприклад, якщо ми хочемо знати, чи будь-яке число в нашому дереві дорівнює <code>3</code>, ми можемо це зробити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Any</span> <span class="o">$</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="n">testTree</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут <code>\x -&gt; Any $ x == 3</code> - це функція, яка приймає число і повертає значення моноїда, а саме <code>Bool</code>, загорнутий у <code>Any</code>. <code>foldMap</code> застосовує цю функцію до кожного елемента в нашому дереві, а потім редукує отримані моноїди в єдиний моноїд з <code>mappend</code>. Якщо ми це зробимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getAny</span> <span class="o">$</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="kt">Any</span> <span class="o">$</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="n">testTree</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Усі вузли на нашому дереві матимуть значення <code>Any False</code> після того, як функція в лямбда застосована до них. Але щоб отримати <code>True</code>, <code>mappend</code> для <code>Any</code> повинен мати як параметр принаймні одне значення <code>True</code>. Ось чому кінцевий результат - <code>False</code>, що має сенс, оскільки жодне значення на нашому дереві не перевищує 15.</p></div>
<div class="paragraph"><p>Ми також можемо легко перетворити наше дерево у список, зробивши <code>foldMap</code> з функцією <code>\x -&gt; [x]</code>. Спочатку запроектувавши цю функцію на наше дерево, кожен елемент стає синглтон списком. Дія <code>mappend</code>, яка відбувається між усіма цим  синглтон списками, приводить до єдиного списку, який містить усі елементи, які є в нашому дереві:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">F</span><span class="o">.</span><span class="n">foldMap</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="n">testTree</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Приємно те, що всі ці трюки не обмежуються деревами, вони працюють на будь-якому екземплярі <code>Foldable</code>.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-28 07:23:00 EET
</div>
</div>
</body>
</html>
