include::header.adoc[]

== Вступ

=== Щодо цього туторіала

Запрошуємо до Learn You a Haskell for Great Good! Якщо ви читаєте це, є шанси, що ви бажаєте вивчити Haskell. Так, ви опинились в правильному місці, але спершу давайте поговоримо про сам цей туторіал.

Я вирішив написати це, бо я хотів покращити моє влане знання Haskell, і оскільки я думав, що можу допомогти новим до Haskell людям вивчати його з моєї перспективи. Існує досить небагато туторіалів по Haskell, що плавають в інтернеті. Коли я починав з Haskell, я не навчався тільки з одного ресурсу. Спосіб, яким я навчався, було читання декількох різних туторіалів та статей, оскільки кожний пояснював дещо в інший спосіб, ніж інший. Проходячи по різним ресурсам я був в змозі скласти разом частини, та все займало своє місце. Так що це спроба додати інший корисний ресурс для вивчення Haskell, так що ви маєте більший шанс знайти те, що вам сподобається.


image:images/bird.png[]
Цей туторіал націлений на людей, що мають досвід з імперативними мовами програмування (C, C++, Java, Python …), але досі не програмували на функціональних мовах (Haskell, ML, OCaml …). Хоча  я можу поспорити, що навіть якщо ви не маєте жодного значного програмного досвіду, розумна людина, як ви, буде в змозі відслідковувати хід подій та навчиться Haskell.

Канал `#haskell` в мережі `freenode` є чудовим місцем запитувати питання, якщо ви почуваєтесь розгубленим. Люди там вкрай милі, терплячі та розуміють початківців.

Я не зміг вивчити Haskell приблизно два рази, перед тим як нарешті підхопив його, оскільки все це виглядало дуже збоченим, і я не міг зрозуміти. Але одного разу воно просто "клацнуло", і після продирання через початкові хащі це видалось досі спокійне плавання. Як мені здається я намагаюсь сказати: Haskell чудовий, і якщо ви дійсно зацікавлені в програмуванні, вам слід дійсно вивчити його, навіть якщо спочатку він виглядає збоченим. Вивчення Haskell більш подібне на навчання програмування з самого початку — це весело! Це дозволяє вам мислити інакше, що відносить нас в другий розділ …

=== Так що таке Haskell?

image:images/fx.png[]
Haskell є *чисто функціональна мова програмування*. В імперативних мовах ви отримуєте речі зробленими через надання комп'ютеру послідовність завдань, та потів виконуєте їх. При їх виконанні це може змінювати стан. Наприклад, ви встановили змінну в `5`, потім робили дещо, та потім встановили її в дещо інше. Ви маєте структури керування потоком, щоб виконати деяку дію декілька раз. В чисто функціональному програмуванні ви не кажете комп'ютеру, що робити як таке, але скоріше ви кажете, що має бути. Факторіал числа є добуток всіх чисел від 1 до цього числа, сума списка чисел є перше число, плюс сума інших чисел, і так далі. Ви виражаєте це в формі функцій. Ви також не можете змінну в дещо, і пізніше встановити її в дещо інше. Якщо ви кажете, що `a` є `5`, ви не можете пізніше сказати що це щось інше, бо ви сказали що це `5`. Ви що, якийсь брехун? Так що в повністю функціональних мовах функція не має побічних ефектів. Єдина річ, що може робити функція, це обчислювати дещо і повертати це як результат. Спочатку це виглядає як деяке обмеження, але насправді має дуже милі наслідки: якщо функція викликається два рази з тими самими параметрами, вона гарантовано повертає той самий результат. Це називаеться посилковою прозорістю, і не тільки дозволяє компілятору промислювати поведінку програми, але також дозволяє просто доходити висновку (та навіть доводити), що функція коректна, та потім будувати більш складні функції, через склеювання простих функцій разом.

image:images/lazy.png[] 
Haskell *лінивий*. Це означає, що якщо спеціально не сказане інше,Haskell не виконуватиме функцій та не обчислюватиме речі, коли його дійсно не змусить це робити, щоб показати вам результат. Це гарно пасує до прозорості посилань, і це дозволяє вам думати про програми як про серії перетворень даних. Це також дозволяє круті речі, такі як безкінечні структури даних. Скажімо, ви маєте незмінний список чисел `xs = [1,2,3,4,5,6,7,8]`, та функцію `doubleMe`, що множить кожний елемент на `2`, та потім повертає новий список. Якщо ми б захотіли помножити весь список на 8 в імперативній мові, та зробити `doubleMe(doubleMe(doubleMe(xs)))`, це можливо пройшло б по списку один раз, та зробило копію, щоб повернути її. Потім це пройшло б по списку ще два рази, та повернуло результат. В лінивій мові виклик `doubleMe` на списку без примусу показати вам результат скінчиться тим, що програма скаже вам щось накшталт "Так-так, я зроблю це пізніше!". Але коли ви захочете побачити результат, перший `doubleMe` каже другому, що він хоче результат, негайно! Другий каже те саме до третього, і третій похопцем повертає подвоєні `1`, що є `2`. Другий отримує це і повертає `4` першому. Перший виклик бачить це і повертає вам `8`. Так що відбувається тільки один прохід по списку, і тільки тоді, коли вам це дійсно треба. Таким чином, коли ви бажаєте дещо від лінивої мови, ви можете просто взяти початкові дані, і ефективно перетворити та полагодити, так, щоб воно відтворювале те, що ви бажаєте мати в кінці.

image:images/boat.png[] 
Haskell є *статично типізованим*. Коли ви компілюєте вашу програму, компілятор знає, яка частина коду є числом, яка є рядком і так далі. Це означає, що багато з можливих помилок будуть виловлені під час компіляції. Якщо ви спробуєте додати разом число та рядок, компілятор буде скиглити на вас. Haskell використовую дуже гарну систему типів, що має вивід типів. Це означає, що вам не треба насправді явно помічати кожний кусок коду типом, бо система типів може розумно здогадатись більшість з них. Якщо ви кажете `a = 5 + 4`, ви не маєте казати Haskell, що `a` є числом, він сам може про це здогадатись. Вивід типів також дозволяє вашому коду бути більш загальним. Якщо функція, що ви створюєте, приймає два параметри, та додає їх разом, та ви явно не встановили їх тип, функція буде робити на любих двох параметрах, що поводяться як числа.

Haskell є *елегантним та стислим*. Оскільки він використовує багато концепцій високого рівня, програми Haskell звичайно коротші, ніж їх імперативні еквіваленти. Та коротші програми простіше підтримувати, ніж довгі, та мати меньшн вад.

Haskell був зроблений *дійсно розумними хлопцями* (з науковими ступенями). Робота над Haskell почалась в 1987му році, коли комітет розробників зібрався разом щоб розробити несамовиту мову. В 2003 був опублікований Haskell Report, що визначає стабільну версію мови.

=== Що вам треба щоб розпочати

Текстовий редактор та компілятор Haskell. Ви, можливо, вже маєте ваш улюблений текстовий редактор встановленим, так що ми не витрачатимемо не це час. Для цілей цього туторіала ми будемо використовувати GHC, найбільш широко уживаний компілятор Haskell. Кращий шлях розпочати - завантажити _Haskell Platform_, що в основному той самий Haskell в комплекті з батарейками.

GHC може прийняти Haskell скрипт (вони звичайно мають розширення `.hs`), та компілювати його, але він також має інтерактивний режим, що дозволяє вам інтерактивно взаємодіяти зі скриптами. Інтерактивно. Ви можете викликати функції зі скриптів, що ви завантажуєте, і результати відображуються безпосередньо. Для навчання це значно простіше і швидше, ніж компілювати кожного разу щоб зробити зміну, та потім виконувати програму з консольної підказки. Інтерактивний режим викликається запуском `ghci` в підказці консолі. Якщо ви визначили деякі функції в викликаному файлі, скажімо, `myfunctions.hs`, ви завантажуєте ці функції через набір `:l myfunctions`, і потім граєтесь з ними, вважаючи, що `myfunctions.hs` в тому самому файлі, з якого був запущений `ghci`. Якщо ви зміните `.hs` скрипт, просто виконайте `:l myfunctions` знову, або зробіть `:r`, що еквівалентно, оскільки це перевантажує поточний скрипт. Звичайна послідовність для мене, коли я граюсь з деякими речами, це створення деяких функцій в `.hs` файлі, завантаження їх, та забавки з ними, та потім зміна файла `.hs`, завантаження його знову, і так далі. Це також те, що ми будемо тут з вами робити.
