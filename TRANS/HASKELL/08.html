<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="______">Створення своїх власних типів та типокласів</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередніх главах ми розглядали деякі існуючі типи та типокласи Haskell. В цій главі ми навчимось як створювати свої власні, та як змусити їх робити!</p></div>
<div class="sect2">
<h3 id="_____">Введення в алгебраїчні типи даних</h3>
<div class="paragraph"><p>Досі ми зустрічали багато типів даних. <code>Bool</code>, <code>Int</code>, <code>Char</code>, <code>Maybe</code>,тощо. Але як ми створюємо свої власні? Гаразд, один спосіб є використання ключового слова <code>data</code> для визначення типу. Давайте подивимось, як визначений тип <code>Bool</code> в стандартній бібліотеці.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>data</code> означає, що ми визначаємо новий тип даних. Частина перед <code>=</code> означає тип, що є <code>Bool</code>. Частини після <code>=</code> є конструкторами значень. Вони вказують різні значення, що може мати тип. <code>|</code> читається як <em>або</em>. Так що ми можемо читати це так: тип <code>Bool</code> може мати тип значення <code>True</code> або <code>False</code>. Обоє, им'я типу та конструктори значення, мають бути з великої літери.</p></div>
<div class="paragraph"><p>В подібному стилі ми можемо думати про тип <code>Int</code>, як визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">2147483648</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2147483647</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">2147483647</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/caveman.png" alt="images/caveman.png" />
</span>
Перший та останній конструктори значень є мінімальне та максимальне можливі значення для <code>Int</code>. Насправді це не визначено таким чином, три крапки, що стоять тут, через те, що ми пропустили безліч чисел, так що все це тільки для цілей ілюстрації.</p></div>
<div class="paragraph"><p>Тепер давайте подумаємо про те, як ми можемо представити фігуру в Haskell. Один спосіб може бути використання таплів. Коло може бути позначено як <code>(43.1, 55.0, 10.4)</code>, де перші два поля є координати центру, а третє поле є радіус. Звучить OK, але це може представляти 3D вектор або будь-що ще. Краще рішення може бути зробити ваш власний тип для представлення фігури. Скажімо, фігури, що може бути колом або прямокутником. Ось вона:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що це тепер? Думайте про це так. Конструктор значення <code>Circle</code> має три поля, що приймають числа з плаваючою крапкою. Так що коли ми пишемо конструктор значення, ми можемо опціонально додати деякі типи після нього, і ці типи визначають значення, що він міститиме. Тут перші два поля є координатами його центру, третя є радіусом. Конструктор значення <code>Rectangle</code> має чотири поля, що приймають плаваючу крапку. Перші два є координатами його верхнього лівого кута, та другі два є координати його нижнього правого кута.</p></div>
<div class="paragraph"><p>Тепер, коли я кажу поля, я насправді маю на увазі параметри. Конструктори значень насправді є функціями, що кінець кінцем повертають значення типу даних. Давайте поглянемо на сигнатури типів для ціх двох конструкторів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Circle</span>
<span class="kt">Circle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Rectangle</span>
<span class="kt">Rectangle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
</pre></div></div></div>
<div class="paragraph"><p>Круть, так що конструктори значень є функціями як всі інші. Хто б міг подумати? Давайте створимо функцію, що приймає фігуру та повертає її поверхню.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перша помітна річ тут є декларація типу. Вона каже, що функція приймає фігуру та повертає число. Ми не можемо написати декларацію типу <code>Circle -&gt; Float</code>, оскільки <code>Circle</code> не є типом, але <code>Shape</code> так. Це так само, як ми не можемо написати функцію з декларацією типу <code>True -&gt; Int</code>. Наступна річ, яку ми відмітимо тут, є те, що ми можемо робити порівняння шаблонів до конструкторів. Ми порівнювали шаблони проти конструкторів до цього (насправді весь час), коли ми порівнювали шаблони проти значень як <code>[]</code> або <code>False</code> або <code>5</code>, тількі ці значення не мали жодних полів. Ми тільки що написали конструктор, та потім прикріпили його поля до імен. Оскільки ми зацікавлені в радіусі, ми насправді не зацікавлені в перших двох полях, що кажуть нам, де знаходиться коло.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">10</span>
<span class="mf">314.15927</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">100</span> <span class="mi">100</span>
<span class="mf">10000.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау, це робить! Але якщо ви спробуєте просто надрукувати <code>Circle 10 20 5</code> в підказці, ми отримаємо помилку. Це тому, що Haskell не знає, як відображувати наші типи даних як рядок (доки). Згадайте, коли ми намагаємось друкувати значення в підказці, Haskell спочатку виконує функцію <code>show</code> для отримання рядкової репрезентації нашого значення, та потім він друкує це на термінал. Щоб зробити наш тип <code>Shape</code> частиною типокласа <code>Show</code>, ми модифікуємо його таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми доки не будемо заморочувати себе <code>deriving</code> дуже сильно. Давайте просто скажемо, що якщо ми додаємо <code>deriving (Show)</code> в кінці декларації даних, Haskell автомагічно робить цей тип частиною типокласу <code>Show</code>. Так що зараз ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="mi">50</span> <span class="mi">230</span> <span class="mi">60</span> <span class="mi">90</span>
<span class="kt">Rectangle</span> <span class="mf">50.0</span> <span class="mf">230.0</span> <span class="mf">60.0</span> <span class="mf">90.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Конструктори значень є функціями, так що ми можемо відображати їх та частково застосовувати їх, і все інше. Якщо ми бажаємо список концентричних з різними радіусами, ми можемо зробити це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">4.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Наш тип даних гарний, хоча він міг би бути кращим. Давайте створимо проміжний тип даних, що визначає точку в двовимірному просторі. Потім ми можемо використовувати це для створення наших фігур більш зрозумілим способом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що коли визначали точку, ми використали те саме ім'я для типу даних та значення конструктора. Це не має особливого значення, хоча це загально використовувати те саме ім'я що і тип, якщо це конструктор одного значення. Так що тепер <code>Circle</code> має два поля, один має тип <code>Point</code>, та інше тип <code>Float</code>. Це спрощує розуміння того, що є що. Те саме стосується і прямокутника. Ми маємо налаштувати нашу функцію <code>surface</code> для відзеркалення ціх змін.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що ми маємо змініти, це шаблони. Ми зневажили цілу точку в шаблоні кола. В шаблоні прямокутника ми просто використовували вкладене порівняння шаблонів, щоб отримати поля точок. Якщо ми б бажали посилатись на самі точки з якоїсь причини, ми могли б використати <code>as</code>-шаблони.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">100</span> <span class="mi">100</span><span class="p">))</span>
<span class="mf">10000.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
<span class="mf">1809.5574</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо функції, що рухає фігуру? Вона бере фігуру, величину руху по осі <code>x</code>, величину руху по осі <code>y</code>, та потім повертає нову фігуру, що має ті самі розміри, але розміщений в іншому місці.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">nudge</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="n">r</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y2</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить прямолінійно. Ми додаємо зсув до точок, що відповідають за позицію фігури.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">34</span> <span class="mi">34</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span>
<span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">39.0</span> <span class="mf">44.0</span><span class="p">)</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми не бажаємо мати справу напряму з точками, ми можемо зробити деякі додаткові функції, що створюють фігури деякого розміру з нульовими координатами, та потім рухати їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">baseCircle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseCircle</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span>

<span class="nf">baseRect</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseRect</span> <span class="n">width</span> <span class="n">height</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">width</span> <span class="n">height</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="n">baseRect</span> <span class="mi">40</span> <span class="mi">100</span><span class="p">)</span> <span class="mi">60</span> <span class="mi">23</span>
<span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">60.0</span> <span class="mf">23.0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">100.0</span> <span class="mf">123.0</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, ви можете експортувати ваші типи даних в ваші модулі. Щоб зробити це, просто напишіть ваші типи разом з функціями, що ви експортуємо, та потім додайте деякі дужки, і в них вкажіть конструктори значень, що ви бажаєте експортувати для них, розділені комами. Якщо ви бажаєте експортувати всі конструктори значень для даного типу, просто напишіть <code>..</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте експортувати функції та типи, що ми визначили тут, в модулі, ми можемо почати, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Shapes</span>
<span class="p">(</span> <span class="kt">Point</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="kt">Shape</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="nf">surface</span>
<span class="p">,</span> <span class="nf">nudge</span>
<span class="p">,</span> <span class="nf">baseCircle</span>
<span class="p">,</span> <span class="nf">baseRect</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div></div></div>
<div class="paragraph"><p>Роблячи <code>Shape(..)</code>, ми експортуємо всі конструктори значень для <code>Shape</code>, і це означає, що коли дехто імпортує наш модуль, він зможе створювати фігури, використовуючи конструктори значень <code>Rectangle</code> та <code>Circle</code>. Це те саме, що написати <code>Shape (Rectangle, Circle)</code>.</p></div>
<div class="paragraph"><p>Ми також можемо вирішити не експортувати жодних конструкторів значень для <code>Shape</code>, просто написавши <code>Shape</code> в твердженні <code>export</code>. Таким чином, той, хто імпортує наш модуль, зможе створювати фігури через використання додаткових функцій <code>baseCircle</code> та <code>baseRect</code>. <code>Data.Map</code> використовує цей підхід. Ви не можете створити мапу, зробивши <code>Map.Map [(1,2),(3,4)]</code>, оскільки він не експортує конструктор значень. Однак ви можете створити відображення через використання однієї з додаткових функцій як <code>Map.fromList</code>. Згадайте,що конструктори є тільки функціями, що приймають поля як параметри, та повертає значення деякого типу (як <code>Shape</code>) в якості результату. Так що коли ми обираємо не експортувати їх, ми просто не даємо тому, хто імпортує наш модуль, використосувати ці функції, але якщо деякі інші функції, що експортуються, повертають тип, ми можемо використовувати їх для створення значень наших власних типів даних.</p></div>
<div class="paragraph"><p>Не-експортування конструкторів значень типів даних робить їх більш абстрактними в той спосіб, що ми приховуємо їх реалізацію. Також той, хто користується нашими типами, не зможе робити порівняння шаблонів до конструкторів значень.</p></div>
<div class="sect3">
<h4 id="__">Синтаксис запису</h4>
<div class="paragraph"><p><span class="image">
<img src="images/record.png" alt="images/record.png" />
</span>
OK, ми отримали завдання створити тип даних, що описував би осообу. Інформація, що ми бажаємо зберігати щодо особи, наступна: ім'я, фамілія, вік, зріст, номер телефону та улюблений сорт морозива. Не знаю як щодо вас, але це все, що я будь-коли бажав знати про людину. Давайте дамо цьому хід!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Окей. Перше поле є першим ім'ям, друге фамілія, третє вік і так далі. Давайте створимо особу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">guy</span>
<span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дещо круте, але трохи не читається. Що, коли ми бажаємо створити функцію для отримання окремої інформації про особу? Функцію, що отримує ім'я, фамілію, вік, тощо. Гаразд, ми маємо визначити її таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">firstName</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">firstname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>

<span class="nf">lastName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lastName</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">lastname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>

<span class="nf">age</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">age</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">age</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">age</span>

<span class="nf">height</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">height</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">height</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">height</span>

<span class="nf">phoneNumber</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">phoneNumber</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">number</span>

<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">flavor</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">flavor</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flavor</span>
</pre></div></div></div>
<div class="paragraph"><p>Хух! Я напевне не був радий написати це! Не зважаючи на плутанину і СКУКУ під час написання, цей метод робить.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">firstName</span> <span class="n">guy</span>
<span class="s">&quot;Buddy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">height</span> <span class="n">guy</span>
<span class="mf">184.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flavor</span> <span class="n">guy</span>
<span class="s">&quot;Chocolate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Має бути кращий спосіб, скажете ви! Ні, немає, пробачайте.</p></div>
<div class="paragraph"><p>Я шуткую, він є. Гигиги! Творці Haskell були досить розумні та передбачили цей сценарій. Вони включили альтернативний спосіб для написання типів даних. Ось як ми можемо досягти ту ж функціональність за допомогою синтаксису запису.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">,</span> <span class="n">height</span> <span class="ow">::</span> <span class="kt">Float</span>
                     <span class="p">,</span> <span class="n">phoneNumber</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">flavor</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що замість називати типи полів один за одним, та розділяти їх проміжками ми використовуємо фігурні дужки. Спочатку ми пишемо ім'я поля, наприклад <code>firstName</code>, та потім ми пишемо дві двокрапки <code>::</code> (що також називається <code>Paamayim Nekudotayim</code>, ахаха - <em>насправді це саме подвійна двокрапка на івриті, назва з'явилась вперше в PHP3 як кваліфікатор поля зору. прим.перекл.</em>), і потім ми задаємо тип. Результуючий тип даних саме такий. Головна перевага цього в тому, що він створює функції, що шукають поля в типі даних. Через використання синтаксису полів для створення цього типу даних, Haskell автоматично створює ці функції: <code>firstName</code>, <code>lastName</code>, <code>age</code>, <code>height</code>, <code>phoneNumber</code> та <code>flavor</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flavor</span>
<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">firstName</span>
<span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Є інша вигода використовувати синтаксис записів. Коли ви наслідуєте  <code>Show</code> для типа, він відображує його по різному, якщо ми використоауємо синтаксис запису при визначенні і створенні екземпляру типу. Скажімо ми маємо тип, що представляє машину. Ми бажаємо відслідковувати компанію, що виробляє її, назву моделі, та рік її виробництва. Дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми використаємо синтаксис запису, ми можемо створити нову машину таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="mi">1967</span><span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми створюємо машину, ми не обов'язково покладаємо поля в певному порядку, доки ми вказуємо їх всі. Але якщо ми не використовуємо синтаксис запису, ми маємо вказувати їх по порядку.</p></div>
<div class="paragraph"><p>Використовуйте синтаксис записів, коли конструктор має декілька полів, і не очевидне, яке поле є яке. Якщо ми створюємо тип даних для тривимірного вектора, роблячи <code>data Vector = Vector Int Int Int</code>, є досить очевидним, що поля є компонентами вектора. Але в наших типах <code>Person</code> та <code>Car</code> це не буде таким очевидним, і ми отримаємо велику вигоду, використовуючи синтаксис запису.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___2">Параметри типів</h3>
<div class="paragraph"><p>Конструктор значення може приймати деякі параметри значення, та потім продукувати нове значення. Наприклад, конструктор <code>Car</code> бере три значення і продукує значення машини. В подібний спосіб конструктори типів можуть приймати типи та продукувати нові типи. Спочатку це може виглядати трохи абстрактним, але це не так складно. Якщо ви знайомі з шаблонами в C++, ви побачите деякі паралелі. Щоб отримати ясну картину як діють параметри типів насправді, давайте поглянемо, як реалізовані типи, з якими ми вже зустрічались.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/yeti.png" alt="images/yeti.png" />
</span>
Тут <code>a</code> є параметром типу. І оскільки задіяно параметр типу, ми викликаємо конструктор типу <code>Maybe</code>. В залежності від того, який тип даних ми бажаємо містити, коли це не <code>Nothing</code>, цей конструктор може кінець кінцем продукувати тип <code>Maybe Int</code>, <code>Maybe Car</code>, <code>Maybe String</code>, тощо. Жодне значення не може мати тип просто <code>Maybe</code>, оскільки це не тип як такий, це конструктор типів. Щоб це стало реальним типом, частиною якого може бути значення, він має заповнити всі свої параметри типів.</p></div>
<div class="paragraph"><p>Так що коли ми передамо <code>Char</code> як параметр типів до <code>Maybe</code>, ми отримаємо тип <code>Maybe Char</code>. Значення <code>Just 'a'</code> має тип <code>Maybe Char</code>, як для прикладу.</p></div>
<div class="paragraph"><p>Ви могли цього не знати, але ми використовували тип, що мав параметр типу, перед тим як ми використовували <code>Maybe</code>. Цей тип є тип списку. Хоча тут задієний деякий синтаксичний цукор, тип списку приймає параметр для утворення певного типу. Значення можуть мати тип <code>[Int]</code>, тип <code>[Char]</code>, тип <code>[[String]]</code>, але ви не можете мати значення, що має просто тип <code>[]</code>.</p></div>
<div class="paragraph"><p>Давайте пограємось з типом <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="kt">Just</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри типів корисні, оскільки ми можемо робити різні типи з їх допомогою, в залежності від того, який тип ми бажаємо щоб містився в нашому типі даних. Коли ми робимо <code>:t Just "Haha"</code>, рушій виводу типів здогадується, що тип має бути <code>Maybe [Char]</code>, бо якщо <code>a</code> в  <code>Just</code> є рядком, тоді <code>a</code> в <code>Maybe</code> також має бути рядком.</p></div>
<div class="paragraph"><p>Зауважте, що тип <code>Nothing</code> є <code>Maybe a</code>. Його тип поліморфний. Якщо деяка функція потребує <code>Maybe Int</code> в якості параметра, ми можемо дати їй <code>Nothing</code>, оскільки <code>Nothing</code> все одно не містить значення, так що воно не має значення. Тип <code>Maybe a</code> може діяти як <code>Maybe Int</code> в разі потреби, так само, як <code>5</code> може діяти як <code>Int</code> або <code>Double</code>. Подібним чином тип порожнього списку є <code>[a]</code>. Порожній список може діяти як список будь чого. Ось чому ми можемо робити <code>[1,2,3] ++ []</code> та <code>["ha","ha","ha"] ++ []</code>.</p></div>
<div class="paragraph"><p>Використання параметрів типів дуже корисні, але тільки якщо їх використання має сенс. Зазвичай ми використовуємо їх, коли наш тип даних буде робити незалежно від типа значення, що буде міститись в ньому. Якщо наш тип діє як свого роду ящик, буде гарно використати його. Ми можемо змінити наш тип даних <code>Car</code> з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span>
               <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>До такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="n">a</span>
                     <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="n">b</span>
                     <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="n">c</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але чи буде з цього користь? Відповідь така: мабуть ні, бо ми лише скінчимо визначенням функцій, що роблять на типі <code>Car String String Int</code>. Наприклад, беручи наше перше визначення <code>Car</code>, ми можемо створити функцію, що показує властивості машини в вигляді невеликого гарного тексту.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">tellCar</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stang</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="n">stang</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Мила мала функція! Декларація типу мила і вона робить гарно. Тепер що буде, коли б <code>Car</code> був <code>Car a b c</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">tellCar</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми б мали примушувати цю функцію приймати тип <code>Car</code> <code>(Show a) =&gt; Car String String a</code>. Ви бачите що ця сигнатура типу більш ускладнена, і дійсно може бути корисною, коли б могли використовувати любий тип, що є примірником типокласу <code>Show</code>, як тип для <code>c</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in 1967&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span><span class="p">)</span>
<span class="s">&quot;This Ford Mustang was made in </span><span class="se">\&quot;</span><span class="s">nineteen sixty seven</span><span class="se">\&quot;</span><span class="s">&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="s">&quot;nineteen sixty seven&quot;</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/meekrat.png" alt="images/meekrat.png" />
</span>
Однак в реальному житті ми будемо в більшості випадків використовувати <code>Car String String Int</code>, так що параметризація типів типу <code>Car</code> насправді не варта цього. Ми звичайно використовуємо параметри типів, коли тип, що міститься в різних конструкторах типу даних насправді не такий важливий для роботи типу. Список речей є список речей, і немає значення, якого типу є ці речі - він все одне буде робити. Якщо ви бажаєте отримати суму чисел, ми можемо вказати візніше в функції суми, що нам потрібен список чисел. Те саме і щодо <code>Maybe</code>. <code>Maybe</code> представляє опцію або не мати нічого, або мати одне щось. Не має значення, якого типу є це дещо.</p></div>
<div class="paragraph"><p>Інший тип параметризованого типу є те, з чим ми вже стикались, і це <code>Map k v</code> з <code>Data.Map</code>. <code>k</code> є типом ключів в мапі, і <code>v</code> є типом значень. Це гарний приклад того, де параметри типів дуже корисні. Маючі параметризовані мапи дозволяє нам робити відображення з любого типу на інший тип, доки тип ключа є частиною типокласу <code>Ord</code>. Якщо ми визначили тип відображення, ми можемо додати обмеження типокласу в декларації даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак існує дуже сильна домовленість в Haskell ніколи не додавати обмеження типокласів в декларації даних. Чому? Гаразд, бо ми не отримаємо багато вигоди, але ми закінчимо написанням додаткових класових обмежень, навіть якщо не потребуємо їх. Якщо ми покладемо, або не покладемо обмеження <code>Ord k</code> в декларацію даних для <code>Map k v</code>, ми матимемо покладати обмеження в функції, що очікують, що ключі в мапі можуть бути впорядковані. Але якщо ми не покладемо обмеження в декларацію даних, ми не маємо ставити <code>(Ord k) =&gt;</code> в декларації типу функцій, що не переймаються через впорядкованість ключів. Прикладом такої функції є <code>toList</code>, що просто бере відображення, та конвертує його в асоціативний список. Її сигнатура типу є <code>toList ::Map k a -&gt; [(k, a)]</code>. Якщо <code>Map k v</code> має обмеження типу в своїй декларації типу, тип для <code>toList</code> має бути <code>toList ::(Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, навіть якщо функція не робить жодних порівнянь ключів за порядком.</p></div>
<div class="paragraph"><p>Так що не покладайте обмеження типу в визначення даних, навіть якщо це виглядає як маюче сенс, бо ви матимете покладати їх в декларації типів функцій в жодному випадку.</p></div>
<div class="paragraph"><p>Давайте реалізуємо тип 3D вектора, і додамо до нього деякі операції. Ми будемо використовувати параметризований тип, бо якщо він звичайно буде містити числові типи, він все одно буде підтримувати декілька з них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">vplus</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">l</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="n">n</span><span class="p">)</span>

<span class="nf">vectMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="n">m</span> <span class="ow">=</span> <span class="kt">Vector</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">j</span><span class="o">*</span><span class="n">m</span><span class="p">)</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="n">m</span><span class="p">)</span>

<span class="nf">scalarMult</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="kt">Vector</span> <span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span>
<span class="p">(</span><span class="kt">Vector</span> <span class="n">i</span> <span class="n">j</span> <span class="n">k</span><span class="p">)</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="n">l</span> <span class="n">m</span> <span class="n">n</span><span class="p">)</span> <span class="ow">=</span> <span class="n">i</span><span class="o">*</span><span class="n">l</span> <span class="o">+</span> <span class="n">j</span><span class="o">*</span><span class="n">m</span> <span class="o">+</span> <span class="n">k</span><span class="o">*</span><span class="n">n</span>
</pre></div></div></div>
<div class="paragraph"><p><code>vplus</code> існує для додавання разом двох векторів. Два вектори додаються просто через додавання своїх відповідних компонент. <code>scalarMult</code> є для скалярнрного множення двох векторів, і <code>vectMult</code> для множення вектора на скаляр. Ці методи можуть оперувати на типах <code>Vector Int</code>, <code>Vector Integer</code>, <code>Vector Float</code>, та будь-чого, доки  <code>a</code> в <code>Vector a</code> належить з типокласу <code>Num</code>. Також, якщо ви перевірите декларації типів для ціх функцій, ви побачите, що вони можуть оперувати тільки на векторах одного типу, і задіяні числа також мають бути одного типу, що міститься в векторах. Зауважте, що ми не покладаємо обмеження класу <code>Num</code> в декларацію даних, бо ми  все одно повторюємо його в функціях.</p></div>
<div class="paragraph"><p>І ще раз: дуже важливо розрізняти конструктор типу і конструктор значення. При декларації типу даних, частина перед <code>=</code> є конструктором типу, і конструктори після нього (можливо розділені <code>|</code>) є конструкторами значення. Беручи функцію типу <code>Vector t t t -&gt; Vector t t t -&gt; t</code> буде помилкою, оскільки ми маємо покладати типи в декларації типів, і конструктор типу вектора приймає тільки один параметр, тоді як конструктор значення бере три. Давайте пограємось з нашими векторами.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">7</span> <span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">8</span> <span class="p">`</span><span class="n">vplus</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="kt">Vector</span> <span class="mi">12</span> <span class="mi">9</span> <span class="mi">19</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">7</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="mi">10</span>
<span class="kt">Vector</span> <span class="mi">30</span> <span class="mi">90</span> <span class="mi">70</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mf">9.0</span> <span class="mf">2.0</span> <span class="mf">4.0</span>
<span class="mf">74.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Vector</span> <span class="mi">2</span> <span class="mi">9</span> <span class="mi">3</span> <span class="p">`</span><span class="n">vectMult</span><span class="p">`</span> <span class="p">(</span><span class="kt">Vector</span> <span class="mi">4</span> <span class="mi">9</span> <span class="mi">5</span> <span class="p">`</span><span class="n">scalarMult</span><span class="p">`</span> <span class="kt">Vector</span> <span class="mi">9</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
<span class="kt">Vector</span> <span class="mi">148</span> <span class="mi">666</span> <span class="mi">222</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___3">Виведені примірники</h3>
<div class="paragraph"><p><span class="image">
<img src="images/gob.png" alt="images/gob.png" />
</span>
В розділі Типокласи 101 ми пояснили основи типокласів. Ми пояснили, що типокласи є різновидом інтерфейса, що визначає деяку поведінку. Тип може бути зроблений примірником типокласу, якщо він підтримує цю поведінку. Приклад: тип <code>Int</code> є примірником типокласу <code>Eq</code>, оскільки типоклас <code>Eq</code> визначає поведінку для речей, що можуть бути рівними. І оскільки можливо порівняти цілі, <code>Int</code> є частиною типокласу <code>Eq</code>. Реальна користь іде від функцій, що діють як інтерфейс для <code>Eq</code>, а саме <code>==</code> та <code>/=</code>. Якщо тип є частиною типокласу <code>Eq</code>, ми можемо використовувати функції <code>==</code> зі значенням цього типу. Ось чому вирази як <code>4 == 4</code> та <code>"foo" /= "bar"</code> проходять перевірку типів.</p></div>
<div class="paragraph"><p>Ми також зазначали, що вони часто плутаються з класами в мовах як Java, Python, C++ і тому подібних, що потім бентежить багато людей. В ціх мовах класи є калькою, з якої потім створюються об'єкти, що мають стан та можуть виконувати деякі дії. Типокласи більше подібні до інтерфейсів. Ми не створюємо дані з типокласів. Замість цього ми створюємо наші типи даних, і потім ми думаємо, як вони можуть діяти. Якщо вони можуть діяти як дещо, що можливо порівняти, ми робимо його примірником типокласа <code>Eq</code>. Якщо воно діє як дещо, що можливо впорядкувати, ми робимо його примірником типокласу <code>Ord</code>.</p></div>
<div class="paragraph"><p>В наступному розділі ми поглянемо, як ми можемо вручну зробити наші типи примірниками типокласів, через реалізацію функцій, визначених в типокласах. Але прямо зараз давайте поглянемо, як Haskell може автоматично зробити наш тип примірником наступних типокласів: <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code>, <code>Read</code>. Haskell може вивести поведінку наших типів в ціх контекстах, якщо ми використовуємо ключове слово <code>deriving</code> при створенні нашого типу даних.</p></div>
<div class="paragraph"><p>Розглянемо цей тип даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Він описує особу. Уявімо, що жодні дві людини не мають ту саму комбінацію імені, фамілії та віку. Тепер, якщо ми маємо записи про двох людей, чи матиме сенс перевірити, що вони представляють ту саму особу? Напевне що так. Ми можемо спробувати порівняти їх, щоб побачити, чи воні однакові чи ні. Ось чому має сенс для цього типу бути частиною типокласу <code>Eq</code>. Ми виведемо примірник.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми виводимо примірник <code>Eq</code> для типа, і потім намагаємось порівняти два значення цього типу за допомогою <code>==</code> або <code>/=</code>, Haskell подивиться, чи співпадають конструктори значень (в нас тільки один конструктор значень), і потім він перевірить, що всі дані, які містяться всередині співпадають, через перевірку пар полів за допомогою <code>==</code>. Однак є одна пастка: типи всіх полів також мають бути частиною типокласу <code>Eq</code>. Але оскільки обоє, <code>String</code> та <code>Int</code> - так, то в нас все гаразд. Давайте перевіримо наш примірник <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adRock</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Horovitz&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">41</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mca</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Adam&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Yauch&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">44</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mca</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">adRock</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="o">==</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, оскільки <code>Person</code> тепер в <code>Eq</code>, ми можемо використовувати його для всіх функцій, що мають обмеження класу <code>Eq</code> в своїй сигнатурі типу, таких як <code>elem</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">beastieBoys</span> <span class="ow">=</span> <span class="p">[</span><span class="n">mca</span><span class="p">,</span> <span class="n">adRock</span><span class="p">,</span> <span class="n">mikeD</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">beastieBoys</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Типокласи <code>Show</code> та <code>Read</code> призначені для речей, що можуть бути перетворені на або з рядків, відповідно. Так само, як для <code>Eq</code>, якщо конструктор типу має поля, їх тип має бути частиною <code>Show</code> або <code>Read</code>, якщо ми бажаємо зробити наш тип їх примірником. Давайте зробимо наш тип даних <code>Person</code> частиною також <code>Show</code> та <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми можемо друкувати дані про особу на терміналі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">mikeD</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">mikeD</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;mikeD is: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">mikeD</span>
<span class="s">&quot;mikeD is: Person {firstName = </span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName = </span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли б ми спробували друкувати особу на термінал, перед тим, як зробити тип даних <code>Person</code> частиною <code>Show</code>, Haskell би поскаржився на нас, кажучи що не може представити особу як рядок. Але тепер, коли ми вивели примірник <code>Show</code> для цього, він вже знає.</p></div>
<div class="paragraph"><p><code>Read</code> є достатньо повною протилежністю до типокласу <code>Show</code>. <code>Show</code> служить перетворенню значень нашого типу до рядка, <code>Read</code> для перетворення рядків до значень нашого типу. Однак пам'ятайте, коли ми використовуємо функцію читання, ми маємо використовувати явну анотацію типу, щоб сказати Haskell, який тип ми бажаємо отримати як результат. Якщо ми не зробимо бажаний тип явним, Haskell не знатиме, який тип ми бажаємо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="ow">::</span> <span class="kt">Person</span>
<span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Michael&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Diamond&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">43</span><span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми використовуємо результат нашого читання пізніше в спосіб, що Haskell зможе вивести, що прочитане має використовуватись як особа, ми не повинні використовувати анотацію типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Person {firstName =</span><span class="se">\&quot;</span><span class="s">Michael</span><span class="se">\&quot;</span><span class="s">, lastName =</span><span class="se">\&quot;</span><span class="s">Diamond</span><span class="se">\&quot;</span><span class="s">, age = 43}&quot;</span> <span class="o">==</span> <span class="n">mikeD</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми також можемо читати параметризовані типи, але ми повинні заповнити параметри типів. Так що ми не можемо робити <code>read "Just 't'" ::Maybe a</code>, але можемо зробити <code>read "Just 't'" ::Maybe Char</code>.</p></div>
<div class="paragraph"><p>Ми можемо вивести примірники для типокласу <code>Ord</code>, що є для типів, значення яких можна впорядкувати. Якщо ми порівняємо два значення того самого типу, що були створені з використанням різних конструкторів, значення, що було створене за допомогою конструктора, що був визначений раніше, вважається меньшим. Наприклад, розглянемо тип <code>Bool</code>, що має значення або <code>False</code> або <code>True</code>. Для наших цілей побачити їх поведінку при порівнянні, будемо вважати що вони реалізовані таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Ord</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки конструктор значення <code>False</code> вказаний першим, і конструктор значення <code>True</code> вказаний після цього, ми розглядаємо <code>True</code> як більше за <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">False</span>
<span class="kt">GT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&gt;</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&lt;</span> <span class="kt">False</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>В типі даних <code>Maybe</code> конструктор значення <code>Nothing</code> вказаний перед конструктором <code>Just</code>, так що <code>Nothing</code> завжди меньший, ніж значення <code>Just</code> дещо, навіть як це дещо мінус мільярд трильйонів. Але якщо ми порівняємо два <code>Just</code> значення, тоді відбудеться порівняння того, що в них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&lt;</span> <span class="kt">Just</span> <span class="mi">100</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Nothing</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="p">(</span><span class="o">-</span><span class="mi">49999</span><span class="p">)</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">3</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Just</span> <span class="mi">2</span>
<span class="kt">GT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">100</span> <span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">50</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Але ми не можемо робити дещо як <code>Just (*3) &gt; Just (*2)</code>, оскільки <code>(*3)</code> та <code>(*2)</code> є функціями, що не є примірниками <code>Ord</code>.</p></div>
<div class="paragraph"><p>Ми можемо просто використовувати алгебраїчні типи даних для створення переліків, і типокласи <code>Enum</code> та <code>Bounded</code> допомагають нам з цім. Розглянемо наступний тип даних:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки всі конструктори даних мають нульову арність (не мають параметрів, тобто полів), ми можемо зробити його типокласу <code>Enum</code>. Типоклас <code>Enum</code> призначений для речей, що мають попередників та наступників. Ми також можемо зробити його частиною типокласу <code>Bounded</code>, що існує для речей, що мають найменьше можливе значення та найбільше можливе значення. І доки ми поряд з цім, давайте також зробимо його примірником всіх інших виведених типокласів, і побачимо, що ми можемо з цім зробити.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Day</span> <span class="ow">=</span> <span class="kt">Monday</span> <span class="o">|</span> <span class="kt">Tuesday</span> <span class="o">|</span> <span class="kt">Wednesday</span> <span class="o">|</span> <span class="kt">Thursday</span> <span class="o">|</span> <span class="kt">Friday</span> <span class="o">|</span> <span class="kt">Saturday</span> <span class="o">|</span> <span class="kt">Sunday</span>
           <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Bounded</span><span class="p">,</span> <span class="kt">Enum</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки це є частиною типокласів <code>Show</code> та <code>Read</code>, ми можемо перетворити значення цього типу на та з рядків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Wednesday</span>
<span class="kt">Wednesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">Wednesday</span>
<span class="s">&quot;Wednesday&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;Saturday&quot;</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Saturday</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки це є частиною типокласу <code>Eq</code> та <code>Ord</code>, ми можемо порівняти або перевірити дні на рівність.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Sunday</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">==</span> <span class="kt">Saturday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Saturday</span> <span class="o">&gt;</span> <span class="kt">Friday</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Monday</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="kt">Wednesday</span>
<span class="kt">LT</span>
</pre></div></div></div>
<div class="paragraph"><p>Це також є частиною <code>Bounded</code>, так що ми можемо отримати найменьший та найбільший день.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Monday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Day</span>
<span class="kt">Sunday</span>
</pre></div></div></div>
<div class="paragraph"><p>Це також є примірником <code>Enum</code>. Ми можемо отримати попередні та наступні дні, та ми можемо створити диапазони з них!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="kt">Monday</span>
<span class="kt">Tuesday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">pred</span> <span class="kt">Saturday</span>
<span class="kt">Friday</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Thursday</span> <span class="o">..</span> <span class="kt">Sunday</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">minBound</span> <span class="o">..</span> <span class="n">maxBound</span><span class="p">]</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Day</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Monday</span><span class="p">,</span><span class="kt">Tuesday</span><span class="p">,</span><span class="kt">Wednesday</span><span class="p">,</span><span class="kt">Thursday</span><span class="p">,</span><span class="kt">Friday</span><span class="p">,</span><span class="kt">Saturday</span><span class="p">,</span><span class="kt">Sunday</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить чудово.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Синоніми типів</h3>
<div class="paragraph"><p>До цього ми згадували, що при написанні типів <code>[Char]</code> та <code>String</code> еквівалентні та взаємозамінні. Це зроблено за допомогою синонимів типів. Синоніми типів насправді нічого не роблять як такі, вони тільки надають деяким типам різні імена, так що вони мають більше сенсу при читанні коду або документації. Ось як стандартна бібліотека визначає <code>String</code> як синонім для <code>[Char]</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">String</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/chicken.png" alt="images/chicken.png" />
</span>
Ми вводили ключове слово <code>type</code>. Ключове слово може декого ввесвти в оману, бо насправді ми не створюємо нічого нового (ми робимо це за допомогою ключового слова <code>data</code>), але ми лише створюємо синонім для вже існуючого типу.</p></div>
<div class="paragraph"><p>Якщо ми створимо функцію, що конвертує рядок в верхній реєстр, та назвемо її <code>toUpperString</code> або якось ще, ми можемо надати їй декларацію типу <code>toUpperString ::[Char] -&gt; [Char]</code> або <code>toUpperString ::String -&gt; String</code>. Обоє з них будуть по суті одне і те ж, тільки останню приємнише читати.</p></div>
<div class="paragraph"><p>Коли ми мали справу з модулем <code>Data.Map</code>, ми спочатку представили телефонний довідник за допомогою асоціативного списку, перед перетворенням його на мапу. Як ми вже з'ясували, асоціативний список є списком пар ключ-значення. Давайте подивимось на телефонний довідник, що в нас є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
<span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми бачимо, що тип довідника <code>phoneBook</code> є <code>[(String,String)]</code>. Це каже нам, що це асоціативний список, що відображує рядки на рядки, але нічого більше. Давайте створимо синонім типу, щоб передати дещо більше інформації в декларації типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер декларація типу для нашого довідника може бути <code>phoneBook ::PhoneBook</code>. Давайте створимо синонім типу також і для <code>String</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">PhoneNumber</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">Name</span> <span class="ow">=</span> <span class="kt">String</span>
<span class="kr">type</span> <span class="kt">PhoneBook</span> <span class="ow">=</span> <span class="p">[(</span><span class="kt">Name</span><span class="p">,</span><span class="kt">PhoneNumber</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Надати синонім типу для <code>String</code> є дещо, що програмісти Haskell роблять, коли вони бажають передати більше інформації щодо того, що будуть робити рядки в їх функціях, і що вони представляють.</p></div>
<div class="paragraph"><p>Так що тепер, коли ми реалізуємо функцію, що приймає ім'я і номер, і перевіряємо, що комбінація імені і номера є в нашому довіднику, ми можемо надати їй дуже гарну і описову декларацію типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">inPhoneBook</span> <span class="ow">::</span> <span class="kt">Name</span> <span class="ow">-&gt;</span> <span class="kt">PhoneNumber</span> <span class="ow">-&gt;</span> <span class="kt">PhoneBook</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">inPhoneBook</span> <span class="n">name</span> <span class="n">pnumber</span> <span class="n">pbook</span> <span class="ow">=</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">pnumber</span><span class="p">)</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="n">pbook</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми оберемо не використовувати синоніми, наша функція мала б тип <code>String -&gt; String -&gt; [(String,String)] -&gt; Bool</code>. В цьому випадку декларація типу, що користується перевагами синонимів, простіша для розуміння. Але з ними не треба передати куті меду. Ми вводимо синоніми типів або для опису, що саме представляє тип в наших функціях (і таким чином наші декларації типів стають кращою документацією), або коли дещо має задовгий тип, що представляє багато чого (як <code>[(String,String)]</code>), але являє собою дещо більш специфічне в контексті нашої функції.</p></div>
<div class="paragraph"><p>Синоніми типів також можуть бути параметризованими. Якщо ви бажаєте мати тип, що представляє асоціативний список, але також бажаєте зробити його загальним, так щоб ви могли використовувати любі типи для ключів та значень, ми можемо зробити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">AssocList</span> <span class="n">k</span> <span class="n">v</span> <span class="ow">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер функція, що отримує значення по ключу в асоціативному списку може мати тип <code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>. <code>AssocList</code> є конструктором типу, що приймає два типи і продукує конкретний тип, як наприклад <code>AssocList Int String</code>.</p></div>
<div class="paragraph"><p>Фонзі каже: Йо! Коли я казав про конкретні типи, я мав на увазі повністю застосовані типи, як <code>Map Int String</code>, або якщо ми мали справу з однією з тих поліморфних функцій, <code>[a]</code> або <code>(Ord a) =&gt; Maybe a</code>. І подібно до цього, я і хлопці кажуть, що <code>Maybe</code> є типом, але ми не маємо це на увазі, бо кожний ідіот знає, що <code>Maybe</code> є конструктором типів. Коли я застосовую додатковий тип до <code>Maybe</code>, як <code>Maybe String</code>, тоді я маю конкретний тип. Ви знаєте, що значення можуть мати тільки тип якщо він конкретний! Так що підсумовуючи - живіть швидко, любіть кріпко і не дозволяйте комусь іншому використовувати ваш гребінець!</p></div>
<div class="paragraph"><p>Так само, як ми можемо частково застосувати функції, так що ми отримуємо нові функції, так само ми можемо вказати конструктор типів з недостатньою кількістю параметрів типів, та отримати новий конструктор типів. Якщо ми бажаємо тип, що представляє мапу (від <code>Data.Map</code>) від цілих до чогось іншого, ми однаково можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntMap</span> <span class="n">v</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span> <span class="n">v</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ми можемо зробити це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">type</span> <span class="kt">IntMap</span> <span class="ow">=</span> <span class="kt">Map</span> <span class="kt">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>В жодному разі конструктор типів <code>IntMap</code> приймає один параметр, і це тип того, на що будуть вказувати наші цілі.</p></div>
<div class="paragraph"><p>О так. Якщо ви бажаєте спробувати і реалізувати це, ви можливо збираєтесь зробити кваліфікований імпорт <code>Data.Map</code>. Коли ви робите кваліфікований імпорт, конструктори типів також повинні мати перед собою ім'я модуля. Так що ви напишете <code>type IntMap = Map.Map Int</code>. Переконайтесь, що ви дійсно розумієте різницю між конструкторами типів і конструкторами значень. Тільки через те, що ми зробили синонім типу з назвою <code>IntMap</code> або <code>AssocList</code>, це не означає, що ми можемо робити речі, як <code>AssocList [(1,2),(4,5),(7,9)]</code>. Все що це означає, що ми можемо посилатись до його типу з використанням інших імен. Ми можемо робити <code>[(1,2),(3,5),(8,9)] ::AssocList Int Int</code>, що буде очікувати тип <code>Int</code> всередині, але ми можемо все ще використовувати цей список якби це був звичайний список з цілими всередині. Синоніми типів (і взагалі типи) можуть бути використані в частині типів в Haskell. Ми в типовій частині Haskell коли ми визначаємо нові типи (тобто в визначеннях даних та типів), або коли ми знаходимось за <code>::</code>. <code>::</code> є деккларація або анотація типу.</p></div>
<div class="paragraph"><p>Інший крутий тип даних, що приймає два типи як параметри, є тип <code>Either a b</code>. Грубо кажучи він визначений так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Він має два конструктори значень. Якщо використовується <code>Left</code>, тоді його компоненти типу <code>a</code>, і коли використовується <code>Right</code>, тоді його вміст типу <code>b</code>. Так що ми можемо використовувати цей тип для інкапсуляції значення одного або іншого типу, і тоді, коли ми отримуємо значення <code>Either a b</code>, ми звичайно порівнюємо з шаблоном на обох, <code>Left</code> та <code>Right</code>, і ми відрізняємо речі на основі того, який з двох типів він має.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Right</span> <span class="mi">20</span>
<span class="kt">Right</span> <span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="kt">Left</span> <span class="s">&quot;w00t&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Right</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">Right</span> <span class="sc">&#39;a&#39;</span> <span class="ow">::</span><span class="kt">Either</span> <span class="n">a</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Left</span> <span class="kt">True</span>
<span class="kt">Left</span> <span class="kt">True</span> <span class="ow">::</span><span class="kt">Either</span> <span class="kt">Bool</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Досі ми бачили, що <code>Maybe</code> здебільшого використовувався для представлення обчислень, що могли або схибити, або ні. Але іноді <code>Maybe</code> не досить гарний, оскільки <code>Nothing</code> насправді не передає досить інформації, окрім того що дещо схибило. Це добре для функцій, що можуть схибити тільки в один спосіб, або якщо нас не цікавить, як вони схибили. Пошук <code>Data.Map</code> буде невдалий тільки якщо ключ не буде знайдений в мапі, так що ми точно знаємо, що скоїлось. Однак якщо ми зацікавлені, як саме функція схибила та чому, ми зазвичай використовуємо результат типу <code>Either a b</code>, де <code>a</code> є деяким різновидом типу, що може сказати дещо про можливий збій, та <code>b</code> є типом вдалого обчислення. Таким чином помилки використовують конструктор значення <code>Left</code>, тоді як результати використовують <code>Right</code>.</p></div>
<div class="paragraph"><p>Приклад: вища школа має роздягальні, так що студенти мають місце для наліплювання своїх плакатів Guns&#8217;n'Roses. Кожна комірка має свою кодову комбінацію. Коли студент бажає нову роздягальну, він каже наглядачеві роздягальні, який номер він бажає, і той дає йому код. Але якщо хтось вже використовує цю комірку, він не може скзати код від тієї комірки, і вони мають обрати інший. Ми будемо використовувати мапу від <code>Data.Map</code> для представлення комірок. Мапа буде відображати номери комірок на пару, того чи комірка вже зайнята або ні, і код комірки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>

<span class="kr">data</span> <span class="kt">LockerState</span> <span class="ow">=</span> <span class="kt">Taken</span> <span class="o">|</span> <span class="kt">Free</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>

<span class="kr">type</span> <span class="kt">Code</span> <span class="ow">=</span> <span class="kt">String</span>

<span class="kr">type</span> <span class="kt">LockerMap</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Int</span> <span class="p">(</span><span class="kt">LockerState</span><span class="p">,</span> <span class="kt">Code</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Прості речі. Ми ввели новий тип даних для представлення того, чи комірка вільна чи ні,  і ми створили синонім для коду комірки. Ми також створили синонім типу для типу, що відображує цілі на пари зі стану та коду комірки. І тепер ми збираємось створити функцію, що шукатиме код в мапі комірок. Ми збираємось використати тип <code>Either String Code</code> для представлення нашого результату, оскільки наш результат може бути невдалим в два способи — комірка може бути зайнятою, в якому випадку ми кажемо код, або номер комірки може взагалі не існувати. Якщо пошук схибив, ми просто збираємось використати <code>String</code>, щоб сказати що трапилось.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">lockerLookup</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">LockerMap</span> <span class="ow">-&gt;</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Code</span>
<span class="nf">lockerLookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="ow">=</span>
    <span class="kr">case</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="n">lockerNumber</span> <span class="n">map</span> <span class="kr">of</span>
        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker number &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; doesn&#39;t exist!&quot;</span>
        <span class="kt">Just</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">code</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">state</span> <span class="o">/=</span> <span class="kt">Taken</span>
                                <span class="kr">then</span> <span class="kt">Right</span> <span class="n">code</span>
                                <span class="kr">else</span> <span class="kt">Left</span> <span class="o">$</span> <span class="s">&quot;Locker &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">lockerNumber</span> <span class="o">++</span> <span class="s">&quot; is already taken!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми тут робимо звичайний пошук по мапі. Якщо ми отримаємо <code>Nothing</code>, ми повертаємо значення типу <code>Left String</code>, що каже, що комірка не існує взагалі. Якщо ми знайдемо її, тоді ми робимо додаткову перевірку, щоб перевірити, чи комірка зайнята. Якщо це так, повертаємо <code>Left</code>, що каже, що вона зайнята. Якщо це не так, тоді повертаємо значення типу <code>Right Code</code>, в якому ми надаємо студентові коректний код комірки. Насправді це <code>Right String</code>, але ми ввели новий синонім типу, щоб додати деяку додаткову документацію до декларації типу. Ось приклад мапи:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">lockers</span> <span class="ow">::</span> <span class="kt">LockerMap</span>
<span class="nf">lockers</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span>
    <span class="p">[(</span><span class="mi">100</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;ZD39I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">101</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;JAH3I&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">103</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;IQSA9&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">105</span><span class="p">,(</span><span class="kt">Free</span><span class="p">,</span><span class="s">&quot;QOTSA&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">109</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;893JJ&quot;</span><span class="p">))</span>
    <span class="p">,(</span><span class="mi">110</span><span class="p">,(</span><span class="kt">Taken</span><span class="p">,</span><span class="s">&quot;99292&quot;</span><span class="p">))</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер давайте спробуємо пошукати деякі коди комірок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">101</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;JAH3I&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">100</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 100 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">102</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker number 102 doesn&#39;t exist!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">110</span> <span class="n">lockers</span>
<span class="kt">Left</span> <span class="s">&quot;Locker 110 is already taken!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lockerLookup</span> <span class="mi">105</span> <span class="n">lockers</span>
<span class="kt">Right</span> <span class="s">&quot;QOTSA&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми могли б використати <code>Maybe</code> для представлення результату, але тоді ми б не знали, чому ми не змогли отримати код. Але тепер ми маємо інформацію щодо збою в нашому результуючому типі.</p></div>
</div>
<div class="sect2">
<h3 id="___">Рекурсивні структури даних</h3>
<div class="paragraph"><p><span class="image">
<img src="images/thefonz.png" alt="images/thefonz.png" />
</span>
Як ми бачили, конструктор в алгебраїчному типі даних може мати декілька (або взагалі жодного) полів, і кожне поле повинно бути деякого конкретного типу. З цім на думці ми можемо створити типи, конструктори якого матимуть поля, що будуть того самого типу! Використовуючи це ми можемо створити рекурсивні типи даних, коли одне значення того самого типу містить значення цього типу, що, в свою чергу, містить ще більше значень того ж типу, і так далі.</p></div>
<div class="paragraph"><p>Подумайте про цей список: <code>[5]</code>. Це тільки синтаксичний цукор для <code>5:[]</code>. З лівого боку від <code>:</code> знаходиться значення, та з правого боку список. І в цьому порядку це порожній список. Тепер як щодо списку <code>[4,5]</code>? Гаразд, це розцукровується до <code>4:(5:[])</code>. Дивлячись на перше <code>:</code> ми бачимо, що він також має елемент з лівої сторони, і список <code>(5:[])</code> з правої сторони. Те саме зі списками як <code>3:(4:(5:6:[]))</code>, що може бути записане також як <code>3:4:5:6:[]</code> (оскільки <code>:</code> право-асоциативне), або <code>[3,4,5,6]</code>.</p></div>
<div class="paragraph"><p>Ми можемо сказати, що список може бути порожнім списком, або це може бути елемент, приєднаний разом через <code>:</code> з іншим списком (що також може бути порожнім списком, або ні).</p></div>
<div class="paragraph"><p>Давайте використаємо алгебраїчні типи даних для реалізації нашого власного типу!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це читається так само, як наше визначення списків з одного з наших попередніх параграфів. Це або порожній список, або комбінація голови в вигляді деякого значення, та списку. Якщо ви стурбовані цім, ви можете знайти простішим зрозуміти синтаксис запису.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="p">{</span> <span class="n">listHead</span> <span class="ow">::</span><span class="n">a</span><span class="p">,</span> <span class="n">listTail</span> <span class="ow">::</span><span class="kt">List</span> <span class="n">a</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете бути стурбовані щодо наведеного тут конструктора <code>Cons</code>. <code>cons</code> є інша слово для <code>:</code>. Ви бачите, що в списках <code>:</code> насправді є конструктором, що приймає значення та інший список, та повертає список. Ми вже використали наш власний тип списку! В інших словах, він має два поля. Одне поле має тип <code>a</code>, і інше має тип <code>[a]</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Empty</span>
<span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span>
<span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">4</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="p">(</span><span class="mi">5</span> <span class="p">`</span><span class="kt">Cons</span><span class="p">`</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="kt">Cons</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">4</span> <span class="p">(</span><span class="kt">Cons</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми викликали наш конструктор <code>Cons</code> в інфіксній манері, так що ми можемо бачити, наскільки це просто <code>:</code>. <code>Empty</code> як <code>[]</code>, і <code>4 `Cons</code> (5 <code>Cons</code> Empty)` як <code>4:(5:[])</code>.</p></div>
<div class="paragraph"><p>Ми можемо визначати функції, що автоматично будуть інфіксними, якщо вони будуть складатись тільки зі спеціальних символів. Ми можемо зробити те саме з конструкторами, бо вони є лише функціями, що повертають тип даних. Перевіримо це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span> <span class="kt">:-:</span>
<span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Empty</span> <span class="o">|</span> <span class="n">a</span> <span class="kt">:-:</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">,</span> <span class="kt">Ord</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Поперше ми помічаємо нову синтаксичну конструкцію, декларацію фіксіті. Коли ми визначаємо функції як оператори, ми можемо використовувати це для надання фіксіті (але не маємо робити це). Фіксіті вказує, як сильно оператор прикріплюється, та чи є він ліво-асоціативним або право-асоціативним. Наприклад, фіксіті <code>*</code> є <code>infixl 7 *</code> та фіксіті <code>+</code> є <code>infixl 6</code>. Це означає, що вони обоє ліво-асоціативні <code>(4 * 3 * 2 is (4 * 3) * 2)</code>, але * прикріплюється краще, ніж <code>+</code>, бо він має більшу фіксіті, так що <code>5 * 4 + 3 is (5 * 4) + 3</code>.</p></div>
<div class="paragraph"><p>Так що ми пишемо просто <code>a :-: (List a)</code>, замість <code>Cons a (List a)</code>. Тепер ми можемо записати наші списки з нашим типом ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">))</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="kt">:-:</span> <span class="n">a</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">100</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="kt">Empty</span><span class="p">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми виводимо <code>Show</code> для нашого типу, Haskell все ще буде відображувати його так, якби конструктор був префіксною функцією, ось чому ми бачимо дужки коло оператора (згадайте, <code>4 + 3</code> є <code>(+) 4 3</code>).</p></div>
<div class="paragraph"><p>Давайте створимо функцію, що додає два наші списки разом. Ось як <code>++</code> визначений для звичайних списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">++</span>
<span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">[]</span>     <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="o">++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що ми просто вкрадемо його для нашого списку. Ми назвемо функцію <code>.++</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">infixr</span> <span class="mi">5</span>  <span class="o">.++</span>
<span class="p">(</span><span class="o">.++</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">List</span> <span class="n">a</span>
<span class="kt">Empty</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">ys</span>
<span class="p">(</span><span class="n">x</span> <span class="kt">:-:</span> <span class="n">xs</span><span class="p">)</span> <span class="o">.++</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:-:</span> <span class="p">(</span><span class="n">xs</span> <span class="o">.++</span> <span class="n">ys</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>І давайте подивимось, чи буде це робити &#8230;</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">3</span> <span class="kt">:-:</span> <span class="mi">4</span> <span class="kt">:-:</span> <span class="mi">5</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">6</span> <span class="kt">:-:</span> <span class="mi">7</span> <span class="kt">:-:</span> <span class="kt">Empty</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">.++</span> <span class="n">b</span>
<span class="p">(</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">3</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">4</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">5</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">6</span> <span class="p">((</span><span class="kt">:-:</span><span class="p">)</span> <span class="mi">7</span> <span class="kt">Empty</span><span class="p">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарно. Це гарно. Якщо б ми побажали, ми б реалізували всі функції, що оперують на списках, для нашого власного типу списків.</p></div>
<div class="paragraph"><p>Зауважте, як ми порівняли шаблон на <code>(x :-: xs)</code>. Це робить, бо порівняння шаблонів насправді має справу з порівнянням конструкторів. Ми можемо порівнювати на <code>:-:</code>, бо це конструктор для нашого власного типу списка, і ми також можемо порівнювати на <code>:</code>, бо це також конструктор для вбудованого типу списка. Те саме і для <code>[]</code>. Оскільки порівняння шаблонів робить (тільки) на конструкторах, ми можемо порівнювати на таких речах, звичайних префіксних конструкторах або такому, як <code>8</code> або <code>'a'</code>, що загалом конструктори для числових та символьних типах, відповідно.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/binarytree.png" alt="images/binarytree.png" />
</span>
Тепер ми збираємось реалізувати двійникове дерево пошуку. Якщо ви не знайомі з такими деревами з мов як C, ось цо вони таке: елемент вказує на два елемента, один сліва і один зправа. Елемент зліва меньший, елемент зправа більший. Кожний з ціх елементів також може вказувати на два елементи (або один, або на жодний). Ефективно кожний елемент має два під-дерева. І крута річ щодо двійникових дерев пошуку в тому, що ми знаємо, що всі елементи на лівому суб-дереві для, скажімо, <code>5</code>, будуть меньшими за <code>5</code>. Елементи в правому суб-дереві будуть більшими. Так що коли нам треба знайти <code>8</code> в нашому дереві, ми починаємо з <code>5</code>, та потім, через те, що <code>8</code> більше <code>5</code>, ми йдемо направо. Тепер ми на <code>7</code>, і оскільки <code>8</code> більше <code>7</code>, ми знову йдемо направо. І ми знайшли наш елемент за три стрибка! Тепер, якщо б це був список (або дерево, але дуже розбалансоване), це зайняло сім стрибків замість трьох, щоб побачити <code>8</code>.</p></div>
<div class="paragraph"><p>Множини та мапи від <code>Data.Set</code> та <code>Data.Map</code> реалізовані за допомогою дерев, тільки замість звичайних двійникових дерев пошуку вони використовують збалансовані двійникові дерева, що весь час збалансовані. Але зараз ми реалізуємо тільки звичайне двійнікове дерево пошуку.</p></div>
<div class="paragraph"><p>Ось що ми збираємось тут сказати: дерево або порожнє дерево, або це елемент, що містить деяке значення та два дерева. Звучить як ідеально підходяще для алгебраїчних типів даних!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">EmptyTree</span> <span class="o">|</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">,</span> <span class="kt">Read</span><span class="p">,</span> <span class="kt">Eq</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так, гарно, це гарно. Замість побудови дерева вручну ми збираємось створити функцію, що приймає дерево і елемент, і вставляє елемент. Ми робимо це через порівняння значення, яке ми бажаємо вставити до кореневого вузла, і коли воно меньше, ми йдемо наліво, або якщо більше - направо. Ми робимо те саме для кожного наступного вузла, доки не дойдемо до порожнього дерева. Як тільки ми дійшли до порожнього дерева, ми просто вставляємо вузол з вставляємим значення замість порожнього дерева.</p></div>
<div class="paragraph"><p>В таких мовах, як C, ми робили б це через модифікацію вказівників та значень в дереві. В Haskell ми насправді не можемо модифікувати наше дерево, так що нам треба створити нове суб-дерево кожний раз, коли ми вирішуємо пійти наліво або направо, і кінець кінцем функція вставки повертає повністю нове дерево, бо насправді Haskell не має концепції вказівника, тільки значення. Таким чином, тип для нашої функції вставки буде щось <code>a -&gt; Tree a - &gt; Tree a</code>. Вона приймає елемент та дерево, та повертає нове дерево, що має в собі цей елемент. Це може виглядати як неефективне, але лінивість потурбується про цю проблему.</p></div>
<div class="paragraph"><p>Так, ось дві функції. Одна функція допоміжна, для створення синглтона дерева (вузол тільки з одним елементом), та функція для вставляння елементу в дерево.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">singleton</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">singleton</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span>

<span class="nf">treeInsert</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="n">singleton</span> <span class="n">x</span>
<span class="nf">treeInsert</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="n">x</span> <span class="n">left</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">left</span><span class="p">)</span> <span class="n">right</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="p">(</span><span class="n">treeInsert</span> <span class="n">x</span> <span class="n">right</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>singleton</code> є просто скороченням для створення вузла, що містить дещо, та потім ще два порожні суб-дерева. В функції вставляння ми спочатку маємо граничну умову в якості шаблона. Якщо ми досягли порожнього суб-дерева, що означає що ми там де треба, і замість порожнього дерева ми покладаємо синглтон дерево з нашим елементом. Якщо ми не вставляємо в порожньє дерево, тоді ми маємо перевірити декілька речей. Спочатку, якщо елемент, що ми вставляємо, дорівнює кореневому елементу, просто повертаємо дерево, що є тим самим. Якщо значення меньше, повертаємо дерево, що має той самий корінь і значення, те саме праве суб-дерево, але замість лівого суб-дерева покладаємо дерево з вставленим нашим елементом. Те саме (але навпаки) відбувається, коли значення більше, ніж кореневий елемент.</p></div>
<div class="paragraph"><p>Далі ми збираємось створити функцію, що перевіряє, чи деякий елемент знаходиться в нашому дереві. Спочатку давайте визначимо граничну умову. Якщо ми шукаємо елемент в порожньому дереві, його там напевне не буде. Гаразд. Зауважте, наскільки це те саме, що і гранична умова при пошуку елементів в списку. Якщо ми шукаємо елемент в порожньому списку, його там нема. В любому разі, якщо ми не шукаємо елемент в порожньому дереві, тоді ми перевіряємо деякі речі. Якщо елемент в кореневому вузлі є те, що ми шукаємо, чудово! Якщо ні, що тоді? Гаразд, ми можемо отримати вигоду від знання, що всі елементи меньші, ніж в кореневому вузлі. Так що якщо ми шукаємо меньший елемент, ніж кореневий, перевіряємо, чи може він знаходиться в лівому суб-дереві. Якщо значення більше, шукаємо його в правому суб-дереві.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">treeElem</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Tree</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">treeElem</span> <span class="n">x</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">a</span> <span class="n">left</span> <span class="n">right</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">left</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span>  <span class="ow">=</span> <span class="n">treeElem</span> <span class="n">x</span> <span class="n">right</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що нам знадобилось, це записати попередній параграф в коді. Давайте розважимось з нашими деревами! Замість вручну будувати дерево (хоча ми можемо), ми використаємо згортку для побудови дерева зі списка. Пам'ятайте, що майже все, що проходить по списку одне по одному, та потім повертає деякий різновид значення, може бути реалізовано як згортка! Ми збираємось почати з порожнього дерева, та потім проходити список зправа, і просто включати елемент за елементом в наше акумулююче дерево.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nums</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">numsTree</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="n">nums</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">numsTree</span>
<span class="kt">Node</span> <span class="mi">5</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">3</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">1</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">7</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">6</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">)</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому <code>foldr</code> функція <code>treeInsert</code> була функцією згортки (вона приймає дерево і елемент списку, і продукує нове дерево), і <code>EmptyTree</code> було початковим аккумулятором. <code>nums</code>, звичайно, було списком, по якому ми робили згортку.</p></div>
<div class="paragraph"><p>Потім ми друкуємо наше дерево на консолі, це не дуже читається, але якщо ми спробуємо, ми можемо відтворити нашу структуру. Ми бачимо, що кореневий вузол є <code>5</code>, та потім має два суб-дерева, один з яких має кореневий вузол <code>3</code>, а інший <code>7</code>, тощо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">8</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">100</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">treeElem</span><span class="p">`</span> <span class="n">numsTree</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевірка на членство також робить гарно. Круто.</p></div>
<div class="paragraph"><p>Так що, як ви можете бачити, алгебраїчні структури даних насправді крута і потужна конецепція в Haskell. Ми можемо використовувати їх для створення будь-чого, від логічних значень та переліку днів тижня до двійникових дерев пошуку і більше!</p></div>
</div>
<div class="sect2">
<h3 id="__102">Типокласи 102</h3>
<div class="paragraph"><p><span class="image">
<img src="images/trafficlight.png" alt="images/trafficlight.png" />
</span>
Досі ми вивчили щодо стандартних типокласів Haskell, і ми побачили, які класи належать до них. Ми також навчились, як автоматично створювати примірники наших класів для стандартних типокласів, щоб Haskell виводив примірники для нас. В цьому розділі ми збираємось вивчити, як створювати свої власні типокласи, та як робити їх типи примірники руками.</p></div>
<div class="paragraph"><p>Швидке нагадування про типокласи: типокласи як інтерфейси. Типоклас визначає деяку поведінку (як порівняння на рівність, порівняння на впорядкованість, перелік), і потім типи, що можуть поводитись в цей спосіб, складають примірники цього типокласу. Поведінка типокласу досягається через визначення функцій, або тільки декларацій типів, які ми реалізуємо. Так що коли ми кажемо, що тип є примірником типокласу, це означає, що ми можемо використовувати функції, що типоклас визначає за допомогою цього типу.</p></div>
<div class="paragraph"><p>Типокласи не мають нічого спільного з класами в мовах як Java або Python. Це бентежить багатьох людей, так що я бажаю, щоб ви забули все, що ви знаєте про класи в імперативних мовах, прямо зараз.</p></div>
<div class="paragraph"><p>Наприклад типоклас <code>Eq</code> є для речей, що можуть бути рівними. Він визначає функції <code>==</code> та <code>/=</code>. Якщо ми маємо тип, (скажімо, <code>Car</code>), і порівняння двох машин функцією <code>==</code> має сенс, тоді <code>Car</code> буде примірником <code>Eq</code>.</p></div>
<div class="paragraph"><p>Ось як клас <code>Eq</code> визначений в стандартному <code>prelude</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ой, ой, ой! Якійсь новий дивний синтаксис і ключові слова! Не турбуйтесь, все з'ясується за секунду. Для початку, коли ми пишемо <code>class Eq a where</code>, це означає, що ми визначаємо новий типоклас, і він має назву <code>Eq</code>. <code>a</code> є змінною типа, і це означає, що вона буде відігравати роль типа, що скоро буде створювати примірник <code>Eq</code>. Вона не має називатись <code>a</code>, вона навіть не має складатись з однієї літери, вона лише повинна бути словом в нижньому реєстрі. Потім ми визначаємо декілька функцій. Не є обов'язковим самому реалізувати тіла функцій, ми тільки маємо вказати декларації типів для функцій.</p></div>
<div class="paragraph"><p>Деякі люди можуть зрозуміти це краще, якщо ми запишемо <code>class Eq equatable where</code> і потім вкажемо декларації типів, як <code>(==) ::equatable -&gt; equatable -&gt; Bool</code>.</p></div>
<div class="paragraph"><p>В жодному разі ми реалізували тіла функції для функцій, що визначає <code>Eq</code>, тільки ми визначили їх в термінах взаємної рекурсії. Ми кажемо, що два примірника <code>Eq</code> рівні, якщо вони не різні, і вони різні, якщо вони не рівні. Насправді ми не мали цього робити, але ми зробили і ми побачимо, як це скоро нам допоможе.</p></div>
<div class="paragraph"><p>Якщо ми сказали <code>class Eq a where</code>, та потім визначили декларацію типу в класі, як <code>(==) ::a -&gt; -a -&gt; Bool</code>, тоді коли ми після цього перевіряємо тип цієї функції, вона буде мати тип <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>.</p></div>
<div class="paragraph"><p>Так,  коли ми одного разу створили клас, що ми можемо робити з ним? Гаразд, насправді не багато. Але як тільки ми починаємо створювати примірники типів цього класу, ми починаємо отримувати деяку милу функціональність. Так що перевірте цей тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span>
</pre></div></div></div>
<div class="paragraph"><p>Він визначає стан світлофора. Зауважте, як ми не виводили жодних примірників класу для нього. Це тому, що ми збираємось написати деякі примірники вручну, навіть якщо ми можемо вивести їх для типів як <code>Eq</code> та <code>Show</code>. Ось як ми робимо його примірником <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Green</span> <span class="o">==</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Yellow</span> <span class="o">==</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми зробили це, використовуючи ключове слово <code>instance</code>. Так що клас для визначення нових типокласів, та примірник для перетворення наших класів на примірники типокласів. Коли ми визначаємо <code>Eq</code>, ми пишемо <code>class Eq a where</code>, і ми сказали, що <code>a</code> грає роль того самого типу, примірник якого ми пізніше створюємо. Ми можемо бачити це ясно тут, бо коли ми створюємо примірник, ми пишемо <code>instance Eq TrafficLight where</code>. Ми заміняємо <code>a</code> на справжній тип.</p></div>
<div class="paragraph"><p>Через те, що <code>==</code> було визначено в термінах <code>/=</code>, і навпаки, в декларації класа, нам треба тільки переписати один з них в декларації примірника. Це називається мінімально повним визначенням для типокласу — мінімум функцій, що нам треба реалізувати, так що наш тип зможе поводитись так, як проголошує клас. Щоб задовільнити мінімальному повному визначенню для <code>Eq</code>, ми маємо переписати одне, або <code>==</code> або <code>/=</code>. Якщо <code>Eq</code> було визначено просто як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>ми б мали реалізовувати обоє ці функції, коли робимо тип примірником класу, оскільки Haskell не має гадки, що ці дві функції пов'язані. Мінімальне повне визначення буде обоє, <code>==</code> та <code>/=</code>.</p></div>
<div class="paragraph"><p>Ви можете бачити, що ми реалізували <code>==</code> просто через порівняння шаблону. Оскільки існує значно більше випадків, коли два світла не рівні, ми вказали ті що рівні, і потім просто зробили шаблон спіймати-всіх, що каже, що якщо це не жодна з попередніх комбінацій, тоді світло не те саме.</p></div>
<div class="paragraph"><p>Давайте також вручну зробимо його примірником <code>Show</code>. Щоб задовільнити мінімальному повному визначенню для <code>Show</code>, ми тільки маємо реалізувати його функцію <code>show</code>, що приймає значення, та перетворює його на рядок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">show</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="s">&quot;Red light&quot;</span>
    <span class="n">show</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="s">&quot;Yellow light&quot;</span>
    <span class="n">show</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="s">&quot;Green light&quot;</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>І знову, ми використали порівняння шаблонів для досягнення наших цілей. Давайте побачимо, як це робить в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Yellow</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Red</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">Red</span><span class="p">,</span> <span class="kt">Yellow</span><span class="p">,</span> <span class="kt">Green</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Red</span> <span class="n">light</span><span class="p">,</span><span class="kt">Yellow</span> <span class="n">light</span><span class="p">,</span><span class="kt">Green</span> <span class="n">light</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Мило. Ми могли просто вивести <code>Eq</code>, і це мало б такий самий ефект (але ми не зробили це для цілей навчання). Однак вивід <code>Show</code> був би прямо трансльований від конструкторів на рядки. Але якщо ви бажаєте, щоб світло виглядало як "Red light", тоді нам треба зробити декларацію примірника вручну.</p></div>
<div class="paragraph"><p>Ви також можете створити типокласи, що є субкласами інших типокласів. Декларація класу для <code>Num</code> трохи задовга, але ось перша частина:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Num</span> <span class="n">a</span> <span class="kr">where</span>
   <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ми вказували до цього, існує багато місць, де ми можемо впихнути обмеження класу. Так що це як написати <code>class Num a where</code>, тільки ми стверджуємо, що наш тип має бути примірником <code>Eq</code>. В основному ми кажемо, що нам треба зробити тип примірником <code>Eq</code>, перед тим, як ми зможемо зробити його примірником <code>Num</code>. Перед тим, як деякий тип може розглядатись як число, має сенс визначитись, чи значення цього типу можуть бути рівними, чи ні. Це і все, що тут відносно субкласів: це просто обмеження на декларації класу! Коли визначаємо тіла функцій в декларації класу, або коли визначаємо їх в деклараціях примірника, ми можемо вважати, що <code>a</code> є частиною <code>Eq</code>, так що ми можемо використовувати <code>==</code> на значеннях цього типу.</p></div>
<div class="paragraph"><p>Але як <code>Maybe</code> або типи списків стають примірниками типокласів? Що робить <code>Maybe</code> іншим від, скажімо, <code>TrafficLight</code>, це те, <code>Maybe</code> сам по собі не є конкретним типом, це конструктор типу, що приймає один параметр типу (як <code>Char</code> або будь-що інше) для продукування конкретного типу (як <code>Maybe Char</code>). Давайте поглянемо на типоклас <code>Eq</code> знову:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>З декларації типу ми бачимо, що <code>a</code> використовується як конкретний тип, бо всі типи в функціях мають бути конкретними (пам'ятаєте, ви не можете мати функцію типу <code>a -&gt; Maybe</code>, але ви можете мати функцію <code>a -&gt; Maybe a</code> або <code>Maybe Int -&gt; Maybe String</code>). Ось чому ми не можемо робити щось таке</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Бо, як ми бачили, <code>a</code> має бути конкретним типом, але <code>Maybe</code> не є конкретним типом. Це конструктор типу, що бере один параметр, і потім продукує конкретний тип. Також буде обтяжливо написати <code>instance Eq (Maybe Int) where</code>, instance Eq (Maybe Char) where, тощо. для кожного існуючого класу. Так що ми можемо записати це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Це як сказати, що ми бажаємо зробити всі типи в формі <code>Maybe</code> дещо примірниками <code>Eq</code>. Ми насправді можемо записати <code>(Maybe something)</code>, але ми зазвичай обираємо одну літеру, щоб бути в стилі Haskell. Тут <code>(Maybe m)</code> грає роль <code>a</code> в <code>class Eq a where</code>. Хоча <code>Maybe</code> і не конкретний тип, <code>Maybe m</code> вже так. Задаючи параметр типу (<code>m</code>, що в нижньому реєстрі), ми кажемо, що ми бажаємо, щоб всі типи, що мають форму <code>Maybe m</code>, де <code>m</code> є довільний тип, були примірниками <code>Eq</code>.</p></div>
<div class="paragraph"><p>Однак з цім є одна проблема. Чи ви помітили її? Ми використовуємо  <code>==</code> на вмісті <code>Maybe</code>, але в нас немає гарантій, що вміст <code>Maybe</code> може бути використаний з <code>Eq</code>! Ось чому ми маємо модифікувати нашу декларацію примірника таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">m</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Eq</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
    <span class="kt">Just</span> <span class="n">x</span> <span class="o">==</span> <span class="kt">Just</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
    <span class="kt">Nothing</span> <span class="o">==</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам знадобилось додати обмеження класу! З цією декларацією примірника ми кажемо: ми бажаємо, щоб всі типи в формі <code>Maybe m</code> були частиною типокласу <code>Eq</code>, але тільки ті типи, де <code>m</code> (тобто те, що міститься в <code>Maybe</code>) також є частиною <code>Eq</code>. Це насправді те, як Haskell буде виводити примірник, також.</p></div>
<div class="paragraph"><p>В більшості випадків обмеження класу в деклараціях класу використовуються щоб зробити типоклас субкласом іншого типокласу, та обмеження класу в деклараціях примірника використовуються для вираження вимог щодо вміста деякого типу. Наприклад, тут ми вимагаємо, щоб вміст <code>Maybe</code> також був частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Коли створюєте примірники, якщо ви бачите, що тип використовується як конкретний тип в деклараціях типу (як <code>a</code> в <code>a -&gt; a -&gt; Bool</code>), ви маєте надати параметри типу, та додати дужки, так щоб у вас утворився конкретний тип.</p></div>
<div class="paragraph"><p>Прийміть до уваги, що тип, який ви намагаєтесь зробити примірником,буде заміщати параметр в декларації класу. <code>a</code> з <code>class Eq a where</code> буде замінений на реальний тип, коли ви створюватимете примірник, так що спробуйте подумки покласти ваш тип в декларації типу функцій, також. <code>(==) ::Maybe -&gt; Maybe -&gt; Bool</code> не має багато сенсу, але <code>(==) ::(Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool</code> так. Але це тільки ще одне, про що треба подумати, бо <code>==</code> буде завжди мати тип <code>(==) ::(Eq a) =&gt; a -&gt; a -&gt; Bool</code>, не важливо, які примірники ми створюємо.</p></div>
<div class="paragraph"><p>О, ще одна річ, перевірте це! Якщо ви бажаєте побачити, які примірники є в типокласа, просто зробіть <code>:info YourTypeClass</code> в GHCI. Так що набравши <code>:info Num</code> покаже вам, які функції визначає типоклас, і це також видасть вам список типів в типокласі. <code>:info</code> робить для типів, і також для конструкторів. Якщо ви робите <code>:info Maybe</code>, воно покаже вам всі типокласи, для яких <code>Maybe</code> є примірником. Також <code>:info</code> може показати декларацію типу для функції. Я думаю це досить круто.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Типоклас так-ні</h3>
<div class="paragraph"><p><span class="image">
<img src="images/yesno.png" alt="images/yesno.png" />
</span>
В JavaScript та деяких інших слабо типізованих мовах ви можете покласти майже будь-що в вираз <code>if</code>. Наприклад, ви можете зробити все з наступного: <code>if (0) alert("YEAH!") else alert("NO!")</code>, <code>if ("") alert ("YEAH!") else alert("NO!")</code>, <code>if (false) alert("YEAH") else alert("NO!)</code>, etc., і все це буде викликати <code>alert NO!</code>. Якщо ви зробите <code>if ("WHAT") alert ("YEAH") else alert("NO!")</code>, буде виконане <code>alert YEAH!</code>, оскільки JavaScript розглядає непорожні рядки як різновид правдо-подібних значень.</p></div>
<div class="paragraph"><p>Навіть якщо пряме використання <code>Bool</code> для логічної семантики робить краще в Haskell, давайте спробуємо і реалізуємо цю JavaScript подібну поведінку все одно. Для розваги! Давайте почнемо з декларації класу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">YesNo</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить просто. Типоклас <code>YesNo</code> визначає одну функцію. Ця функція бере одне значення типу <code>a</code>, що може розгядатись як емність деякої концепції правдивості, і каже нам напевне, чи це правда, чи ні. Зауважте, що з того, в який спосіб ми використовуємо <code>a</code> в функції, це має бути конкретним типом.</p></div>
<div class="paragraph"><p>Далі давайте визначимо деякі примірники. Для чисел ми вважаємо, що (подібно до JavaScript) любе число, що не є <code>0</code>, є правдивим, та <code>0</code> є лживим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Int</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Порожні списки (і по розширенню рядки) є ні-значеннями, тоді як непорожні списки є так-значеннями.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, як ми просто поклали в параметр типу <code>a</code>, щоб зробити список конкретним типом, навіть якщо ми не робимо жодних припущень щодо типу, що міститься в списку. Що ще, хм &#8230; Я знаю, <code>Bool</code> сам по собі містить правдивість та неправдивість, і це досить очевидно щодо цього.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">Bool</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="ow">=</span> <span class="n">id</span>
</pre></div></div></div>
<div class="paragraph"><p>Так, що за <code>id</code>? Це тільки функція стандартної бібліотеки, що приймає параметр, та повертає ту саму річ, що саме те, що ми бажаємо тут написати.</p></div>
<div class="paragraph"><p>Давайте також зробимо примірником <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="p">(</span><span class="kt">Just</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="n">yesno</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам не треба обмеження типу, оскільки ми не маємо припущень щодо вмісту <code>Maybe</code>. Ми тільки що сказали, що ми правдиві коли маємо <code>Just</code> значення, та ні коли <code>Nothing</code>. Ми все ще маємо писати <code>(Maybe a)</code> замість просто <code>Maybe</code>, оскільки, якщо ви про це подумаєте, функція <code>Maybe -&gt; Bool</code> не може існувати (оскільки <code>Maybe</code> не є конкретним типом), тоді як <code>Maybe a -&gt; Bool</code> добре і елегантно. Це вже досить круто, бо зараз любий тип в формі <code>Maybe</code> дещо є частиною <code>YesNo</code>, і це не має значення, що є це дещо.</p></div>
<div class="paragraph"><p>До цього ми визначили тип <code>Tree a</code>, що представляв дерево двійникового пошуку. Ми можемо сказати, що порожнє дерево фальшиве, і непорожнє дерево є правдивим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="p">(</span><span class="kt">Tree</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Чи може світло світлофора бути значенням так або ні? Звичайно. Якщо світло червоне, ви зупиняєтесь. Якщо світло зелене, ви йдете. Якщо воно жовте? Ну так, зазвичай я біжу на жовтий, бо я живу на адреналіні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">YesNo</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="n">yesno</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">False</span>
    <span class="n">yesno</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто, тепер, коли ми маємо декілька примірників, давайте гратись!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="n">length</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;haha&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="s">&quot;&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="o">$</span> <span class="kt">Just</span> <span class="mi">0</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">EmptyTree</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="kt">[]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesno</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">yesno</span>
<span class="nf">yesno</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Все вірно, це робить! Давайте створимо функцію, що копіює твердження <code>if</code>, але робить зі значеннями <code>YesNo</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">yesnoIf</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">YesNo</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">yesnoIf</span> <span class="n">yesnoVal</span> <span class="n">yesResult</span> <span class="n">noResult</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">yesno</span> <span class="n">yesnoVal</span> <span class="kr">then</span> <span class="n">yesResult</span> <span class="kr">else</span> <span class="n">noResult</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить прямолінійно. Вона приймає значення <code>yes-no</code> та дві речі. Якщо значення скоріше <code>yes</code>, повертається перша з двох речей, інакше повертається друга річ.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">[]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">True</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">500</span><span class="p">)</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;YEAH!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">yesnoIf</span> <span class="kt">Nothing</span> <span class="s">&quot;YEAH!&quot;</span> <span class="s">&quot;NO!&quot;</span>
<span class="s">&quot;NO!&quot;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__functor">Типоклас Functor</h3>
<div class="paragraph"><p>Досі ми зустрічали багато типокласів в стандартній бібліотеці. Ми грали з <code>Ord</code>, що призначений для речей, що можуть бути впорядковані. Ми намотали на вус щодо <code>Eq</code>, що є для речей, які можуть бути рівними. Ми бачили <code>Show</code>, що представляє інтерфейс для типів, чиї значення можуть бути відображені як рядки. Наш гарний друг <code>Read</code> був поряд, коли нам треба конвертувати рядок на значення деякого типу. І тепер ми збираємось подивитись на типоклас <code>Functor</code>, що в основному для речей, по яких можна робити відображення. Можливо, ви зараз думаєте про списки, оскільки відображення по списках є домінантною ідіомою в Haskell. І ви праві, тип списку є частиною типокласу <code>Functor</code>.</p></div>
<div class="paragraph"><p>Що може бути кращим способом отримати знання про типоклас <code>Functor</code>, ніж побачити його реалізацію? Давайте поглянемо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/functor.png" alt="images/functor.png" />
</span>
Гаразд, ми бачимо що це визначає функцію, <code>fmap</code>, і не провадимо жодної реалізації по замовчанню для неї. Тип <code>fmap</code> є цікавим. Досі в визначеннях типокласів змінна типу, що грала роль типу в типокласі, була конкретного типу, як <code>a</code> в <code>(==) ::(Eq a) =&gt; a -&gt; a -&gt; Bool</code>. Але тепер <code>f</code> не є конкретним типом (тип, що може містити <code>a</code>, як <code>Int</code>, <code>Bool</code> або <code>Maybe String</code>), але це конструктор типу, що приймає один параметр типу. Швидке нагадування: <code>Maybe Int</code> є конкретним типом, але <code>Maybe</code> є конструктором типу, що приймає один тип в якості параметра. В жодному разі, ми бачимо що <code>fmap</code> бере функцію з одного типу до іншого, і функтор, застосований з одного типу та повертає функтор, застосований з іншим типом.</p></div>
<div class="paragraph"><p>Не турбуйтесь, якщо це виглядає трохи збентежливо. Все швидко викриється, коли ми побачимо декілька прикладів. Хм, ця декларація типу <code>fmap</code> нагадує мені щось. Якщо ви не знаєте, якого типу є сигнатура <code>map</code>, вона така: <code>map ::(a -&gt; b) -&gt; [a] -&gt; [b]</code>.</p></div>
<div class="paragraph"><p>А, цікаво! Це бере функцію від одного типу до іншого, і список одного типу і повертає список іншого типу. Мої друзі, ми маємо з вами функтор! Фактично, <code>map</code> є просто <code>fmap</code>, що робить на списках. Ось як список є примірником типокласу <code>Functor</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="n">map</span>
</pre></div></div></div>
<div class="paragraph"><p>І це все! Зауважте, що ми не писали <code>instance Functor [a] where</code>, бо з <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>, ми бачимо, що <code>f</code> має бути конструктором типів, що приймає один тип. <code>[a]</code> є вже конкретним типом (списком з деяким списком всередині), тоді як <code>[]</code> є конструтором типів, що приймає один тип, і може продукувати типи як  <code>[Int]</code>, <code>[String]</code> або навіть <code>[[String]]</code>.</p></div>
<div class="paragraph"><p>Оскільки для списків <code>fmap</code> є просто <code>map</code>, ми отримуємо ті самі результати, коли використовуємо його на списках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що трапиться, коли ми зробимо <code>map</code> або <code>fmap</code> на порожньому списку? Гаразд, звичайно ми отримаємо порожній список. Вони просто перетворюють порожній список типу <code>[a]</code> в порожній список типу <code>[b]</code>.</p></div>
<div class="paragraph"><p>Типи, що можуть діяти як бокси, можуть бути функторами. You can think of a list as a box that has an infinite amount of little compartments and they can all be empty, one can be full and the others empty or a number of them can be full. So, what else has the properties of being like a box? For one, the Maybe a type. In a way, it&#8217;s like a box that can either hold nothing, in which case it has the value of Nothing, or it can hold one item, like "HAHA", in which case it has a value of Just "HAHA". Here&#8217;s how Maybe is a functor.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Again, notice how we wrote instance Functor Maybe where instead of instance Functor (Maybe m) where, like we did when we were dealing with Maybe and YesNo. Functor wants a type constructor that takes one type and not a concrete type. If you mentally replace the fs with Maybes, fmap acts like a (a &#8594; b) &#8594; Maybe a &#8594; Maybe b for this particular type, which looks OK. But if you replace f with (Maybe m), then it would seem to act like a (a &#8594; b) &#8594; Maybe m a &#8594; Maybe m b, which doesn&#8217;t make any damn sense because Maybe takes just one type parameter.</p></div>
<div class="paragraph"><p>Anyway, the fmap implementation is pretty simple. If it&#8217;s an empty value of Nothing, then just return a Nothing. If we map over an empty box, we get an empty box. It makes sense. Just like if we map over an empty list, we get back an empty list. If it&#8217;s not an empty value, but rather a single value packed up in a Just, then we apply the function on the contents of the Just.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="s">&quot;Something serious.&quot;</span><span class="p">)</span>
<span class="kt">Just</span> <span class="s">&quot;Something serious. HEY GUYS IM INSIDE THE JUST&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HEY GUYS IM INSIDE THE JUST&quot;</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="kt">Just</span> <span class="mi">200</span><span class="p">)</span>
<span class="kt">Just</span> <span class="mi">400</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Another thing that can be mapped over and made an instance of Functor is our Tree a type. It can be thought of as a box in a way (holds several or no values) and the Tree type constructor takes exactly one type parameter. If you look at fmap as if it were a function made only for Tree, its type signature would look like (a &#8594; b) &#8594; Tree a &#8594; Tree b. We&#8217;re going to use recursion on this one. Mapping over an empty tree will produce an empty tree. Mapping over a non-empty tree will be a tree consisting of our function applied to the root value and its left and right sub-trees will be the previous sub-trees, only our function will be mapped over them.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Tree</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">EmptyTree</span> <span class="ow">=</span> <span class="kt">EmptyTree</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Node</span> <span class="n">x</span> <span class="n">leftsub</span> <span class="n">rightsub</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">leftsub</span><span class="p">)</span> <span class="p">(</span><span class="n">fmap</span> <span class="n">f</span> <span class="n">rightsub</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="kt">EmptyTree</span>
<span class="kt">EmptyTree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="n">foldr</span> <span class="n">treeInsert</span> <span class="kt">EmptyTree</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="kt">Node</span> <span class="mi">28</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">4</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">8</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">12</span> <span class="kt">EmptyTree</span> <span class="p">(</span><span class="kt">Node</span> <span class="mi">20</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">))))</span> <span class="kt">EmptyTree</span>
</pre></div></div></div>
<div class="paragraph"><p>Nice! Now how about Either a b? Can this be made a functor? The Functor typeclass wants a type constructor that takes only one type parameter but Either takes two. Hmmm! I know, we&#8217;ll partially apply Either by feeding it only one parameter so that it has one free parameter. Here&#8217;s how Either a is a functor in the standard libraries:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Well well, what did we do here? You can see how we made Either a an instance instead of just Either. That&#8217;s because Either a is a type constructor that takes one parameter, whereas Either takes two. If fmap was specifically for Either a, the type signature would then be (b &#8594; c) &#8594; Either a b &#8594; Either a c because that&#8217;s the same as (b &#8594; c) &#8594; (Either a) b &#8594; (Either a) c. In the implementation, we mapped in the case of a Right value constructor, but we didn&#8217;t in the case of a Left. Why is that? Well, if we look back at how the Either a b type is defined, it&#8217;s kind of like:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Well, if we wanted to map one function over both of them, a and b would have to be the same type. I mean, if we tried to map a function that takes a string and returns a string and the b was a string but the a was a number, that wouldn&#8217;t really work out. Also, from seeing what fmap&#8217;s type would be if it operated only on Either values, we see that the first parameter has to remain the same while the second one can change and the first parameter is actualized by the Left value constructor.</p></div>
<div class="paragraph"><p>This also goes nicely with our box analogy if we think of the Left part as sort of an empty box with an error message written on the side telling us why it&#8217;s empty.</p></div>
<div class="paragraph"><p>Maps from Data.Map can also be made a functor because they hold values (or not!). In the case of Map k v, fmap will map a function v &#8594; v' over a map of type Map k v and return a map of type Map k v'.</p></div>
<div class="paragraph"><p>Note, the ' has no special meaning in types just like it doesn&#8217;t have special meaning when naming values. It&#8217;s used to denote things that are similar, only slightly changed.
Try figuring out how Map k is made an instance of Functor by yourself!</p></div>
<div class="paragraph"><p>With the Functor typeclass, we&#8217;ve seen how typeclasses can represent pretty cool higher-order concepts. We&#8217;ve also had some more practice with partially applying types and making instances. In one of the next chapters, we&#8217;ll also take a look at some laws that apply for functors.</p></div>
<div class="paragraph"><p>Just one more thing! Functors should obey some laws so that they may have some properties that we can depend on and not think about too much. If we use fmap (+1) over the list [1,2,3,4], we expect the result to be [2,3,4,5] and not its reverse, [5,4,3,2]. If we use fmap (\a &#8594; a) (the identity function, which just returns its parameter) over some list, we expect to get back the same list as a result. For example, if we gave the wrong functor instance to our Tree type, using fmap over a tree where the left sub-tree of a node only has elements that are smaller than the node and the right sub-tree only has nodes that are larger than the node might produce a tree where that&#8217;s not the case. We&#8217;ll go over the functor laws in more detail in one of the next chapters.</p></div>
<div class="sect3">
<h4 id="_kinds_and_some_type_foo">Kinds and some type-foo</h4>
<div class="paragraph"><p>TYPE FOO MASTER
Type constructors take other types as parameters to eventually produce concrete types. That kind of reminds me of functions, which take values as parameters to produce values. We&#8217;ve seen that type constructors can be partially applied (Either String is a type that takes one type and produces a concrete type, like Either String Int), just like functions can. This is all very interesting indeed. In this section, we&#8217;ll take a look at formally defining how types are applied to type constructors, just like we took a look at formally defining how values are applied to functions by using type declarations. You don&#8217;t really have to read this section to continue on your magical Haskell quest and if you don&#8217;t understand it, don&#8217;t worry about it. However, getting this will give you a very thorough understanding of the type system.</p></div>
<div class="paragraph"><p>So, values like 3, "YEAH" or takeWhile (functions are also values, because we can pass them around and such) each have their own type. Types are little labels that values carry so that we can reason about the values. But types have their own little labels, called kinds. A kind is more or less the type of a type. This may sound a bit weird and confusing, but it&#8217;s actually a really cool concept.</p></div>
<div class="paragraph"><p>What are kinds and what are they good for? Well, let&#8217;s examine the kind of a type by using the :k command in GHCI.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Int</span>
<span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div></div></div>
<div class="paragraph"><p>A star? How quaint. What does that mean? A * means that the type is a concrete type. A concrete type is a type that doesn&#8217;t take any type parameters and values can only have types that are concrete types. If I had to read * out loud (I haven&#8217;t had to do that so far), I&#8217;d say star or just type.</p></div>
<div class="paragraph"><p>Okay, now let&#8217;s see what the kind of Maybe is.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span>
<span class="kt">Maybe</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div></div></div>
<div class="paragraph"><p>The Maybe type constructor takes one concrete type (like Int) and then returns a concrete type like Maybe Int. And that&#8217;s what this kind tells us. Just like Int &#8594; Int means that a function takes an Int and returns an Int, * &#8594; * means that the type constructor takes one concrete type and returns a concrete type. Let&#8217;s apply the type parameter to Maybe and see what the kind of that type is.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="kt">Maybe</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div></div></div>
<div class="paragraph"><p>Just like I expected! We applied the type parameter to Maybe and got back a concrete type (that&#8217;s what * &#8594; * means. A parallel (although not equivalent, types and kinds are two different things) to this is if we do :t isUpper and :t isUpper <em>A</em>. isUpper has a type of Char &#8594; Bool and isUpper <em>A</em> has a type of Bool, because its value is basically True. Both those types, however, have a kind of *.</p></div>
<div class="paragraph"><p>We used :k on a type to get its kind, just like we can use :t on a value to get its type. Like we said, types are the labels of values and kinds are the labels of types and there are parallels between the two.</p></div>
<div class="paragraph"><p>Let&#8217;s look at another kind.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span>
<span class="kt">Either</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div></div></div>
<div class="paragraph"><p>Aha, this tells us that Either takes two concrete types as type parameters to produce a concrete type. It also looks kind of like a type declaration of a function that takes two values and returns something. Type constructors are curried (just like functions), so we can partially apply them.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="ow">::</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span>
<span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="ow">::</span> <span class="o">*</span>
</pre></div></div></div>
<div class="paragraph"><p>When we wanted to make Either a part of the Functor typeclass, we had to partially apply it because Functor wants types that take only one parameter while Either takes two. In other words, Functor wants types of kind * &#8594; * and so we had to partially apply Either to get a type of kind * &#8594; * instead of its original kind * &#8594; * &#8594; *. If we look at the definition of Functor again</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>we see that the f type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it&#8217;s used as the type of a value in a function. And from that, we can deduce that types that want to be friends with Functor have to be of kind * &#8594; *.</p></div>
<div class="paragraph"><p>Now, let&#8217;s do some type-foo. Take a look at this typeclass that I&#8217;m just going to make up right now:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">Tofu</span> <span class="n">t</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="ow">::</span> <span class="n">j</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="n">j</span>
</pre></div></div></div>
<div class="paragraph"><p>Man, that looks weird. How would we make a type that could be an instance of that strange typeclass? Well, let&#8217;s look at what its kind would have to be. Because j a is used as the type of a value that the tofu function takes as its parameter, j a has to have a kind of <strong>. We assume * for a and so we can infer that j has to have a kind of * &#8594; *. We see that t has to produce a concrete value too and that it takes two types. And knowing that a has a kind of * and j has a kind of * &#8594; *, we infer that t has to have a kind of * &#8594; (</strong> &#8594; *) &#8594; *. So it takes a concrete type (a), a type constructor that takes one concrete type (j) and produces a concrete type. Wow.</p></div>
<div class="paragraph"><p>OK, so let&#8217;s make a type with a kind of * &#8594; (* &#8594; *) &#8594; *. Here&#8217;s one way of going about it.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
data Frank a b  = Frank {frankField 
</dt>
<dd>
<p>
b a} deriving (Show)
How do we know this type has a kind of * &#8594; (* &#8594; <strong>) - &gt; *? Well, fields in ADTs are made to hold values, so they must be of kind *, obviously. We assume * for a, which means that b takes one type parameter and so its kind is * &#8594; *. Now we know the kinds of both a and b and because they&#8217;re parameters for Frank, we see that Frank has a kind of * &#8594; (</strong> &#8594; <strong>) &#8594; * The first * represents a and the (</strong> &#8594; *) represents b. Let&#8217;s make some Frank values and check out their types.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="s">&quot;HAHA&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">Maybe</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Node</span> <span class="sc">&#39;a&#39;</span> <span class="kt">EmptyTree</span> <span class="kt">EmptyTree</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Tree</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="s">&quot;YES&quot;</span><span class="p">}</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p>Hmm. Because frankField has a type of form a b, its values must have types that are of a similar form as well. So they can be Just "HAHA", which has a type of Maybe [Char] or it can have a value of [<em>Y</em>,<em>E</em>,<em>S</em>], which has a type of [Char] (if we used our own list type for this, it would have a type of List Char). And we see that the types of the Frank values correspond with the kind for Frank. [Char] has a kind of * and Maybe has a kind of * &#8594; *. Because in order to have a value, it has to be a concrete type and thus has to be fully applied, every value of Frank blah blaah has a kind of *.</p></div>
<div class="paragraph"><p>Making Frank an instance of Tofu is pretty simple. We see that tofu takes a j a (so an example type of that form would be Maybe Int) and returns a t a j. So if we replace Frank with j, the result type would be Frank Int Maybe.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Tofu</span> <span class="kt">Frank</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="n">x</span> <span class="ow">=</span> <span class="kt">Frank</span> <span class="n">x</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">(</span><span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="kt">Char</span> <span class="kt">Maybe</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="sc">&#39;a&#39;</span><span class="p">}</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tofu</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]</span> <span class="ow">::</span> <span class="kt">Frank</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="kt">[]</span>
<span class="kt">Frank</span> <span class="p">{</span><span class="n">frankField</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;HELLO&quot;</span><span class="p">]}</span>
</pre></div></div></div>
<div class="paragraph"><p>Not very useful, but we did flex our type muscles. Let&#8217;s do some more type-foo. We have this data type:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Barry</span> <span class="n">t</span> <span class="n">k</span> <span class="n">p</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span> <span class="n">yabba</span> <span class="ow">::</span><span class="n">p</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">::</span><span class="n">t</span> <span class="n">k</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>And now we want to make it an instance of Functor. Functor wants types of kind * &#8594; * but Barry doesn&#8217;t look like it has that kind. What is the kind of Barry? Well, we see it takes three type parameters, so it&#8217;s going to be something &#8594; something &#8594; something &#8594; <strong>. It&#8217;s safe to say that p is a concrete type and thus has a kind of *. For k, we assume * and so by extension, t has a kind of * &#8594; *. Now let&#8217;s just replace those kinds with the somethings that we used as placeholders and we see it has a kind of (</strong> &#8594; *) &#8594; * &#8594; * &#8594; *. Let&#8217;s check that with GHCI.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">k</span> <span class="kt">Barry</span>
<span class="kt">Barry</span> <span class="ow">::</span> <span class="p">(</span><span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span> <span class="ow">-&gt;</span> <span class="o">*</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ah, we were right. How satisfying. Now, to make this type a part of Functor we have to partially apply the first two type parameters so that we&#8217;re left with * &#8594; *. That means that the start of the instance declaration will be: instance Functor (Barry a b) where. If we look at fmap as if it was made specifically for Barry, it would have a type of fmap 
</dt>
<dd>
<p>
(a &#8594; b) &#8594; Barry c d a &#8594; Barry c d b, because we just replace the Functor&#8217;s f with Barry c d. The third type parameter from Barry will have to change and we see that it&#8217;s conviniently in its own field.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Barry</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="kt">Barry</span> <span class="p">{</span><span class="n">yabba</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span><span class="p">,</span> <span class="n">dabba</span> <span class="ow">=</span> <span class="n">y</span><span class="p">}</span>
<span class="kt">There</span> <span class="n">we</span> <span class="n">go</span><span class="o">!</span> <span class="kt">We</span> <span class="n">just</span> <span class="n">mapped</span> <span class="n">the</span> <span class="n">f</span> <span class="n">over</span> <span class="n">the</span> <span class="n">first</span> <span class="n">field</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>In this section, we took a good look at how type parameters work and kind of formalized them with kinds, just like we formalized function parameters with type declarations. We saw that there are interesting parallels between functions and type constructors. They are, however, two completely different things. When working on real Haskell, you usually won&#8217;t have to mess with kinds and do kind inference by hand like we did now. Usually, you just have to partially apply your own type to * &#8594; * or * when making it an instance of one of the standard typeclasses, but it&#8217;s good to know how and why that actually works. It&#8217;s also interesting to see that types have little types of their own. Again, you don&#8217;t really have to understand everything we did here to read on, but if you understand how kinds work, chances are that you have a very solid grasp of Haskell&#8217;s type system.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-09-28 03:27:21 EEST
</div>
</div>
</body>
</html>
