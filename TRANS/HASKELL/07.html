<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_">Модулі</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__">Завантаження модулів</h3>
<div class="paragraph"><p><span class="image">
<img src="images/modules.png" alt="images/modules.png" />
</span>
Модуль Haskell є колекцією пов'язаних функцій, типів та типокласів. Програма Haskell є колекцією модулів, де головний модул завантажує інші модулі, та потім використовує функції, визначені в них, щоб зробити дещо. Мати код поділеним на декілька модулів має досить багато переваг. Якщо модуль досить загальний, функції, які він експортує, можуть бути використані в безлічі різних програм. Якщо ваш власний код поділений на само-достатні модулі, що не покладаються один на одний дуже сильно (ми кажемо що вони слабко пов'язані), в падольшому ви можете використовувати їх. Це робить всю справу написання коду більш керованою, маючи поділеним його на окремі частини, кожна з яких має власне призначення.</p></div>
<div class="paragraph"><p>Стандартна бібліотека Haskell поділена на модулі, кожний з них містить функції та типи, які деяким чином пов'язані та служать деякій загальній цілі. Є модуль для маніпуляцій зі списками, модуль для конкурентного програмування, модуль для справ з комплексними числами, тощо. Всі функції, типи та типокласи, з якими ми досі мали справу, були частиною модуля <code>Prelude</code>, що імпортується по замовчанню. В цій главі ми збираємось дослідити декілька корисних модулів та функцій, що вони мають. Але спочатку ми збираємось подивитись, як імпортувати модулі.</p></div>
<div class="paragraph"><p>Синтаксис для імпортування модулів в скрипті Haskell є <code>import &lt;module name&gt;</code>. Це має бути зроблене перед визначенням любих функцій, так що імпорти звичайно робляться зверху файла. Звичайно, один скрипт може імпортувати декілька модулів. Просто покладіть кожний імпорт в окремий рядок. Давайте імпортуємо модуль <code>Data.List</code>, що має декілька корисних функцій для роботи зі списками, та використаємо функцію, що він експортує, для створення функції, що каже нам, як багато унікальних елементів має наш список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">numUniques</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">numUniques</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">nub</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви робите <code>import Data.List</code>, всі функції, що експортує <code>Data.List</code>, стають доступними в глобальному просторі імен, що значить, що ви можете викликати їх будь-деme в скрипті. <code>nub</code> є функція, визначена в <code>Data.List</code>, що приймає список і відкидає дубліковані елементи. Компонуючи <code>length</code> та <code>nub</code> роблячи <code>length . nub</code> продукує функцію, що еквівалентна до <code>\xs -&gt; length (nub xs)</code>.</p></div>
<div class="paragraph"><p>Ви також можете покласти функції модулів в глобальний простір імен при використанні GHCI. Якщо ви в GHCI, і ви бажаєте бути в змозі викликати функції, експортовані <code>Data.List</code>, зробіть це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте завантажити імена з декількох модулів всередині GHCI, ми не маємо робити <code>:m +</code> декілька раз, ми можемо просто завантажити декілька модулів за один раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ви завантажили скрипт, що вже імпортує модуль, вам не треба використовувати <code>:m +</code> щоб отримати доступ до нього.</p></div>
<div class="paragraph"><p>Якщо вам просто треба пара функцій з модуля, ви можете вибірково імпортувати лише ці функції. Якщо ви бажаєте імпортувати тільки функції <code>nub</code> та <code>sort</code> з <code>Data.List</code>, ми робимо так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">nub</span><span class="p">,</span> <span class="nf">sort</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете також обрати імпорт всіх функцій з модуля, за винятком декількох обраних. Це часто корисно, коли декілька модулів експортують функції з тим самим іменем, і ви бажаєте прибрати заважаючі варіанти. Скажімо, ми вже маємо нашу власну функцію, що називається <code>nub</code>, і ми бажаємо імпортувати всі функції з <code>Data.List</code>, за винятком функції <code>nub</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">nub</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший шлях мати справу з класами з перетином імен - робити кваліфіковані імпорти. Модуль <code>Data.Map</code>, що пропонує структуру даних для пошуку значень по ключу, експортує декілька функцій з тими ж назвами, що і функції <code>Prelude</code>, як <code>filter</code> або <code>null</code>. Так що коли ми імпортуємо <code>Data.Map</code> і потім викликаємо <code>filter</code>, Haskell не знає, яку функцію використовувати. Ось як ми вирішуємо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить так, що коли ми бажаємо посилатись на функцію <code>Data.Map</code>  <code>filter</code>, ми маємо робити <code>Data.Map.filter</code>, коли тільки <code>filter</code> все ще посилається на нормальний <code>filter</code>, який ми всі знаємо і любимо. Але набір <code>Data.Map</code> перед кожною функцію з цього модуля є дещо обтяжливо. Осі чому ми можемо переіменувати кваліфікований імпорт на дещо коротше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер для посилання на функцію <code>Data.Map</code> <code>filter</code> ми виристовуємо лише <code>M.filter</code>.</p></div>
<div class="paragraph"><p>Використовуйте це зручне посилання, щоб побачити, які модулі є в стандартній бібліотеці. Гарний спосіб отримати нове знання щодо Haskell є просто клацати по посиланню стандартної бібліотеки, та досліджувати модулі та їх функції. Ви можете також передивлятись джерельний код Haskell для кожного модуля. Читання джерельного коду для деяких модулів є дійсно гарним шляхом вивчати Haskell та отримати солідне відчуття мови.</p></div>
<div class="paragraph"><p>Для пошуку функцій або для пошуку, де вони розташовані, використовуйте <code>Hoogle</code>. Це дійсно неймовірна пошукова система Haskell, ви можете шукати по імені, імені модуля або навіть сигнатурі типу.</p></div>
</div>
<div class="sect2">
<h3 id="_data_list">Data.List</h3>
<div class="paragraph"><p>Модуль <code>Data.List</code> це все про списки, це очевидно. Він провадить деякі дуже корисні функції для роботи з ними. Ми вже зустрічались з деяким з ціх функцій (як <code>map</code> та <code>filter</code>), оскільки модуль <code>Prelude</code> експортує деякі функції з <code>Data.List</code> для зручності. Ви не маєте імпортувати <code>Data.List</code> через кваліфікований імпорт, оскільки його імена не перетинаються з жодними іменами <code>Prelude</code>, за винятком тих, що <code>Prelude</code> вже краде у <code>Data.List</code>. Давайте поглянемо на деякі функції, з якими ми раніше не зустрічались.</p></div>
<div class="paragraph"><p><code>intersperse</code> бере елемент та список, і потім покладає цей елемент між кожною парою елементів списка. Ось демонстрація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="sc">&#39;.&#39;</span> <span class="s">&quot;MONKEY&quot;</span>
<span class="s">&quot;M.O.N.K.E.Y&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intercalate</code> бере лист список списків, і список. Потім він вставляє цей список між всіма ціма списками, і потім сплощує результат.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="s">&quot; &quot;</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there guys&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>transpose</code> траспонує список списків. Якщо ви подивитесь на список списків як на 2D матрицю, стовпчики стають рядками та навпаки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;htg&quot;</span><span class="p">,</span><span class="s">&quot;ehu&quot;</span><span class="p">,</span><span class="s">&quot;yey&quot;</span><span class="p">,</span><span class="s">&quot;rs&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Скажімо, ми маємо поліноми <code>3x2 + 5x + 9</code>, <code>10x3 + 9</code> та <code>8x3 + 5x2 + x - 1</code> і ми бажаємо додати їх разом. Ми можемо використати списки <code>[0,3,5,9]</code>, <code>[10,0,0,9]</code> та <code>[8,5,1,-1]</code> для представлення їх в Haskell. Тепер щоб додати їх, все що треба зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми транспонуємо ці три списки, три куби опиняться в першому рядку, квадрати в другому, і так далі. Відображуючи <code>sum</code> на це продукує бажаний результат.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lists.png" alt="images/lists.png" />
</span>
<code>foldl'</code> та <code>foldl1'</code> є суворіші версії відносно до своїх лінивих інкарнацій. Коли використовуються ліниві згортки на дійсно списках, часто ви можете отримати помилку переповнення стеку. Винуватцем цього є те, що через ліниву природу згорток значення аккумулятора насправді не оновлюється по мірі згортки. Що насправді відбувається, це те, що аккумулятор робить свого роду обіцянки, що віе обчислить своє значення, коли попросять дійсно зпродукувати результат (що також називається грім). Це відбувається для кожного проміжного аккумулятора, і всі ці громи переповнюють ваш стек. Сувора згортка не така лінива істота, та насправді обчислює проміжні значення по мірі надходження, замість заповнювати ваш стек. Так що якщо ви колись отримаєте переповнення стеку роблячи ліниві згортки, спробуйте переключитись на їх суворі версії.</p></div>
<div class="paragraph"><p><code>concat</code> зрівнює список списків в просто список елементів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="s">&quot;car&quot;</span><span class="p">]</span>
<span class="s">&quot;foobarcar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Він буде видаляти лише один рівень вкладення. Так що якщо ви бажаете повністю сплющити <code>[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</code>, що є списком списків списків, ви маєте виконати конкатенацію двічі.</p></div>
<div class="paragraph"><p>Виконання <code>concatMap</code> є те саме, що спочатку відобразити функцію на список, та потім конкатувати список <code>concat</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>and</code> бере список логічних значень, та повертає <code>True</code> тільки якщо всі значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>or</code> подібне до <code>and</code>, тільки повертає <code>True</code> якщо любе логічне значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>any</code> та <code>all</code> беруть предикат, та потім перевіряють, чи якісь або всі елементи списку задовільняють предикату, відповідно. Звичайно ми використовуємо ці дві функції замість відображення по списку, та потім робити <code>and</code> або <code>or</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>iterate</code> бере функцію та початкове значення. Вона застосовує функцію до стартового значення, потім вона застосовує цю функцію до результату знову, тощо. Вона повертає всі результати в формі безкінечного списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span> <span class="s">&quot;haha&quot;</span>
<span class="p">[</span><span class="s">&quot;haha&quot;</span><span class="p">,</span><span class="s">&quot;hahahaha&quot;</span><span class="p">,</span><span class="s">&quot;hahahahahaha&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>splitAt</code> бере число та список. Потім вона розділяє список на це число елементів, повертаючи два списки як тапл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;man&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">100</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;heyman&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;heyman&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;foobar&quot;</span> <span class="kr">in</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
<span class="s">&quot;barfoo&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>takeWhile</code> є дійсно корисною невеликою функцією. Вона бере елементи зі списку доки виконується предикат, та коли трепиться елемент, що не задовільняє, вона відсікає всі інші. Як з'ясовується ще дуже корисно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Скажімо, ми бажаємо знати суму всіх третіх ступінів, що є до <code>10000</code>. Ми не можемо зробити <code>map (^3)</code> до <code>[1..]</code>, застосувати <code>filter</code> та потім спробувати підсумувати все це, бо фільтр на безкінечному спіску ніколи не завершиться. Ви можете знати, що всі елементи ідуть по зростанню, але Haskell ні. Ось чому ми можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="mi">53361</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми застосовуємо <code>(^3)</code> до безкінечного списку, та потім, коли це буде більше <code>10000</code>, список буде обрізаний. Тепер ми можемо його легко підсумувати.</p></div>
<div class="paragraph"><p><code>dropWhile</code> є подібним, тільки вона відкидає всі елементи, доки виконується предикат. Як тільки предикат дорівнює <code>False</code>, вона повертає залишок списку. Вкрай корисна і мила функція!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot; is a sentence&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми надали список, що представляє значення акцій по даті. Список складається з таплів, чий перший компонент є значення курсу акцій, другий елемент рік, третій місяць а четвертий дата. Ми бажаємо знати, коли значення акцій вперше перевищило тисячу доларів!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stock</span> <span class="ow">=</span> <span class="p">[(</span><span class="mf">994.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mf">995.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mf">999.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mf">998.3</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">(</span><span class="n">dropWhile</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="n">stock</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>span</code> дещо як <code>takeWhile</code>, тільки він повертає пару списків. Перший список містить все, що містив би результуючий список <code>takeWhile</code>, коли б ми викликали його з тим самим предикатом та тим самим списком. Другий список містить частину списку, що мала б бути відкинутою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span> <span class="kr">in</span> <span class="s">&quot;First word:&quot;</span> <span class="o">++</span> <span class="n">fw</span> <span class="o">++</span> <span class="s">&quot;, the rest:&quot;</span> <span class="o">++</span> <span class="n">rest</span>
<span class="s">&quot;First word: This, the rest: is a sentence&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як <code>span</code> поділяє список доки предикат вірний, <code>break</code> перериває коли предикат стає перший раз <code>True</code>. Зробити <code>break p</code> є еквівалентним зробити <code>span (not . p)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>При використанні <code>break</code>, другий список в результаті буде починатись з першого елементу, що задовільняє предикату.</p></div>
<div class="paragraph"><p><code>sort</code> просто сортує список. Тип елементів в списку має бути частиною типокласу <code>Ord</code>, оскільки якщо елементи списку не можуть бути покладені в деякому порядку, тоді такий список неможливо відсортувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="s">&quot;This will be sorted soon&quot;</span>
<span class="s">&quot;    Tbdeehiillnooorssstw&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>group</code> бере список та групує сусідні елементи в субсписки, якщо вони рівні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми вортуємо список перед групуванням, ми можемо знайти, скільки разів кожний елемент з'являється в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">length</span> <span class="n">l</span><span class="p">))</span> <span class="o">.</span> <span class="n">group</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>inits</code> та <code>tails</code> подібні до <code>init</code> та <code>tail</code>, тільки вони рекурсивно застосовуються до списку, доки нічого не залишиться. Дослідимо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">inits</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tails</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">w</span> <span class="ow">=</span> <span class="s">&quot;w00t&quot;</span> <span class="kr">in</span> <span class="n">zip</span> <span class="p">(</span><span class="n">inits</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">tails</span> <span class="n">w</span><span class="p">)</span>
<span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">),(</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">),(</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">),(</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">),(</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте використаємо <code>fold</code> для реалізації пошуку підсписку в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">search</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">search</span> <span class="n">needle</span> <span class="n">haystack</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">nlen</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">needle</span>
    <span class="kr">in</span>  <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">take</span> <span class="n">nlen</span> <span class="n">x</span> <span class="o">==</span> <span class="n">needle</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="n">tails</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Спочатку ми викликаємо <code>tails</code> зі списком, в якому ми шукаємо. Потім ми проходимо по кожному хвосту, та дивимось, чи він починається з того, що ми шукаємо.</p></div>
<div class="paragraph"><p>Маючи це, ми насправді лише зробили функцію, що поводиться як <code>isInfixOf</code>. <code>isInfixOf</code> шукає субсписок, та повертає <code>True</code>, якщо субсписок, що ми шукаємо, десь всередині цільового списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cats&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>isPrefixOf</code> та <code>isSuffixOf</code> шукають субсписок напочатку та в кінці списку, відповідно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elem</code> та <code>notElem</code> перевіряють, чи елемент є або його немає в списку.</p></div>
<div class="paragraph"><p><code>partition</code> бере список та предикат, та повертає пару списків. Перший список в результаті містить всі списки, що задовільняють предикату, другий містить всі що не задовільняють.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOBMORGAN&quot;</span><span class="p">,</span><span class="s">&quot;sidneyeddy&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Важливо розуміти, як це відрізняється від <code>span</code> та <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOB&quot;</span><span class="p">,</span><span class="s">&quot;sidneyMORGANeddy&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли <code>span</code> та <code>break</code> завершуються коли вони натраплять на перший елемент, що не- або задовільняє предикату, <code>partition</code> проходить по цілому списку, та розділяє його відповідно предиката.</p></div>
<div class="paragraph"><p><code>find</code> бере список та предикат, та повертає перший елемент, що задовільняє предикату. Але він повертає цей елемент огорнутим в значення <code>Maybe</code>. Ми будемо розглядати алгебраїчні типи даних більш детально в наступній главі, але доки це все що ви маєте знати: значення <code>Maybe</code> може бути або <code>Just</code> дещо або <code>Nothing</code>. Так само, як список може бути або порожнім, або списком з якимось елементами, значення <code>Maybe</code> може бути або без елементів, або мати один елемент. І так само, як тип списку, скажімо, цілих є <code>[Int]</code>, тип можливо цілого значення є <code>Maybe Int</code>. В жодному разі розкрутимо нашу функцію <code>find</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">find</span>
<span class="nf">find</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте тип <code>find</code>. Його результат є <code>Maybe a</code>. Це майже так само, як мати тип <code>[a]</code>, тільки значення типу <code>Maybe</code> можуть містити або елемент, або нічого, тоді як список може не мати жодного, мати один або мати декілька елементів.</p></div>
<div class="paragraph"><p>Згадайте, як ми шукали, коли перший раз наші акції дійшли більше <code>$1000</code>. Ми робили <code>head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</code>. Згадайте, що <code>head</code> насправді не досить безпечна. Що має трапитись, якщо курс ніколи не доходить за <code>$1000</code>? Наше застосування <code>dropWhile</code> буде повертати порожній список, та отримання <code>head</code> від порожнього списку призведе до помилки. Однак якщо ми перепишемо це як <code>(\(val,y,m,d) -&gt; val &gt; 1000) stock</code>, ми будемо значно безпечніше. Якщо наші акції ніколи не заходять за <code>$1000</code> (так що немає жодного елементу, що задовільняє предикату), ми отримуємо назад <code>Nothing</code>. Але якщо в списку була валідна відповідь в списку, ми б отримали б, скажімо <code>Just (1001.4,2008,9,4)</code>.</p></div>
<div class="paragraph"><p><code>elemIndex</code> є різновидом <code>elem</code>, тільки він не повертає логічне значення. Він можливо повертає індекс елемента, який ми шукаємо. Якщо такого елемента немає в нашому списку, він повертає <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">elemIndex</span>
<span class="nf">elemIndex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elemIndices</code> подібна до <code>elemIndex</code>, тільки вона повертає список індексів, в випадку, коли елемент що ми шукаємо знаходиться в нашому списку декілька раз. Оскільки ми використовуємо список для представлення індексов, нам не треба тип <code>Maybe</code>, тому невдача може бути представлена як порожній список, що є досить синонімичнім до <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39; &#39;</span> <span class="p">`</span><span class="n">elemIndices</span><span class="p">`</span> <span class="s">&quot;Where are the spaces?&quot;</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>findIndex</code> подібне до <code>find</code>, але вона можливо повертає індекс першого елемента, що задовільняє предикату. <code>findIndices</code> повертає індекси всіх елементів, що задовільняють предикату в формі списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndices</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;Where Are The Caps?&quot;</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми вже розглядали <code>zip</code> та <code>zipWith</code>. Ми зауважили, що вони поеднують разом два списки, або в тапл, або за допомогою двомісної функції (що означає, що функція приймає два параметра). Але що, коли ви бажаєте поеднати разом три списки? Або поєднати три списки за допомогою функції, що приймає три параметри? Гаразд, для цього ми маємо <code>zip3</code>, <code>zip4</code>, тощо, та <code>zipWith3</code>, <code>zipWith4</code>, etc. Ці варіанти ідуть до <code>7</code>. Хоча це може виглядати як хак, це робить досить гарно, оскільки не дуже часто трапляються випадки, коли вам треба поєднати 8 списків. Також існую розумний спосіб поєднати довільне число списків, але ми не досить просунулись, щоб розглядати його прямо тут.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith3</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip4</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Так само, як з нормальним поєднанням, списки, що довші ніж найкоротший список, відсікаються до його розміру.</p></div>
<div class="paragraph"><p><code>lines</code> є корисною функцією, коли маємо справу з файлами або ввод від чогось іншого. Вона приймає рядок, та повертає кожний рядок в окремий список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line&quot;</span>
<span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span><span class="s">&quot;second line&quot;</span><span class="p">,</span><span class="s">&quot;third line&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>'\n'</code> є символ для нового рядка Юнікс. Зворотні косі мають особливе значення в Haskell рядках та символах.</p></div>
<div class="paragraph"><p><code>unlines</code> є зворотньою до <code>lines</code> функцією. Вона приймає список рядків, та потім поєднує їх разом з використанням <code>'\n'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unlines</span> <span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span> <span class="s">&quot;second line&quot;</span><span class="p">,</span> <span class="s">&quot;third line&quot;</span><span class="p">]</span>
<span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>words</code> та <code>unwords</code> призначені для поділу рядка тексту на слова, або поєднання списку слов в текст. Дуже корисно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these are the words in this sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these           are    the words in this</span><span class="se">\n</span><span class="s">sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unwords</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;mate&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there mate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми вже згадували <code>nub</code>. Він бере список та відкидає дублікати елементів, повертаючи список, кожний елемент якого є унікальною сніжинкою! Функція має дещо дивне ім'я. Виявляється, що <code>"nub"</code> означає малу грудку або головну частину чогось. По-моєму для назв функцій треба використовувати справжні слова, замість застарілих.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;Lots of words and stuff&quot;</span>
<span class="s">&quot;Lots fwrdanu&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>delete</code> бере елемент і список, і видаляє перше входження елемента в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey there ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere gang!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>\\</code> є функцією різниці. Вона діє як різниця множин, в основному. Для кожного елементу зправа вона видаляє елемент в лівому списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">\\</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Im a big baby&quot;</span> <span class="o">\\</span> <span class="s">&quot;big&quot;</span>
<span class="s">&quot;Im a  baby&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зробити <code>[1..10] \\ [2,5,9]</code> це як зробити <code>delete 2 . delete 5 . delete 9 $ [1..10]</code>.</p></div>
<div class="paragraph"><p><code>union</code> також діє як функція на множинах. Вона повертає поєднання двох списків. Вона добряче проходиться по кожному елементу в другому списку, та додає його до першого, якщо його там ще немає. Однак начувайтесь, дублікати видаляються з другого списку!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey man&quot;</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="s">&quot;man what&#39;s up&quot;</span>
<span class="s">&quot;hey manwt&#39;sup&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intersect</code> робить як перетин множин. Вона повертає тільки ті елементи, що знайдені в обох списках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">intersect</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insert</code> бере елемент та список, що може бути відсортований, та вставляє його в останню позицію, де він все ще меньший або рівний наступному елементу. Іншими словами <code>insert</code> буде починати на початку списку, та потім продовжувати, доки не знайде елемент, що більше або дорівнює нашому елементу, який він вставляє, і робить вставку перед цім елементом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>4</code> вставлене прямо після <code>3</code> та перед <code>5</code> в першому прикладі, та між <code>3</code> і <code>4</code> в другому прикладі.</p></div>
<div class="paragraph"><p>Якщо ми вставляємо в відсортований список, отриманий список буде також відсортований.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="sc">&#39;g&#39;</span> <span class="o">$</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;f&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;h&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що загального між <code>length</code>, <code>take</code>, <code>drop</code>, <code>splitAt</code>, <code>!!</code> та <code>replicate</code>, це те, що вони приймають <code>Int</code> в якості одного з параметрів (або повертають <code>Int</code>), навіть якщо вони могли б бути більш загальними та корисними, якщо б вони приймали любий тип, що є частиною типокласів <code>Integral</code> або <code>Num</code> (в залежності від функцій). Вони роблять це з історичних причин. Однак виправлення цього можливо зламає безліч існуючого коду. Ось чому <code>Data.List</code> має власні більш загальні еквіваленти, названі <code>genericLength</code>, <code>genericTake</code>, <code>genericDrop</code>, <code>genericSplitAt</code>, <code>genericIndex</code> та <code>genericReplicate</code>. Наприклад, довжина має сигнатуру типу <code>length::[a] -&gt; Int</code>. Якщо ми спробуємо отримати середнє від списку чисел, виконавши <code>let xs = [1..6] in sum xs / length xs</code>, ми отримаємо помилку типу, оскільки ви не можете використовувати <code>/</code> з <code>Int</code>. З іншого боку <code>genericLength</code> має сигнатуру <code>genericLength::(Num a) =&gt; [b] -&gt; a</code>. Оскільки <code>Num</code> може діяти як число з плаваючою крапкою, взяття середнього через виконання <code>let xs = [1..6] in sum xs / genericLength xs</code> робить гарно.</p></div>
<div class="paragraph"><p>Функції <code>nub</code>, <code>delete</code>, <code>union</code>, <code>intersect</code> та <code>group</code> всі мають свої більш загальні варіанти на ім'я <code>nubBy</code>, <code>deleteBy</code>, <code>unionBy</code>, <code>intersectBy</code> та <code>groupBy</code>. Різниця між ними в тому, що перший набір функцій використовує <code>==</code> для перевірки на рівність, тоді як <code>By</code> варіанти також приймають функцію еквівалентності, та потім порівнюють з використанням цієї функції. <code>group</code> є те ж саме, що і <code>groupBy (==)</code>.</p></div>
<div class="paragraph"><p>Наприклда, скажімо ми маємо список, що описує значення функції для кожної секунди. Ми бажаємо поділити її на субсписки, базуючись на тому, чи значення меньше або більше нуля. Якщо ми зробимо лише звичайне групування, це лише згрупує сусідні однакові значення. Але ми бажаємо згрупувати на основі того, чи воні від'ємні чи ні. Ось де з'являється <code>groupBy</code>! Функція еквівалентності, що надається до функцій <code>By</code>, повинні приймати две елементи того самого типу, і повертати <code>True</code>, якщо вони рівні за її стандартами.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">values</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.9</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mf">29.1</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>З цього ми ясно бачимо, які частини є додатними, та які від'ємними. Надана функція рівності приймає два елементи, та потім повертає <code>True</code>, тільки якщо обоє є від'ємними або обоє додатними. Цю функцію рівності також можна записати як <code>\x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)</code>, хоча я думаю, що перший варіант краще читається. Навіть ясніший спосіб написати функцію рівності для функцій <code>By</code> є імпортувати функцію <code>on</code> з <code>Data.Function</code>. <code>on</code> визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">on</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що зробити <code>(==) ``on`</code> (&gt; 0)` повертає функцію рівності, що виглядає як <code>\x y -&gt; (x &gt; 0) == (y &gt; 0)</code>. <code>on</code> використовується з функціями <code>By</code>, бо з ним ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span> <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Вочевидь гарно читається! Ви можете прочитати це вголос: згрупувати це за рівністю, що настає коли елементи більші нуля.</p></div>
<div class="paragraph"><p>Подібним чином <code>sort</code>, <code>insert</code>, <code>maximum</code> та <code>minimum</code> також мають свої більш загальні еквіваленти. Функції як <code>groupBy</code> беруть функцію, що визначає, коли два елементи рівні. <code>sortBy</code>, <code>insertBy</code>, <code>maximumBy</code> та <code>minimumBy</code> беруть функцію, що визначає, чи елемент більший, меньший або рівний до іншого. Сигнатура типу <code>sortBy</code> є <code>sortBy::( a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>. Якщо ви пам'ятаєте з попереднього, тип <code>Ordering</code> має значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. <code>sort</code> еквівалентна до <code>sortBy compare</code>, оскільки тільки приймає два елементи, чиї типи в типокласі <code>Ord</code>, та повертає їх відношення впорядкування.</p></div>
<div class="paragraph"><p>Списки можуть бути порівняні, пле при цьому вони порівнюються лексографічно. Що, коли ми маємо список списків, та ми бажаємо сортувати їх не на основі їх вмісту, а на основі їх довжини? Так, ви майже здогадались, ми будемо використовувати функцію <code>sortBy</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sortBy</span> <span class="p">(</span><span class="n">compare</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">length</span><span class="p">)</span> <span class="n">xs</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Неймовірно! <code>compare `on`</code> <code>length</code> &#8230; це читається майже як англійська! Якщо ви не впевнені, як саме це тут робить, <code>compare `on`</code> <code>length</code> еквівалентне до <code>\x y -&gt; length x `compare`</code> <code>length y</code>. Коли ви маєте справу з функціями <code>By</code>, що приймають функцію рівності, ви зазвичай робите <code>(==) `on`</code> <code>something</code>, та коли ви маєте справу з функціями <code>By</code>, що приймають функцію впорядкування, ви зазвичай робите <code>compare `on`</code> <code>something</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_data_char">Data.Char</h3>
<div class="paragraph"><p><span class="image">
<img src="images/legochar.png" alt="images/legochar.png" />
</span>
Модуль <code>Data.Char</code> робить те, на що натякає його ім'я. Він експортує функції, що мають справи з символами. Це також корисне при фільтруванні та відображенні з рядками, бо вони є лише списками символів.</p></div>
<div class="paragraph"><p><code>Data.Char</code> експортує декілька предикатів над символами. Тобто функцій, що приймають символ, та кажуть, чи справджується деяке припущення щодо нього. Ось як це виглядає:</p></div>
<div class="paragraph"><p><code>isControl</code> перевіряє, чи символ є символом керування.</p></div>
<div class="paragraph"><p><code>isSpace</code> перевіряє, чи символ є проміжком. Це включає проміжки, табуляції, нові рядки, тощо.</p></div>
<div class="paragraph"><p><code>isLower</code> перевіряє, чи символ в нижньому реєстрі.</p></div>
<div class="paragraph"><p><code>isUpper</code> перевіряє, чи символ в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAlpha</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isAlphaNum</code> перевіряє, чи символ є літерою або цифрою.</p></div>
<div class="paragraph"><p><code>isPrint</code> перевіряє, чи символ є друкованим. Наприклад, керівні символи не друкуються.</p></div>
<div class="paragraph"><p><code>isDigit</code> перевіряє, чи символ є цифрою.</p></div>
<div class="paragraph"><p><code>isOctDigit</code> перевіряє, чи символ є восьмиричним символом.</p></div>
<div class="paragraph"><p><code>isHexDigit</code> перевіряє, чи символ є шістнацятиричною цифрою.</p></div>
<div class="paragraph"><p><code>isLetter</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isMark</code> перевіряє щодо символів маркування Unicode. Це символи, що комбінуються з попередніми символами для формування літер з наголосами та умулятами. Використовуйте це, якщо ви француз.</p></div>
<div class="paragraph"><p><code>isNumber</code> перевіряє, чи символ є числом.</p></div>
<div class="paragraph"><p><code>isPunctuation</code> перевіряє, чи символ є пунктуацією.</p></div>
<div class="paragraph"><p><code>isSymbol</code> перевіряє, чи символ є незвичайним математичним або символом валют.</p></div>
<div class="paragraph"><p><code>isSeparator</code> перевіряє на проміжки та роздільники Unicode.</p></div>
<div class="paragraph"><p><code>isAscii</code> перевіряє, чи символ підпадає в перші 128 символів набору символів Unicode.</p></div>
<div class="paragraph"><p><code>isLatin1</code> перевіряє, чи символ підпадає в перші 256 символів Unicode.</p></div>
<div class="paragraph"><p><code>isAsciiUpper</code> перевіряє, чи символ ASCII в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAsciiLower</code> перевіряє, чи символ ASCII в нижньому реєстрі.</p></div>
<div class="paragraph"><p>Всі ці предикати мають сигнатуру типу <code>Char -&gt; Bool</code>. Більшість часу ви будете використовувати їх для фільтрування рядків або чогось подібного. Наприклад, скажімо, ми робимо програму, що приймає ім'я користувачи, та це ім'я може складатись тільки з літер та цифр. Ми можемо використовувати функцію <code>Data.List</code> <code>all</code> в комбінації з предикатами <code>Data.Char</code> для визначення, чи ім'я користувача в порядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;bobby283&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;eddy the fish!&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто. В випадку якщо ви не пам'ятаєте, <code>all</code> приймає предикат та список, та повертає <code>True</code> тільки якщо предикат дотримується для всіх елементів в списку.</p></div>
<div class="paragraph"><p>Ми також можемо використовувати <code>isSpace</code> для симуляції функції <code>Data.List</code> <code>words</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Хмм, гарно, це робить майже те саме що робить <code>words</code>, але ми залишились з елементами, що містять тільки проміжки. Хмм, то що ми маємо робити? Я знаю, просто відфільтруемо цей непотріб.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">any</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">.</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">$</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось так.</p></div>
<div class="paragraph"><p><code>Data.Char</code> також імпортує тип даних що подібний до <code>Ordering</code>. Тип <code>Ordering</code> може мати значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. Це різновид переліку. Він описує декілька можливих результатів, що можуть виникнути від порівняння двох елементів. Тип <code>GeneralCategory</code> також є переліком. Він презентує декілька можливих категорій, до яких може належати символ. Головна функція для отримання загальної категорії символа є <code>generalCategory</code>. Вона має тип <code>generalCategory ::Char -&gt; GeneralCategory</code>. Існує близько <code>31</code> категорій, так що ми не будемо перелічувати їх тут, але пограємось з функцією.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39; &#39;</span>
<span class="kt">Space</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;A&#39;</span>
<span class="kt">UppercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">LowercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;.&#39;</span>
<span class="kt">OtherPunctuation</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;9&#39;</span>
<span class="kt">DecimalNumber</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">generalCategory</span> <span class="s">&quot; </span><span class="se">\t\n</span><span class="s">A9?|&quot;</span>
<span class="p">[</span><span class="kt">Space</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">UppercaseLetter</span><span class="p">,</span><span class="kt">DecimalNumber</span><span class="p">,</span><span class="kt">OtherPunctuation</span><span class="p">,</span><span class="kt">MathSymbol</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки тип <code>GeneralCategory</code> є частиною типокласу <code>Eq</code>, ми можемо також перевірити дещо, наприклад <code>generalCategory c == Space</code>.</p></div>
<div class="paragraph"><p><code>toUpper</code> конвертує символ в верхній реєстр. Проміжки, числа та все подібне залишається без змін.</p></div>
<div class="paragraph"><p><code>toLower</code> конвертує символи в нижній реєстр.</p></div>
<div class="paragraph"><p><code>toTitle</code> конвертує символ в заглавні. Для більшості символів це те саме, що верхній реєстр.</p></div>
<div class="paragraph"><p><code>digitToInt</code> конвертує символ до <code>Int</code>. Щоб це було успішним символ має бути в диапазоні <code>'0'..'9'</code>, <code>'a'..'f'</code> або <code>'A'..'F'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;34538&quot;</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;FF85AB&quot;</span>
<span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intToDigit</code> є інверсною функцією до <code>digitToInt</code>. Вона приймає <code>Int</code> в диапазоні <code>0..15</code> та конвертує його в символ нижнього реєстра.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">15</span>
<span class="sc">&#39;f&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">5</span>
<span class="sc">&#39;5&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції <code>ord</code> та <code>chr</code> конвертують символи до відповідних чисел та навпаки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ord</span> <span class="sc">&#39;a&#39;</span>
<span class="mi">97</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chr</span> <span class="mi">97</span>
<span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">ord</span> <span class="s">&quot;abcdefgh&quot;</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Різниця між <code>ord</code> значеннями двох символів дорівнює тому, як далеко вони в таблиці Unicode.</p></div>
<div class="paragraph"><p>Шифр Цезаря є примітивним методом кодування повідомлень, зсуваючи кожний символ в повідомленні на фіксований число позицій в абетці. Ми можемо просто створити різновид шифра Цезаря, тільки ми не будемо обмежувати себе абеткою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">encode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">encode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">ords</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">ord</span> <span class="n">msg</span>
        <span class="n">shifted</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="n">ords</span>
    <span class="kr">in</span>  <span class="n">map</span> <span class="n">chr</span> <span class="n">shifted</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми зпочатку конвертуємо рядок в список чисел. Потім ми додаємо сзув до кожного значення перед конвертації списку назад до символів. Якщо ви ковбой композиції, ви можете записати тіло цієї функції як <code>map (chr . (+ shift) . ord) msg</code>. Давайте спробуємо закодувати декілька повідомлень.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Khhhhh|&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">4</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Liiiii}&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">1</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;bcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">5</span> <span class="s">&quot;Marry Christmas! Ho ho ho!&quot;</span>
<span class="s">&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Все закодовується гарно. Декодування повідомлення є в основному зсув назад на число позицій, на яке воно було спочатку зсунуте.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">decode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">decode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span> <span class="n">encode</span> <span class="p">(</span><span class="n">negate</span> <span class="n">shift</span><span class="p">)</span> <span class="n">msg</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Im a little teapot&quot;</span>
<span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">3</span> <span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="s">&quot;Im a little teapot&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">5</span> <span class="o">.</span> <span class="n">encode</span> <span class="mi">5</span> <span class="o">$</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This is a sentence&quot;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_data_map">Data.Map</h3>
<div class="paragraph"><p>Асоціативні списки (також називаються словниками) є списками, що використовуються для зберігання пар ключ-значення, коли порядок не має значення. Наприклад, ми можемо використовувати асоціативний список для зберігання номерів телефонів, де номери телефонів будуть значеннями, а імена людей будуть ключами. Нам байдуже в якому порядку вони зберігаються, ми просто хочемо отримати правильний номер телефону для певної особи.</p></div>
<div class="paragraph"><p>Найбільш очевидний шлях представити асоціативні списки в Haskell буде використання списку пар. Перший компонент в парі буде ключем, другий компонент значення. Ось приклад асоціативного списку з номерами телефонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Не зважаючи на ці досить дивні відступи це все ще пари рядків. Найбільш загальна задача коли маємо справу з асоціативними списками є пошук значення по ключу. Давайте створимо функцію, що шукає деяке значення по ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить просто. Функція, що бере ключ та список, фільтрує список так, що залишаються лише співпадаючі ключі, бере першу пару ключ-значення та повертає значення. Але що трапляється, якщо ключ що ми шукаємо відсутній в асоціативному списку? Хмм. В даному випадку якщо ключа немає в списку ми скінчимо беручи <code>head</code> від порожнього списку, що закидає помилку часу виконання. Однак нам слідує уникати таких простих катастроф нашої програми, так що використаємо тип даних <code>Maybe</code>. Якщо ми не знайшли ключ ми повертаємо <code>Nothing</code>. Якщо ми знайшли його, ми повертаємо <code>Just</code> дещо, де дещо це значення, що відповідає ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>
                            <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span>
                            <span class="kr">else</span> <span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивіться на декларацію типу. Вона приймає ключ, що може бути порівняний, асоціативний список, і потім, вірогідно, продукує значення. Виглядає правильним.</p></div>
<div class="paragraph"><p>Це класична рекурсивна функція, що оперує зі списком. Граничний випадок, поділення списку на голову та хвіст, рекурсивні виклики - вони всі тут. Це класичний шаблон <code>fold</code>, так що давайте подивимось, як це може бути реалізовано через згортання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: Зазвичай краще використовувати згортки для цього стандартного шаблону рекурсії по списку, замість явного написання рекурсії, бо це краще читати та розпізнавати. Всі знають що це згортання, коли вони бачать виклик <code>foldr</code>, але читання явної рекурсії займає деякий час.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;penny&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;853-2492&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;betty&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;555-2938&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;wilma&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/legomap.png" alt="images/legomap.png" />
</span>
Робить чудово! Якщо ми маємо номер телефону дівчини, ми <code>Just</code> отримуємо номер, інакше ми отримуємо <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Ми тільки що реалізували функцію пошуку з <code>Data.List</code>. Якщо ми бажаємо знайти відповідне до ключа значення, ми маємо пройти всі елементи списка, доки ми не знайдемо його. Модуль <code>Data.Map</code> пропонує асоціативні списки, що значно швидші (оскільки вони внутрішньо реалізовані як дерева), і також вона провадить багато допоміжних функцій. Відтепер ми будемо казати, що ми робимо з мапами замість асоціативних списків.</p></div>
<div class="paragraph"><p>Оскільки <code>Data.Map</code> експортує функції, що перетинаються з такими з <code>Prelude</code> та <code>Data.List</code>, ми будемо робити кваліфікований імпорт.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
</pre></div></div></div>
<div class="paragraph"><p>Покладемо це твердження в скрипт, та потім завантажимо скрипт через  <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Давайте пійдемо далі, та побачимо, що має для нас <code>Data.Map</code>! Ось базовий огляд його функцій.</p></div>
<div class="paragraph"><p>Функція <code>fromList</code> бере асоціативний список (в формі списка) і повертає мапу з тими самими асоціаціями.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо в оригінальному асоціативному списку є дублікати ключів, дублікати просто відкидаються. Ось сигнатура типу для <code>fromList</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона каже, що береться список пар типів <code>k</code> та <code>v</code>, та повертається мапа, що відображує тип <code>k</code> на тип <code>v</code>. Зауважте, що коли ми робимо асоціативні списки з нормальними списками, ключі тільки мають проходити порівняння на рівність (їх тип належить до типокласу <code>Eq</code>), але тепер вони мають впорядковуватись. Це основний контраст в модулі <code>Data.Map</code>. Він вимагає щоб ключі впорядковувались, і тоді він зможе вистроїти їх в дерево.</p></div>
<div class="paragraph"><p>Вам слідує завжди використовувати <code>Data.Map</code> для асоціацій ключ-значення, тільки якщо ви не маєте ключів, що не є частиною типокласу <code>Ord</code>.</p></div>
<div class="paragraph"><p><code>empty</code> представляє порожню мапу. Вона не приймає аргументів, вона просто повертає порожню мапу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insert</code> бере ключ, значення та мапу, і повертає нову мапу, що така сама, тільки з доданим ключем та значенням.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="p">(</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span>  <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо реалізувати наш власний <code>fromList</code> через використання порожньої мапи, <code>insert</code> та <code>fold</code>. Дивіться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fromList&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
<span class="nf">fromList&#39;</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">v</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить прямолінійне згортання. Ми починаємо з порожньої мапи, і ми згортаємо її зправа, включаючи пари ключ значення в акумулятор по мірі проходження.</p></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи мапа є порожня.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>size</code> повідомляє про розмір мапи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>singleton</code> бере ключ та значення, та створює мапу, що має одне відображення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">9</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>lookup</code> робить як <code>Data.List</code> <code>lookup</code>, тільки він оперує з мапами. Він повертає <code>Just</code> дещо, якщо він знаходить дещо для ключі, і <code>Nothing</code> якщо ні.</p></div>
<div class="paragraph"><p><code>member</code> є предикатом, що приймає ключ і мапу, та повідомляє, чи ключ в мапі або ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>map</code> та <code>filter</code> роблять як їх еквіваленти для списків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">400</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">900</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">isUpper</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>toList</code> є зворотнім до <code>fromList</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">9</span> <span class="mi">2</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="p">[(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>keys</code> та <code>elems</code> повертають списки ключів та значень відповідно. <code>keys</code> є еквівалентом до <code>map fst . Map.toList</code> та <code>elems</code> є еквівалентом до <code>map snd . Map.toList</code>.</p></div>
<div class="paragraph"><p><code>fromListWith</code> є милою маленькою функцією. Вона діє як <code>fromList</code>, тільки вона не відкидає дублікати ключів, але використовує надану функцію для вирішення, що з ними робити. Скажімо, дівчина має декілька номерів, і ми маємо асоціативний список приблизно такого вигляду.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;342-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;827-9162&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;555-2111&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми просто використовуємо <code>fromList</code> щоб перенести це в мапу, ми втратимо декілька номерів! Так що ось як ми будемо робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="kt">String</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">number1</span> <span class="n">number2</span> <span class="ow">-&gt;</span> <span class="n">number1</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">number2</span><span class="p">)</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;827-9162, 943-2929, 493-2928&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;wendy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;939-8282&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;betty&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;342-2492, 555-2938&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми знайдемо дублікований ключ, функція, яку ми передали, буде використана для комбінації ціх значень для ключа в деяке інше значення. Ми можемо також спочатку створити для всіх значень в асоціативному списку списки синглтони, і потім ми можемо використати <code>++</code> для комбінації чисел.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,[</span><span class="n">v</span><span class="p">]))</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="p">[</span><span class="s">&quot;827-9162&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дуже добре! Інший випадок це коли ми робимо мапу з асоціативного списку чисел, і коли трапляється дублікований ключ, ми бажаємо зберігти більше значення для ключа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="n">max</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ми можемо скласти разом значення по тому самому ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">108</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">62</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">37</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insertWith</code> те саме до <code>insert</code>, що <code>fromListWith</code> до <code>fromList</code>. Вона вставляє пару ключ-значення в мапу, але якщо мапа вже містить ключ, вона використовує передану функцію для визначення того, що треба робити.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insertWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">104</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це було лише декілька функцій з <code>Data.Map</code>. Повний список функцій ви можете побачити в документації.</p></div>
</div>
<div class="sect2">
<h3 id="_data_set">Data.Set</h3>
<div class="paragraph"><p><span class="image">
<img src="images/legosets.png" alt="images/legosets.png" />
</span>
Модуль <code>Data.Set</code> пропонує нам множини. Це як множини в математиці. Множини як скрещені списки з мапами. Всі елементи в множині унікальні. І оскільки вони внутрішньо реалізовані за допомогою дерев (як мапи в <code>Data.Map</code>), вони впорядковані. Перевірка на членство, вставка, видалення, тощо значно швидші, ніж робити ті самі речі зі списками. Найбільш загальні операції при роботі з множинами є вставка в множину, перевірка членства та перетворення множини на список.</p></div>
<div class="paragraph"><p>Оскільки імена в <code>Data.Set</code> перетинаються значною мірою з іменами в  <code>Prelude</code> та <code>Data.List</code>, ми робимо кваліфікований імпорт.</p></div>
<div class="paragraph"><p>Покладіть твердження <code>import</code> в скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">Set</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім завантажте скрипт через <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Скажімо ми маємо два шматки тексту. Ми бажаємо з'ясувати, які символи використовуються в кожному з них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">text1</span> <span class="ow">=</span> <span class="s">&quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;</span>
<span class="nf">text2</span> <span class="ow">=</span> <span class="s">&quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>fromList</code> робить майже як ви могли очікувати. Вона бере список та конвертуж його в множину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set1</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set2</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot; .?AIRadefhijlmnorstuy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !Tabcdefghilmnorstuvwy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи впорядковані і кожний елемент унікальний. Тепер давайте використаємо функцію <code>intersection</code> щоб побачити, які елементи поділяють обоє.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">intersection</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; adefhilmnorstuy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо використовувати функцію <code>difference</code> щоб побачити, які літери в першій множині, але не в другій, і навпаки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot;.?AIRj&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set2</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot;!Tbcgvw&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ми можемо бачити всі унікальні літери в обох послідовностях з використанням <code>union</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції <code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code> та <code>delete</code> всі роблять як ви могли цього очікувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">8</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">delete</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми також можемо перевірити підмножини. Множина <code>A</code> є підмножиною <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code>. Множина <code>A</code> є власне підмножиною множини <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code> ,але також і інші елементи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isProperSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми також можемо відображати множини і фільтрувати їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Множини часто використовуються для позбавлення списків від дублікатів, спершу перетворивши їх на множину за допомогою <code>fromList</code>, та потім перетворивши її на список за допомогою <code>toList</code>. Функція <code>Data.List</code> <code>nub</code> вже робить це, але зачистка дублікатів для великих списків значно швидша, якщо ви перекачаєте його в множину, ніж якщо використаєте <code>nub</code>. Але викорастання <code>nub</code> вимагає тільки щоб тип елементів списку був частиною типокласу <code>Eq</code>, натомість якщо ви бажаєте перевести елементи в множину, тип списку має бути в <code>Ord</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">setNub</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">toList</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">setNub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot; ACEHIKLNRSTWY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot;HEY WATSCRKLIN&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>setNub</code> загалом швидша, ніж <code>nub</code> на великих списках, але як ви бачите, <code>nub</code> зберігає впорядкування елемнтів списку, тоді як <code>setNub</code> ні.</p></div>
</div>
<div class="sect2">
<h3 id="___">Створення власних модулей</h3>
<div class="paragraph"><p><span class="image">
<img src="images/making_modules.png" alt="images/making_modules.png" />
</span>
Ми вже подивились на деякі круті модулі, то як нам зробити наш власний модуль? Майже кожна мова програмування дозволяє вам поділити ваш код не декілька файлів, і Haskell не є виключенням. При створенні програм є гарною практикою брати функції і типи, що служать деяким подібним цілям, і покладати їх в модуль. Таким чином ви легко можете використати ці функції в інших програмах, просто імпортувавши ваш модуль.</p></div>
<div class="paragraph"><p>Давайте подивимось, як ви можете створити ваші власні модулі, створивши невеликий модуль, що провадить деякі функції для обчислення об'єму та площі декількох геометричних об'єктів. Ми почнемо зі створення файла з назвою <code>Geometry.hs</code>.</p></div>
<div class="paragraph"><p>Ми кажемо, що модуль експортує функції. Це означає те, що коли я імпортує модуль, я можу використовувати функції, які він експортує. Він може визначати функції, що його функції використовують внутрішньо, але ми можемо бачити та використовувати лише ті, що експортуються.</p></div>
<div class="paragraph"><p>На початку модуля ми вказуємо ім'я модуля. Якщо ми маємо файл з назвою <code>Geometry.hs</code>, тоді ми маємо назвати наш модуль <code>Geometry</code>. Потім ми вказуємо функції, які він експортує, і після цього ми починаємо писати функції. Так що ми почнемо з цього.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ми бачимо, ми робимо площі та об'єми для сфер, кубів та кубоїдів. Ідемо далі і визначаємо функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">sphereVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereVolume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">sphereArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereArea</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">cubeVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeVolume</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidVolume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cubeArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeArea</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidArea</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cuboidVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidVolume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">cuboidArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidArea</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут досить стандартна геометрія. Деякі речі мають прийти на думку. Оскільки куб лише особливий випадок кубоїду, ми визначили його площу та об'єм через трактування його як кубоїда, в якого всі сторони рівної довжини. Ми також визначили допоміжну функцію з назвою <code>rectangleArea</code>, що обчислює площу прямокутника на основі довжини сторін. Вона скоріше тривіальна, бо це лише множення. Зауважте, що ми використали її в наших функціях в модулі (а саме <code>cuboidArea</code> та <code>cuboidVolume</code>), але ми не експортували її! Оскільки ми лише бажаємо, щоб наш модуль представляв лише функції, що мають справу з тривимірними об'єктами, ми використали <code>rectangleArea</code>, але ми не експортували її.</p></div>
<div class="paragraph"><p>При створенні модуля ми зазвичай експортуємо тільки ті функції, що діють як різновид інтерфейсу до нашого модуля, так що сама релалізація прохована. Якщо дехто використовує наш модуль <code>Geometry</code>, вони не мають обтяжувати себе функціями, які ми не експортуємо. Ми можемо вирішити змінити ці функції повністю, або видалити їх в новій версії (ми можемо видалити <code>rectangleArea</code> та замість поставити лише <code>*</code>), і ніхто не перейматиметься, бо ми для початку не експортували їх.</p></div>
<div class="paragraph"><p>Щоб використати наш модуль ми просто робимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Geometry.hs</code> повинен бути в тій же папці, що і програма, до якої ми його імпортуємо.</p></div>
<div class="paragraph"><p>Модулі також можуть бути взяті як ієрархічні структури. Кожний модуль може мати декілька субмодулів, і ті також можуть мати власні субмодулі. Давайте поділимо ці функції, так що <code>Geometry</code> буде модулем, що має три субмодулі, по одному для кожного типу об'єктів.</p></div>
<div class="paragraph"><p>Спочатку створимо папку з назвою <code>Geometry</code>. Подумайте про велику  <code>G</code>. В цій папці розташуємо три файли: <code>Sphere.hs</code>, <code>Cuboid.hs</code>, та <code>Cube.hs</code>. Ось що будуть містити файли:</p></div>
<div class="paragraph"><p><code>Sphere.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Sphere</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Cuboid.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cuboid</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Cube.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cube</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">volume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">area</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд! Перше <code>Geometry.Sphere</code>. Зауважте, як ми поклали його в папку з назвою <code>Geometry</code>, та потім визначили модуль на ім'я <code>Geometry.Sphere</code>. Ми зробили те саме для кубоїда. Також зауважте, як в усіх трьох субмодулях ми визначили функції з тими самими назвами. Ми можемо зробити це, оскільки вони в окремих модулях. Ми бажаємо використати функції з <code>Geometry.Cuboid</code> в <code>Geometry.Cube</code>, але ми не можемо напряму зробити імпорт <code>Geometry.Cuboid</code>, оскільки він експортує функції з тими самими іменами, що і <code>Geometry.Cube</code>. Ось чому ми зробили кваліфікований імпорт, і все гаразд.</p></div>
<div class="paragraph"><p>Так що коли ми в файлі на тому самому рівні, що і папка <code>Geometry</code>, ми можемо зробити, скажімо, таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry.Sphere</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>area</code> та <code>volume</code>, і вони даватимуть нам площу та об'єм сфери. Але якщо ми бажаємо жанглювати двома або більше з ціх модулів, ми маємо робити кваліфікований імпорт, оскільки вони експортують функції з тіма самими іменами. Так що ми робимо дещо таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Sphere</span> <span class="k">as</span> <span class="n">Sphere</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cube</span> <span class="k">as</span> <span class="n">Cube</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>Sphere.area</code>, <code>Sphere.volume</code>, <code>Cuboid.area</code>, тощо, і кожний буде обчислювати площу та об'єм для свого відповідного об'єкту.</p></div>
<div class="paragraph"><p>Наступного разу, коли ви будете писати файл, що дійсно великий, та має безліч функцій, спробуйте визначити, які функції служать якімось загальним цілям, і потім розгляньте, як покласти ці функції у свій власний модуль. Ви будете в змозі просто імпортувати ваш власний модуль наступного разу, коли ви писатимите програму, що потребує тої самої функціональності.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-09-18 14:11:33 EEST
</div>
</div>
</body>
</html>
