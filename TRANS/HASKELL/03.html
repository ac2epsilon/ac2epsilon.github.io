<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Типи і типокласи</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__">Повірте типу</h3>
<div class="paragraph"><p><span class="image">
<img src="images/cow.png" alt="images/cow.png" />
</span>
Раніше ми згадували, що Haskell має статичну систему типів. Тип кожного виразу відомий під час компіляції, що призводить до безпечнішого коду. Якщо ви напишете програму, де ви спробуєте поділити логічний тип на деяке число, вона навіть не скомпілюється. Це добре, бо краще перехоплювати такі помилки під час компіляції, замість отримати крах вашої програми. Все в Haskell має тип, так що компілятор може міркувати щодо вашої програми, перед тим як скомпілювати її.</p></div>
<div class="paragraph"><p>На відміну від Java або Pascal, Haskell має вивід типів. Якщо ви пишете число, ви не маєте казати Haskell, що це число. Він може вивести це сам, так що нам не треба явно писати типи наших функцій та виразів, щоб все робилось відповідно. Ми розглянули деяки з основ Haskell, тільки зверньо поглянувши на типи. Однак розуміння системи типів є дуже важливою частиною в вивченні Haskell.</p></div>
<div class="paragraph"><p>Тип є різновидом мітки, що має кожен вираз. Він каже нам, до якої категорії речей належить вираз. Вираз <code>True</code> є логічним, <code>"hello"</code> є рядком, тощо.</p></div>
<div class="paragraph"><p>Зараз ми будемо використовувати GHCI для перевірки типів деяких виразів. Ми будемо робити це, використовуючи команду <code>:t</code>, яка, якщо стоїть перед валідним виразом, каже його тип. Дамо йому вир.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="sc">&#39;a&#39;</span>
<span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">True</span>
<span class="kt">True</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="s">&quot;HELLO!&quot;</span>
<span class="s">&quot;HELLO!&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bomb.png" alt="images/bomb.png" />
</span>
Тут ми бачимо, що робити <code>:t</code> на виразі друкує вираз, за яким іде <code>::</code> та його тип. <code>::</code> читається як "має певний тип". Явні типи завжди позначаються першою літерою верхнього реєству. <code>'a'</code>, як можна бачити, має тип <code>Char</code>. Не важко зробити висновок, що це позначає символ. <code>True</code> має тип <code>Bool</code> (логічний тип, названий за розробником логічної алгебри предикатів, Буля. прим.перекл). Це має сенс. Але що це? Дослідження типу <code>"HELLO!"</code> дає <code>[Char]</code>. Квадратні дужки позначають список. Так що ми читаємо це як список символів. На відміну від списків кожна довжина таплу має власний тип. Так що вираз <code>(True, 'a')</code> має тип <code>(Bool, Char)</code>, тоді як вираз як <code>('a','b','c')</code> матиме тип <code>(Char, Char, Char)</code>. <code>4 == 5</code> завжди повертатиме <code>False</code>, так що його тип <code>Bool</code>.</p></div>
<div class="paragraph"><p>Функції також мають типи. Коли ми пишемо власні функції, ми можемо обрати надавати їм явні декларації типів. Це загалом розглядається як гарна практика, за винятком коли ми пишемо дуже малі функції. Звідси і надалі ми надаватимемо функції, що мають явні декларації типів. Згадайте осяжності списків, що ми робили до цього, що фільтрували рядки, що мають лише великі літери? Ось як це виглядає з декларацією типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>removeNonUppercase</code> має тип <code>[Char] -&gt; [Char]</code>, що каже, що вона відзеркалює рядок на рядок. Це тому, що вона бере один рядок як параметр, та повертає інший як результат. Тип <code>[Char]</code> є синонімом до <code>String</code>, так що буде яснішим, якщо ми напишемо <code>removeNonUppercase    \:\: String -&gt; String</code>. Ми не маємо надавати цій функції декларацію типу, оскільки компілятор може вивести це самостійно, що це функція рядка до рядка, ала ми зробили це все одно. Але як записати тип функції, що приймає декілька параметрів? Ось проста функція, що приймає три цілі та складає їх разом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addThree</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри розділені позначкою <code>-&gt;</code>, і немає особливої різниці між параметрами та типом повернення. Тип повернення є останнім елементом в декларації, та параметри перші три. Пізніше ми побачимо, чому вони всі розділені <code>-&gt;</code>, замість мати деякий більш явний спосіб розрізнення між типом повернення та параметрами, як <code>Int, Int, Int -&gt; Int</code>, або щось таке.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте надати вашій функції декларацію типу, але не впевнені, що це має бути, ви можете тільки написати функцію без нього, та потім перевірити її за допомогою <code>:t</code>. Функції також є виразами, так що <code>:t</code> робить на них без проблем.</p></div>
<div class="paragraph"><p>Ось огляд деяких загальних типів.</p></div>
<div class="paragraph"><p><code>Int</code> означає цілі. Він використовується для цілих чисел. <code>7</code> може бути <code>Int</code>, але <code>7.2</code> ні. <code>Int</code> обмежене, що означає, що вони мають мінімум та максимальне значення. Зазвичай на 32-бітних машинах максимально можливе <code>Int</code> є <code>2147483647</code>, та мінімальне є <code>-2147483648</code>.</p></div>
<div class="paragraph"><p><code>Integer</code> позначає також, хм … також ціле. Головна різниця в тому, що він не прив'язаний до меж, і він може використовуватись для представлення насправді великих чисел. Я маю на увазі що дійсно великіх. Однак <code>Int</code> більш ефективний.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">factorial</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">factorial</span> <span class="mi">50</span>
<span class="mi">30414093201713378043612608166064768844377641568960512000000000000</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Float</code> є дійсне плаваюче з одинарною точністю.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">circumference</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference</span> <span class="mf">4.0</span>
<span class="mf">25.132742</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Double</code> є дійсне плаваюче з подвійною точністю!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference&#39;</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">circumference&#39;</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference&#39;</span> <span class="mf">4.0</span>
<span class="mf">25.132741228718345</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Bool</code> є логічний тип. Він може мати тільки два значення: <code>True</code> та <code>False</code>.</p></div>
<div class="paragraph"><p><code>Char</code> представляє символ. Він позначається поодинокими лапками. Список символів є рядком.</p></div>
<div class="paragraph"><p>Тапли є типами, але вони залежні від своєї довжини, так само, як і від типів своїх компонентів, так що теоретично є безліч типів таплів, що забагато, щоб накрити в цьому туторіалу. Зауважте, що порожній тапл <code>()</code> також є типом, що може мати одне значення: <code>()</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Змінні типів</h3>
<div class="paragraph"><p>Який, як ви думаєте, є тип функції <code>head</code>? Оскільки <code>head</code> приймає список любого типу, та повертає перший елемент, то що це має бути? Давайте перевіримо!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">head</span>
<span class="nf">head</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/box.png" alt="images/box.png" />
</span>
Хмм! Що є це <code>a</code>? Чи це є тип? Згадайте, що дотепер ми стверджували, що типи записуються з великої літери, так що це не може в точності бути типом. Оскільки це не велика літера, це насправді змінна типу. Це значить, що це може бути любий тип. Це здебільшого як дженеріки в інших мовах, але в Haskell це значно більш потужне, оскільки це дозволяє нам просто писати любі загальні функції, тільки якщо вони не використовують деяку особливу специфічну поведінку на типах в своєму складі. Функції, що мають змінні типів, називаються поліморфними функціями. Декларація типу <code>head</code> стверджує, що вона приймає список любого типу, та повертає один елемент цього типу.</p></div>
<div class="paragraph"><p>Хоча змінні типів можуть мати ім'я, довші за один символ, ми зазвичай даємо їм імена <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p></div>
<div class="paragraph"><p>Пам'ятаєте <code>fst</code>? Він повертає перший компонент з пари. Давайте дослідимо його тип.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fst</span>
<span class="nf">fst</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми бачимо, що <code>fst</code> бере тапл, що має два типи, і повертає елемент, чий тип такий самий, що і тип першого компонента з пари. Ось чому ми можемо використовувати <code>fst</code> на парі, що містить два довільні типи. Зауважте, що тільки через те, що <code>a</code> та <code>b</code> є різними змінними типів, вони не мають бути різними типами. Це типами стверджує, що тип першого компоненту та тип значення повернення є тим самим.</p></div>
</div>
<div class="sect2">
<h3 id="__101">Типокласи 101</h3>
<div class="paragraph"><p><span class="image">
<img src="images/classes.png" alt="images/classes.png" />
</span>
Типоклас є деяким різновидом інтерфейсу, що визначає деяку поведінку. Якщо тип є частиною типокласу, це означає, що він підтримує та реалізує поведінку, яку описує типоклас. Багато людей, що приходять з OOP, спантеличені типокласами, бо вважають їх подібними до класів в об'єктно орієнтовних мовах. Гараз, це не так. Ви можете думати про них, як про різновид Java інтерфейсів, тільки кращіх.</p></div>
<div class="sect3">
<h4 id="_____code_code">Яка сигнатура типу функції <code>==</code>?</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
<span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: оператор еквівалентності <code>==</code> є функцією. Так само, як <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, та майже всі інші оператори. Якщо функція складається тільки зі спеціальних символів, вона розглядається як інфіксна функція по замовчанню. Якщо ми бажаємо перевірити її тип, передати її до іншої функції, або викликати як префіксну функцію, ми маємо оточити її дужками.</p></div>
<div class="paragraph"><p>Цікаво. Ми бачимо тут нову річ, символ <code>=&gt;</code>. Все перед символом <code>=&gt;</code> має назву класової константи. Ми можемо прочитати попередню декларацію типу таким чином: Функція еквівалентності бере два значення, що мають однаковий тип, та повертає <code>Bool</code>. Тип ціх значень мусить бути типом класу <code>Eq</code> (це була класова константа).</p></div>
<div class="paragraph"><p>Типоклас <code>Eq</code> провадить інтерфейс для перевірки на рівність. Кожний клас, коли має сенс перевірка на рівність між двома елементами для цього типу, мав би бути членом класу <code>Eq</code>. Всі стандартні типи Haskell, за винятком IO (тип для роботи з вводом та виводом), та функції є частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Функція <code>elem</code> має тип <code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>, оскільки він використовує <code>==</code> по списку, щоб перевірити, чи деяке значення, яке ми шукаємо, знаходиться в списку.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____2">Деякі базові типокласи:</h3>
<div class="paragraph"><p><code>Eq</code> використовується для типів, що підтримують перевірку на рівність. Функції, що реалізують його члени є <code>==</code> та <code>/=</code>. Так що якщо є обмеження класу <code>Eq</code> для змінної типу в функції, вона використовує <code>==</code> або <code>/=</code> десь в своїй декларації. Всі типи, що ми згадували до цього, за винятком функцій, є частинами <code>Eq</code>, так що вони можуть бути перевірені на рівність.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">==</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Ho Ho&quot;</span> <span class="o">==</span> <span class="s">&quot;Ho Ho&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mf">3.432</span> <span class="o">==</span> <span class="mf">3.432</span>
<span class="kt">True</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Ord</code> призначений для типів, що мають впорядкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі типи, що ми розглядали досі, за винятком функцій, є частиною <code>Ord</code>. <code>Ord</code> покриває всі стандартні функції порівняння, такі як <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> та <code>&lt;=</code>. Функції порівнянь беруть два члени <code>Ord</code> того самого типу, і повертають впорядкування <code>Ordering</code>. <code>Ordering</code> є типом, що може бути <code>GT</code>, <code>LT</code> або <code>EQ</code>, що відповідно означає більше ніж, меньше ніж, або дорівнює.</p></div>
<div class="paragraph"><p>Щоб бути членом <code>Ord</code> тип має зпочатку мати членство в престижному та ексклюзивному клубі <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="o">&lt;</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">3</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Show</code> можуть бути представлені як рядкі. Всі типи, що розглядались досі, за винятком функцій, є частиною <code>Show</code>. Найбільш уживана функція, що має справу з типокласом <code>Show</code> є <code>show</code>. Вона бере значення, чий тип є членом <code>Show</code>, та представляє його нам як рядок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">3</span>
<span class="s">&quot;3&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mf">5.334</span>
<span class="s">&quot;5.334&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">True</span>
<span class="s">&quot;True&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Read</code> є дещо протилежним типокласом до <code>Show</code>. Функція <code>read</code> бере рядок, та повертає тип, який є членом <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;True&quot;</span> <span class="o">||</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;8.2&quot;</span> <span class="o">+</span> <span class="mf">3.8</span>
<span class="mf">12.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="o">-</span> <span class="mi">2</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Доки досить. Знову, всі типи, розглянуті до сих пір, знаходяться в цьому типокласі. Але що відбудеться, якщо ми тільки зробимо <code>read "4"</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;4&quot;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
      <span class="p">`</span><span class="kt">Read</span> <span class="n">a&#39;</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">7</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що GHCI тут нам каже, це те, що він не знає, що ми бажаємо повернути. Зауважте, що в попередніх використаннях <code>read</code> ми робили дещо з результатом після цього. Таким чином, GHCI міг вивести, який тип результату ми бажали від <code>read</code>. Якщо ми б використовували це як логічне, він би знав, що треба повертати <code>Bool</code>. Але тепер він знає, що ми бажаємо деякий тип, що є частиною класу <code>Read</code>, він тільки не знає, який саме. Давайте поглянемо на сигнатуру типу <code>read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите? Він повертає тип, що є частиною <code>Read</code>, але якщо ми потім не спробуємо використати його якось далі, немає шляху дізнатись, що саме цей тип. Ось чому ми можемо використовувати явні анотації типів. Анотації типів є шлях явно сказати, яким має бути тип виразу. Ми робимо це, додаючи <code>::</code> наприкінці виразу, та потім вказавши тип. Дивіться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;(3, &#39;a&#39;)&quot;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість виразів такі, що компілятор може вивести їх тип самотужки. Але іноді компілятор не знає, чи треба повертати значення типу <code>Int</code> або <code>Float</code> для виразів як <code>read "5"</code>. Щоб побачити, який тип є насправді, Haskell мав би насправді обчислити <code>read "5"</code>. Але оскільки Haskell є статично типізованою мовою, він має знати всі типи перед компіляцією кода (або в випадку GHCI, обчисленням). Так що ми маємо сказати Haskell: "Йо, цей вираз має бути такого типу, в випадку якщо ти не знаєш!".</p></div>
<div class="paragraph"><p><code>Enum</code> члени є послідовно впорядкованими типами — вони можуть бути перелічені. Головна перевага типокласу <code>Enum</code> в тому, що ми можемо використовувати його типи як диапазони списків. Вони також мають визначені попередників та послідовників, що ви можете отримати функціями <code>succ</code> та <code>pred</code>. Типи в цьому класі: <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> та <code>Double</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;e&#39;</span><span class="p">]</span>
<span class="s">&quot;abcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">LT</span> <span class="o">..</span> <span class="kt">GT</span><span class="p">]</span>
<span class="p">[</span><span class="kt">LT</span><span class="p">,</span><span class="kt">EQ</span><span class="p">,</span><span class="kt">GT</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="sc">&#39;B&#39;</span>
<span class="sc">&#39;C&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Bounded</code> мають верхню та нижню межу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="o">-</span><span class="mi">2147483648</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>minBound</code> та <code>maxBound</code> є цікаві, бо вони мають тип <code>(Bounded a) =&gt; a</code>. В деякому сенсі вони є поліморфними константами.</p></div>
<div class="paragraph"><p>Всі тапли також є частиною <code>Bounded</code>, якщо в ньому також їх компоненти.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">,</span><span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Num</code> є числовим типокласом. Його члени мають властивість діяти як числа. Давайте дослідимо тип числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">20</span>
<span class="mi">20</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Виглядає так, що цілі числа також є поліморфними константами. Вони можуть діяти як любий тип, що є членом типокласу <code>Num</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Double</span>
<span class="mf">20.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це ті типи, що належать до типокласа <code>Num</code>. Якщо ми перевіримо тип <code>*</code>, ми побачимо, що він приймає всі числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Він приймає всі числа того самого типу, та повертає число того ж типу. Ось чому <code>(5 :: Int) * (6 :: Integer)</code> призведе до посилки типу, тоді як `5 * (6 
</dt>
<dd>
<p>
Integer)` буде робити досить добре, та спродукує <code>Integer</code>, оскільки <code>5</code> може діяти як <code>Integer</code> або <code>Int</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Щоб поєднати <code>Num</code>, тип має вже бути друзями з <code>Show</code> та <code>Eq</code>.</p></div>
<div class="paragraph"><p><code>Integral</code> є також числовим типокласом. <code>Num</code> включає всі числа, включаючи дійсні числа та цілі числа, <code>Integral</code> включає тільки цілі числа. В цьому типокласі <code>Int</code> та <code>Integer</code>.</p></div>
<div class="paragraph"><p><code>Floating</code> включає тільки числа з плаваючою крапкою, <code>Float</code> та <code>Double</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дуже корисна функція для справ з числами є <code>fromIntegral</code>. Вона має декларацію типу <code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. З цієї декларації типів ми бачимо, що він приймає ціле число, та перетворює його в більш загальне число. Це корисно, коли ви бажаєте, щоб цілі та з плаваючою крапкою гарно робили поспіль. Наприклад, функція <code>length</code> має декларацію типу <code>length :: [a] -&gt; Int</code>, замість мати більш загальний тип `(Num b) &#8658; length 
</dt>
<dd>
<p>
[a] &#8594; b`. Я думаю, це має історичні причини або щось таке, хоча, як до мене, це дурниці. В жодному разі, якщо ви отримаєте довжину списку, та потім додасте її до <code>3.2</code>, ми отримаємо помилку, бо ми намагались додати разом <code>Int</code> та число з плаваючою крапкою. Щоб уникнути цього ми робимо <code>fromIntegral (length [1,2,3,4]) + 3.2</code>, і тоді це буде робити.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що <code>fromIntegral</code> має декілька класових обмежень в своїй сигнатурі типу. Це повністю валідне, та як ви можете бачити, обмеження класів відокремлені комами в дужках.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-08-09 22:27:13 EEST
</div>
</div>
</body>
</html>
