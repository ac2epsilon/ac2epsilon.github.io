include::header.adoc[]

== Функтори, аплікативні функтори, моноїди

Поєднання в Haskell чистоти, функцій вищого порядку, параметризованих типів даних алгебраїки та класів типів дозволяє нам реалізувати поліморфізм на набагато вищому рівні, ніж це можливо в інших мовах. Нам не потрібно думати про типи, що належать до великої ієрархії типів. Натомість ми думаємо про те, як можуть діяти типи, а потім з'єднуємо їх з відповідними класами. `Int` може діяти як багато речей. Він може діяти як рівнозначна річ, як впорядкована річ, як численна річ тощо.

Класи типу відкриті, це означає, що ми можемо визначити свій власний тип даних, подумати про те, як він може діяти, і пов’язати це з типовими класами, що визначають його поведінку. Через це і завдяки чудовій системі Haskell, яка дозволяє нам багато чого знати про функцію, лише знаючи її декларацію типу, ми можемо визначити типи класів, які визначають поведінку, яка є дуже загальною та абстрактною. Ми зустрічалися з класами типів, які визначають операції, щоб перевірити, чи дві речі рівні, або порівняти дві речі за деяким упорядкуванням. Це дуже абстрактна та елегантна поведінка, але ми просто не вважаємо їх за щось особливе, тому що ми маємо справу з ними більшу частину свого життя. Нещодавно ми зустріли функтори, які, в основному, позначають речі які можуть відображатись. Це приклад корисної і все ще досить абстрактної властивості, яку можуть описати типокласи. В цьому розділі ми детальніше розглянемо функтори, а також дещо сильніші та корисніші версії функторів, які називаються аплікативними функторами. Ми також поглянемо на моноїди, які схожі на шкарпетки.

=== Редукційні функтори

image:images/frogtor.png[]
Про функтори ми вже говорили у своєму маленькому розділі. Якщо ви ще його не прочитали, вам, ймовірно, варто поглянути на нього прямо зараз, а може, пізніше, коли у вас буде більше часу. Або ви можете просто зробити вигляд, що ви його прочитали.

Але ось швидка підказка: функтори - це речі, по яких можна зробити відображення, наприклад, списки, `Maybe`, дерева тощо. У Haskell вони описуються типокласом `Functor`, який має лише один метод типокласу, а саме `fmap`, який має тип `fmap ::(a -> b) -> f a -> f b`. Він говорить: дайте мені функцію, яка приймає `a`, і повертає `b` і коробку з `a` (або декількома з них) всередині, і я дам вам коробку з `b` (або декількома з них) всередині неї. Це свого роду застосовує функцію до елемента всередині коробки.

Слово поради. Багато разів використовується аналогія коробки, щоб допомогти вам зрозуміти, як функціонують функтори, і пізніше, ймовірно, ми будемо використовувати ту саму аналогію для аплікативних функторів і монад. Це нормальна аналогія, яка допомагає людям спочатку зрозуміти функтори, просто не сприймайте це занадто буквально, тому що для деяких функторів аналогія коробки повинна бути розтягнута дуже тонко, щоб все-таки зберігати деяку правду. Більш правильним терміном для того, що таке функтор, буде обчислювальний контекст. Контекст може полягати в тому, що обчислення може мати значення або воно може бути невдалим (`Maybe` та `Either a`), або що може бути більше значень (списків).

Якщо ми хочемо зробити конструктор типу екземпляром `Functor`, він повинен мати вид `* -> *`, що означає, що він повинен приймати рівно один конкретний тип як параметр типу. Наприклад, можна зробити екземпляр, оскільки для створення конкретного типу потрібен параметр одного типу, наприклад, `Int` або `Maybe String`. Якщо конструктор типів приймає два параметри, як, наприклад, `Either`, нам доведеться частково застосувати конструктор типу, поки він не прийме лише один параметр типу. Таким чином, ми не можемо писати `instance Functor Either where`, але ми можемо записати `instance Functor (Either a) where`, і тоді, якщо ми уявимо що `fmap` призначена лише для `Either a`, вона мала би декларацію типу `map ::(b -> c) -> Either a b -> Either a c`. Як бачимо, частина `Either a` є виправленою, тому що Either a приймає лише один тип параметра, тоді як просто `Either` бере два, тому `fmap ::(b -> c) -> Either b -> Either c` справді не має сенсу .

We've learned by now how a lot of types (well, type constructors really) are instances of Functor, like [], Maybe, Either a and a Tree type that we made on our own. We saw how we can map functions over them for great good. In this section, we'll take a look at two more instances of functor, namely IO and (->) r.
Ми вже дізналися, як багато типів (гаразд, насправді конструктори типів) є екземплярами `Functor`, як `[]`, `Maybe`, `Either a`, або тип `Tree`, який ми створили самостійно. Ми бачили, як чудово ми можемо відображати функції над ними. У цьому розділі ми розглянемо ще два екземпляри функтора, а саме `IO` та `(->) r`.

Якщо якесь значення має тип, скажімо, `IO String`, це означає, що це дія вводу/виводу, яка, виконуючись, вийде в реальний світ і отримає для нас деяку строку, яка в результаті надійде як результат. Ми можемо використовувати `<-` in `do` синтаксисі, щоб прив'язати результат до імені. Ми згадували, що дії вводу/виводу - це як коробки з маленькими ніжками, які виходять назовні і приносять для нас деяке значення із зовнішнього світу. Ми можемо перевірити, що вони отримали, але після перевірки нам доведеться обернути значення назад в `IO`. Роздумуючи про цю коробку з аналогією маленьких ніжок, ми можемо побачити, як `IO` діє як функтор.

Подивимося, як `IO` є екземпляром `Functor`. Коли ми `fmap` функцію над дією вводу-виводу, ми хочемо повернути дію вводу-виводу, яка робить те саме, але наша функція застосовується до значення результату.

[source,haskell]
----
instance Functor IO where  
    fmap f action = do  
        result <- action  
        return (f result)  
----

Результатом відображення чогось на дії вводу-виводу буде дія вводу-виводу, тому мимоволі використовуємо синтаксис, щоб склеїти дві дії та зробити нову. У реалізації для `fmap` ми робимо нову дію вводу-виводу, яка спочатку виконує оригінальну дію вводу-виводу та викликає її `result` результату. Потім робимо `return (f result)`. Як відомо, `return` це функція, яка виконує дію вводу-виводу, яка нічого не робить, а лише щось представляє як результат. Дія, яку виробляє блок `do`, завжди матиме значення результату останньої дії. Ось чому ми використовуємо `return` для того, щоб зробити дію вводу-виводу, яка насправді нічого не робить. Вона просто представляє `f result` як результат нової дії вводу-виводу.

Ми можемо пограти з цим, щоб отримати деяку інтуїцію. Насправді це дуже просто. Ознайомтеся з цим кодом:

[source,haskell]
----
main = do line <- getLine   
          let line' = reverse line  
          putStrLn $ "You said " ++ line' ++ " backwards!"  
          putStrLn $ "Yes, you really said" ++ line' ++ " backwards!"  
----

Користувачеві пропонується ввести рядок, і ми повертаємо його назад, лише обернувши його. Ось як це переписати за допомогою `fmap`:

[source,haskell]
----
main = do line <- fmap reverse getLine  
          putStrLn $ "You said " ++ line ++ " backwards!"  
          putStrLn $ "Yes, you really said" ++ line ++ " backwards!"  
----

image:images/alien.png[]
Так само, як коли ми робимо `fmap reverse Just "blah"`, щоб отримати `Just "halb"`, ми можемо `fmap reverse getLine`. `getLine` - це введення-виведення, яке має тип `IO String` та `reverse` відображення по ньому, дає нам дію вводу-виводу, яка вийде у реальний світ та отримає рядок, а потім застосує `reverse` до її результату. Так само, як ми можемо застосувати функцію до чогось, що знаходиться у вікні `Maybe`, ми можемо застосувати функцію до того, що знаходиться всередині `IO` вікна, лише воно повинне вийти у реальний світ, щоб щось отримати. Тоді, коли ми прив’яжемо його до імені використовуючи `<-`, ім'я відображатиме результат, до якого вже застосовано `reverse`.

Дія вводу-виводу `fmap (++ "!") getLine` поводиться так само, як і `getLine`, тільки щоб її результат завжди мав доданий `"!"`!

Якщо ми подивимось, який би тип `fmap` був, якби він обмежився `IO`, це буде `fmap ::(a -> b) -> IO a -> IO b`. `fmap` приймає функцію та дію вводу-виводу та повертає нову дію вводу-виводу, подібно до старої, за винятком того, що до її результату застосовується функція.

Якщо ви коли-небудь виявляєте, що зв'язуєте результат дії вводу-виводу з іменем, лише щоб застосувати до нього функцію і викликати щось інше, подумайте про використання `fmap`, оскільки це виглядає краще. Якщо ви хочете застосувати кілька перетворень до деяких даних всередині функтора, ви можете оголосити власну функцію на верхньому рівні, зробити лямбда функцію або в ідеалі використовувати композицію функцій:

[source,haskell]
----
import Data.Char  
import Data.List  
  
main = do line <- fmap (intersperse '-' . reverse . map toUpper) getLine  
          putStrLn line  
$ runhaskell fmapping_io.hs  
hello there  
E-R-E-H-T- -O-L-L-E-H  
----

Як ви, напевно, знаєте, `intersperse '-' . reverse . map toUpper` - це функція, яка приймає рядок, `map toUpper` по ній, застосовує `reverse` до результату, а потім застосовує `intersperse '-'` до цього результату. Це як записати `(\ xs -> intersperse '-' (reverse(map toUpper xs)))`, тільки красивіше.

Інший екземпляр `Functor`, з яким ми весь час мали справу, але не знали, що це `Functor`, є `(->) r`. Ви, мабуть, трохи розгублені, адже що набіса значить це `(->) r`? Тип функції `r -> a` можна переписати як `(->) r a`, так само, як ми можемо записати `2 + 3` як `(+) 2 3`. Коли ми дивимось на це як `(->) r a`, ми можемо побачити `(->)` у дещо іншому світлі, оскільки ми бачимо, що це просто тип конструктора, який приймає два параметри типу, як в `Either`. Але пам’ятайте, ми говорили, що конструктор типу повинен приймати рівно один параметр типу, щоб він міг зробити екземпляр `Functor`. Тому ми не можемо зробити `(->)` екземпляром `Functor`. Але якщо ми частково застосуємо його до `(->) r`, це не створює проблем. Якщо синтаксис дозволив конструкторам типів частково застосувати з розділами (як ми можемо частково застосувати `+`, зробивши `(2+)`, що те саме, що `(+) 2`), ви можете написати `(->) r` як `(r ->)`. Як функціонують функтори? Що ж, давайте подивимось на реалізацію, яка лежить в `Control.Monad.Insances`

Зазвичай ми позначаємо функції, які беруть що завгодно, і повертають що-небудь як `a -> b`. `r -> a` - те саме, ми просто використали інші літери для змінних типів.

[source,haskell]
----
instance Functor ((->) r) where  
    fmap f g = (\x -> f (g x))  
----

Якщо синтаксис дозволяв би це, він міг бути записаний як

[source,haskell]
----
instance Functor (r ->) where  
    fmap f g = (\x -> f (g x))  
----

Але це не так, тому ми повинні писати це попереднім способом.

Перш за все, давайте подумаємо про тип `fmap`. Це `fmap ::(a -> b) -> f a -> f b`. Тепер ми подумки замінимо всі `f`, що є роллю, що грає наш примірник функтора, на `(->) r`. Ми зробимо це, щоб побачити, як повинен поводитися `fmap` для цього конкретного екземпляра. Отримуємо `fmap ::(a -> b) -> ((->) r a) -> ((->) r b)`. Тепер, що ми можемо зробити, - записати типи `(->) r a` і `(->) r b` як інфікс `r -> a` і `r -> b`, як це зазвичай робимо з функціями. Тепер ми отримуємо `fmap ::(a -> b) -> (r -> a) -> (r -> b)`.

Хммм добре. Відображення однієї функції над функцією повинно створювати функцію, подібно до відображення функції над `Maybe` має створити `Maybe`, а відображення функції над списком має створити список. Що говорить нам тип `fmap ::(a -> b) -> (r -> a) -> (r -> b)` для цього примірника? Що ж, ми бачимо, що вона приймає функцію від `a` до `b` і функцію від `r` до `a` і повертає функцію від `r` до `b`. Це вам щось нагадує? Так! Функціональну композицію! Ми вводимо вихід `r -> a` на вхід `a -> b`, щоб отримати функцію `r -> b`, яка саме полягає у композиції функцй. Якщо ви подивитеся на те, як визначений екземпляр вище, ви побачите, що це лише композиція функції. Ще один спосіб написання цього примірника:

[source,haskell]
----
instance Functor ((->) r) where  
    fmap = (.)  
----

This makes the revelation that using fmap over functions is just composition sort of obvious. Do :m + Control.Monad.Instances, since that's where the instance is defined and then try playing with mapping over functions.
Це визнає очевидним факт, що використання `fmap` над функціями просто композиція. Зробіть `:m + Control.Monad.Insances`, оскільки там визначено екземпляр, а потім спробуйте грати з відображенням функцій.

[source,haskell]
----
ghci> :t fmap (*3) (+100)  
fmap (*3) (+100) :: (Num a) => a -> a  
ghci> fmap (*3) (+100) 1  
303  
ghci> (*3) `fmap` (+100) $ 1  
303  
ghci> (*3) . (+100) $ 1  
303  
ghci> fmap (show . (*3)) (*100) 1  
"300"  
----

Ми можемо викликати `fmap` як інфіксну функцію, так що схожість з `.` прозора. У другому рядку ми відображаємо `(* 3)` над `(+100)`, що призводить до функції, яка буде приймати вхід, викликати на ньому `(+100)`, а потім викликати `(* 3)` на результаті. Ми викликаємо цю функцію для 1.

Як тут дотримується аналогія коробки? Добре, якщо ви розтягнете її, це має місце. Коли ми використовуємо `fmap (+3)` над `Just 3`, легко уявити `Maybe` як коробку, яке містить деякий вміст, до якого ми застосовуємо функцію `(+3)`. Але що коли ми робимо `fmap (* 3) (+100)`? Ну, ви можете розглядати функцію `(+100)` як коробку, що містить її кінцевий результат. На кшталт того, як дії вводу/виводу можна розглядати як вікно, яке вийде в реальний світ і отримає певний результат. Використання `fmap (* 3)` на `(+100)` створить іншу функцію, яка діє на зразок `(+100)`, але перед тим, як створити результат, буде застосовано `(* 3)` до цього результату. Тепер ми можемо побачити, як `fmap` діє як `.` для функцій.

Те, що `fmap` - це функціональна композиція при використанні функцій, зараз не дуже корисно, але принаймні дуже цікаво. Це також трохи згинає наш розум і давайте подивимось, як речі, які діють більше як обчислення, ніж коробки (`IO` та `(->) r`), можуть бути функторами. Функція, яка відображається через обчислення, призводить до того ж обчислення, але результат цього обчислення модифікується з функцією.

image:images/lifter.png[]
Перш ніж ми перейдемо до правил, яких слід дотримуватися `fmap`, давайте ще раз подумаємо про тип `fmap`. Її тип `fmap ::(a -> b) -> f a -> f b`. Нам не вистачає обмеження класу `(Functor f) =>`, але ми його пропустили тут для стислості. Оскільки ми так чи інакше говоримо про функтори, тому ми знаємо, що означає `f`. Коли ми вперше дізналися про _каровані_ функції, ми сказали, що всі функції Haskell насправді приймають один параметр. Функція `a -> b -> c` насправді приймає лише один параметр типу `a`, а потім повертає функцію `b -> c`, яка приймає один параметр і повертає `c`. Ось так, якщо ми викличемо функцію з занадто малою кількістю параметрів (тобто частково застосуємо її), ми повернемо функцію, яка приймає кількість параметрів, які ми залишили (якщо ми думаємо про функції, як знову приймати кілька параметрів). Отже, `a -> b -> c` можна записати як `a -> (b -> c)`, щоб зробити вигляд більш наочним.

In the same vein, if we write fmap :: (a -> b) -> (f a -> f b), we can think of fmap not as a function that takes one function and a functor and returns a functor, but as a function that takes a function and returns a new function that's just like the old one, only it takes a functor as a parameter and returns a functor as the result. It takes an a -> b function and returns a function f a -> f b. This is called lifting a function. Let's play around with that idea by using GHCI's :t command:
У такому ж ключі, якщо ми пишемо `fmap ::(a -> b) -> (fa -> fb)`, ми можемо думати про `fmap` не як про функцію, яка бере одну функцію та функтор і повертає функтор, а як функцію, яка приймає функцію і повертає нову функцію, подібно до старої, лише вона приймає функтор як параметр і повертає функтор як результат. Вона бере функцію `a -> b` і повертає функцію `f a -> f b`. Це називається підйомом функції. Давайте пограємо з цією ідеєю, використовуючи команду GHCI: `t:`

[source,haskell]
----
ghci> :t fmap (*2)  
fmap (*2) :: (Num a, Functor f) => f a -> f a  
ghci> :t fmap (replicate 3)  
fmap (replicate 3) :: (Functor f) => f a -> f [a]  
----

Вираз `fmap (* 2)`- це функція, яка приймає функтор `f` над числами і повертає функтор над числами. Цей функтор може бути списком, `Maybe`, `Either String` або будь чим. Вираз `fmap (replicate 3)` візьме функтор над будь-яким типом і поверне функтор над списком елементів цього типу.

Коли ми говоримо функтор над числами, ви можете думати про це як про функтор, який має в собі числа. Перший варіант трохи химерніший і технічніше правильний, але останній зазвичай простіше зрозуміти.

Це ще більш очевидно, якщо ми частково застосуємо, скажімо, `fmap (++ "!")`, і потім прив’яжемо його до імені в GHCI.

Ви можете вважати `fmap` або функцією, яка приймає функцію і функтор, а потім відображає цю функцію над функтором, або ви можете вважати це функцією, яка приймає функцію і піднімає цю функцію, щоб вона працювала на функторах. Обидва погляди правильні та в Haskell рівнозначні.

Тип `fmap (replicate 3) ::(Functor f) => f a -> f [a]` означає, що функція буде працювати на будь-якому функторі. Що саме воно буде робити, залежить від того, на якому функторі ми його будемо використовувати. Якщо ми використовуємо `fmap (replicate 3)` на списку, буде обрана реалізація списку для `fmap`, яка є лише `map`. Якщо ми будемо використовувати його на `Maybe a`, вона застосує `replicate 3` до значення всередині `Just`, або якщо це `Nothing`, то воно залишається `Nothing`.

[source,haskell]
----
ghci> fmap (replicate 3) [1,2,3,4]  
[[1,1,1],[2,2,2],[3,3,3],[4,4,4]]  
ghci> fmap (replicate 3) (Just 4)  
Just [4,4,4]  
ghci> fmap (replicate 3) (Right "blah")  
Right ["blah","blah","blah"]  
ghci> fmap (replicate 3) Nothing  
Nothing  
ghci> fmap (replicate 3) (Left "foo")  
Left "foo"  
----

Далі ми розглянемо закони функтора. Для того, щоб щось було функтором, воно повинно задовольняти деяким законам. Очікується, що всі функтори проявлятимуть певні типи функціональних властивостей та поведінки. Вони повинні надійно вести себе як речі, які можна відображувати. Виклик `fmap` на функторі повинен просто відображати функцію над функтором, не більше того. Така поведінка описана в законах функтора. Є два з них, якими повинні дотримуватися всі екземпляри `Functor`. Вони не застосовуються Haskell автоматично, тому вам доведеться перевірити їх самостійно.

Перший закон функторів зазначає, що якщо ми будемо відображати функцію `id` на функторі, той, який ми повернемо, повинен бути таким же, як і вихідний. Якщо ми напишемо це трохи формальніше, це означає, що `fmap id = id`. По суті це говорить про те, що якщо ми робимо `fmap id` над функтором, він повинен бути таким же, як просто виклик ідентичності на функторі. Пам'ятайте, `id` - це функція ідентичності, яка просто повертає немодифікований параметр. Його також можна записати як `\x -> x`. Якщо ми розглядаємо функтор як щось, що можна відобразити, закон `fmap id = id` видається тривіальним або очевидним.

Давайте подивимось, чи справедливий цей закон для кількох значень функторів.

[source,haskell]
----
ghci> fmap id (Just 3)  
Just 3  
ghci> id (Just 3)  
Just 3  
ghci> fmap id [1..5]  
[1,2,3,4,5]  
ghci> id [1..5]  
[1,2,3,4,5]  
ghci> fmap id []  
[]  
ghci> fmap id Nothing  
Nothing  
----

Якщо ми подивимось на реалізацію `fmap` для, скажімо, `Maybe`, ми можемо зрозуміти, чому існує перший закон функтора.

[source,haskell]
----
instance Functor Maybe where  
    fmap f (Just x) = Just (f x)  
    fmap f Nothing = Nothing  
----

Ми уявляємо, що `id` відіграє роль параметра `f` у реалізації. Ми бачимо, що якщо ми `fmap id` над `Just x`, результатом буде `Just (id x)`, і оскільки `id` просто повертає його параметр, ми можемо зробити висновок, що `Just (id x)` дорівнює `Just x`. Отже, тепер ми знаємо, що якщо відобразити ідентичність на значення `Maybe` з конструктором `Just`, ми повернемо це саме значення.

Бачити, що `id` відображення на значення `Nothing` повертає те саме значення, є тривіальним. Отже, з цих двох рівнянь у реалізації для `fmap` ми бачимо, що закон `fmap id = id` виконується.

image:images/justice.png[]
Другий закон говорить, що композиція двох функцій, а потім відображення отриманої функції через функтор має бути таким же, як спочатку відображення однієї функції над функтором, а потім відображення іншої. Формально це означає, що `fmap (f. G) = fmap f. fmap g`. Або, щоб записати це іншим способом, для будь-якого функтора `F` має дотримуватись таке: `fmap (f. G) F = fmap f (fmap g F)`.

Якщо ми можемо показати, що якийсь тип підкоряється обом законам функторів, ми можемо розраховувати на те, що він має ті ж основні поведінки, що й інші функтори, коли справа стосується відображення. Ми можемо знати, що коли ми використовуємо `fmap` на ній, не буде нічого, крім відображення, що відбувається за лаштунками, і що вона буде діяти як річ, яку можна відобразити, тобто функтор. Ви з'ясовуєте, як другий закон дотримується для певного типу, переглядаючи реалізацію `fmap` для цього типу, а потім використовуючи метод, який використовували ми, щоб перевірити, чи дотримується перший закон.

Якщо ви хочете, ми можемо перевірити, як діє закон другого функтора для `Maybe`. Якщо ми робимо `fmap (f. G)` над `Nothing`, ми отримуємо `Nothing`, тому що якщо виконати `fmap` з будь-якою функцією над `Nothing`, нічого не повертається. Якщо ми робимо `fmap f (fmap g Nothing)`, з тієї ж причини ми отримуємо `Nothing`. Гаразд, бачити, як діє другий закон на `Maybe` якщо це значення `Nothing`, це досить легко, майже тривіально.

Як щодо того, якщо це просто якесь `Just` значення? Що ж, якщо ми робимо `fmap (f . G) (Just x)`, то з реалізації ми бачимо, що воно реалізоване як `Just ( (f . G) x)`, що, звичайно, `Just (f (g x))`. Якщо ми робимо `fmap f (fmap g (Just x))`, то з реалізації бачимо, що `fmap g (Just x)` - це `Just (g x)`. Ergo, `fmap f (fmap g (Just x))` дорівнює `fmap f (Just (g x))`, і з реалізації ми бачимо, що це дорівнює `Just (f (g x))`.

Якщо вас трохи бентежить цей доказ, не хвилюйтесь. Будьте впевнені, що ви розумієте, як працює композиція функцій. Багато разів можна інтуїтивно побачити, як дотримуються ці закони, оскільки типи діють як контейнери або функції. Ви також можете просто спробувати їх на купі різних значень типу і мати можливість з певністю сказати, що тип дійсно підкоряється законам.

Давайте подивимося на патологічний приклад конструктора типу, який є екземпляром типу класу `Functor`, але насправді не є функтором, оскільки він не відповідає законам. Скажімо, у нас є тип:

[source,haskell]
----
data CMaybe a = CNothing | CJust Int a deriving (Show)  
----

The C here stands for counter. It's a data type that looks much like Maybe a, only the Just part holds two fields instead of one. The first field in the CJust value constructor will always have a type of Int, and it will be some sort of counter and the second field is of type a, which comes from the type parameter and its type will, of course, depend on the concrete type that we choose for CMaybe a. Let's play with our new type to get some intuition for it.
`C` тут означає лічильник. Це тип даних, який схожий на `Maybe a`, лише частина `Just` містить два поля замість одного. Перше поле в конструкторі значень `CJust` завжди матиме тип `Int`, і це буде якийсь лічильник, а друге поле типу `a`, яке походить від параметра типу, і його тип буде, звичайно, залежати від конкретного типу, який ми обираємо для `CMaybe a`. Давайте пограємо з нашим новим типом, щоб отримати певну інтуїцію.

[source,haskell]
----
ghci> CNothing  
CNothing  
ghci> CJust 0 "haha"  
CJust 0 "haha"  
ghci> :t CNothing  
CNothing :: CMaybe a  
ghci> :t CJust 0 "haha"  
CJust 0 "haha" :: CMaybe [Char]  
ghci> CJust 100 [1,2,3]  
CJust 100 [1,2,3]  
----

Якщо ми використовуємо конструктор `CNothing`, поля немає, і якщо ми використовуємо конструктор `CJust`, перше поле є цілим числом, а друге поле може бути будь-якого типу. Давайте зробимо це екземпляром `Functor` так, що кожного разу, коли ми використовуємо `fmap`, функція застосовується до другого поля, тоді як перше поле збільшується на 1.

[source,haskell]
----
instance Functor CMaybe where  
    fmap f CNothing = CNothing  
    fmap f (CJust counter x) = CJust (counter+1) (f x)  
----

Це на зразок реалізації екземпляра для `Maybe`, за винятком того, що коли ми робимо `fmap` над значенням, яке не являє собою порожнє поле (значення `CJust`), ми не просто застосовуємо функцію до вмісту, ми також збільшуємо лічильник на 1. Все поки здається крутим, ми навіть можемо трохи пограти з цим:

[source,haskell]
----
ghci> fmap (++"ha") (CJust 0 "ho")  
CJust 1 "hoha"  
ghci> fmap (++"he") (fmap (++"ha") (CJust 0 "ho"))  
CJust 2 "hohahe"  
ghci> fmap (++"blah") CNothing  
CNothing  
----

Це дотримується законів функтора? Для того, щоб побачити, що щось не підкоряється закону, достатньо знайти лише один суперечливий приклад.

[source,haskell]
----
ghci> fmap id (CJust 0 "haha")  
CJust 1 "haha"  
ghci> id (CJust 0 "haha")  
CJust 0 "haha"  
----

Ах! Ми знаємо, що перший закон функторів говорить, що якщо ми відображаємо `id` над функтором, він повинен бути таким самим, як просто виклик `id` тим самим функтором. Але, як ми бачили з цього прикладу, це не вірно для нашого функтора `CMaybe`. Незважаючи на те, що він є частиною типокласу `Functor`, він не підпорядковується законам функтора і тому не є функтором. Якщо би хтось використовував наш тип `CMaybe` як функтор, він би сподівався, що він виконує закони функтора, як хороший функтор. Але `CMaybe` не в змозі бути функтором, навіть якщо він видає себе за такий, тому використання його як функтора може призвести до дефектного коду. Коли ми використовуємо функтор, це не має значення, спочатку складемо кілька функцій, а потім відобразимо їх через функтор або якщо ми просто відображаємо кожну функцію над функтором послідовно. Але для `CMaybe` це важливо, тому що він відслідковує, скільки разів його відображали. Не круто! Якби ми хотіли, щоб `CMaybe` підкорявся законам функтора, нам довелося б зробити так, щоб поле `Int` залишалося таким же, коли ми використовуємо `fmap`.

Спочатку закони функтора можуть здатися трохи заплутаними та непотрібними, але потім ми бачимо, що якщо ми знаємо, що тип підкоряється обом законам, ми можемо зробити певні припущення щодо того, як він буде діяти. Якщо тип підкоряється законам функтора, ми знаємо, що виклик `fmap` у значенні цього типу буде відображати лише функцію над ним, не більше того. Це призводить до більш абстрактного та розширюваного коду, оскільки ми можемо використовувати закони, щоб міркувати про поведінку, яку повинен мати будь-який функтор, і робити функції, які надійно працюють на будь-якому функторі.

Усі екземпляри `Functor` у стандартній бібліотеці підкоряються цим законам, але ви можете перевірити, якщо ви мені не вірите. І наступного разу, коли ви введете екземпляр `Functor`, знайдіть хвилину, щоб переконатися, що він виконує закони функтора. Після того, як ви розібралися з достатньою кількістю функторів, ви начебто інтуїтивно бачите властивості та поведінку, які вони мають спільні, і не важко інтуїтивно зрозуміти, чи підпорядковується якийсь закон законам функтора. Але навіть не маючи інтуїції, ви завжди можете просто переходити по рядках реалізації та бачити, чи існують закони чи намагатися знайти контр приклад.

Ми також можемо розглядати функтори як речі, які виводять значення в контекст. Наприклад, `Just 3` виводить значення 3 у контексті того, що воно може взагалі не виводити будь-які значення. `[1,2,3]` виводить три значення - 1, 2 і 3, контекст полягає в тому, що може бути кілька значень або немає значень. Функція `(+3)` виведе значення залежно від того, який параметр буде заданий.

Якщо ви вважаєте функтори як речі, що виводять значення, ви можете вважати відображення функторів як приєднання перетворення до виходу функтора, що змінює значення. Коли ми робимо `fmap (+3) [1,2,3]`, ми додаємо перетворення `(+3)` до виводу `[1,2,3]`. Тому кожен раз, коли ми дивимося на число, яке виводить список, `(+ 3)` буде застосовано до нього. Інший приклад - відображення функцій. Коли ми робимо `fmap (+3) (* 3)`, ми додаємо перетворення `(+3)` до можливого виходу `(* 3)`. Дивлячись на це таким чином, ми даємо деяку інтуїцію, чому використання `fmap` для функцій є просто композицією `(fmap (+3) (* 3)` дорівнює `(+3). (* 3)`, що дорівнює `\ x -> ( (x * 3) +3))`. Оскільки ми беремо таку функцію, як `(* 3)`, тоді ми приєднуємо перетворення `(+3`) до її виводу. Результат все ще є функцією, лише коли ми дамо йому число, воно помножиться на три, а потім воно пройде через додане перетворення, де воно буде додане до трьох. Це те, що відбувається з композицією.

=== Аплікативні функтори

image:images/present.png[]
У цьому розділі ми розглянемо аплікативні функтори, які є зведеними функторами, представлені в Haskell типокласом Applicative, знайденим у модулі `Control.Applicative`.

Як відомо, у Haskell функції за замовчуванням каруються. Це означає, що функція, яка, здається, приймає декілька параметрів, насправді приймає лише один параметр і повертає функцію, яка приймає наступний параметр тощо. Якщо функція типу `a -> b -> c`, ми зазвичай кажемо, що вона бере два параметри і повертає `c`, але насправді вона займає `a` і повертає функцію `b -> c`. Ось чому ми можемо називати функцію як `f x y` або як `(f x) y`. Цей механізм дозволяє нам частково застосовувати функції, просто викликаючи їх із занадто малою кількістю параметрів, що призводить до функцій, які ми можемо потім передати іншим функціям.

Поки, коли ми відображували функції над функторами, ми зазвичай відображали функції, що приймають лише один параметр. Але що відбувається, коли ми відобразимо функцію типу * , яка приймає два параметри, над функтором? Давайте розглянемо пару конкретних прикладів цього. Якщо у нас є `Just 3` і ми робимо `fmap (* ) (Just 3)`, що ми отримуємо? З реалізації екземпляра `Maybe` для `Functor` ми знаємо, що якщо це значення `Just something`, воно застосує функцію до чогось усередині `Just`. Тому виконання `fmap (* ) (Just 3)` призводить до `Just ((* ) 3)`, який також може бути записаний як `Just (* 3)`, якщо ми використовуємо розділи. Цікаво! Ми отримуємо функцію, загорнуту в `Just`!

[source,haskell]
----
ghci> :t fmap (++) (Just "hey")  
fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])  
ghci> :t fmap compare (Just 'a')  
fmap compare (Just 'a') :: Maybe (Char -> Ordering)  
ghci> :t fmap compare "A LIST OF CHARS"  
fmap compare "A LIST OF CHARS" :: [Char -> Ordering]  
ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]  
fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]  
----

Якщо ми робимо `map compare`, яка має тип `(Ord a) => a -> a -> Ordering` над списком символів, ми отримаємо список функцій типу `Char -> Ordering`, оскільки функція `compare` частково застосовується з символами у списку. Це не список `(Ord a) => a -> Ordering`, тому що перший `a`, який застосовано, був `Char`, тому другий `a` повинен мати тип `Char`.

Ми бачимо, як відображаючи "багатопараметричні" функції над функторами, ми отримуємо функтори, що містять функції всередині них. То тепер, що ми можемо з ними зробити? Ну, по перше ми можемо відобразити функції, які приймають ці функції як параметри над ними, тому що все, що знаходиться всередині функтора, буде надано функції, яку ми відображаємо через нього як параметр.

[source,haskell]
----
ghci> let a = fmap (*) [1,2,3,4]  
ghci> :t a  
a :: [Integer -> Integer]  
ghci> fmap (\f -> f 9) a  
[9,18,27,36]  
----

Але що робити, якщо у нас є значення функтора `Just (3 *)` і значення функтора `Just 5`, і ми хочемо вийняти функцію з `Just (3 *)` і відобразити її на `Just 5`? З нормальними функторами нам не пощастило, адже все, що вони підтримують, - це лише відображення нормальних функцій на існуючі функтори. Навіть коли ми відображали `\f -> f 9` через функтор, який містив функції всередині нього, ми просто відображали нормальну функцію над ним. Але ми не можемо відобразити функцію, яка знаходиться у функторі, над іншим функтором із тим, що пропонує нам `fmap`. Ми могли б порівняти шаблон до конструктора `Just`, щоб отримати функцію з неї, а потім відобразити її на `Just 5`. Але ми шукаємо більш загальний та абстрактний спосіб зробити це, який працює у функторах.

Знайомтесь з типокласом `Applicative`. Він лежить у модулі `Control.Applicative`, і він визначає два способи, `pure` та `<*>`. Він не забезпечує реалізацію за замовчуванням для будь-якого з них, тому ми повинні визначати обидва, якщо ми хочемо, щоб щось було аплікативним функтором. Клас визначається так:

[source,haskell]
----
class (Functor f) => Applicative f where  
    pure :: a -> f a  
    (<*>) :: f (a -> b) -> f a -> f b  
----

Це просте визначення класу з трьох рядків нам багато чого говорить! Почнемо з першого рядка. Він починає визначення класу `Applicative`, а також вводить обмеження для класу. Це говорить про те, що якщо ми хочемо зробити конструктор типів частиною класу `Applicative`, він повинен бути спочатку у `Functor`. Ось чому, якщо ми знаємо, що якщо конструктор типу є частиною класу `Applicative`, він також знаходиться у `Functor`, і тому ми можемо використовувати на ньому `fmap`.

Перший метод, який він визначає, називається `pure`. Декларація типу є `pure ::a -> f a`. `f` тут відіграє роль нашого аплікативного функтора. Оскільки Haskell має дуже гарну систему типів і тому, що все, що функція може зробити, це взяти деякі параметри і повернути деяке значення, ми можемо багато сказати з декларації типу, і це не є винятком. `pure` повинен приймати значення будь-якого типу та повертати аплікативний функтор із цим значенням всередині. Коли ми говоримо всередині, ми знову використовуємо аналогію коробки, хоча ми бачили, що вона не завжди витримує критику. Але декларація типу `a -> f` все ще є досить описовою. Ми беремо значення і загортаємо його в аплікативний функтор, який має це значення як результат всередині.

Кращим способом мислення про `pure` було б сказати, що він приймає значення і ставить його в якийсь контекст за замовчуванням (або чистий) - мінімальний контекст, який все ще дає це значення.

Функція `<* >` дійсно цікава. Вона має декларацію типу `f (a -> b) -> f a -> f b`. Це вам щось нагадує? Звичайно, `fmap ::(a -> b) -> f a -> f b`. Це свого роду розгодований `fmap`. Тоді як `fmap` приймає функцію і функтор і застосовує функцію всередині функтора, `<*>` приймає функтор, який має в ньому функцію та інший функтор, і свого роду витягає цю функцію з першого функтора, а потім відображає його на другому. Коли я кажу витягає, я фактично маю на на увазі виконати, а потім витягнути, можливо навіть послідовність. Чому ми побачимо незабаром.

Давайте розглянемо реалізацію екземпляра `Applicative` для `Maybe`.

[source,haskell]
----
instance Applicative Maybe where  
    pure = Just  
    Nothing <*> _ = Nothing  
    (Just f) <*> something = fmap f something  
----

Знову з визначення класу ми бачимо, що `f`, що грає роль аплікативного функтора, повинен брати один параметр конкретного типу, тому ми пишемо `instance Applicative Maybe where`,  замість того, щоб писати `instance Applicative (Maybe а) where`.

По-перше `pure`. Раніше ми говорили, що його призначення щось взяти і загорнути в аплікативний функтор. Ми написали `pure = Just`, тому що конструктори значень як `Just` є нормальними функціями. Ми могли також написати `pure x = Just x`.

Далі ми маємо визначення для `<* >`. Ми не можемо витягти функцію з `Nothing`, оскільки воно не має функції всередині. Тому ми кажемо, що якщо ми намагаємося витягти функцію з `Nothing`, результат - `Nothing`. Якщо ви подивитесь на визначення класу для `Applicative`, ви побачите, що існує обмеження класу `Functor`, а це означає, що ми можемо припустити, що обидва параметра `<*>` є функторами. Якщо перший параметр - це не `Nothing`, а `Just` з деякою функцією всередині, ми говоримо, що потім хочемо відобразити цю функцію над другим параметром. Це також враховує випадок, коли другим параметром є `Nothing`, тому що виконання `fmap` з будь-якою функцією над `Nothing` поверне `Nothing`.

Тож для `Maybe` `<*>` витягує функцію з лівого значення, якщо це `Just`, і відображає його над правим значенням. Якщо будь-який з параметрів є `Nothing`, результат буде `Nothing`.

Добре круто чудово. Дамо цьому вир.

[source,haskell]
----
ghci> Just (+3) <*> Just 9  
Just 12  
ghci> pure (+3) <*> Just 10  
Just 13  
ghci> pure (+3) <*> Just 9  
Just 12  
ghci> Just (++"hahah") <*> Nothing  
Nothing  
ghci> Nothing <*> Just "woot"  
Nothing  
----

Ми бачимо, як `pure (+3)` і `Just (+3)` те саме в цьому випадку. Використовуйте `pure`, якщо ви маєте справу зі значеннями `Maybe` в аплікативному контексті (тобто, використовуючи їх з `<*>`), інакше дотримуйтесь `Just`. Перші чотири вхідні рядки демонструють, як функція витягується та потім відображається, але в цьому випадку їх можна було досягти, просто зіставивши розгорнуті функції по функторам. Останній рядок цікавий тим, що ми намагаємося витягти функцію з `Nothing`, а потім відобразити її через щось, що, звичайно, призводить до `Nothing`.

З нормальними функторами ви можете просто зіставити функцію над функтором, і тоді ви не зможете отримати результат жодним загальним способом, навіть якщо результат є частково застосованою функцією. З іншого боку, аплікативні функтори дозволяють керувати кількома функторами з однією функцією. Ознайомтеся з цим кодом:

[source,haskell]
----
ghci> pure (+) <*> Just 3 <*> Just 5  
Just 8  
ghci> pure (+) <*> Just 3 <*> Nothing  
Nothing  
ghci> pure (+) <*> Nothing <*> Just 5  
Nothing  
----

image:images/whale.png[]
Що тут відбувається? Давайте подивимось, крок за кроком. `<* >` є ліво-асоціативним, що означає, що `pure (+) <*> Just 3 <*> Just 5` - це те саме, що `(pure (+) <*> Just 3) <*> Just 5`. По-перше, функція `+`  розміщується у функторі, що в цьому випадку є значення `Maybe`, яке містить функцію. Отже, спочатку у нас є `pure (+)`, а це `Just (+)`. Далі трапляється `Just (+) <* > Just 3`. Результат цього - `Just (3+)`. Це відбувається через часткове застосування. Лише застосування `3` до функції `+` призводить до функції, яка бере один параметр і додає до нього `3`. Нарешті, виконується `Just (3+) <*> Just 5`, що призводить до отримання `Just 8`.

Хіба це не дивовижно ?! Аплікативні функтори та аплікативний стиль виконання `pure f <* > x <*> y <*>` ... дозволяють нам взяти функцію, яка очікує параметри, які не обов'язково загорнуті у функтори, і використовувати цю функцію для роботи на кількох значеннях які є у контекстах функтора. Функція може приймати стільки параметрів, скільки ми хочемо, оскільки вона завжди частково застосовується крок за кроком між зустрічними `<*>`.

This becomes even more handy and apparent if we consider the fact that pure f <*> x equals fmap f x. This is one of the applicative laws. We'll take a closer look at them later, but for now, we can sort of intuitively see that this is so. Think about it, it makes sense. Like we said before, pure puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, we did the same as just mapping that function over that applicative functor. Instead of writing pure f <*> x <*> y <*> ..., we can write fmap f x <*> y <*> .... This is why Control.Applicative exports a function called <$>, which is just fmap as an infix operator. Here's how it's defined:
Це стає ще більш зручним і очевидним, якщо врахувати той факт, що `pure f <* > x` дорівнює `fmap f x`. Це один із аплікативних законів. Ми детальніше розглянемо їх пізніше, але наразі ми можемо якось інтуїтивно побачити, що це так. Подумайте про це, воно має сенс. Як ми говорили раніше, `pure` ставить значення в контексті за замовчуванням. Якщо ми просто помістимо функцію в контекст за замовчуванням, а потім витягнемо і застосуємо її до значення всередині іншого аплікативного функтора, ми зробили те саме, що просто відобразили цю функцію над цим аплікативним функтором. Замість того, щоб писати `pure f <* > x <*> y <*>` ..., ми можемо написати `fmap fx <*> y <*>` .... Ось чому `Control.Applicative` експортує функцію під назвою `<$>`, яка є просто `fmap` як інфіксний оператор. Ось як вона визначена:

[source,haskell]
----
(<$>) ::(Functor f) => (a -> b) -> f a -> f b  
f <$> x = fmap f x  
----

Йо! Швидке нагадування: змінні типу не залежать від імен параметрів чи інших імен значень. Тут `f` в декларції функції - це змінна типу з обмеженням класу, яка говорить про те, що будь-який конструктор типу, який замінює `f`, повинен бути в типокласі `Functor`. `f` в тілі функції позначає функцію, яку ми відображаємо через `x`. Те, що ми використовували `f` для представлення обох, не означає, що вони якимось чином представляють те саме.

Використовуючи `<$>`, аплікативний стиль дійсно сяє, тому що тепер, якщо ми хочемо застосувати функцію `f` між трьома прикладними функторами, ми можемо записати `f <$> x <*> y <*> z`. Якби параметри були не аплікативними функторами, а нормальними значеннями, ми б записали `f x y z`.

Давайте докладніше розглянемо, як це працює. У нас є значення `Just "johntra"` і значення `Just "volta"`, і ми хочемо об'єднати їх в один рядок всередині `Maybe` функтора. Ми робимо це:

[source,haskell]
----
ghci> (++) <$> Just "johntra" <*> Just "volta"  
Just "johntravolta"  
----

Перш ніж ми побачимо, як це відбувається, порівняйте наведений рядок із цим:

[source,haskell]
----
ghci> (++) "johntra" "volta"  
"johntravolta"  
----

Дивовижно! Щоб використовувати звичайну функцію на аплікативних функторах, просто посипте кілька `<$>` і `<*>`, і функція буде працювати над аплікативах та повертати аплікатив. Наскільки це круто?

У будь-якому разі, коли ми робимо `(++) <$> Just "johntra" <* > Just "volta"`, перший `(++)`, який має тип `(++) ::[a] -> [a] - > [a]` відображається на просто `"johntra"`, в результаті чого значення є таким же, як `Just ("johntra" ++)` і має тип `Maybe ([Char] -> [Char])`. Зверніть увагу, як перший параметр `(++)` був з'їдений та як перетворився на `Chars`. І тепер відбувається `Just ("johntra" ++) <*> Just "volta"`, яка виймає функцію з `Just` і відображає її на `Just "volta"`, в результаті чого отримуємо `Just "johntravolta"`. Якби будь-яке з двох значень було `Nothing`, результат також був би `Nothing`.

Поки що ми використовували тільки `Maybe` в наших прикладах, і ви можете думати, що аплікативні функтори - це все про `Maybe`. Але існує маса інших примірників `Applicative`, тому підемо і познайомимось з ними!

Списки (власне конструктор типу списку, `[]`) - це аплікативні функтори. Який сюрприз! Ось як `[]` є екземпляром `Applicative`:

[source,haskell]
----
instance Applicative [] where  
    pure x = [x]  
    fs <*> xs = [f x | f <- fs, x <- xs]  
----

Раніше ми говорили, що `pure` приймає значення і ставить його в контекст за замовчуванням. Або іншими словами, мінімальний контекст, який все-таки приносить це значення. Мінімальним контекстом для списків буде порожній список, `[]`, але порожній список представляє відсутність значення, тому він не може утримувати в собі значення, для якого ми використовували `pure`. Ось чому `pure` приймає значення і ставить його в одиночний список. Аналогічним чином, мінімальний контекст для аплікативного функтора `Maybe` був би `Nothing`, але він представляє відсутність значення замість значення. Так що `pure` реалізується як `Just` в реалізації екземпляра для `Maybe`.

[source,haskell]
----
ghci> pure "Hey" :: [String]  
["Hey"]  
ghci> pure "Hey" :: Maybe String  
Just "Hey"  
----

Що до `<*>`? Якщо ми подивимось на тип `<*>`, якби він був обмежений лише списками, це було б `(<*>) ::[a -> b] -> [a] -> [b]`. Він реалізований за допомогою осяжності списку. `<*>` має якось витягнути функцію з лівого параметра, а потім відобразити її через правий параметр. Але справа в тому, що лівий список може мати нуль функцій, одну функцію або кілька функцій всередині. Правий список також може містити кілька значень. Ось чому ми використовуємо осяжність списку, щоб зписувати з обох списків. Ми застосовуємо всі можливі функції з лівого списку до кожного можливого значення з правого списку. Отриманий список має всі можливі поєднання застосування функції з лівого списку до значеннь у правому.

[source,haskell]
----
ghci> [(*0),(+100),(^2)] <*> [1,2,3]  
[0,0,0,101,102,103,1,4,9]  
----

У лівому списку є три функції, а в правому - три значення, тому в отриманому списку буде дев'ять елементів. Кожна функція у лівому списку застосовується до кожної функції у правій. Якщо у нас є список функцій, які приймають два параметри, ми можемо застосувати ці функції між двома списками.

[source,haskell]
----
ghci> [(+),(*)] <*> [1,2] <*> [3,4]  
[4,5,5,6,3,4,6,8]  
----

Оскільки `<* >`є ліво-асоціативним, `[(+), (*)] <*> [1,2]` відбувається спочатку, в результаті виходить список, такий же як `[(1 +), (2 +), (1 *), (2 *)]`, оскільки кожна функція зліва застосовується до кожного значення праворуч. Потім відбувається `[(1 +), (2 +), (1 *), (2 *)] <*> [3,4]`, що дає кінцевий результат.

Використання додаткового стилю зі списками - це цікаво! Дивитися:

[source,haskell]
----
ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]  
["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]  
----

Знову, подивіться, як ми використовували звичайну функцію, яка приймає два рядки між двома аплікативними функторами рядків, просто вставивши відповідні аплікативні оператори.

Ви можете розглядати списки як недетерміновані обчислення. Значення типу `100` або `"what"` можна розглядати як детерміновані обчислення, які мають лише один результат, тоді як список типу `[1,2,3]` можна розглядати як обчислення, яке не може визначити, який результат він хоче мати , тож це дає нам усі можливі результати. Отже, коли ви робите щось на кшталт `(+) <$> [1,2,3] <*> [4,5,6]`, ви можете вважати це як додавання двох недетермінованих обчислень за допомогою `+` для створення іншого недетерміновані обчислення, і навіть менше впевнені в його результаті.

Використання аплікативного стилю на списках часто є хорошою заміною для осяжності списків. У другому розділі ми хотіли побачити всі можливі добутки `[2,5,10]` та `[8,10,11]`, тому ми робили таке:

[source,haskell]
----
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]     
[16,20,22,40,50,55,80,100,110]     
----

Ми просто списуємо з двох списків і застосовуємо функцію між кожною комбінацією елементів. Це також можна зробити в аплікативному стилі:

[source,haskell]
----
ghci> (*) <$> [2,5,10] <*> [8,10,11]  
[16,20,22,40,50,55,80,100,110]  
----

Мені це здається прозорішим, оскільки простіше зрозуміти, що ми просто викликаємо `*` між двома недетермінованими обчисленнями. Якби б ми хотіли отримати усі можливі добутки з цих двох списків, що більше 50, ми просто зробили:

[source,haskell]
----
ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]  
[55,80,100,110]  
----

Неважко зрозуміти, що чистий для списків `f <* > xs` дорівнює `fmap f xs`. `pure f` - це просто `[f]` і `[f] <*> xs` застосує кожну функцію у лівому списку до кожного значення у правому, але в лівому списку є лише одна функція, тож це як відображення.

Ще один екземпляр `Applicative`, з яким ми вже стикалися, - це `IO`. Ось як реалізується екземпляр:

[source,haskell]
----
instance Applicative IO where  
    pure = return  
    a <*> b = do  
        f <- a  
        x <- b  
        return (f x)  
----

image:images/knight.png[]
Оскільки `pure` полягає лише у тому, щоб поставити значення в мінімальний контекст, який все-таки вважає його результатом, має сенс, що `pure` - це просто `return`, оскільки `return` робить саме це; вона робить дію вводу-виводу, яка нічого не робить. Вона дає лише деяке значення як результат, але насправді не виконує жодних операцій вводу-виводу, таких як друк до терміналу або зчитування з файлу.

Якби `<* >` були спеціалізовані для `IO`, він мав би тип `(<*>) ::IO (a -> b) -> IO a -> IO b`. Воно братиме дію вводу-виводу, що видає функцію як результат, іншу дію вводу-виводу і створить нову дію вводу-виводу з тих двох, які, виконуючись, спочатку виконують першу для отримання функції, потім виконують другу - отримати значення. І тоді отримуємо функцію, застосовану до значення як результат. Ми використовували для реалізації `do` синтаксис. Пам'ятайте, що `do` синтаксис - це взяти кілька дій вводу-виводу та склеїти їх в одне, саме це ми тут і робимо.

З `Maybe` і `[]` ми могли б вважати `<*>` просто вилученням функції з її лівого параметра, а потім свого роду застосуванням її над правим. З `IO` вилучення все ще в грі, але тепер ми також маємо поняття послідовності, тому що ми робимо дві дії вводу-виводу і ми впорядковуємо або склеюємо їх в одну. Ми повинні дістати функцію з першої дії вводу-виводу, але для отримання результату дії вводу-виводу вона повинна бути виконана.

Розглянемо це:

[source,haskell]
----
myAction :: IO String  
myAction = do  
    a <- getLine  
    b <- getLine  
    return $ a ++ b  
----

Це дія вводу-виводу, яка запитує користувача ввести два рядки і результатом має поєднання ціх рядків. Ми досягли цього, склеївши дві `I/O` дії `getLineта` та `return`, тому що ми хотіли, щоб наша нова зклеєна дія мала результат `a ++ b`. Ще одним способом написання цього було б використання аплікативного стилю.

[source,haskell]
----
myAction :: IO String  
myAction = (++) <$> getLine <*> getLine  
----

Те, що ми робили раніше, створювало дію вводу-виводу, яка застосовувала функцію між результатами двох інших дій вводу-виводу, і це те саме. Пам'ятайте, `getLine` - це введення-виведення з типом `getLine ::IO String`. Коли ми використовуємо `<*>` між двома аплікативними функторами, результат є аплікативним функтором, тому все це має сенс.

Якщо ми повернемось до аналогії коробки, ми можемо уявити `getLine` як коробку, яка вийде в реальний світ і підтягне нам рядок. Виконання `(++) <$> getLine <*> getLine` створює нову, більшу скриньку, яка надсилає ці дві скриньки для отримання рядків з терміналу, а потім представляє конкатенацію цих двох рядків як результат.

Тип виразу `(++) <$> getLine <*> getLine` - це `IO String`, а це означає, що це вираз є абсолютно нормальною дією вводу/виводу, як і будь-яка інша, яка також містить значення результату всередині, як і інші дії вводу/виводу. Ось чому ми можемо робити такі речі, як:

[source,haskell]
----
main = do  
    a <- (++) <$> getLine <*> getLine  
    putStrLn $ "The two lines concatenated turn out to be: " ++ a  
----

Якщо ви коли-небудь виявляєте, що пов’язуєте деякі дії вводу-виводу з іменами, а потім викликаєте якусь функцію на них і представляєте це як результат, використовуючи `return`, подумайте про використання аплікативного стилю, тому що це, можливо, трохи більш стисло і коротко.

Ще один екземпляр `Applicative` - `(->) r`, тобто функції. Вони рідко використовуються у застосувальному стилі поза кодовим гольфом, але вони все ще цікаві як аплікативи, тому давайте подивимось на те, як реалізується екземпляр функції.

If you're confused about what (->) r means, check out the previous section where we explain how (->) r is a functor.
Якщо вас бентежить питання про те, що означає `(->) r`, перегляньте попередній розділ, де ми пояснюємо, як `(->) r` може бути функтором.

[source,haskell]
----
instance Applicative ((->) r) where  
    pure x = (\_ -> x)  
    f <*> g = \x -> f x (g x)  
----

Коли ми перетворюємо значення в аплікативний функтор за допомогою `pure`, результат, який він отримує, завжди повинен бути таким значенням. Мінімальний контекст за замовчуванням, який як і раніше дає це значення. Ось чому в реалізації екземпляра функції `pure` приймає значення і створює функцію, яка ігнорує його параметр і завжди повертає це значення. Якщо ми подивимось на тип для `pure`, але спеціалізованого для екземпляра (->) r, це `pure ::a -> (r -> a)`.

[source,haskell]
----
ghci> (pure 3) "blah"  
3  
----

Через карування застосування функції є ліво-асоціативним, тому ми можемо опустити дужки.

[source,haskell]
----
ghci> pure 3 "blah"  
3  
----

Реалізація екземпляра для `<*>` трохи зашифрована, тому найкраще, якщо ми просто подивимось на те, як використовувати функції в якості аплікативних функторів в аплікативному стилі.

[source,haskell]
----
ghci> :t (+) <$> (+3) <*> (*100)  
(+) <$> (+3) <*> (*100) :: (Num a) => a -> a  
ghci> (+) <$> (+3) <*> (*100) $ 5  
508  
----

Виклик `<* >` на двох аплікативних функторах призводить до отримання аплікативного функтора, тому, якщо ми будемо використовувати його на двох функціях, ми повернемо функцію. То що тут відбувається? Коли ми робимо `(+) <$> (+3) <*> (* 100)`, ми створюємо функцію, яка використовуватиме `+` на результатах `(+3)` і `(* 100)` і повертаємо її. Щоб продемонструвати на реальному прикладі, коли ми зробили `(+) <$> (+3) <*> (* 100) $ 5`, 5 спочатку застосували до `(+3)` та `(* 100)`, в результаті чого отримали `8` та `500`. Потім `+` визивається з `8` і `500`, в результаті чого стає `508`.

[source,haskell]
----
ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5  
[8.0,10.0,2.5]  
----

image:images/jazzb.png[]
Тут те ж саме. Ми створюємо функцію, яка буде викликати функцію `\x y z -> [x, y, z]` з можливими результатами з `(+3)`, `(* 2)` і `(/ 2)`. `5` подається до кожної з трьох функцій, а потім `\ x y z -> [x, y, z]` викликається з ціма результатами.

Ви можете розглядати функції як коробки, що містять їх кінцеві результати, тому виконання `k <$> f <* > g` створює функцію, яка буде викликати `k` з кінцевими результатами з `f` і `g`. Коли ми робимо щось на зразок `(+) <$> Just 3 <* > Just 5`, ми використовуємо `+` на значеннях, які можуть бути або не бути там, що також призводить до значення, яке може бути або не бути там. Коли ми робимо `(+) <$> (+10) <*> (+5)`, ми використовуємо `+` на майбутніх повернених значеннях `(+10)` і `(+5)`, і результат також буде чимось, що буде продукувати значення тільки якщо викликано з параметром.

Ми часто не використовуємо функції як аплікативи, але це все одно цікаво. Не дуже важливо зрозуміти, як працює екземпляр `(->) r` для `Applicative`, тому не впадайте у відчай, якщо ви зараз не отримуєте цього. Спробуйте пограти з аплікативним стилем і функціями, щоб створити інтуїцію щодо функціональних анлікативів.

Екземпляр `Applicative`, з яким ми ще не стикалися, - це `ZipList`, і він живе в `Control.Applicative`.

Виявляється, насправді існує більше способів, щоб списки були аплікативними функторами. Один із способів - це вже описаний нами, який говорить про те, що виклик `<* >` зі списком функцій та списком значень призводить до списку, який містить усі можливі комбінації застосування функцій з лівого списку до значень у правому списку . Якщо у нас `[(+3), (* 2)] <* > [1,2]`, `(+3)` буде застосовано як до `1` і до `2`, `(* 2)` також буде застосовано до `1` і до `2`, в результаті виходить список, який містить чотири елементи, а саме `[4,5,2,4]`.

Однак `[(+3), (* 2)] <*> [1,2]` також може працювати таким чином, що перша функція в лівому списку буде застосована до першого значення в правому, друга функція застосовується до другого значення тощо. Це призвело б до списку з двома значеннями, а саме `[4,4]`. Ви можете розглядати це як `[1 + 3, 2 * 2]`.

Оскільки один тип не може мати два екземпляри для одного класу, введено тип `ZipList`, який має один конструктор `ZipList`, який має лише одне поле, і це поле є списком. Ось приклад:

[source,haskell]
----
instance Applicative ZipList where  
        pure x = ZipList (repeat x)  
        ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)  
----

`<*>` робить саме те, що ми сказали. Він застосовує першу функцію до першого значення, другу функцію до другого значення тощо. Це робиться за допомогою zipWith `(\ f x -> f x) fs xs`. Через те, як працює `zipWith`, отриманий список буде в довжину як коротший з двох списків.

Тут також цікавий `pure`. Він приймає значення і вносить його до списку, який просто повторює це значення без кінця. `pure "haha"` призводить до `ZipList (["haha", "haha", "haha"` .... Це може дещо спантеличити, оскільки ми говорили, що `pure` повинен ставити значення в мінімальний контекст, який все ще дає це значення. І ви можете думати, що нескінченний перелік чогось навряд чи мінімальний, але це має сенс у zip-списках, оскільки він повинен створювати значення для кожної позиції. Це також задовольняє закону, що `pure f <* > xs` повинен дорівнювати `fmap f xs` Якщо `pure 3` щойно повернув `ZipList [3]`, `pure (* 2) <*> ZipList [1,5,10]` призведе до отримання `ZipList [2]`, тому що результуючий список двох спарованих списків має довжину меншого з двох. Якщо ми поєднаємо скінчений список з нескінченним списком, довжина результуючого списку завжди буде дорівнює довжині скінченого списку.

Отже, як zip списки працюють арлікативному стилі? Подивимось. Ага, тип `ZipList` не має екземпляра `Show`, тому нам потрібно використовувати функцію `getZipList` для вилучення сирого списку зі списку zip.

[source,haskell]
----
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]  
[101,102,103]  
ghci> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100..]  
[101,102,103]  
ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]  
[5,3,3,4]  
ghci> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"  
[('d','c','r'),('o','a','a'),('g','t','t')]  
----

Функція `(,,)` така сама, як `\x y z -> (x, y, z)`. Також функція `(,)` така сама, як `\x y -> (x, y)`.

Окрім `zipWith`, стандартна бібліотека має такі функції, як `zipWith3`, `zipWith4`, аж до 7. `zipWith` приймає функцію, яка приймає два параметри та поєднує два списки в свій спосіб. `zipWith3` приймає функцію, яка приймає три параметри і пов'язує три списки тощо. Використовуючи zip списки в аплікативному стилі, нам не потрібно мати окрему функцію zip для кожного числа списків, які ми хочемо зібрати разом. Ми просто використовуємо аплікативний стиль, щоб зібрати довільну кількість списків функцією, і це дуже круто.

`Control.Applicative` визначає функцію з назвою `liftA2`, яка має тип `liftA2 ::(Applicative f) => (a -> b -> c) -> f a -> f b -> f c`. Це визначено так:

[source,haskell]
----
liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c  
liftA2 f a b = f <$> a <*> b  
----

Нічого особливого, вона просто застосовує функцію між двома аплікативами, приховуючи знайомий нам аплікативний стиль. Причина, з якої ми її розглядаємо, полягає в тому, що це чітко демонструє, чому аплікативні функтори є потужнішими, ніж просто звичайні. За допомогою звичайних функторів ми можемо просто відображати функції над одним функтором. Але за допомогою аплікативних функторів ми можемо застосувати функцію між кількома функторами. Також цікаво подивитися на тип цієї функції як `(a -> b -> c) -> (f a -> f b -> f c)`. Якщо ми подивимось на це таким чином, то можна сказати, що `liftA2` приймає нормальну двомісну функцію і перетворює її на функцію, яка працює на двох функторах.

Ось цікава концепція: ми можемо взяти два аплікативних функтора і об'єднати їх в один аплікативний функтор, який має в ньому результати цих двох функторів у списку. Наприклад, у нас є `Just 3` і `Just 4`. Припустимо, що другий має в своєму розпорядженні список синглтон, тому що цього дуже легко досягти:

[source,haskell]
----
ghci> fmap (\x -> [x]) (Just 4)  
Just [4]  
----

Добре, тож скажімо, у нас `Just 3` і `Just [4]`. Як ми отримуємо `Just [3,4]`? Легко.

[source,haskell]
----
ghci> liftA2 (:) (Just 3) (Just [4])  
Just [3,4]  
ghci> (:) <$> Just 3 <*> Just [4]  
Just [3,4]  
----

Пам'ятайте, `:` це функція, яка бере елемент і список і повертає новий список з цим елементом на початку. Тепер, коли у нас є `Just [3,4]`, чи могли б ми поєднати це з `Just 2` для отримання `Just [2,3,4]`? Звичайно, ми могли. Здається, що ми можемо поєднати будь-яку кількість аплікативів в один, який містить в собі список результатів цих аплікативів. Спробуємо реалізувати функцію, яка бере список аплікативів і повертає аплікатив, який має список як значення результату. Ми будемо називати її `sequenceA`.

[source,haskell]
----

sequenceA ::(Applicative f) => [f a] -> f [a]  
sequenceA [] = pure []  
sequenceA (x:xs) = (:) <$> x <*> sequenceA xs  
----

Так, рекурсія! Спочатку подивимось на тип. Це перетворить список аплікативів в аплікатив зі списком. Виходячи з цього, ми можемо закласти деякі основи для крайових умов. Якщо ми хочемо перетворити порожній список у апликатив із переліком результатів, ми просто поставимо порожній список у контекст за замовчуванням. Зараз настає рекурсія. Якщо у нас є список з головою і хвостом (пам’ятайте, `x` - аплікатив, а `xs` - список з них), ми викликаємо `sequenceA` на хвості, в результаті матимемо аплікатив із списком. Тоді ми просто додаємо значення всередині аплікатива `x` до цього аплікатива зі списком, і це все!

Отже, якщо ми робимо `sequenceA [Just 1, Just 2]`, це `(:) <$> Just 1 <* >  sequenceA [Just 2]`. Це дорівнює `(:) <$> Just 1 <* > ((:) <$> Just 2 <* > sequenceA [])`. А! Ми знаємо, що `sequenceA []` закінчується як `Just []`, тому цей вираз зараз `(:) <$> Just 1 <* > ((:) <$> Just 2 <* > Just [])`, що є `((:) <$> Just 1 <*> Just [2]`, що `Just [1,2]`!

Інший спосіб реалізації `sequenceA` - це `fold`. Пам'ятайте, що майже будь-яка функція, де ми переходимо елементами списку і накопичуємо по дорозі результат, може бути реалізована через `fold`.

[source,haskell]
----
sequenceA :: (Applicative f) => [f a] -> f [a]  
sequenceA = foldr (liftA2 (:)) (pure [])  
----

Ми підходимо до списку праворуч і починаємо з акумуляторного значення `pure []`. Ми робимо `liftA2 (:)` між акумулятором і останнім елементом списку, що призводить до аплікатива з синглтоном всередині. Потім робимо `liftA2 (:)` з останнім елементом і поточним акумулятором тощо), поки ми не залишимося лише з акумулятором, який містить список результатів усіх аплікативів.

Дамо нашим функціям крутитись на деяких аплікативів.

[source,haskell]
----
ghci> sequenceA [Just 3, Just 2, Just 1]  
Just [3,2,1]  
ghci> sequenceA [Just 3, Nothing, Just 1]  
Nothing  
ghci> sequenceA [(+3),(+2),(+1)] 3  
[6,5,4]  
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2,3],[4,5,6],[3,4,4],[]]  
[]  
----

Ах! Дуже гарно. При використанні значень `Maybe`, `sequenceA` створює значення `Maybe` з усіма результатами всередині нього як список. Якщо одним із значень було `Nothing`, то результат також є `Nothing`. Це здорово, коли у вас є список значень `Maybe`, і ви цікавитесь значеннями, якщо жодне з них не є `Nothing`.

При використанні з функціями `sequenceA` приймає список функцій і повертає функцію, яка повертає список. У нашому прикладі ми створили функцію, яка приймає число як параметр і застосувала його до кожної функції у списку, а потім повернула список результатів. `sequenceA [(+3), (+ 2), (+ 1)] 3` викличе `(+3)` з `3`, `(+2)` з `3` і `(+1)` з `3` і представить усі ці результати у списку.

Виконання `(+) <$> (+3) <*> (* 2)` створить функцію, яка приймає параметр, подає його в обидва `(+3)` і `(* 2)`, а потім викликає `+` з цими двома результатами. У цьому ж дусі є сенс, що `sequenceA [(+3), (* 2)]` створює функцію, яка приймає параметр і подає його на всі функції у списку. Замість виклику `+` з результатами функцій використовується комбінація `:` і `pure []` для збору цих результатів у список, який є результатом цієї функції.

Використання `sequenceA` це здорово, коли у нас є список функцій, і ми хочемо подати один і той же вхід для всіх, а потім переглянути список результатів. Наприклад, у нас є число, і нам цікаво, чи задовольняє воно всім предикатам в списку. Один із способів зробити це:

[source,haskell]
----
ghci> map (\f -> f 7) [(>4),(<10),odd]  
[True,True,True]  
ghci> and $ map (\f -> f 7) [(>4),(<10),odd]  
True  
----

Пам'ятайте, `and` бере список логічних і повертає `True`, якщо вони всі `True`. Ще один спосіб досягти того ж, що було б із `sequenceA`:

[source,haskell]
----
ghci> sequenceA [(>4),(<10),odd] 7  
[True,True,True]  
ghci> and $ sequenceA [(>4),(<10),odd] 7  
True  
----

`sequenceA [(> 4), (<10), odd]` створює функцію, яка буде приймати число і подавати його всім предикатам у `[(> 4), (<10), odd]` і повертає список логічних значень. Це перетворює список із типом `(Num a) => [a -> Bool]` у функцію з типом `(Num a) => a -> [Bool]`. Досить акуратно, так?

Оскільки списки є однорідними, звичайно, всі функції у списку повинні бути функціями одного типу. У вас не може бути списку типу `[ord, (+3)]`, оскільки `ord` приймає символ і повертає число, тоді як `(+3)` бере число і повертає число.

Якщо використовується з `[]`, `sequenceA` приймає список списків і повертає список списків. Хм, це цікаво. Він фактично створює списки, у яких є всі можливі комбінації їх елементів. Для ілюстрації, ось описане вище, зроблене за допомогою `sequenceA`, а потім зроблене із осяжністю списку:

[source,haskell]
----
ghci> sequenceA [[1,2,3],[4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> [[x,y] | x <- [1,2,3], y <- [4,5,6]]  
[[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]  
ghci> sequenceA [[1,2],[3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> [[x,y] | x <- [1,2], y <- [3,4]]  
[[1,3],[1,4],[2,3],[2,4]]  
ghci> sequenceA [[1,2],[3,4],[5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
ghci> [[x,y,z] | x <- [1,2], y <- [3,4], z <- [5,6]]  
[[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]  
----

Це може бути трохи важко зрозуміти, але якщо ви пограєте з ним деякий час, ви побачите, як це працює. Скажімо, ми робимо `sequenceA [[1,2], [3,4]]`. Щоб побачити, як це відбувається, давайте скористаємося визначенням `sequenceA (x: xs) = (:) <$> x <*> sequenceA xs` та граничною умовою `sequenceA [] = pure []`. Вам не доведеться слідувати цьому обчисленню, але це може допомогти вам, якщо у вас виникнуть проблеми уявити, як `sequenceA` працює на списках списків.

* Почнемо з `sequenceA [[1,2], [3,4]]`
* Це обчислюється до `(:) <$> [1,2] <*> sequenceA [[3,4]]`
* Далі оцінюючи внутрішню `sequenceA`, отримуємо `(:) <$> [1,2] <*> ((:) <$> [3,4] <*> sequenceA [])`
* Ми досягли граничної умови, тому це зараз `(:) <$> [1,2] <* > ((:) <$> [3,4] <*> [[]])`
Now, we evaluate the (:) <$> [3,4] <*> [[]] part, which will use : with every possible value in the left list (possible values are 3 and 4) with every possible value on the right list (only possible value is []), which results in [3:[], 4:[]], which is [[3],[4]]. So now we have (:) <$> [1,2] <*> [[3],[4]]
* Тепер ми оцінюємо частину `(:) <$> [3,4] <* > [[]]`, яка використовуватиме `:` з кожним можливим значенням у лівому списку (можливі значення `3` та `4`) з кожним можливим значенням на правий список (можливе лише значення `[]`), в результаті якого виходять `[3: [], 4: []]`, що є `[[3], [4]]`. Отже, тепер у нас є `(:) <$> [1,2] <*> [[3], [4]]`
Now, : is used with every possible value from the left list (1 and 2) with every possible value in the right list ([3] and [4]), which results in [1:[3], 1:[4], 2:[3], 2:[4]], which is [[1,3],[1,4],[2,3],[2,4]
Тепер `:` використовується з усіма можливими значеннями з лівого списку (`1` і `2`) з кожним можливим значенням у правому списку (`[3]` та `[4]`), що призводить до `[1: [3], 1: [4 ], 2: [3], 2: [4]]`, що є `[[1,3], [1,4], [2,3], [2,4]`

Виконання `(+) <$> [1,2] <*> [4,5,6]` призводить до недетермінованого обчислення `x + y`, де `x` приймає кожне значення від `[1,2]`, а y приймає кожне значення від `[4,5,6]`. Ми представляємо це як список, який містить усі можливі результати. Аналогічно, коли ми робимо послідовності `[[1,2], [3,4], [5,6], [7,8]]`, результат - недетерміновані обчислення `[x, y, z, w]`, де `x` приймає кожне значення від `[1,2]`, `y` приймає кожне значення від `[3,4]` тощо. Щоб представити результат цього недетермінованого обчислення, ми використовуємо список, де кожен елемент у списку - один можливий список. Ось чому результат - це список списків.

Якщо використовується з I/O діями, `sequenceA` - це те саме, що і послідовність! Він приймає список дій вводу-виводу та повертає дію вводу-виводу, яка буде виконувати кожну з цих дій і матиме як результат перелік результатів цих дій вводу-виводу. Це тому, що щоб перетворити значення `[IO a]` у значення `IO [a]`, щоб зробити дію вводу/виводу, яка дає список результатів, коли вони виконуються, всі ці дії вводу/виводу повинні бути послідовними, щоб вони потім були виконується одна за одною, коли оцінювання вимушене. Ви не можете отримати результат дії вводу-виводу, не виконавши його.

[source,haskell]
----
ghci> sequenceA [getLine, getLine, getLine]  
heyh  
ho  
woo  
["heyh","ho","woo"]  
[source,haskell]
----

Як і звичайні функтори, аплікативні фуктори мають кілька законів. Найважливішим є той, про який ми вже згадували, а саме - має дотримуватись `pure f <*> x = fmap f x`. В якості вправи ви можете довести цей закон для деяких аплікативних функторів, з якими ми зустрілися в цій главі. Іншими законами функторів є:

[source,haskell]
----
pure id <*> v = v
pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
pure f <*> pure x = pure (f x)
u <*> pure y = pure ($ y) <*> u
----

Зараз ми не будемо детально їх обговорювати, тому що це займе багато сторінок, і, мабуть, це буде дуже нудно. Але якщо ви вирішите подолати це завдання, ви можете більш детально розглянути їх і подивитися, чи вони дотримуються для деяких примірників.

На закінчення, аплікативні функтори не просто цікаві, вони також корисні, оскільки вони дозволяють поєднувати різні обчислення, такі як обчислення вводу/виводу, недетерміновані обчислення, обчислення, які могли бути невдалими тощо, використовуючи аплікативний стиль. Тільки за допомогою `<$>` і `<*>` ми можемо використовувати звичайні функції для одноманітного оперування на будь-якій кількості аплікативних функторів і використовувати переваги семантики кожного з них.

=== Ключове слово newtype

image:images/maoi.png[]
Поки ми дізналися, як зробити власні алгебраїчні типи даних за допомогою ключового слова `data`. Ми також дізналися, як давати існуючим типам синоніми за допомогою ключового слова `type`. У цьому розділі ми розглянемо, як зробити нові типи з існуючих типів даних за допомогою ключового слова `newtype` і чому ми хотіли б це зробити в першу чергу.

У попередньому розділі ми бачили, що існує фактично більше способів для типу списку бути аплікативним функтором. Один із способів - це за допомогою `<*>` вийняти кожну функцію зі списку, що є її лівим параметром, і застосувати її до кожного значення у списку, який знаходиться праворуч, в результаті чого можливе поєднання застосування функції з лівого списку до значення в правому списку.

[source,haskell]
----
ghci> [(+1),(*100),(*5)] <*> [1,2,3]  
[2,3,4,100,200,300,5,10,15]  
----

Другий спосіб - взяти першу функцію з лівого боку `<*>` та застосувати її до першого значення праворуч, потім взяти другу функцію зі списку зліва та застосувати її до другого значення праворуч , і так далі. Зрештою, це схоже на зшивання двох списків разом. Але списки вже є екземпляром `Applicative`, тож як ми також зробили списки екземпляром `Applicative` цим другим способом? Якщо ви пам’ятаєте, ми говорили, що з цієї причини був введений тип `ZipList`, який має один конструктор значень, `ZipList`, який має лише одне поле. Ми поміщаємо список, який ми огортаємо в це поле. Потім, `ZipList` був зроблений екземпляр `Applicative`, так що коли ми хочемо використовувати списки як аплікативи в zip стилі, ми просто огортаємо їх конструктором `ZipList`, а потім, як тільки ми закінчимо, розгортаємо їх за допомогою `getZipList`:

[source,haskell]
----
ghci> getZipList $ ZipList [(+1),(*100),(*5)] <*> ZipList [1,2,3]  
[2,200,15]  
----

Отже, як це стосується цього ключового слова `newtype`? Гаразд, подумайте, як ми могли б написати декларацію даних для нашого типу `ZipList`. Один із способів - це зробити так:

[source,haskell]
----
data ZipList a = ZipList [a]  
----

Тип, у якого є лише один конструктор значень, і у цього конструктора значень є лише одне поле, яке є переліком речей. Ми також можемо використовувати синтаксис запису, щоб ми автоматично отримували функцію, яка витягує список із `ZipList`:

[source,haskell]
----
data ZipList a = ZipList { getZipList :: [a] } 
----

Це виглядає чудово і насправді спрацює досить добре. У нас було два способи зробити існуючий тип екземпляром типокласу, тому ми використовували ключове слово `data`, щоб просто перетворити цей тип в інший тип, а другий тип - екземпляр другим способом.

Ключове слово `newtype` в Haskell створено саме для цих випадків, коли ми хочемо просто взяти один тип і обгорнути його в щось, щоб представити його як інший тип. У справжніх бібліотеках `ZipList a` визначається так:

[source,haskell]
----
newtype ZipList a = ZipList { getZipList :: [a] }  
----

Замість ключового слова `data` використовується ключове слово `newtype`. Чому це? Одна з причин, `newtype` швидше. Якщо ви використовуєте ключове слово `data` для огорнення типу, коли програма працює є деякі накладні витрати на все, що обгортає та розгортає. Але якщо ви використовуєте `newtype`, Haskell знає, що ви просто використовуєте його, щоб перетворити наявний тип у новий тип (звідси і назва), оскільки ви хочете, щоб він був таким же всередині, але мав інший тип. Зважаючи на це, Haskell може позбутися обгортання та розгортання, як тільки вирішить, який тип має значення.

То чому б тоді просто не використовувати `newtype` весь час замість `data`? Добре, коли ви створюєте новий тип із наявного типу за допомогою ключового слова `newtype`, у вас може бути лише один конструктор значень, і цей конструктор значень може мати лише одне поле. Але за допомогою даних можна створювати типи даних, які мають кілька конструкторів значень, і кожен конструктор може мати нуль або більше полів:

[source,haskell]
----
data Profession = Fighter | Archer | Accountant  
  
data Race = Human | Elf | Orc | Goblin  
  
data PlayerCharacter = PlayerCharacter Race Profession  
----

Використовуючи `newtype`, ви обмежуєтесь лише одним конструктором з одним полем.

Ми також можемо використовувати ключове слово `deriving` з `newtype` так само, як і з `data`. Ми можемо отримати екземпляри для `Eq`, `Ord`, `Enum`, `Bounded`, `Show` і `Read`. Якщо ми отримуємо екземпляр для типокласу, для початку тип, який ми обертаємо, повинен бути у цьому типокласі. Це має сенс, оскільки новий тип просто обгортає існуючий тип. Отже, якщо ми зробимо наступне, ми можемо друкувати та порівнювати значення нового типу:

[source,haskell]
----
newtype CharList = CharList { getCharList :: [Char] } deriving (Eq, Show)  
----

Давайте спробуємо:

[source,haskell]
----
ghci> CharList "this will be shown!"  
CharList {getCharList = "this will be shown!"}  
ghci> CharList "benny" == CharList "benny"  
True  
ghci> CharList "benny" == CharList "oisters"  
False  
----

У цьому конкретному `newtype` конструктор значення має такий тип:

[source,haskell]
----
CharList :: [Char] -> CharList  
----

Він приймає значення `[Char]`, наприклад `"my sharona"` і повертає значення `CharList`. З наведених вище прикладів, де ми використовували конструктор значень `CharList`, ми бачимо, що це дійсно так. І навпаки, функція `getCharList`, яка була створена для нас, оскільки ми використовували синтаксис запису в нашому `newtype`, має такий тип:

[source,haskell]
----
getCharList :: CharList -> [Char]  
----

Він приймає значення `CharList` і перетворює його у значення `[Char]`. Ви можете вважати це обгортанням і розгортанням, але ви можете також вважати це перетворенням значень одного типу в інший.

==== Використання newtype для створення екземплярів типокласа

Many times, we want to make our types instances of certain type classes, but the type parameters just don't match up for what we want to do. It's easy to make Maybe an instance of Functor, because the Functor type class is defined like this:
Часто ми хочемо зробити наші типи екземплярами певних типокласів, але параметри типу просто не відповідають тому, що ми хочемо зробити. Легко зробити `Maybe` екземпляром `Functor`, тому що клас типу `Functor` визначений так:

[source,haskell]
----
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
----

Так що ми починаємо прямо з такого:

[source,haskell]
----
instance Functor Maybe where   
----

And then implement fmap. All the type parameters add up because the Maybe takes the place of f in the definition of the Functor type class and so if we look at fmap like it only worked on Maybe, it ends up behaving like:
Та потім реалізуйте `fmap`. Всі параметри типу згортуваються, тому що `Maybe` займає місце `f` у визначенні типокласу `Functor`, і тому, якщо ми подивимось на `fmap`, якби він працював лише на `Maybe`, кінець кінцем він би працював так:

[source,haskell]
----
fmap :: (a -> b) -> Maybe a -> Maybe b 
----

image:images/krakatoa.png[]
Хіба це не просто персик? А що робити, якщо ми захотіли би зробити кортеж екземпляром `Functor` таким чином, що коли ми `fmap` функції над кортежем, вона б застосовувалась до першого компонента кортежу? Таким чином, виконання `fmap (+3) (1,1)` призведе до `(4,1)`. Виглядає так, що написати екземпляр для цього начебто важко. З `Maybe`, ми просто говоримо `instance Functor Maybe`, тому що лише конструктори типу, які беруть точно один параметр, можуть бути зроблені екземпляром `Functor`. Але здається, що немає ніякого способу зробити щось подібне з `(a, b)`, щоб параметр типу `a` кінець кінцем був тим, який змінюється, коли ми використовуємо `fmap`. Щоб обійти це, ми можемо `newtype` наш кортеж таким чином, що другий параметр типу представляв тип першого компонента в кортежі:

[source,haskell]
----
newtype Pair b a = Pair { getPair :: (a,b) }  
----

А тепер ми можемо зробити його екземпляром `Functor`, щоб функція була відображена на перший компонент:

[source,haskell]
----
instance Functor (Pair c) where  
    fmap f (Pair (x,y)) = Pair (f x, y) 
----

Як бачимо, ми можемо робити співпадіння на типах, визначених `newtype`. Ми порівнюємо шаблон, щоб підлеглий кортеж, потім застосовуємо функцію `f` до першого компонента кортежу, а потім використовуємо конструктор значень `Pair` для перетворення кортежу назад у нашу `Pair b a`. Якщо ми уявимо, яким би був тип `fmap`, якби він працював лише на наших нових парах, це було б:

[source,haskell]
----
fmap :: (a -> b) -> Pair c a -> Pair c b  
----

Знову ж таки, ми сказали `instance Functor (Pair c) where`,і так `Pair c` зайняв місце `f` у визначенні типокласу для `Functor`:

[source,haskell]
----
class Functor f where  
    fmap :: (a -> b) -> f a -> f b  
----

Отже, якщо ми перетворимо кортеж у `Pair b a`, ми можемо використовувати `fmap` над ним, і функція буде відображена на перший компонент:

[source,haskell]
----
ghci> getPair $ `fmap` (*100) (Pair (2,3))  
(200,3)  
ghci> getPair $ fmap reverse (Pair ("london calling", 3))  
("gnillac nodnol",3)  
----

==== Про лінивісь newtype

Ми згадували, що `newtype` зазвичай швидший, ніж `data`. Єдине, що можна зробити з `newtype` - це перетворити існуючий тип у новий тип, тому внутрішньо Haskell може представляти значення типів, визначених `newtype` так само, як оригінали, лише слід пам’ятати, що їх типи є тепер різні. Цей факт означає, що не тільки новий тип швидше, але і лазулінивіше. Давайте розберемося, що це означає.

Як ми вже говорили раніше, Haskell за замовчуванням лінивий. Це означає, що будь-які обчислення відбуватимуться лише тоді, коли ми намагатимемося надрукувати результати наших функцій. Крім того, будуть проведені лише ті обчислення, необхідні для того, щоб наша функція повідомила нам результат. Невизначене значення `undefined` в Haskell представляє помилкові обчислення. Якщо ми спробуємо оцінити його (тобто змусити Haskell насправді обчислити його), надрукувавши його до терміналу, Haskell видасть істерику (технічно називається винятком):

[source,haskell]
----
ghci> undefined  
*** Exception: Prelude.undefined  
----

Однак, якщо ми складемо список, у якому є деякі невизначені значення, але запитаємо лише голову списку, що є визначеною, все пройде гладко, оскільки Haskell насправді не потребує оцінювання будь-яких інших елементів у списку, якщо ми лише хочемо подивитися на перший елемент:

[source,haskell]
----
ghci> head [3,4,5,undefined,2,undefined]  
3  
----

Тепер розглянемо такий тип:

[source,haskell]
----
data CoolBool = CoolBool { getCoolBool :: Bool }  
----

It's your run-of-the-mill algebraic data type that was defined with the data keyword. It has one value constructor, which has one field whose type is Bool. Let's make a function that pattern matches on a CoolBool and returns the value "hello" regardless of whether the Bool inside the CoolBool was True or False:
Це ваш алгебраїчний тип даних,визначений за допомогою ключового слова `data`. Він має один конструктор значення, який має одне поле, тип якого - `Bool`. Давайте зробимо функцію, яка відповідає шаблону на `CoolBool` і повертає значення `"hello"` незалежно від того, був `Bool` всередині CoolBool `True` чи `False`:

[source,haskell]
----
helloMe :: CoolBool -> String  
helloMe (CoolBool _) = "hello"  
----

Instead of applying this function to a normal CoolBool, let's throw it a curveball and apply it to undefined!
Замість того, щоб застосовувати цю функцію до звичайного `CoolBool`, давайте кинемо їй кручений і застосуємо її до `undefined`!

[source,haskell]
----
ghci> helloMe undefined  
"*** Exception: Prelude.undefined  
----

Йо! Виняток! Тепер чому стався такий виняток? Типи, визначені за допомогою ключового слова `data`, можуть мати конструктори декількох значень (навіть якщо у `CoolBool` є лише один). Тож для того, щоб переконатися, що значення, яке надається нашій функції, відповідає шаблону `(CoolBool _)`, Haskell повинен оцінити значення достатньо, щоб побачити, який конструктор значень використовувався, коли ми робили це значення. І коли ми намагаємось оцінити невизначене значення, навіть трохи, закидається виняток.

Замість використання ключового слова `data` для `CoolBool`, давайте спробуємо використати `newtype`:

[source,haskell]
----
newtype CoolBool = CoolBool { getCoolBool :: Bool }  
----

Нам не потрібно змінювати нашу функцію `helloMe`, оскільки синтаксис узгодження шаблонів однаковий, якщо ви використовуєте `newtype` або `data` для визначення свого типу. Зробимо тут те ж саме і застосуємо `helloMe` до невизначеного значення:

[source,haskell]
----
ghci> helloMe undefined  
"hello"  
----

image:images/shamrock.png[]
Це спрацювало! Хммм, чому це? Ну, як ми вже говорили, коли ми використовуємо `newtype`, Haskell може внутрішньо представляти значення нового типу так само, як і оригінальні значення. Він не повинен додавати ще одне поле навколо них, він просто повинен знати про значення різних типів. Оскільки Haskell знає, що типи, створені за допомогою ключового слова `newtype`, можуть мати лише один конструктор, йому не потрібно оцінювати значення, передане функції, щоб переконатися, що воно відповідає шаблону `(CoolBool _)`, оскільки типи `newtype` можуть мати лише один можливий конструктор значень і одне поле!

Ця різниця в поведінці може здатися тривіальною, але насправді є досить важливою, оскільки допомагає нам усвідомити, що хоча типи, визначені `data` та `newtype`, поводяться аналогічно з точки зору програміста, оскільки вони обоє мають конструктори значень та поля, вони насправді є двома різними механізмами . Якщо `data` можуть бути використані для створення власних типів з нуля, `newtype` призначений для створення абсолютно нового типу з існуючого типу. Співставлення шаблонів для значень `newtype` не схоже на те, щоб вийняти щось із коробки (як це є з `data`), це більше про пряме перетворення з одного типу в інший.

==== type vs. newtype vs. data

На даний момент ви можете трохи заплутатися в тому, в чому полягає різниця між `типом`, `data` та `newtype`, тож давайте трохи освіжимо нашу пам’ять.

Ключове слово `type` призначене для створення синонімів типу. Це означає, що ми просто даємо інше ім’я вже існуючому типу, щоб на його було легше посилатися. Скажімо, ми зробили наступне:

[source,haskell]
----
type IntList = [Int]  
----

Все що це робить, що ми можемо називати тип `[Int]` як `IntList`. Їх можна використовувати взаємозамінно. Ми не отримуємо конструктор значень `IntList` або щось подібне. Оскільки `[Int]` та `IntList` - це лише два способи посилання на один і той же тип, не має значення, яке ім'я ми використовуємо в анотаціях типу:

[source,haskell]
----
ghci> ([1,2,3] :: IntList) ++ ([1,2,3] :: [Int])  
[1,2,3,1,2,3]  
----

Ми використовуємо синоніми типів, коли хочемо зробити сигнатури типів більш описовими, надаючи імена типів, які розповідають щось про їх призначення в контексті функцій, де вони використовуються. Наприклад, коли ми використовували список асоціацій типу `[(String, String)]` для представлення телефонної книги, ми дали йому синонім типу `PhoneBook`, щоб сигнатури типів наших функцій було легше читати.

Ключове слово `newtype` призначене для прийняття існуючих типів та загортання їх у нові типи, здебільшого, щоб було простіше зробити їх примірниками певних типокласів. Коли ми використовуємо `newtype`, щоб обернути існуючий тип, тип, який ми отримуємо, є окремим від початкового типу. Якщо ми зробимо наступний новий тип:

[source,haskell]
----
newtype CharList = CharList { getCharList :: [Char] }  
----

Ми не можемо використовувати `++` для згортування `CharList` та списку типу `[Char]`. Ми навіть не можемо використовувати `++` для згортування двох `CharList`, оскільки `++` працює лише у списках, а тип `CharList` - це не список, хоча можна сказати, що він містить список. Однак ми можемо конвертувати два `CharLists` у списки, `++` їх, а потім перетворити їх назад у `CharList`.

Коли ми використовуємо синтаксис запису в наших деклараціях `newtype`, ми отримуємо функції для перетворення між новим типом і оригінальним типом: а саме конструктор значень нашого нового типу та функцію вилучення значення в його полі. Новий тип також автоматично не робиться екземпляром типокласів, до яких належить оригінальний тип, тому нам потрібно вивести або записати їх вручну.

На практиці ви можете вважати декларації `newtype` як декларації `data`, які можуть мати лише один конструктор і одне поле. Якщо ви зловили себе за написанням такої `data` декларації, подумайте про використання `newtype`.

Ключове слово `data` призначене для створення власних типів даних, і тут ви можете дати собі волю. Вони можуть мати стільки конструкторів і полів, скільки бажаєте, і їх можна використовувати для самостійного впровадження будь-якого алгебраїчного типу даних. Все - від списків та типів, схожих на `Maybe`, до дерев.

Якщо ви просто хочете, щоб сигнатури вашого типу виглядали більш чистими та описовими, ви, мабуть, хочете ввести синоніми `type`. Якщо ви хочете взяти існуючий тип і перетворити його в новий тип, щоб зробити його екземпляром типокласу, швидше за все, ви шукаєте `newtype`. І якщо ви хочете зробити щось абсолютно нове, хороші шанси, що ви шукаєте ключове слово `data`.

=== Моноїди

image:images/pirateship.png[]
Типокласи в Haskell використовуються для представлення інтерфейсу для типів, які мають певну загальну поведінку. Ми розпочали з простих класів типів, таких як `Eq`, який призначений для типів, значення яких можна прирівняти, і `Ord`, для речей, які можна впорядкувати, а потім перейти до більш цікавих, таких як `Functor` та `Applicative`.

Коли ми робимо тип, ми думаємо про те, яку поведінку він підтримує, тобто, як він може діяти. А потім, виходячи з цього, ми вирішуємо, примірником яких типокласів  його зробити. Якщо має сенс рівняти значення нашого типу, ми робимо його екземпляром типокласу `Eq`. Якщо ми бачимо, що наш тип є якимось функтором, ми робимо його екземпляром `Functor` тощо.

Тепер розглянемо наступне: `*` - це функція, яка приймає два числа і премножує їх. Якщо множимо якесь число на `1`, результат завжди дорівнює цьому числу. Не має значення, якщо ми робимо `1 * x` або `x * 1`, результат завжди `x`. Аналогічно, `++` також є функцією, яка приймає дві речі, а повертає третю. Тільки замість множення чисел він бере два списки і з'єднує їх. І так само, як `*`, він також має певне значення, яке не змінює іншого при використанні з `++`. Це значення - порожній список: `[]`.

[source,haskell]
----
ghci> 4 * 1  
4  
ghci> 1 * 9  
9  
ghci> [1,2,3] ++ []  
[1,2,3]  
ghci> [] ++ [0.5, 2.5]  
[0.5,2.5]  
----

Схоже, що обидва `*` разом з `1` і `++` разом із `[]` мають спільні властивості:

* Функція приймає два параметри.
* Параметри та значення результату мають один і той же тип.
* Існує таке значення, яке не змінює інших значень при використанні з двомісною функцією.

Є ще одна річ, що ці дві операції мають назагал, що може бути не настільки очевидно, як наші попередні спостереження: коли у нас є три і більше значень, і ми хочемо використати двомісну функцію, щоб звести їх до єдиного результату, порядок, в якому ми застосовуємо функцію не має значення. Не має значення, чи робимо ми `(3 * 4) * 5` або `3 * (4 * 5)`. У будь-якому випадку результат - `60`. Те саме стосується `++`:

[source,haskell]
----
ghci> (3 * 2) * (8 * 5)  
240  
ghci> 3 * (2 * (8 * 5))  
240  
ghci> "la" ++ ("di" ++ "da")  
"ladida"  
ghci> ("la" ++ "di") ++ "da"  
"ladida"  
----

Ми називаємо цю властивість _асоціативністю_. `*` є асоціативним, так само є `++`, але `-` наприклад, не є. Вирази `(5 - 3) - 4` і `5 - (3 - 4)` призводять до різних результатів.

By noticing and writing down these properties, we have chanced upon monoids! A monoid is when you have an associative binary function and a value which acts as an identity with respect to that function. When something acts as an identity with respect to a function, it means that when called with that function and some other value, the result is always equal to that other value. 1 is the identity with respect to * and [] is the identity with respect to ++. There are a lot of other monoids to be found in the world of Haskell, which is why the Monoid type class exists. It's for types which can act like monoids. Let's see how the type class is defined:
Помітивши та записавши ці властивості, ми поставили перед собою моноїди! Моноїд - це коли у вас є асоціативна двомісна функція та значення, яке виступає як тотожність щодо цієї функції. Коли щось виступає як ідентичність відносно функції, це означає, що коли викликається з цією функцією та іншим значенням, результат завжди дорівнює цьому іншому значенню. `1` - тотожність відносно `*`, а `[]` - тотожність відносно `++`. У світі Haskell можна знайти багато інших моноїдів, саме тому існує типоклас `Monoid`. Це для типів, які можуть діяти як моноїди. Давайте подивимось, як визначається цей типоклас типу:

[source,haskell]
----
class Monoid m where  
    mempty :: m  
    mappend :: m -> m -> m  
    mconcat :: [m] -> m  
    mconcat = foldr mappend mempty  
----

image:images/balloondog.png[]
Типоклас `Monoid` визначений у `import Data.Monoid`. Давайте витратимо трохи часу і познайомимося належним чином з цим.

Перш за все, ми бачимо, що лише конкретні типи можуть бути зроблені екземплярами `Monoid`, оскільки `m` у визначенні класу типу не приймає жодних параметрів типу. Це відрізняється від `Functor` та `Applicative`, які вимагають, щоб їх екземпляри були конструкторами типу, які приймають один параметр.

Перша функція `mempty`. Це насправді не функція, оскільки вона не приймає параметрів, тому це поліморфна константа, на зразок `minBound` від `Bounded`. `mempty` являє значення ідентичності для певного моноїда.

Далі ми маємо `mappend`, що, як ви, напевно, здогадалися, є двомісною функцією. Вона приймає два значення одного типу і також повертає значення цього типу. Варто зазначити, що рішення назвати `mappend` так, як воно було назване, було якось невдалим, оскільки це означає, що ми певним чином додаємо дві речі. Хоча `++` приймає два списки і додає один до іншого, `*` насправді нічого не додає, він просто перемножує два числа разом. Коли ми зустрінемося з іншими екземплярами `Monoid`, ми побачимо, що більшість з них також не додає значення, тому уникайте думки з точки зору додавання, а просто думайте з точки зору `mappend` як двомісної функції, яка приймає два моноїдні значення і повертає третє.

Остання функція визначення цього типокласу - `mconcat`. Вона бере список моноїдних значень і зводить їх до єдиного значення, виконуючи відображення між елементами списку. У ньому є реалізація за замовчуванням, яка просто приймає порожній як початкове значення і складе список праворуч з `mappend`. Оскільки реалізація за замовчуванням для більшості випадків прекрасна, ми відтепер не будемо занадто сильно цікавитись `mconcat`. Створюючи тип екземпляр `Monoid`, достатньо просто реалізувати `mempty` і `mappend`. Причина, з якої `mconcat` взагалі існує, в тому, що для деяких випадків може бути більш ефективні способи реалізації `mconcat`, але для більшості випадків реалізація за замовчуванням просто чудова.

Перш ніж перейти до конкретних екземплярів `Monoid`, давайте коротко розглянемо закони моноїдів. Ми згадували, що повинно бути значення, яке виступає як тотожність щодо двомісної функції і що двомісна функція повинна бути асоціативною. Можна зробити екземпляри `Monoid`, які не відповідають цим правилам, але такі екземпляри нікому не приносять користі, оскільки, використовуючи типоклас `Monoid`, ми покладаємось на його екземпляри, що діють як моноїди. Інакше в чому сенс? Ось чому, створюючи екземпляри, ми повинні переконатися, що вони відповідають цим законам:

[source,haskell]
----
mempty `mappend` x = x
x `mappend` mempty = x
(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)
----

Перші два встановлюють, що `mempty` повинна діяти як тотожність щодо `mappend`, а третій говорить, що `mappend` має бути асоціативним, тобто, порядок, у якому ми використовуємо `mappend`, щоб змішати кілька моноїдних значень в одне, не має значення. Haskell не примушує виконувати ці закони, тому ми, як програмісти, повинні бути обережними, щоб наші екземпляри дійсно їм підкорялися.

=== Списки - це моноїди

Так, списки - моноїди! Як ми бачили, функція `++` та порожній список `[]` утворюють моноїд. Екземпляр дуже простий:

[source,haskell]
----
instance Monoid [a] where  
    mempty = []  
    mappend = (++)  
----

Списки - це екземпляр типокласу `Monoid` незалежно від типу елементів, які вони містять. Зауважте, що ми писали `instance Monoid [a]`, а не `instance Monoid []`, оскільки `Monoid` вимагає конкретного типу для екземпляра.

Проводячи тестовий прогон ми не стикаємось із сюрпризами:

[source,haskell]
----
ghci> [1,2,3] `mappend` [4,5,6]  
[1,2,3,4,5,6]  
ghci> ("one" `mappend` "two") `mappend` "tree"  
"onetwotree"  
ghci> "one" `mappend` ("two" `mappend` "tree")  
"onetwotree"  
ghci> "one" `mappend` "two" `mappend` "tree"  
"onetwotree"  
ghci> "pang" `mappend` mempty  
"pang"  
ghci> mconcat [[1,2],[3,6],[9]]  
[1,2,3,6,9]  
ghci> mempty :: [a]  
[]  
----

image:images/smug.png[]
Зауважте, що в останньому рядку нам довелося написати явну анотацію типу, бо якби ми просто вказали порожні дужки, GHCi не знав би, який екземпляр використовувати. Тому ми повинні були сказати, що хочемо екземпляр списку. Ми змогли використовувати загальний тип `[a]` (на відміну від вказання `[Int]` або `[String]`), оскільки порожній список може діяти так, ніби він містить будь-який тип.

Оскільки `mconcat` має реалізацію за замовчуванням, ми отримуємо її безкоштовно, коли робимо щось екземпляром `Monoid`. Що стосується списку, `mconcat` виявляється просто `concat`. Він бере список списків і сплющує його, тому що це еквівалент робити `++` над усіма суміжними списками списків.

Закони для моноїдів дійсно дотримуються для екземпляру списку. Коли у нас є кілька списків і ми відображуємо їх (або робимо `++`) разом, не має значення, які з них ми зробимо спочатку, оскільки вони все одно просто з'єднані на кінцях. Також порожній список виступає як тотожність, тому все добре. Зауважте, що моноїди не вимагають, щоб `b mappend b` дорівнювало `a mappend a`. Що стосується списку, це, вочевидь, не так:

[source,haskell]
----
ghci> "one" `mappend` "two"  
"onetwo"  
ghci> "two" `mappend` "one"  
"twoone"  
----

І це нормально. Той факт, що для множення `3 * 5` і `5 * 3` однакові, є лише властивістю множення, але це не стосується всіх (і справді більшості) моноїдів.

==== Product і Sum

Ми вже вивчили один із способів, щоб числа вважалися моноїдами. Треба тільки взяти операцію `*`, а значення тотожності `1`. Виявляється, це не єдиний спосіб, щоб числа були моноїдами. Інший спосіб полягає у тому, щоб двомісна функція була `+`, а значення тотожності `0`:

[source,haskell]
----
ghci> 0 + 4  
4  
ghci> 5 + 0  
5  
ghci> (1 + 3) + 5  
9  
ghci> 1 + (3 + 5)  
9  
----

Закони моноїдів дотримуються, тому що якщо ви додасте `0` до будь-якого числа, то результат - це саме число. І додаток також асоціативний, тому ми не маємо там ніяких проблем. Отже, тепер, коли є два однаково дійсні способи числа бути моноїдами, який спосіб вибрати? Ну, нам не треба саме обирати. Пам'ятайте, що коли існує декілька способів для того, щоб якийсь тип був екземпляром одного типокласу, ми можемо огорнути цей тип у `newtype`, а потім зробити новий тип примірником типокласу по-іншому. Ми можемо і мати свій торт, і при цьому з'їсти його.

Модуль `Data.Monoid` експортує для цього два типи, а саме `Product` and `Sum`. `Product` визначається так:

[source,haskell]
----
newtype Product a =  Product { getProduct :: a }  
    deriving (Eq, Ord, Read, Show, Bounded)  
----

Simple, just a newtype wrapper with one type parameter along with some derived instances. Its instance for Monoid goes a little something like this:

[source,haskell]
----
instance Num a => Monoid (Product a) where  
    mempty = Product 1  
    Product x `mappend` Product y = Product (x * y)  
----

`mempty` - це лише `1` загорнутий у конструктор `Product`. `mappend` робить відповідність шаблону на конструкторі `Product`, помножить два числа і потім повертає отримане число назад. Як бачите, існує обмеження класу `Num`. Отже, це означає, що `Product a` є екземпляром `Monoid` для всіх `a`, які вже є екземпляром `Num`. Щоб використовувати `Producta a` як моноїд, нам потрібно зробити деяке загортання та розгортання `newtype`:

[source,haskell]
----
ghci> getProduct $ Product 3 `mappend` Product 9  
27  
ghci> getProduct $ Product 3 `mappend` mempty  
3  
ghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2  
24  
ghci> getProduct . mconcat . map Product $ [3,4,2]  
24  
----

Це добре, як демонстрація типокласу `Monoid`. Та ніхто у власному розумі не використовує цей спосіб множення чисел, а просто записує `3 * 9` і `3 * 1`. Але трохи пізніше ми побачимо, як ці екземпляри `Monoid` випадки, які зараз можуть здатися тривіальними, можуть стати в нагоді.

`Sum` визначається як `Product`, і екземпляр також подібний. Ми використовуємо його так само:

[source,haskell]
----
ghci> getSum $ Sum 2 `mappend` Sum 9  
11  
ghci> getSum $ mempty `mappend` Sum 3  
3  
ghci> getSum . mconcat . map Sum $ [1,2,3]  
6  
----

==== Any та All

Інший тип, який може діяти як моноїд двома різними, але однаково справедливими способами - це `Bool`. Перший спосіб - щоб `or` функція `||` виступала як двомісна функція, з `False` як значення ідентичності. Логічне  `or` працює так, що якщо будь-який з двох його параметрів є `True`, він повертає `True`, інакше повертає `False`. Отже, якщо ми використовуємо `False` як значення ідентичності, воно повертає `False`, коли робиться `or` із `False`, та `True`, коли `or` з `True`. Таким чином, конструктор `newtype Any` є примірником `Monoid`. Це визначено так:

[source,haskell]
----
newtype Any = Any { getAny :: Bool }  
    deriving (Eq, Ord, Read, Show, Bounded)  
----

Його екземпляр виглядає так:

[source,haskell]
----
instance Monoid Any where  
        mempty = Any False  
        Any x `mappend` Any y = Any (x || y)  
----

Причина, чому це називається `Any` - це те, що `x mappend y` буде `True`, якщо будь-який з цих двох є `True`. Навіть якщо три або більше будь-яких огорнутих `Bool` відображаються разом, результат буде `True`, якщо будь-який з них `True`:

[source,haskell]
----
ghci> getAny $ Any True `mappend` Any False  
True  
ghci> getAny $ mempty `mappend` Any True  
True  
ghci> getAny . mconcat . map Any $ [False, False, False, True]  
True  
ghci> getAny $ mempty `mappend` mempty  
False  
----

Інший спосіб для `Bool` бути екземпляром `Monoid` - це зробити щось протилежне: обрати `&&` двомісною функцією, а потім зробити `True` значенням ідентичності. Логічно, і поверне `True` лише в тому випадку, якщо обидва його параметра є `True`. Це декларація `newtype`, нічого захмарного:

[source,haskell]
----
newtype All = All { getAll :: Bool }  
        deriving (Eq, Ord, Read, Show, Bounded)  
----

І ось екземпляр:

[source,haskell]
----
instance Monoid All where  
        mempty = All True  
        All x `mappend` All y = All (x && y)  
----

Коли ми будемо відображати значення типу `All`, результат буде `True`, лише якщо всі значення, використані в операціях є `True`:

[source,haskell]
----
ghci> getAll $ mempty `mappend` All True  
True  
ghci> getAll $ mempty `mappend` All False  
False  
ghci> getAll . mconcat . map All $ [True, True, True]  
True  
ghci> getAll . mconcat . map All $ [True, True, False]  
False  
----

Як і у випадку множення та додавання, ми, як правило, явно констатуємо двомісні функції замість того, щоб загортати їх у нові типи, а потім використовуючи `mappend` та `mempty`. `mconcat` здається корисним для `Any` та `All`, але зазвичай простіше використовувати функції `or` та `and`, які беруть списки `Bool` та повертають `True`, якщо будь-який з них є `True` або, якщо всі вони `True`, відповідно.

=== Моноїд Ordering

Гей, пам'ятаєте тип замовлення? Він використовується як результат при порівнянні речей, і він може мати три значення: `LT`, `EQ` і `GT`, які означають менше, рівне і більше, ніж відповідно:

[source,haskell]
----
ghci> 1 `compare` 2  
LT  
ghci> 2 `compare` 2  
EQ  
ghci> 3 `compare` 2  
GT  
----

Зі списків, чисел та логігчних значень пошук моноїдів був лише питанням перегляду вже існуючих загальновживаних функцій та з'ясування, чи виявляють вони певну поведінку моноїдів. З `Ordering` нам потрібно трохи важче розпізнати моноїд, але виявляється, що його екземпляр `Monoid` такий же інтуїтивний, як і ті, з якими ми зустрічалися дотепер, а також досить корисний:

[source,haskell]
----
instance Monoid Ordering where  
    mempty = EQ  
    LT `mappend` _ = LT  
    EQ `mappend` y = y  
    GT `mappend` _ = GT  
----

image:images/bear.png[]
Екземпляр налаштовано так: коли ми відображаємо два значення `Ordering`, якщо значення зліва не є `EQ` - зберігається те що зліва, в іншошму випадку правий результат. Тотожність - `EQ`. Спочатку це може здатися вигадкою, але насправді це нагадує те, як ми в алфавітному порядку порівнюємо слова. Ми порівнюємо перші дві літери, і якщо вони відрізняються, ми вже можемо вирішити, яке слово піде першим у словнику. Однак якщо перші дві літери рівні, то переходимо до порівняння наступної пари літер і повторюємо процес.

Наприклад, якби ми порівнювали слова `"ox"` і `"on"` за алфавітом, ми спочатку порівняємо перші дві літери кожного слова, побачимо, що вони рівні, а потім перейдемо до порівняння другої літери кожного слова. Ми бачимо, що `"x"` в алфавітному порядку більше, ніж `"n"`, і тому ми знаємо, як порівняти. Щоб отримати певну інтуїцію того, що `EQ` є тотожністю, ми можемо помітити, що якби ми описували одну й ту саму букву в одному положенні обома словами, це не змінило б їх алфавітне впорядкування. `"oix"` як і раніше в алфавітному порядку більше, ніж `"oin"`.

Важливо зазначити, що в екземплярі `Monoid` для `Ordering` вираз `x ``mappend`` y` не дорівнює `y ``mappend`` x`. Оскільки перший параметр зберігається, якщо це не `EQ`, `LT `mappend` GT` призведе до LT, тоді як `GT ``mappend`` LT` призведе до `GT`:

[source,haskell]
----
ghci> LT `mappend` GT  
LT  
ghci> GT `mappend` LT  
GT  
ghci> mempty `mappend` LT  
LT  
ghci> mempty `mappend` GT  
GT  
----

Гаразд, так чим корисний цей моноїд? Скажімо, ви писали функцію, яка приймає два рядки, порівнює їх довжину та повертає `Ordering`. Але якщо рядки однакової довжини, то замість повернення `EQ` відразу, ми хочемо порівняти їх за алфавітом. Один із способів написати це було б так:

[source,haskell]
----
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = let a = length x `compare` length y   
                        b = x `compare` y  
                    in  if a == EQ then b else a  
----

Ми називаємо результат порівняння довжин `a` і результат алфавітного порівняння `b`, а потім, якщо виявиться, що довжини були рівними, повертаємо їх алфавітне впорядкування.

Але використовуючи розуміння того, як `Ordering` є моноїдом, ми можемо переписати цю функцію набагато простіше:

[source,haskell]
----
import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (x `compare` y)  
----

Ми можемо спробувати це:

[source,haskell]
----
ghci> lengthCompare "zen" "ants"  
LT  
ghci> lengthCompare "zen" "ant"  
GT  
----

Пам'ятайте, що коли ми використовуємо `mappend`, його лівий параметр завжди зберігається, якщо це не `EQ`, в цьому випадку зберігається правий. Ось чому ми ставимо першим параметром порівняння, яке ми вважаємо першим, більш важливим критерієм. Якщо ми хочемо розширити цю функцію і порівняти за кількістю голосних і встановити це другим найважливішим критерієм для порівняння, ми просто змінимо її так:

[source,haskell]
----
import Data.Monoid  
  
lengthCompare :: String -> String -> Ordering  
lengthCompare x y = (length x `compare` length y) `mappend`  
                    (vowels x `compare` vowels y) `mappend`  
                    (x `compare` y)  
    where vowels = length . filter (`elem` "aeiou")  
----

Ми зробили допоміжну функцію, яка приймає рядок і повідомляє нам, скільки с ньому голосних, спочатку відфільтрувавши лише літери, що знаходяться в рядку `"aeiou"`, а потім застосувавши до цього `length`.

[source,haskell]
----
ghci> lengthCompare "zen" "anna"  
LT  
ghci> lengthCompare "zen" "ana"  
LT  
ghci> lengthCompare "zen" "ann"  
GT  
----

Дуже круто. Тут ми бачимо, як у першому прикладі довжини виявляються різними, і тому повертається `LT`, оскільки довжина `"zen"` менша, ніж довжина `"anna"`. У другому прикладі довжини однакові, але другий рядок має більше голосних, тому `LT` повертається знову. У третьому прикладі вони обидві мають однакову довжину і однакову кількість голосних, тому їх порівнюють за алфавітом і `"zen"` перемагає.

Моноїд `Ordering` дуже класний, оскільки дозволяє легко порівнювати речі за багатьма різними критеріями та встановлювати ці критерії в самому порядку, починаючи від найважливішого до найменш важливого.

==== Монада Maybe

Давайте розглянемо різні способи того, можна `Maybe` зробити екземпляром `Monoid` і для чого ці екземпляри корисні.

One way is to treat Maybe a as a monoid only if its type parameter a is a monoid as well and then implement mappend in such a way that it uses the mappend operation of the values that are wrapped with Just. We use Nothing as the identity, and so if one of the two values that we're mappending is Nothing, we keep the other value. Here's the instance declaration:
Одним із способів є трактування `Maybe` як моноїд лише у тому випадку, якщо його параметр типу `a` є також моноїдом, а потім реалізувати `mappend` таким чином, щоб він використовував операцію відображення значень, які обернуті `Just`. Ми використовуємо `Nothing` як тотожність, і тому, якщо одне з двох значень, які ми відображаємо, - `Nothing`, ми зберігаємо інше значення. Ось декларація екземпляра:

[source,haskell]
----
instance Monoid a => Monoid (Maybe a) where  
    mempty = Nothing  
    Nothing `mappend` m = m  
    m `mappend` Nothing = m  
    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)  
----

Зауважте обмеження класу. Це говорить про те, що `Maybe a` є екземпляром `Monoid`, лише якщо `a` є екземпляром `Monoid`. Якщо ми відображаємо щось з `Nothing`, результат - це щось. Якщо ми відображаємо два значення `Just`, вміст ціх `Just` отримують `mappend`, а потім загортають у `Just`. Ми можемо це зробити, тому що обмеження класу гарантує, що тип того, що знаходиться всередині `Just`, є примірником `Monoid`.

[source,haskell]
----
ghci> Nothing `mappend` Just "andy"  
Just "andy"  
ghci> Just LT `mappend` Nothing  
Just LT  
ghci> Just (Sum 3) `mappend` Just (Sum 4)  
Just (Sum {getSum = 7})  
----

Це застосовується, коли ви маєте справу з моноїдами як результати обчислень, які, можливо, не вдалися. Через цей екземпляр нам не потрібно перевіряти, чи не вдалося здійснити обчислення, побачивши, чи є вони значенням `Nothing` чи `Just`; ми можемо просто продовжувати ставитися до них як до звичайних моноїдів.

Але що робити, якщо тип вмісту `Maybe` не є екземпляром `Monoid`? Зауважте, що в попередній декларації екземпляра єдиний випадок, коли нам доводиться розраховувати на те, що вміст є моноїдами, це коли обидва параметри відображення є `Just` значеннями. Але якщо ми не знаємо, чи вміст є моноїдами, ми не можемо використовувати `mappend` між ними, і що робити? Ну, одне, що ми можемо зробити, - це просто відкинути друге значення і зберегти перше. Для цього існує тип `First`, і це його визначення:

[source,haskell]
----
newtype First a = First { getFirst :: Maybe a }  
    deriving (Eq, Ord, Read, Show)  
----

Ми беремо `Maybe` і огортаємо його новим типом. Екземпляр `Monoid` такий:

[source,haskell]
----
instance Monoid (First a) where  
    mempty = First Nothing  
    First (Just x) `mappend` _ = First (Just x)  
    First Nothing `mappend` x = x  
----

Саме так, як ми казали. `mempty` - це просто `Nothing`, обгорнуте `newtype` конструктором `First`. Якщо перший параметр `mappend` - це значення `Just`, ми ігноруємо другий. Якщо перший - це `Nothing`, то в результаті ми представляємо другий параметр, незалежно від того, чи це `Just` чи `Nothing`:

[source,haskell]
----
ghci> getFirst $ First (Just 'a') `mappend` First (Just 'b')  
Just 'a'  
ghci> getFirst $ First Nothing `mappend` First (Just 'b')  
Just 'b'  
ghci> getFirst $ First (Just 'a') `mappend` First Nothing  
Just 'a'  
----

`First` корисний, коли у нас є кіпа значень `Maybe`, і ми просто хочемо знати, чи є якась із них `Just`. Стає в нагоді функція `mconcat`:

[source,haskell]
----
ghci> getFirst . mconcat . map First $ [Nothing, Just 9, Just 10]  
Just 9  
----

Якщо ми хочемо моноїд на `Maybe` такий, щоб зберігався другий параметр, якщо обидва параметри відображення є `Just` значеннями, `Data.Monoid` надає тип `Last`, який працює як `First a`, але при використанні `mconcat` зберігається лише останнє не-`Nothing` значення:

[source,haskell]
----
ghci> getLast . mconcat . map Last $ [Nothing, Just 9, Just 10]  
Just 10  
ghci> getLast $ Last (Just "one") `mappend` Last (Just "two")  
Just "two"  
----

=== Використання моноїдів для згортання структур даних

Один з найбільш цікавих способів примусити моноїди працювати - це зробити так, щоб вони допомагали нам визначати згортки різних структур даних. Поки що ми робили лише згортки над списками, але списки - не єдина структура даних, яку можна згорнути. Ми можемо визначити згортку майже будь-якої структури даних. Дерева особливо добре піддаються згортанню.

Оскільки існує стільки структур даних, які добре працюють зі згортками, було введено типоклас `Foldable`. Настільки ж, як `Functor` - для речей, по яких можна зробити відображення, `Foldable` - для речей, які можна згорнути! Його можна знайти в `Data.Foldable`, і тому що він імпортує функції, імена яких суперечать тим, що знаходяться в `Prelude`, його краще імпортувати кваліфікованим (і подавати з базиліком):

[source,haskell]
----
import qualified Foldable as F  
----

Щоб заощадити собі дорогоцінні натискання клавіш, ми вирішили імпортувати його кваліфікований як `F`. Добре, тож які функції, які визначає цей тип класу? Ну, серед них є `foldr`, `foldl`, `foldr1` і `foldl1`. Так? Але ми вже знаємо ці функції, що тут нового у цьому? Порівняємо типи `Foldable foldr` та `foldr` з `Prelude`, щоб побачити, як вони відрізняються:

[source,haskell]
----
ghci> :t foldr  
foldr :: (a -> b -> b) -> b -> [a] -> b  
ghci> :t F.foldr  
F.foldr :: (F.Foldable t) => (a -> b -> b) -> b -> t a -> b  
----

Ah! So whereas foldr takes a list and folds it up, the foldr from Data.Foldable accepts any type that can be folded up, not just lists! As expected, both foldr functions do the same for lists:
Ах! Тоді як `foldr` бере список і згортає його, то `foldr` від `Data.Foldable` приймає будь-який тип, який можна згорнути, а не лише списки! Як і очікувалося, обидві функції `foldr` роблять те саме для списків:

[source,haskell]
----
ghci> foldr (*) 1 [1,2,3]  
6  
ghci> F.foldr (*) 1 [1,2,3]  
6  
----

Добре, тоді які ще структури даних підтримують згортання? Що ж, `Maybe`, яку ми всі знаємо і любимо!

[source,haskell]
----
ghci> F.foldl (+) 2 (Just 9)  
11  
ghci> F.foldr (||) False (Just True)  
True  
----

Але згортування значень `Maybe` не дуже цікаве, тому що, коли мова йде про згортання, воно просто діє як список з одним елементом, якщо це значення `Just`, і як порожній список, якщо це `Nothing`. Тож тоді давайте вивчимо структуру даних, яка трохи складніша.

Пам'ятаєте структуру даних дерево з розділу "Створення власних типів та класів типів"? Ми визначили її так:

[source,haskell]
----
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)  
----

Ми казали, що дерево - це порожнє дерево, яке не містить жодних значень, або це вузол, який містить одне значення, а також два інші дерева. Визначивши, ми зробили його екземпляром `Functor` і завдяки цьому ми отримали можливість `fmap` функцій над ним. Тепер ми зробимо його екземпляром `Foldable`, щоб ми отримали можливість згортати її. Один із способів зробити конструктор типу екземпляром `Foldable` - це просто безпосередньо реалізувати `foldr` для нього. Але ще один, часто набагато простіший спосіб - реалізувати функцію `foldMap`, яка також є частиною класу типу `Foldable`. Функція `foldMap` має такий тип:

[source,haskell]
----
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m  
----

Перший її параметр - це функція, яка приймає значення типу, що містить наша згорнувана структура (позначена тут `а`) і повертає моноїдне значення. Другий його параметр - структура, яка містить значення типу `a`. Він відображає функції, що функціонують над згортуваною структурою, створюючи таким чином згортувану структуру, яка містить моноїдні значення. Потім, зробивши відображення між цими моноїдними значеннями, він об'єднує їх усі в єдине моноїдне значення. Наразі ця функція може здатися дивною, але ми побачимо, що це дуже легко здійснити. Що також приємно - це те, що реалізація цієї функції - це все, що потрібно для нашого типу, щоб зробити екземпляр `Foldable`. Отже, якщо ми просто реалізуємо `foldMap` для певного типу, ми отримуємо `foldr` та `foldl` цього типу безкоштовно!

Ось як ми робимо `Tree` екземпляром `Foldable`:

[source,haskell]
----
instance F.Foldable Tree where  
    foldMap f Empty = mempty  
    foldMap f (Node x l r) = F.foldMap f l `mappend`  
                             f x           `mappend`  
                             F.foldMap f r  
----

image:images/accordion.png[]
Ми думаємо так: якщо нам надають функцію, яка бере елемент нашого дерева і повертає моноїдне значення, як ми зменшимо все наше дерево до одного моноїдного значення? Коли ми робили `fmap` над своїм деревом, ми застосували функцію, яку ми відображали у вузол, а потім рекурсивно відобразили функцію як на лівому піддереві, так і на правому. Тут ми маємо завдання не тільки відобразити функцію, але і об'єднати результати в єдине моноїдне значення за допомогою `mappend`. Спочатку ми розглянемо випадок порожнього дерева - сумного і самотнього дерева, яке не має жодних значень чи піддерев. Воно не має жодного значення, яке ми можемо надати нашій функції створення моноїдів, тому ми просто кажемо, що якщо наше дерево порожнє, значення моноїда, яким воно стає, є `mempty`.

Випадок непорожнього вузла трохи цікавіший. Він містить два піддерева, а також значення. У цьому випадку ми рекурсивно `foldMap` однакову функцію `f` над лівим та правим під деревами. Пам’ятайте, наш `foldMap` приводить до єдиного моноїдного значення. Ми також застосовуємо нашу функцію `f` до значення у вузлі. Тепер у нас є три моноїдні значення (два з наших під-дерев і одне із застосування `f` до значення у вузлі), і нам просто потрібно об'єднати їх в одне значення. Для цієї мети ми використовуємо `mappend`, і, природно, спочатку приходить ліве піддерево, потім значення вузла, а потім праве піддерево.

Зауважте, що нам не довелося надавати функцію, яка приймає значення і повертає моноїдне значення. Ми отримуємо цю функцію як параметр `foldMap`, і все, що нам потрібно вирішити, це де застосувати цю функцію та як з'єднати отримані з нею моноїди.

Тепер, коли у нас є `Foldable` екземпляр для нашого типу дерева, ми отримуємо `foldr` і `foldl` безкоштовно! Розглянемо це дерево:

[source,haskell]
----
testTree = Node 5  
            (Node 3  
                (Node 1 Empty Empty)  
                (Node 6 Empty Empty)  
            )  
            (Node 9  
                (Node 8 Empty Empty)  
                (Node 10 Empty Empty)  
            )  
----

У його корені 5, а потім лівий вузол має 3, 1 зліва та 6 праворуч. Правий вузол кореня має 9, а потім 8 зліва та 10 на крайній правій стороні. За допомогою згортуваного екземпляра ми можемо виконати всі згортки, які ми можемо зробити у списках:

[source,haskell]
----
ghci> F.foldl (+) 0 testTree  
42  
ghci> F.foldl (*) 1 testTree  
64800  
----

Крім того, `foldMap` корисний не лише для створення нових примірників `Foldable`; він стане в нагоді для редукції нашої структури до єдиного моноїдного значення. Наприклад, якщо ми хочемо знати, чи будь-яке число в нашому дереві дорівнює `3`, ми можемо це зробити:

[source,haskell]
----
ghci> getAny $ F.foldMap (\x -> Any $ x == 3) testTree  
True  
----

Тут `\x -> Any $ x == 3` - це функція, яка приймає число і повертає значення моноїда, а саме `Bool`, загорнутий у `Any`. `foldMap` застосовує цю функцію до кожного елемента в нашому дереві, а потім редукує отримані моноїди в єдиний моноїд з `mappend`. Якщо ми це зробимо:

[source,haskell]
----
ghci> getAny $ F.foldMap (\x -> Any $ x > 15) testTree  
False  
----

Усі вузли на нашому дереві матимуть значення `Any False` після того, як функція в лямбда застосована до них. Але щоб отримати `True`, `mappend` для `Any` повинен мати як параметр принаймні одне значення `True`. Ось чому кінцевий результат - `False`, що має сенс, оскільки жодне значення на нашому дереві не перевищує 15.

Ми також можемо легко перетворити наше дерево у список, зробивши `foldMap` з функцією `\x -> [x]`. Спочатку запроектувавши цю функцію на наше дерево, кожен елемент стає синглтон списком. Дія `mappend`, яка відбувається між усіма цим  синглтон списками, приводить до єдиного списку, який містить усі елементи, які є в нашому дереві:

[source,haskell]
----
ghci> F.foldMap (\x -> [x]) testTree  
[1,3,6,5,8,9,10]  
----

Приємно те, що всі ці трюки не обмежуються деревами, вони працюють на будь-якому екземплярі `Foldable`.