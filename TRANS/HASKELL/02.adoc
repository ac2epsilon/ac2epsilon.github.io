include::header.adoc[]

== На старт, пішли!

image:images/startingout.png[]
Гаразд, давайте розпочнемо! Якщо ви з тих жахливих людей, що не читають інструкцій до речей, і пропускаєте їх, в жодному разі ви маєте прочитати останній розділ зі вступу, оскільки він пояснює, що вам треба, щоб слідувати цьому туторіалу, і як ми збираємось завантажувати функції. Перша річ, що ми збираємось зробити, це виконати `ghc` в інтерактивному режимі, та викликати деякі функції, щоб отримати дуже базове відчуття `haskell`. Відкрийте ваш термінал та наберіть `ghci`. Ви отримаєте привітання, подібне до наступного.

[source,haskell]
----
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help  
Loading package base ... linking ... done.  
Prelude>  
----

Вітаємо, ви в GHCI! Тут підказка `Prelude>`, але оскільки вона може стати довшою коли ви завантажите дещо в сессії, ми збираємось використовувати `ghci>`. Якщо ви бажаєте мати таку саму підказку, просто наберіть `:set prompt "ghci> "`.

Ось деяка проста арифметика.

[source,haskell]
----
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>  
----

Це досить пояснює себе. Ми також можемо використовувати декілька операторів в одному рядку, і вони будуть підкорюватись звичайним правилам преоритетів. Ми можемо використовувати дужки, щоб зробити преоритети явними, або щоб змінити їх.

[source,haskell]
----
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950  
----

Досить круто, чи не так? Так, я знаю що ні, але повірте мені. Невелика пастка тут - подивитись як змінюється знак чисел. Якщо ви бажаєте мати від'ємне число, завжди краще оточити його в дужки. робити `5 * -3` змусить GHCI скаржитись на вас, але якщо зробити `5 * (-3)`, це буде робити добре.

Логічна алгебра також досить прямолінійна. Як ви ,вірогідно, знаєте, `&&` позначає логічне `AND`, `||` позначає логічне `OR`. `not` обертає `True` або `False`.

[source,haskell]
----
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False  
----

Перевірка на рівність робиться так.

[source,haskell]
----
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True   
----

Як щодо зробити  `5 + "llama"` або `5 == True`? Гаразд, якщо ми спробуємо перший фрагмент, ми отримаємо велике і жахливе повідомлення про помилку!

----
No instance for (Num [Char])  
arising from a use of `+' at <interactive>:1:0-9  
Possible fix: add an instance declaration for (Num [Char])  
In the expression: 5 + "llama"  
In the definition of `it': it = 5 + "llama"   
----

Такої! Що тут GHCI каже нам, це те, що `"llama"` не є числом, і так він не знає, як додати його до `5`. Навіть якщо це б було не `"llama"`, а `"four"` або `"4"`, Haskell все одно не може дійти висновку, що це число. `+` очікує, що зправа та зліва від нього числа. Якщо ви спробуєте зробити `True == 5`, GHCI скаже нам, що типи не співпадають. Хоча `+` робить тільки на речах, що розглядаються як числа, `==` робить на любих двох речах, що можна порівняти. Але зачіпка в тому, що вони обоє мають бути одним типом речей. Ви не можете порівняти яблука та помаранчі. Ми зробимо ближчий погляд на типи пізніше. Зауваження: ви можете робити `5 + 4.0`, оскільки `5` хитра, і може діяти як ціле або число з плаваючою крапкою. `4.0` не може діяти як ціле, так що `5` єдине, що має пристосовуватись.

Можиливо ви не знали це, але ми використовували функції весь цей час. Наприклад, `*` є функцією, що приймає два числа, та перемножує їх. Як ви бачили, ми використовували її, утворивши сендвіч з них. Це те, що ми називаємо інфіксною функцією. Більшість функцій, що не використовуються з числами, є префіксні функції. Давайте поглянемо на них.

image:images/phoen.png[]
Функції звичайно ідуть як префікс, такщо від тепер ми не будемо явно вказувати, що функція має префіксну форму, ми будемо просто вважати що це так. В багатьої імперативних мовах функції викликаються через запис імені функції, та потім її параметри в дужках, звичайно розділені комами. В Haskell функції викликаються записом ім'я функції, проміжок, і розділені проміжками параметри. Для початку ми спробуємо викликати одну зі скучніших функцій в Haskell.

[source,haskell]
----
ghci> succ 8  
9   
----

Функція `succ` приймає будь-що, що має визначений наступний, та повертає це наступне. Як ви можете бачити, ми просто відділили ім'я функції від параметра проміжком. Виклик функції з декількома параметрами також просте. Функції `min` та `max` приймають дві речі, що можуть бути впорядковані (як числа!). `min` повертає те, що меньше, та `max` повертає те, що більше. Дивіться самі:

[source,haskell]
----
ghci> min 9 10  
9  
ghci> min 3.4 3.2  
3.2  
ghci> max 100 101  
101   
----

Застосування функції (виклик функції через покладання проміжку пісня неї, та потім набір параметрів) має найвищий преоритет з них усіх. Це означає, що наступні два твердження еквівалентні.

[source,haskell]
----
ghci> succ 9 + max 5 4 + 1  
16  
ghci> (succ 9) + (max 5 4) + 1  
16  
----

Однак якщо ми бажаємо отримати наступний до добутку чисел `9` та `10`, ми не можемо записати  `succ 9 * 10`, оскільки це отримання послідовника для `9`, що потім буде помножений на `10`. Тобто `100`. Ми маємо писати `succ (9 * 10)` щоб отримати `91`.

Якщо функція прийма два параметри, ми також можемо викликати її як інфіксну функцію, оточивши її зворотніми апострофами. Наприклад, функція `div` приймає два цілі, та робить ціле ділення першого на друге. Обчислення `div 92 10` дає результат `9`. Але коли ми викликаємо її таким чином, може бути деякий сумнів, яке число є чисельник і яке займенник. Так що ми можемо викликати її як інфіксну функцію, зробивши `92 ``div`` 10`, і миттєво все стає зрозуміло.

Багато людей, які прийшли з імперативних мов, маю схильність приставати на нотацію, де дужки мають позначати застосування функції. Наприклад в C ви виокристовуєте дужки для виклику функції, як `foo()`, `bar(1)` або `baz(3, "haha")`. Як ми казали, в Haskell для застосування функції ми використовуємо дужки. Так що ці функції в Haskell будуть `foo`, `bar 1` та `baz 3 "haha"`. Так що якщо ви бачите що подібне до `bar (bar 3)`, це не означає, що `bar` викликається з `bar` та `3` в якості параметрів. Це означає, що спочатку ми викликаємо `bar` з `3` в якості параметра, щоб отримати якесь число, та потім ми викликаємо `bar` знову з цім числом. В C це буде щось подібне до `bar(bar(3))`.

=== Перша функції дитини

В попередньому розділі ми отримали базове відчуття щодо виклику функцій. Тепер давайте спробуємо створити свої власні! Відкрийте ваш улюблений текстовий редактор, і видайте таку функцію, що приймає число та множить його на два.

[source,haskell]
----
doubleMe x = x + x  
----

Функції визначають в спосіб, подібний до їх виклику. Ім'я функції іде перед параметрами, розділені проміжками. Але коли функція визначається, існує знак `=` , та після нього визначення того, що робить функція. Збережіть це як `baby.hs` або будь-як інакше. Тепер перейдіть туди, де ви збереглись, і запустіть там `ghci`. Всередині  GHCI зробіть `:l baby`. Тепер, коли наш скрипт завантажений, ми можемо гратись з функцією, яку ми визначили.

[source,haskell]
----
ghci> :l baby  
[1 of 1] Compiling Main             ( baby.hs, interpreted )  
Ok, modules loaded: Main.  
ghci> doubleMe 9  
18  
ghci> doubleMe 8.3  
16.6   
----

Оскільки `+` робить на цілих, так само як і на числах з плаваючою крапкою (насправді на будь-чому, що може розглядатись як число), наша функція також може робити з любими числами. Давайте зробимо функцію, що приймає два числа, та перемножує їх на два, і потім складає результати разом.

[source,haskell]
----
doubleUs x y = x*2 + y*2   
----

Просто. Ми також могли визначити це як `doubleUs x y = x + x + y + y`. Тестування продукує досить передбачувані результати (пам'ятайте додати цю функцію до файлу  `baby.hs`, збережіть його, та потім зробіть `:l baby` в GHCI).

[source,haskell]
----
ghci> doubleUs 4 9  
26  
ghci> doubleUs 2.3 34.2  
73.0  
ghci> doubleUs 28 88 + doubleMe 123  
478  
----

Як і очікувалось, ви можете викликати ваші власні функції з інших функцій, які ви створили. Маючи це на увазі, ви можете перевизначити `doubleUs` таким чином:

[source,haskell]
----
doubleUs x y = doubleMe x + doubleMe y   
----

Це дуже простий приклад загального шаблону, що ви бачитимете повсякчас в Haskell. Створення простих функцій, що вочевидь коректні, та потім комбінування їх в більш складні функції. Таким чином ви також уникаєте повторень. Що, коли деякий математик дійде висновку, що `2` насправді `3`, і ви маєте змінити програму? Ви можете просто перевизначити `doubleMe` як `x + x + x`, і оскільки `doubleUs` викликає `doubleMe`, вона також буде автоматично робити в цьому дивному світі, де `2` є `3`.

Функції в Haskell не мають іти в якомусь певному порядку, так що не має значення, якщо ви визначите `doubleMe` спочатку, та потім `doubleUs`, або ви зробите це навпаки.

Тепер ми збираємось створити функцію, що множить число на `2`, але тільки якщо число меньше або рівне `100`, бо числа більше ніж `100` досить великі як вони є!

[source,haskell]
----
doubleSmallNumber x = if x > 100  
                        then x  
                        else x*2   
----

image:images/baby.png[]
Прямо зараз ми ввели Haskell твердження `if`. Ви, можливо, знайомі з `if` твердженнями в інших мовах. Різниця між Haskell твердженням `if`, та твердженнями `if` в імперативних мовах в тому, що частина `else` обов'язкова в Haskell. В імперативних мовах ви можете просто пропустити пару кроків, якщо умова не задовільняється, але в Haskell кожний вираз та функція має щось повертати. Ми можемо також записати твердження `if` в один рядок, але я вважаю цей спосіб значно читабельніше. Інша річ щодо твердження `if` в Haskell в тому, що це вираз. Вираз загалом це шматок коду, що повертає значення. `5` є виразом, бо воно повертає `5`, `4 + 8` також вираз, `x + y` також вираз, бо він повертає суму `x` та `y`. Оскільки `else` обов'язкове, твердження `if` буде завжди  щось повертати, і ось чому це також вираз. Якщо ми бажаємо додавати одиницю до кожного числа, що спродуковане в нашій попередній функції, ми маємо записати тіло таким чином.

[source,haskell]
----
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  
----

Якщо ми б пропустили дужки, воно додавало одиницю тільки якщо `x` не було б більше `100`. Зауважте `'` наприкінці імені функції. Цей апостроф не має жодного спеціального значення в синтаксисі Haskell. Це валідний символ для використання в іменах функцій. Ми зазвичай використовуємо `'` для позначення суворої версії функції (що не є лінива), або трохи модифікованої версії функції або змінної. Оскільки `'` валідний символ в функціях, ми можемо зробити функцію таким чином.

[source,haskell]
----
conanO'Brien = "It's a-me, Conan O'Brien!"   
----

Тут дві речі, варті уваги. Перша в тому, що в назві функції ми не пишемо ім'я Конана з великої литери. Це тому, що функції не можуть починатись з великої літери. Пізніше ми побачимо чому. Друга річ в тому, що ця функція не приймає жодних параметрів. Коли функція не приймає жодних параметрів, ми кажемо що це визначення (або ім'я). Оскільки ми не можемо змінити те, що імена (та функції) означають після того, як ми їх визначили, `conanO'Brien` та рядок `"It's a-me, Conan O'Brien!"` можна використовувати взаємозамінно.

=== Вступ до списків

image:images/list.png[]
Здебільшого так само, як списки покупок в реальному світі, списки в Haskell дуже корисні. Це найбільш використовувана структура даних, і вона може бути використана в безлічі різних способів, щоб моделювати та вирішувати цілу кіпу проблем. Списки ТАКІ неймовірні. В цьому розділі ми побачимо на основи списків, рядкі (що є списками) та осяжність списків.

В Haskell списки є гомогенними структурами даних. Вони зберігають декілька елементів одного типу. Це означає, що ми можемо мати список цілих та список символів, але ми не можемо мати список, що має трохи цілих, та трохи символів. І тепер - список!

Note: Ми можемо використовувати ключове слово `let` для визначення імені прямо в GHCI. Зробити `let a = 1` в GHCI еквівалентно до написання `a = 1` в скрипті, та потім його завантаження.

[source,haskell]
----
ghci> let lostNumbers = [4,8,15,16,23,42]  
ghci> lostNumbers  
[4,8,15,16,23,42]  
----

Як ви можете бачити, списки позначаються квадратними дужками, та значення в списках розділяються комами. Якщо ми спробуємо список `[1,2,'a',3,'b','c',4]`, Haskell буде скаржитись, що символи (що, проміж іншого, позначаються символами в поодиноких лапках) не є числами. Кажучи про символи, рядки є тільки списками символів. `"hello"` є тільки синтаксичним цукром для `['h','e','l','l','o']`. Оскільки рядки є списками, ми можемо використовувати функції для спискив з рядками, що дійсно зручно.

Загальна задача є складання двох списків разом. Це робиться за допомогою оператора `++`.

[source,haskell]
----
ghci> [1,2,3,4] ++ [9,10,11,12]  
[1,2,3,4,9,10,11,12]  
ghci> "hello" ++ " " ++ "world"  
"hello world"  
ghci> ['w','o'] ++ ['o','t']  
"woot"  
----

Пильнуйте, коли постійно використовуєте оператор `++` на довгих рядках. Коли ми складаємо разом два списки (навіть якщо ми додаємо синглтон список до списку, наприклад: `[1,2,3] ++ [4]`), внутрішньо Haskell має пройти по всьому списку злівого боку від `++`. Це не проблема, коли маємо справи зі списками, що не дуже великі. Але покладання дечого в кінець списку, що має п'ядесят мільйонів елементів в довжину таки займе деякий ча. Однак покладання дечого на початок списку з використанням оператора `:` (також називається `cons` оператором) є миттєвим.

[source,haskell]
----
ghci> 'A':" SMALL CAT"  
"A SMALL CAT"  
ghci> 5:[1,2,3,4,5]  
[5,1,2,3,4,5]  
----

Зауважте, як `:` приймає число і список чисел, або символ та список символів, тоді як `++` приймає два списки. Навіть якщо ви додаєте один елемент в кінець списку за допомогою `++`, ви маєте оточити його в квадратні дужки, так щоб він став списком.

`[1,2,3]` насправді є тільки синтаксичним цукром для `1:2:3:[]`. `[]` це порожній список. Якщо перед ним добавити `3` це перетвориться на `[3]`. Якщо перед цім поставити `2`, стане `[2,3]`, і так далі.

Note: `[]`, `[[]]` та `[[],[],[]]` все різні речі. Перше це порожній список, друге це список, що містить один порожній список, третій список містить три порожні списки.

Якщо ви бажаєте отримати елемент зі списку по індексу, використовуйте `!!`. Індекси починаються з `0`.

[source,haskell]
----
ghci> "Steve Buscemi" !! 6  
'B'  
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1  
33.2  
----

Але якщо ви намагатиметесь отримати шостий елемент зі списку, що має тільки чотири елементи, ви отримаєте помилку, так що будьте уважні!

Списки також можуть містити списки. Вони також можуть містити списки, що містять списки, що містять списки …

[source,haskell]
----
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b  
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b ++ [[1,1,1,1]]  
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]  
ghci> [6,6,6]:b  
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b !! 2  
[1,2,2,3,4]   
----

Списки в списку можуть бути різної довжини, але вони не можуть бути різних типів. Так само, як ви не можете мати список, що містить деякі числаі деяки символи, ви не можете мати деякі списки з символами, і деякі списки з числами.

Списки можливо порівняти, якщо те, що вони містять, може бути порівняно. Коли використовуються `<`, `<=`, `>` та `>=` для порівняння списків, вони порівнюються в лексографічному порядку. Спочатку порівнюються голови. Якщо вони рівні, порівнюються другі елементи, і так далі.

[source,haskell]
----
ghci> [3,2,1] > [2,1,0]  
True  
ghci> [3,2,1] > [2,10,100]  
True  
ghci> [3,4,2] > [3,4]  
True  
ghci> [3,4,2] > [2,4]  
True  
ghci> [3,4,2] == [3,4,2]  
True  
----

Що ще можна робити зі списками? Ось деякі базові функції, що оперують на списках.

`head` бере список, та повертає його голову. Голова списку це його перший елемент.

[source,haskell]
----
ghci> head [5,4,3,2,1]  
5   
----

`tail` бере список, та повертає його хвіст. Іншими словами вона відрубає йому голову.

[source,haskell]
----
ghci> tail [5,4,3,2,1]  
[4,3,2,1]   
----

`last` бере список, та повертає останній елемент.

[source,haskell]
----
ghci> last [5,4,3,2,1]  
1   
----

`init` бере список, та повератє все, крім останнього елемента.

[source,haskell]
----
ghci> init [5,4,3,2,1]  
[5,4,3,2]   
----

Якщо ви вважаєте, що список це монстр, тоді вам сподобається таке.

image::images/listmonster.png[]

Але що трапиться, якщо ми спробуємо отримати голову порожнього списку?

[source,haskell]
----
ghci> head []  
*** Exception: Prelude.head: empty list  
----

Матінко рідна! Все це вибухнуло нам у лице! Якщо немає монстра, в нього немає голови. Коли використовуєте `head`, `tail`, `last` та `init`, будьте уважні не використовувати їх на порожніх списках. Ця помилка не може бути перехоплена під час компіляції, так що завжди гарна практика докласти перестороги супроти випадкового прохання до Haskell отримати елементи з порожнього списку.

`length` бере список, та повертає його довжину, очевидно.

[source,haskell]
----
ghci> length [5,4,3,2,1]  
5  
----

`null` перевіряє, чи список порожній. Якщо це так, він повертає `True`, інакше `False`. Використовуйте цю функцію замість `xs == []` (якщо ви маєте список з назвою `xs`)

[source,haskell]
----
ghci> null [1,2,3]  
False  
ghci> null []  
True  
----

`reverse` обертає список.

[source,haskell]
----
ghci> reverse [5,4,3,2,1]  
[1,2,3,4,5]  
----

`take` бере число і список. Він виділяє таку кількість з початку списка. Дивіться.

[source,haskell]
----
ghci> take 3 [5,4,3,2,1]  
[5,4,3]  
ghci> take 1 [3,9,3]  
[3]  
ghci> take 5 [1,2]  
[1,2]  
ghci> take 0 [6,6,6]  
[]  
----

Бачите, якщо ми намагаємось взяти більше елементів, ніє є в списку, він просто повертає список. Якщо ми намагаємось взяти `0` повертається порожній список.

`drop` робить подібним чином, тільки він відкидає число елементів з початку списка.

[source,haskell]
----
ghci> drop 3 [8,4,2,1,5,6]  
[1,5,6]  
ghci> drop 0 [1,2,3,4]  
[1,2,3,4]  
ghci> drop 100 [1,2,3,4]  
[]   
----

`maximum` бере список дечого, що може бути впорядковане, і повертає найбільший елемент.

`minimum` повертає найменьший.

[source,haskell]
----
ghci> minimum [8,4,2,1,5,6]  
1  
ghci> maximum [1,9,2,3,4]  
9   
----

`sum` бере список чисел, та повертає його суму.

`product` бере список чисел, та повертає його добуток.

[source,haskell]
----
ghci> sum [5,2,1,6,3,2,5,7]  
31  
ghci> product [6,2,1,2]  
24  
ghci> product [1,2,5,6,7,9,2,0]  
0   
----

`elem` бере річ та список речей, та каже нам, чи є такий елемент в списку. Це звичайно викликається як інфіксна функція, оскільки так воно краще читається.

[source,haskell]
----
ghci> 4 `elem` [3,4,5,6]  
True  
ghci> 10 `elem` [3,4,5,6]  
False  
----

Це були декілька базових функцій, що оперують на списках. Ми побачимо більше спискових функцій пізніше.

=== Техаські ренджі

image:images/cowboy.png[] 
Що, коли ми бажаємо перелічити всі числа від 1 до 20? Звичайно, ми можемо просто надрукувати їх всі разом, але вочевидь це не рішення для джентельмена, що вимагає досконалості від своїх мов програмування. Замість цього ми використовуємо диапазони. Диапазони - це спосіб створювати списки, що є арифметичними послідовностями елементів, що можуть бути перелічені. Числа можуть бути перелічені. Один, два, три, чотири, тощо. Символи можути бути перелічені. Абетка є перелік літер від `A` до `Z`. Імена не можуть бути перелічені. Що іде після `"John"`? Я не знаю.

Щоб зробити список, що містить всі натуральні числа від 1 до 20 ви можете записати`[1..20]`. Це еквівалентно до написання `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`, і немає різниці між написанням одного чи іншого, за винятком того, що написання довгих послідовностей переліку вручну є дурнею.

[source,haskell]
----
ghci> [1..20]  
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
ghci> ['a'..'z']  
"abcdefghijklmnopqrstuvwxyz"  
ghci> ['K'..'Z']  
"KLMNOPQRSTUVWXYZ"   
----

Диапазони круті, оскільки ви можете задати крок. Що, якщо ми бажаємо всі парні числа між 1 та 20? Або навіть тожне третє між 1 та 20?

[source,haskell]
----
ghci> [2,4..20]  
[2,4,6,8,10,12,14,16,18,20]  
ghci> [3,6..20]  
[3,6,9,12,15,18]   
----

Це просто справа розділення перших двох елементів комою, та потім вказати вищий ліміт. Хоча це досить розумне, диапазони з кроками не такі розумні, ніє деяки люди бажали б їх бачити. Ви не можете зробити `[1,2,4,8,16..100]`, та очікувати отримання всіх ступеней `2`. Для початку тому що ви можете вказати один крок. Та подруге через те, що деякі неарифметичні послідовності неоднозначні, якщо задати тільки декілька з перших членів послідовності.

Щоб зробити список з усіх чисел від 20 до 1, ви не можете записати тільки `[20..1]`, ви маєте зробити `[20,19..1]`.

Слідкуйте за використанням чисел з плаваючою крапкою в диапазонах! Завдяки тому, що вони не повністю точні (по визначенню), їх використання може дати деякі досить дивні результаті.

[source,haskell]
----
ghci> [0.1, 0.3 .. 1]  
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  
----

Моя порада не використовувати їх в спискових диапазонах.

Ви також можете використовувати диапазони для створення безкінечних списків, просто не задаючи верню межу. Пізніше ми дійдемо до більших деталей щодо безкінечних списків. Тепер давайте перевіримо, як ви можете отримати перші `24` добутки числа `13`. Звичайно, ви можете зробити `[13,26..24*13]`. Але є кращий шлях: `take 24 [13,26..]`. Оскільки Haskell лінивий, він не буде намагатись обчислити безкінечний список безпосередньо, бо це ніколи не скінчиться. Він буде чекати, що ви бажаєте отримати з цього безкінечного списку. І тут він бачить, що ви бажаєте отримати лише перші `24` елементи, на що він легко погоджується.

Декілька фунцій, що продукують безкінечні списки:

`cycle` бере список, та в циклі перетворює його в безкінечний список. Якщо ви спробуєте тільки отримати результат, це триматиме вічність, тому ви маєте перерватись десь.

[source,haskell]
----
ghci> take 10 (cycle [1,2,3])  
[1,2,3,1,2,3,1,2,3,1]  
ghci> take 12 (cycle "LOL ")  
"LOL LOL LOL "   
----

`repeat` бере елемент, та продукує безкінечний список тільки з цього елемента. Це як цикл по списку тільки з одного елемента.

[source,haskell]
----
ghci> take 10 (repeat 5)  
[5,5,5,5,5,5,5,5,5,5]  
----

Хоча це простіше просто використовувати фуункцію `replicate`, якщо ви бажаєте деяке число одного елемента в списку. `replicate 3 10` повертає `[10,10,10]`.

=== Я - породжуючий списки

image:images/kermit.png[] 
Якщо ви колись вивчали курс з математики, ви, можливо, натрапляли на осяжності множин (прим.перекл. Насправді термін _comprehension_ погано або майже не перекладається одинм словом. Суть в процедурному породженні множини, так би мовити делегація вирішення питання належності до деякого функціоналу - фактично, _comprehension_ легше зрозуміти з боку функціонального програмування). Вони звичайно використовуються для побудови більш специфічних множин на основі більш загальних. Базова осяжність для множини, що містить перші десять парних натуральних чисел є нотація множини.

image:images/setnotation.png[] 
Частина перед рискою називається функцією виводу, `x` це змінна, `N` є вхідна множина, та `x <= 10` є предикат. Це означає, що множина містить подвоєння всіх натуральних чисел, що задовільняють предикату.

Якщо ви бажаєте записати це в Haskell, ви можете зробити щось подібне до `10 [2,4..]`. Але що, якщо ви не бажаєте подвоєння перших `10` натуральних чисел, але деякий різновид більш складної функції, застосованої до них? Ми можемо застосувати для цього осяжність множини. Ми покі пристанемо до отримання перших `10` парних чисел. Осяжність списків, яку ми ми можемо використати, це `[x*2 | x <- [1..10]]`. `x` береться з `[1..10]`, і для кожного елемента в `[1..10]` (який ми прив'язуємо до `x`), ми отримуємо цей елемент, тільки подвоєний. Ось осяжність в дії.

[source,haskell]
----
ghci> [x*2 | x <- [1..10]]  
[2,4,6,8,10,12,14,16,18,20]  
----

Як ви можете бачити, ми отримали бажаний результат. Тепер давайте додамо умову (або предикат) до осяжності. Предикати ідуть після частини прив'язування, та відокремлюються від них комою. Скажімо, ми бажаємо тільки елементи, що, вже подвоїні, більші або рівні до `12`.

[source,haskell]
----
ghci> [x*2 | x <- [1..10], x*2 >= 12]  
[12,14,16,18,20]  
----

Круто, це робить. Що, коли ми бажаємо всі числа від `50` до `100`, чий залишок, коли поділений на число `7`, є `3`? Легко.

[source,haskell]
----
ghci> [ x | x <- [50..100], x `mod` 7 == 3]  
[52,59,66,73,80,87,94]   
----

Успіх! Зауважте, що пропускання списків через предикати також називається фільтрацією. Ми беремо список з чисел, і ми фільтруємо його предикатом. Тепер інший приклад. Скажімо, ми бажаємо осяжність, що замінює кожне непарне число, більше ніж `10` на `"BANG!"`, та кожне непарне, що меньше ніж `10` на `"BOOM!"`. Якщо число не непарне, ми відкидаємо його зі списку. Для зручності ми покладемо цю осяжність в функцію, так що ми можемо легко використовувати її декілька раз.

[source,haskell]
----
boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]   
----

Остання частина осяжності є предикат. Функція `odd` повертає `True` на непарних числах, та `False` на парних. Елемент включається в список тільки якщо всі його предикати обчислюються до `True`.

[source,haskell]
----
ghci> boomBangs [7..13]  
["BOOM!","BOOM!","BANG!","BANG!"]   
----

Ми можемо включити декілька предикатів. Якщо ми бажаємо всі числа від `10` до `20`, що не є `13`, `15` або `19`, ми робимо:

[source,haskell]
----
ghci> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]  
[10,11,12,14,16,17,18,20]  
----

Ви не тільки можете мати декілька предикатів в осяжностях списків (елемент має задовільняти всім предикатам щоб бути включеним в результуючий список), ми також можемо вибирати з декількох списків. Коли здаєте з кількох списків, осяжність продукує всі комбінації з наданих списків, та потім поєднує їх в вихідній функції, яку ми надаємо. Список, вироблений осяжністю, що вибирає з двох списків довжиною `4`, буде мати довжину `16`, якщо вважати, що ми нічого не фільтруємо. Якщо ми маємо два списки, `[2,5,10]` та `[8,10,11]`, та бажаємо спродукувати всі можливі комбінації між числами в ціх списках, ось як ми це робимо.

[source,haskell]
----
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]  
[16,20,22,40,50,55,80,100,110]   
----

Як очікувалось, довжина нового списку є `9`. Що, коли ми бажаємо всі можливі добутки, що більші за `50`?

[source,haskell]
----
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], x*y > 50]  
[55,80,100,110]   
----

Як щодо осяжності списку, що комбінує список прикметників та список іменників … заради епічної втіхи.

[source,haskell]
----
ghci> let nouns = ["hobo","frog","pope"]  
ghci> let adjectives = ["lazy","grouchy","scheming"]  
ghci> [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns]  
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",  
"grouchy pope","scheming hobo","scheming frog","scheming pope"]   
----

Я знаю! Давайте напишемо свою власну версію `length`! Ми назвемо її `length'`.

[source,haskell]
----
length' xs = sum [1 | _ <- xs]   
----

`_` означає, що нам байдуже, що ми витягнули зі списку, так що замість писати ім'я змінної, що ніколи не буде використовуватись, ми просто пишемо _. Ця функція заміняє кожний елемент в списку на `1`, та потім підсумовує їх. Це означає, що отримана сума буде рівною довжині нашого списка.

Просто дружнє нагадування: оскільки рядки є списками, ми можемо використовувати осяжності списків для обробки та продукування рядків. Ось функція, що бере рядок, та видаляє будь-що, за винятком великих літер.

[source,haskell]
----
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   
----

Testing it out:

[source,haskell]
----
ghci> removeNonUppercase "Hahaha! Ahahaha!"  
"HA"  
ghci> removeNonUppercase "IdontLIKEFROGS"  
"ILIKEFROGS"   
----

Тут предикат робить всю роботу. Він каже, що символи будуть включені в новий список, тільки якщо вони є елементами списку `['A'..'Z']`. Вкладені осяжності списків також можливі, якщо ви оперуєте зі списками, що містять списки. Список містить декілька списків чисел. Давайте видалимо всі непарні числа без вирівнювання списку.

[source,haskell]
----
ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]  
ghci> [ [ x | x <- xs, even x ] | xs <- xxs]  
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]  
----

Ви можете записувати осяжності списків на декількох рядках. Так що якщо ви не в GHCI, краще розділити довші осяжності списків на декілька рядків, особливо якщо вони вкладені.

=== Тапли

image:images/tuples.png[]
В деякий спосіб тапли як списки — вони є спосіб зберігати декілька значень в одному значенні. Але є декілька фундаментальних відмінностей. Список чисел є список чисел. Це його тип, і не має значення, чи він має лише одне число в собі, або безкінечне іисло чисел. Однак тапли використовуються, коли ви напевне знаєте, скільки значень ви бажаєте скомбінувати, та їх тип залежить від того, як багато компонент, та який їх тип. Вони позначаються дужками, та їх компоненти розділені комами.

Інша ключова відмінність в тому, що вони не мають бути гомогенними. На відміну від списків, тапл може містити комбінацію декількох типів.

Подумайте про те, як ми представляємо дво-вимірний вектор в Haskell. Один спосіб може бути список. Це має деяк робити. То що, якщо ми бажаємо покласти пару векторів в список, щоб представляти точки фігури на дво-мірній площині? Ми маємо зробити щось таке: `[[1,2],[8,11],[4,5]]`. Проблема з цім методом в тому, що ми також можемо робити такі речі: `[[1,2],[8,11,5],[4,5]]`, з чим Haskell не матиме проблем, бо це також список списків з числами, але це щось таке, що не має сенсу. Але тапл розміром два (що також має назву `pair`) є власним типом, що означає, що список не може мати декілька пар, і потім `triple` (тапл розміром три), так що давайте краще використовувати пари. Замість оточувати вектори квадратними дужками, ми використовуємо дужки: `[(1,2),(8,11),(4,5)]`. Що, коли ми спробуємо зробити фігуру як `[(1,2),(8,11,5),(4,5)]`? Гаразд, ми отримаємо таку помилку:

----
Couldn't match expected type `(t, t1)'  
against inferred type `(t2, t3, t4)'  
In the expression: (8, 11, 5)  
In the expression: [(1, 2), (8, 11, 5), (4, 5)]  
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]  
----

Це каже нам, що ми спробували використовувати пару та трійку в одному списку, що не мало б статись. Ви також не можете зробити список як `[(1,2),("One",2)]`, оскільки перший елемент в списку є парою чисел, і другий елемент є парою, що складається з рядка та числа. Тапли також можуть використовуватись для представлення широкого різноманіття даних. Наприклад, якщо ми бажаємо представити чиєсь ім'я і вік в Haskell, ми можемо використовувати `triple`: `("Christopher", "Walken", 55)`. Як бачимо в цьому прикладі, тапли також можуть містити списки.

Використовуйте тапли, коли ви знаєте заздалегідь, як багато компонент буде мати деякий шматок даних. Тапли значно більш обмежені, оскільки кожни інший розмір тапла є власним типом, так що ви не можете написати загальну функцію для додавання елементу до тапла — ви маєте писати функцію для додавання до пари, одну функцію для додавання до трійці, одну для додавання до четвірки і так далі.

Хоча є списки синглтони, немає такої речі як синглтон тапл. Це не має багато сенсу, якщо ви поміркуєте про це. Синглтон тапл є тільки значення, що він містить, і це не дає нам жодних переваг.

Як списки, тапли можуть бути порівняні один з одним, якщо їх компоненти можуть бути порівняні. Ви не можете порівняти два тапла різного розміру, хоча ви можете порівняти два списки різного розміру. Дві корисні функції для операцій на парах:

`fst` бере пару, та повертає перший компонент.

[source,haskell]
----
ghci> fst (8,11)  
8  
ghci> fst ("Wow", False)  
"Wow"  
----

`snd` бере пару, та повертає другий компонент. Сюрприз!

[source,haskell]
----
ghci> snd (8,11)  
11  
ghci> snd ("Wow", False)  
False  
----

Note: ці функції оперують тільки на парах. Вони не працюватимуть на трійках, четвірках, п'ятірках, тощо. Ми дійдемо до отримання даних з таплів в різний спосіб трохи пізніше.

Крута функція, що продукує список пар: `zip`. Вона приймає список з двох списків, та потім поєднує їх разом в один список, через поєднання елементів з одним індексом в пари. Це насправді проста функція, але вона має безліч застосувань. Вона особливо корисна, коли ви бажаєте скомбінувати два списки в цей спосіб, або пересуватись по обох списках одночасно. Ось демонстрація.

[source,haskell]
----
ghci> zip [1,2,3,4,5] [5,5,5,5,5]  
[(1,5),(2,5),(3,5),(4,5),(5,5)]  
ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]  
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]  
----

Це спаровує елементи та продукує новий список. Перший елемент з першим, другий з другим, і так далі. Зауважте, що оскільки пари можуть мати різні типи в собі, `zip` може приймати два списка, що містять різні типи, та поєднати їх разом. Що трапиться, якщо довжина списків не співпаде?

[source,haskell]
----
ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]  
[(5,"im"),(3,"a"),(2,"turtle")]  
----

Довший список просто буде обрізаний, щоб співпадати по довжині з коротшим. Оскільки Haskell лінивий, ми можемо поєднувати скінчені списки з безкінечними списками:

[source,haskell]
----
ghci> zip [1..] ["apple", "orange", "cherry", "mango"]  
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]  
----

image:images/pythag.png[]
Ось проблема, що поєднує тапли та осяжності списків: який правильний трикутник, що має цілими всі сторони, і всі сторони меньше або рівні `10`, має периметр `24`? Перше, давайте спробуємо генерувати всі трикутники, зі сторонами меньшими ніж `10`:

[source,haskell]
----
ghci> let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ]   
----

Ми тільки но тягнемо з трьох списків, і наша вихідна функція є поєднання їх в трійцю. Якщо ви обчислите це, набравши `triangles`  в GHCI, ви отримаєте список всіх можливих трикутників зі сторонами довжиною `10` або меньше. Далі ми додамо умову, щоб всі вони були правильними трикутниками. Ми також будемо модифікувати цю функцію, приймаючи до уваги, що сторона `b` не більша за гіпотенузу, і що сторона `a` не більша за сторону `b`.

[source,haskell]
----
ghci> let rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]   
----

Ми майже скінчили. Тепер ми тільки модифікуємо функцію, сказавши, що ми бажаємо тільки коли периметр дорівнює `24`.

[source,haskell]
----
ghci> let rightTriangles' = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24]  
ghci> rightTriangles'  
[(6,8,10)]  
----

А ось і відповідь! Це загальних шаблон функціонального програмування. Ви берете стартовий набір рішень, та потім ви застосовуєте трансформації до ціх рішень, та фільтруєте їх, доки ви не отримаєте потрібні.
