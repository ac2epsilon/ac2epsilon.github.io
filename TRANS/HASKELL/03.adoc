include::header.adoc[]

== Типи і типокласи

=== Повірте типу

image:images/cow.png[]
Раніше ми згадували, що Haskell має статичну систему типів. Тип кожного виразу відомий під час компіляції, що призводить до безпечнішого коду. Якщо ви напишете програму, де ви спробуєте поділити логічний тип на деяке число, вона навіть не скомпілюється. Це добре, бо краще перехоплювати такі помилки під час компіляції, замість отримати крах вашої програми. Все в Haskell має тип, так що компілятор може міркувати щодо вашої програми, перед тим як скомпілювати її.

На відміну від Java або Pascal, Haskell має вивід типів. Якщо ви пишете число, ви не маєте казати Haskell, що це число. Він може вивести це сам, так що нам не треба явно писати типи наших функцій та виразів, щоб все робилось відповідно. Ми розглянули деяки з основ Haskell, тільки зверньо поглянувши на типи. Однак розуміння системи типів є дуже важливою частиною в вивченні Haskell.

Тип є різновидом мітки, що має кожен вираз. Він каже нам, до якої категорії речей належить вираз. Вираз `True` є логічним, `"hello"` є рядком, тощо.

Зараз ми будемо використовувати GHCI для перевірки типів деяких виразів. Ми будемо робити це, використовуючи команду `:t`, яка, якщо стоїть перед валідним виразом, каже його тип. Дамо йому вир.

[source,haskell]
----
ghci> :t 'a'  
'a' :: Char  
ghci> :t True  
True :: Bool  
ghci> :t "HELLO!"  
"HELLO!" :: [Char]  
ghci> :t (True, 'a')  
(True, 'a') :: (Bool, Char)  
ghci> :t 4 == 5  
4 == 5 :: Bool  
----

image:images/bomb.png[]
Тут ми бачимо, що робити `:t` на виразі друкує вираз, за яким іде `::` та його тип. `::` читається як "має певний тип". Явні типи завжди позначаються першою літерою верхнього реєству. `'a'`, як можна бачити, має тип `Char`. Не важко зробити висновок, що це позначає символ. `True` має тип `Bool` (логічний тип, названий за розробником логічної алгебри предикатів, Буля. прим.перекл). Це має сенс. Але що це? Дослідження типу `"HELLO!"` дає `[Char]`. Квадратні дужки позначають список. Так що ми читаємо це як список символів. На відміну від списків кожна довжина таплу має власний тип. Так що вираз `(True, 'a')` має тип `(Bool, Char)`, тоді як вираз як `('a','b','c')` матиме тип `(Char, Char, Char)`. `4 == 5` завжди повертатиме `False`, так що його тип `Bool`.

Функції також мають типи. Коли ми пишемо власні функції, ми можемо обрати надавати їм явні декларації типів. Це загалом розглядається як гарна практика, за винятком коли ми пишемо дуже малі функції. Звідси і надалі ми надаватимемо функції, що мають явні декларації типів. Згадайте осяжності списків, що ми робили до цього, що фільтрували рядки, що мають лише великі літери? Ось як це виглядає з декларацією типу.

[source,haskell]
----
removeNonUppercase :: [Char] -> [Char]  
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   
----

`removeNonUppercase` має тип `[Char] -> [Char]`, що каже, що вона відзеркалює рядок на рядок. Це тому, що вона бере один рядок як параметр, та повертає інший як результат. Тип `[Char]` є синонімом до `String`, так що буде яснішим, якщо ми напишемо `removeNonUppercase    \:\: String -> String`. Ми не маємо надавати цій функції декларацію типу, оскільки компілятор може вивести це самостійно, що це функція рядка до рядка, ала ми зробили це все одно. Але як записати тип функції, що приймає декілька параметрів? Ось проста функція, що приймає три цілі та складає їх разом:

[source,haskell]
----
addThree :: Int -> Int -> Int -> Int  
addThree x y z = x + y + z  
----

Параметри розділені позначкою `->`, і немає особливої різниці між параметрами та типом повернення. Тип повернення є останнім елементом в декларації, та параметри перші три. Пізніше ми побачимо, чому вони всі розділені `->`, замість мати деякий більш явний спосіб розрізнення між типом повернення та параметрами, як `Int, Int, Int -> Int`, або щось таке.

Якщо ви бажаєте надати вашій функції декларацію типу, але не впевнені, що це має бути, ви можете тільки написати функцію без нього, та потім перевірити її за допомогою `:t`. Функції також є виразами, так що `:t` робить на них без проблем.

Ось огляд деяких загальних типів.

`Int` означає цілі. Він використовується для цілих чисел. `7` може бути `Int`, але `7.2` ні. `Int` обмежене, що означає, що вони мають мінімум та максимальне значення. Зазвичай на 32-бітних машинах максимально можливе `Int` є `2147483647`, та мінімальне є `-2147483648`.

`Integer` позначає також, хм … також ціле. Головна різниця в тому, що він не прив'язаний до меж, і він може використовуватись для представлення насправді великих чисел. Я маю на увазі що дійсно великіх. Однак `Int` більш ефективний.

[source,haskell]
----
factorial :: Integer -> Integer  
factorial n = product [1..n]  
ghci> factorial 50  
30414093201713378043612608166064768844377641568960512000000000000  
----

`Float` є дійсне плаваюче з одинарною точністю.

[source,haskell]
----
circumference :: Float -> Float  
circumference r = 2 * pi * r  
ghci> circumference 4.0  
25.132742  
----

`Double` є дійсне плаваюче з подвійною точністю!

[source,haskell]
----
circumference' :: Double -> Double  
circumference' r = 2 * pi * r  
ghci> circumference' 4.0  
25.132741228718345  
----

`Bool` є логічний тип. Він може мати тільки два значення: `True` та `False`.

`Char` представляє символ. Він позначається поодинокими лапками. Список символів є рядком.

Тапли є типами, але вони залежні від своєї довжини, так само, як і від типів своїх компонентів, так що теоретично є безліч типів таплів, що забагато, щоб накрити в цьому туторіалу. Зауважте, що порожній тапл `()` також є типом, що може мати одне значення: `()`.

=== Змінні типів

Який, як ви думаєте, є тип функції `head`? Оскільки `head` приймає список любого типу, та повертає перший елемент, то що це має бути? Давайте перевіримо!

[source,haskell]
----
ghci> :t head  
head :: [a] -> a  
----

image:images/box.png[] 
Хмм! Що є це `a`? Чи це є тип? Згадайте, що дотепер ми стверджували, що типи записуються з великої літери, так що це не може в точності бути типом. Оскільки це не велика літера, це насправді змінна типу. Це значить, що це може бути любий тип. Це здебільшого як дженеріки в інших мовах, але в Haskell це значно більш потужне, оскільки це дозволяє нам просто писати любі загальні функції, тільки якщо вони не використовують деяку особливу специфічну поведінку на типах в своєму складі. Функції, що мають змінні типів, називаються поліморфними функціями. Декларація типу `head` стверджує, що вона приймає список любого типу, та повертає один елемент цього типу.

Хоча змінні типів можуть мати ім'я, довші за один символ, ми зазвичай даємо їм імена `a`, `b`, `c`, `d` …

Пам'ятаєте `fst`? Він повертає перший компонент з пари. Давайте дослідимо його тип.

[source,haskell]
----
ghci> :t fst  
fst :: (a, b) -> a  
----

Ми бачимо, що `fst` бере тапл, що має два типи, і повертає елемент, чий тип такий самий, що і тип першого компонента з пари. Ось чому ми можемо використовувати `fst` на парі, що містить два довільні типи. Зауважте, що тільки через те, що `a` та `b` є різними змінними типів, вони не мають бути різними типами. Це типами стверджує, що тип першого компоненту та тип значення повернення є тим самим.

=== Типокласи 101

image:images/classes.png[]
Типоклас є деяким різновидом інтерфейсу, що визначає деяку поведінку. Якщо тип є частиною типокласу, це означає, що він підтримує та реалізує поведінку, яку описує типоклас. Багато людей, що приходять з OOP, спантеличені типокласами, бо вважають їх подібними до класів в об'єктно орієнтовних мовах. Гараз, це не так. Ви можете думати про них, як про різновид Java інтерфейсів, тільки кращіх.

==== Яка сигнатура типу функції `==`?

[source,haskell]
----
ghci> :t (==)  
(==) :: (Eq a) => a -> a -> Bool  
----

Note: оператор еквівалентності `==` є функцією. Так само, як `+`, `*`, `-`, `/`, та майже всі інші оператори. Якщо функція складається тільки зі спеціальних символів, вона розглядається як інфіксна функція по замовчанню. Якщо ми бажаємо перевірити її тип, передати її до іншої функції, або викликати як префіксну функцію, ми маємо оточити її дужками.

Цікаво. Ми бачимо тут нову річ, символ `=>`. Все перед символом `=>` має назву класової константи. Ми можемо прочитати попередню декларацію типу таким чином: Функція еквівалентності бере два значення, що мають однаковий тип, та повертає `Bool`. Тип ціх значень мусить бути типом класу `Eq` (це була класова константа).

Типоклас `Eq` провадить інтерфейс для перевірки на рівність. Кожний клас, коли має сенс перевірка на рівність між двома елементами для цього типу, мав би бути членом класу `Eq`. Всі стандартні типи Haskell, за винятком IO (тип для роботи з вводом та виводом), та функції є частиною типокласу `Eq`.

Функція `elem` має тип `(Eq a) => a -> [a] -> Bool`, оскільки він використовує `==` по списку, щоб перевірити, чи деяке значення, яке ми шукаємо, знаходиться в списку.

=== Деякі базові типокласи:

`Eq` використовується для типів, що підтримують перевірку на рівність. Функції, що реалізують його члени є `==` та `/=`. Так що якщо є обмеження класу `Eq` для змінної типу в функції, вона використовує `==` або `/=` десь в своїй декларації. Всі типи, що ми згадували до цього, за винятком функцій, є частинами `Eq`, так що вони можуть бути перевірені на рівність.

[source,haskell]
----
ghci> 5 == 5  
True  
ghci> 5 /= 5  
False  
ghci> 'a' == 'a'  
True  
ghci> "Ho Ho" == "Ho Ho"  
True  
ghci> 3.432 == 3.432  
True  
[source,haskell]
----

`Ord` призначений для типів, що мають впорядкування.

[source,haskell]
----
ghci> :t (>)  
(>) :: (Ord a) => a -> a -> Bool  
----

Всі типи, що ми розглядали досі, за винятком функцій, є частиною `Ord`. `Ord` покриває всі стандартні функції порівняння, такі як `>`, `<`, `>=` та `<=`. Функції порівнянь беруть два члени `Ord` того самого типу, і повертають впорядкування `Ordering`. `Ordering` є типом, що може бути `GT`, `LT` або `EQ`, що відповідно означає більше ніж, меньше ніж, або дорівнює.

Щоб бути членом `Ord` тип має зпочатку мати членство в престижному та ексклюзивному клубі `Eq`.

[source,haskell]
----
ghci> "Abrakadabra" < "Zebra"  
True  
ghci> "Abrakadabra" `compare` "Zebra"  
LT  
ghci> 5 >= 2  
True  
ghci> 5 `compare` 3  
GT  
----

Члени `Show` можуть бути представлені як рядкі. Всі типи, що розглядались досі, за винятком функцій, є частиною `Show`. Найбільш уживана функція, що має справу з типокласом `Show` є `show`. Вона бере значення, чий тип є членом `Show`, та представляє його нам як рядок.

[source,haskell]
----
ghci> show 3  
"3"  
ghci> show 5.334  
"5.334"  
ghci> show True  
"True"  
----

`Read` є дещо протилежним типокласом до `Show`. Функція `read` бере рядок, та повертає тип, який є членом `Read`.

[source,haskell]
----
ghci> read "True" || False  
True  
ghci> read "8.2" + 3.8  
12.0  
ghci> read "5" - 2  
3  
ghci> read "[1,2,3,4]" ++ [3]  
[1,2,3,4,3]  
----

Доки досить. Знову, всі типи, розглянуті до сих пір, знаходяться в цьому типокласі. Але що відбудеться, якщо ми тільки зробимо `read "4"`?

[source,haskell]
----
ghci> read "4"  
<interactive>:1:0:  
    Ambiguous type variable `a' in the constraint:  
      `Read a' arising from a use of `read' at <interactive>:1:0-7  
    Probable fix: add a type signature that fixes these type variable(s)  
----

Що GHCI тут нам каже, це те, що він не знає, що ми бажаємо повернути. Зауважте, що в попередніх використаннях `read` ми робили дещо з результатом після цього. Таким чином, GHCI міг вивести, який тип результату ми бажали від `read`. Якщо ми б використовували це як логічне, він би знав, що треба повертати `Bool`. Але тепер він знає, що ми бажаємо деякий тип, що є частиною класу `Read`, він тільки не знає, який саме. Давайте поглянемо на сигнатуру типу `read`.

[source,haskell]
----
ghci> :t read  
read :: (Read a) => String -> a  
----

Бачите? Він повертає тип, що є частиною `Read`, але якщо ми потім не спробуємо використати його якось далі, немає шляху дізнатись, що саме цей тип. Ось чому ми можемо використовувати явні анотації типів. Анотації типів є шлях явно сказати, яким має бути тип виразу. Ми робимо це, додаючи `::` наприкінці виразу, та потім вказавши тип. Дивіться:

[source,haskell]
----
ghci> read "5" :: Int  
5  
ghci> read "5" :: Float  
5.0  
ghci> (read "5" :: Float) * 4  
20.0  
ghci> read "[1,2,3,4]" :: [Int]  
[1,2,3,4]  
ghci> read "(3, 'a')" :: (Int, Char)  
(3, 'a')  
----

Більшість виразів такі, що компілятор може вивести їх тип самотужки. Але іноді компілятор не знає, чи треба повертати значення типу `Int` або `Float` для виразів як `read "5"`. Щоб побачити, який тип є насправді, Haskell мав би насправді обчислити `read "5"`. Але оскільки Haskell є статично типізованою мовою, він має знати всі типи перед компіляцією кода (або в випадку GHCI, обчисленням). Так що ми маємо сказати Haskell: "Йо, цей вираз має бути такого типу, в випадку якщо ти не знаєш!".

`Enum` члени є послідовно впорядкованими типами — вони можуть бути перелічені. Головна перевага типокласу `Enum` в тому, що ми можемо використовувати його типи як диапазони списків. Вони також мають визначені попередників та послідовників, що ви можете отримати функціями `succ` та `pred`. Типи в цьому класі: `()`, `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float` та `Double`.

[source,haskell]
----
ghci> ['a'..'e']  
"abcde"  
ghci> [LT .. GT]  
[LT,EQ,GT]  
ghci> [3 .. 5]  
[3,4,5]  
ghci> succ 'B'  
'C'  
----

Члени `Bounded` мають верхню та нижню межу.

[source,haskell]
----
ghci> minBound :: Int  
-2147483648  
ghci> maxBound :: Char  
'\1114111'  
ghci> maxBound :: Bool  
True  
ghci> minBound :: Bool  
False  
----

`minBound` та `maxBound` є цікаві, бо вони мають тип `(Bounded a) => a`. В деякому сенсі вони є поліморфними константами.

Всі тапли також є частиною `Bounded`, якщо в ньому також їх компоненти.

[source,haskell]
----
ghci> maxBound :: (Bool, Int, Char)  
(True,2147483647,'\1114111')  
----

`Num` є числовим типокласом. Його члени мають властивість діяти як числа. Давайте дослідимо тип числа.

[source,haskell]
----
ghci> :t 20  
20 :: (Num t) => t  
----

Виглядає так, що цілі числа також є поліморфними константами. Вони можуть діяти як любий тип, що є членом типокласу `Num`.

[source,haskell]
----
ghci> 20 :: Int  
20  
ghci> 20 :: Integer  
20  
ghci> 20 :: Float  
20.0  
ghci> 20 :: Double  
20.0  
----

Це ті типи, що належать до типокласа `Num`. Якщо ми перевіримо тип `*`, ми побачимо, що він приймає всі числа.

[source,haskell]
----
ghci> :t (*)  
(*) :: (Num a) => a -> a -> a  
----

Він приймає всі числа того самого типу, та повертає число того ж типу. Ось чому `(5 :: Int) * (6 :: Integer)` призведе до посилки типу, тоді як `5 * (6 :: Integer)` буде робити досить добре, та спродукує `Integer`, оскільки `5` може діяти як `Integer` або `Int`.

Щоб поєднати `Num`, тип має вже бути друзями з `Show` та `Eq`.

`Integral` є також числовим типокласом. `Num` включає всі числа, включаючи дійсні числа та цілі числа, `Integral` включає тільки цілі числа. В цьому типокласі `Int` та `Integer`.

`Floating` включає тільки числа з плаваючою крапкою, `Float` та `Double`.

Дуже корисна функція для справ з числами є `fromIntegral`. Вона має декларацію типу `fromIntegral :: (Num b, Integral a) => a -> b`. З цієї декларації типів ми бачимо, що він приймає ціле число, та перетворює його в більш загальне число. Це корисно, коли ви бажаєте, щоб цілі та з плаваючою крапкою гарно робили поспіль. Наприклад, функція `length` має декларацію типу `length :: [a] -> Int`, замість мати більш загальний тип `(Num b) => length :: [a] -> b`. Я думаю, це має історичні причини або щось таке, хоча, як до мене, це дурниці. В жодному разі, якщо ви отримаєте довжину списку, та потім додасте її до `3.2`, ми отримаємо помилку, бо ми намагались додати разом `Int` та число з плаваючою крапкою. Щоб уникнути цього ми робимо `fromIntegral (length [1,2,3,4]) + 3.2`, і тоді це буде робити.

Зауважте, що `fromIntegral` має декілька класових обмежень в своїй сигнатурі типу. Це повністю валідне, та як ви можете бачити, обмеження класів відокремлені комами в дужках.