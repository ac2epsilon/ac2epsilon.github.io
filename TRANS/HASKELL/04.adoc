include::header.adoc[]

== Синтаксис в функціях

=== Співпадіння шаблонів

image:images/pattern.png[]
Ця глава дослідить деякі з крутих синтаксичних конструкцій Haskell, і ми почнемо зі співпадіння шаблонів. Співпадіння шаблонів складається з вказання шаблонів, яким мають відповідати деякі дані, та потім перевірити, чи це так, та деконструювати дані відповідно до ціх шаблонів.

Коли визначаєте функції, ви можете визначити окремі тіла функції для різних шаблонів. Це призводить до дійсно милого коду, що простий та читається. Ви можете перевіряти шаблони на кожному типі — числах, символах, списках, таплах, тощо. Давайте зробимо насправді тривіальну функцію, що перевіряє, чи надане нами число сімка, або ні.

[source,haskell]
----
lucky :: (Integral a) => a -> String  
lucky 7 = "LUCKY NUMBER SEVEN!"  
lucky x = "Sorry, you're out of luck, pal!"   
----

Коли ми викликаємо `lucky`, шаблони будуть перевірятись згори донизу, і коли шаблон буде задовільнятись, відповідне тіло буде використовуватись. Єдиний спосіб, як число може задовільніти першому шаблону - якщо це `7`. Якщо ні, керування провалюється до другого шаблону, що співпадає з будь чим, та прикріпляє його до `x`. Ця функція також може бути реалізованою через використання твердження `if`. Але що, коли ми бажаємо функцію, що каже числа від `1` до `5`, та каже "Not between 1 and 5" для любого іншого числа? Без співпадіння шаблоній ми будемо швидко втягнуті в дерево `if then else`. Однак з шаблонами:

[source,haskell]
----
sayMe :: (Integral a) => a -> String  
sayMe 1 = "One!"  
sayMe 2 = "Two!"  
sayMe 3 = "Three!"  
sayMe 4 = "Four!"  
sayMe 5 = "Five!"  
sayMe x = "Not between 1 and 5"  
----

Зауважте, що якщо ми перемістмо останній шаблон (спіймати все) догори, він завжди буде казати "Not between 1 and 5", оскільки він буде ловити всі числа без шансу провалитись, та перевірити всі інші шаблони.

Згадайте функцію факторіала, що ми реалізували до цього? Ми визначали `factorial` числа `n` як добуток `[1..n]`. Ми також можемо визначити функцію факториала рекурсивно, спосіб, що зазвичай використовується в математиці. Ми починаємо, кажучи що факторіал `0` є `1`. Потім ми кажемо, що факторіал любого позитивного цілого є це ціле, помножене на факторіал свого попередника. Ось як це виглядає, перекладене в терміни Haskell.

[source,haskell]
----
factorial :: (Integral a) => a -> a  
factorial 0 = 1  
factorial n = n * factorial (n - 1)  
----

Це перший раз, коли ми визначили функцію рекурсивно. Рекурсія важлива в Haskell, і пізніше ми поглянемо на неї ближче. Але ось що відбувається, коли ми беремо факторіал, скажімо, `3`. Він намагаться обчислити `3 * factorial 2`. Факторіал 2 є `2 * factorial 1`, так що досі ми маємо `3 * (2 * factorial 1)`. `factorial 1` є `1 * factorial 0`, так що ми маємо `3 * (2 * (1 * factorial 0))`. Тепер настає час трюку — ми визначили факторіал `0` як просто `1`, та оскільки це підпадає під той шаблон, що іде до загального випадка, він просто повертає `1`. Так що остаточний результат еквівалентний до `3 * (2 * (1 * 1))`. Якщо б ми написали другий шаблон над першим, він би відловлював всі числа, включаючи 0, і наші обчислення ніколи б не закінчились. Ось чому порядок важливий, коли вкзуєте шаблони, і завжди краще вказувати найбільш специфічні першими, та більш загальні потім.

Співпадіння шаблонів також може схибити. Якщо ми визначимо функцію ось так:

[source,haskell]
----
charName :: Char -> String  
charName 'a' = "Albert"  
charName 'b' = "Broseph"  
charName 'c' = "Cecil"  
----

та потім спробуємо викликати її маючи на вході щось неочікуване, ось що трапиться:

[source,haskell]
----
ghci> charName 'a'  
"Albert"  
ghci> charName 'b'  
"Broseph"  
ghci> charName 'h'  
"*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName  
----

Вона скаржиться, що ми маємо невиключні шаблони, і це так і є насправді. При створенні шаблонів нам слідує завжди включати загальні шаблони, так що наша програма не завалиться, якщо ми отримаємо неочікуваний вхід.

Співпадіння шаблонів також може використовувати тапли. Що, коли ми бажаємо створити функцію, що приймає два вектори в 2D просторі (що є в формі пар), та додає їх разом? Щоб додати разом два вектори, ми додаємо їх `x` компоненти окремо, та потім їх `y` компоненти окремо. Ось що ми можемо зробити, якщо ви не знаємо про співпадіння шаблонів:

[source,haskell]
----
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors a b = (fst a + fst b, snd a + snd b)  
----

Гаразд, це робить, але існує кращий шлях, щоб зробити це. Давайте модифікуємо функцію, так щоб вона використовувала співпадіння шаблонів.

[source,haskell]
----
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  
----

Ось так! Значно краще. Зауважте, що це все ще загальний шаблон. Тип `addVectors` (в обох випадках) є `addVectors :: (Num a) => (a, a) -> (a, a) - > (a, a)`, так що ми гарантовано отримуємо дві пари як параметри.

`fst` та `snd` виділяють компоненти з пар. Але що з трійками? Гаразд, немає готової функції, щоб зробити це, але ми можемо створити власну.

[source,haskell]
----
first :: (a, b, c) -> a  
first (x, _, _) = x  
  
second :: (a, b, c) -> b  
second (_, y, _) = y  
  
third :: (a, b, c) -> c  
third (_, _, z) = z  
----

Знак `_` означає ту саму річ, що він робить в осяжностях списків. Це означає, що насправді нам байдуже, що є в цій частині, так що пи просто пишемо `_`.

Що нагадує мені, що ви також можете робити співпадіння в осяжностях списків. Перевірте це:

[source,haskell]
----
ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]  
ghci> [a+b | (a,b) <- xs]  
[4,7,6,8,11,4]   
----

Коли співпадіння схибить, він буде тільки переходити на наступний елемент.

Самі списки також можуть використовуватись в співпадінні шаблонів. Ви можете порівнювати з порожнім списком `[]`, або любим шаблоном, що включає `:` та порожній список. Але оскільки `[1,2,3]` є тільки синтаксичним цукром для `1:2:3:[]`, ви також можете використовувати і такий шаблон. Шаблон як `x:xs` буде прикріпляти голову списку до `x`, та залишок до `xs`, навіть якщо був один елемент, так що `xs` в кінці буде порожнім списком.

Note: Шаблон `x:xs` багато використовується, особливо з рекурсивними функціями. Але шаблони, що мають в собі `:`, співпадають тільки зі списками довжини 1 або більше.

Якщо ви бажаєте прикріпити, скажімо, перші три елементи до змінних, та залишок до іншої змінної, ви можете використовувати щось подібне до `x:y:z:zs`. Це буде співпадати тільки зі списками, що мають три елементи або більше.

Тепер ми знаємо, як порівнювати шаблони зі списками, давайте створими нашу власну реалізацію функції `head`.

[source,haskell]
----
head' :: [a] -> a  
head' [] = error "Can't call head on an empty list, dummy!"  
head' (x:_) = x  
----

Перевіримо, чи вона робить:

[source,haskell]
----
ghci> head' [4,5,6]  
4  
ghci> head' "Hello"  
'H'  
----

Гарно! Зауважте, що якщо ви бажаєте прикріпити декілька змінних (навіть якщо одна з них просто `_`, та взагалі нічого не прикріплює), ми маємо оточити їх в дужки. Також зауважте функцію `error`, яку ми використовуємо. Вона приймає рядок та генерує помилку часу виконання, використовуючи рядок як інформацію щодо різновиду виникшої помилки. Це призводить до падіння програми, так що недобре використовувати її дуже багато. Але виклик `head` на порожньому списку не має сенсу.

Давайте створимо тривіальну функцію, що каже нам перші елементи списку в зручній англійській формі.

[source,haskell]
----
tell :: (Show a) => [a] -> String  
tell [] = "The list is empty"  
tell (x:[]) = "The list has one element: " ++ show x  
tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y  
tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y  
----

Ця функція безпечна, оскільки вона турбується про порожній список, список синглтон, список з двома елементами, та списки з більше двох елементів. Зауважте, що `(x:[])` та `(x:y:[])` можуть бути переписані як `[x]` та `[x,y]` (завдяки синтаксичному цукру нам не потрібні дужки). Ми не можемо переписати `(x:y:_)` з квадратними дужками, оскільки він співпадає зі списком довжини 2 або більше.

Ми вже реалізовали нашу власну функцію `length` використовуючи осяжність списків. Тепер ми зробимо це, використовуючи співпадіння шаблонів та трохи рекурсії:

[source,haskell]
----
length' :: (Num b) => [a] -> b  
length' [] = 0  
length' (_:xs) = 1 + length' xs  
----

Це подібно до функції `factorial`, що ми писали раніше. Спочатку ми визначили результат для відомого входу — порожнього списку. Це також відомо як гранична умова. Потім в другому шаблоні ми розбиваємо список на частки, відділяючи голову та хвіст. Ми кажемо, що довжина дорівнює 1 плюс довжина хвоста. Ми використовуємо `_` для співпадіння з головою, оскільки нам насправді байдуже, що це. Також зауважте, що ми потурбувались про всі можливі шаблони для списку. Перший шаблон співпадає з порожнім списком, та другий співпадає з будь чим, що не є порожнім списком.

Давайте подивимось, що коли ми викличемо `length'` на `"ham"`. Спочатку ми перевіримо, чи це порожній список, і через те, що це не так, ми провалимось до другого шаблону. Це співпадає з другим шаблоном, і каже, що довжина є `1 + length' "am"`, оскільки ми розбили рядок на голову і хвіст, та відкинули голову. Гаразд. Довжина `length'` від `"am"` подібним чином є `1 + length' "m"`. Так що прямо зараз ми маємо `1 + (1 + length' "m")`. `length' "m"` є `1 + length' ""` (також можна записати як `1 + length' []`). І ми визначили `length' []` як `0`. Так що в кінці ми маємо `1 + (1 + (1 + 0))`.

Давайте реалізуємо `sum`. Ми знаємо, що сума порожнього списку є 0. Запишемо це в вигляді шаблону. І ми також знаємо, що сума списку є голова, плюс сума залишку списку. Коли ми запишемо все це, ми отримаємо:

[source,haskell]
----
sum' :: (Num a) => [a] -> a  
sum' [] = 0  
sum' (x:xs) = x + sum' xs  
----

Також є така річ, що називається `as` шаблонами. Це зручний спосіб розбити щось відповідно до шаблону, та прикріпити частки до імен, при цьому зберігаючи посилання на цілу річ. Ви робите це, покладаючи ім'я та знак `@` перед шаблоном. Наприклад, шаблон `xs@(x:y:ys)`. Цей шаблон буде співпадати точно з тією самою річчю, що і `x:y:ys`, але ви можете просто отримати цілий список через `xs`, замість повторювати себе через повторний набір `x:y:ys` в тілі функції. Ось швидкий та брудний приклад:

[source,haskell]
----
capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x]  
ghci> capital "Dracula"  
"The first letter of Dracula is D"  
----

Звичайно ми використовуємо шаблони щоб уникнути повторення себе, коли порівнення з більшим шаблоном, коли ми використовуємо цілу річ в тілі функції.

Ще одна річ — ви не можете використовувати `++` в співпадіннях шаблонів. Якщо ви спробуєте порівняти шаблон з `(xs ++ ys)`, що буде першим списком, та що буде другим списком? Це не має великого сенсу. Буде мати сенс порівняти з `(xs ++ [x,y,z])` або просто `(xs ++ [x])`, але завдяки природі списків ви не можете зробити цього.

=== Охорона, охорона!

image:images/guards.png[]
В той час, коли шаблони є шляхом переконатись, що значення відповідає деякій формі, та деконструкції, охоронці є шляхом перевірити, чи деяка властивість значення (або декілька з них) є `true` або `false`. Це звучить як твердження `if`, і є дуже подібним. Річ в тому, що охоронці значно легше читаються, коли ви маєте декілька умов, і вони грають добре в команді з шаблонами.

Замість пояснення їх синтаксису, давайте просто зануримось, та створимо функцію з використанням охоронців. Ми збираємось створити просту функцію, що кваліфікує вас відповідно до вашого індексу BMI (body mass index). Ваш BMI дорівнює вашій вазі, поділеній на ваш зріст в квадраті. Якщо ваш BMI менший за 18.5, в вас недостатньо ваги. Якщо ви десь між 18.5 до 25, ви відповідаєте нормі. Від 25 до 30 є надмірною вагою, і більше 30 це ожиріння. Так що ось функція (ми не будемо обчислювати прямо зараз, ця функція обчислює BMI та каже результат):

[source,haskell]
----
bmiTell :: (RealFloat a) => a -> String  
bmiTell bmi  
    | bmi <= 18.5 = "You're underweight, you emo, you!"  
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
    | otherwise   = "You're a whale, congratulations!"  
----

Охоронці позначаються стовпчиками, що слідують за ім'ям функції та її параметрами. Зазвичай вони відступають трохи вправо, та відрівняні між собою. Охоронець в основі є логічний вираз. Якщо він обчислюється до `True`, тоді використовується відповідне тіло функції. Якщо він обчислюється до `False`, перевірка переходить до наступного охоронця і так далі. Якщо ми викличемо цю функцію з 24.3, вона спочатку перевірить, чи це меньше або рівне ніж 18.5. Оскільки це ні, переходимо до наступного охоронця. Перевірка каже, що другій охоронець пропускає, бо 24.3 меньше ніж 25.0, і повертається другий рядок.

Це дуже нагадує велике дерево з `if` `else` в імперативних мовах, тільки це значно краще і гарно читається. Хоча великі дерева `if else` звичайно не схвалюються, іноді проблема виражена в такий дискретний спосіб, що ви не можете це обійти. Охоронці є гарною альтернативою для цього.

Дуже часто останній охоронець є `otherwise`. `otherwise` визначене просто як `otherwise = True`, і відловлює все. Це дуже подібне до шаблонів, тільки вони превірять, чи задовільняє вхід шаблону, а охоронці перевіряють логічні умови. Якщо всі охоронці функції обчислюються до `False` (і ми не надали загального охоронця `otherwise`), обчислення провалюється до наступного шаблону. Ось як шаблони та охоронці гарно грають разом. Якщо не знайдено підходящого охоронця або шаблона закидається помилка.

Звичайно, ми можемо використовувати охоронців з функціями, що приймають так багато параметрів, як нам треба. Замість того, щоб користувач обчислював власний BMI перед викликом функції, давайте модифікуємо цю функцію, так що вона братиме висоту та вагу, та розрахує все за нас.

[source,haskell]
----
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"  
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"  
    | otherwise                 = "You're a whale, congratulations!"  
----

Подивимось, чи я гладкий ...

[source,haskell]
----
ghci> bmiTell 85 1.90  
"You're supposedly normal. Pffft, I bet you're ugly!"  
----

Вау! Я не товстий! Але Haskell все одно назвав мене огидним. Чортзна що!

Зауважте, що немає `=` прямо після імені функції та її параметрами, перед першим охоронцем. Багато новачків отримують синтаксичну помилку, оскільки вони часто ставлять там рівняння.

Інший дуже простий приклад: давайте реалізуєма власну функцію `max`. Якщо ви пам'ятаєте, вона приймає дві речі, що можна порівняти, та повертає більше з них.

[source,haskell]
----
max' :: (Ord a) => a -> a -> a  
max' a b   
    | a > b     = a  
    | otherwise = b  
----

Охоронці можуть бути записані в один рядок, хоча я не раджу цього, оскільки це менш читається, навіть для дуже коротких функцій. Але для демонстрації запишемо `max'` таким чином:

[source,haskell]
----
max' :: (Ord a) => a -> a -> a  
max' a b | a > b = a | otherwise = b  
----

Йо! Не читається взагалі! Рухаємось далі: давайте реалізуємо власну `compare` через використання охоронців.

[source,haskell]
----
myCompare :: (Ord a) => a -> a -> Ordering  
a `myCompare` b  
    | a > b     = GT  
    | a == b    = EQ  
    | otherwise = LT  
ghci> 3 `myCompare` 2  
GT  
----

Note: ми не тільки можемо викликати функції інфіксно з апострофами, ми також можемо визначати їх з апострофами. Іноді так їх легше прочитати.

=== Де!?

В попередньому розділі ми визначили калькулятор BMI таким чином:

[source,haskell]
----
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | weight / height ^ 2 <= 18.5 = "You're underweight, you emo, you!"  
    | weight / height ^ 2 <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
    | weight / height ^ 2 <= 30.0 = "You're fat! Lose some weight, fatty!"  
    | otherwise                   = "You're a whale, congratulations!"  
----

Зауважте, що ми повторили себе тут три рази поспіль. Ми повторили себе три рази. Повторити себе (три рази) при програмуванні так само бажано, як вдаритись головою. Оскільки ми повторили вираз три рази, було б ідеальним, щоб ми могли обчислити його один раз, прікріпити до імені, і потім використовувати це ім'я замість виразу. Гаразд, ми можемо модифікувати нашу функцію таким чином:

[source,haskell]
----
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | bmi <= 18.5 = "You're underweight, you emo, you!"  
    | bmi <= 25.0 = "You're supposedly normal. Pffft, I bet you're ugly!"  
    | bmi <= 30.0 = "You're fat! Lose some weight, fatty!"  
    | otherwise   = "You're a whale, congratulations!"  
    where bmi = weight / height ^ 2  
----

Ми поклали ключове слово `where` після охоронців (зазвичай краще відступити так само, як здвинуті риски), та потім ми визначаємо декікька імен або функцій. Ці імена видимі в охоронцях, та дають нам перевагу не мати повторювати самих себе. Якщо ми вирішимо, що треба обчислювати BMI трохи інакше, ми маємо змінити це тільки один раз.  Це також покращує читабельність, надаючи імена речам, і може зробити наші програми видшими, оскільки такі речі, як наша змінна `bmi`, обчислюються тільки один раз. Ми можемо піти трохи далі, та представити нашу функцію таким чином:

[source,haskell]
----
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | bmi <= skinny = "You're underweight, you emo, you!"  
    | bmi <= normal = "You're supposedly normal. Pffft, I bet you're ugly!"  
    | bmi <= fat    = "You're fat! Lose some weight, fatty!"  
    | otherwise     = "You're a whale, congratulations!"  
    where bmi = weight / height ^ 2  
          skinny = 18.5  
          normal = 25.0  
          fat = 30.0  
----

Імена, які ми визначили в розділі `where` функції, видимі тількі в цій функції, так що ми не маємо турбуватись щодо забруднення простору імен інших функцій. Зауважте, що всі ці імена вирівнені в один стовпчик. Якщо ми не вирівняємо їх гарно і відповідно, Haskell буде засмучений, оскільки він не знатиме, що все це частини одного блоку.

Прикріплення `where` не поділяються між тілами функцій для різних шаблонів. Якщо ви бажаєте, щоб декілька шаблонів однієї функції мали доступ до одного імені, ви маєте визначити його глобально.

Ви також можете використовувати прикріплення `where` до порівняння шаблонів! Ви можете переписати розділ `where` попередньої функції таким чином:

[source,haskell]
----
...  
where bmi = weight / height ^ 2  
      (skinny, normal, fat) = (18.5, 25.0, 30.0)  
----

Давайте створимо іншу, досить тривіальну функці, де ми отримуємо перше та останнє ім'я, та повертаємо ініціали.

[source,haskell]
----
initials :: String -> String -> String  
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
    where (f:_) = firstname  
          (l:_) = lastname    
----

Ми можемо виконати це співпадіння шаблонів прямо в параметрах функції (вона насправді може бути коротшою та яснішою), але це показує тільки те, що це можливо зробити також в прикріпленнях `where`.

Так само, як ми визначали константи в блоках `where`, ви також можете визначити функції. Дотримуючись нашої здорової теми програмування, давайте створимо функцію, що приймає список пар вага-висота, та повертає список BMI.

[source,haskell]
----
calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
calcBmis xs = [bmi w h | (w, h) <- xs]  
    where bmi weight height = weight / height ^ 2  
----

Ось і все, що ми мали сказати про це! Причина, з якої ми мали ввести  `bmi` як функцію в цьому прикладі, це те, що ми не можемо обчислити один BMI з параметрів функції. Ми маємо перевіряти список, переданий до функції, і тут буде різний BMI для кожної пари.

`where` прикріплення також можуть бути вкладені. Це загальна ідіома, створити функцію, і визначити допоміжну функцію в її твердженні `where`, і потім надати цім функціям допоміжні функції, також, кожна в своєму власному твердженні `where`.

=== Let it be

Дуже подібні до `where` прикріалень є прикріплення `let`. `Where` прикріплення є синтаксичною конструкцією, що дозволяє вам прикріпляти змінні в кінці функції, та ціла функція може бачити їх, включаючи всіх охоронців. `Let` прикріплення дозволяють вам прикріпляти змінні будь де, та самі є виразами, але є дуже локальними, так що вони не поширюються серед охоронців. Так само, як любі конструкції в Haskell, що використовуються для прикріплення значень до імен, `let` прикріплення можуть використовуватись для співпадінь шаблонів. Давайте подивимось на це дії! Ось як ви можете визначити функцію, що дає нам площу циліндричної поверхні, базуючись на її висоті та радіусі: 

[source,haskell]
----
cylinder :: (RealFloat a) => a -> a -> a  
cylinder r h = 
    let sideArea = 2 * pi * r * h  
        topArea = pi * r ^2  
    in  sideArea + 2 * topArea  
----

image:images/letitbe.png[]
Форма є `let <bindings> in <expression>`. Імена дає вам визначити в частині `let` доступною до виразу в частині `in`. Як ви можете бачити, ви можете також виразити це як `where` прив'язку. Зауважте, що імена також вирівняні в один стовпчик. То яка різниця між ціма двома? На тепер виглядає, що `let` покладає прикріплення першими, та вираз, що використовує їх після, тоді як `where` робить це навпаки.

Різниця в тому, що `let` прикріплення самі є виразами. `where` прикріалення є тільки синтаксичніми конструкціями. Згадайте, як ми робили твердження `if`, та пояснювали, що твердження `if else` є виразом, і ви можете набивати його маже будь де?

[source,haskell]
----
ghci> [if 5 > 3 then "Woo" else "Boo", if 'a' > 'b' then "Foo" else "Bar"]  
["Woo", "Bar"]  
ghci> 4 * (if 10 > 5 then 10 else 0) + 2  
42  
----

Ви також можете робити це за допомогою `let` прикріплень.

[source,haskell]
----
ghci> 4 * (let a = 9 in a + 1) + 2  
42  
----

Вони також можуть бути використані для введення функцій в локальному полі зору:

[source,haskell]
----
ghci> [let square x = x * x in (square 5, square 3, square 2)]  
[(25,9,4)]  
----

Якщо ми бажаємо прикріпити декілька змінних разом, ми, вочевидь, не можемо вирівняти їх в вигляді стовпчика. Ось чому ми можемо розділити крапками з комою.

[source,haskell]
----
ghci> (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)  
(6000000,"Hey there!")  
----

Ви не маєте ставити крапку з комою після останнього прикріплення, але ви можете це зробити, якщо бажаєте. Як ми казали раніше, ви можете робити порівняння шаблонів з `let` прикріпленнями. Вони дуже корисні для швидкого розбирання тапла на компоненти, та прикріплення їх до імен, або чогось подібного.

[source,haskell]
----
ghci> (let (a,b,c) = (1,2,3) in a+b+c) * 100  
600  
----

Ви також можете покласти `let` прикріплення в осяжності списків. Давайте перепишемо наші попередні приклади обчислення списків пар ваги-висоти, щоб використовувати `let` в осяжності списків, замість визначення зовнішньої функції за допомогою `where`.

[source,haskell]
----
calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2]  
----

Ми включили `let` в осяжність списків, майже так само як предикат, але він не фільтрує список, але тільки прив'язує імена. Імена, визначені в `let` всередині осяжності списків, видимий для функції виводу (частина перед `|`), та всі предикати та розділи, що ідуть після прикріплення. Так що ви можете зробити, щоб функція повертала тільки BMI для товстих людей:

[source,haskell]
----
calcBmis :: (RealFloat a) => [(a, a)] -> [a]  
calcBmis xs = [bmi | (w, h) <- xs, let bmi = w / h ^ 2, bmi >= 25.0]  
----

Ми не можемо використовувати ім'я `bmi` в частині `(w, h) <- xs`, оскільки вона визначена перед прикріпленням `let`.

Ми оминули частину `in` прикріалення `let`, коли ми використовуємо їх в осяжностях списків, оскільки видимість імен тут завжди передвизначена. Однак ми можемо використовувати `let` в прикріпленні в предикаті, та визначені імена будуть видимі тільки в ціх предикатах. Частину `in` також можна оминути при визначенні функцій і констант прямо в GHCi. Якщо ми зробимо це, імена будуть видимі на протязі цілої інтерактивної сессії.

[source,haskell]
----
ghci> let zoot x y z = x * y + z  
ghci> zoot 3 9 2  
29  
ghci> let boot x y z = x * y + z in boot 3 4 2  
14  
ghci> boot  
<interactive>:1:0: Not in scope: `boot'  
----

Якщо `let` прикріплення такі круті, ви можете запитати, чому не використовувати їх весь час замість прикріплень `where`? Гаразд, оскільки `let` прикріплення є виразами та досить локальні в плані видимості, вони не можуть використовуватись серед охоронців. Деякі люди обирають `where` прикріалення, оскільки імена ідуть після функції, де вони використовуються. Таким чином, тіло функції ближче до його імені та його типу, і для декого це краще читати.

=== Case вирази

image:images/case.png[]
Багато імперативних мов (C, C++, Java, etc.) мають `case` синтаксис, і якщо ви колись програмували на них, ви можливо знаєте про що іде мова. Береться змінна, та потім виконуються блоки коду для специфічних значень цієї змінної, і можливо включає блок спіймати-всіх на випадок, коли змінна має значення, для якого ми не встановили `case`.

Haskell приймає цю концепцію і покращує її. Як підказує ім'я, `case` вирази є, гаразд, виразами, подібно до `if else` виразів та `let` прикріплень. Ми не тільки можемо обчислювати вирази на основі можливих варіантів змінної, ми також можемо робити співпадіння шаблонів. Хммм, беремо змінну, порівнюємо її з шаблоном, обчислюємо частини коду на основі цього значення, де ми вже це бачили? Так, порівняння шаблонів на параметрах в визначеннях функції! Гаразд, це тільки синтаксичний цукор для `case`. Ці дві частини коду роблять те саме, і взаємозамінні:

[source,haskell]
----
head' :: [a] -> a  
head' [] = error "No head for empty lists!"  
head' (x:_) = x  
head' :: [a] -> a  
head' xs = case xs of [] -> error "No head for empty lists!"  
                      (x:_) -> x  
----

Як ви можете бачити, синтаксис для `case` виразів є доволі простий:

[source,haskell]
----
case expression of pattern -> result  
                   pattern -> result  
                   pattern -> result  
                   ...  
----

`expression` порівнюється відносно `pattern`-ів. Порівняння шаблонів діє як очікується: перший шаблон, що співпадає з виразом, буде використаний. Якщо це провалюється через вираз `case`, і підходящого шаблону не знайдено, виникає помилка часу виконання.

Хоча співпадіння на параметрах функцій може виконуватись тільки при визначенні функції, `case` вирази можуть бути використані майже будь де. Наприклад:

[source,haskell]
----
describeList :: [a] -> String  
describeList xs = "The list is " ++ case xs of [] -> "empty."  
[x] -> "a singleton list."   
xs -> "a longer list."  
----

Вони корисні для порівняння шаблонів з чимось всередині виразу. Оскільки співпадіння шаблонів в функції є синтаксичним цукром для `case` виразів, ми можемо також визначити це таким чином:

[source,haskell]
----
describeList :: [a] -> String  
describeList xs = "The list is " ++ what xs  
    where what [] = "empty."  
          what [x] = "a singleton list."  
          what xs = "a longer list."  
----
