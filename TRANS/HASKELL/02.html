<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">На старт, пішли!</h2>
<div class="sectionbody">
<div class="paragraph"><p><span class="image">
<img src="images/startingout.png" alt="images/startingout.png" />
</span>
Гаразд, давайте розпочнемо! Якщо ви з тих жахливих людей, що не читають інструкцій до речей, і пропускаєте їх, в жодному разі ви маєте прочитати останній розділ зі вступу, оскільки він пояснює, що вам треба, щоб слідувати цьому туторіалу, і як ми збираємось завантажувати функції. Перша річ, що ми збираємось зробити, це виконати <code>ghc</code> в інтерактивному режимі, та викликати деякі функції, щоб отримати дуже базове відчуття <code>haskell</code>. Відкрийте ваш термінал та наберіть <code>ghci</code>. Ви отримаєте привітання, подібне до наступного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">GHCi</span><span class="p">,</span> <span class="n">version</span> <span class="mf">6.8</span><span class="o">.</span><span class="mi">2</span><span class="kt">:</span> <span class="n">http</span><span class="kt">://</span><span class="n">www</span><span class="o">.</span><span class="n">haskell</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">ghc</span><span class="o">/</span>  <span class="kt">:?</span> <span class="n">for</span> <span class="n">help</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">base</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Prelude</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вітаємо, ви в GHCI! Тут підказка <code>Prelude&gt;</code>, але оскільки вона може стати довшою коли ви завантажите дещо в сессії, ми збираємось використовувати <code>ghci&gt;</code>. Якщо ви бажаєте мати таку саму підказку, просто наберіть <code>:set prompt "ghci&gt; "</code>.</p></div>
<div class="paragraph"><p>Ось деяка проста арифметика.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">15</span>
<span class="mi">17</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">49</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">4900</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1892</span> <span class="o">-</span> <span class="mi">1472</span>
<span class="mi">420</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">2.5</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить пояснює себе. Ми також можемо використовувати декілька операторів в одному рядку, і вони будуть підкорюватись звичайним правилам преоритетів. Ми можемо використовувати дужки, щоб зробити преоритети явними, або щоб змінити їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span><span class="p">)</span>
<span class="o">-</span><span class="mi">244950</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить круто, чи не так? Так, я знаю що ні, але повірте мені. Невелика пастка тут - подивитись як змінюється знак чисел. Якщо ви бажаєте мати від'ємне число, завжди краще оточити його в дужки. робити <code>5 * -3</code> змусить GHCI скаржитись на вас, але якщо зробити <code>5 * (-3)</code>, це буде робити добре.</p></div>
<div class="paragraph"><p>Логічна алгебра також досить прямолінійна. Як ви ,вірогідно, знаєте, <code>&amp;&amp;</code> позначає логічне <code>AND</code>, <code>||</code> позначає логічне <code>OR</code>. <code>not</code> обертає <code>True</code> або <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевірка на рівність робиться так.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">4</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо зробити  <code>5 + "llama"</code> або <code>5 == True</code>? Гаразд, якщо ми спробуємо перший фрагмент, ми отримаємо велике і жахливе повідомлення про помилку!</p></div>
<div class="listingblock">
<div class="content">
<pre><code>No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"</code></pre>
</div></div>
<div class="paragraph"><p>Такої! Що тут GHCI каже нам, це те, що <code>"llama"</code> не є числом, і так він не знає, як додати його до <code>5</code>. Навіть якщо це б було не <code>"llama"</code>, а <code>"four"</code> або <code>"4"</code>, Haskell все одно не може дійти висновку, що це число. <code>+</code> очікує, що зправа та зліва від нього числа. Якщо ви спробуєте зробити <code>True == 5</code>, GHCI скаже нам, що типи не співпадають. Хоча <code>+</code> робить тільки на речах, що розглядаються як числа, <code>==</code> робить на любих двох речах, що можна порівняти. Але зачіпка в тому, що вони обоє мають бути одним типом речей. Ви не можете порівняти яблука та помаранчі. Ми зробимо ближчий погляд на типи пізніше. Зауваження: ви можете робити <code>5 + 4.0</code>, оскільки <code>5</code> хитра, і може діяти як ціле або число з плаваючою крапкою. <code>4.0</code> не може діяти як ціле, так що <code>5</code> єдине, що має пристосовуватись.</p></div>
<div class="paragraph"><p>Можиливо ви не знали це, але ми використовували функції весь цей час. Наприклад, <code>*</code> є функцією, що приймає два числа, та перемножує їх. Як ви бачили, ми використовували її, утворивши сендвіч з них. Це те, що ми називаємо інфіксною функцією. Більшість функцій, що не використовуються з числами, є префіксні функції. Давайте поглянемо на них.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/phoen.png" alt="images/phoen.png" />
</span>
Функції звичайно ідуть як префікс, такщо від тепер ми не будемо явно вказувати, що функція має префіксну форму, ми будемо просто вважати що це так. В багатьої імперативних мовах функції викликаються через запис імені функції, та потім її параметри в дужках, звичайно розділені комами. В Haskell функції викликаються записом ім'я функції, проміжок, і розділені проміжками параметри. Для початку ми спробуємо викликати одну зі скучніших функцій в Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">8</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>succ</code> приймає будь-що, що має визначений наступний, та повертає це наступне. Як ви можете бачити, ми просто відділили ім'я функції від параметра проміжком. Виклик функції з декількома параметрами також просте. Функції <code>min</code> та <code>max</code> приймають дві речі, що можуть бути впорядковані (як числа!). <code>min</code> повертає те, що меньше, та <code>max</code> повертає те, що більше. Дивіться самі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mf">3.4</span> <span class="mf">3.2</span>
<span class="mf">3.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">100</span> <span class="mi">101</span>
<span class="mi">101</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосування функції (виклик функції через покладання проміжку пісня неї, та потім набір параметрів) має найвищий преоритет з них усіх. Це означає, що наступні два твердження еквівалентні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">succ</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ми бажаємо отримати наступний до добутку чисел <code>9</code> та <code>10</code>, ми не можемо записати  <code>succ 9 * 10</code>, оскільки це отримання послідовника для <code>9</code>, що потім буде помножений на <code>10</code>. Тобто <code>100</code>. Ми маємо писати <code>succ (9 * 10)</code> щоб отримати <code>91</code>.</p></div>
<div class="paragraph"><p>Якщо функція прийма два параметри, ми також можемо викликати її як інфіксну функцію, оточивши її зворотніми апострофами. Наприклад, функція <code>div</code> приймає два цілі, та робить ціле ділення першого на друге. Обчислення <code>div 92 10</code> дає результат <code>9</code>. Але коли ми викликаємо її таким чином, може бути деякий сумнів, яке число є чисельник і яке займенник. Так що ми можемо викликати її як інфіксну функцію, зробивши <code>92 ``div`</code> 10`, і миттєво все стає зрозуміло.</p></div>
<div class="paragraph"><p>Багато людей, які прийшли з імперативних мов, маю схильність приставати на нотацію, де дужки мають позначати застосування функції. Наприклад в C ви виокристовуєте дужки для виклику функції, як <code>foo()</code>, <code>bar(1)</code> або <code>baz(3, "haha")</code>. Як ми казали, в Haskell для застосування функції ми використовуємо дужки. Так що ці функції в Haskell будуть <code>foo</code>, <code>bar 1</code> та <code>baz 3 "haha"</code>. Так що якщо ви бачите що подібне до <code>bar (bar 3)</code>, це не означає, що <code>bar</code> викликається з <code>bar</code> та <code>3</code> в якості параметрів. Це означає, що спочатку ми викликаємо <code>bar</code> з <code>3</code> в якості параметра, щоб отримати якесь число, та потім ми викликаємо <code>bar</code> знову з цім числом. В C це буде щось подібне до <code>bar(bar(3))</code>.</p></div>
<div class="sect2">
<h3 id="____2">Перша функції дитини</h3>
<div class="paragraph"><p>В попередньому розділі ми отримали базове відчуття щодо виклику функцій. Тепер давайте спробуємо створити свої власні! Відкрийте ваш улюблений текстовий редактор, і видайте таку функцію, що приймає число та множить його на два.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції визначають в спосіб, подібний до їх виклику. Ім'я функції іде перед параметрами, розділені проміжками. Але коли функція визначається, існує знак <code>=</code> , та після нього визначення того, що робить функція. Збережіть це як <code>baby.hs</code> або будь-як інакше. Тепер перейдіть туди, де ви збереглись, і запустіть там <code>ghci</code>. Всередині  GHCI зробіть <code>:l baby</code>. Тепер, коли наш скрипт завантажений, ми можемо гратись з функцією, яку ми визначили.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">baby</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">baby</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mi">9</span>
<span class="mi">18</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mf">8.3</span>
<span class="mf">16.6</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>+</code> робить на цілих, так само як і на числах з плаваючою крапкою (насправді на будь-чому, що може розглядатись як число), наша функція також може робити з любими числами. Давайте зробимо функцію, що приймає два числа, та перемножує їх на два, і потім складає результати разом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Просто. Ми також могли визначити це як <code>doubleUs x y = x + x + y + y</code>. Тестування продукує досить передбачувані результати (пам'ятайте додати цю функцію до файлу  <code>baby.hs</code>, збережіть його, та потім зробіть <code>:l baby</code> в GHCI).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">4</span> <span class="mi">9</span>
<span class="mi">26</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mf">2.3</span> <span class="mf">34.2</span>
<span class="mf">73.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">28</span> <span class="mi">88</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="mi">123</span>
<span class="mi">478</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, ви можете викликати ваші власні функції з інших функцій, які ви створили. Маючи це на увазі, ви можете перевизначити <code>doubleUs</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">doubleMe</span> <span class="n">x</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дуже простий приклад загального шаблону, що ви бачитимете повсякчас в Haskell. Створення простих функцій, що вочевидь коректні, та потім комбінування їх в більш складні функції. Таким чином ви також уникаєте повторень. Що, коли деякий математик дійде висновку, що <code>2</code> насправді <code>3</code>, і ви маєте змінити програму? Ви можете просто перевизначити <code>doubleMe</code> як <code>x + x + x</code>, і оскільки <code>doubleUs</code> викликає <code>doubleMe</code>, вона також буде автоматично робити в цьому дивному світі, де <code>2</code> є <code>3</code>.</p></div>
<div class="paragraph"><p>Функції в Haskell не мають іти в якомусь певному порядку, так що не має значення, якщо ви визначите <code>doubleMe</code> спочатку, та потім <code>doubleUs</code>, або ви зробите це навпаки.</p></div>
<div class="paragraph"><p>Тепер ми збираємось створити функцію, що множить число на <code>2</code>, але тільки якщо число меньше або рівне <code>100</code>, бо числа більше ніж <code>100</code> досить великі як вони є!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
                        <span class="kr">then</span> <span class="n">x</span>
                        <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/baby.png" alt="images/baby.png" />
</span>
Прямо зараз ми ввели Haskell твердження <code>if</code>. Ви, можливо, знайомі з <code>if</code> твердженнями в інших мовах. Різниця між Haskell твердженням <code>if</code>, та твердженнями <code>if</code> в імперативних мовах в тому, що частина <code>else</code> обов'язкова в Haskell. В імперативних мовах ви можете просто пропустити пару кроків, якщо умова не задовільняється, але в Haskell кожний вираз та функція має щось повертати. Ми можемо також записати твердження <code>if</code> в один рядок, але я вважаю цей спосіб значно читабельніше. Інша річ щодо твердження <code>if</code> в Haskell в тому, що це вираз. Вираз загалом це шматок коду, що повертає значення. <code>5</code> є виразом, бо воно повертає <code>5</code>, <code>4 + 8</code> також вираз, <code>x + y</code> також вираз, бо він повертає суму <code>x</code> та <code>y</code>. Оскільки <code>else</code> обов'язкове, твердження <code>if</code> буде завжди  щось повертати, і ось чому це також вираз. Якщо ми бажаємо додавати одиницю до кожного числа, що спродуковане в нашій попередній функції, ми маємо записати тіло таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми б пропустили дужки, воно додавало одиницю тільки якщо <code>x</code> не було б більше <code>100</code>. Зауважте <code>'</code> наприкінці імені функції. Цей апостроф не має жодного спеціального значення в синтаксисі Haskell. Це валідний символ для використання в іменах функцій. Ми зазвичай використовуємо <code>'</code> для позначення суворої версії функції (що не є лінива), або трохи модифікованої версії функції або змінної. Оскільки <code>'</code> валідний символ в функціях, ми можемо зробити функцію таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">conanO&#39;Brien</span> <span class="ow">=</span> <span class="s">&quot;It&#39;s a-me, Conan O&#39;Brien!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут дві речі, варті уваги. Перша в тому, що в назві функції ми не пишемо ім'я Конана з великої литери. Це тому, що функції не можуть починатись з великої літери. Пізніше ми побачимо чому. Друга річ в тому, що ця функція не приймає жодних параметрів. Коли функція не приймає жодних параметрів, ми кажемо що це визначення (або ім'я). Оскільки ми не можемо змінити те, що імена (та функції) означають після того, як ми їх визначили, <code>conanO'Brien</code> та рядок <code>"It's a-me, Conan O'Brien!"</code> можна використовувати взаємозамінно.</p></div>
</div>
<div class="sect2">
<h3 id="____3">Вступ до списків</h3>
<div class="paragraph"><p><span class="image">
<img src="images/list.png" alt="images/list.png" />
</span>
Здебільшого так само, як списки покупок в реальному світі, списки в Haskell дуже корисні. Це найбільш використовувана структура даних, і вона може бути використана в безлічі різних способів, щоб моделювати та вирішувати цілу кіпу проблем. Списки ТАКІ неймовірні. В цьому розділі ми побачимо на основи списків, рядкі (що є списками) та осяжність списків.</p></div>
<div class="paragraph"><p>В Haskell списки є гомогенними структурами даних. Вони зберігають декілька елементів одного типу. Це означає, що ми можемо мати список цілих та список символів, але ми не можемо мати список, що має трохи цілих, та трохи символів. І тепер - список!</p></div>
<div class="paragraph"><p>Note: Ми можемо використовувати ключове слово <code>let</code> для визначення імені прямо в GHCI. Зробити <code>let a = 1</code> в GHCI еквівалентно до написання <code>a = 1</code> в скрипті, та потім його завантаження.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">lostNumbers</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lostNumbers</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, списки позначаються квадратними дужками, та значення в списках розділяються комами. Якщо ми спробуємо список <code>[1,2,'a',3,'b','c',4]</code>, Haskell буде скаржитись, що символи (що, проміж іншого, позначаються символами в поодиноких лапках) не є числами. Кажучи про символи, рядки є тільки списками символів. <code>"hello"</code> є тільки синтаксичним цукром для <code>['h','e','l','l','o']</code>. Оскільки рядки є списками, ми можемо використовувати функції для спискив з рядками, що дійсно зручно.</p></div>
<div class="paragraph"><p>Загальна задача є складання двох списків разом. Це робиться за допомогою оператора <code>++</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="s">&quot;world&quot;</span>
<span class="s">&quot;hello world&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;w&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">]</span>
<span class="s">&quot;woot&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Пильнуйте, коли постійно використовуєте оператор <code>++</code> на довгих рядках. Коли ми складаємо разом два списки (навіть якщо ми додаємо синглтон список до списку, наприклад: <code>[1,2,3] ++ [4]</code>), внутрішньо Haskell має пройти по всьому списку злівого боку від <code>++</code>. Це не проблема, коли маємо справи зі списками, що не дуже великі. Але покладання дечого в кінець списку, що має п'ядесят мільйонів елементів в довжину таки займе деякий ча. Однак покладання дечого на початок списку з використанням оператора <code>:</code> (також називається <code>cons</code> оператором) є миттєвим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;A&#39;</span><span class="kt">:</span><span class="s">&quot; SMALL CAT&quot;</span>
<span class="s">&quot;A SMALL CAT&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, як <code>:</code> приймає число і список чисел, або символ та список символів, тоді як <code>++</code> приймає два списки. Навіть якщо ви додаєте один елемент в кінець списку за допомогою <code>++</code>, ви маєте оточити його в квадратні дужки, так щоб він став списком.</p></div>
<div class="paragraph"><p><code>[1,2,3]</code> насправді є тільки синтаксичним цукром для <code>1:2:3:[]</code>. <code>[]</code> це порожній список. Якщо перед ним добавити <code>3</code> це перетвориться на <code>[3]</code>. Якщо перед цім поставити <code>2</code>, стане <code>[2,3]</code>, і так далі.</p></div>
<div class="paragraph"><p>Note: <code>[]</code>, <code>[[]]</code> та <code>[[],[],[]]</code> все різні речі. Перше це порожній список, друге це список, що містить один порожній список, третій список містить три порожні списки.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте отримати елемент зі списку по індексу, використовуйте <code>!!</code>. Індекси починаються з <code>0</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Steve Buscemi&quot;</span> <span class="o">!!</span> <span class="mi">6</span>
<span class="sc">&#39;B&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">9.4</span><span class="p">,</span><span class="mf">33.2</span><span class="p">,</span><span class="mf">96.2</span><span class="p">,</span><span class="mf">11.2</span><span class="p">,</span><span class="mf">23.25</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">1</span>
<span class="mf">33.2</span>
</pre></div></div></div>
<div class="paragraph"><p>Але якщо ви намагатиметесь отримати шостий елемент зі списку, що має тільки чотири елементи, ви отримаєте помилку, так що будьте уважні!</p></div>
<div class="paragraph"><p>Списки також можуть містити списки. Вони також можуть містити списки, що містять списки, що містять списки …</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">++</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="kt">:</span><span class="n">b</span>
<span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки в списку можуть бути різної довжини, але вони не можуть бути різних типів. Так само, як ви не можете мати список, що містить деякі числаі деяки символи, ви не можете мати деякі списки з символами, і деякі списки з числами.</p></div>
<div class="paragraph"><p>Списки можливо порівняти, якщо те, що вони містять, може бути порівняно. Коли використовуються <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> та <code>&gt;=</code> для порівняння списків, вони порівнюються в лексографічному порядку. Спочатку порівнюються голови. Якщо вони рівні, порівнюються другі елементи, і так далі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Що ще можна робити зі списками? Ось деякі базові функції, що оперують на списках.</p></div>
<div class="paragraph"><p><code>head</code> бере список, та повертає його голову. Голова списку це його перший елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>tail</code> бере список, та повертає його хвіст. Іншими словами вона відрубає йому голову.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>last</code> бере список, та повертає останній елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p><code>init</code> бере список, та повератє все, крім останнього елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">init</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви вважаєте, що список це монстр, тоді вам сподобається таке.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/listmonster.png" alt="images/listmonster.png" />
</div>
</div>
<div class="paragraph"><p>Але що трапиться, якщо ми спробуємо отримати голову порожнього списку?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">head</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
</pre></div></div></div>
<div class="paragraph"><p>Матінко рідна! Все це вибухнуло нам у лице! Якщо немає монстра, в нього немає голови. Коли використовуєте <code>head</code>, <code>tail</code>, <code>last</code> та <code>init</code>, будьте уважні не використовувати їх на порожніх списках. Ця помилка не може бути перехоплена під час компіляції, так що завжди гарна практика докласти перестороги супроти випадкового прохання до Haskell отримати елементи з порожнього списку.</p></div>
<div class="paragraph"><p><code>length</code> бере список, та повертає його довжину, очевидно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи список порожній. Якщо це так, він повертає <code>True</code>, інакше <code>False</code>. Використовуйте цю функцію замість <code>xs == []</code> (якщо ви маєте список з назвою <code>xs</code>)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>reverse</code> обертає список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>take</code> бере число і список. Він виділяє таку кількість з початку списка. Дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите, якщо ми намагаємось взяти більше елементів, ніє є в списку, він просто повертає список. Якщо ми намагаємось взяти <code>0</code> повертається порожній список.</p></div>
<div class="paragraph"><p><code>drop</code> робить подібним чином, тільки він відкидає число елементів з початку списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>maximum</code> бере список дечого, що може бути впорядковане, і повертає найбільший елемент.</p></div>
<div class="paragraph"><p><code>minimum</code> повертає найменьший.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p><code>sum</code> бере список чисел, та повертає його суму.</p></div>
<div class="paragraph"><p><code>product</code> бере список чисел, та повертає його добуток.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">31</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">24</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elem</code> бере річ та список речей, та каже нам, чи є такий елемент в списку. Це звичайно викликається як інфіксна функція, оскільки так воно краще читається.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Це були декілька базових функцій, що оперують на списках. Ми побачимо більше спискових функцій пізніше.</p></div>
</div>
<div class="sect2">
<h3 id="__">Техаські ренджі</h3>
<div class="paragraph"><p><span class="image">
<img src="images/cowboy.png" alt="images/cowboy.png" />
</span>
Що, коли ми бажаємо перелічити всі числа від 1 до 20? Звичайно, ми можемо просто надрукувати їх всі разом, але вочевидь це не рішення для джентельмена, що вимагає досконалості від своїх мов програмування. Замість цього ми використовуємо диапазони. Диапазони - це спосіб створювати списки, що є арифметичними послідовностями елементів, що можуть бути перелічені. Числа можуть бути перелічені. Один, два, три, чотири, тощо. Символи можути бути перелічені. Абетка є перелік літер від <code>A</code> до <code>Z</code>. Імена не можуть бути перелічені. Що іде після <code>"John"</code>? Я не знаю.</p></div>
<div class="paragraph"><p>Щоб зробити список, що містить всі натуральні числа від 1 до 20 ви можете записати<code>[1..20]</code>. Це еквівалентно до написання <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>, і немає різниці між написанням одного чи іншого, за винятком того, що написання довгих послідовностей переліку вручну є дурнею.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;K&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]</span>
<span class="s">&quot;KLMNOPQRSTUVWXYZ&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони круті, оскільки ви можете задати крок. Що, якщо ми бажаємо всі парні числа між 1 та 20? Або навіть тожне третє між 1 та 20?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це просто справа розділення перших двох елементів комою, та потім вказати вищий ліміт. Хоча це досить розумне, диапазони з кроками не такі розумні, ніє деяки люди бажали б їх бачити. Ви не можете зробити <code>[1,2,4,8,16..100]</code>, та очікувати отримання всіх ступеней <code>2</code>. Для початку тому що ви можете вказати один крок. Та подруге через те, що деякі неарифметичні послідовності неоднозначні, якщо задати тільки декілька з перших членів послідовності.</p></div>
<div class="paragraph"><p>Щоб зробити список з усіх чисел від 20 до 1, ви не можете записати тільки <code>[20..1]</code>, ви маєте зробити <code>[20,19..1]</code>.</p></div>
<div class="paragraph"><p>Слідкуйте за використанням чисел з плаваючою крапкою в диапазонах! Завдяки тому, що вони не повністю точні (по визначенню), їх використання може дати деякі досить дивні результаті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.8999999999999999</span><span class="p">,</span><span class="mf">1.0999999999999999</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Моя порада не використовувати їх в спискових диапазонах.</p></div>
<div class="paragraph"><p>Ви також можете використовувати диапазони для створення безкінечних списків, просто не задаючи верню межу. Пізніше ми дійдемо до більших деталей щодо безкінечних списків. Тепер давайте перевіримо, як ви можете отримати перші <code>24</code> добутки числа <code>13</code>. Звичайно, ви можете зробити <code>[13,26..24*13]</code>. Але є кращий шлях: <code>take 24 [13,26..]</code>. Оскільки Haskell лінивий, він не буде намагатись обчислити безкінечний список безпосередньо, бо це ніколи не скінчиться. Він буде чекати, що ви бажаєте отримати з цього безкінечного списку. І тут він бачить, що ви бажаєте отримати лише перші <code>24</code> елементи, на що він легко погоджується.</p></div>
<div class="paragraph"><p>Декілька фунцій, що продукують безкінечні списки:</p></div>
<div class="paragraph"><p><code>cycle</code> бере список, та в циклі перетворює його в безкінечний список. Якщо ви спробуєте тільки отримати результат, це триматиме вічність, тому ви маєте перерватись десь.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">12</span> <span class="p">(</span><span class="n">cycle</span> <span class="s">&quot;LOL &quot;</span><span class="p">)</span>
<span class="s">&quot;LOL LOL LOL &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>repeat</code> бере елемент, та продукує безкінечний список тільки з цього елемента. Це як цикл по списку тільки з одного елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це простіше просто використовувати фуункцію <code>replicate</code>, якщо ви бажаєте деяке число одного елемента в списку. <code>replicate 3 10</code> повертає <code>[10,10,10]</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____4">Я - породжуючий списки</h3>
<div class="paragraph"><p><span class="image">
<img src="images/kermit.png" alt="images/kermit.png" />
</span>
Якщо ви колись вивчали курс з математики, ви, можливо, натрапляли на осяжності множин (прим.перекл. Насправді термін <em>comprehension</em> погано або майже не перекладається одинм словом. Суть в процедурному породженні множини, так би мовити делегація вирішення питання належності до деякого функціоналу - фактично, <em>comprehension</em> легше зрозуміти з боку функціонального програмування). Вони звичайно використовуються для побудови більш специфічних множин на основі більш загальних. Базова осяжність для множини, що містить перші десять парних натуральних чисел є нотація множини.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/setnotation.png" alt="images/setnotation.png" />
</span>
Частина перед рискою називається функцією виводу, <code>x</code> це змінна, <code>N</code> є вхідна множина, та <code>x &lt;= 10</code> є предикат. Це означає, що множина містить подвоєння всіх натуральних чисел, що задовільняють предикату.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте записати це в Haskell, ви можете зробити щось подібне до <code>10 [2,4..]</code>. Але що, якщо ви не бажаєте подвоєння перших <code>10</code> натуральних чисел, але деякий різновид більш складної функції, застосованої до них? Ми можемо застосувати для цього осяжність множини. Ми покі пристанемо до отримання перших <code>10</code> парних чисел. Осяжність списків, яку ми ми можемо використати, це <code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> береться з <code>[1..10]</code>, і для кожного елемента в <code>[1..10]</code> (який ми прив'язуємо до <code>x</code>), ми отримуємо цей елемент, тільки подвоєний. Ось осяжність в дії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, ми отримали бажаний результат. Тепер давайте додамо умову (або предикат) до осяжності. Предикати ідуть після частини прив'язування, та відокремлюються від них комою. Скажімо, ми бажаємо тільки елементи, що, вже подвоїні, більші або рівні до <code>12</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто, це робить. Що, коли ми бажаємо всі числа від <code>50</code> до <code>100</code>, чий залишок, коли поділений на число <code>7</code>, є <code>3</code>? Легко.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">50</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">94</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Успіх! Зауважте, що пропускання списків через предикати також називається фільтрацією. Ми беремо список з чисел, і ми фільтруємо його предикатом. Тепер інший приклад. Скажімо, ми бажаємо осяжність, що замінює кожне непарне число, більше ніж <code>10</code> на <code>"BANG!"</code>, та кожне непарне, що меньше ніж <code>10</code> на <code>"BOOM!"</code>. Якщо число не непарне, ми відкидаємо його зі списку. Для зручності ми покладемо цю осяжність в функцію, так що ми можемо легко використовувати її декілька раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">boomBangs</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">&quot;BOOM!&quot;</span> <span class="kr">else</span> <span class="s">&quot;BANG!&quot;</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Остання частина осяжності є предикат. Функція <code>odd</code> повертає <code>True</code> на непарних числах, та <code>False</code> на парних. Елемент включається в список тільки якщо всі його предикати обчислюються до <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boomBangs</span> <span class="p">[</span><span class="mi">7</span><span class="o">..</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо включити декілька предикатів. Якщо ми бажаємо всі числа від <code>10</code> до <code>20</code>, що не є <code>13</code>, <code>15</code> або <code>19</code>, ми робимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">19</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не тільки можете мати декілька предикатів в осяжностях списків (елемент має задовільняти всім предикатам щоб бути включеним в результуючий список), ми також можемо вибирати з декількох списків. Коли здаєте з кількох списків, осяжність продукує всі комбінації з наданих списків, та потім поєднує їх в вихідній функції, яку ми надаємо. Список, вироблений осяжністю, що вибирає з двох списків довжиною <code>4</code>, буде мати довжину <code>16</code>, якщо вважати, що ми нічого не фільтруємо. Якщо ми маємо два списки, <code>[2,5,10]</code> та <code>[8,10,11]</code>, та бажаємо спродукувати всі можливі комбінації між числами в ціх списках, ось як ми це робимо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як очікувалось, довжина нового списку є <code>9</code>. Що, коли ми бажаємо всі можливі добутки, що більші за <code>50</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо осяжності списку, що комбінує список прикметників та список іменників … заради епічної втіхи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nouns</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;hobo&quot;</span><span class="p">,</span><span class="s">&quot;frog&quot;</span><span class="p">,</span><span class="s">&quot;pope&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adjectives</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="s">&quot;grouchy&quot;</span><span class="p">,</span><span class="s">&quot;scheming&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">adjective</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">noun</span> <span class="o">|</span> <span class="n">adjective</span> <span class="ow">&lt;-</span> <span class="n">adjectives</span><span class="p">,</span> <span class="n">noun</span> <span class="ow">&lt;-</span> <span class="n">nouns</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;lazy hobo&quot;</span><span class="p">,</span><span class="s">&quot;lazy frog&quot;</span><span class="p">,</span><span class="s">&quot;lazy pope&quot;</span><span class="p">,</span><span class="s">&quot;grouchy hobo&quot;</span><span class="p">,</span><span class="s">&quot;grouchy frog&quot;</span><span class="p">,</span>
<span class="s">&quot;grouchy pope&quot;</span><span class="p">,</span><span class="s">&quot;scheming hobo&quot;</span><span class="p">,</span><span class="s">&quot;scheming frog&quot;</span><span class="p">,</span><span class="s">&quot;scheming pope&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Я знаю! Давайте напишемо свою власну версію <code>length</code>! Ми назвемо її <code>length'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">length&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span> <span class="o">|</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>_</code> означає, що нам байдуже, що ми витягнули зі списку, так що замість писати ім'я змінної, що ніколи не буде використовуватись, ми просто пишемо _. Ця функція заміняє кожний елемент в списку на <code>1</code>, та потім підсумовує їх. Це означає, що отримана сума буде рівною довжині нашого списка.</p></div>
<div class="paragraph"><p>Просто дружнє нагадування: оскільки рядки є списками, ми можемо використовувати осяжності списків для обробки та продукування рядків. Ось функція, що бере рядок, та видаляє будь-що, за винятком великих літер.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Testing it out:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;Hahaha! Ahahaha!&quot;</span>
<span class="s">&quot;HA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;IdontLIKEFROGS&quot;</span>
<span class="s">&quot;ILIKEFROGS&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут предикат робить всю роботу. Він каже, що символи будуть включені в новий список, тільки якщо вони є елементами списку <code>['A'..'Z']</code>. Вкладені осяжності списків також можливі, якщо ви оперуєте зі списками, що містять списки. Список містить декілька списків чисел. Давайте видалимо всі непарні числа без вирівнювання списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xxs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span> <span class="p">]</span> <span class="o">|</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">xxs</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете записувати осяжності списків на декількох рядках. Так що якщо ви не в GHCI, краще розділити довші осяжності списків на декілька рядків, особливо якщо вони вкладені.</p></div>
</div>
<div class="sect2">
<h3 id="_">Тапли</h3>
<div class="paragraph"><p><span class="image">
<img src="images/tuples.png" alt="images/tuples.png" />
</span>
В деякий спосіб тапли як списки — вони є спосіб зберігати декілька значень в одному значенні. Але є декілька фундаментальних відмінностей. Список чисел є список чисел. Це його тип, і не має значення, чи він має лише одне число в собі, або безкінечне іисло чисел. Однак тапли використовуються, коли ви напевне знаєте, скільки значень ви бажаєте скомбінувати, та їх тип залежить від того, як багато компонент, та який їх тип. Вони позначаються дужками, та їх компоненти розділені комами.</p></div>
<div class="paragraph"><p>Інша ключова відмінність в тому, що вони не мають бути гомогенними. На відміну від списків, тапл може містити комбінацію декількох типів.</p></div>
<div class="paragraph"><p>Подумайте про те, як ми представляємо дво-вимірний вектор в Haskell. Один спосіб може бути список. Це має деяк робити. То що, якщо ми бажаємо покласти пару векторів в список, щоб представляти точки фігури на дво-мірній площині? Ми маємо зробити щось таке: <code>[[1,2],[8,11],[4,5]]</code>. Проблема з цім методом в тому, що ми також можемо робити такі речі: <code>[[1,2],[8,11,5],[4,5]]</code>, з чим Haskell не матиме проблем, бо це також список списків з числами, але це щось таке, що не має сенсу. Але тапл розміром два (що також має назву <code>pair</code>) є власним типом, що означає, що список не може мати декілька пар, і потім <code>triple</code> (тапл розміром три), так що давайте краще використовувати пари. Замість оточувати вектори квадратними дужками, ми використовуємо дужки: <code>[(1,2),(8,11),(4,5)]</code>. Що, коли ми спробуємо зробити фігуру як <code>[(1,2),(8,11,5),(4,5)]</code>? Гаразд, ми отримаємо таку помилку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]</code></pre>
</div></div>
<div class="paragraph"><p>Це каже нам, що ми спробували використовувати пару та трійку в одному списку, що не мало б статись. Ви також не можете зробити список як <code>[(1,2),("One",2)]</code>, оскільки перший елемент в списку є парою чисел, і другий елемент є парою, що складається з рядка та числа. Тапли також можуть використовуватись для представлення широкого різноманіття даних. Наприклад, якщо ми бажаємо представити чиєсь ім'я і вік в Haskell, ми можемо використовувати <code>triple</code>: <code>("Christopher", "Walken", 55)</code>. Як бачимо в цьому прикладі, тапли також можуть містити списки.</p></div>
<div class="paragraph"><p>Використовуйте тапли, коли ви знаєте заздалегідь, як багато компонент буде мати деякий шматок даних. Тапли значно більш обмежені, оскільки кожни інший розмір тапла є власним типом, так що ви не можете написати загальну функцію для додавання елементу до тапла — ви маєте писати функцію для додавання до пари, одну функцію для додавання до трійці, одну для додавання до четвірки і так далі.</p></div>
<div class="paragraph"><p>Хоча є списки синглтони, немає такої речі як синглтон тапл. Це не має багато сенсу, якщо ви поміркуєте про це. Синглтон тапл є тільки значення, що він містить, і це не дає нам жодних переваг.</p></div>
<div class="paragraph"><p>Як списки, тапли можуть бути порівняні один з одним, якщо їх компоненти можуть бути порівняні. Ви не можете порівняти два тапла різного розміру, хоча ви можете порівняти два списки різного розміру. Дві корисні функції для операцій на парах:</p></div>
<div class="paragraph"><p><code>fst</code> бере пару, та повертає перший компонент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">8</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="s">&quot;Wow&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>snd</code> бере пару, та повертає другий компонент. Сюрприз!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">11</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: ці функції оперують тільки на парах. Вони не працюватимуть на трійках, четвірках, п'ятірках, тощо. Ми дійдемо до отримання даних з таплів в різний спосіб трохи пізніше.</p></div>
<div class="paragraph"><p>Крута функція, що продукує список пар: <code>zip</code>. Вона приймає список з двох списків, та потім поєднує їх разом в один список, через поєднання елементів з одним індексом в пари. Це насправді проста функція, але вона має безліч застосувань. Вона особливо корисна, коли ви бажаєте скомбінувати два списки в цей спосіб, або пересуватись по обох списках одночасно. Ось демонстрація.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">,</span> <span class="s">&quot;five&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;three&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;four&quot;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;five&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це спаровує елементи та продукує новий список. Перший елемент з першим, другий з другим, і так далі. Зауважте, що оскільки пари можуть мати різні типи в собі, <code>zip</code> може приймати два списка, що містять різні типи, та поєднати їх разом. Що трапиться, якщо довжина списків не співпаде?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;im&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;im&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Довший список просто буде обрізаний, щоб співпадати по довжині з коротшим. Оскільки Haskell лінивий, ми можемо поєднувати скінчені списки з безкінечними списками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;cherry&quot;</span><span class="p">,</span> <span class="s">&quot;mango&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;apple&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;orange&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;cherry&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;mango&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/pythag.png" alt="images/pythag.png" />
</span>
Ось проблема, що поєднує тапли та осяжності списків: який правильний трикутник, що має цілими всі сторони, і всі сторони меньше або рівні <code>10</code>, має периметр <code>24</code>? Перше, давайте спробуємо генерувати всі трикутники, зі сторонами меньшими ніж <code>10</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">triangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми тільки но тягнемо з трьох списків, і наша вихідна функція є поєднання їх в трійцю. Якщо ви обчислите це, набравши <code>triangles</code>  в GHCI, ви отримаєте список всіх можливих трикутників зі сторонами довжиною <code>10</code> або меньше. Далі ми додамо умову, щоб всі вони були правильними трикутниками. Ми також будемо модифікувати цю функцію, приймаючи до уваги, що сторона <code>b</code> не більша за гіпотенузу, і що сторона <code>a</code> не більша за сторону <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми майже скінчили. Тепер ми тільки модифікуємо функцію, сказавши, що ми бажаємо тільки коли периметр дорівнює <code>24</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles&#39;</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">24</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">rightTriangles&#39;</span>
<span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>А ось і відповідь! Це загальних шаблон функціонального програмування. Ви берете стартовий набір рішень, та потім ви застосовуєте трансформації до ціх рішень, та фільтруєте їх, доки ви не отримаєте потрібні.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-08-02 02:15:58 EEST
</div>
</div>
</body>
</html>
