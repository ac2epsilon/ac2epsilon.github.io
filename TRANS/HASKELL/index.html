<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Miran Lipovača</p></div>
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
<div class="paragraph"><p>Запрошуємо до Learn You a Haskell for Great Good! Якщо ви читаєте це, є шанси, що ви бажаєте вивчити Haskell. Так, ви опинились в правильному місці, але спершу давайте поговоримо про сам цей туторіал.</p></div>
<div class="paragraph"><p>Я вирішив написати це, бо я хотів покращити моє влане знання Haskell, і оскільки я думав, що можу допомогти новим до Haskell людям вивчати його з моєї перспективи. Існує досить небагато туторіалів по Haskell, що плавають в інтернеті. Коли я починав з Haskell, я не навчався тільки з одного ресурсу. Спосіб, яким я навчався, було читання декількох різних туторіалів та статей, оскільки кожний пояснював дещо в інший спосіб, ніж інший. Проходячи по різним ресурсам я був в змозі скласти разом частини, та все займало своє місце. Так що це спроба додати інший корисний ресурс для вивчення Haskell, так що ви маєте більший шанс знайти те, що вам сподобається.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/bird.png" alt="images/bird.png" />
</span>
Цей туторіал націлений на людей, що мають досвід з імперативними мовами програмування (C, C++, Java, Python …), але досі не програмували на функціональних мовах (Haskell, ML, OCaml …). Хоча  я можу поспорити, що навіть якщо ви не маєте жодного значного програмного досвіду, розумна людина, як ви, буде в змозі відслідковувати хід подій та навчиться Haskell.</p></div>
<div class="paragraph"><p>Канал <code>#haskell</code> в мережі <code>freenode</code> є чудовим місцем запитувати питання, якщо ви почуваєтесь розгубленим. Люди там вкрай милі, терплячі та розуміють початківців.</p></div>
<div class="paragraph"><p>Я не зміг вивчити Haskell приблизно два рази, перед тим як нарешті підхопив його, оскільки все це виглядало дуже збоченим, і я не міг зрозуміти. Але одного разу воно просто "клацнуло", і після продирання через початкові хащі це видалось досі спокійне плавання. Як мені здається я намагаюсь сказати: Haskell чудовий, і якщо ви дійсно зацікавлені в програмуванні, вам слід дійсно вивчити його, навіть якщо спочатку він виглядає збоченим. Вивчення Haskell більш подібне на навчання програмування з самого початку — це весело! Це дозволяє вам мислити інакше, що відносить нас в другий розділ …</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/fx.png" alt="images/fx.png" />
</span>
Haskell є <strong>чисто функціональна мова програмування</strong>. В імперативних мовах ви отримуєте речі зробленими через надання комп'ютеру послідовність завдань, та потів виконуєте їх. При їх виконанні це може змінювати стан. Наприклад, ви встановили змінну в <code>5</code>, потім робили дещо, та потім встановили її в дещо інше. Ви маєте структури керування потоком, щоб виконати деяку дію декілька раз. В чисто функціональному програмуванні ви не кажете комп'ютеру, що робити як таке, але скоріше ви кажете, що має бути. Факторіал числа є добуток всіх чисел від 1 до цього числа, сума списка чисел є перше число, плюс сума інших чисел, і так далі. Ви виражаєте це в формі функцій. Ви також не можете змінну в дещо, і пізніше встановити її в дещо інше. Якщо ви кажете, що <code>a</code> є <code>5</code>, ви не можете пізніше сказати що це щось інше, бо ви сказали що це <code>5</code>. Ви що, якийсь брехун? Так що в повністю функціональних мовах функція не має побічних ефектів. Єдина річ, що може робити функція, це обчислювати дещо і повертати це як результат. Спочатку це виглядає як деяке обмеження, але насправді має дуже милі наслідки: якщо функція викликається два рази з тими самими параметрами, вона гарантовано повертає той самий результат. Це називаеться посилковою прозорістю, і не тільки дозволяє компілятору промислювати поведінку програми, але також дозволяє просто доходити висновку (та навіть доводити), що функція коректна, та потім будувати більш складні функції, через склеювання простих функцій разом.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lazy.png" alt="images/lazy.png" />
</span>
Haskell <strong>лінивий</strong>. Це означає, що якщо спеціально не сказане інше,Haskell не виконуватиме функцій та не обчислюватиме речі, коли його дійсно не змусить це робити, щоб показати вам результат. Це гарно пасує до прозорості посилань, і це дозволяє вам думати про програми як про серії перетворень даних. Це також дозволяє круті речі, такі як безкінечні структури даних. Скажімо, ви маєте незмінний список чисел <code>xs = [1,2,3,4,5,6,7,8]</code>, та функцію <code>doubleMe</code>, що множить кожний елемент на <code>2</code>, та потім повертає новий список. Якщо ми б захотіли помножити весь список на 8 в імперативній мові, та зробити <code>doubleMe(doubleMe(doubleMe(xs)))</code>, це можливо пройшло б по списку один раз, та зробило копію, щоб повернути її. Потім це пройшло б по списку ще два рази, та повернуло результат. В лінивій мові виклик <code>doubleMe</code> на списку без примусу показати вам результат скінчиться тим, що програма скаже вам щось накшталт "Так-так, я зроблю це пізніше!". Але коли ви захочете побачити результат, перший <code>doubleMe</code> каже другому, що він хоче результат, негайно! Другий каже те саме до третього, і третій похопцем повертає подвоєні <code>1</code>, що є <code>2</code>. Другий отримує це і повертає <code>4</code> першому. Перший виклик бачить це і повертає вам <code>8</code>. Так що відбувається тільки один прохід по списку, і тільки тоді, коли вам це дійсно треба. Таким чином, коли ви бажаєте дещо від лінивої мови, ви можете просто взяти початкові дані, і ефективно перетворити та полагодити, так, щоб воно відтворювале те, що ви бажаєте мати в кінці.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/boat.png" alt="images/boat.png" />
</span>
Haskell є <strong>статично типізованим</strong>. Коли ви компілюєте вашу програму, компілятор знає, яка частина коду є числом, яка є рядком і так далі. Це означає, що багато з можливих помилок будуть виловлені під час компіляції. Якщо ви спробуєте додати разом число та рядок, компілятор буде скиглити на вас. Haskell використовую дуже гарну систему типів, що має вивід типів. Це означає, що вам не треба насправді явно помічати кожний кусок коду типом, бо система типів може розумно здогадатись більшість з них. Якщо ви кажете <code>a = 5 + 4</code>, ви не маєте казати Haskell, що <code>a</code> є числом, він сам може про це здогадатись. Вивід типів також дозволяє вашому коду бути більш загальним. Якщо функція, що ви створюєте, приймає два параметри, та додає їх разом, та ви явно не встановили їх тип, функція буде робити на любих двох параметрах, що поводяться як числа.</p></div>
<div class="paragraph"><p>Haskell є <strong>елегантним та стислим</strong>. Оскільки він використовує багато концепцій високого рівня, програми Haskell звичайно коротші, ніж їх імперативні еквіваленти. Та коротші програми простіше підтримувати, ніж довгі, та мати меньшн вад.</p></div>
<div class="paragraph"><p>Haskell був зроблений <strong>дійсно розумними хлопцями</strong> (з науковими ступенями). Робота над Haskell почалась в 1987му році, коли комітет розробників зібрався разом щоб розробити несамовиту мову. В 2003 був опублікований Haskell Report, що визначає стабільну версію мови.</p></div>
<div class="paragraph"><p>Текстовий редактор та компілятор Haskell. Ви, можливо, вже маєте ваш улюблений текстовий редактор встановленим, так що ми не витрачатимемо не це час. Для цілей цього туторіала ми будемо використовувати GHC, найбільш широко уживаний компілятор Haskell. Кращий шлях розпочати - завантажити <em>Haskell Platform</em>, що в основному той самий Haskell в комплекті з батарейками.</p></div>
<div class="paragraph"><p>GHC може прийняти Haskell скрипт (вони звичайно мають розширення <code>.hs</code>), та компілювати його, але він також має інтерактивний режим, що дозволяє вам інтерактивно взаємодіяти зі скриптами. Інтерактивно. Ви можете викликати функції зі скриптів, що ви завантажуєте, і результати відображуються безпосередньо. Для навчання це значно простіше і швидше, ніж компілювати кожного разу щоб зробити зміну, та потім виконувати програму з консольної підказки. Інтерактивний режим викликається запуском <code>ghci</code> в підказці консолі. Якщо ви визначили деякі функції в викликаному файлі, скажімо, <code>myfunctions.hs</code>, ви завантажуєте ці функції через набір <code>:l myfunctions</code>, і потім граєтесь з ними, вважаючи, що <code>myfunctions.hs</code> в тому самому файлі, з якого був запущений <code>ghci</code>. Якщо ви зміните <code>.hs</code> скрипт, просто виконайте <code>:l myfunctions</code> знову, або зробіть <code>:r</code>, що еквівалентно, оскільки це перевантажує поточний скрипт. Звичайна послідовність для мене, коли я граюсь з деякими речами, це створення деяких функцій в <code>.hs</code> файлі, завантаження їх, та забавки з ними, та потім зміна файла <code>.hs</code>, завантаження його знову, і так далі. Це також те, що ми будемо тут з вами робити.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/startingout.png" alt="images/startingout.png" />
</span>
Гаразд, давайте розпочнемо! Якщо ви з тих жахливих людей, що не читають інструкцій до речей, і пропускаєте їх, в жодному разі ви маєте прочитати останній розділ зі вступу, оскільки він пояснює, що вам треба, щоб слідувати цьому туторіалу, і як ми збираємось завантажувати функції. Перша річ, що ми збираємось зробити, це виконати <code>ghc</code> в інтерактивному режимі, та викликати деякі функції, щоб отримати дуже базове відчуття <code>haskell</code>. Відкрийте ваш термінал та наберіть <code>ghci</code>. Ви отримаєте привітання, подібне до наступного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">GHCi</span><span class="p">,</span> <span class="n">version</span> <span class="mf">6.8</span><span class="o">.</span><span class="mi">2</span><span class="kt">:</span> <span class="n">http</span><span class="kt">://</span><span class="n">www</span><span class="o">.</span><span class="n">haskell</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">ghc</span><span class="o">/</span>  <span class="kt">:?</span> <span class="n">for</span> <span class="n">help</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">base</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Prelude</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вітаємо, ви в GHCI! Тут підказка <code>Prelude&gt;</code>, але оскільки вона може стати довшою коли ви завантажите дещо в сессії, ми збираємось використовувати <code>ghci&gt;</code>. Якщо ви бажаєте мати таку саму підказку, просто наберіть <code>:set prompt "ghci&gt; "</code>.</p></div>
<div class="paragraph"><p>Ось деяка проста арифметика.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">15</span>
<span class="mi">17</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">49</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">4900</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1892</span> <span class="o">-</span> <span class="mi">1472</span>
<span class="mi">420</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">2.5</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить пояснює себе. Ми також можемо використовувати декілька операторів в одному рядку, і вони будуть підкорюватись звичайним правилам преоритетів. Ми можемо використовувати дужки, щоб зробити преоритети явними, або щоб змінити їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span><span class="p">)</span>
<span class="o">-</span><span class="mi">244950</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить круто, чи не так? Так, я знаю що ні, але повірте мені. Невелика пастка тут - подивитись як змінюється знак чисел. Якщо ви бажаєте мати від'ємне число, завжди краще оточити його в дужки. робити <code>5 * -3</code> змусить GHCI скаржитись на вас, але якщо зробити <code>5 * (-3)</code>, це буде робити добре.</p></div>
<div class="paragraph"><p>Логічна алгебра також досить прямолінійна. Як ви ,вірогідно, знаєте, <code>&amp;&amp;</code> позначає логічне <code>AND</code>, <code>||</code> позначає логічне <code>OR</code>. <code>not</code> обертає <code>True</code> або <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевірка на рівність робиться так.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">4</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо зробити  <code>5 + "llama"</code> або <code>5 == True</code>? Гаразд, якщо ми спробуємо перший фрагмент, ми отримаємо велике і жахливе повідомлення про помилку!</p></div>
<div class="listingblock">
<div class="content">
<pre><code>No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"</code></pre>
</div></div>
<div class="paragraph"><p>Такої! Що тут GHCI каже нам, це те, що <code>"llama"</code> не є числом, і так він не знає, як додати його до <code>5</code>. Навіть якщо це б було не <code>"llama"</code>, а <code>"four"</code> або <code>"4"</code>, Haskell все одно не може дійти висновку, що це число. <code>+</code> очікує, що зправа та зліва від нього числа. Якщо ви спробуєте зробити <code>True == 5</code>, GHCI скаже нам, що типи не співпадають. Хоча <code>+</code> робить тільки на речах, що розглядаються як числа, <code>==</code> робить на любих двох речах, що можна порівняти. Але зачіпка в тому, що вони обоє мають бути одним типом речей. Ви не можете порівняти яблука та помаранчі. Ми зробимо ближчий погляд на типи пізніше. Зауваження: ви можете робити <code>5 + 4.0</code>, оскільки <code>5</code> хитра, і може діяти як ціле або число з плаваючою крапкою. <code>4.0</code> не може діяти як ціле, так що <code>5</code> єдине, що має пристосовуватись.</p></div>
<div class="paragraph"><p>Можиливо ви не знали це, але ми використовували функції весь цей час. Наприклад, <code>*</code> є функцією, що приймає два числа, та перемножує їх. Як ви бачили, ми використовували її, утворивши сендвіч з них. Це те, що ми називаємо інфіксною функцією. Більшість функцій, що не використовуються з числами, є префіксні функції. Давайте поглянемо на них.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/phoen.png" alt="images/phoen.png" />
</span>
Функції звичайно ідуть як префікс, такщо від тепер ми не будемо явно вказувати, що функція має префіксну форму, ми будемо просто вважати що це так. В багатьої імперативних мовах функції викликаються через запис імені функції, та потім її параметри в дужках, звичайно розділені комами. В Haskell функції викликаються записом ім'я функції, проміжок, і розділені проміжками параметри. Для початку ми спробуємо викликати одну зі скучніших функцій в Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">8</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>succ</code> приймає будь-що, що має визначений наступний, та повертає це наступне. Як ви можете бачити, ми просто відділили ім'я функції від параметра проміжком. Виклик функції з декількома параметрами також просте. Функції <code>min</code> та <code>max</code> приймають дві речі, що можуть бути впорядковані (як числа!). <code>min</code> повертає те, що меньше, та <code>max</code> повертає те, що більше. Дивіться самі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mf">3.4</span> <span class="mf">3.2</span>
<span class="mf">3.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">100</span> <span class="mi">101</span>
<span class="mi">101</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосування функції (виклик функції через покладання проміжку пісня неї, та потім набір параметрів) має найвищий преоритет з них усіх. Це означає, що наступні два твердження еквівалентні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">succ</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ми бажаємо отримати наступний до добутку чисел <code>9</code> та <code>10</code>, ми не можемо записати  <code>succ 9 * 10</code>, оскільки це отримання послідовника для <code>9</code>, що потім буде помножений на <code>10</code>. Тобто <code>100</code>. Ми маємо писати <code>succ (9 * 10)</code> щоб отримати <code>91</code>.</p></div>
<div class="paragraph"><p>Якщо функція прийма два параметри, ми також можемо викликати її як інфіксну функцію, оточивши її зворотніми апострофами. Наприклад, функція <code>div</code> приймає два цілі, та робить ціле ділення першого на друге. Обчислення <code>div 92 10</code> дає результат <code>9</code>. Але коли ми викликаємо її таким чином, може бути деякий сумнів, яке число є чисельник і яке займенник. Так що ми можемо викликати її як інфіксну функцію, зробивши <code>92 ``div`</code> 10`, і миттєво все стає зрозуміло.</p></div>
<div class="paragraph"><p>Багато людей, які прийшли з імперативних мов, маю схильність приставати на нотацію, де дужки мають позначати застосування функції. Наприклад в C ви виокристовуєте дужки для виклику функції, як <code>foo()</code>, <code>bar(1)</code> або <code>baz(3, "haha")</code>. Як ми казали, в Haskell для застосування функції ми використовуємо дужки. Так що ці функції в Haskell будуть <code>foo</code>, <code>bar 1</code> та <code>baz 3 "haha"</code>. Так що якщо ви бачите що подібне до <code>bar (bar 3)</code>, це не означає, що <code>bar</code> викликається з <code>bar</code> та <code>3</code> в якості параметрів. Це означає, що спочатку ми викликаємо <code>bar</code> з <code>3</code> в якості параметра, щоб отримати якесь число, та потім ми викликаємо <code>bar</code> знову з цім числом. В C це буде щось подібне до <code>bar(bar(3))</code>.</p></div>
<div class="paragraph"><p>В попередньому розділі ми отримали базове відчуття щодо виклику функцій. Тепер давайте спробуємо створити свої власні! Відкрийте ваш улюблений текстовий редактор, і видайте таку функцію, що приймає число та множить його на два.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції визначають в спосіб, подібний до їх виклику. Ім'я функції іде перед параметрами, розділені проміжками. Але коли функція визначається, існує знак <code>=</code> , та після нього визначення того, що робить функція. Збережіть це як <code>baby.hs</code> або будь-як інакше. Тепер перейдіть туди, де ви збереглись, і запустіть там <code>ghci</code>. Всередині  GHCI зробіть <code>:l baby</code>. Тепер, коли наш скрипт завантажений, ми можемо гратись з функцією, яку ми визначили.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">baby</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">baby</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mi">9</span>
<span class="mi">18</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mf">8.3</span>
<span class="mf">16.6</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>+</code> робить на цілих, так само як і на числах з плаваючою крапкою (насправді на будь-чому, що може розглядатись як число), наша функція також може робити з любими числами. Давайте зробимо функцію, що приймає два числа, та перемножує їх на два, і потім складає результати разом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Просто. Ми також могли визначити це як <code>doubleUs x y = x + x + y + y</code>. Тестування продукує досить передбачувані результати (пам'ятайте додати цю функцію до файлу  <code>baby.hs</code>, збережіть його, та потім зробіть <code>:l baby</code> в GHCI).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">4</span> <span class="mi">9</span>
<span class="mi">26</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mf">2.3</span> <span class="mf">34.2</span>
<span class="mf">73.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">28</span> <span class="mi">88</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="mi">123</span>
<span class="mi">478</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, ви можете викликати ваші власні функції з інших функцій, які ви створили. Маючи це на увазі, ви можете перевизначити <code>doubleUs</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">doubleMe</span> <span class="n">x</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дуже простий приклад загального шаблону, що ви бачитимете повсякчас в Haskell. Створення простих функцій, що вочевидь коректні, та потім комбінування їх в більш складні функції. Таким чином ви також уникаєте повторень. Що, коли деякий математик дійде висновку, що <code>2</code> насправді <code>3</code>, і ви маєте змінити програму? Ви можете просто перевизначити <code>doubleMe</code> як <code>x + x + x</code>, і оскільки <code>doubleUs</code> викликає <code>doubleMe</code>, вона також буде автоматично робити в цьому дивному світі, де <code>2</code> є <code>3</code>.</p></div>
<div class="paragraph"><p>Функції в Haskell не мають іти в якомусь певному порядку, так що не має значення, якщо ви визначите <code>doubleMe</code> спочатку, та потім <code>doubleUs</code>, або ви зробите це навпаки.</p></div>
<div class="paragraph"><p>Тепер ми збираємось створити функцію, що множить число на <code>2</code>, але тільки якщо число меньше або рівне <code>100</code>, бо числа більше ніж <code>100</code> досить великі як вони є!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
                        <span class="kr">then</span> <span class="n">x</span>
                        <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/baby.png" alt="images/baby.png" />
</span>
Прямо зараз ми ввели Haskell твердження <code>if</code>. Ви, можливо, знайомі з <code>if</code> твердженнями в інших мовах. Різниця між Haskell твердженням <code>if</code>, та твердженнями <code>if</code> в імперативних мовах в тому, що частина <code>else</code> обов'язкова в Haskell. В імперативних мовах ви можете просто пропустити пару кроків, якщо умова не задовільняється, але в Haskell кожний вираз та функція має щось повертати. Ми можемо також записати твердження <code>if</code> в один рядок, але я вважаю цей спосіб значно читабельніше. Інша річ щодо твердження <code>if</code> в Haskell в тому, що це вираз. Вираз загалом це шматок коду, що повертає значення. <code>5</code> є виразом, бо воно повертає <code>5</code>, <code>4 + 8</code> також вираз, <code>x + y</code> також вираз, бо він повертає суму <code>x</code> та <code>y</code>. Оскільки <code>else</code> обов'язкове, твердження <code>if</code> буде завжди  щось повертати, і ось чому це також вираз. Якщо ми бажаємо додавати одиницю до кожного числа, що спродуковане в нашій попередній функції, ми маємо записати тіло таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми б пропустили дужки, воно додавало одиницю тільки якщо <code>x</code> не було б більше <code>100</code>. Зауважте <code>'</code> наприкінці імені функції. Цей апостроф не має жодного спеціального значення в синтаксисі Haskell. Це валідний символ для використання в іменах функцій. Ми зазвичай використовуємо <code>'</code> для позначення суворої версії функції (що не є лінива), або трохи модифікованої версії функції або змінної. Оскільки <code>'</code> валідний символ в функціях, ми можемо зробити функцію таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">conanO&#39;Brien</span> <span class="ow">=</span> <span class="s">&quot;It&#39;s a-me, Conan O&#39;Brien!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут дві речі, варті уваги. Перша в тому, що в назві функції ми не пишемо ім'я Конана з великої литери. Це тому, що функції не можуть починатись з великої літери. Пізніше ми побачимо чому. Друга річ в тому, що ця функція не приймає жодних параметрів. Коли функція не приймає жодних параметрів, ми кажемо що це визначення (або ім'я). Оскільки ми не можемо змінити те, що імена (та функції) означають після того, як ми їх визначили, <code>conanO'Brien</code> та рядок <code>"It's a-me, Conan O'Brien!"</code> можна використовувати взаємозамінно.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/list.png" alt="images/list.png" />
</span>
Здебільшого так само, як списки покупок в реальному світі, списки в Haskell дуже корисні. Це найбільш використовувана структура даних, і вона може бути використана в безлічі різних способів, щоб моделювати та вирішувати цілу кіпу проблем. Списки ТАКІ неймовірні. В цьому розділі ми побачимо на основи списків, рядкі (що є списками) та осяжність списків.</p></div>
<div class="paragraph"><p>В Haskell списки є гомогенними структурами даних. Вони зберігають декілька елементів одного типу. Це означає, що ми можемо мати список цілих та список символів, але ми не можемо мати список, що має трохи цілих, та трохи символів. І тепер - список!</p></div>
<div class="paragraph"><p>Note: Ми можемо використовувати ключове слово <code>let</code> для визначення імені прямо в GHCI. Зробити <code>let a = 1</code> в GHCI еквівалентно до написання <code>a = 1</code> в скрипті, та потім його завантаження.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">lostNumbers</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lostNumbers</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, списки позначаються квадратними дужками, та значення в списках розділяються комами. Якщо ми спробуємо список <code>[1,2,'a',3,'b','c',4]</code>, Haskell буде скаржитись, що символи (що, проміж іншого, позначаються символами в поодиноких лапках) не є числами. Кажучи про символи, рядки є тільки списками символів. <code>"hello"</code> є тільки синтаксичним цукром для <code>['h','e','l','l','o']</code>. Оскільки рядки є списками, ми можемо використовувати функції для спискив з рядками, що дійсно зручно.</p></div>
<div class="paragraph"><p>Загальна задача є складання двох списків разом. Це робиться за допомогою оператора <code>++</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="s">&quot;world&quot;</span>
<span class="s">&quot;hello world&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;w&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">]</span>
<span class="s">&quot;woot&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Пильнуйте, коли постійно використовуєте оператор <code>++</code> на довгих рядках. Коли ми складаємо разом два списки (навіть якщо ми додаємо синглтон список до списку, наприклад: <code>[1,2,3] ++ [4]</code>), внутрішньо Haskell має пройти по всьому списку злівого боку від <code>++</code>. Це не проблема, коли маємо справи зі списками, що не дуже великі. Але покладання дечого в кінець списку, що має п'ядесят мільйонів елементів в довжину таки займе деякий ча. Однак покладання дечого на початок списку з використанням оператора <code>:</code> (також називається <code>cons</code> оператором) є миттєвим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;A&#39;</span><span class="kt">:</span><span class="s">&quot; SMALL CAT&quot;</span>
<span class="s">&quot;A SMALL CAT&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, як <code>:</code> приймає число і список чисел, або символ та список символів, тоді як <code>++</code> приймає два списки. Навіть якщо ви додаєте один елемент в кінець списку за допомогою <code>++</code>, ви маєте оточити його в квадратні дужки, так щоб він став списком.</p></div>
<div class="paragraph"><p><code>[1,2,3]</code> насправді є тільки синтаксичним цукром для <code>1:2:3:[]</code>. <code>[]</code> це порожній список. Якщо перед ним добавити <code>3</code> це перетвориться на <code>[3]</code>. Якщо перед цім поставити <code>2</code>, стане <code>[2,3]</code>, і так далі.</p></div>
<div class="paragraph"><p>Note: <code>[]</code>, <code>[[]]</code> та <code>[[],[],[]]</code> все різні речі. Перше це порожній список, друге це список, що містить один порожній список, третій список містить три порожні списки.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте отримати елемент зі списку по індексу, використовуйте <code>!!</code>. Індекси починаються з <code>0</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Steve Buscemi&quot;</span> <span class="o">!!</span> <span class="mi">6</span>
<span class="sc">&#39;B&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">9.4</span><span class="p">,</span><span class="mf">33.2</span><span class="p">,</span><span class="mf">96.2</span><span class="p">,</span><span class="mf">11.2</span><span class="p">,</span><span class="mf">23.25</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">1</span>
<span class="mf">33.2</span>
</pre></div></div></div>
<div class="paragraph"><p>Але якщо ви намагатиметесь отримати шостий елемент зі списку, що має тільки чотири елементи, ви отримаєте помилку, так що будьте уважні!</p></div>
<div class="paragraph"><p>Списки також можуть містити списки. Вони також можуть містити списки, що містять списки, що містять списки …</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">++</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="kt">:</span><span class="n">b</span>
<span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки в списку можуть бути різної довжини, але вони не можуть бути різних типів. Так само, як ви не можете мати список, що містить деякі числаі деяки символи, ви не можете мати деякі списки з символами, і деякі списки з числами.</p></div>
<div class="paragraph"><p>Списки можливо порівняти, якщо те, що вони містять, може бути порівняно. Коли використовуються <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> та <code>&gt;=</code> для порівняння списків, вони порівнюються в лексографічному порядку. Спочатку порівнюються голови. Якщо вони рівні, порівнюються другі елементи, і так далі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Що ще можна робити зі списками? Ось деякі базові функції, що оперують на списках.</p></div>
<div class="paragraph"><p><code>head</code> бере список, та повертає його голову. Голова списку це його перший елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>tail</code> бере список, та повертає його хвіст. Іншими словами вона відрубає йому голову.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>last</code> бере список, та повертає останній елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p><code>init</code> бере список, та повератє все, крім останнього елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">init</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви вважаєте, що список це монстр, тоді вам сподобається таке.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/listmonster.png" alt="images/listmonster.png" />
</div>
</div>
<div class="paragraph"><p>Але що трапиться, якщо ми спробуємо отримати голову порожнього списку?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">head</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
</pre></div></div></div>
<div class="paragraph"><p>Матінко рідна! Все це вибухнуло нам у лице! Якщо немає монстра, в нього немає голови. Коли використовуєте <code>head</code>, <code>tail</code>, <code>last</code> та <code>init</code>, будьте уважні не використовувати їх на порожніх списках. Ця помилка не може бути перехоплена під час компіляції, так що завжди гарна практика докласти перестороги супроти випадкового прохання до Haskell отримати елементи з порожнього списку.</p></div>
<div class="paragraph"><p><code>length</code> бере список, та повертає його довжину, очевидно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи список порожній. Якщо це так, він повертає <code>True</code>, інакше <code>False</code>. Використовуйте цю функцію замість <code>xs == []</code> (якщо ви маєте список з назвою <code>xs</code>)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>reverse</code> обертає список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>take</code> бере число і список. Він виділяє таку кількість з початку списка. Дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите, якщо ми намагаємось взяти більше елементів, ніє є в списку, він просто повертає список. Якщо ми намагаємось взяти <code>0</code> повертається порожній список.</p></div>
<div class="paragraph"><p><code>drop</code> робить подібним чином, тільки він відкидає число елементів з початку списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>maximum</code> бере список дечого, що може бути впорядковане, і повертає найбільший елемент.</p></div>
<div class="paragraph"><p><code>minimum</code> повертає найменьший.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p><code>sum</code> бере список чисел, та повертає його суму.</p></div>
<div class="paragraph"><p><code>product</code> бере список чисел, та повертає його добуток.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">31</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">24</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elem</code> бере річ та список речей, та каже нам, чи є такий елемент в списку. Це звичайно викликається як інфіксна функція, оскільки так воно краще читається.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Це були декілька базових функцій, що оперують на списках. Ми побачимо більше спискових функцій пізніше.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cowboy.png" alt="images/cowboy.png" />
</span>
Що, коли ми бажаємо перелічити всі числа від 1 до 20? Звичайно, ми можемо просто надрукувати їх всі разом, але вочевидь це не рішення для джентельмена, що вимагає досконалості від своїх мов програмування. Замість цього ми використовуємо диапазони. Диапазони - це спосіб створювати списки, що є арифметичними послідовностями елементів, що можуть бути перелічені. Числа можуть бути перелічені. Один, два, три, чотири, тощо. Символи можути бути перелічені. Абетка є перелік літер від <code>A</code> до <code>Z</code>. Імена не можуть бути перелічені. Що іде після <code>"John"</code>? Я не знаю.</p></div>
<div class="paragraph"><p>Щоб зробити список, що містить всі натуральні числа від 1 до 20 ви можете записати<code>[1..20]</code>. Це еквівалентно до написання <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>, і немає різниці між написанням одного чи іншого, за винятком того, що написання довгих послідовностей переліку вручну є дурнею.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;K&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]</span>
<span class="s">&quot;KLMNOPQRSTUVWXYZ&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони круті, оскільки ви можете задати крок. Що, якщо ми бажаємо всі парні числа між 1 та 20? Або навіть тожне третє між 1 та 20?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це просто справа розділення перших двох елементів комою, та потім вказати вищий ліміт. Хоча це досить розумне, диапазони з кроками не такі розумні, ніє деяки люди бажали б їх бачити. Ви не можете зробити <code>[1,2,4,8,16..100]</code>, та очікувати отримання всіх ступеней <code>2</code>. Для початку тому що ви можете вказати один крок. Та подруге через те, що деякі неарифметичні послідовності неоднозначні, якщо задати тільки декілька з перших членів послідовності.</p></div>
<div class="paragraph"><p>Щоб зробити список з усіх чисел від 20 до 1, ви не можете записати тільки <code>[20..1]</code>, ви маєте зробити <code>[20,19..1]</code>.</p></div>
<div class="paragraph"><p>Слідкуйте за використанням чисел з плаваючою крапкою в диапазонах! Завдяки тому, що вони не повністю точні (по визначенню), їх використання може дати деякі досить дивні результаті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.8999999999999999</span><span class="p">,</span><span class="mf">1.0999999999999999</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Моя порада не використовувати їх в спискових диапазонах.</p></div>
<div class="paragraph"><p>Ви також можете використовувати диапазони для створення безкінечних списків, просто не задаючи верню межу. Пізніше ми дійдемо до більших деталей щодо безкінечних списків. Тепер давайте перевіримо, як ви можете отримати перші <code>24</code> добутки числа <code>13</code>. Звичайно, ви можете зробити <code>[13,26..24*13]</code>. Але є кращий шлях: <code>take 24 [13,26..]</code>. Оскільки Haskell лінивий, він не буде намагатись обчислити безкінечний список безпосередньо, бо це ніколи не скінчиться. Він буде чекати, що ви бажаєте отримати з цього безкінечного списку. І тут він бачить, що ви бажаєте отримати лише перші <code>24</code> елементи, на що він легко погоджується.</p></div>
<div class="paragraph"><p>Декілька фунцій, що продукують безкінечні списки:</p></div>
<div class="paragraph"><p><code>cycle</code> бере список, та в циклі перетворює його в безкінечний список. Якщо ви спробуєте тільки отримати результат, це триматиме вічність, тому ви маєте перерватись десь.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">12</span> <span class="p">(</span><span class="n">cycle</span> <span class="s">&quot;LOL &quot;</span><span class="p">)</span>
<span class="s">&quot;LOL LOL LOL &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>repeat</code> бере елемент, та продукує безкінечний список тільки з цього елемента. Це як цикл по списку тільки з одного елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це простіше просто використовувати фуункцію <code>replicate</code>, якщо ви бажаєте деяке число одного елемента в списку. <code>replicate 3 10</code> повертає <code>[10,10,10]</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/kermit.png" alt="images/kermit.png" />
</span>
Якщо ви колись вивчали курс з математики, ви, можливо, натрапляли на осяжності множин (прим.перекл. Насправді термін <em>comprehension</em> погано або майже не перекладається одинм словом. Суть в процедурному породженні множини, так би мовити делегація вирішення питання належності до деякого функціоналу - фактично, <em>comprehension</em> легше зрозуміти з боку функціонального програмування). Вони звичайно використовуються для побудови більш специфічних множин на основі більш загальних. Базова осяжність для множини, що містить перші десять парних натуральних чисел є нотація множини.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/setnotation.png" alt="images/setnotation.png" />
</span>
Частина перед рискою називається функцією виводу, <code>x</code> це змінна, <code>N</code> є вхідна множина, та <code>x &lt;= 10</code> є предикат. Це означає, що множина містить подвоєння всіх натуральних чисел, що задовільняють предикату.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте записати це в Haskell, ви можете зробити щось подібне до <code>10 [2,4..]</code>. Але що, якщо ви не бажаєте подвоєння перших <code>10</code> натуральних чисел, але деякий різновид більш складної функції, застосованої до них? Ми можемо застосувати для цього осяжність множини. Ми покі пристанемо до отримання перших <code>10</code> парних чисел. Осяжність списків, яку ми ми можемо використати, це <code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> береться з <code>[1..10]</code>, і для кожного елемента в <code>[1..10]</code> (який ми прив'язуємо до <code>x</code>), ми отримуємо цей елемент, тільки подвоєний. Ось осяжність в дії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, ми отримали бажаний результат. Тепер давайте додамо умову (або предикат) до осяжності. Предикати ідуть після частини прив'язування, та відокремлюються від них комою. Скажімо, ми бажаємо тільки елементи, що, вже подвоїні, більші або рівні до <code>12</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто, це робить. Що, коли ми бажаємо всі числа від <code>50</code> до <code>100</code>, чий залишок, коли поділений на число <code>7</code>, є <code>3</code>? Легко.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">50</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">94</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Успіх! Зауважте, що пропускання списків через предикати також називається фільтрацією. Ми беремо список з чисел, і ми фільтруємо його предикатом. Тепер інший приклад. Скажімо, ми бажаємо осяжність, що замінює кожне непарне число, більше ніж <code>10</code> на <code>"BANG!"</code>, та кожне непарне, що меньше ніж <code>10</code> на <code>"BOOM!"</code>. Якщо число не непарне, ми відкидаємо його зі списку. Для зручності ми покладемо цю осяжність в функцію, так що ми можемо легко використовувати її декілька раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">boomBangs</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">&quot;BOOM!&quot;</span> <span class="kr">else</span> <span class="s">&quot;BANG!&quot;</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Остання частина осяжності є предикат. Функція <code>odd</code> повертає <code>True</code> на непарних числах, та <code>False</code> на парних. Елемент включається в список тільки якщо всі його предикати обчислюються до <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boomBangs</span> <span class="p">[</span><span class="mi">7</span><span class="o">..</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо включити декілька предикатів. Якщо ми бажаємо всі числа від <code>10</code> до <code>20</code>, що не є <code>13</code>, <code>15</code> або <code>19</code>, ми робимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">19</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не тільки можете мати декілька предикатів в осяжностях списків (елемент має задовільняти всім предикатам щоб бути включеним в результуючий список), ми також можемо вибирати з декількох списків. Коли здаєте з кількох списків, осяжність продукує всі комбінації з наданих списків, та потім поєднує їх в вихідній функції, яку ми надаємо. Список, вироблений осяжністю, що вибирає з двох списків довжиною <code>4</code>, буде мати довжину <code>16</code>, якщо вважати, що ми нічого не фільтруємо. Якщо ми маємо два списки, <code>[2,5,10]</code> та <code>[8,10,11]</code>, та бажаємо спродукувати всі можливі комбінації між числами в ціх списках, ось як ми це робимо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як очікувалось, довжина нового списку є <code>9</code>. Що, коли ми бажаємо всі можливі добутки, що більші за <code>50</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо осяжності списку, що комбінує список прикметників та список іменників … заради епічної втіхи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nouns</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;hobo&quot;</span><span class="p">,</span><span class="s">&quot;frog&quot;</span><span class="p">,</span><span class="s">&quot;pope&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adjectives</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="s">&quot;grouchy&quot;</span><span class="p">,</span><span class="s">&quot;scheming&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">adjective</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">noun</span> <span class="o">|</span> <span class="n">adjective</span> <span class="ow">&lt;-</span> <span class="n">adjectives</span><span class="p">,</span> <span class="n">noun</span> <span class="ow">&lt;-</span> <span class="n">nouns</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;lazy hobo&quot;</span><span class="p">,</span><span class="s">&quot;lazy frog&quot;</span><span class="p">,</span><span class="s">&quot;lazy pope&quot;</span><span class="p">,</span><span class="s">&quot;grouchy hobo&quot;</span><span class="p">,</span><span class="s">&quot;grouchy frog&quot;</span><span class="p">,</span>
<span class="s">&quot;grouchy pope&quot;</span><span class="p">,</span><span class="s">&quot;scheming hobo&quot;</span><span class="p">,</span><span class="s">&quot;scheming frog&quot;</span><span class="p">,</span><span class="s">&quot;scheming pope&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Я знаю! Давайте напишемо свою власну версію <code>length</code>! Ми назвемо її <code>length'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">length&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span> <span class="o">|</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>_</code> означає, що нам байдуже, що ми витягнули зі списку, так що замість писати ім'я змінної, що ніколи не буде використовуватись, ми просто пишемо _. Ця функція заміняє кожний елемент в списку на <code>1</code>, та потім підсумовує їх. Це означає, що отримана сума буде рівною довжині нашого списка.</p></div>
<div class="paragraph"><p>Просто дружнє нагадування: оскільки рядки є списками, ми можемо використовувати осяжності списків для обробки та продукування рядків. Ось функція, що бере рядок, та видаляє будь-що, за винятком великих літер.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Testing it out:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;Hahaha! Ahahaha!&quot;</span>
<span class="s">&quot;HA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;IdontLIKEFROGS&quot;</span>
<span class="s">&quot;ILIKEFROGS&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут предикат робить всю роботу. Він каже, що символи будуть включені в новий список, тільки якщо вони є елементами списку <code>['A'..'Z']</code>. Вкладені осяжності списків також можливі, якщо ви оперуєте зі списками, що містять списки. Список містить декілька списків чисел. Давайте видалимо всі непарні числа без вирівнювання списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xxs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span> <span class="p">]</span> <span class="o">|</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">xxs</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете записувати осяжності списків на декількох рядках. Так що якщо ви не в GHCI, краще розділити довші осяжності списків на декілька рядків, особливо якщо вони вкладені.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/tuples.png" alt="images/tuples.png" />
</span>
В деякий спосіб тапли як списки — вони є спосіб зберігати декілька значень в одному значенні. Але є декілька фундаментальних відмінностей. Список чисел є список чисел. Це його тип, і не має значення, чи він має лише одне число в собі, або безкінечне іисло чисел. Однак тапли використовуються, коли ви напевне знаєте, скільки значень ви бажаєте скомбінувати, та їх тип залежить від того, як багато компонент, та який їх тип. Вони позначаються дужками, та їх компоненти розділені комами.</p></div>
<div class="paragraph"><p>Інша ключова відмінність в тому, що вони не мають бути гомогенними. На відміну від списків, тапл може містити комбінацію декількох типів.</p></div>
<div class="paragraph"><p>Подумайте про те, як ми представляємо дво-вимірний вектор в Haskell. Один спосіб може бути список. Це має деяк робити. То що, якщо ми бажаємо покласти пару векторів в список, щоб представляти точки фігури на дво-мірній площині? Ми маємо зробити щось таке: <code>[[1,2],[8,11],[4,5]]</code>. Проблема з цім методом в тому, що ми також можемо робити такі речі: <code>[[1,2],[8,11,5],[4,5]]</code>, з чим Haskell не матиме проблем, бо це також список списків з числами, але це щось таке, що не має сенсу. Але тапл розміром два (що також має назву <code>pair</code>) є власним типом, що означає, що список не може мати декілька пар, і потім <code>triple</code> (тапл розміром три), так що давайте краще використовувати пари. Замість оточувати вектори квадратними дужками, ми використовуємо дужки: <code>[(1,2),(8,11),(4,5)]</code>. Що, коли ми спробуємо зробити фігуру як <code>[(1,2),(8,11,5),(4,5)]</code>? Гаразд, ми отримаємо таку помилку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]</code></pre>
</div></div>
<div class="paragraph"><p>Це каже нам, що ми спробували використовувати пару та трійку в одному списку, що не мало б статись. Ви також не можете зробити список як <code>[(1,2),("One",2)]</code>, оскільки перший елемент в списку є парою чисел, і другий елемент є парою, що складається з рядка та числа. Тапли також можуть використовуватись для представлення широкого різноманіття даних. Наприклад, якщо ми бажаємо представити чиєсь ім'я і вік в Haskell, ми можемо використовувати <code>triple</code>: <code>("Christopher", "Walken", 55)</code>. Як бачимо в цьому прикладі, тапли також можуть містити списки.</p></div>
<div class="paragraph"><p>Використовуйте тапли, коли ви знаєте заздалегідь, як багато компонент буде мати деякий шматок даних. Тапли значно більш обмежені, оскільки кожни інший розмір тапла є власним типом, так що ви не можете написати загальну функцію для додавання елементу до тапла — ви маєте писати функцію для додавання до пари, одну функцію для додавання до трійці, одну для додавання до четвірки і так далі.</p></div>
<div class="paragraph"><p>Хоча є списки синглтони, немає такої речі як синглтон тапл. Це не має багато сенсу, якщо ви поміркуєте про це. Синглтон тапл є тільки значення, що він містить, і це не дає нам жодних переваг.</p></div>
<div class="paragraph"><p>Як списки, тапли можуть бути порівняні один з одним, якщо їх компоненти можуть бути порівняні. Ви не можете порівняти два тапла різного розміру, хоча ви можете порівняти два списки різного розміру. Дві корисні функції для операцій на парах:</p></div>
<div class="paragraph"><p><code>fst</code> бере пару, та повертає перший компонент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">8</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="s">&quot;Wow&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>snd</code> бере пару, та повертає другий компонент. Сюрприз!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">11</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: ці функції оперують тільки на парах. Вони не працюватимуть на трійках, четвірках, п'ятірках, тощо. Ми дійдемо до отримання даних з таплів в різний спосіб трохи пізніше.</p></div>
<div class="paragraph"><p>Крута функція, що продукує список пар: <code>zip</code>. Вона приймає список з двох списків, та потім поєднує їх разом в один список, через поєднання елементів з одним індексом в пари. Це насправді проста функція, але вона має безліч застосувань. Вона особливо корисна, коли ви бажаєте скомбінувати два списки в цей спосіб, або пересуватись по обох списках одночасно. Ось демонстрація.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">,</span> <span class="s">&quot;five&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;three&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;four&quot;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;five&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це спаровує елементи та продукує новий список. Перший елемент з першим, другий з другим, і так далі. Зауважте, що оскільки пари можуть мати різні типи в собі, <code>zip</code> може приймати два списка, що містять різні типи, та поєднати їх разом. Що трапиться, якщо довжина списків не співпаде?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;im&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;im&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Довший список просто буде обрізаний, щоб співпадати по довжині з коротшим. Оскільки Haskell лінивий, ми можемо поєднувати скінчені списки з безкінечними списками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;cherry&quot;</span><span class="p">,</span> <span class="s">&quot;mango&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;apple&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;orange&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;cherry&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;mango&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/pythag.png" alt="images/pythag.png" />
</span>
Ось проблема, що поєднує тапли та осяжності списків: який правильний трикутник, що має цілими всі сторони, і всі сторони меньше або рівні <code>10</code>, має периметр <code>24</code>? Перше, давайте спробуємо генерувати всі трикутники, зі сторонами меньшими ніж <code>10</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">triangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми тільки но тягнемо з трьох списків, і наша вихідна функція є поєднання їх в трійцю. Якщо ви обчислите це, набравши <code>triangles</code>  в GHCI, ви отримаєте список всіх можливих трикутників зі сторонами довжиною <code>10</code> або меньше. Далі ми додамо умову, щоб всі вони були правильними трикутниками. Ми також будемо модифікувати цю функцію, приймаючи до уваги, що сторона <code>b</code> не більша за гіпотенузу, і що сторона <code>a</code> не більша за сторону <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми майже скінчили. Тепер ми тільки модифікуємо функцію, сказавши, що ми бажаємо тільки коли периметр дорівнює <code>24</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles&#39;</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">24</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">rightTriangles&#39;</span>
<span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>А ось і відповідь! Це загальних шаблон функціонального програмування. Ви берете стартовий набір рішень, та потім ви застосовуєте трансформації до ціх рішень, та фільтруєте їх, доки ви не отримаєте потрібні.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cow.png" alt="images/cow.png" />
</span>
Раніше ми згадували, що Haskell має статичну систему типів. Тип кожного виразу відомий під час компіляції, що призводить до безпечнішого коду. Якщо ви напишете програму, де ви спробуєте поділити логічний тип на деяке число, вона навіть не скомпілюється. Це добре, бо краще перехоплювати такі помилки під час компіляції, замість отримати крах вашої програми. Все в Haskell має тип, так що компілятор може міркувати щодо вашої програми, перед тим як скомпілювати її.</p></div>
<div class="paragraph"><p>На відміну від Java або Pascal, Haskell має вивід типів. Якщо ви пишете число, ви не маєте казати Haskell, що це число. Він може вивести це сам, так що нам не треба явно писати типи наших функцій та виразів, щоб все робилось відповідно. Ми розглянули деяки з основ Haskell, тільки зверньо поглянувши на типи. Однак розуміння системи типів є дуже важливою частиною в вивченні Haskell.</p></div>
<div class="paragraph"><p>Тип є різновидом мітки, що має кожен вираз. Він каже нам, до якої категорії речей належить вираз. Вираз <code>True</code> є логічним, <code>"hello"</code> є рядком, тощо.</p></div>
<div class="paragraph"><p>Зараз ми будемо використовувати GHCI для перевірки типів деяких виразів. Ми будемо робити це, використовуючи команду <code>:t</code>, яка, якщо стоїть перед валідним виразом, каже його тип. Дамо йому вир.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="sc">&#39;a&#39;</span>
<span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">True</span>
<span class="kt">True</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="s">&quot;HELLO!&quot;</span>
<span class="s">&quot;HELLO!&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bomb.png" alt="images/bomb.png" />
</span>
Тут ми бачимо, що робити <code>:t</code> на виразі друкує вираз, за яким іде <code>::</code> та його тип. <code>::</code> читається як "має певний тип". Явні типи завжди позначаються першою літерою верхнього реєству. <code>'a'</code>, як можна бачити, має тип <code>Char</code>. Не важко зробити висновок, що це позначає символ. <code>True</code> має тип <code>Bool</code> (логічний тип, названий за розробником логічної алгебри предикатів, Буля. прим.перекл). Це має сенс. Але що це? Дослідження типу <code>"HELLO!"</code> дає <code>[Char]</code>. Квадратні дужки позначають список. Так що ми читаємо це як список символів. На відміну від списків кожна довжина таплу має власний тип. Так що вираз <code>(True, 'a')</code> має тип <code>(Bool, Char)</code>, тоді як вираз як <code>('a','b','c')</code> матиме тип <code>(Char, Char, Char)</code>. <code>4 == 5</code> завжди повертатиме <code>False</code>, так що його тип <code>Bool</code>.</p></div>
<div class="paragraph"><p>Функції також мають типи. Коли ми пишемо власні функції, ми можемо обрати надавати їм явні декларації типів. Це загалом розглядається як гарна практика, за винятком коли ми пишемо дуже малі функції. Звідси і надалі ми надаватимемо функції, що мають явні декларації типів. Згадайте осяжності списків, що ми робили до цього, що фільтрували рядки, що мають лише великі літери? Ось як це виглядає з декларацією типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>removeNonUppercase</code> має тип <code>[Char] -&gt; [Char]</code>, що каже, що вона відзеркалює рядок на рядок. Це тому, що вона бере один рядок як параметр, та повертає інший як результат. Тип <code>[Char]</code> є синонімом до <code>String</code>, так що буде яснішим, якщо ми напишемо <code>removeNonUppercase    \:\: String -&gt; String</code>. Ми не маємо надавати цій функції декларацію типу, оскільки компілятор може вивести це самостійно, що це функція рядка до рядка, ала ми зробили це все одно. Але як записати тип функції, що приймає декілька параметрів? Ось проста функція, що приймає три цілі та складає їх разом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addThree</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри розділені позначкою <code>-&gt;</code>, і немає особливої різниці між параметрами та типом повернення. Тип повернення є останнім елементом в декларації, та параметри перші три. Пізніше ми побачимо, чому вони всі розділені <code>-&gt;</code>, замість мати деякий більш явний спосіб розрізнення між типом повернення та параметрами, як <code>Int, Int, Int -&gt; Int</code>, або щось таке.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте надати вашій функції декларацію типу, але не впевнені, що це має бути, ви можете тільки написати функцію без нього, та потім перевірити її за допомогою <code>:t</code>. Функції також є виразами, так що <code>:t</code> робить на них без проблем.</p></div>
<div class="paragraph"><p>Ось огляд деяких загальних типів.</p></div>
<div class="paragraph"><p><code>Int</code> означає цілі. Він використовується для цілих чисел. <code>7</code> може бути <code>Int</code>, але <code>7.2</code> ні. <code>Int</code> обмежене, що означає, що вони мають мінімум та максимальне значення. Зазвичай на 32-бітних машинах максимально можливе <code>Int</code> є <code>2147483647</code>, та мінімальне є <code>-2147483648</code>.</p></div>
<div class="paragraph"><p><code>Integer</code> позначає також, хм … також ціле. Головна різниця в тому, що він не прив'язаний до меж, і він може використовуватись для представлення насправді великих чисел. Я маю на увазі що дійсно великіх. Однак <code>Int</code> більш ефективний.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">factorial</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">factorial</span> <span class="mi">50</span>
<span class="mi">30414093201713378043612608166064768844377641568960512000000000000</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Float</code> є дійсне плаваюче з одинарною точністю.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">circumference</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference</span> <span class="mf">4.0</span>
<span class="mf">25.132742</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Double</code> є дійсне плаваюче з подвійною точністю!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference&#39;</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">circumference&#39;</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference&#39;</span> <span class="mf">4.0</span>
<span class="mf">25.132741228718345</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Bool</code> є логічний тип. Він може мати тільки два значення: <code>True</code> та <code>False</code>.</p></div>
<div class="paragraph"><p><code>Char</code> представляє символ. Він позначається поодинокими лапками. Список символів є рядком.</p></div>
<div class="paragraph"><p>Тапли є типами, але вони залежні від своєї довжини, так само, як і від типів своїх компонентів, так що теоретично є безліч типів таплів, що забагато, щоб накрити в цьому туторіалу. Зауважте, що порожній тапл <code>()</code> також є типом, що може мати одне значення: <code>()</code>.</p></div>
<div class="paragraph"><p>Який, як ви думаєте, є тип функції <code>head</code>? Оскільки <code>head</code> приймає список любого типу, та повертає перший елемент, то що це має бути? Давайте перевіримо!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">head</span>
<span class="nf">head</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/box.png" alt="images/box.png" />
</span>
Хмм! Що є це <code>a</code>? Чи це є тип? Згадайте, що дотепер ми стверджували, що типи записуються з великої літери, так що це не може в точності бути типом. Оскільки це не велика літера, це насправді змінна типу. Це значить, що це може бути любий тип. Це здебільшого як дженеріки в інших мовах, але в Haskell це значно більш потужне, оскільки це дозволяє нам просто писати любі загальні функції, тільки якщо вони не використовують деяку особливу специфічну поведінку на типах в своєму складі. Функції, що мають змінні типів, називаються поліморфними функціями. Декларація типу <code>head</code> стверджує, що вона приймає список любого типу, та повертає один елемент цього типу.</p></div>
<div class="paragraph"><p>Хоча змінні типів можуть мати ім'я, довші за один символ, ми зазвичай даємо їм імена <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p></div>
<div class="paragraph"><p>Пам'ятаєте <code>fst</code>? Він повертає перший компонент з пари. Давайте дослідимо його тип.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fst</span>
<span class="nf">fst</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми бачимо, що <code>fst</code> бере тапл, що має два типи, і повертає елемент, чий тип такий самий, що і тип першого компонента з пари. Ось чому ми можемо використовувати <code>fst</code> на парі, що містить два довільні типи. Зауважте, що тільки через те, що <code>a</code> та <code>b</code> є різними змінними типів, вони не мають бути різними типами. Це типами стверджує, що тип першого компоненту та тип значення повернення є тим самим.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/classes.png" alt="images/classes.png" />
</span>
Типоклас є деяким різновидом інтерфейсу, що визначає деяку поведінку. Якщо тип є частиною типокласу, це означає, що він підтримує та реалізує поведінку, яку описує типоклас. Багато людей, що приходять з OOP, спантеличені типокласами, бо вважають їх подібними до класів в об'єктно орієнтовних мовах. Гараз, це не так. Ви можете думати про них, як про різновид Java інтерфейсів, тільки кращіх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
<span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: оператор еквівалентності <code>==</code> є функцією. Так само, як <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, та майже всі інші оператори. Якщо функція складається тільки зі спеціальних символів, вона розглядається як інфіксна функція по замовчанню. Якщо ми бажаємо перевірити її тип, передати її до іншої функції, або викликати як префіксну функцію, ми маємо оточити її дужками.</p></div>
<div class="paragraph"><p>Цікаво. Ми бачимо тут нову річ, символ <code>=&gt;</code>. Все перед символом <code>=&gt;</code> має назву класової константи. Ми можемо прочитати попередню декларацію типу таким чином: Функція еквівалентності бере два значення, що мають однаковий тип, та повертає <code>Bool</code>. Тип ціх значень мусить бути типом класу <code>Eq</code> (це була класова константа).</p></div>
<div class="paragraph"><p>Типоклас <code>Eq</code> провадить інтерфейс для перевірки на рівність. Кожний клас, коли має сенс перевірка на рівність між двома елементами для цього типу, мав би бути членом класу <code>Eq</code>. Всі стандартні типи Haskell, за винятком IO (тип для роботи з вводом та виводом), та функції є частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Функція <code>elem</code> має тип <code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>, оскільки він використовує <code>==</code> по списку, щоб перевірити, чи деяке значення, яке ми шукаємо, знаходиться в списку.</p></div>
<div class="paragraph"><p><code>Eq</code> використовується для типів, що підтримують перевірку на рівність. Функції, що реалізують його члени є <code>==</code> та <code>/=</code>. Так що якщо є обмеження класу <code>Eq</code> для змінної типу в функції, вона використовує <code>==</code> або <code>/=</code> десь в своїй декларації. Всі типи, що ми згадували до цього, за винятком функцій, є частинами <code>Eq</code>, так що вони можуть бути перевірені на рівність.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">==</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Ho Ho&quot;</span> <span class="o">==</span> <span class="s">&quot;Ho Ho&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mf">3.432</span> <span class="o">==</span> <span class="mf">3.432</span>
<span class="kt">True</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Ord</code> призначений для типів, що мають впорядкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі типи, що ми розглядали досі, за винятком функцій, є частиною <code>Ord</code>. <code>Ord</code> покриває всі стандартні функції порівняння, такі як <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> та <code>&lt;=</code>. Функції порівнянь беруть два члени <code>Ord</code> того самого типу, і повертають впорядкування <code>Ordering</code>. <code>Ordering</code> є типом, що може бути <code>GT</code>, <code>LT</code> або <code>EQ</code>, що відповідно означає більше ніж, меньше ніж, або дорівнює.</p></div>
<div class="paragraph"><p>Щоб бути членом <code>Ord</code> тип має зпочатку мати членство в престижному та ексклюзивному клубі <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="o">&lt;</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">3</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Show</code> можуть бути представлені як рядкі. Всі типи, що розглядались досі, за винятком функцій, є частиною <code>Show</code>. Найбільш уживана функція, що має справу з типокласом <code>Show</code> є <code>show</code>. Вона бере значення, чий тип є членом <code>Show</code>, та представляє його нам як рядок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">3</span>
<span class="s">&quot;3&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mf">5.334</span>
<span class="s">&quot;5.334&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">True</span>
<span class="s">&quot;True&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Read</code> є дещо протилежним типокласом до <code>Show</code>. Функція <code>read</code> бере рядок, та повертає тип, який є членом <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;True&quot;</span> <span class="o">||</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;8.2&quot;</span> <span class="o">+</span> <span class="mf">3.8</span>
<span class="mf">12.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="o">-</span> <span class="mi">2</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Доки досить. Знову, всі типи, розглянуті до сих пір, знаходяться в цьому типокласі. Але що відбудеться, якщо ми тільки зробимо <code>read "4"</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;4&quot;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
      <span class="p">`</span><span class="kt">Read</span> <span class="n">a&#39;</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">7</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що GHCI тут нам каже, це те, що він не знає, що ми бажаємо повернути. Зауважте, що в попередніх використаннях <code>read</code> ми робили дещо з результатом після цього. Таким чином, GHCI міг вивести, який тип результату ми бажали від <code>read</code>. Якщо ми б використовували це як логічне, він би знав, що треба повертати <code>Bool</code>. Але тепер він знає, що ми бажаємо деякий тип, що є частиною класу <code>Read</code>, він тільки не знає, який саме. Давайте поглянемо на сигнатуру типу <code>read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите? Він повертає тип, що є частиною <code>Read</code>, але якщо ми потім не спробуємо використати його якось далі, немає шляху дізнатись, що саме цей тип. Ось чому ми можемо використовувати явні анотації типів. Анотації типів є шлях явно сказати, яким має бути тип виразу. Ми робимо це, додаючи <code>::</code> наприкінці виразу, та потім вказавши тип. Дивіться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;(3, &#39;a&#39;)&quot;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість виразів такі, що компілятор може вивести їх тип самотужки. Але іноді компілятор не знає, чи треба повертати значення типу <code>Int</code> або <code>Float</code> для виразів як <code>read "5"</code>. Щоб побачити, який тип є насправді, Haskell мав би насправді обчислити <code>read "5"</code>. Але оскільки Haskell є статично типізованою мовою, він має знати всі типи перед компіляцією кода (або в випадку GHCI, обчисленням). Так що ми маємо сказати Haskell: "Йо, цей вираз має бути такого типу, в випадку якщо ти не знаєш!".</p></div>
<div class="paragraph"><p><code>Enum</code> члени є послідовно впорядкованими типами — вони можуть бути перелічені. Головна перевага типокласу <code>Enum</code> в тому, що ми можемо використовувати його типи як диапазони списків. Вони також мають визначені попередників та послідовників, що ви можете отримати функціями <code>succ</code> та <code>pred</code>. Типи в цьому класі: <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> та <code>Double</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;e&#39;</span><span class="p">]</span>
<span class="s">&quot;abcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">LT</span> <span class="o">..</span> <span class="kt">GT</span><span class="p">]</span>
<span class="p">[</span><span class="kt">LT</span><span class="p">,</span><span class="kt">EQ</span><span class="p">,</span><span class="kt">GT</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="sc">&#39;B&#39;</span>
<span class="sc">&#39;C&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Bounded</code> мають верхню та нижню межу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="o">-</span><span class="mi">2147483648</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>minBound</code> та <code>maxBound</code> є цікаві, бо вони мають тип <code>(Bounded a) =&gt; a</code>. В деякому сенсі вони є поліморфними константами.</p></div>
<div class="paragraph"><p>Всі тапли також є частиною <code>Bounded</code>, якщо в ньому також їх компоненти.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">,</span><span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Num</code> є числовим типокласом. Його члени мають властивість діяти як числа. Давайте дослідимо тип числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">20</span>
<span class="mi">20</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Виглядає так, що цілі числа також є поліморфними константами. Вони можуть діяти як любий тип, що є членом типокласу <code>Num</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Double</span>
<span class="mf">20.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це ті типи, що належать до типокласа <code>Num</code>. Якщо ми перевіримо тип <code>*</code>, ми побачимо, що він приймає всі числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Він приймає всі числа того самого типу, та повертає число того ж типу. Ось чому <code>(5 :: Int) * (6 :: Integer)</code> призведе до посилки типу, тоді як `5 * (6 
</dt>
<dd>
<p>
Integer)` буде робити досить добре, та спродукує <code>Integer</code>, оскільки <code>5</code> може діяти як <code>Integer</code> або <code>Int</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Щоб поєднати <code>Num</code>, тип має вже бути друзями з <code>Show</code> та <code>Eq</code>.</p></div>
<div class="paragraph"><p><code>Integral</code> є також числовим типокласом. <code>Num</code> включає всі числа, включаючи дійсні числа та цілі числа, <code>Integral</code> включає тільки цілі числа. В цьому типокласі <code>Int</code> та <code>Integer</code>.</p></div>
<div class="paragraph"><p><code>Floating</code> включає тільки числа з плаваючою крапкою, <code>Float</code> та <code>Double</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дуже корисна функція для справ з числами є <code>fromIntegral</code>. Вона має декларацію типу <code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. З цієї декларації типів ми бачимо, що він приймає ціле число, та перетворює його в більш загальне число. Це корисно, коли ви бажаєте, щоб цілі та з плаваючою крапкою гарно робили поспіль. Наприклад, функція <code>length</code> має декларацію типу <code>length :: [a] -&gt; Int</code>, замість мати більш загальний тип `(Num b) &#8658; length 
</dt>
<dd>
<p>
[a] &#8594; b`. Я думаю, це має історичні причини або щось таке, хоча, як до мене, це дурниці. В жодному разі, якщо ви отримаєте довжину списку, та потім додасте її до <code>3.2</code>, ми отримаємо помилку, бо ми намагались додати разом <code>Int</code> та число з плаваючою крапкою. Щоб уникнути цього ми робимо <code>fromIntegral (length [1,2,3,4]) + 3.2</code>, і тоді це буде робити.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що <code>fromIntegral</code> має декілька класових обмежень в своїй сигнатурі типу. Це повністю валідне, та як ви можете бачити, обмеження класів відокремлені комами в дужках.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/pattern.png" alt="images/pattern.png" />
</span>
Ця глава дослідить деякі з крутих синтаксичних конструкцій Haskell, і ми почнемо зі співпадіння шаблонів. Співпадіння шаблонів складається з вказання шаблонів, яким мають відповідати деякі дані, та потім перевірити, чи це так, та деконструювати дані відповідно до ціх шаблонів.</p></div>
<div class="paragraph"><p>Коли визначаєте функції, ви можете визначити окремі тіла функції для різних шаблонів. Це призводить до дійсно милого коду, що простий та читається. Ви можете перевіряти шаблони на кожному типі — числах, символах, списках, таплах, тощо. Давайте зробимо насправді тривіальну функцію, що перевіряє, чи надане нами число сімка, або ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">lucky</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lucky</span> <span class="mi">7</span> <span class="ow">=</span> <span class="s">&quot;LUCKY NUMBER SEVEN!&quot;</span>
<span class="nf">lucky</span> <span class="n">x</span> <span class="ow">=</span> <span class="s">&quot;Sorry, you&#39;re out of luck, pal!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми викликаємо <code>lucky</code>, шаблони будуть перевірятись згори донизу, і коли шаблон буде задовільнятись, відповідне тіло буде використовуватись. Єдиний спосіб, як число може задовільніти першому шаблону - якщо це <code>7</code>. Якщо ні, керування провалюється до другого шаблону, що співпадає з будь чим, та прикріпляє його до <code>x</code>. Ця функція також може бути реалізованою через використання твердження <code>if</code>. Але що, коли ми бажаємо функцію, що каже числа від <code>1</code> до <code>5</code>, та каже "Not between 1 and 5" для любого іншого числа? Без співпадіння шаблоній ми будемо швидко втягнуті в дерево <code>if then else</code>. Однак з шаблонами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sayMe</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">sayMe</span> <span class="mi">1</span> <span class="ow">=</span> <span class="s">&quot;One!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">2</span> <span class="ow">=</span> <span class="s">&quot;Two!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">3</span> <span class="ow">=</span> <span class="s">&quot;Three!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">4</span> <span class="ow">=</span> <span class="s">&quot;Four!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">5</span> <span class="ow">=</span> <span class="s">&quot;Five!&quot;</span>
<span class="nf">sayMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="s">&quot;Not between 1 and 5&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо ми перемістмо останній шаблон (спіймати все) догори, він завжди буде казати "Not between 1 and 5", оскільки він буде ловити всі числа без шансу провалитись, та перевірити всі інші шаблони.</p></div>
<div class="paragraph"><p>Згадайте функцію факторіала, що ми реалізували до цього? Ми визначали <code>factorial</code> числа <code>n</code> як добуток <code>[1..n]</code>. Ми також можемо визначити функцію факториала рекурсивно, спосіб, що зазвичай використовується в математиці. Ми починаємо, кажучи що факторіал <code>0</code> є <code>1</code>. Потім ми кажемо, що факторіал любого позитивного цілого є це ціле, помножене на факторіал свого попередника. Ось як це виглядає, перекладене в терміни Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">factorial</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">factorial</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це перший раз, коли ми визначили функцію рекурсивно. Рекурсія важлива в Haskell, і пізніше ми поглянемо на неї ближче. Але ось що відбувається, коли ми беремо факторіал, скажімо, <code>3</code>. Він намагаться обчислити <code>3 * factorial 2</code>. Факторіал 2 є <code>2 * factorial 1</code>, так що досі ми маємо <code>3 * (2 * factorial 1)</code>. <code>factorial 1</code> є <code>1 * factorial 0</code>, так що ми маємо <code>3 * (2 * (1 * factorial 0))</code>. Тепер настає час трюку — ми визначили факторіал <code>0</code> як просто <code>1</code>, та оскільки це підпадає під той шаблон, що іде до загального випадка, він просто повертає <code>1</code>. Так що остаточний результат еквівалентний до <code>3 * (2 * (1 * 1))</code>. Якщо б ми написали другий шаблон над першим, він би відловлював всі числа, включаючи 0, і наші обчислення ніколи б не закінчились. Ось чому порядок важливий, коли вкзуєте шаблони, і завжди краще вказувати найбільш специфічні першими, та більш загальні потім.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може схибити. Якщо ми визначимо функцію ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">charName</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">charName</span> <span class="sc">&#39;a&#39;</span> <span class="ow">=</span> <span class="s">&quot;Albert&quot;</span>
<span class="nf">charName</span> <span class="sc">&#39;b&#39;</span> <span class="ow">=</span> <span class="s">&quot;Broseph&quot;</span>
<span class="nf">charName</span> <span class="sc">&#39;c&#39;</span> <span class="ow">=</span> <span class="s">&quot;Cecil&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>та потім спробуємо викликати її маючи на вході щось неочікуване, ось що трапиться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;a&#39;</span>
<span class="s">&quot;Albert&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;b&#39;</span>
<span class="s">&quot;Broseph&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;h&#39;</span>
<span class="s">&quot;*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона скаржиться, що ми маємо невиключні шаблони, і це так і є насправді. При створенні шаблонів нам слідує завжди включати загальні шаблони, так що наша програма не завалиться, якщо ми отримаємо неочікуваний вхід.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може використовувати тапли. Що, коли ми бажаємо створити функцію, що приймає два вектори в 2D просторі (що є в формі пар), та додає їх разом? Щоб додати разом два вектори, ми додаємо їх <code>x</code> компоненти окремо, та потім їх <code>y</code> компоненти окремо. Ось що ми можемо зробити, якщо ви не знаємо про співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addVectors</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">addVectors</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fst</span> <span class="n">a</span> <span class="o">+</span> <span class="n">fst</span> <span class="n">b</span><span class="p">,</span> <span class="n">snd</span> <span class="n">a</span> <span class="o">+</span> <span class="n">snd</span> <span class="n">b</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, це робить, але існує кращий шлях, щоб зробити це. Давайте модифікуємо функцію, так щоб вона використовувала співпадіння шаблонів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addVectors</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">addVectors</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="p">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ось так! Значно краще. Зауважте, що це все ще загальний шаблон. Тип <code>addVectors</code> (в обох випадках) є `addVectors 
</dt>
<dd>
<p>
(Num a) &#8658; (a, a) &#8594; (a, a) - &gt; (a, a)`, так що ми гарантовано отримуємо дві пари як параметри.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>fst</code> та <code>snd</code> виділяють компоненти з пар. Але що з трійками? Гаразд, немає готової функції, щоб зробити це, але ми можемо створити власну.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">first</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">first</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">second</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">second</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">y</span>

<span class="nf">third</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">third</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Знак <code>_</code> означає ту саму річ, що він робить в осяжностях списків. Це означає, що насправді нам байдуже, що є в цій частині, так що пи просто пишемо <code>_</code>.</p></div>
<div class="paragraph"><p>Що нагадує мені, що ви також можете робити співпадіння в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли співпадіння схибить, він буде тільки переходити на наступний елемент.</p></div>
<div class="paragraph"><p>Самі списки також можуть використовуватись в співпадінні шаблонів. Ви можете порівнювати з порожнім списком <code>[]</code>, або любим шаблоном, що включає <code>:</code> та порожній список. Але оскільки <code>[1,2,3]</code> є тільки синтаксичним цукром для <code>1:2:3:[]</code>, ви також можете використовувати і такий шаблон. Шаблон як <code>x:xs</code> буде прикріпляти голову списку до <code>x</code>, та залишок до <code>xs</code>, навіть якщо був один елемент, так що <code>xs</code> в кінці буде порожнім списком.</p></div>
<div class="paragraph"><p>Note: Шаблон <code>x:xs</code> багато використовується, особливо з рекурсивними функціями. Але шаблони, що мають в собі <code>:</code>, співпадають тільки зі списками довжини 1 або більше.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте прикріпити, скажімо, перші три елементи до змінних, та залишок до іншої змінної, ви можете використовувати щось подібне до <code>x:y:z:zs</code>. Це буде співпадати тільки зі списками, що мають три елементи або більше.</p></div>
<div class="paragraph"><p>Тепер ми знаємо, як порівнювати шаблони зі списками, давайте створими нашу власну реалізацію функції <code>head</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;Can&#39;t call head on an empty list, dummy!&quot;</span>
<span class="nf">head&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевіримо, чи вона робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head&#39;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">4</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head&#39;</span> <span class="s">&quot;Hello&quot;</span>
<span class="sc">&#39;H&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарно! Зауважте, що якщо ви бажаєте прикріпити декілька змінних (навіть якщо одна з них просто <code>_</code>, та взагалі нічого не прикріплює), ми маємо оточити їх в дужки. Також зауважте функцію <code>error</code>, яку ми використовуємо. Вона приймає рядок та генерує помилку часу виконання, використовуючи рядок як інформацію щодо різновиду виникшої помилки. Це призводить до падіння програми, так що недобре використовувати її дуже багато. Але виклик <code>head</code> на порожньому списку не має сенсу.</p></div>
<div class="paragraph"><p>Давайте створимо тривіальну функцію, що каже нам перші елементи списку в зручній англійській формі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">tell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tell</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="s">&quot;The list is empty&quot;</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:[]</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The list has one element: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:[]</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The list has two elements: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;This list is long. The first two elements are: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція безпечна, оскільки вона турбується про порожній список, список синглтон, список з двома елементами, та списки з більше двох елементів. Зауважте, що <code>(x:[])</code> та <code>(x:y:[])</code> можуть бути переписані як <code>[x]</code> та <code>[x,y]</code> (завдяки синтаксичному цукру нам не потрібні дужки). Ми не можемо переписати <code>(x:y:_)</code> з квадратними дужками, оскільки він співпадає зі списком довжини 2 або більше.</p></div>
<div class="paragraph"><p>Ми вже реалізовали нашу власну функцію <code>length</code> використовуючи осяжність списків. Тепер ми зробимо це, використовуючи співпадіння шаблонів та трохи рекурсії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">length&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">length&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">length&#39;</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Це подібно до функції <code>factorial</code>, що ми писали раніше. Спочатку ми визначили результат для відомого входу — порожнього списку. Це також відомо як гранична умова. Потім в другому шаблоні ми розбиваємо список на частки, відділяючи голову та хвіст. Ми кажемо, що довжина дорівнює 1 плюс довжина хвоста. Ми використовуємо <code>_</code> для співпадіння з головою, оскільки нам насправді байдуже, що це. Також зауважте, що ми потурбувались про всі можливі шаблони для списку. Перший шаблон співпадає з порожнім списком, та другий співпадає з будь чим, що не є порожнім списком.</p></div>
<div class="paragraph"><p>Давайте подивимось, що коли ми викличемо <code>length'</code> на <code>"ham"</code>. Спочатку ми перевіримо, чи це порожній список, і через те, що це не так, ми провалимось до другого шаблону. Це співпадає з другим шаблоном, і каже, що довжина є <code>1 + length' "am"</code>, оскільки ми розбили рядок на голову і хвіст, та відкинули голову. Гаразд. Довжина <code>length'</code> від <code>"am"</code> подібним чином є <code>1 + length' "m"</code>. Так що прямо зараз ми маємо <code>1 + (1 + length' "m")</code>. <code>length' "m"</code> є <code>1 + length' ""</code> (також можна записати як <code>1 + length' []</code>). І ми визначили <code>length' []</code> як <code>0</code>. Так що в кінці ми маємо <code>1 + (1 + (1 + 0))</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо <code>sum</code>. Ми знаємо, що сума порожнього списку є 0. Запишемо це в вигляді шаблону. І ми також знаємо, що сума списку є голова, плюс сума залишку списку. Коли ми запишемо все це, ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sum&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є така річ, що називається <code>as</code> шаблонами. Це зручний спосіб розбити щось відповідно до шаблону, та прикріпити частки до імен, при цьому зберігаючи посилання на цілу річ. Ви робите це, покладаючи ім'я та знак <code>@</code> перед шаблоном. Наприклад, шаблон <code>xs@(x:y:ys)</code>. Цей шаблон буде співпадати точно з тією самою річчю, що і <code>x:y:ys</code>, але ви можете просто отримати цілий список через <code>xs</code>, замість повторювати себе через повторний набір <code>x:y:ys</code> в тілі функції. Ось швидкий та брудний приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">capital</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">capital</span> <span class="s">&quot;&quot;</span> <span class="ow">=</span> <span class="s">&quot;Empty string, whoops!&quot;</span>
<span class="nf">capital</span> <span class="n">all</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The first letter of &quot;</span> <span class="o">++</span> <span class="n">all</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">capital</span> <span class="s">&quot;Dracula&quot;</span>
<span class="s">&quot;The first letter of Dracula is D&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно ми використовуємо шаблони щоб уникнути повторення себе, коли порівнення з більшим шаблоном, коли ми використовуємо цілу річ в тілі функції.</p></div>
<div class="paragraph"><p>Ще одна річ — ви не можете використовувати <code>++</code> в співпадіннях шаблонів. Якщо ви спробуєте порівняти шаблон з <code>(xs ++ ys)</code>, що буде першим списком, та що буде другим списком? Це не має великого сенсу. Буде мати сенс порівняти з <code>(xs ++ [x,y,z])</code> або просто <code>(xs ++ [x])</code>, але завдяки природі списків ви не можете зробити цього.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/guards.png" alt="images/guards.png" />
</span>
В той час, коли шаблони є шляхом переконатись, що значення відповідає деякій формі, та деконструкції, охоронці є шляхом перевірити, чи деяка властивість значення (або декілька з них) є <code>true</code> або <code>false</code>. Це звучить як твердження <code>if</code>, і є дуже подібним. Річ в тому, що охоронці значно легше читаються, коли ви маєте декілька умов, і вони грають добре в команді з шаблонами.</p></div>
<div class="paragraph"><p>Замість пояснення їх синтаксису, давайте просто зануримось, та створимо функцію з використанням охоронців. Ми збираємось створити просту функцію, що кваліфікує вас відповідно до вашого індексу BMI (body mass index). Ваш BMI дорівнює вашій вазі, поділеній на ваш зріст в квадраті. Якщо ваш BMI менший за 18.5, в вас недостатньо ваги. Якщо ви десь між 18.5 до 25, ви відповідаєте нормі. Від 25 до 30 є надмірною вагою, і більше 30 це ожиріння. Так що ось функція (ми не будемо обчислювати прямо зараз, ця функція обчислює BMI та каже результат):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">bmi</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Охоронці позначаються стовпчиками, що слідують за ім'ям функції та її параметрами. Зазвичай вони відступають трохи вправо, та відрівняні між собою. Охоронець в основі є логічний вираз. Якщо він обчислюється до <code>True</code>, тоді використовується відповідне тіло функції. Якщо він обчислюється до <code>False</code>, перевірка переходить до наступного охоронця і так далі. Якщо ми викличемо цю функцію з 24.3, вона спочатку перевірить, чи це меньше або рівне ніж 18.5. Оскільки це ні, переходимо до наступного охоронця. Перевірка каже, що другій охоронець пропускає, бо 24.3 меньше ніж 25.0, і повертається другий рядок.</p></div>
<div class="paragraph"><p>Це дуже нагадує велике дерево з <code>if</code> <code>else</code> в імперативних мовах, тільки це значно краще і гарно читається. Хоча великі дерева <code>if else</code> звичайно не схвалюються, іноді проблема виражена в такий дискретний спосіб, що ви не можете це обійти. Охоронці є гарною альтернативою для цього.</p></div>
<div class="paragraph"><p>Дуже часто останній охоронець є <code>otherwise</code>. <code>otherwise</code> визначене просто як <code>otherwise = True</code>, і відловлює все. Це дуже подібне до шаблонів, тільки вони превірять, чи задовільняє вхід шаблону, а охоронці перевіряють логічні умови. Якщо всі охоронці функції обчислюються до <code>False</code> (і ми не надали загального охоронця <code>otherwise</code>), обчислення провалюється до наступного шаблону. Ось як шаблони та охоронці гарно грають разом. Якщо не знайдено підходящого охоронця або шаблона закидається помилка.</p></div>
<div class="paragraph"><p>Звичайно, ми можемо використовувати охоронців з функціями, що приймають так багато параметрів, як нам треба. Замість того, щоб користувач обчислював власний BMI перед викликом функції, давайте модифікуємо цю функцію, так що вона братиме висоту та вагу, та розрахує все за нас.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>                 <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивимось, чи я гладкий &#8230;</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">bmiTell</span> <span class="mi">85</span> <span class="mf">1.90</span>
<span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау! Я не товстий! Але Haskell все одно назвав мене огидним. Чортзна що!</p></div>
<div class="paragraph"><p>Зауважте, що немає <code>=</code> прямо після імені функції та її параметрами, перед першим охоронцем. Багато новачків отримують синтаксичну помилку, оскільки вони часто ставлять там рівняння.</p></div>
<div class="paragraph"><p>Інший дуже простий приклад: давайте реалізуєма власну функцію <code>max</code>. Якщо ви пам'ятаєте, вона приймає дві речі, що можна порівняти, та повертає більше з них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">max&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">max&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>     <span class="ow">=</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Охоронці можуть бути записані в один рядок, хоча я не раджу цього, оскільки це менш читається, навіть для дуже коротких функцій. Але для демонстрації запишемо <code>max'</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">max&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">max&#39;</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Йо! Не читається взагалі! Рухаємось далі: давайте реалізуємо власну <code>compare</code> через використання охоронців.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">myCompare</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">a</span> <span class="p">`</span><span class="n">myCompare</span><span class="p">`</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>     <span class="ow">=</span> <span class="kt">GT</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>    <span class="ow">=</span> <span class="kt">EQ</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="n">myCompare</span><span class="p">`</span> <span class="mi">2</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: ми не тільки можемо викликати функції інфіксно з апострофами, ми також можемо визначати їх з апострофами. Іноді так їх легше прочитати.</p></div>
<div class="paragraph"><p>В попередньому розділі ми визначили калькулятор BMI таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>                   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що ми повторили себе тут три рази поспіль. Ми повторили себе три рази. Повторити себе (три рази) при програмуванні так само бажано, як вдаритись головою. Оскільки ми повторили вираз три рази, було б ідеальним, щоб ми могли обчислити його один раз, прікріпити до імені, і потім використовувати це ім'я замість виразу. Гаразд, ми можемо модифікувати нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми поклали ключове слово <code>where</code> після охоронців (зазвичай краще відступити так само, як здвинуті риски), та потім ми визначаємо декікька імен або функцій. Ці імена видимі в охоронцях, та дають нам перевагу не мати повторювати самих себе. Якщо ми вирішимо, що треба обчислювати BMI трохи інакше, ми маємо змінити це тільки один раз.  Це також покращує читабельність, надаючи імена речам, і може зробити наші програми видшими, оскільки такі речі, як наша змінна <code>bmi</code>, обчислюються тільки один раз. Ми можемо піти трохи далі, та представити нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">skinny</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">normal</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">fat</span>    <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>     <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
          <span class="n">skinny</span> <span class="ow">=</span> <span class="mf">18.5</span>
          <span class="n">normal</span> <span class="ow">=</span> <span class="mf">25.0</span>
          <span class="n">fat</span> <span class="ow">=</span> <span class="mf">30.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Імена, які ми визначили в розділі <code>where</code> функції, видимі тількі в цій функції, так що ми не маємо турбуватись щодо забруднення простору імен інших функцій. Зауважте, що всі ці імена вирівнені в один стовпчик. Якщо ми не вирівняємо їх гарно і відповідно, Haskell буде засмучений, оскільки він не знатиме, що все це частини одного блоку.</p></div>
<div class="paragraph"><p>Прикріплення <code>where</code> не поділяються між тілами функцій для різних шаблонів. Якщо ви бажаєте, щоб декілька шаблонів однієї функції мали доступ до одного імені, ви маєте визначити його глобально.</p></div>
<div class="paragraph"><p>Ви також можете використовувати прикріплення <code>where</code> до порівняння шаблонів! Ви можете переписати розділ <code>where</code> попередньої функції таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
      <span class="p">(</span><span class="n">skinny</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">fat</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте створимо іншу, досить тривіальну функці, де ми отримуємо перше та останнє ім'я, та повертаємо ініціали.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">initials</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">initials</span> <span class="n">firstname</span> <span class="n">lastname</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">++</span> <span class="s">&quot;. &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">++</span> <span class="s">&quot;.&quot;</span>
    <span class="kr">where</span> <span class="p">(</span><span class="n">f</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>
          <span class="p">(</span><span class="n">l</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо виконати це співпадіння шаблонів прямо в параметрах функції (вона насправді може бути коротшою та яснішою), але це показує тільки те, що це можливо зробити також в прикріпленнях <code>where</code>.</p></div>
<div class="paragraph"><p>Так само, як ми визначали константи в блоках <code>where</code>, ви також можете визначити функції. Дотримуючись нашої здорової теми програмування, давайте створимо функцію, що приймає список пар вага-висота, та повертає список BMI.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="n">w</span> <span class="n">h</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="n">weight</span> <span class="n">height</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось і все, що ми мали сказати про це! Причина, з якої ми мали ввести  <code>bmi</code> як функцію в цьому прикладі, це те, що ми не можемо обчислити один BMI з параметрів функції. Ми маємо перевіряти список, переданий до функції, і тут буде різний BMI для кожної пари.</p></div>
<div class="paragraph"><p><code>where</code> прикріплення також можуть бути вкладені. Це загальна ідіома, створити функцію, і визначити допоміжну функцію в її твердженні <code>where</code>, і потім надати цім функціям допоміжні функції, також, кожна в своєму власному твердженні <code>where</code>.</p></div>
<div class="paragraph"><p>Дуже подібні до <code>where</code> прикріалень є прикріплення <code>let</code>. <code>Where</code> прикріплення є синтаксичною конструкцією, що дозволяє вам прикріпляти змінні в кінці функції, та ціла функція може бачити їх, включаючи всіх охоронців. <code>Let</code> прикріплення дозволяють вам прикріпляти змінні будь де, та самі є виразами, але є дуже локальними, так що вони не поширюються серед охоронців. Так само, як любі конструкції в Haskell, що використовуються для прикріплення значень до імен, <code>let</code> прикріплення можуть використовуватись для співпадінь шаблонів. Давайте подивимось на це дії! Ось як ви можете визначити функцію, що дає нам площу циліндричної поверхні, базуючись на її висоті та радіусі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">cylinder</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">cylinder</span> <span class="n">r</span> <span class="n">h</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">sideArea</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">h</span>
        <span class="n">topArea</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span><span class="mi">2</span>
    <span class="kr">in</span>  <span class="n">sideArea</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">topArea</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/letitbe.png" alt="images/letitbe.png" />
</span>
Форма є <code>let &lt;bindings&gt; in &lt;expression&gt;</code>. Імена дає вам визначити в частині <code>let</code> доступною до виразу в частині <code>in</code>. Як ви можете бачити, ви можете також виразити це як <code>where</code> прив'язку. Зауважте, що імена також вирівняні в один стовпчик. То яка різниця між ціма двома? На тепер виглядає, що <code>let</code> покладає прикріплення першими, та вираз, що використовує їх після, тоді як <code>where</code> робить це навпаки.</p></div>
<div class="paragraph"><p>Різниця в тому, що <code>let</code> прикріплення самі є виразами. <code>where</code> прикріалення є тільки синтаксичніми конструкціями. Згадайте, як ми робили твердження <code>if</code>, та пояснювали, що твердження <code>if else</code> є виразом, і ви можете набивати його маже будь де?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kr">if</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span> <span class="s">&quot;Woo&quot;</span> <span class="kr">else</span> <span class="s">&quot;Boo&quot;</span><span class="p">,</span> <span class="kr">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;</span> <span class="sc">&#39;b&#39;</span> <span class="kr">then</span> <span class="s">&quot;Foo&quot;</span> <span class="kr">else</span> <span class="s">&quot;Bar&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;Woo&quot;</span><span class="p">,</span> <span class="s">&quot;Bar&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="kr">if</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="kr">then</span> <span class="mi">10</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете робити це за допомогою <code>let</code> прикріплень.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">9</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони також можуть бути використані для введення функцій в локальному полі зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kr">let</span> <span class="n">square</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">square</span> <span class="mi">5</span><span class="p">,</span> <span class="n">square</span> <span class="mi">3</span><span class="p">,</span> <span class="n">square</span> <span class="mi">2</span><span class="p">)]</span>
<span class="p">[(</span><span class="mi">25</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми бажаємо прикріпити декілька змінних разом, ми, вочевидь, не можемо вирівняти їх в вигляді стовпчика. Ось чому ми можемо розділити крапками з комою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">c</span> <span class="ow">=</span> <span class="mi">300</span> <span class="kr">in</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kr">let</span> <span class="n">foo</span><span class="ow">=</span><span class="s">&quot;Hey &quot;</span><span class="p">;</span> <span class="n">bar</span> <span class="ow">=</span> <span class="s">&quot;there!&quot;</span> <span class="kr">in</span> <span class="n">foo</span> <span class="o">++</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">(</span><span class="mi">6000000</span><span class="p">,</span><span class="s">&quot;Hey there!&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не маєте ставити крапку з комою після останнього прикріплення, але ви можете це зробити, якщо бажаєте. Як ми казали раніше, ви можете робити порівняння шаблонів з <code>let</code> прикріпленнями. Вони дуже корисні для швидкого розбирання тапла на компоненти, та прикріплення їх до імен, або чогось подібного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">600</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете покласти <code>let</code> прикріплення в осяжності списків. Давайте перепишемо наші попередні приклади обчислення списків пар ваги-висоти, щоб використовувати <code>let</code> в осяжності списків, замість визначення зовнішньої функції за допомогою <code>where</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми включили <code>let</code> в осяжність списків, майже так само як предикат, але він не фільтрує список, але тільки прив'язує імена. Імена, визначені в <code>let</code> всередині осяжності списків, видимий для функції виводу (частина перед <code>|</code>), та всі предикати та розділи, що ідуть після прикріплення. Так що ви можете зробити, щоб функція повертала тільки BMI для товстих людей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span> <span class="o">^</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bmi</span> <span class="o">&gt;=</span> <span class="mf">25.0</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо використовувати ім'я <code>bmi</code> в частині <code>(w, h) &lt;- xs</code>, оскільки вона визначена перед прикріпленням <code>let</code>.</p></div>
<div class="paragraph"><p>Ми оминули частину <code>in</code> прикріалення <code>let</code>, коли ми використовуємо їх в осяжностях списків, оскільки видимість імен тут завжди передвизначена. Однак ми можемо використовувати <code>let</code> в прикріпленні в предикаті, та визначені імена будуть видимі тільки в ціх предикатах. Частину <code>in</code> також можна оминути при визначенні функцій і констант прямо в GHCi. Якщо ми зробимо це, імена будуть видимі на протязі цілої інтерактивної сессії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">zoot</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zoot</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">2</span>
<span class="mi">29</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">boot</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="kr">in</span> <span class="n">boot</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">2</span>
<span class="mi">14</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boot</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">boot&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>let</code> прикріплення такі круті, ви можете запитати, чому не використовувати їх весь час замість прикріплень <code>where</code>? Гаразд, оскільки <code>let</code> прикріплення є виразами та досить локальні в плані видимості, вони не можуть використовуватись серед охоронців. Деякі люди обирають <code>where</code> прикріалення, оскільки імена ідуть після функції, де вони використовуються. Таким чином, тіло функції ближче до його імені та його типу, і для декого це краще читати.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/case.png" alt="images/case.png" />
</span>
Багато імперативних мов (C, C++, Java, etc.) мають <code>case</code> синтаксис, і якщо ви колись програмували на них, ви можливо знаєте про що іде мова. Береться змінна, та потім виконуються блоки коду для специфічних значень цієї змінної, і можливо включає блок спіймати-всіх на випадок, коли змінна має значення, для якого ми не встановили <code>case</code>.</p></div>
<div class="paragraph"><p>Haskell приймає цю концепцію і покращує її. Як підказує ім'я, <code>case</code> вирази є, гаразд, виразами, подібно до <code>if else</code> виразів та <code>let</code> прикріплень. Ми не тільки можемо обчислювати вирази на основі можливих варіантів змінної, ми також можемо робити співпадіння шаблонів. Хммм, беремо змінну, порівнюємо її з шаблоном, обчислюємо частини коду на основі цього значення, де ми вже це бачили? Так, порівняння шаблонів на параметрах в визначеннях функції! Гаразд, це тільки синтаксичний цукор для <code>case</code>. Ці дві частини коду роблять те саме, і взаємозамінні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;No head for empty lists!&quot;</span>
<span class="nf">head&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&quot;No head for empty lists!&quot;</span>
                      <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис для <code>case</code> виразів є доволі простий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">expression</span> <span class="kr">of</span> <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>expression</code> порівнюється відносно <code>pattern</code>-ів. Порівняння шаблонів діє як очікується: перший шаблон, що співпадає з виразом, буде використаний. Якщо це провалюється через вираз <code>case</code>, і підходящого шаблону не знайдено, виникає помилка часу виконання.</p></div>
<div class="paragraph"><p>Хоча співпадіння на параметрах функцій може виконуватись тільки при визначенні функції, <code>case</code> вирази можуть бути використані майже будь де. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">describeList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">describeList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;The list is &quot;</span> <span class="o">++</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="s">&quot;empty.&quot;</span>
<span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="s">&quot;a singleton list.&quot;</span>
<span class="nf">xs</span> <span class="ow">-&gt;</span> <span class="s">&quot;a longer list.&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони корисні для порівняння шаблонів з чимось всередині виразу. Оскільки співпадіння шаблонів в функції є синтаксичним цукром для <code>case</code> виразів, ми можемо також визначити це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">describeList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">describeList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;The list is &quot;</span> <span class="o">++</span> <span class="n">what</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">what</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="s">&quot;empty.&quot;</span>
          <span class="n">what</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="s">&quot;a singleton list.&quot;</span>
          <span class="n">what</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;a longer list.&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/recursion.png" alt="images/recursion.png" />
</span>
Ми коротко згадували рекурсію в попередній главі. В цій главі ми близько розглянемо рекурсію, чому вона важлива для Haskell, та як ми можете виробляти дуже стислі та елегантні рішення до проблем, розмірковуючи рекурсивно.</p></div>
<div class="paragraph"><p>Якщо ви все ще не знаєте що таке рекурсія, прочитайте це речення. Ха! Це просто жарт! Насправді рекурсія є шляхом визначення функцій, в яких функція застосовується в своєму власному визначенні. Визначення в математиці часто даються рекурсивно. Наприклад, послідовність Фібоначчі визначається рекурсивно. Спочатку ми визначаємо перші два числа Фібоначчі нерекурсивно. Ми кажемо, що <code>F(0) = 0</code> та <code>F(1) = 1</code>, що означає, що перший і другий елементи послідовності є <code>0</code> та <code>1</code>, відповідно. Потім ми кажемо, що для кожного іншого натурального числа число Фібоначчі є сумою попередніх двох чисел послідовності. Так що <code>F(n) = F(n-1) + F(n-2)</code>. Таким чином, <code>F(3)</code> є <code>F(2) + F(1)</code>, що є <code>(F(1) + F(0)) + F(1)</code>. Оскільки ми тепер дійшли до тільки нерекурсивно визначених чисел Фібоначчі, ми можемо безпечно сказати, що <code>F(3)</code> є <code>2</code>. Маючи елемент або два в рекурсивньому визначенні, визначені нерекурсивно, (як <code>F(0)</code> та <code>F(1)</code> тут), що також називаються граничними умовами, і важливо, якщо ви бажаєте, щоб ваша рекурсивна функція завершилась. Якщо ви не визначили <code>F(0)</code> та <code>F(1)</code> нерекурсивно, ви ніколи не отримаєте рішення для любого значення, бо дійдете до нуля, та потім пійдете по від'ємним числам. З часом ви дізнаєтесь, що <code>F(-2000)</code> є <code>F(-2001) + F(-2002)</code>, і все ще кінця цьому не буде видно!</p></div>
<div class="paragraph"><p>Рекурсія важлива в Haskell, оскільки на відміну від імперативних мов, ви робите обчислення в Haskell через декларацію, що є дещо, замість декларування того, як це треба отримати. Ось чому немає <code>while</code> циклів або <code>for</code> циклів в Haskell, і замість ми багато раз маємо використовувати рекурсію для декларування, чим є дещо.</p></div>
<div class="paragraph"><p>Функція <code>maximum</code> бере список речей, що можуть бути впорядковані (тобто примірників типокласу <code>Ord</code>), та повертає більший з них. Поміркуйте про те, як би ви реалізували це в імперативний спосіб. Ви б, можливо, встановили змінну для зберігання максимального значення, та потім би додали цикл по елементах списку, та якщо елемент більше, ніж поточне максимальне значення, ви заміщуюте його цім елементом. Максимальне значення, що залишиться в кінці, і є результат. Фу! Це досить багато слів для опису такого простого алгоритму!</p></div>
<div class="paragraph"><p>Тепер давайте подивимось, як ми визначемо це рекурсивно. Ми можемо спочатку встановити граничну умову, та сказати, що максимум синглтон списку дорівнює значенню його єдиного елементу. Потім ми можемо сказати, що максимум довшого списку є голова, якщо голова більша ніж максимум хвоста. Якщо максимум хвоста більший, гаразд, тоді максимум буде цей максимум хвоста. І все! Тепер давайте реалізуємо це в Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">maximum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">maximum&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;maximum of empty list&quot;</span>
<span class="nf">maximum&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">maxTail</span>
    <span class="kr">where</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">maximum&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, порівняння шаблонів гарно пасує до рекурсії! Більшість імперативних мов не мають порівняння шаблонів, так що ви маєте робити багато <code>if else</code> тверджень для перевірки граничних умов. тут ми просто покладаємо їх як шаблони. Так що перша гранична умова каже, якщо список порожній, це крах! Має сенс, оскільки що буде максимумом порожнього списку? Я не знаю. Другий шаблон також окреслює граничну умову. Він каже, що якщо це синглтон список - просто повернути його єдиний елемент.</p></div>
<div class="paragraph"><p>Тепер третій шаблон, де відбувається справжня дія. Ми використовуємо співпадіння шаблонів для поділу списку на голову та хвіст. Це дуже загальна ідиома при виконанні рекурсії зі списками, так що використаємо її. Ми використовуємо <code>where</code> прикріплення для визначення <code>maxTail</code> як максимума залишку списка. Коли ми перевіряємо, чи голова більша ніж максимум залишку списку. Якщо це так, ми повертаємо голову. Інакше ми повертаємо максимум залишку списку.</p></div>
<div class="paragraph"><p>Давайте візьмемо список прикладу, та перевіримо, як це буде робити з ним: <code>[2,5,1]</code>. Якщо ми викличемо для нього <code>maximum'</code>, перші два шаблони не співпадуть. Третій співпаде, і поділить список на <code>2</code> та <code>[5,1]</code>. Твердження <code>where</code> бажає знати максимум від <code>[5,1]</code>, так що ми йдемо цім шляхом. Він знову співпадає з третім шаблоном, та <code>[5,1]</code> ділиться на <code>5</code> та <code>[1]</code>. Знову, твердження <code>where</code> бажає мати максимум від <code>[1]</code>. Оскільки це гранична умова, вона повертає <code>1</code>. Нарешті! Так що підіймаємось на рівень вище, порівнюючи <code>5</code> з максимумом <code>[1]</code> (що є <code>1</code>), і очевидно отримуємо <code>5</code>. Так що ми знаємо, що максимум <code>[5,1]</code> є <code>5</code>. Ми знову підіймаємось на один рівень вище, де ми маємо <code>2</code> та <code>[5,1]</code>. Порівняння <code>2</code> з максимумом <code>[5,1]</code>, що є <code>