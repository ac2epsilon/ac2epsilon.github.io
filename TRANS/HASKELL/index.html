<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Miran Lipovača
:ascii-ids:
:doctype: book
:source-highlighter: pygments</p></div>
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
<div class="paragraph"><p>Запрошуємо до Learn You a Haskell for Great Good! Якщо ви читаєте це, є шанси, що ви бажаєте вивчити Haskell. Так, ви опинились в правильному місці, але спершу давайте поговоримо про сам цей туторіал.</p></div>
<div class="paragraph"><p>Я вирішив написати це, бо я хотів покращити моє влане знання Haskell, і оскільки я думав, що можу допомогти новим до Haskell людям вивчати його з моєї перспективи. Існує досить небагато туторіалів по Haskell, що плавають в інтернеті. Коли я починав з Haskell, я не навчався тільки з одного ресурсу. Спосіб, яким я навчався, було читання декількох різних туторіалів та статей, оскільки кожний пояснював дещо в інший спосіб, ніж інший. Проходячи по різним ресурсам я був в змозі скласти разом частини, та все займало своє місце. Так що це спроба додати інший корисний ресурс для вивчення Haskell, так що ви маєте більший шанс знайти те, що вам сподобається.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/bird.png" alt="images/bird.png" />
</span>
Цей туторіал націлений на людей, що мають досвід з імперативними мовами програмування (C, C++, Java, Python …), але досі не програмували на функціональних мовах (Haskell, ML, OCaml …). Хоча  я можу поспорити, що навіть якщо ви не маєте жодного значного програмного досвіду, розумна людина, як ви, буде в змозі відслідковувати хід подій та навчиться Haskell.</p></div>
<div class="paragraph"><p>Канал <code>#haskell</code> в мережі <code>freenode</code> є чудовим місцем запитувати питання, якщо ви почуваєтесь розгубленим. Люди там вкрай милі, терплячі та розуміють початківців.</p></div>
<div class="paragraph"><p>Я не зміг вивчити Haskell приблизно два рази, перед тим як нарешті підхопив його, оскільки все це виглядало дуже збоченим, і я не міг зрозуміти. Але одного разу воно просто "клацнуло", і після продирання через початкові хащі це видалось досі спокійне плавання. Як мені здається я намагаюсь сказати: Haskell чудовий, і якщо ви дійсно зацікавлені в програмуванні, вам слід дійсно вивчити його, навіть якщо спочатку він виглядає збоченим. Вивчення Haskell більш подібне на навчання програмування з самого початку — це весело! Це дозволяє вам мислити інакше, що відносить нас в другий розділ …</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/fx.png" alt="images/fx.png" />
</span>
Haskell є <strong>чисто функціональна мова програмування</strong>. В імперативних мовах ви отримуєте речі зробленими через надання комп'ютеру послідовність завдань, та потів виконуєте їх. При їх виконанні це може змінювати стан. Наприклад, ви встановили змінну в <code>5</code>, потім робили дещо, та потім встановили її в дещо інше. Ви маєте структури керування потоком, щоб виконати деяку дію декілька раз. В чисто функціональному програмуванні ви не кажете комп'ютеру, що робити як таке, але скоріше ви кажете, що має бути. Факторіал числа є добуток всіх чисел від 1 до цього числа, сума списка чисел є перше число, плюс сума інших чисел, і так далі. Ви виражаєте це в формі функцій. Ви також не можете змінну в дещо, і пізніше встановити її в дещо інше. Якщо ви кажете, що <code>a</code> є <code>5</code>, ви не можете пізніше сказати що це щось інше, бо ви сказали що це <code>5</code>. Ви що, якийсь брехун? Так що в повністю функціональних мовах функція не має побічних ефектів. Єдина річ, що може робити функція, це обчислювати дещо і повертати це як результат. Спочатку це виглядає як деяке обмеження, але насправді має дуже милі наслідки: якщо функція викликається два рази з тими самими параметрами, вона гарантовано повертає той самий результат. Це називаеться посилковою прозорістю, і не тільки дозволяє компілятору промислювати поведінку програми, але також дозволяє просто доходити висновку (та навіть доводити), що функція коректна, та потім будувати більш складні функції, через склеювання простих функцій разом.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lazy.png" alt="images/lazy.png" />
</span>
Haskell <strong>лінивий</strong>. Це означає, що якщо спеціально не сказане інше,Haskell не виконуватиме функцій та не обчислюватиме речі, коли його дійсно не змусить це робити, щоб показати вам результат. Це гарно пасує до прозорості посилань, і це дозволяє вам думати про програми як про серії перетворень даних. Це також дозволяє круті речі, такі як безкінечні структури даних. Скажімо, ви маєте незмінний список чисел <code>xs = [1,2,3,4,5,6,7,8]</code>, та функцію <code>doubleMe</code>, що множить кожний елемент на <code>2</code>, та потім повертає новий список. Якщо ми б захотіли помножити весь список на 8 в імперативній мові, та зробити <code>doubleMe(doubleMe(doubleMe(xs)))</code>, це можливо пройшло б по списку один раз, та зробило копію, щоб повернути її. Потім це пройшло б по списку ще два рази, та повернуло результат. В лінивій мові виклик <code>doubleMe</code> на списку без примусу показати вам результат скінчиться тим, що програма скаже вам щось накшталт "Так-так, я зроблю це пізніше!". Але коли ви захочете побачити результат, перший <code>doubleMe</code> каже другому, що він хоче результат, негайно! Другий каже те саме до третього, і третій похопцем повертає подвоєні <code>1</code>, що є <code>2</code>. Другий отримує це і повертає <code>4</code> першому. Перший виклик бачить це і повертає вам <code>8</code>. Так що відбувається тільки один прохід по списку, і тільки тоді, коли вам це дійсно треба. Таким чином, коли ви бажаєте дещо від лінивої мови, ви можете просто взяти початкові дані, і ефективно перетворити та полагодити, так, щоб воно відтворювале те, що ви бажаєте мати в кінці.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/boat.png" alt="images/boat.png" />
</span>
Haskell є <strong>статично типізованим</strong>. Коли ви компілюєте вашу програму, компілятор знає, яка частина коду є числом, яка є рядком і так далі. Це означає, що багато з можливих помилок будуть виловлені під час компіляції. Якщо ви спробуєте додати разом число та рядок, компілятор буде скиглити на вас. Haskell використовую дуже гарну систему типів, що має вивід типів. Це означає, що вам не треба насправді явно помічати кожний кусок коду типом, бо система типів може розумно здогадатись більшість з них. Якщо ви кажете <code>a = 5 + 4</code>, ви не маєте казати Haskell, що <code>a</code> є числом, він сам може про це здогадатись. Вивід типів також дозволяє вашому коду бути більш загальним. Якщо функція, що ви створюєте, приймає два параметри, та додає їх разом, та ви явно не встановили їх тип, функція буде робити на любих двох параметрах, що поводяться як числа.</p></div>
<div class="paragraph"><p>Haskell є <strong>елегантним та стислим</strong>. Оскільки він використовує багато концепцій високого рівня, програми Haskell звичайно коротші, ніж їх імперативні еквіваленти. Та коротші програми простіше підтримувати, ніж довгі, та мати меньшн вад.</p></div>
<div class="paragraph"><p>Haskell був зроблений <strong>дійсно розумними хлопцями</strong> (з науковими ступенями). Робота над Haskell почалась в 1987му році, коли комітет розробників зібрався разом щоб розробити несамовиту мову. В 2003 був опублікований Haskell Report, що визначає стабільну версію мови.</p></div>
<div class="paragraph"><p>Текстовий редактор та компілятор Haskell. Ви, можливо, вже маєте ваш улюблений текстовий редактор встановленим, так що ми не витрачатимемо не це час. Для цілей цього туторіала ми будемо використовувати GHC, найбільш широко уживаний компілятор Haskell. Кращий шлях розпочати - завантажити <em>Haskell Platform</em>, що в основному той самий Haskell в комплекті з батарейками.</p></div>
<div class="paragraph"><p>GHC може прийняти Haskell скрипт (вони звичайно мають розширення <code>.hs</code>), та компілювати його, але він також має інтерактивний режим, що дозволяє вам інтерактивно взаємодіяти зі скриптами. Інтерактивно. Ви можете викликати функції зі скриптів, що ви завантажуєте, і результати відображуються безпосередньо. Для навчання це значно простіше і швидше, ніж компілювати кожного разу щоб зробити зміну, та потім виконувати програму з консольної підказки. Інтерактивний режим викликається запуском <code>ghci</code> в підказці консолі. Якщо ви визначили деякі функції в викликаному файлі, скажімо, <code>myfunctions.hs</code>, ви завантажуєте ці функції через набір <code>:l myfunctions</code>, і потім граєтесь з ними, вважаючи, що <code>myfunctions.hs</code> в тому самому файлі, з якого був запущений <code>ghci</code>. Якщо ви зміните <code>.hs</code> скрипт, просто виконайте <code>:l myfunctions</code> знову, або зробіть <code>:r</code>, що еквівалентно, оскільки це перевантажує поточний скрипт. Звичайна послідовність для мене, коли я граюсь з деякими речами, це створення деяких функцій в <code>.hs</code> файлі, завантаження їх, та забавки з ними, та потім зміна файла <code>.hs</code>, завантаження його знову, і так далі. Це також те, що ми будемо тут з вами робити.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/startingout.png" alt="images/startingout.png" />
</span>
Гаразд, давайте розпочнемо! Якщо ви з тих жахливих людей, що не читають інструкцій до речей, і пропускаєте їх, в жодному разі ви маєте прочитати останній розділ зі вступу, оскільки він пояснює, що вам треба, щоб слідувати цьому туторіалу, і як ми збираємось завантажувати функції. Перша річ, що ми збираємось зробити, це виконати <code>ghc</code> в інтерактивному режимі, та викликати деякі функції, щоб отримати дуже базове відчуття <code>haskell</code>. Відкрийте ваш термінал та наберіть <code>ghci</code>. Ви отримаєте привітання, подібне до наступного.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вітаємо, ви в GHCI! Тут підказка <code>Prelude&gt;</code>, але оскільки вона може стати довшою коли ви завантажите дещо в сессії, ми збираємось використовувати <code>ghci&gt;</code>. Якщо ви бажаєте мати таку саму підказку, просто наберіть <code>:set prompt "ghci&gt; "</code>.</p></div>
<div class="paragraph"><p>Ось деяка проста арифметика.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це досить пояснює себе. Ми також можемо використовувати декілька операторів в одному рядку, і вони будуть підкорюватись звичайним правилам преоритетів. Ми можемо використовувати дужки, щоб зробити преоритети явними, або щоб змінити їх.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить круто, чи не так? Так, я знаю що ні, але повірте мені. Невелика пастка тут - подивитись як змінюється знак чисел. Якщо ви бажаєте мати від'ємне число, завжди краще оточити його в дужки. робити <code>5 * -3</code> змусить GHCI скаржитись на вас, але якщо зробити <code>5 * (-3)</code>, це буде робити добре.</p></div>
<div class="paragraph"><p>Логічна алгебра також досить прямолінійна. Як ви ,вірогідно, знаєте, <code>&amp;&amp;</code> позначає логічне <code>AND</code>, <code>||</code> позначає логічне <code>OR</code>. <code>not</code> обертає <code>True</code> або <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Перевірка на рівність робиться так.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як щодо зробити  <code>5 + "llama"</code> або <code>5 == True</code>? Гаразд, якщо ми спробуємо перший фрагмент, ми отримаємо велике і жахливе повідомлення про помилку!</p></div>
<div class="listingblock">
<div class="content">
<pre><code>No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"</code></pre>
</div></div>
<div class="paragraph"><p>Такої! Що тут GHCI каже нам, це те, що <code>"llama"</code> не є числом, і так він не знає, як додати його до <code>5</code>. Навіть якщо це б було не <code>"llama"</code>, а <code>"four"</code> або <code>"4"</code>, Haskell все одно не може дійти висновку, що це число. <code>+</code> очікує, що зправа та зліва від нього числа. Якщо ви спробуєте зробити <code>True == 5</code>, GHCI скаже нам, що типи не співпадають. Хоча <code>+</code> робить тільки на речах, що розглядаються як числа, <code>==</code> робить на любих двох речах, що можна порівняти. Але зачіпка в тому, що вони обоє мають бути одним типом речей. Ви не можете порівняти яблука та помаранчі. Ми зробимо ближчий погляд на типи пізніше. Зауваження: ви можете робити <code>5 + 4.0</code>, оскільки <code>5</code> хитра, і може діяти як ціле або число з плаваючою крапкою. <code>4.0</code> не може діяти як ціле, так що <code>5</code> єдине, що має пристосовуватись.</p></div>
<div class="paragraph"><p>Можиливо ви не знали це, але ми використовували функції весь цей час. Наприклад, <code>*</code> є функцією, що приймає два числа, та перемножує їх. Як ви бачили, ми використовували її, утворивши сендвіч з них. Це те, що ми називаємо інфіксною функцією. Більшість функцій, що не використовуються з числами, є префіксні функції. Давайте поглянемо на них.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/phoen.png" alt="images/phoen.png" />
</span>
Функції звичайно ідуть як префікс, такщо від тепер ми не будемо явно вказувати, що функція має префіксну форму, ми будемо просто вважати що це так. В багатьої імперативних мовах функції викликаються через запис імені функції, та потім її параметри в дужках, звичайно розділені комами. В Haskell функції викликаються записом ім'я функції, проміжок, і розділені проміжками параметри. Для початку ми спробуємо викликати одну зі скучніших функцій в Haskell.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функція <code>succ</code> приймає будь-що, що має визначений наступний, та повертає це наступне. Як ви можете бачити, ми просто відділили ім'я функції від параметра проміжком. Виклик функції з декількома параметрами також просте. Функції <code>min</code> та <code>max</code> приймають дві речі, що можуть бути впорядковані (як числа!). <code>min</code> повертає те, що меньше, та <code>max</code> повертає те, що більше. Дивіться самі:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Застосування функції (виклик функції через покладання проміжку пісня неї, та потім набір параметрів) має найвищий преоритет з них усіх. Це означає, що наступні два твердження еквівалентні.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак якщо ми бажаємо отримати наступний до добутку чисел <code>9</code> та <code>10</code>, ми не можемо записати  <code>succ 9 * 10</code>, оскільки це отримання послідовника для <code>9</code>, що потім буде помножений на <code>10</code>. Тобто <code>100</code>. Ми маємо писати <code>succ (9 * 10)</code> щоб отримати <code>91</code>.</p></div>
<div class="paragraph"><p>Якщо функція прийма два параметри, ми також можемо викликати її як інфіксну функцію, оточивши її зворотніми апострофами. Наприклад, функція <code>div</code> приймає два цілі, та робить ціле ділення першого на друге. Обчислення <code>div 92 10</code> дає результат <code>9</code>. Але коли ми викликаємо її таким чином, може бути деякий сумнів, яке число є чисельник і яке займенник. Так що ми можемо викликати її як інфіксну функцію, зробивши <code>92 ``div`</code> 10`, і миттєво все стає зрозуміло.</p></div>
<div class="paragraph"><p>Багато людей, які прийшли з імперативних мов, маю схильність приставати на нотацію, де дужки мають позначати застосування функції. Наприклад в C ви виокристовуєте дужки для виклику функції, як <code>foo()</code>, <code>bar(1)</code> або <code>baz(3, "haha")</code>. Як ми казали, в Haskell для застосування функції ми використовуємо дужки. Так що ці функції в Haskell будуть <code>foo</code>, <code>bar 1</code> та <code>baz 3 "haha"</code>. Так що якщо ви бачите що подібне до <code>bar (bar 3)</code>, це не означає, що <code>bar</code> викликається з <code>bar</code> та <code>3</code> в якості параметрів. Це означає, що спочатку ми викликаємо <code>bar</code> з <code>3</code> в якості параметра, щоб отримати якесь число, та потім ми викликаємо <code>bar</code> знову з цім числом. В C це буде щось подібне до <code>bar(bar(3))</code>.</p></div>
<div class="paragraph"><p>В попередньому розділі ми отримали базове відчуття щодо виклику функцій. Тепер давайте спробуємо створити свої власні! Відкрийте ваш улюблений текстовий редактор, і видайте таку функцію, що приймає число та множить його на два.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функції визначають в спосіб, подібний до їх виклику. Ім'я функції іде перед параметрами, розділені проміжками. Але коли функція визначається, існує знак <code>=</code> , та після нього визначення того, що робить функція. Збережіть це як <code>baby.hs</code> або будь-як інакше. Тепер перейдіть туди, де ви збереглись, і запустіть там <code>ghci</code>. Всередині  GHCI зробіть <code>:l baby</code>. Тепер, коли наш скрипт завантажений, ми можемо гратись з функцією, яку ми визначили.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки <code>+</code> робить на цілих, так само як і на числах з плаваючою крапкою (насправді на будь-чому, що може розглядатись як число), наша функція також може робити з любими числами. Давайте зробимо функцію, що приймає два числа, та перемножує їх на два, і потім складає результати разом.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Просто. Ми також могли визначити це як <code>doubleUs x y = x + x + y + y</code>. Тестування продукує досить передбачувані результати (пам'ятайте додати цю функцію до файлу  <code>baby.hs</code>, збережіть його, та потім зробіть <code>:l baby</code> в GHCI).</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як і очікувалось, ви можете викликати ваші власні функції з інших функцій, які ви створили. Маючи це на увазі, ви можете перевизначити <code>doubleUs</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це дуже простий приклад загального шаблону, що ви бачитимете повсякчас в Haskell. Створення простих функцій, що вочевидь коректні, та потім комбінування їх в більш складні функції. Таким чином ви також уникаєте повторень. Що, коли деякий математик дійде висновку, що <code>2</code> насправді <code>3</code>, і ви маєте змінити програму? Ви можете просто перевизначити <code>doubleMe</code> як <code>x + x + x</code>, і оскільки <code>doubleUs</code> викликає <code>doubleMe</code>, вона також буде автоматично робити в цьому дивному світі, де <code>2</code> є <code>3</code>.</p></div>
<div class="paragraph"><p>Функції в Haskell не мають іти в якомусь певному порядку, так що не має значення, якщо ви визначите <code>doubleMe</code> спочатку, та потім <code>doubleUs</code>, або ви зробите це навпаки.</p></div>
<div class="paragraph"><p>Тепер ми збираємось створити функцію, що множить число на <code>2</code>, але тільки якщо число меньше або рівне <code>100</code>, бо числа більше ніж <code>100</code> досить великі як вони є!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/baby.png" alt="images/baby.png" />
</span>
Прямо зараз ми ввели Haskell твердження <code>if</code>. Ви, можливо, знайомі з <code>if</code> твердженнями в інших мовах. Різниця між Haskell твердженням <code>if</code>, та твердженнями <code>if</code> в імперативних мовах в тому, що частина <code>else</code> обов'язкова в Haskell. В імперативних мовах ви можете просто пропустити пару кроків, якщо умова не задовільняється, але в Haskell кожний вираз та функція має щось повертати. Ми можемо також записати твердження <code>if</code> в один рядок, але я вважаю цей спосіб значно читабельніше. Інша річ щодо твердження <code>if</code> в Haskell в тому, що це вираз. Вираз загалом це шматок коду, що повертає значення. <code>5</code> є виразом, бо воно повертає <code>5</code>, <code>4 + 8</code> також вираз, <code>x + y</code> також вираз, бо він повертає суму <code>x</code> та <code>y</code>. Оскільки <code>else</code> обов'язкове, твердження <code>if</code> буде завжди  щось повертати, і ось чому це також вираз. Якщо ми бажаємо додавати одиницю до кожного числа, що спродуковане в нашій попередній функції, ми маємо записати тіло таким чином.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми б пропустили дужки, воно додавало одиницю тільки якщо <code>x</code> не було б більше <code>100</code>. Зауважте <code>'</code> наприкінці імені функції. Цей апостроф не має жодного спеціального значення в синтаксисі Haskell. Це валідний символ для використання в іменах функцій. Ми зазвичай використовуємо <code>'</code> для позначення суворої версії функції (що не є лінива), або трохи модифікованої версії функції або змінної. Оскільки <code>'</code> валідний символ в функціях, ми можемо зробити функцію таким чином.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут дві речі, варті уваги. Перша в тому, що в назві функції ми не пишемо ім'я Конана з великої литери. Це тому, що функції не можуть починатись з великої літери. Пізніше ми побачимо чому. Друга річ в тому, що ця функція не приймає жодних параметрів. Коли функція не приймає жодних параметрів, ми кажемо що це визначення (або ім'я). Оскільки ми не можемо змінити те, що імена (та функції) означають після того, як ми їх визначили, <code>conanO'Brien</code> та рядок <code>"It's a-me, Conan O'Brien!"</code> можна використовувати взаємозамінно.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/list.png" alt="images/list.png" />
</span>
Здебільшого так само, як списки покупок в реальному світі, списки в Haskell дуже корисні. Це найбільш використовувана структура даних, і вона може бути використана в безлічі різних способів, щоб моделювати та вирішувати цілу кіпу проблем. Списки ТАКІ неймовірні. В цьому розділі ми побачимо на основи списків, рядкі (що є списками) та осяжність списків.</p></div>
<div class="paragraph"><p>В Haskell списки є гомогенними структурами даних. Вони зберігають декілька елементів одного типу. Це означає, що ми можемо мати список цілих та список символів, але ми не можемо мати список, що має трохи цілих, та трохи символів. І тепер - список!</p></div>
<div class="paragraph"><p>Note: Ми можемо використовувати ключове слово <code>let</code> для визначення імені прямо в GHCI. Зробити <code>let a = 1</code> в GHCI еквівалентно до написання <code>a = 1</code> в скрипті, та потім його завантаження.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, списки позначаються квадратними дужками, та значення в списках розділяються комами. Якщо ми спробуємо список <code>[1,2,'a',3,'b','c',4]</code>, Haskell буде скаржитись, що символи (що, проміж іншого, позначаються символами в поодиноких лапках) не є числами. Кажучи про символи, рядки є тільки списками символів. <code>"hello"</code> є тільки синтаксичним цукром для <code>['h','e','l','l','o']</code>. Оскільки рядки є списками, ми можемо використовувати функції для спискив з рядками, що дійсно зручно.</p></div>
<div class="paragraph"><p>Загальна задача є складання двох списків разом. Це робиться за допомогою оператора <code>++</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Пильнуйте, коли постійно використовуєте оператор <code>++</code> на довгих рядках. Коли ми складаємо разом два списки (навіть якщо ми додаємо синглтон список до списку, наприклад: <code>[1,2,3] ++ [4]</code>), внутрішньо Haskell має пройти по всьому списку злівого боку від <code>++</code>. Це не проблема, коли маємо справи зі списками, що не дуже великі. Але покладання дечого в кінець списку, що має п'ядесят мільйонів елементів в довжину таки займе деякий ча. Однак покладання дечого на початок списку з використанням оператора <code>:</code> (також називається <code>cons</code> оператором) є миттєвим.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, як <code>:</code> приймає число і список чисел, або символ та список символів, тоді як <code>++</code> приймає два списки. Навіть якщо ви додаєте один елемент в кінець списку за допомогою <code>++</code>, ви маєте оточити його в квадратні дужки, так щоб він став списком.</p></div>
<div class="paragraph"><p><code>[1,2,3]</code> насправді є тільки синтаксичним цукром для <code>1:2:3:[]</code>. <code>[]</code> це порожній список. Якщо перед ним добавити <code>3</code> це перетвориться на <code>[3]</code>. Якщо перед цім поставити <code>2</code>, стане <code>[2,3]</code>, і так далі.</p></div>
<div class="paragraph"><p>Note: <code>[]</code>, <code>[[]]</code> та <code>[[],[],[]]</code> все різні речі. Перше це порожній список, друге це список, що містить один порожній список, третій список містить три порожні списки.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте отримати елемент зі списку по індексу, використовуйте <code>!!</code>. Індекси починаються з <code>0</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Але якщо ви намагатиметесь отримати шостий елемент зі списку, що має тільки чотири елементи, ви отримаєте помилку, так що будьте уважні!</p></div>
<div class="paragraph"><p>Списки також можуть містити списки. Вони також можуть містити списки, що містять списки, що містять списки …</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Списки в списку можуть бути різної довжини, але вони не можуть бути різних типів. Так само, як ви не можете мати список, що містить деякі числаі деяки символи, ви не можете мати деякі списки з символами, і деякі списки з числами.</p></div>
<div class="paragraph"><p>Списки можливо порівняти, якщо те, що вони містять, може бути порівняно. Коли використовуються <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> та <code>&gt;=</code> для порівняння списків, вони порівнюються в лексографічному порядку. Спочатку порівнюються голови. Якщо вони рівні, порівнюються другі елементи, і так далі.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що ще можна робити зі списками? Ось деякі базові функції, що оперують на списках.</p></div>
<div class="paragraph"><p><code>head</code> бере список, та повертає його голову. Голова списку це його перший елемент.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>tail</code> бере список, та повертає його хвіст. Іншими словами вона відрубає йому голову.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>last</code> бере список, та повертає останній елемент.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>init</code> бере список, та повератє все, крім останнього елемента.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ви вважаєте, що список це монстр, тоді вам сподобається таке.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/listmonster.png" alt="images/listmonster.png" />
</div>
</div>
<div class="paragraph"><p>Але що трапиться, якщо ми спробуємо отримати голову порожнього списку?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Матінко рідна! Все це вибухнуло нам у лице! Якщо немає монстра, в нього немає голови. Коли використовуєте <code>head</code>, <code>tail</code>, <code>last</code> та <code>init</code>, будьте уважні не використовувати їх на порожніх списках. Ця помилка не може бути перехоплена під час компіляції, так що завжди гарна практика докласти перестороги супроти випадкового прохання до Haskell отримати елементи з порожнього списку.</p></div>
<div class="paragraph"><p><code>length</code> бере список, та повертає його довжину, очевидно.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи список порожній. Якщо це так, він повертає <code>True</code>, інакше <code>False</code>. Використовуйте цю функцію замість <code>xs == []</code> (якщо ви маєте список з назвою <code>xs</code>)</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>reverse</code> обертає список.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>take</code> бере число і список. Він виділяє таку кількість з початку списка. Дивіться.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Бачите, якщо ми намагаємось взяти більше елементів, ніє є в списку, він просто повертає список. Якщо ми намагаємось взяти <code>0</code> повертається порожній список.</p></div>
<div class="paragraph"><p><code>drop</code> робить подібним чином, тільки він відкидає число елементів з початку списка.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>maximum</code> бере список дечого, що може бути впорядковане, і повертає найбільший елемент.</p></div>
<div class="paragraph"><p><code>minimum</code> повертає найменьший.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>sum</code> бере список чисел, та повертає його суму.</p></div>
<div class="paragraph"><p><code>product</code> бере список чисел, та повертає його добуток.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>elem</code> бере річ та список речей, та каже нам, чи є такий елемент в списку. Це звичайно викликається як інфіксна функція, оскільки так воно краще читається.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це були декілька базових функцій, що оперують на списках. Ми побачимо більше спискових функцій пізніше.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cowboy.png" alt="images/cowboy.png" />
</span>
Що, коли ми бажаємо перелічити всі числа від 1 до 20? Звичайно, ми можемо просто надрукувати їх всі разом, але вочевидь це не рішення для джентельмена, що вимагає досконалості від своїх мов програмування. Замість цього ми використовуємо диапазони. Диапазони - це спосіб створювати списки, що є арифметичними послідовностями елементів, що можуть бути перелічені. Числа можуть бути перелічені. Один, два, три, чотири, тощо. Символи можути бути перелічені. Абетка є перелік літер від <code>A</code> до <code>Z</code>. Імена не можуть бути перелічені. Що іде після <code>"John"</code>? Я не знаю.</p></div>
<div class="paragraph"><p>Щоб зробити список, що містить всі натуральні числа від 1 до 20 ви можете записати<code>[1..20]</code>. Це еквівалентно до написання <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>, і немає різниці між написанням одного чи іншого, за винятком того, що написання довгих послідовностей переліку вручну є дурнею.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Диапазони круті, оскільки ви можете задати крок. Що, якщо ми бажаємо всі парні числа між 1 та 20? Або навіть тожне третє між 1 та 20?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це просто справа розділення перших двох елементів комою, та потім вказати вищий ліміт. Хоча це досить розумне, диапазони з кроками не такі розумні, ніє деяки люди бажали б їх бачити. Ви не можете зробити <code>[1,2,4,8,16..100]</code>, та очікувати отримання всіх ступеней <code>2</code>. Для початку тому що ви можете вказати один крок. Та подруге через те, що деякі неарифметичні послідовності неоднозначні, якщо задати тільки декілька з перших членів послідовності.</p></div>
<div class="paragraph"><p>Щоб зробити список з усіх чисел від 20 до 1, ви не можете записати тільки <code>[20..1]</code>, ви маєте зробити <code>[20,19..1]</code>.</p></div>
<div class="paragraph"><p>Слідкуйте за використанням чисел з плаваючою крапкою в диапазонах! Завдяки тому, що вони не повністю точні (по визначенню), їх використання може дати деякі досить дивні результаті.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Моя порада не використовувати їх в спискових диапазонах.</p></div>
<div class="paragraph"><p>Ви також можете використовувати диапазони для створення безкінечних списків, просто не задаючи верню межу. Пізніше ми дійдемо до більших деталей щодо безкінечних списків. Тепер давайте перевіримо, як ви можете отримати перші <code>24</code> добутки числа <code>13</code>. Звичайно, ви можете зробити <code>[13,26..24*13]</code>. Але є кращий шлях: <code>take 24 [13,26..]</code>. Оскільки Haskell лінивий, він не буде намагатись обчислити безкінечний список безпосередньо, бо це ніколи не скінчиться. Він буде чекати, що ви бажаєте отримати з цього безкінечного списку. І тут він бачить, що ви бажаєте отримати лише перші <code>24</code> елементи, на що він легко погоджується.</p></div>
<div class="paragraph"><p>Декілька фунцій, що продукують безкінечні списки:</p></div>
<div class="paragraph"><p><code>cycle</code> бере список, та в циклі перетворює його в безкінечний список. Якщо ви спробуєте тільки отримати результат, це триматиме вічність, тому ви маєте перерватись десь.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>repeat</code> бере елемент, та продукує безкінечний список тільки з цього елемента. Це як цикл по списку тільки з одного елемента.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Хоча це простіше просто використовувати фуункцію <code>replicate</code>, якщо ви бажаєте деяке число одного елемента в списку. <code>replicate 3 10</code> повертає <code>[10,10,10]</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/kermit.png" alt="images/kermit.png" />
</span>
Якщо ви колись вивчали курс з математики, ви, можливо, натрапляли на осяжності множин (прим.перекл. Насправді термін <em>comprehension</em> погано або майже не перекладається одинм словом. Суть в процедурному породженні множини, так би мовити делегація вирішення питання належності до деякого функціоналу - фактично, <em>comprehension</em> легше зрозуміти з боку функціонального програмування). Вони звичайно використовуються для побудови більш специфічних множин на основі більш загальних. Базова осяжність для множини, що містить перші десять парних натуральних чисел є нотація множини.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/setnotation.png" alt="images/setnotation.png" />
</span>
Частина перед рискою називається функцією виводу, <code>x</code> це змінна, <code>N</code> є вхідна множина, та <code>x &lt;= 10</code> є предикат. Це означає, що множина містить подвоєння всіх натуральних чисел, що задовільняють предикату.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте записати це в Haskell, ви можете зробити щось подібне до <code>10 [2,4..]</code>. Але що, якщо ви не бажаєте подвоєння перших <code>10</code> натуральних чисел, але деякий різновид більш складної функції, застосованої до них? Ми можемо застосувати для цього осяжність множини. Ми покі пристанемо до отримання перших <code>10</code> парних чисел. Осяжність списків, яку ми ми можемо використати, це <code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> береться з <code>[1..10]</code>, і для кожного елемента в <code>[1..10]</code> (який ми прив'язуємо до <code>x</code>), ми отримуємо цей елемент, тільки подвоєний. Ось осяжність в дії.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, ми отримали бажаний результат. Тепер давайте додамо умову (або предикат) до осяжності. Предикати ідуть після частини прив'язування, та відокремлюються від них комою. Скажімо, ми бажаємо тільки елементи, що, вже подвоїні, більші або рівні до <code>12</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Круто, це робить. Що, коли ми бажаємо всі числа від <code>50</code> до <code>100</code>, чий залишок, коли поділений на число <code>7</code>, є <code>3</code>? Легко.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Успіх! Зауважте, що пропускання списків через предикати також називається фільтрацією. Ми беремо список з чисел, і ми фільтруємо його предикатом. Тепер інший приклад. Скажімо, ми бажаємо осяжність, що замінює кожне непарне число, більше ніж <code>10</code> на <code>"BANG!"</code>, та кожне непарне, що меньше ніж <code>10</code> на <code>"BOOM!"</code>. Якщо число не непарне, ми відкидаємо його зі списку. Для зручності ми покладемо цю осяжність в функцію, так що ми можемо легко використовувати її декілька раз.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Остання частина осяжності є предикат. Функція <code>odd</code> повертає <code>True</code> на непарних числах, та <code>False</code> на парних. Елемент включається в список тільки якщо всі його предикати обчислюються до <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми можемо включити декілька предикатів. Якщо ми бажаємо всі числа від <code>10</code> до <code>20</code>, що не є <code>13</code>, <code>15</code> або <code>19</code>, ми робимо:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви не тільки можете мати декілька предикатів в осяжностях списків (елемент має задовільняти всім предикатам щоб бути включеним в результуючий список), ми також можемо вибирати з декількох списків. Коли здаєте з кількох списків, осяжність продукує всі комбінації з наданих списків, та потім поєднує їх в вихідній функції, яку ми надаємо. Список, вироблений осяжністю, що вибирає з двох списків довжиною <code>4</code>, буде мати довжину <code>16</code>, якщо вважати, що ми нічого не фільтруємо. Якщо ми маємо два списки, <code>[2,5,10]</code> та <code>[8,10,11]</code>, та бажаємо спродукувати всі можливі комбінації між числами в ціх списках, ось як ми це робимо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як очікувалось, довжина нового списку є <code>9</code>. Що, коли ми бажаємо всі можливі добутки, що більші за <code>50</code>?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як щодо осяжності списку, що комбінує список прикметників та список іменників … заради епічної втіхи.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Я знаю! Давайте напишемо свою власну версію <code>length</code>! Ми назвемо її <code>length'</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>_</code> означає, що нам байдуже, що ми витягнули зі списку, так що замість писати ім'я змінної, що ніколи не буде використовуватись, ми просто пишемо _. Ця функція заміняє кожний елемент в списку на <code>1</code>, та потім підсумовує їх. Це означає, що отримана сума буде рівною довжині нашого списка.</p></div>
<div class="paragraph"><p>Просто дружнє нагадування: оскільки рядки є списками, ми можемо використовувати осяжності списків для обробки та продукування рядків. Ось функція, що бере рядок, та видаляє будь-що, за винятком великих літер.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Testing it out:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут предикат робить всю роботу. Він каже, що символи будуть включені в новий список, тільки якщо вони є елементами списку <code>['A'..'Z']</code>. Вкладені осяжності списків також можливі, якщо ви оперуєте зі списками, що містять списки. Список містить декілька списків чисел. Давайте видалимо всі непарні числа без вирівнювання списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви можете записувати осяжності списків на декількох рядках. Так що якщо ви не в GHCI, краще розділити довші осяжності списків на декілька рядків, особливо якщо вони вкладені.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/tuples.png" alt="images/tuples.png" />
</span>
В деякий спосіб тапли як списки — вони є спосіб зберігати декілька значень в одному значенні. Але є декілька фундаментальних відмінностей. Список чисел є список чисел. Це його тип, і не має значення, чи він має лише одне число в собі, або безкінечне іисло чисел. Однак тапли використовуються, коли ви напевне знаєте, скільки значень ви бажаєте скомбінувати, та їх тип залежить від того, як багато компонент, та який їх тип. Вони позначаються дужками, та їх компоненти розділені комами.</p></div>
<div class="paragraph"><p>Інша ключова відмінність в тому, що вони не мають бути гомогенними. На відміну від списків, тапл може містити комбінацію декількох типів.</p></div>
<div class="paragraph"><p>Подумайте про те, як ми представляємо дво-вимірний вектор в Haskell. Один спосіб може бути список. Це має деяк робити. То що, якщо ми бажаємо покласти пару векторів в список, щоб представляти точки фігури на дво-мірній площині? Ми маємо зробити щось таке: <code>[[1,2],[8,11],[4,5]]</code>. Проблема з цім методом в тому, що ми також можемо робити такі речі: <code>[[1,2],[8,11,5],[4,5]]</code>, з чим Haskell не матиме проблем, бо це також список списків з числами, але це щось таке, що не має сенсу. Але тапл розміром два (що також має назву <code>pair</code>) є власним типом, що означає, що список не може мати декілька пар, і потім <code>triple</code> (тапл розміром три), так що давайте краще використовувати пари. Замість оточувати вектори квадратними дужками, ми використовуємо дужки: <code>[(1,2),(8,11),(4,5)]</code>. Що, коли ми спробуємо зробити фігуру як <code>[(1,2),(8,11,5),(4,5)]</code>? Гаразд, ми отримаємо таку помилку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]</code></pre>
</div></div>
<div class="paragraph"><p>Це каже нам, що ми спробували використовувати пару та трійку в одному списку, що не мало б статись. Ви також не можете зробити список як <code>[(1,2),("One",2)]</code>, оскільки перший елемент в списку є парою чисел, і другий елемент є парою, що складається з рядка та числа. Тапли також можуть використовуватись для представлення широкого різноманіття даних. Наприклад, якщо ми бажаємо представити чиєсь ім'я і вік в Haskell, ми можемо використовувати <code>triple</code>: <code>("Christopher", "Walken", 55)</code>. Як бачимо в цьому прикладі, тапли також можуть містити списки.</p></div>
<div class="paragraph"><p>Використовуйте тапли, коли ви знаєте заздалегідь, як багато компонент буде мати деякий шматок даних. Тапли значно більш обмежені, оскільки кожни інший розмір тапла є власним типом, так що ви не можете написати загальну функцію для додавання елементу до тапла — ви маєте писати функцію для додавання до пари, одну функцію для додавання до трійці, одну для додавання до четвірки і так далі.</p></div>
<div class="paragraph"><p>Хоча є списки синглтони, немає такої речі як синглтон тапл. Це не має багато сенсу, якщо ви поміркуєте про це. Синглтон тапл є тільки значення, що він містить, і це не дає нам жодних переваг.</p></div>
<div class="paragraph"><p>Як списки, тапли можуть бути порівняні один з одним, якщо їх компоненти можуть бути порівняні. Ви не можете порівняти два тапла різного розміру, хоча ви можете порівняти два списки різного розміру. Дві корисні функції для операцій на парах:</p></div>
<div class="paragraph"><p><code>fst</code> бере пару, та повертає перший компонент.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>snd</code> бере пару, та повертає другий компонент. Сюрприз!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note: ці функції оперують тільки на парах. Вони не працюватимуть на трійках, четвірках, п'ятірках, тощо. Ми дійдемо до отримання даних з таплів в різний спосіб трохи пізніше.</p></div>
<div class="paragraph"><p>Крута функція, що продукує список пар: <code>zip</code>. Вона приймає список з двох списків, та потім поєднує їх разом в один список, через поєднання елементів з одним індексом в пари. Це насправді проста функція, але вона має безліч застосувань. Вона особливо корисна, коли ви бажаєте скомбінувати два списки в цей спосіб, або пересуватись по обох списках одночасно. Ось демонстрація.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це спаровує елементи та продукує новий список. Перший елемент з першим, другий з другим, і так далі. Зауважте, що оскільки пари можуть мати різні типи в собі, <code>zip</code> може приймати два списка, що містять різні типи, та поєднати їх разом. Що трапиться, якщо довжина списків не співпаде?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Довший список просто буде обрізаний, щоб співпадати по довжині з коротшим. Оскільки Haskell лінивий, ми можемо поєднувати скінчені списки з безкінечними списками:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/pythag.png" alt="images/pythag.png" />
</span>
Ось проблема, що поєднує тапли та осяжності списків: який правильний трикутник, що має цілими всі сторони, і всі сторони меньше або рівні <code>10</code>, має периметр <code>24</code>? Перше, давайте спробуємо генерувати всі трикутники, зі сторонами меньшими ніж <code>10</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми тільки но тягнемо з трьох списків, і наша вихідна функція є поєднання їх в трійцю. Якщо ви обчислите це, набравши <code>triangles</code>  в GHCI, ви отримаєте список всіх можливих трикутників зі сторонами довжиною <code>10</code> або меньше. Далі ми додамо умову, щоб всі вони були правильними трикутниками. Ми також будемо модифікувати цю функцію, приймаючи до уваги, що сторона <code>b</code> не більша за гіпотенузу, і що сторона <code>a</code> не більша за сторону <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми майже скінчили. Тепер ми тільки модифікуємо функцію, сказавши, що ми бажаємо тільки коли периметр дорівнює <code>24</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>А ось і відповідь! Це загальних шаблон функціонального програмування. Ви берете стартовий набір рішень, та потім ви застосовуєте трансформації до ціх рішень, та фільтруєте їх, доки ви не отримаєте потрібні.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cow.png" alt="images/cow.png" />
</span>
Раніше ми згадували, що Haskell має статичну систему типів. Тип кожного виразу відомий під час компіляції, що призводить до безпечнішого коду. Якщо ви напишете програму, де ви спробуєте поділити логічний тип на деяке число, вона навіть не скомпілюється. Це добре, бо краще перехоплювати такі помилки під час компіляції, замість отримати крах вашої програми. Все в Haskell має тип, так що компілятор може міркувати щодо вашої програми, перед тим як скомпілювати її.</p></div>
<div class="paragraph"><p>На відміну від Java або Pascal, Haskell має вивід типів. Якщо ви пишете число, ви не маєте казати Haskell, що це число. Він може вивести це сам, так що нам не треба явно писати типи наших функцій та виразів, щоб все робилось відповідно. Ми розглянули деяки з основ Haskell, тільки зверньо поглянувши на типи. Однак розуміння системи типів є дуже важливою частиною в вивченні Haskell.</p></div>
<div class="paragraph"><p>Тип є різновидом мітки, що має кожен вираз. Він каже нам, до якої категорії речей належить вираз. Вираз <code>True</code> є логічним, <code>"hello"</code> є рядком, тощо.</p></div>
<div class="paragraph"><p>Зараз ми будемо використовувати GHCI для перевірки типів деяких виразів. Ми будемо робити це, використовуючи команду <code>:t</code>, яка, якщо стоїть перед валідним виразом, каже його тип. Дамо йому вир.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bomb.png" alt="images/bomb.png" />
</span>
Тут ми бачимо, що робити <code>:t</code> на виразі друкує вираз, за яким іде <code>::</code> та його тип. <code>::</code> читається як "має певний тип". Явні типи завжди позначаються першою літерою верхнього реєству. <code>'a'</code>, як можна бачити, має тип <code>Char</code>. Не важко зробити висновок, що це позначає символ. <code>True</code> має тип <code>Bool</code> (логічний тип, названий за розробником логічної алгебри предикатів, Буля. прим.перекл). Це має сенс. Але що це? Дослідження типу <code>"HELLO!"</code> дає <code>[Char]</code>. Квадратні дужки позначають список. Так що ми читаємо це як список символів. На відміну від списків кожна довжина таплу має власний тип. Так що вираз <code>(True, 'a')</code> має тип <code>(Bool, Char)</code>, тоді як вираз як <code>('a','b','c')</code> матиме тип <code>(Char, Char, Char)</code>. <code>4 == 5</code> завжди повертатиме <code>False</code>, так що його тип <code>Bool</code>.</p></div>
<div class="paragraph"><p>Функції також мають типи. Коли ми пишемо власні функції, ми можемо обрати надавати їм явні декларації типів. Це загалом розглядається як гарна практика, за винятком коли ми пишемо дуже малі функції. Звідси і надалі ми надаватимемо функції, що мають явні декларації типів. Згадайте осяжності списків, що ми робили до цього, що фільтрували рядки, що мають лише великі літери? Ось як це виглядає з декларацією типу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>removeNonUppercase</code> має тип <code>[Char] -&gt; [Char]</code>, що каже, що вона відзеркалює рядок на рядок. Це тому, що вона бере один рядок як параметр, та повертає інший як результат. Тип <code>[Char]</code> є синонімом до <code>String</code>, так що буде яснішим, якщо ми напишемо <code>removeNonUppercase    \:\: String -&gt; String</code>. Ми не маємо надавати цій функції декларацію типу, оскільки компілятор може вивести це самостійно, що це функція рядка до рядка, ала ми зробили це все одно. Але як записати тип функції, що приймає декілька параметрів? Ось проста функція, що приймає три цілі та складає їх разом:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Параметри розділені позначкою <code>-&gt;</code>, і немає особливої різниці між параметрами та типом повернення. Тип повернення є останнім елементом в декларації, та параметри перші три. Пізніше ми побачимо, чому вони всі розділені <code>-&gt;</code>, замість мати деякий більш явний спосіб розрізнення між типом повернення та параметрами, як <code>Int, Int, Int -&gt; Int</code>, або щось таке.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте надати вашій функції декларацію типу, але не впевнені, що це має бути, ви можете тільки написати функцію без нього, та потім перевірити її за допомогою <code>:t</code>. Функції також є виразами, так що <code>:t</code> робить на них без проблем.</p></div>
<div class="paragraph"><p>Ось огляд деяких загальних типів.</p></div>
<div class="paragraph"><p><code>Int</code> означає цілі. Він використовується для цілих чисел. <code>7</code> може бути <code>Int</code>, але <code>7.2</code> ні. <code>Int</code> обмежене, що означає, що вони мають мінімум та максимальне значення. Зазвичай на 32-бітних машинах максимально можливе <code>Int</code> є <code>2147483647</code>, та мінімальне є <code>-2147483648</code>.</p></div>
<div class="paragraph"><p><code>Integer</code> позначає також, хм … також ціле. Головна різниця в тому, що він не прив'язаний до меж, і він може використовуватись для представлення насправді великих чисел. Я маю на увазі що дійсно великіх. Однак <code>Int</code> більш ефективний.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Float</code> є дійсне плаваюче з одинарною точністю.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Double</code> є дійсне плаваюче з подвійною точністю!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Bool</code> є логічний тип. Він може мати тільки два значення: <code>True</code> та <code>False</code>.</p></div>
<div class="paragraph"><p><code>Char</code> представляє символ. Він позначається поодинокими лапками. Список символів є рядком.</p></div>
<div class="paragraph"><p>Тапли є типами, але вони залежні від своєї довжини, так само, як і від типів своїх компонентів, так що теоретично є безліч типів таплів, що забагато, щоб накрити в цьому туторіалу. Зауважте, що порожній тапл <code>()</code> також є типом, що може мати одне значення: <code>()</code>.</p></div>
<div class="paragraph"><p>Який, як ви думаєте, є тип функції <code>head</code>? Оскільки <code>head</code> приймає список любого типу, та повертає перший елемент, то що це має бути? Давайте перевіримо!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/box.png" alt="images/box.png" />
</span>
Хмм! Що є це <code>a</code>? Чи це є тип? Згадайте, що дотепер ми стверджували, що типи записуються з великої літери, так що це не може в точності бути типом. Оскільки це не велика літера, це насправді змінна типу. Це значить, що це може бути любий тип. Це здебільшого як дженеріки в інших мовах, але в Haskell це значно більш потужне, оскільки це дозволяє нам просто писати любі загальні функції, тільки якщо вони не використовують деяку особливу специфічну поведінку на типах в своєму складі. Функції, що мають змінні типів, називаються поліморфними функціями. Декларація типу <code>head</code> стверджує, що вона приймає список любого типу, та повертає один елемент цього типу.</p></div>
<div class="paragraph"><p>Хоча змінні типів можуть мати ім'я, довші за один символ, ми зазвичай даємо їм імена <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p></div>
<div class="paragraph"><p>Пам'ятаєте <code>fst</code>? Він повертає перший компонент з пари. Давайте дослідимо його тип.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми бачимо, що <code>fst</code> бере тапл, що має два типи, і повертає елемент, чий тип такий самий, що і тип першого компонента з пари. Ось чому ми можемо використовувати <code>fst</code> на парі, що містить два довільні типи. Зауважте, що тільки через те, що <code>a</code> та <code>b</code> є різними змінними типів, вони не мають бути різними типами. Це типами стверджує, що тип першого компоненту та тип значення повернення є тим самим.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/classes.png" alt="images/classes.png" />
</span>
Типоклас є деяким різновидом інтерфейсу, що визначає деяку поведінку. Якщо тип є частиною типокласу, це означає, що він підтримує та реалізує поведінку, яку описує типоклас. Багато людей, що приходять з OOP, спантеличені типокласами, бо вважають їх подібними до класів в об'єктно орієнтовних мовах. Гараз, це не так. Ви можете думати про них, як про різновид Java інтерфейсів, тільки кращіх.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note: оператор еквівалентності <code>==</code> є функцією. Так само, як <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, та майже всі інші оператори. Якщо функція складається тільки зі спеціальних символів, вона розглядається як інфіксна функція по замовчанню. Якщо ми бажаємо перевірити її тип, передати її до іншої функції, або викликати як префіксну функцію, ми маємо оточити її дужками.</p></div>
<div class="paragraph"><p>Цікаво. Ми бачимо тут нову річ, символ <code>=&gt;</code>. Все перед символом <code>=&gt;</code> має назву класової константи. Ми можемо прочитати попередню декларацію типу таким чином: Функція еквівалентності бере два значення, що мають однаковий тип, та повертає <code>Bool</code>. Тип ціх значень мусить бути типом класу <code>Eq</code> (це була класова константа).</p></div>
<div class="paragraph"><p>Типоклас <code>Eq</code> провадить інтерфейс для перевірки на рівність. Кожний клас, коли має сенс перевірка на рівність між двома елементами для цього типу, мав би бути членом класу <code>Eq</code>. Всі стандартні типи Haskell, за винятком IO (тип для роботи з вводом та виводом), та функції є частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Функція <code>elem</code> має тип <code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>, оскільки він використовує <code>==</code> по списку, щоб перевірити, чи деяке значення, яке ми шукаємо, знаходиться в списку.</p></div>
<div class="paragraph"><p><code>Eq</code> використовується для типів, що підтримують перевірку на рівність. Функції, що реалізують його члени є <code>==</code> та <code>/=</code>. Так що якщо є обмеження класу <code>Eq</code> для змінної типу в функції, вона використовує <code>==</code> або <code>/=</code> десь в своїй декларації. Всі типи, що ми згадували до цього, за винятком функцій, є частинами <code>Eq</code>, так що вони можуть бути перевірені на рівність.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Ord</code> призначений для типів, що мають впорядкування.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Всі типи, що ми розглядали досі, за винятком функцій, є частиною <code>Ord</code>. <code>Ord</code> покриває всі стандартні функції порівняння, такі як <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> та <code>&lt;=</code>. Функції порівнянь беруть два члени <code>Ord</code> того самого типу, і повертають впорядкування <code>Ordering</code>. <code>Ordering</code> є типом, що може бути <code>GT</code>, <code>LT</code> або <code>EQ</code>, що відповідно означає більше ніж, меньше ніж, або дорівнює.</p></div>
<div class="paragraph"><p>Щоб бути членом <code>Ord</code> тип має зпочатку мати членство в престижному та ексклюзивному клубі <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Члени <code>Show</code> можуть бути представлені як рядкі. Всі типи, що розглядались досі, за винятком функцій, є частиною <code>Show</code>. Найбільш уживана функція, що має справу з типокласом <code>Show</code> є <code>show</code>. Вона бере значення, чий тип є членом <code>Show</code>, та представляє його нам як рядок.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Read</code> є дещо протилежним типокласом до <code>Show</code>. Функція <code>read</code> бере рядок, та повертає тип, який є членом <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Доки досить. Знову, всі типи, розглянуті до сих пір, знаходяться в цьому типокласі. Але що відбудеться, якщо ми тільки зробимо <code>read "4"</code>?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що GHCI тут нам каже, це те, що він не знає, що ми бажаємо повернути. Зауважте, що в попередніх використаннях <code>read</code> ми робили дещо з результатом після цього. Таким чином, GHCI міг вивести, який тип результату ми бажали від <code>read</code>. Якщо ми б використовували це як логічне, він би знав, що треба повертати <code>Bool</code>. Але тепер він знає, що ми бажаємо деякий тип, що є частиною класу <code>Read</code>, він тільки не знає, який саме. Давайте поглянемо на сигнатуру типу <code>read</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Бачите? Він повертає тип, що є частиною <code>Read</code>, але якщо ми потім не спробуємо використати його якось далі, немає шляху дізнатись, що саме цей тип. Ось чому ми можемо використовувати явні анотації типів. Анотації типів є шлях явно сказати, яким має бути тип виразу. Ми робимо це, додаючи <code>::</code> наприкінці виразу, та потім вказавши тип. Дивіться:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Більшість виразів такі, що компілятор може вивести їх тип самотужки. Але іноді компілятор не знає, чи треба повертати значення типу <code>Int</code> або <code>Float</code> для виразів як <code>read "5"</code>. Щоб побачити, який тип є насправді, Haskell мав би насправді обчислити <code>read "5"</code>. Але оскільки Haskell є статично типізованою мовою, він має знати всі типи перед компіляцією кода (або в випадку GHCI, обчисленням). Так що ми маємо сказати Haskell: "Йо, цей вираз має бути такого типу, в випадку якщо ти не знаєш!".</p></div>
<div class="paragraph"><p><code>Enum</code> члени є послідовно впорядкованими типами — вони можуть бути перелічені. Головна перевага типокласу <code>Enum</code> в тому, що ми можемо використовувати його типи як диапазони списків. Вони також мають визначені попередників та послідовників, що ви можете отримати функціями <code>succ</code> та <code>pred</code>. Типи в цьому класі: <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> та <code>Double</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Члени <code>Bounded</code> мають верхню та нижню межу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>minBound</code> та <code>maxBound</code> є цікаві, бо вони мають тип <code>(Bounded a) =&gt; a</code>. В деякому сенсі вони є поліморфними константами.</p></div>
<div class="paragraph"><p>Всі тапли також є частиною <code>Bounded</code>, якщо в ньому також їх компоненти.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Num</code> є числовим типокласом. Його члени мають властивість діяти як числа. Давайте дослідимо тип числа.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Виглядає так, що цілі числа також є поліморфними константами. Вони можуть діяти як любий тип, що є членом типокласу <code>Num</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це ті типи, що належать до типокласа <code>Num</code>. Якщо ми перевіримо тип <code>*</code>, ми побачимо, що він приймає всі числа.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Він приймає всі числа того самого типу, та повертає число того ж типу. Ось чому <code>(5 :: Int) * (6 :: Integer)</code> призведе до посилки типу, тоді як `5 * (6 
</dt>
<dd>
<p>
Integer)` буде робити досить добре, та спродукує <code>Integer</code>, оскільки <code>5</code> може діяти як <code>Integer</code> або <code>Int</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Щоб поєднати <code>Num</code>, тип має вже бути друзями з <code>Show</code> та <code>Eq</code>.</p></div>
<div class="paragraph"><p><code>Integral</code> є також числовим типокласом. <code>Num</code> включає всі числа, включаючи дійсні числа та цілі числа, <code>Integral</code> включає тільки цілі числа. В цьому типокласі <code>Int</code> та <code>Integer</code>.</p></div>
<div class="paragraph"><p><code>Floating</code> включає тільки числа з плаваючою крапкою, <code>Float</code> та <code>Double</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дуже корисна функція для справ з числами є <code>fromIntegral</code>. Вона має декларацію типу <code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. З цієї декларації типів ми бачимо, що він приймає ціле число, та перетворює його в більш загальне число. Це корисно, коли ви бажаєте, щоб цілі та з плаваючою крапкою гарно робили поспіль. Наприклад, функція <code>length</code> має декларацію типу <code>length :: [a] -&gt; Int</code>, замість мати більш загальний тип `(Num b) &#8658; length 
</dt>
<dd>
<p>
[a] &#8594; b`. Я думаю, це має історичні причини або щось таке, хоча, як до мене, це дурниці. В жодному разі, якщо ви отримаєте довжину списку, та потім додасте її до <code>3.2</code>, ми отримаємо помилку, бо ми намагались додати разом <code>Int</code> та число з плаваючою крапкою. Щоб уникнути цього ми робимо <code>fromIntegral (length [1,2,3,4]) + 3.2</code>, і тоді це буде робити.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що <code>fromIntegral</code> має декілька класових обмежень в своїй сигнатурі типу. Це повністю валідне, та як ви можете бачити, обмеження класів відокремлені комами в дужках.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/pattern.png" alt="images/pattern.png" />
</span>
Ця глава дослідить деякі з крутих синтаксичних конструкцій Haskell, і ми почнемо зі співпадіння шаблонів. Співпадіння шаблонів складається з вказання шаблонів, яким мають відповідати деякі дані, та потім перевірити, чи це так, та деконструювати дані відповідно до ціх шаблонів.</p></div>
<div class="paragraph"><p>Коли визначаєте функції, ви можете визначити окремі тіла функції для різних шаблонів. Це призводить до дійсно милого коду, що простий та читається. Ви можете перевіряти шаблони на кожному типі — числах, символах, списках, таплах, тощо. Давайте зробимо насправді тривіальну функцію, що перевіряє, чи надане нами число сімка, або ні.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми викликаємо <code>lucky</code>, шаблони будуть перевірятись згори донизу, і коли шаблон буде задовільнятись, відповідне тіло буде використовуватись. Єдиний спосіб, як число може задовільніти першому шаблону - якщо це <code>7</code>. Якщо ні, керування провалюється до другого шаблону, що співпадає з будь чим, та прикріпляє його до <code>x</code>. Ця функція також може бути реалізованою через використання твердження <code>if</code>. Але що, коли ми бажаємо функцію, що каже числа від <code>1</code> до <code>5</code>, та каже "Not between 1 and 5" для любого іншого числа? Без співпадіння шаблоній ми будемо швидко втягнуті в дерево <code>if then else</code>. Однак з шаблонами:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, що якщо ми перемістмо останній шаблон (спіймати все) догори, він завжди буде казати "Not between 1 and 5", оскільки він буде ловити всі числа без шансу провалитись, та перевірити всі інші шаблони.</p></div>
<div class="paragraph"><p>Згадайте функцію факторіала, що ми реалізували до цього? Ми визначали <code>factorial</code> числа <code>n</code> як добуток <code>[1..n]</code>. Ми також можемо визначити функцію факториала рекурсивно, спосіб, що зазвичай використовується в математиці. Ми починаємо, кажучи що факторіал <code>0</code> є <code>1</code>. Потім ми кажемо, що факторіал любого позитивного цілого є це ціле, помножене на факторіал свого попередника. Ось як це виглядає, перекладене в терміни Haskell.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це перший раз, коли ми визначили функцію рекурсивно. Рекурсія важлива в Haskell, і пізніше ми поглянемо на неї ближче. Але ось що відбувається, коли ми беремо факторіал, скажімо, <code>3</code>. Він намагаться обчислити <code>3 * factorial 2</code>. Факторіал 2 є <code>2 * factorial 1</code>, так що досі ми маємо <code>3 * (2 * factorial 1)</code>. <code>factorial 1</code> є <code>1 * factorial 0</code>, так що ми маємо <code>3 * (2 * (1 * factorial 0))</code>. Тепер настає час трюку — ми визначили факторіал <code>0</code> як просто <code>1</code>, та оскільки це підпадає під той шаблон, що іде до загального випадка, він просто повертає <code>1</code>. Так що остаточний результат еквівалентний до <code>3 * (2 * (1 * 1))</code>. Якщо б ми написали другий шаблон над першим, він би відловлював всі числа, включаючи 0, і наші обчислення ніколи б не закінчились. Ось чому порядок важливий, коли вкзуєте шаблони, і завжди краще вказувати найбільш специфічні першими, та більш загальні потім.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може схибити. Якщо ми визначимо функцію ось так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>та потім спробуємо викликати її маючи на вході щось неочікуване, ось що трапиться:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вона скаржиться, що ми маємо невиключні шаблони, і це так і є насправді. При створенні шаблонів нам слідує завжди включати загальні шаблони, так що наша програма не завалиться, якщо ми отримаємо неочікуваний вхід.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може використовувати тапли. Що, коли ми бажаємо створити функцію, що приймає два вектори в 2D просторі (що є в формі пар), та додає їх разом? Щоб додати разом два вектори, ми додаємо їх <code>x</code> компоненти окремо, та потім їх <code>y</code> компоненти окремо. Ось що ми можемо зробити, якщо ви не знаємо про співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гаразд, це робить, але існує кращий шлях, щоб зробити це. Давайте модифікуємо функцію, так щоб вона використовувала співпадіння шаблонів.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ось так! Значно краще. Зауважте, що це все ще загальний шаблон. Тип <code>addVectors</code> (в обох випадках) є `addVectors 
</dt>
<dd>
<p>
(Num a) &#8658; (a, a) &#8594; (a, a) - &gt; (a, a)`, так що ми гарантовано отримуємо дві пари як параметри.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>fst</code> та <code>snd</code> виділяють компоненти з пар. Але що з трійками? Гаразд, немає готової функції, щоб зробити це, але ми можемо створити власну.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Знак <code>_</code> означає ту саму річ, що він робить в осяжностях списків. Це означає, що насправді нам байдуже, що є в цій частині, так що пи просто пишемо <code>_</code>.</p></div>
<div class="paragraph"><p>Що нагадує мені, що ви також можете робити співпадіння в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли співпадіння схибить, він буде тільки переходити на наступний елемент.</p></div>
<div class="paragraph"><p>Самі списки також можуть використовуватись в співпадінні шаблонів. Ви можете порівнювати з порожнім списком <code>[]</code>, або любим шаблоном, що включає <code>:</code> та порожній список. Але оскільки <code>[1,2,3]</code> є тільки синтаксичним цукром для <code>1:2:3:[]</code>, ви також можете використовувати і такий шаблон. Шаблон як <code>x:xs</code> буде прикріпляти голову списку до <code>x</code>, та залишок до <code>xs</code>, навіть якщо був один елемент, так що <code>xs</code> в кінці буде порожнім списком.</p></div>
<div class="paragraph"><p>Note: Шаблон <code>x:xs</code> багато використовується, особливо з рекурсивними функціями. Але шаблони, що мають в собі <code>:</code>, співпадають тільки зі списками довжини 1 або більше.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте прикріпити, скажімо, перші три елементи до змінних, та залишок до іншої змінної, ви можете використовувати щось подібне до <code>x:y:z:zs</code>. Це буде співпадати тільки зі списками, що мають три елементи або більше.</p></div>
<div class="paragraph"><p>Тепер ми знаємо, як порівнювати шаблони зі списками, давайте створими нашу власну реалізацію функції <code>head</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Перевіримо, чи вона робить:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гарно! Зауважте, що якщо ви бажаєте прикріпити декілька змінних (навіть якщо одна з них просто <code>_</code>, та взагалі нічого не прикріплює), ми маємо оточити їх в дужки. Також зауважте функцію <code>error</code>, яку ми використовуємо. Вона приймає рядок та генерує помилку часу виконання, використовуючи рядок як інформацію щодо різновиду виникшої помилки. Це призводить до падіння програми, так що недобре використовувати її дуже багато. Але виклик <code>head</code> на порожньому списку не має сенсу.</p></div>
<div class="paragraph"><p>Давайте створимо тривіальну функцію, що каже нам перші елементи списку в зручній англійській формі.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ця функція безпечна, оскільки вона турбується про порожній список, список синглтон, список з двома елементами, та списки з більше двох елементів. Зауважте, що <code>(x:[])</code> та <code>(x:y:[])</code> можуть бути переписані як <code>[x]</code> та <code>[x,y]</code> (завдяки синтаксичному цукру нам не потрібні дужки). Ми не можемо переписати <code>(x:y:_)</code> з квадратними дужками, оскільки він співпадає зі списком довжини 2 або більше.</p></div>
<div class="paragraph"><p>Ми вже реалізовали нашу власну функцію <code>length</code> використовуючи осяжність списків. Тепер ми зробимо це, використовуючи співпадіння шаблонів та трохи рекурсії:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це подібно до функції <code>factorial</code>, що ми писали раніше. Спочатку ми визначили результат для відомого входу — порожнього списку. Це також відомо як гранична умова. Потім в другому шаблоні ми розбиваємо список на частки, відділяючи голову та хвіст. Ми кажемо, що довжина дорівнює 1 плюс довжина хвоста. Ми використовуємо <code>_</code> для співпадіння з головою, оскільки нам насправді байдуже, що це. Також зауважте, що ми потурбувались про всі можливі шаблони для списку. Перший шаблон співпадає з порожнім списком, та другий співпадає з будь чим, що не є порожнім списком.</p></div>
<div class="paragraph"><p>Давайте подивимось, що коли ми викличемо <code>length'</code> на <code>"ham"</code>. Спочатку ми перевіримо, чи це порожній список, і через те, що це не так, ми провалимось до другого шаблону. Це співпадає з другим шаблоном, і каже, що довжина є <code>1 + length' "am"</code>, оскільки ми розбили рядок на голову і хвіст, та відкинули голову. Гаразд. Довжина <code>length'</code> від <code>"am"</code> подібним чином є <code>1 + length' "m"</code>. Так що прямо зараз ми маємо <code>1 + (1 + length' "m")</code>. <code>length' "m"</code> є <code>1 + length' ""</code> (також можна записати як <code>1 + length' []</code>). І ми визначили <code>length' []</code> як <code>0</code>. Так що в кінці ми маємо <code>1 + (1 + (1 + 0))</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо <code>sum</code>. Ми знаємо, що сума порожнього списку є 0. Запишемо це в вигляді шаблону. І ми також знаємо, що сума списку є голова, плюс сума залишку списку. Коли ми запишемо все це, ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Також є така річ, що називається <code>as</code> шаблонами. Це зручний спосіб розбити щось відповідно до шаблону, та прикріпити частки до імен, при цьому зберігаючи посилання на цілу річ. Ви робите це, покладаючи ім'я та знак <code>@</code> перед шаблоном. Наприклад, шаблон <code>xs@(x:y:ys)</code>. Цей шаблон буде співпадати точно з тією самою річчю, що і <code>x:y:ys</code>, але ви можете просто отримати цілий список через <code>xs</code>, замість повторювати себе через повторний набір <code>x:y:ys</code> в тілі функції. Ось швидкий та брудний приклад:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Звичайно ми використовуємо шаблони щоб уникнути повторення себе, коли порівнення з більшим шаблоном, коли ми використовуємо цілу річ в тілі функції.</p></div>
<div class="paragraph"><p>Ще одна річ — ви не можете використовувати <code>++</code> в співпадіннях шаблонів. Якщо ви спробуєте порівняти шаблон з <code>(xs ++ ys)</code>, що буде першим списком, та що буде другим списком? Це не має великого сенсу. Буде мати сенс порівняти з <code>(xs ++ [x,y,z])</code> або просто <code>(xs ++ [x])</code>, але завдяки природі списків ви не можете зробити цього.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/guards.png" alt="images/guards.png" />
</span>
В той час, коли шаблони є шляхом переконатись, що значення відповідає деякій формі, та деконструкції, охоронці є шляхом перевірити, чи деяка властивість значення (або декілька з них) є <code>true</code> або <code>false</code>. Це звучить як твердження <code>if</code>, і є дуже подібним. Річ в тому, що охоронці значно легше читаються, коли ви маєте декілька умов, і вони грають добре в команді з шаблонами.</p></div>
<div class="paragraph"><p>Замість пояснення їх синтаксису, давайте просто зануримось, та створимо функцію з використанням охоронців. Ми збираємось створити просту функцію, що кваліфікує вас відповідно до вашого індексу BMI (body mass index). Ваш BMI дорівнює вашій вазі, поділеній на ваш зріст в квадраті. Якщо ваш BMI менший за 18.5, в вас недостатньо ваги. Якщо ви десь між 18.5 до 25, ви відповідаєте нормі. Від 25 до 30 є надмірною вагою, і більше 30 це ожиріння. Так що ось функція (ми не будемо обчислювати прямо зараз, ця функція обчислює BMI та каже результат):</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Охоронці позначаються стовпчиками, що слідують за ім'ям функції та її параметрами. Зазвичай вони відступають трохи вправо, та відрівняні між собою. Охоронець в основі є логічний вираз. Якщо він обчислюється до <code>True</code>, тоді використовується відповідне тіло функції. Якщо він обчислюється до <code>False</code>, перевірка переходить до наступного охоронця і так далі. Якщо ми викличемо цю функцію з 24.3, вона спочатку перевірить, чи це меньше або рівне ніж 18.5. Оскільки це ні, переходимо до наступного охоронця. Перевірка каже, що другій охоронець пропускає, бо 24.3 меньше ніж 25.0, і повертається другий рядок.</p></div>
<div class="paragraph"><p>Це дуже нагадує велике дерево з <code>if</code> <code>else</code> в імперативних мовах, тільки це значно краще і гарно читається. Хоча великі дерева <code>if else</code> звичайно не схвалюються, іноді проблема виражена в такий дискретний спосіб, що ви не можете це обійти. Охоронці є гарною альтернативою для цього.</p></div>
<div class="paragraph"><p>Дуже часто останній охоронець є <code>otherwise</code>. <code>otherwise</code> визначене просто як <code>otherwise = True</code>, і відловлює все. Це дуже подібне до шаблонів, тільки вони превірять, чи задовільняє вхід шаблону, а охоронці перевіряють логічні умови. Якщо всі охоронці функції обчислюються до <code>False</code> (і ми не надали загального охоронця <code>otherwise</code>), обчислення провалюється до наступного шаблону. Ось як шаблони та охоронці гарно грають разом. Якщо не знайдено підходящого охоронця або шаблона закидається помилка.</p></div>
<div class="paragraph"><p>Звичайно, ми можемо використовувати охоронців з функціями, що приймають так багато параметрів, як нам треба. Замість того, щоб користувач обчислював власний BMI перед викликом функції, давайте модифікуємо цю функцію, так що вона братиме висоту та вагу, та розрахує все за нас.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Подивимось, чи я гладкий &#8230;</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вау! Я не товстий! Але Haskell все одно назвав мене огидним. Чортзна що!</p></div>
<div class="paragraph"><p>Зауважте, що немає <code>=</code> прямо після імені функції та її параметрами, перед першим охоронцем. Багато новачків отримують синтаксичну помилку, оскільки вони часто ставлять там рівняння.</p></div>
<div class="paragraph"><p>Інший дуже простий приклад: давайте реалізуєма власну функцію <code>max</code>. Якщо ви пам'ятаєте, вона приймає дві речі, що можна порівняти, та повертає більше з них.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Охоронці можуть бути записані в один рядок, хоча я не раджу цього, оскільки це менш читається, навіть для дуже коротких функцій. Але для демонстрації запишемо <code>max'</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Йо! Не читається взагалі! Рухаємось далі: давайте реалізуємо власну <code>compare</code> через використання охоронців.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note: ми не тільки можемо викликати функції інфіксно з апострофами, ми також можемо визначати їх з апострофами. Іноді так їх легше прочитати.</p></div>
<div class="paragraph"><p>В попередньому розділі ми визначили калькулятор BMI таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, що ми повторили себе тут три рази поспіль. Ми повторили себе три рази. Повторити себе (три рази) при програмуванні так само бажано, як вдаритись головою. Оскільки ми повторили вираз три рази, було б ідеальним, щоб ми могли обчислити його один раз, прікріпити до імені, і потім використовувати це ім'я замість виразу. Гаразд, ми можемо модифікувати нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми поклали ключове слово <code>where</code> після охоронців (зазвичай краще відступити так само, як здвинуті риски), та потім ми визначаємо декікька імен або функцій. Ці імена видимі в охоронцях, та дають нам перевагу не мати повторювати самих себе. Якщо ми вирішимо, що треба обчислювати BMI трохи інакше, ми маємо змінити це тільки один раз.  Це також покращує читабельність, надаючи імена речам, і може зробити наші програми видшими, оскільки такі речі, як наша змінна <code>bmi</code>, обчислюються тільки один раз. Ми можемо піти трохи далі, та представити нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Імена, які ми визначили в розділі <code>where</code> функції, видимі тількі в цій функції, так що ми не маємо турбуватись щодо забруднення простору імен інших функцій. Зауважте, що всі ці імена вирівнені в один стовпчик. Якщо ми не вирівняємо їх гарно і відповідно, Haskell буде засмучений, оскільки він не знатиме, що все це частини одного блоку.</p></div>
<div class="paragraph"><p>Прикріплення <code>where</code> не поділяються між тілами функцій для різних шаблонів. Якщо ви бажаєте, щоб декілька шаблонів однієї функції мали доступ до одного імені, ви маєте визначити його глобально.</p></div>
<div class="paragraph"><p>Ви також можете використовувати прикріплення <code>where</code> до порівняння шаблонів! Ви можете переписати розділ <code>where</code> попередньої функції таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте створимо іншу, досить тривіальну функці, де ми отримуємо перше та останнє ім'я, та повертаємо ініціали.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми можемо виконати це співпадіння шаблонів прямо в параметрах функції (вона насправді може бути коротшою та яснішою), але це показує тільки те, що це можливо зробити також в прикріпленнях <code>where</code>.</p></div>
<div class="paragraph"><p>Так само, як ми визначали константи в блоках <code>where</code>, ви також можете визначити функції. Дотримуючись нашої здорової теми програмування, давайте створимо функцію, що приймає список пар вага-висота, та повертає список BMI.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ось і все, що ми мали сказати про це! Причина, з якої ми мали ввести  <code>bmi</code> як функцію в цьому прикладі, це те, що ми не можемо обчислити один BMI з параметрів функції. Ми маємо перевіряти список, переданий до функції, і тут буде різний BMI для кожної пари.</p></div>
<div class="paragraph"><p><code>where</code> прикріплення також можуть бути вкладені. Це загальна ідіома, створити функцію, і визначити допоміжну функцію в її твердженні <code>where</code>, і потім надати цім функціям допоміжні функції, також, кожна в своєму власному твердженні <code>where</code>.</p></div>
<div class="paragraph"><p>Дуже подібні до <code>where</code> прикріалень є прикріплення <code>let</code>. <code>Where</code> прикріплення є синтаксичною конструкцією, що дозволяє вам прикріпляти змінні в кінці функції, та ціла функція може бачити їх, включаючи всіх охоронців. <code>Let</code> прикріплення дозволяють вам прикріпляти змінні будь де, та самі є виразами, але є дуже локальними, так що вони не поширюються серед охоронців. Так само, як любі конструкції в Haskell, що використовуються для прикріплення значень до імен, <code>let</code> прикріплення можуть використовуватись для співпадінь шаблонів. Давайте подивимось на це дії! Ось як ви можете визначити функцію, що дає нам площу циліндричної поверхні, базуючись на її висоті та радіусі:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/letitbe.png" alt="images/letitbe.png" />
</span>
Форма є <code>let &lt;bindings&gt; in &lt;expression&gt;</code>. Імена дає вам визначити в частині <code>let</code> доступною до виразу в частині <code>in</code>. Як ви можете бачити, ви можете також виразити це як <code>where</code> прив'язку. Зауважте, що імена також вирівняні в один стовпчик. То яка різниця між ціма двома? На тепер виглядає, що <code>let</code> покладає прикріплення першими, та вираз, що використовує їх після, тоді як <code>where</code> робить це навпаки.</p></div>
<div class="paragraph"><p>Різниця в тому, що <code>let</code> прикріплення самі є виразами. <code>where</code> прикріалення є тільки синтаксичніми конструкціями. Згадайте, як ми робили твердження <code>if</code>, та пояснювали, що твердження <code>if else</code> є виразом, і ви можете набивати його маже будь де?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви також можете робити це за допомогою <code>let</code> прикріплень.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вони також можуть бути використані для введення функцій в локальному полі зору:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми бажаємо прикріпити декілька змінних разом, ми, вочевидь, не можемо вирівняти їх в вигляді стовпчика. Ось чому ми можемо розділити крапками з комою.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви не маєте ставити крапку з комою після останнього прикріплення, але ви можете це зробити, якщо бажаєте. Як ми казали раніше, ви можете робити порівняння шаблонів з <code>let</code> прикріпленнями. Вони дуже корисні для швидкого розбирання тапла на компоненти, та прикріплення їх до імен, або чогось подібного.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви також можете покласти <code>let</code> прикріплення в осяжності списків. Давайте перепишемо наші попередні приклади обчислення списків пар ваги-висоти, щоб використовувати <code>let</code> в осяжності списків, замість визначення зовнішньої функції за допомогою <code>where</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми включили <code>let</code> в осяжність списків, майже так само як предикат, але він не фільтрує список, але тільки прив'язує імена. Імена, визначені в <code>let</code> всередині осяжності списків, видимий для функції виводу (частина перед <code>|</code>), та всі предикати та розділи, що ідуть після прикріплення. Так що ви можете зробити, щоб функція повертала тільки BMI для товстих людей:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми не можемо використовувати ім'я <code>bmi</code> в частині <code>(w, h) &lt;- xs</code>, оскільки вона визначена перед прикріпленням <code>let</code>.</p></div>
<div class="paragraph"><p>Ми оминули частину <code>in</code> прикріалення <code>let</code>, коли ми використовуємо їх в осяжностях списків, оскільки видимість імен тут завжди передвизначена. Однак ми можемо використовувати <code>let</code> в прикріпленні в предикаті, та визначені імена будуть видимі тільки в ціх предикатах. Частину <code>in</code> також можна оминути при визначенні функцій і констант прямо в GHCi. Якщо ми зробимо це, імена будуть видимі на протязі цілої інтерактивної сессії.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо <code>let</code> прикріплення такі круті, ви можете запитати, чому не використовувати їх весь час замість прикріплень <code>where</code>? Гаразд, оскільки <code>let</code> прикріплення є виразами та досить локальні в плані видимості, вони не можуть використовуватись серед охоронців. Деякі люди обирають <code>where</code> прикріалення, оскільки імена ідуть після функції, де вони використовуються. Таким чином, тіло функції ближче до його імені та його типу, і для декого це краще читати.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/case.png" alt="images/case.png" />
</span>
Багато імперативних мов (C, C++, Java, etc.) мають <code>case</code> синтаксис, і якщо ви колись програмували на них, ви можливо знаєте про що іде мова. Береться змінна, та потім виконуються блоки коду для специфічних значень цієї змінної, і можливо включає блок спіймати-всіх на випадок, коли змінна має значення, для якого ми не встановили <code>case</code>.</p></div>
<div class="paragraph"><p>Haskell приймає цю концепцію і покращує її. Як підказує ім'я, <code>case</code> вирази є, гаразд, виразами, подібно до <code>if else</code> виразів та <code>let</code> прикріплень. Ми не тільки можемо обчислювати вирази на основі можливих варіантів змінної, ми також можемо робити співпадіння шаблонів. Хммм, беремо змінну, порівнюємо її з шаблоном, обчислюємо частини коду на основі цього значення, де ми вже це бачили? Так, порівняння шаблонів на параметрах в визначеннях функції! Гаразд, це тільки синтаксичний цукор для <code>case</code>. Ці дві частини коду роблять те саме, і взаємозамінні:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис для <code>case</code> виразів є доволі простий:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>expression</code> порівнюється відносно <code>pattern</code>-ів. Порівняння шаблонів діє як очікується: перший шаблон, що співпадає з виразом, буде використаний. Якщо це провалюється через вираз <code>case</code>, і підходящого шаблону не знайдено, виникає помилка часу виконання.</p></div>
<div class="paragraph"><p>Хоча співпадіння на параметрах функцій може виконуватись тільки при визначенні функції, <code>case</code> вирази можуть бути використані майже будь де. Наприклад:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вони корисні для порівняння шаблонів з чимось всередині виразу. Оскільки співпадіння шаблонів в функції є синтаксичним цукром для <code>case</code> виразів, ми можемо також визначити це таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/recursion.png" alt="images/recursion.png" />
</span>
Ми коротко згадували рекурсію в попередній главі. В цій главі ми близько розглянемо рекурсію, чому вона важлива для Haskell, та як ми можете виробляти дуже стислі та елегантні рішення до проблем, розмірковуючи рекурсивно.</p></div>
<div class="paragraph"><p>Якщо ви все ще не знаєте що таке рекурсія, прочитайте це речення. Ха! Це просто жарт! Насправді рекурсія є шляхом визначення функцій, в яких функція застосовується в своєму власному визначенні. Визначення в математиці часто даються рекурсивно. Наприклад, послідовність Фібоначчі визначається рекурсивно. Спочатку ми визначаємо перші два числа Фібоначчі нерекурсивно. Ми кажемо, що <code>F(0) = 0</code> та <code>F(1) = 1</code>, що означає, що перший і другий елементи послідовності є <code>0</code> та <code>1</code>, відповідно. Потім ми кажемо, що для кожного іншого натурального числа число Фібоначчі є сумою попередніх двох чисел послідовності. Так що <code>F(n) = F(n-1) + F(n-2)</code>. Таким чином, <code>F(3)</code> є <code>F(2) + F(1)</code>, що є <code>(F(1) + F(0)) + F(1)</code>. Оскільки ми тепер дійшли до тільки нерекурсивно визначених чисел Фібоначчі, ми можемо безпечно сказати, що <code>F(3)</code> є <code>2</code>. Маючи елемент або два в рекурсивньому визначенні, визначені нерекурсивно, (як <code>F(0)</code> та <code>F(1)</code> тут), що також називаються граничними умовами, і важливо, якщо ви бажаєте, щоб ваша рекурсивна функція завершилась. Якщо ви не визначили <code>F(0)</code> та <code>F(1)</code> нерекурсивно, ви ніколи не отримаєте рішення для любого значення, бо дійдете до нуля, та потім пійдете по від'ємним числам. З часом ви дізнаєтесь, що <code>F(-2000)</code> є <code>F(-2001) + F(-2002)</code>, і все ще кінця цьому не буде видно!</p></div>
<div class="paragraph"><p>Рекурсія важлива в Haskell, оскільки на відміну від імперативних мов, ви робите обчислення в Haskell через декларацію, що є дещо, замість декларування того, як це треба отримати. Ось чому немає <code>while</code> циклів або <code>for</code> циклів в Haskell, і замість ми багато раз маємо використовувати рекурсію для декларування, чим є дещо.</p></div>
<div class="paragraph"><p>Функція <code>maximum</code> бере список речей, що можуть бути впорядковані (тобто примірників типокласу <code>Ord</code>), та повертає більший з них. Поміркуйте про те, як би ви реалізували це в імперативний спосіб. Ви б, можливо, встановили змінну для зберігання максимального значення, та потім би додали цикл по елементах списку, та якщо елемент більше, ніж поточне максимальне значення, ви заміщуюте його цім елементом. Максимальне значення, що залишиться в кінці, і є результат. Фу! Це досить багато слів для опису такого простого алгоритму!</p></div>
<div class="paragraph"><p>Тепер давайте подивимось, як ми визначемо це рекурсивно. Ми можемо спочатку встановити граничну умову, та сказати, що максимум синглтон списку дорівнює значенню його єдиного елементу. Потім ми можемо сказати, що максимум довшого списку є голова, якщо голова більша ніж максимум хвоста. Якщо максимум хвоста більший, гаразд, тоді максимум буде цей максимум хвоста. І все! Тепер давайте реалізуємо це в Haskell.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, порівняння шаблонів гарно пасує до рекурсії! Більшість імперативних мов не мають порівняння шаблонів, так що ви маєте робити багато <code>if else</code> тверджень для перевірки граничних умов. тут ми просто покладаємо їх як шаблони. Так що перша гранична умова каже, якщо список порожній, це крах! Має сенс, оскільки що буде максимумом порожнього списку? Я не знаю. Другий шаблон також окреслює граничну умову. Він каже, що якщо це синглтон список - просто повернути його єдиний елемент.</p></div>
<div class="paragraph"><p>Тепер третій шаблон, де відбувається справжня дія. Ми використовуємо співпадіння шаблонів для поділу списку на голову та хвіст. Це дуже загальна ідиома при виконанні рекурсії зі списками, так що використаємо її. Ми використовуємо <code>where</code> прикріплення для визначення <code>maxTail</code> як максимума залишку списка. Коли ми перевіряємо, чи голова більша ніж максимум залишку списку. Якщо це так, ми повертаємо голову. Інакше ми повертаємо максимум залишку списку.</p></div>
<div class="paragraph"><p>Давайте візьмемо список прикладу, та перевіримо, як це буде робити з ним: <code>[2,5,1]</code>. Якщо ми викличемо для нього <code>maximum'</code>, перші два шаблони не співпадуть. Третій співпаде, і поділить список на <code>2</code> та <code>[5,1]</code>. Твердження <code>where</code> бажає знати максимум від <code>[5,1]</code>, так що ми йдемо цім шляхом. Він знову співпадає з третім шаблоном, та <code>[5,1]</code> ділиться на <code>5</code> та <code>[1]</code>. Знову, твердження <code>where</code> бажає мати максимум від <code>[1]</code>. Оскільки це гранична умова, вона повертає <code>1</code>. Нарешті! Так що підіймаємось на рівень вище, порівнюючи <code>5</code> з максимумом <code>[1]</code> (що є <code>1</code>), і очевидно отримуємо <code>5</code>. Так що ми знаємо, що максимум <code>[5,1]</code> є <code>5</code>. Ми знову підіймаємось на один рівень вище, де ми маємо <code>2</code> та <code>[5,1]</code>. Порівняння <code>2</code> з максимумом <code>[5,1]</code>, що є <code>5</code>, ми обираємо <code>5</code>.</p></div>
<div class="paragraph"><p>Навіть ясніший шлях написати цю функцію є використання <code>max</code>. Якщо ви пам'ятаєте, <code>max</code> є функцією, що приймає два числа, та повертає більше з них. Ось як ми можемо переписати <code>maximum'</code> з використанням <code>max</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як це елегантно! В основному, максимум списку є <code>max</code> першого елементу та максимум хвоста.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/maxs.png" alt="images/maxs.png" />
</div>
</div>
<div class="paragraph"><p>Тепер, коли ми знаємо, як загалом мислити рекурсивно, давайте реалізуємо декілька функцій використовуючи рекурсію. Для початку реалізуємо <code>replicate</code>. <code>replicate</code> бере <code>Int</code> та деякий елемент, та повертає список, що має декілька повторень того самого елементу. Наприклад, <code>replicate 3 5</code> повертає <code>[5,5,5]</code>. Давайте думати про граничні умови. Я маю думку, що гранична умова <code>0</code> або меньше. Якщо ми спробуємо повторити дещо нуль раз, це має повертати порожній список. Також і для негативних чисел, оскільки це не має ніякого сернсу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми використали тут охоронців замість шаблонів, оскільки ми перевіряємо на логічні умови. Якщо <code>n</code> меньше або рівне до <code>0</code>, повертаємо порожній список. Інакше повертаємо список, що має <code>x</code> як перший елемент, та потім <code>x</code>, повторений <code>n-1</code> разів в якості хвоста. З часом частина <code>(n-1)</code> приведе нашу функцію до граничної умови.</p></div>
<div class="paragraph"><p>Note: <code>Num</code> не є субкласом до <code>Ord</code>. Це означає, що те, що належить до чисел, не обов'язково має бути впорядкованим. Ось чому ми маємо вказувати обоє обмеження, класи <code>Num</code> та <code>Ord</code>, і потім робити додавання і віднімання, а також порівняння.</p></div>
<div class="paragraph"><p>Далі ми реалізуємо <code>take</code>. Вона приймає певне число елементів зі списку. Наприклад, <code>take 3 [5,4,3,2,1]</code> буде повертати <code>[5,4,3]</code>. Якщо ми спробуємо взяти <code>0</code> або меньше елементів зі списку ми отримаємо порожній список. Зауважне ці дві граничні умови. Так що давайте запишемо:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/painter.png" alt="images/painter.png" />
</span>
Перший шаблон задає, що коли ми спробуємо взяти <code>0</code> або від'ємне число елементів, ми отримаємо порожній список. Зауважте, що ми використовуємо <code>_</code> для порівняння списку, оскільки нас насправді не турбує, що це в данному випадку. Також зауважте, що ми використовуємо охоронця, але без частини <code>otherwise</code>. Це означає, що якщо <code>n</code> виявиться більше ніж <code>0</code>, порівняння провалиться до наступного шаблону. Другий шаблон вказує, що якщо ми спробуємо взяти будь-що з порожнього списку, ми отримаємо порожній список. Третій шаблон розбиває список на голову та хвіст. І потім ми стверджуємо, що взяти <code>n</code> елементів зі списку те саме, що список, що має <code>x</code> в якості голови, та список, що бере <code>n-1</code> елементів з хвоста списка. Спробуйте взяти шматок папіру для запису, як виглядає це обчислення, якщо ми, скажімо, беремо <code>3</code> з <code>[4,3,2,1]</code>.</p></div>
<div class="paragraph"><p><code>reverse</code> просто обертає список. Подумайте про граничні умови. Що це буде? Гаразд &#8230; це порожній список! Порожній список обернений дорівнює самому порожньому списку. Окей. Як щодо інших варіантів? Ви можете сказати, що якщо розділити список на голову та хвіст, обернений список дорівнює оберненому хвосту, та потім голова в кінці.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це все!</p></div>
<div class="paragraph"><p>Оскільки Haskell підтримує нескінчені списки, наша рекурсія насправді не обов'язково повинна мати граничну умову. Але якщо вона не має її, вона або буде продовжувати накручувати без кінця, або продукувати безкінечну структуру даних. Гарна річ щодо безкінечних списків в тому, що ми можемо обрізати їх, якщо схочемо. <code>repeat</code> бере елемент, та повертає безкінечний список, що має цей елемент. Рекурсивна реалізація цього дійсно проста, дивіться.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Виклик <code>repeat 3</code> дасть нам список, що починається з <code>3</code>, і потім має безкінечну кількість <code>3</code> в хвості. Так що виклик <code>repeat 3</code> буде обчислюватись як <code>3:repeat 3</code>, що є <code>3:(3:repeat 3)</code>, що є <code>3:(3:(3:repeat 3))</code>, тощо. <code>repeat 3</code> ніколи не припинить обчислення, але <code>take 5 (repeat 3)</code> дасть нам список з п'яти трійок. Так що це те саме, що зробити <code>replicate 5 3</code>.</p></div>
<div class="paragraph"><p><code>zip</code> приймає два списки да поєднує їх разом. <code>zip [1,2,3] [2,3]</code> повертає <code>[(1,2),(2,3)]</code>, оскільки вона відсікає довший список до довжини коротшого. Що, коли ми поєднаємо щось з порожнім списком? Тоді ми знову отримаємо порожній список. Так що це наша гранична умова. Однак <code>zip</code> приймає два списки як параметри, так що насправді дві граничні умови.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Перші два шаблони кажуть, що якщо перший список або другий список порожні ми отримуємо порожній список. Третій каже, що два поєднані списки рівні до пари з їх голів, та потім список з поєднанних хвостів. Поєднання <code>[1,2,3]</code> та <code>['a','b']</code> з часом спробує <code>zip [3]</code> з <code>[]</code>. Гранична умова спрацьовує, і таким чином результат буде <code>(1,'a'):(2,'b'):[]</code>, що точно те саме, що і <code>[(1,'a'),(2,'b')]</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо ще одну функцію зі стандартної бібліотеки — <code>elem</code>. Вона бере елемент та список, та дивиться, чи елемент є в списку. Гранична умова, як в більшості випадків зі списками, це порожній список. Ми знаємо, що порожній список не має елементів, так що він напевне не має того, що ми шукаємо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить просто та очікувано. Якщо голова не є нашим елементом, тоді ми перевіряємо хвіст. Якщо ми досягли порожнього списку результатом буде <code>False</code>.</p></div>
<div class="paragraph"><p>Ми маємо з елементів, що може бути відсортований. Їх тип є примірником типокласу <code>Ord</code>. І тепер ми бажаємо відсортувати їх! Існує дуже крутий алгоритм сортування з назвою <code>quicksort</code>. Це дуже розумний спосіб сортувати елементи. Хоча це займає 10 рядків для реалізації <code>quicksort</code> на імперативних мовах, реалізація значно коротша і елегантніша на Haskell. Quicksort став різновидом візитівки для Haskell. Таким чином давайте реалізуємо його тут, навіть не зважаючи на те, що реалізація <code>quicksort</code> на Haskell стала загальним місцем, бо кожний робить її, щоб показати елегантність Haskell.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/quickman.png" alt="images/quickman.png" />
</span>
І так, сигнатура типу має бути <code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>. No surprises there. Гранична умова? Порожній список, як і очікувалось. Відсортований порожній список є порожній список. Тепер іде головний алоритм: сортований список є список, що має всі значення меньші (або еквівалентні до) голови списку спереду (і ці значення відсортовані), потім іде голова списку всередині і потім ідуть всі значення, що більші ніж голова (вони також відсортовані). Зауважте, що ми сказали <em>відсортовані</em> два рази в цьому визначенні, так що ми можливо маємо зробити рекурсивний виклик двічі! Також зауважте, що ми визначили його з використанням дієслова <em>is</em> для визначення алгоритму, замість казати роби це, роби те, потім оце &#8230;. Це краса функціонального програмування! Як ми збираємось фільтрувати список, так щоб він містив тільки елементи, меньші голови нашого списку, та елементи, що більші. Давайте зануримось, та визначимо цю функцію.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте зробимо невеликий тест щоб побачити, чи це робить коректно.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Клац! Ще те, про що я говорив! Так що коли ми маємо, скажімо, <code>[5,1,9,4,6,7,3]</code>, і ми маємо відсортувати його, цей алгоритм спочатку бере голову, що є <code>5</code>, і потім кладе посередині двох списків, тих що меньше та тих що більше. Так що в одній точці ви будете мати <code>[1,4,3] ++ [5] ++ [9,6,7]</code>. Ми знаємо, що коли список буде відсортований повністю, число <code>5</code> буде на четвертому місці, оскільки три числа меньші, та три числа більші ніж воно. Тепер, якщо ми відсортуємо <code>[1,4,3]</code> та <code>[9,6,7]</code>, ми матимемо відсортований список! Ми сортуємо два списки, використовуючи ту саму функцію. З часом ми розіб'ємо їх до того стану, що отримаємо порожні списки, а порожні списки вже відсортовані, хоча і порожні. Ось ілюстрація:</p></div>
<div class="imageblock">
<div class="content">
<img src="images/quicksort.png" alt="images/quicksort.png" />
</div>
</div>
<div class="paragraph"><p>Елемент, що вже на своєму місці, і більше не рухається, представлений помаранчевим. Якщо ви читаєте це зліва направо, ви побачите відсортований список. Хоча ми обрали порівнювати елементи з головою, ми можемо обрати кожний елемент для порівняння. В <code>quicksort</code> елемент, з яким ви порівнюєте має назву точки повороту. Вони тут зелені. Ми обрали їх як голову, бо її просто отримати через порівняння шаблонів. Елементи, що меньші за поворотну точку світло зелені, та більші елементи темно зелені. Жовтуватий градієнт представляє застосування <code>quicksort</code>.</p></div>
<div class="paragraph"><p>Ми вже наробили досі рекурсій, і ви можливо помітили, що тут є шаблон. Зазвичай ви визначаєте граничну умову, та потім ви визначаєте функцію, що робить щось між деяким елементом і функцією, застосованою до залишку. Не має значення, чи це список, дерево або люба інша структура даних. <code>sum</code> в перший елемент списку, плюс <code>sum</code> залишку списку. <code>product</code> списку є перший елемент списку, помножений на <code>product</code> залишку списку. Довжина списку є один плюс довжина хвоста списку. І так далі, і так далі &#8230;</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/brain.png" alt="images/brain.png" />
</span>
Звичайно, також існують граничні умови. Звичайно граничні випадки є деякий сценарій, де рекурсивне застосування не має сенсу. Коли маємо справу зі списками, граничний випадок найбільш часто є порожнім списком. Якщо ви маєте справу з деревами, це часто вузол, що не має жодних дітей.</p></div>
<div class="paragraph"><p>Це подібно до того, коли ви маєте справу з числами рекурсивно. Звичайно ми маєм осправу з деяким числом, і потім функцію, застосовану до модифікації цього числа. Ми робили функцію факторіала раніше, і це добуток числа і факторіала цього числа мінус одиниця. Таке рекурсивне застосування не має сенсу для нуля, оскільки факторіали визначені тільки для позитивних цілих. Часто граничним випадком є значення ідентичності. Для множення це 1, оскільки якщо ви помножите щось на 1, ви отримаєте те саме. Також коли ви робите суму списків, ми визначаємо суму порожнього списку як 0, і 0 є ідентичність для додавання. В <code>quicksort</code> граничний випадок є порожній список, оскільки якщо ви додасте порожній список до списка, ви отримаєте всього лише оригінальний список.</p></div>
<div class="paragraph"><p>Таким чином, коли намагаєтесь думати в рекурсивний спосіб для вирішення проблеми, намагайтесь подумати, коли рекурсивність не може застосовуватись, і побачте, чи ви не можете використати це в якості граничного випадку, подумайте про ідентичності, і подумайте, чи ви можете розбити на частини параметри функції (наприклад, списки зазвичай розбиваються на голову та хвіст через порівняння шаблонів), і на якій частині ви будете застосовувати рекурсивний виклик.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/sun.png" alt="images/sun.png" />
</span>
Функції Haskell можуть приймати функції як параметри, та повертати функції як значення повернення. Функція, що робить щось з цього, називається функцією вищого порядку. Функції вищого порядку є не тільки частиною досвіду Haskell, вони в великій мірі є сам досвід Haskell. З'ясовується, що якщо ви бажаєте визначити обчислення, визначаючи що це таке, замість визначати кроки, що змінюють деякий стан та можливо роблячи цикли, функції вищих порядків незамінні. Вони дійсно є потужним способом вирішення проблем і думати про программи.</p></div>
<div class="paragraph"><p>Кожна функція в Haskell офіційно приймає тільки один параметр. Так як це можливо, що ми визначили декілька функцій, що приймають більше ніж один параметр? Гаразд, це дотепний трюк! Всі функції, що приймають декілька параметрів, були карованими функціями. Що це означає? Ви краще зрозумієте це на прикладі. Давайте візьмемо нашого гарного друга, функцію <code>max</code>. Виглядає, що вона приймає два параметри, та повертає той, що більше. Виконання <code>max 4 5</code> спочатку створює функцію, що приймає параметр, і повертає або <code>4</code>, або цей параметр, в залежності що більше. Потім 5 застосовується до цієї функції, і ця функція продукує наш бажаний результат. Це виглядає як балачка, але насправді це крута концепція. Наступні два виклики еквівалентні:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/curry.png" alt="images/curry.png" />
</span>
Покладання проміжка між двома речами є просто застосування функції. Проміжок є різновидом оператора, і він має найвищий преоритет. Давайте перевіримо тип <code>max</code>. Це <code>max ::( Ord a) =&gt; a -&gt; a -&gt; a</code>. Він може бути записаний як <code>max ::( Ord a) =&gt; a -&gt; (a -&gt; a)</code>. Це може бути прочитане так: <code>max</code> бере <code>a</code>, та повертає (це <code>-&gt;</code>) функцію, що бере <code>a</code> та повертає <code>a</code>. Ось чому тип повернення та параметри функцій просто розділені стрілками.</p></div>
<div class="paragraph"><p>Погляньте на цю образливо просту функцію:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>То як це вигідно для нас? Кажучи просто, якщо ми викликаємо функцію з недостатньою кількістю параметрів, ми отримаємо назад частково застосовану функцію, що приймає стільки параметрів, скльки ми залишили. Використання часткового застосування (виклик функцій з недостатньою кількістю параметрів, якщо бажаєте), є милий спосіб створювати функції на льоту, так що ми можемо передавати їх до інших функцій, або наповнювати їх деякими даними.</p></div>
<div class="paragraph"><p>Що насправді відбувається, коли ми робимо <code>multThree 3 5 9</code> або <code>( (multThree 3) 5) 9</code>? Спочатку <code>3</code> застосовується до <code>multThree</code>, оскільки вони розділені проміжком. Це створює функцію, що приймає один параметр, та повертає функцію. Так що <code>5</code> застосовується до цього, це створює функцію, що буде брати параметр, та множити його на <code>15</code>. <code>9</code> застосовується до цієї функції, та результат буде <code>135</code>, або десь так. Пам'ятайте, що цей тип функції може бути переписаний як <code>multThree ::( Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</code>. Річ перед <code>-&gt;</code> є параметр, що приймає функція, і річ, що йде після цього є те, що вона повертає. Так що наша функція приймає <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; (a -&gt; a)</code>. Подібно до цього, ця функція бере <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; a</code>. І ця функція, нарешті, просто бере <code>a</code> і повертає <code>a</code>. Погляньте на це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Викликаючи функції з недостатніми параметрами, так би мовити, ми створюємо функції на льоту. Що, якщо ми бажаємо створити функцію, що приймає число, та порівнюєте його зі <code>100</code>? Ми можемо зробити щось подібне до наступного:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми викличемо її з <code>99</code>, вона поверне <code>GT</code>. Прості речі. Зауважте, що <code>x</code> зправа по обі сторони від рівності. Тепер давайте подумаємо щодо того, що повертає <code>compare 100</code>. Воно повертає функцію, що бере число, та порівнює його з <code>100</code>. Вау! Чи це не функція, яку ми бажали? Ми можемо переписати це так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Декларація типу каже те саме, оскільки <code>compare 100</code> повертає функцію. <code>Compare</code> має тип <code>(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code>, та виклик її з <code>100</code> повертає <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. Додаткове обмеження класу присутнє, оскільки <code>100</code> також є частиною типокласу <code>Num</code>.</p></div>
<div class="paragraph"><p>Йо! Переконайтесь, що ви справді розумієте, як роблять каровані функції та робить часткове застосування, бо воні справді важливі!</p></div>
<div class="paragraph"><p>Інфіксні функції також можуть бути частково застосовані з використанням секцій. Для секції інфіксної функції просто оточите її дужками, і надайте параметр тільки з однієї сторони. Це створить функцію, що приймає один параметр, та потім застосовує його до сторони, де відсутній операнд. Образливо тривіальна функція:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Виклик, скажімо, <code>divideByTen 200</code> еквівалентне до <code>200 / 10</code>, так само, як зробити <code>(/10) 200</code>. Функція, що перевіряє, що наданий символ є великою літерою:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Єдина особлива річ щодо секцій є використання <code>-</code>. З визначення секцій <code>(-4)</code> має давати результат в вигляді функції, що приймає число, та віднімає <code>4</code> з нього. Однак для зручності <code>(-4)</code> означає мінус чотири. Так що якщо ви бажаєте створити функцію, що віднімає <code>4</code> від часла як параметра, частково застосуйте функцію <code>subtract</code> таким чином: <code>(subtract 4)</code>.</p></div>
<div class="paragraph"><p>Що трапиться, якщо ми спробуємо просто зробити <code>multThree 3 4</code> в GHCI, замість прикріплення її до імені за допомогою <code>let</code>, або передачі її до іншої функції?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>GHCI каже нам, що вираз спродукував функцію типу <code>a -&gt; a</code>, але воно не знає, як друкувати її на екрані. Функції не є членами типокласу  <code>Show</code>, так що ви не можете отримати милого рядкового представлення функції. Коли ми робимо, скажімо, <code>1 + 1</code> в підказці GHCI, воно спочатку ообчислює <code>2</code>, та потім викликає <code>show</code> на <code>2</code> для отримання текстуального представлення числа. І текстуальна репрезентація <code>2</code> є просто рядок <code>"2"</code>, що друкується на екрані.</p></div>
<div class="paragraph"><p>Функції можуть приймати функції як параметри і також повертають функції. Щоб проілюстровати це, ми збираємось створити функцію, що приймає функцію, та потім застосовує її двічі до будь-чого!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bonus.png" alt="images/bonus.png" />
</span>
Для початку зауважте декларацію типу. Перед цім ми не потребували дужок, оскільки <code>-&gt;</code> є право асоціативним. Але тут воно обов'язкове. Це каже, що перший параметр є функція, що приймає дещо, та повертає ту саму річ. Другий параметр є дещо, і цього ж типу також значення повернення. Ми можемо читати цю декларацію типу, але щоб не заморочуватись ми просто скажемо, що ця функція приймає два параметри, та повертає одну річ. Перший параметр є функція (типу <code>a -&gt; a</code>) та другий те саме <code>a</code>. Функція також може бути <code>Int -&gt; Int</code> або <code>String -&gt; String</code>, або будь-що. Але потім другий параметр має також бути того самого типу.</p></div>
<div class="paragraph"><p>Note: Відтепер ми будемо казати, що функції приймають декілька параметрів, незважаючи на те, що кожна функція насправді бере тільки один параметр, та повертає частково застосовані функції, доки ми не досягнемо функцію, що повертає справжнє значення. Так що для спрощення ми кажемо, що <code>a -&gt; a -&gt; a</code> бере два параметри, навіть маючи на увазі, що це відбувається за лаштунками.</p></div>
<div class="paragraph"><p>Тіло функції досить просте. Ми просто використовуємо параметр <code>f</code> як функцію, застосовуючи <code>x</code> до неї, розділяючи їх проміжками, і потім застосовуючи результат знову до <code>f</code>. В любому випадку пограємось з функцією:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Дивовижність та корисність часткових функцій є очевидною. Якщо наша функція потребує передати їй функцію, що приймає тільки один параметр, ви можете тільки частково застосувати функцію до тієї точки, коли вона прийматиме тільки один параметр, та потім передати її.</p></div>
<div class="paragraph"><p>Тепер ми збираємось використати програмування вищого порядку для реалізації насправді корисної функції, що є в стандартній бібліотеці. Вона називається <code>zipWith</code>. Вона бере функцію та два списки як параметри, та потім поєднує два списки, застосовуючи функцію між відповідними елементами. Ось як ми реалізуємо її:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Подивимось на декларацію типу. Перший параметр є функція, що бере дві речі і повертає третю річ. Вони не мають бути того самого типу, але вони можуть. Другий та третій параметр є списками. Результат також список. Перший має бути списком з <code>a</code>, оскікльки функція поєднання бере <code>a</code> як перший аргумент. Другий має бути списком <code>b</code>, тому що другий параметр функції поєднання має тип <code>b</code>. Результатом є список <code>c</code>. Якщо декларація типу функції каже, що вона сприймає функцію <code>a -&gt; b -&gt; c</code> як параметр, вона також сприйматиме функцію <code>a -&gt; a -&gt; a</code>, але не навпаки! Пам'ятайте, що коли в створюєте функції, особливо вищого порядку, і ви не впевнені щодо типу, ви можете просто оминути декларацію типу, та потім перевірити, що Haskell виводить щодо типу через <code>:t</code>.</p></div>
<div class="paragraph"><p>Дія в функції досить подібна до звичайного <code>zip</code>. Граничні умови ті самі, тільки є додатковий аргумент, функція поєднання, але цей аргумент не має значення в граничних умовах, так що ми використовуємо <code>_</code> щодо цього. Та тіло функції останнього шаблону подібне до <code>zip</code>, але він не робить <code>(x,y)</code>, але <code>f x y</code>. Єдина функція вищого порядку може бути використана для безлічі різних завдань, якщо вона досить загальна. Ось маленька демонстрація всьго різноманіття речей, що може робити наша функція <code>zipWith'</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, єдина функція вищого порядку може бути використана в дуже різноманітний спосіб. Імперативне програмування зазвичай використовує речі як <code>for</code> цикли, <code>while</code> цикли, присвоєння чогось до змінної, перевірка її стану, тощо, щоб досягти певної поведінки та потім огорнути її в інтерфейс, такий як функція. Функціональне програмування використовує функції вищого порядку щоб абстрагувати загальні шаблони, як попарно екзаменувати два списки, та потім робити щось з ціма парами, або отримати набір рішень, та відкинути ті, що нам не потрібні.</p></div>
<div class="paragraph"><p>Давайте реалізуємо іншу функцію, що вже є стандартній бібліотеці, що називається <code>flip</code>. <code>Flip</code> просто бере функцію, та повертає функцію, що подібна до нашої оригінальної функції, тільки два перших аргументи обміняні місцями. Ми можемо реалізувати її таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Читаючи декларацію типу ми кажемо, що вона бере функцію, що приймає <code>a</code> та <code>b</code>, та повертає функцію, що приймає <code>b</code> та <code>a</code>. Але оскільки функції каровані по замовчанню, друга пара дужок не є насправді потрібною, бо <code>-&gt;</code> є право асоціативним по замовчанню. <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> є те саме, що і <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, що те саме, що і <code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. Ми записуємо, що <code>g x y = f y x</code>. Якщо це так, тоді <code>f y x = g x y</code> має також дотримуватись, вірно? Маючи це на увазі, ми можемо визначити цю функцію навіть в ще простіший спосіб.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут ми отримуємо вигоду від факту, що функція карована. Коли ми в икликаємо <code>flip' f</code> без параметров <code>y</code> та <code>x</code>, вона буде повертати <code>f</code>, що бере ці два параметри, але переставляє їх місцями. Навіть не зважаючи на те, що функції з перестановкою звичайно передаються в інші функції, ви можете отримати перевагу від карування, та потім створювати функції вищих порядків, при цьому розмірковуючи наперед, та написання їх таким чином, щоб остаточний результат був би такий, якби вони були повністю застосовані.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>map</code> приймає функцію та список, та застосовує цю функцію до кожного елементу, продукуючи новий список. Давайте подивимось, яка в неї сигнатура типу, та як вона визначена.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Сигнатура типу каже, що вона приймає функцію, що приймає <code>a</code> та повертає <code>b</code>, список <code>a</code> перетворюється на список <code>b</code>. Цікаво, що просто дивлячись на сигнатуру типу функції, ви можете інколи сказати, що вона робить. <code>map</code> одна з ціх дійсно універсальних функцій вищого порядку, що може використовуватись в мільйони різних способів. Ось вона в дії:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви, можливо, зауважили, що все це можна досягти осяжністю списків. <code>map (+3) [1,5,3,1,6]</code> те саме, що написати <code>[x+3 | x &lt;- [1,5,3,1,6]]</code>. Однак використання <code>map</code> значно краще читається для випадків, коли ви лише застосовуєте функцію до елементів списку, особливо коли ви маєте справу з мапою мап, і тоді ціла річ з багатьма дужками може стати заплутаною.</p></div>
<div class="paragraph"><p><code>filter</code> є функцією, що приймає предикат (предикат є функція, що каже, чи дещо вірно або ні, так що в нашому випадку повертає логічне значення), та список, та потім повертає список елементів, що задовільняє предикату. Сигнатура типу та реалізація виглядають так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Доволі проста річ. Якщо <code>p x</code> обчислюється до <code>True</code>, елемент буде включений в новий список. Якщо ні, елемент відкидається. Деякі приклади використання:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Все це можна досягти за допомогою осяжності списків через використання предикатів. Немає встановленого правила для використання <code>map</code> та <code>filter</code>, проти використання осяжності списків, вам треба просто визначити, що читається краще в залежності від коду та контексту. <code>filter</code> еквівалентно до застосування декількох предикатів в осяжності списків, або фільтруючи дещо декілька раз, або поєднуючи предикати логічною функцією <code>&amp;&amp;</code>.</p></div>
<div class="paragraph"><p>Пам'ятаєте нашу функцію <code>quicksort</code> з минулої глави? Ми використовували осяжність списків для фільтрування елементів списку, що меньші (або рівні), та більше ніж переломна точка. Ми можемо досягти такої самої функціональності в більш читаємий спосіб, за допомогою <code>filter</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/map.png" alt="images/map.png" />
</span>
Відображення та фільтрація є хліб та масло серед інструментів кожного функціонального програміста. Так. Не має значення, чи ви робите це за допомогою функцій <code>map</code> та <code>filter</code>, або осяжністю списків. Згадайте, як ми вірішували проблема пошуку правильних трикутників в певному колі. В імперативному програмуванні ми можемо вирішити це через вкладання трьох циклів, та потім перевіряючи, чи поточна комбінація задовільняю умовам трикутника, що має заданий периметр. Якщо це так, ми можемо роздрукувати це не екрані, або зробити щось інше. В функціональному програмуванні цей шаблон досягається через відображення та фільтрацію. Ви створюєте функцію, що приймає значення та продукує деякий результат. Ми відображуємо цю функцію на списку значень, та потім ми фільтруємо результуючий список щодо результатів, які задовільняють умовам пошуку. Дякуючи лінивості Haskell, навіть якщо ви робите <code>map</code> по списку декілька разів і фільтруєте його декілька раз, він пройде по списку один раз.</p></div>
<div class="paragraph"><p>Давайте знайдемо найбільше число до <code>100,000</code> що ділиться на <code>3829</code>. Щоб зробити це, ми просто відфільтруємо набір можливостей, де за нашими підрахунками знаходяться наші рішення.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Спочатку створимо список всіх чисел, меньших <code>100,000</code> від великих до малих. Потім ми фільтруємо його по нашому предикату, і оскільки числа ідуть від великих, найбільше число за нашою умовою буде першим в списку результатів. Нам навіть не треба використовувати скінчений список для початку нашої множини. Це знову лінивість в дії. Оскільки ми закінчуємо використанням голови відфільтрованого списку, не має значення, чи ми фільтруємо скінчений список, або безкінечний. Обчислення зупиняється, коли буде знайдене перше адекватне рішення.</p></div>
<div class="paragraph"><p>Далі ми збираємось знайти суму всіх непарних квадратів, що меньше <code>10,000</code>. Але спочатку, оскільки ми використовуємо її в нашому рішенню, ми збираємось ввести функцію <code>takeWhile</code>. Вона приймає предикат і список, і потім проходить від початку списку, та повертає елемнти, доки предикат повертає істину. Як тільки знайдений елемент, для якого умова не виконується, все завершується. Якщо ви бажаєте отримати перше слово на початку рядка <code>"elephants know how to party"</code>, ми можемо зробити <code>takeWhile (/=' ') "elephants know how to party"</code>, що поверне <code>"elephants"</code>. Гаразд. Сума всіх непарних квадратів, що меньша <code>10,000</code>. Перше, ми почнемо з відображення функції <code>(^2)</code> на безкінечний список <code>[1..]</code>. Потім ми фільтруємо їх, щоб отримати лише непарні. І потім ми беремо елементи з цього списку, доки вони меньші ніж <code>10,000</code>. Нарешті ми отримуємо суму цього списку. Нам навіть немає потреби визначати для цього функцію, ми можемо зробити це в один рядок в GHCI:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Блискуче! Ми почали з деяких початкових даних (нескінчений список з усіх натуральних чисел), та потім ми робимо <code>map</code> по них, <code>filter</code> по ньому, та відсікаємо їх, доки він задовільняє нашим потребам, та потім підсумовуємо докупи. Ми можемо також переписати це, використовуючи осяжності списків:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Те, що ми обираємо, є лише справою смаку. І знову, властивість лінівості Haskell є те, що робить це можливим. Ми можемо робити відображення та фільтрувати по безкінечному списку, оскільки це насправді безпосередньо не робитиме <code>map</code> та <code>filter</code>, ці дії буде відкладено. Тільки коли ми змусимо Haskell показати нам суму буде викликана <code>sum</code>, що зробить <code>takeWhile</code> для отримання ціх чисел. <code>takeWhile</code> змушує виконання фільтрування та відображення, але тільки до тих пір, доки не трапиться число більше або рівне до <code>10,000</code>.</p></div>
<div class="paragraph"><p>Для нашої наступної проблеми ми будемо мати справу з послідовностями <code>Collatz</code>. Ми беремо натуральне число. Якщо число парне, ми ділимо його на два. Якщо воно непарне, ми множимо його на <code>3</code>, і потім додаємо <code>1</code>. Ми беремо результуюче число, та застосовуємо до нього ту саму річ, що продукує нове число, і так далі. В основі ми отримуємо ланцюжок чисел. Є думка, що для всіх початкових чисел ланцюжки закінчуються числом <code>1</code>. Так що якщо ми візьмемо початкове число <code>13</code>,ми отримаємо таку послідовність: <code>13</code>, <code>40</code>, <code>20</code>, <code>10</code>, <code>5</code>, <code>16</code>, <code>8</code>, <code>4</code>, <code>2</code>, <code>1</code>. <code>13*3 + 1</code> дорівнює <code>40</code>. <code>40</code> поділене на <code>2</code> є <code>20</code>, тощо. Ми бачимо, що ланцюжок має <code>10</code> термів.</p></div>
<div class="paragraph"><p>Те, що ми бажаємо знати, є наступним: для всіх початкових чисел між  <code>1</code> та <code>100</code>, як багато ланцюжків мають довжину, більшу ніж <code>15</code>? Спочатку ми напишемо функцію, що продукує ланцюжок:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки ланцюжки закінчуються на <code>1</code>, це буде граничний випадок. Це досить стандартна рекурсивна функція.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вау! Здається це робить коректно. І тепер функцію, що дає відповідь на наше запитання:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми відображуємо функцію <code>chain</code> до <code>[1..100]</code>, щоб отримати список ланцюжків, що самі представлені як списки. Потім ми фільтруємо їх предикатом, що тільки перевіряє, чи довжина більше ніж <code>15</code>. Як тільки ви виконали фільтрацію, ми бачимо, скільки ланцюжків залишилось в результуючому списку.</p></div>
<div class="paragraph"><p>Note: Ця функція має тип <code>numLongChains ::Int</code>, оскільки <code>length</code> повертає <code>Int</code> замість <code>Num</code> з історичних причин. Якщо ви бажаєте повертати більш загальне <code>Num</code>, ми можемо використати <code>fromIntegral</code> на результуючій довжині.</p></div>
<div class="paragraph"><p>Використовуючи <code>map</code>, ми також можемо робити речі, як <code>map (* ) [0..]</code>, якщо і не з іншої причини, ніж проілюструвати, як робить карування, та як (частково застосовані) функції є реальними значеннями, які ви можете передати по кругу до інших функцій, або покласти в списки (ви тільки не можете перетворити їх на рядки). Досі ми тільки відображали функції, що бере один параметр зі списку, як <code>map (* 2) [0..]</code> для отримання списку типу <code>(Num a) =&gt; [a]</code>, але ми також можемо робити <code>map (* ) [0..]</code> без проблем. Що трапиться тут, це те, що число в списку застосовується до функції <code>* `, що має тип `(Num a) =&gt; a -&gt; a -&gt; a</code>. Застосовуючи тільки один параметр до функції, що приймає два параметра, повертає функцію, що приймає один параметр . Якщо <code>* ` по списку `[0..]</code>, ми отримаємо список функцій, що приймають тільки один параметр, так що <code>(Num a) =&gt; [a -&gt; a]</code>. <code>map (* ) [0..]</code> продукує список, як такий, що ми отримаємо, написавши <code>[(0*),(1*),(2*),(3*),(4*),(5*)..</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Отримавши елемент з індексом <code>4</code> з нашого списку повертаємо функцію, що еквівалентна до <code>(4*)</code>. Та потім ми просто застосовуємо 5 до цієї функції. Так що це як написати <code>(4*) 5</code>, або просто <code>4 * 5</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lambda.png" alt="images/lambda.png" />
</span>
Лямбда в основному анонімні функції, що використовуються, оскільки нам треба деякі функції тільки один раз. Звичайно ми створюємо лямбду з єдиним призначенням передати її в функцію вищого порядку. Щоб створити лямбду ми пишемо <code>\</code> (оскільки це виглядає дещо подібно на грецьку літеру лямбда, якщо придивитись досить сильно), та потім ми пишемо параметри, розділені проміжками. Після цього іде <code>-&gt;</code>, та потім тіло функції. Ми звичайно оточуємо їх в дужки, оскільки інакше вони розширюються весь час вправо.</p></div>
<div class="paragraph"><p>Якщо ви подивитесь на 5 дюймів вище, ви побачите, що ми використовували <code>where</code> прикріплення в нашій функції <code>numLongChains</code> для створення функції <code>isLong</code> для єдиного призначення передати її в фільтр. Гаразд, замість цього ми можемо використати лямбду:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Лямбди є виразами, і ось чому ми тільки можемо передати їх таким чином. Вираз <code>(\xs -&gt; length xs &gt; 15)</code> повертає функцію, що каже нам, чи довжина списку, переданому до них, більше ніж <code>15</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lamb.png" alt="images/lamb.png" />
</span>
Люди, що не дуже знайомі з тим, як роблять карування та часткове застосування, часто використовують лямбди там, да цього не треба робити. Наприклад, вирази <code>map (+3) [1,6,3,2]</code> та <code>map (\x -&gt; x + 3) [1,6,3,2]</code> еквівалентні, оскільки обоє, <code>(+3)</code> та <code>(\x -&gt; x + 3)</code> є функціями, що приймають число, та додають до нього <code>3</code>. Не треба казати, що створення лямбди в цьому випадку є марним, оскільки використання часткового застосування значно більше читабельне.</p></div>
<div class="paragraph"><p>Як нормальні функції, лямбди можуть приймати любе число параметрів:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Та як це нормальна функція, ви можете робити в лямбді співпадіння шаблонів. Єдина різниця в тому, що ви не можете визначити декілька шаблонів для одного параметру, як зробити <code>[]</code> та <code>(x:xs)</code> шаблони для одного параметру, та потім мати значення, що провалюються. Якщо співпадіння шаблонів схибиться в лямбді, виникне помилка виконання, так що будьте уважні, коли порівнюєте шаблони в лямбдах!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Лямбди зазвичай оточені дужками, якщо тільки ми не хочемо, щоб вони поширювались весь час вправо. Тут є дещо цікаве: через спосіб, як функції каровані по замовчанню, наступні два варіанти еквівівалентні:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо визначити функцію таким чином, стає зрозумілим, чому її декларація типу така, як вона є. Є три <code>-&gt;</code> в обох деклараціях типу і рівності. Але, звичайно, перший спосіб запису функції значно більш читабельний, другий є скоріше трюком для демонстрації карування.</p></div>
<div class="paragraph"><p>Однак є випадки, коли використання цієї нотації є крутим. Я думаю, що функція перестановки <code>flip</code> найбільш зрозуміла, коли записана таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Навіть якщо це те саме, що і написати <code>flip' f x y = f y x</code>, ми робимо очевидним, що це буде використане для створення нової функції в більшості випадків. Найбільш загальний випадок використання для <code>flip</code> є виклик її з тільки однією функцією-параметром, та потім передати отриману функцію далі до <code>map</code> або <code>filter</code>. Так що в
икористовуйте лямбди в цей спосіб, коли ви бажаєте зробити явним, щваша функція здебільшого призначена бути частково застосованою та переданою до деякої функції як параметр.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/origami.png" alt="images/origami.png" />
</span>
Раніше, коли мали справу з рекурсією, ми зауважили лейтмотив в більшості рекурсивних функцій, що оперують зі списками. Зазвичай ми маємо граничний випадок для порожнього списку. Ми ввели шаблон <code>x:xs</code>, та потім ми виконували деяку дію, що включає один елемент та залишок списку. З'ясовується, що це дуже загальний шаблон, так що для його енкапсуляції були введені декілька функцій. Ці функції мають назву згорток <code>fold</code>. Вони є деяким різновидом функції <code>map</code>, тільки вони скорочують список до деякого одного значення.</p></div>
<div class="paragraph"><p><code>fold</code> бере двомісну функцію, початкове значення (мені подобається називати її аккумулятором) та список, що треба згорнути. Сама двомісна функція приймає два параметри. Двомісна функція викликається з акумулятором та першим (або останнім) елементом, та продукує новий акумулятор. Потім двомісна функція викликається знову з новим акумулятором та тепер новим першим (або останнім) елементом, і так далі. Коли ми пройшли по всьому списку, залишається лише аккумулятор, і це те, до чого ми скоротили список.</p></div>
<div class="paragraph"><p>Спочатку давайте поглянемо на функцію <code>foldl</code>, що також називають лівою згорткою. Вона згортає список з лівогоо боку. Двомісна функція застосовується між початковим значенням та головою списку. Це продукує нове значення аккумулятора, і двомісна фінкція викликається з цім значенням та наступним елементом, тощо.</p></div>
<div class="paragraph"><p>Давайте знову реалізуємо <code>sum</code>, тільки на цей рез через <code>fold</code> замість явної рекурсії.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тестуємо, раз-два-три:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/foldl.png" alt="images/foldl.png" />
</span>
Давайте глибоко розглянемо, як відбувається цей <code>fold</code>. <code>\acc x -&gt; acc + x</code> є двомісна функція. <code>0</code> є початкове значення, та <code>xs</code> є список, що згортається. Тепер спочатку <code>0</code> використовується як параметр <code>acc</code> до двомісної функції, та <code>3</code> використовується як параметр <code>x</code> (або поточний елемент). <code>0 + 3</code> продукує <code>3</code> і це стає новим значенням аккумулятора. На наступному кроці <code>3</code> використовується як значення аккумулятора та <code>5</code> як поточний елемент, після цього <code>8</code> стає новим значенням аккумулятора. Рухаючись далі, <code>8</code> є значенням аккумулятора, 2 поточним елементом, нове значення аккумулятора <code>10</code>. Нарешті, це <code>10</code> використовується як значення аккумулятора, <code>1</code> поточний елемент, що продукує <code>11</code>. Вітаємо, ви виконали згортання!</p></div>
<div class="paragraph"><p>Ця професійна діаграма зліва ілюструє як відбувається згортка, крок за кроком (день за днем!). Зеленувате коричневе число є значення аккумулятора. Ви можете бачити, як цей список свого роду споживається з лівого боку акумулятором. Ням-ням-нам! Якщо ви приймете до уваги, що функції каровані, ви можете записати цю реалізацію навіть більш скорочено, десь так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Лямбда функція <code>(\acc x -&gt; acc + x)</code> є те саме, що <code>(+)</code>. Ми можемо уникнути параметра <code>xs</code>, оскільки виклик <code>foldl (+) 0</code> буде повертати функцію, яка приймає список. Загалом, якщо ви маєте функцію, як <code>foo a = bar b a</code>, ви можете переписати її як <code>foo = bar b</code> завдяки каруванню.</p></div>
<div class="paragraph"><p>Так чи інакше, давайте реалізуємо іншу функцію з лівим <code>fold</code> перед тим, як перейти до правих <code>fold</code>. Я впевнений, що ви всі знаєте, що `elem`перевіряє, чи значення є частиною списку, так що я не буду проходитись по цьому ще раз (я знову зробив це!). Давайте зробимо це за допомогою лівої згортки.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гаразд, гаразд, гаразд, що ми тут маємо? Початкове значення та аккумулятор тут логічні значення. Тип значення аккумулятора та результуючого значення завжди те саме, коли маємо справу зі згортками. Пам'ятайте, що якщо ви колись не знаєте, що використовувати як початкове значення, це дасть вам якусь ідею. Ми розпочинаємо з <code>False</code>. Має сенс використовувати <code>False</code> як стартове значення. Ми вважаємо, що того, що ми шукаємо, тут немає. Також якщо викличемо <code>fold</code> на порожньому списку, результатом буде просто стартове значення. Потім ми перевіряємо поточний елемент, чи є він те, що ми шукаємо. Якщо так, ми встановлюємо аккумулятор в <code>True</code>. Якщо ні, ми просто залишаємо аккумулятор незмінним. Якщо він до цього був <code>False</code>, він залишається таким самим, бо цей елемент не те, що треба. Якщо він був <code>True</code>, ми залишаємо його таким самим.</p></div>
<div class="paragraph"><p>Права згортка, <code>foldr</code>, робить в подібний спосіб як ліва, тільки аккумулятор з'їдає значення зправа. Також двомісна функція лівої згортки має акумулятор як перший параметр, та поточне значення як друге значення (так що <code>\acc x -&gt; ...</code>), двомісна функція правої згортки має поточне значення як перший параметр, та аккумулятор як другий (так що <code>\x acc -&gt; ...</code>). Це має деякий сенс, що права згортка має аккумулятор зправа, оскільки вона згортає з правого боку.</p></div>
<div class="paragraph"><p>Значення аккумулятора (і, таким чином, результат) згортки може бути любого типу. Це може бути число, логічне, або навіть новий список. Ми реалізуємо функцію <code>map</code> за допомогою правої згортки. Аккумулятором буде список, де ми будемо аккумулювати відображений список елемент за елементом. Виходячи з цього є очевидним, що початковим елементом буде порожній список.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми відображуемо <code>(+3)</code> до <code>[1,2,3]</code>, ми підходимо до списку з правого боку. Ми беремо останній елемент, що є <code>3</code>, та застосовуємо до нього функцію, що в результаті дає <code>6</code>. Потім ми ставимо його на початок аккумілятора, що був <code>[]</code>. <code>6:[]</code> є <code>[6]</code>, і це тепер значення аккумулятора. Ми застосовуємо <code>(+3)</code> до <code>2</code>, що є <code>5</code>, і ми ставимо його перед <code>(:)</code> аккумулятором, так що аккумулятор тепер <code>[5,6]</code>. Ми застосовуємо <code>(+3)</code> до <code>1</code>, і ставимо його в початок аккумілятора, так що останнє значення є <code>[4,5,6]</code>.</p></div>
<div class="paragraph"><p>Звичайно, ми могли б реалізувати цю функцію за допомогою лівої звертки, також. Це було б <code>map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</code>, але річ в тому, що функція <code>++</code> значно більш коштовна, ніж <code>:</code>, так що зазвичай використовуйте праву звертку коли будуєте нові спискі зі списків.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/washmachine.png" alt="images/washmachine.png" />
</span>
Якщо ви обертаєте список, ви можете робити праве згортання на ньому, так само як робите ліве, і навпаки. Іноді вам навіть не треба робити це. Функція <code>sum</code> може бути реалізована майже так само за допомогою правого або лівого <code>fold</code>. Одна велика різниця в тому, що права згортка робить на безкінечних списках, тоді як ліва ні! Кажучи просто, якщо ви берете безкінечний список в деякій точці, і ви згортаєте його зправа, ви з часом досягнете початку списку. Однак якщо ви візьмете безкінечний список в деякій точці, і спробуєте згорнути його зліва, ви ніколи не досягнете кінця!</p></div>
<div class="paragraph"><p>Згортки можуть бути використані в любій функції, де ви подорожуєте списком один раз, елемент за елементом, та потім повертаєте дещо на основі цього. Коли ви подорожуєте списком, та повертаєте дещо, є шанси, що ви бажаєте виконати згортку. Ось чому згортки, разом з мапами та фільтрами, одни з найкорисніших типів функцій в функціональному програмуванні.</p></div>
<div class="paragraph"><p>Функції <code>foldl1</code> та <code>foldr1</code> роблять в основному як <code>foldl</code> та <code>foldr</code>, тільки вам не треба провадити для них явне початкове значення. Вони вважають, що перший (або останній) елемент списку буде початковим значенням, та потім починає згортання з елемента, що іде за ним. Маючи це на увазі, функція <code>sum</code> може бути реалізована таким чином: <code>sum = foldl1 (+)</code>. Оскільки вони залежать від того, що списки, які згортаються, мають щонайменьше один елемент, вони призводять до помилок виконання, якщо викликаються з порожніми списками. <code>foldl</code> та <code>foldr</code>, з іншого боку, гарно роблять з порожніми списками. Коли робите згортку, подумайте про те, як це діє з порожнім списком. Якщо ваша функція не має сенсу, коли отримує порожній список, ви можливо можете використовувати <code>foldl1</code> або <code>foldr1</code> для її реалізації.</p></div>
<div class="paragraph"><p>Щоб показати, наскільки потужними є згортання, ми збираємось реалізувати декілька функцій зі стандартної бібліотеки з використанням :</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>head</code> краще реалізується через порівняння шаблонів, але вона тут наведена тільки для демонстрації, ви також можете досягти того ж через згортку. Наше визначення <code>reverse'</code> досить розумне, як я думаю. Ми беремо порожній список в якості початкового значення, та потім проходимо наш список зліва, та ставимо елементи в початок нашого аккумулятора. В кінці кінців ми побудували обернений список. <code>\acc x -&gt; x : acc</code> виглядає як функція <code>:</code>, тільки параметри в іншому порядку. Ось чому ми також можемо записати <code>reverse</code> як <code>foldl (flip (:)) []</code>.</p></div>
<div class="paragraph"><p>Інший шлях змалювати праві і ліві згортки: скажімо, ми маємо праву згортку, двомісну функцію <code>f</code> та початкове значення є <code>z</code>. Якщо ми робимо праве згортання по списку <code>[3,4,5,6]</code>, ми в основному робимо таке: <code>f 3 (f 4 (f 5 (f 6 z)))</code>. <code>f</code> викликається по останньому елементу в списку та аккумулятором, її значення надається як аккумулятор аккумулятор до передостаннього значення, і так далі. Якщо ми в якості <code>f</code> беремо <code>+</code>, та початкове значення аккумулятора буде <code>0</code>, тобто отримуємо <code>3 + (4 + (5 + (6 + 0)))</code>. Або, якщо запишемо <code>+</code> як префіксну функцію, це буде <code>(+) 3 (( +) 4 (( +) 5 (( +) 6 0)))</code>. Подібно до цього, зробити ліве згортання по цьому списку з <code>g</code> в якості двомісної функції та <code>z</code> в якості аккумулятора еквівалентне до до <code>g (g (g (g z 3) 4) 5) 6</code>. Якщо ми використовуємо <code>flip (:)</code> як двомісну функцію, та <code>[]</code> як аккумулятор (так що ми обертаємо список),тоді це еквівалентно до <code>flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</code>. Та будьте впевнені, якщо ви обчислите цей вираз, ви отримаєте <code>[6,5,4,3]</code>.</p></div>
<div class="paragraph"><p><code>scanl</code> та <code>scanr</code> подібні до <code>foldl</code> та <code>foldr</code>, тільки вони доповідають всі проміжні стани аккумулятора в формі списка. Також існують <code>scanl1</code> та <code>scanr1</code>, що аналогічні до <code>foldl1</code> та <code>foldr1</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли використовуєте <code>scanl</code>, остаточний результат буде в останньому елементі результуючого списку, тоді як <code>scanr</code> буде покладати результат в голову.</p></div>
<div class="paragraph"><p>Сканування використовуються для моніторингу прогресву функції, що може бути реалізована як згортка. Давайте відповимо на запитання: як багато елементів зайняло б підсумок коренів всіх натуральних чисел, щоб перевищити <code>1000</code>? Щоб отримати корені всіх натуральних чисел ми просто робимо <code>map sqrt [1..]</code>. Тепер для отримання суми ми можемо зробити згортку, але оскільки ми зацікавлені в тому, як сума прогресує, ми збираємось зробити сканування. Як тільки ми зробимо сканування, ми побачимо, як багато сум до <code>1000</code>. Перша сума в списку буде 1, що є природним. Друга буде <code>1</code> плюс корінь квадратний від <code>2</code>. Третя додасть квадратний корінь від <code>3</code>. Якщо буде <code>X</code> сум до <code>1000</code>, тоді це займе <code>X+1</code> елементів, щоб сума перевищила <code>1000</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми використовуємо тут <code>takeWhile</code> замість <code>filter</code>, оскільки <code>filter</code> не робить з безкінечними списками. Навіть знаючи, що список зростає, фільтр цього не знає, так що ми використовуємо <code>takeWhile</code>, щоб відрізати список сканування до першого входження суми, більшої ніж <code>1000</code>.</p></div>
<div class="paragraph"><p>Гараз, прийшов час поглянути на функцію <code>$</code>, також названою застосуванням функції. Спочатку подивимось, як вона визначена:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/dollar.png" alt="images/dollar.png" />
</span>
Що за біс? Що це за некорисний оператор? Це просто застосування функції! Гаразд, майже, але не зовсім! Тоді як нормальне застосування функції (покладання проміжку між двома речами) має дійсно високий преоритет, функція <code>$</code> має нижчий преоритет. Застосування функції з проміжком ліво-асоціативне (так що <code>f a b c</code> те саме, що і <code>( (f a) b) c))</code>, застосування функції з <code>$</code> є право-асоциативним.</p></div>
<div class="paragraph"><p>Все це дуже добре, але як це допоможе нам? Більшість часу це зручна функція, так що нам не треба писати стільки багато дужок. Розглянемо вираз <code>sum (map sqrt [1..130])</code>. Оскільки <code>$</code> має такий малий преоритет, ми можемо переписати вираз як  <code>sum $ map sqrt [1..130]</code>, зберігши свої коштовні натискання клавіш! Коли трапляється <code>$</code>, вираз зправа застосовується як параметр до функції зліва. Як щодо <code>sqrt 3 + 4 + 9</code>? Це додає разом <code>9</code>, <code>4</code>, та квадратний корінь від <code>3</code>. Якщо ми бажаємо отримати корінь від <code>3 + 4 + 9</code>, ми маємо записати <code>sqrt (3 + 4 + 9)</code>, або, якщо ми використовуємо <code>$</code>, ми можемо записати це як <code>sqrt $ 3 + 4 + 9</code>, оскільки <code>$</code> має найменьший преоритет відносно любого оператора. Ось чому ви можете уявляти <code>$</code> як різновид еквіваленту написання відкритих дужок, та потім написання закриваючих з самого правого краю виразу.</p></div>
<div class="paragraph"><p>Як щодо <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>? Гаразд, оскільки <code>$</code> є право-асоциативною, <code>f (g (z x))</code> еквівалентне до <code>f $ g $ z x</code>. Так що ми можемо переписати <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code> як <code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>.</p></div>
<div class="paragraph"><p>Але крім покладання краю дужкам <code>$</code> означає, що застосування функції можна розглядати просто як іншу функцію. Таким чином ми можемо, наприклад, відобразити застосування функції на список функцій.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В математиці композиція (також відома як суперпозиція. прим. перекл.) функцій визначається так:  <code>(f . g)(x) = f(g(x))</code>, що означає, що композиція двох функцій продукує нову функцію, що, коли викликаєтья з параметром, скажімо <code>x</code>, є еквалентним до виклику <code>g</code> з параметром <code>x</code>, та потім виклику <code>f</code> з її результатом.</p></div>
<div class="paragraph"><p>В Haskell композиція функцій є гарною мірою те саме. Ми робимо композицію функції за допомогою функції <code>.</code>, що визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/notes.png" alt="images/notes.png" />
</span>
Подумайте про декларацію типу. <code>f</code> має приймати в якості параметра значення, що має той самий тип, що і тип повернення <code>g</code>. Так що результуюча функція бере параметр того самого типу, що бере <code>g</code>, та повертає значення того самого типу, що повертає <code>f</code>. Вираз <code>negate . (* 3)</code> повертає функцію, що приймає число, множить його на <code>3</code>, та потім змінює знак.</p></div>
<div class="paragraph"><p>Одне з використань композиції функцій є створення функцій на льоту, щоб передати в інші функції. Напевно для цього можливо використовувати лямбди, але в багатьох випадках композиція функцій ясніша та більш стисла. Скажімо, ви маєте список чисел, і ми бажаємо перетворити їх всі в від'ємні числа. Один зі способів буде отримати абсолютне значення кожного числа, та потім обернути його:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте лямбду, і як це виглядає як результат композиції функцій, що ми запишемо таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Дивовижно! Композиція функцій право-асоциативна, так що ми можемо компонувати багато функцій одночасно. Вираз <code>f (g (z x))</code> еквівалентний до <code>(f . g . z) x</code>. Маючи це на думці, ми можемо перетворити</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>на</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Але щодо функцій, що приймають декілька параметрів? Гаразд, якщо ми бажаємо використовувати їх в композиції функцій, ми маємо частково застосувати їх, тільки в тій мірі, щоб кожна функція приймала один параметр. <code>sum (replicate 5 (max 6.7 8.9))</code> може бути переписана як <code>(sum . replicate 5 . max 6.7) 8.9</code> або як <code>sum . replicate 5 . max 6.7 $ 8.9</code>. Ось що тут відбувається: створюється функція, що приймає <code>max 6.7</code> бере та застосовує <code>replicate 5</code> до цього. Потім створюється функція, що бере результат від того, та робить суму. Нарешті ця функція викликається з <code>8.9</code>. Але звичайно ви читаєте це просто так: застосувати <code>8.9</code> до <code>max 6.7</code>, потім застосувати <code>replicate 5</code> до цього, та потім застосувати <code>sum</code> до отриманого. Якщо ви бажаєте записати вираз з багатьма дужками через композицію функцій, ви можете почати з покладання останнього параметра самої внутрішньої функції після <code>$</code>, та потім скомпонувати всі інші виклики функцій, записуючи їх без останнього параметру, та ставлячи між ними крапку. Якщо ви маєте <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>, ви можете записати це як <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>. Якщо вираз завершується на три дужки, є шанси що після трансляції в композицію функцій це буде мати три оператори композиції.</p></div>
<div class="paragraph"><p>Інше загальне використання композиції функцій є визначення функцій в так званому стилі вільних крапок (також називається безглуздим стилем). Візьміть для прикладу цю функцію, що ми записали раніше :</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>xs</code> з'являється з обох боків. Завдяки каруванню ми можемо уникнути <code>xs</code> з обох боків, оскільки <code>foldl (+) 0</code> створює функцію, що приймає список. Запис функції як <code>sum' = foldl (+) 0</code> називається запис в стилі вільних крапок. Як ми повинні писати в цьому стилі?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми не можемо просто позбутись від <code>x</code> з обох боків. <code>x</code> в тілі функції має дужки за собою. <code>cos (max 50)</code> не матиме сенсу. Ви не можете взяти косінус від функції. Що ми можете зробити, це виразити <code>fn</code> як композицію функцій.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Чудово! В багатьох випадках цей стиль більш читабельний та стислий,оскікльки він дає вам мислити щодо функцій і який тип функцій компонується для отримання результату, замість того, щоб думати про дані і як вони тусуються між собою. Ви можете брати прості функції та використовувати композицію як клей, щоб формувати більш складні функції. Однак в багатьох випадках написання функції в крапках може бути меньш читабельним, якщо функція дуже складна. Ось чому робити довгі ланцюжки з композиції функцій не заохочується, але я визнаю себе винним, що іноді буваю композиціє-щасливим. Бажаний стиль є використання <code>let</code> прив'язок для отримання міток для проміжних результатів, або розділення проблеми на суб-проблеми, та потім збирання їх разом, так щоб функція мала сенс для декого, хто читає її, замість того, щоб робити гігантський ланцюг композиції.</p></div>
<div class="paragraph"><p>В розділі про мапи та фільтри ми вирішили проблему пошуку суми з усіх непарних квадратів, що меньше за <code>10000</code>. Ось як виглядає рішення, коли воно покладено в функцію.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Будучи таким фанатом композиції функцій, я міг би можливо записати це таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак якщо є шанси, що хтось інший буде читати цей код, я б переписав це таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це не виграє змагання з кодового гольфу, але дехто читаючи цю функцію винайде її читання простіше, ніж ланцюжок композицій.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/modules.png" alt="images/modules.png" />
</span>
Модуль Haskell є колекцією пов'язаних функцій, типів та типокласів. Програма Haskell є колекцією модулів, де головний модул завантажує інші модулі, та потім використовує функції, визначені в них, щоб зробити дещо. Мати код поділеним на декілька модулів має досить багато переваг. Якщо модуль досить загальний, функції, які він експортує, можуть бути використані в безлічі різних програм. Якщо ваш власний код поділений на само-достатні модулі, що не покладаються один на одний дуже сильно (ми кажемо що вони слабко пов'язані), в падольшому ви можете використовувати їх. Це робить всю справу написання коду більш керованою, маючи поділеним його на окремі частини, кожна з яких має власне призначення.</p></div>
<div class="paragraph"><p>Стандартна бібліотека Haskell поділена на модулі, кожний з них містить функції та типи, які деяким чином пов'язані та служать деякій загальній цілі. Є модуль для маніпуляцій зі списками, модуль для конкурентного програмування, модуль для справ з комплексними числами, тощо. Всі функції, типи та типокласи, з якими ми досі мали справу, були частиною модуля <code>Prelude</code>, що імпортується по замовчанню. В цій главі ми збираємось дослідити декілька корисних модулів та функцій, що вони мають. Але спочатку ми збираємось подивитись, як імпортувати модулі.</p></div>
<div class="paragraph"><p>Синтаксис для імпортування модулів в скрипті Haskell є <code>import &lt;module name&gt;</code>. Це має бути зроблене перед визначенням любих функцій, так що імпорти звичайно робляться зверху файла. Звичайно, один скрипт може імпортувати декілька модулів. Просто покладіть кожний імпорт в окремий рядок. Давайте імпортуємо модуль <code>Data.List</code>, що має декілька корисних функцій для роботи зі списками, та використаємо функцію, що він експортує, для створення функції, що каже нам, як багато унікальних елементів має наш список.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ви робите <code>import Data.List</code>, всі функції, що експортує <code>Data.List</code>, стають доступними в глобальному просторі імен, що значить, що ви можете викликати їх будь-деme в скрипті. <code>nub</code> є функція, визначена в <code>Data.List</code>, що приймає список і відкидає дубліковані елементи. Компонуючи <code>length</code> та <code>nub</code> роблячи <code>length . nub</code> продукує функцію, що еквівалентна до <code>\xs -&gt; length (nub xs)</code>.</p></div>
<div class="paragraph"><p>Ви також можете покласти функції модулів в глобальний простір імен при використанні GHCI. Якщо ви в GHCI, і ви бажаєте бути в змозі викликати функції, експортовані <code>Data.List</code>, зробіть це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ви бажаєте завантажити імена з декількох модулів всередині GHCI, ми не маємо робити <code>:m +</code> декілька раз, ми можемо просто завантажити декілька модулів за один раз.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак якщо ви завантажили скрипт, що вже імпортує модуль, вам не треба використовувати <code>:m +</code> щоб отримати доступ до нього.</p></div>
<div class="paragraph"><p>Якщо вам просто треба пара функцій з модуля, ви можете вибірково імпортувати лише ці функції. Якщо ви бажаєте імпортувати тільки функції <code>nub</code> та <code>sort</code> з <code>Data.List</code>, ми робимо так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви можете також обрати імпорт всіх функцій з модуля, за винятком декількох обраних. Це часто корисно, коли декілька модулів експортують функції з тим самим іменем, і ви бажаєте прибрати заважаючі варіанти. Скажімо, ми вже маємо нашу власну функцію, що називається <code>nub</code>, і ми бажаємо імпортувати всі функції з <code>Data.List</code>, за винятком функції <code>nub</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Інший шлях мати справу з класами з перетином імен - робити кваліфіковані імпорти. Модуль <code>Data.Map</code>, що пропонує структуру даних для пошуку значень по ключу, експортує декілька функцій з тими ж назвами, що і функції <code>Prelude</code>, як <code>filter</code> або <code>null</code>. Так що коли ми імпортуємо <code>Data.Map</code> і потім викликаємо <code>filter</code>, Haskell не знає, яку функцію використовувати. Ось як ми вирішуємо це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це робить так, що коли ми бажаємо посилатись на функцію <code>Data.Map</code>  <code>filter</code>, ми маємо робити <code>Data.Map.filter</code>, коли тільки <code>filter</code> все ще посилається на нормальний <code>filter</code>, який ми всі знаємо і любимо. Але набір <code>Data.Map</code> перед кожною функцію з цього модуля є дещо обтяжливо. Осі чому ми можемо переіменувати кваліфікований імпорт на дещо коротше:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер для посилання на функцію <code>Data.Map</code> <code>filter</code> ми виристовуємо лише <code>M.filter</code>.</p></div>
<div class="paragraph"><p>Використовуйте це зручне посилання, щоб побачити, які модулі є в стандартній бібліотеці. Гарний спосіб отримати нове знання щодо Haskell є просто клацати по посиланню стандартної бібліотеки, та досліджувати модулі та їх функції. Ви можете також передивлятись джерельний код Haskell для кожного модуля. Читання джерельного коду для деяких модулів є дійсно гарним шляхом вивчати Haskell та отримати солідне відчуття мови.</p></div>
<div class="paragraph"><p>Для пошуку функцій або для пошуку, де вони розташовані, використовуйте <code>Hoogle</code>. Це дійсно неймовірна пошукова система Haskell, ви можете шукати по імені, імені модуля або навіть сигнатурі типу.</p></div>
<div class="paragraph"><p>Модуль <code>Data.List</code> це все про списки, це очевидно. Він провадить деякі дуже корисні функції для роботи з ними. Ми вже зустрічались з деяким з ціх функцій (як <code>map</code> та <code>filter</code>), оскільки модуль <code>Prelude</code> експортує деякі функції з <code>Data.List</code> для зручності. Ви не маєте імпортувати <code>Data.List</code> через кваліфікований імпорт, оскільки його імена не перетинаються з жодними іменами <code>Prelude</code>, за винятком тих, що <code>Prelude</code> вже краде у <code>Data.List</code>. Давайте поглянемо на деякі функції, з якими ми раніше не зустрічались.</p></div>
<div class="paragraph"><p><code>intersperse</code> бере елемент та список, і потім покладає цей елемент між кожною парою елементів списка. Ось демонстрація:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>intercalate</code> бере лист список списків, і список. Потім він вставляє цей список між всіма ціма списками, і потім сплощує результат.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>transpose</code> траспонує список списків. Якщо ви подивитесь на список списків як на 2D матрицю, стовпчики стають рядками та навпаки.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Скажімо, ми маємо поліноми <code>3x2 + 5x + 9</code>, <code>10x3 + 9</code> та <code>8x3 + 5x2 + x - 1</code> і ми бажаємо додати їх разом. Ми можемо використати списки <code>[0,3,5,9]</code>, <code>[10,0,0,9]</code> та <code>[8,5,1,-1]</code> для представлення їх в Haskell. Тепер щоб додати їх, все що треба зробити це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми транспонуємо ці три списки, три куби опиняться в першому рядку, квадрати в другому, і так далі. Відображуючи <code>sum</code> на це продукує бажаний результат.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lists.png" alt="images/lists.png" />
</span>
<code>foldl'</code> та <code>foldl1'</code> є суворіші версії відносно до своїх лінивих інкарнацій. Коли використовуються ліниві згортки на дійсно списках, часто ви можете отримати помилку переповнення стеку. Винуватцем цього є те, що через ліниву природу згорток значення аккумулятора насправді не оновлюється по мірі згортки. Що насправді відбувається, це те, що аккумулятор робить свого роду обіцянки, що віе обчислить своє значення, коли попросять дійсно зпродукувати результат (що також називається грім). Це відбувається для кожного проміжного аккумулятора, і всі ці громи переповнюють ваш стек. Сувора згортка не така лінива істота, та насправді обчислює проміжні значення по мірі надходження, замість заповнювати ваш стек. Так що якщо ви колись отримаєте переповнення стеку роблячи ліниві згортки, спробуйте переключитись на їх суворі версії.</p></div>
<div class="paragraph"><p><code>concat</code> зрівнює список списків в просто список елементів.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Він буде видаляти лише один рівень вкладення. Так що якщо ви бажаете повністю сплющити <code>[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</code>, що є списком списків списків, ви маєте виконати конкатенацію двічі.</p></div>
<div class="paragraph"><p>Виконання <code>concatMap</code> є те саме, що спочатку відобразити функцію на список, та потім конкатувати список <code>concat</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>and</code> бере список логічних значень, та повертає <code>True</code> тільки якщо всі значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>or</code> подібне до <code>and</code>, тільки повертає <code>True</code> якщо любе логічне значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>any</code> та <code>all</code> беруть предикат, та потім перевіряють, чи якісь або всі елементи списку задовільняють предикату, відповідно. Звичайно ми використовуємо ці дві функції замість відображення по списку, та потім робити <code>and</code> або <code>or</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>iterate</code> бере функцію та початкове значення. Вона застосовує функцію до стартового значення, потім вона застосовує цю функцію до результату знову, тощо. Вона повертає всі результати в формі безкінечного списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>splitAt</code> бере число та список. Потім вона розділяє список на це число елементів, повертаючи два списки як тапл.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>takeWhile</code> є дійсно корисною невеликою функцією. Вона бере елементи зі списку доки виконується предикат, та коли трепиться елемент, що не задовільняє, вона відсікає всі інші. Як з'ясовується ще дуже корисно.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Скажімо, ми бажаємо знати суму всіх третіх ступінів, що є до <code>10000</code>. Ми не можемо зробити <code>map (^3)</code> до <code>[1..]</code>, застосувати <code>filter</code> та потім спробувати підсумувати все це, бо фільтр на безкінечному спіску ніколи не завершиться. Ви можете знати, що всі елементи ідуть по зростанню, але Haskell ні. Ось чому ми можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми застосовуємо <code>(^3)</code> до безкінечного списку, та потім, коли це буде більше <code>10000</code>, список буде обрізаний. Тепер ми можемо його легко підсумувати.</p></div>
<div class="paragraph"><p><code>dropWhile</code> є подібним, тільки вона відкидає всі елементи, доки виконується предикат. Як тільки предикат дорівнює <code>False</code>, вона повертає залишок списку. Вкрай корисна і мила функція!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми надали список, що представляє значення акцій по даті. Список складається з таплів, чий перший компонент є значення курсу акцій, другий елемент рік, третій місяць а четвертий дата. Ми бажаємо знати, коли значення акцій вперше перевищило тисячу доларів!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>span</code> дещо як <code>takeWhile</code>, тільки він повертає пару списків. Перший список містить все, що містив би результуючий список <code>takeWhile</code>, коли б ми викликали його з тим самим предикатом та тим самим списком. Другий список містить частину списку, що мала б бути відкинутою.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тоді як <code>span</code> поділяє список доки предикат вірний, <code>break</code> перериває коли предикат стає перший раз <code>True</code>. Зробити <code>break p</code> є еквівалентним зробити <code>span (not . p)</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>При використанні <code>break</code>, другий список в результаті буде починатись з першого елементу, що задовільняє предикату.</p></div>
<div class="paragraph"><p><code>sort</code> просто сортує список. Тип елементів в списку має бути частиною типокласу <code>Ord</code>, оскільки якщо елементи списку не можуть бути покладені в деякому порядку, тоді такий список неможливо відсортувати.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>group</code> бере список та групує сусідні елементи в субсписки, якщо вони рівні.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми вортуємо список перед групуванням, ми можемо знайти, скільки разів кожний елемент з'являється в списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>inits</code> та <code>tails</code> подібні до <code>init</code> та <code>tail</code>, тільки вони рекурсивно застосовуються до списку, доки нічого не залишиться. Дослідимо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Давайте використаємо <code>fold</code> для реалізації пошуку підсписку в списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Спочатку ми викликаємо <code>tails</code> зі списком, в якому ми шукаємо. Потім ми проходимо по кожному хвосту, та дивимось, чи він починається з того, що ми шукаємо.</p></div>
<div class="paragraph"><p>Маючи це, ми насправді лише зробили функцію, що поводиться як <code>isInfixOf</code>. <code>isInfixOf</code> шукає субсписок, та повертає <code>True</code>, якщо субсписок, що ми шукаємо, десь всередині цільового списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>isPrefixOf</code> та <code>isSuffixOf</code> шукають субсписок напочатку та в кінці списку, відповідно.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>elem</code> та <code>notElem</code> перевіряють, чи елемент є або його немає в списку.</p></div>
<div class="paragraph"><p><code>partition</code> бере список та предикат, та повертає пару списків. Перший список в результаті містить всі списки, що задовільняють предикату, другий містить всі що не задовільняють.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Важливо розуміти, як це відрізняється від <code>span</code> та <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли <code>span</code> та <code>break</code> завершуються коли вони натраплять на перший елемент, що не- або задовільняє предикату, <code>partition</code> проходить по цілому списку, та розділяє його відповідно предиката.</p></div>
<div class="paragraph"><p><code>find</code> бере список та предикат, та повертає перший елемент, що задовільняє предикату. Але він повертає цей елемент огорнутим в значення <code>Maybe</code>. Ми будемо розглядати алгебраїчні типи даних більш детально в наступній главі, але доки це все що ви маєте знати: значення <code>Maybe</code> може бути або <code>Just</code> дещо або <code>Nothing</code>. Так само, як список може бути або порожнім, або списком з якимось елементами, значення <code>Maybe</code> може бути або без елементів, або мати один елемент. І так само, як тип списку, скажімо, цілих є <code>[Int]</code>, тип можливо цілого значення є <code>Maybe Int</code>. В жодному разі розкрутимо нашу функцію <code>find</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте тип <code>find</code>. Його результат є <code>Maybe a</code>. Це майже так само, як мати тип <code>[a]</code>, тільки значення типу <code>Maybe</code> можуть містити або елемент, або нічого, тоді як список може не мати жодного, мати один або мати декілька елементів.</p></div>
<div class="paragraph"><p>Згадайте, як ми шукали, коли перший раз наші акції дійшли більше <code>$1000</code>. Ми робили <code>head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</code>. Згадайте, що <code>head</code> насправді не досить безпечна. Що має трапитись, якщо курс ніколи не доходить за <code>$1000</code>? Наше застосування <code>dropWhile</code> буде повертати порожній список, та отримання <code>head</code> від порожнього списку призведе до помилки. Однак якщо ми перепишемо це як <code>(\(val,y,m,d) -&gt; val &gt; 1000) stock</code>, ми будемо значно безпечніше. Якщо наші акції ніколи не заходять за <code>$1000</code> (так що немає жодного елементу, що задовільняє предикату), ми отримуємо назад <code>Nothing</code>. Але якщо в списку була валідна відповідь в списку, ми б отримали б, скажімо <code>Just (1001.4,2008,9,4)</code>.</p></div>
<div class="paragraph"><p><code>elemIndex</code> є різновидом <code>elem</code>, тільки він не повертає логічне значення. Він можливо повертає індекс елемента, який ми шукаємо. Якщо такого елемента немає в нашому списку, він повертає <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>elemIndices</code> подібна до <code>elemIndex</code>, тільки вона повертає список індексів, в випадку, коли елемент що ми шукаємо знаходиться в нашому списку декілька раз. Оскільки ми використовуємо список для представлення індексов, нам не треба тип <code>Maybe</code>, тому невдача може бути представлена як порожній список, що є досить синонімичнім до <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>findIndex</code> подібне до <code>find</code>, але вона можливо повертає індекс першого елемента, що задовільняє предикату. <code>findIndices</code> повертає індекси всіх елементів, що задовільняють предикату в формі списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми вже розглядали <code>zip</code> та <code>zipWith</code>. Ми зауважили, що вони поеднують разом два списки, або в тапл, або за допомогою двомісної функції (що означає, що функція приймає два параметра). Але що, коли ви бажаєте поеднати разом три списки? Або поєднати три списки за допомогою функції, що приймає три параметри? Гаразд, для цього ми маємо <code>zip3</code>, <code>zip4</code>, тощо, та <code>zipWith3</code>, <code>zipWith4</code>, etc. Ці варіанти ідуть до <code>7</code>. Хоча це може виглядати як хак, це робить досить гарно, оскільки не дуже часто трапляються випадки, коли вам треба поєднати 8 списків. Також існую розумний спосіб поєднати довільне число списків, але ми не досить просунулись, щоб розглядати його прямо тут.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так само, як з нормальним поєднанням, списки, що довші ніж найкоротший список, відсікаються до його розміру.</p></div>
<div class="paragraph"><p><code>lines</code> є корисною функцією, коли маємо справу з файлами або ввод від чогось іншого. Вона приймає рядок, та повертає кожний рядок в окремий список.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>'\n'</code> є символ для нового рядка Юнікс. Зворотні косі мають особливе значення в Haskell рядках та символах.</p></div>
<div class="paragraph"><p><code>unlines</code> є зворотньою до <code>lines</code> функцією. Вона приймає список рядків, та потім поєднує їх разом з використанням <code>'\n'</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>words</code> та <code>unwords</code> призначені для поділу рядка тексту на слова, або поєднання списку слов в текст. Дуже корисно.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми вже згадували <code>nub</code>. Він бере список та відкидає дублікати елементів, повертаючи список, кожний елемент якого є унікальною сніжинкою! Функція має дещо дивне ім'я. Виявляється, що <code>"nub"</code> означає малу грудку або головну частину чогось. По-моєму для назв функцій треба використовувати справжні слова, замість застарілих.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>delete</code> бере елемент і список, і видаляє перше входження елемента в списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>\\</code> є функцією різниці. Вона діє як різниця множин, в основному. Для кожного елементу зправа вона видаляє елемент в лівому списку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зробити <code>[1..10] \\ [2,5,9]</code> це як зробити <code>delete 2 . delete 5 . delete 9 $ [1..10]</code>.</p></div>
<div class="paragraph"><p><code>union</code> також діє як функція на множинах. Вона повертає поєднання двох списків. Вона добряче проходиться по кожному елементу в другому списку, та додає його до першого, якщо його там ще немає. Однак начувайтесь, дублікати видаляються з другого списку!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>intersect</code> робить як перетин множин. Вона повертає тільки ті елементи, що знайдені в обох списках.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>insert</code> бере елемент та список, що може бути відсортований, та вставляє його в останню позицію, де він все ще меньший або рівний наступному елементу. Іншими словами <code>insert</code> буде починати на початку списку, та потім продовжувати, доки не знайде елемент, що більше або дорівнює нашому елементу, який він вставляє, і робить вставку перед цім елементом.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>4</code> вставлене прямо після <code>3</code> та перед <code>5</code> в першому прикладі, та між <code>3</code> і <code>4</code> в другому прикладі.</p></div>
<div class="paragraph"><p>Якщо ми вставляємо в відсортований список, отриманий список буде також відсортований.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що загального між <code>length</code>, <code>take</code>, <code>drop</code>, <code>splitAt</code>, <code>!!</code> та <code>replicate</code>, це те, що вони приймають <code>Int</code> в якості одного з параметрів (або повертають <code>Int</code>), навіть якщо вони могли б бути більш загальними та корисними, якщо б вони приймали любий тип, що є частиною типокласів <code>Integral</code> або <code>Num</code> (в залежності від функцій). Вони роблять це з історичних причин. Однак виправлення цього можливо зламає безліч існуючого коду. Ось чому <code>Data.List</code> має власні більш загальні еквіваленти, названі <code>genericLength</code>, <code>genericTake</code>, <code>genericDrop</code>, <code>genericSplitAt</code>, <code>genericIndex</code> та <code>genericReplicate</code>. Наприклад, довжина має сигнатуру типу <code>length::[a] -&gt; Int</code>. Якщо ми спробуємо отримати середнє від списку чисел, виконавши <code>let xs = [1..6] in sum xs / length xs</code>, ми отримаємо помилку типу, оскільки ви не можете використовувати <code>/</code> з <code>Int</code>. З іншого боку <code>genericLength</code> має сигнатуру <code>genericLength::(Num a) =&gt; [b] -&gt; a</code>. Оскільки <code>Num</code> може діяти як число з плаваючою крапкою, взяття середнього через виконання <code>let xs = [1..6] in sum xs / genericLength xs</code> робить гарно.</p></div>
<div class="paragraph"><p>Функції <code>nub</code>, <code>delete</code>, <code>union</code>, <code>intersect</code> та <code>group</code> всі мають свої більш загальні варіанти на ім'я <code>nubBy</code>, <code>deleteBy</code>, <code>unionBy</code>, <code>intersectBy</code> та <code>groupBy</code>. Різниця між ними в тому, що перший набір функцій використовує <code>==</code> для перевірки на рівність, тоді як <code>By</code> варіанти також приймають функцію еквівалентності, та потім порівнюють з використанням цієї функції. <code>group</code> є те ж саме, що і <code>groupBy (==)</code>.</p></div>
<div class="paragraph"><p>Наприклда, скажімо ми маємо список, що описує значення функції для кожної секунди. Ми бажаємо поділити її на субсписки, базуючись на тому, чи значення меньше або більше нуля. Якщо ми зробимо лише звичайне групування, це лише згрупує сусідні однакові значення. Але ми бажаємо згрупувати на основі того, чи воні від'ємні чи ні. Ось де з'являється <code>groupBy</code>! Функція еквівалентності, що надається до функцій <code>By</code>, повинні приймати две елементи того самого типу, і повертати <code>True</code>, якщо вони рівні за її стандартами.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>З цього ми ясно бачимо, які частини є додатними, та які від'ємними. Надана функція рівності приймає два елементи, та потім повертає <code>True</code>, тільки якщо обоє є від'ємними або обоє додатними. Цю функцію рівності також можна записати як <code>\x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)</code>, хоча я думаю, що перший варіант краще читається. Навіть ясніший спосіб написати функцію рівності для функцій <code>By</code> є імпортувати функцію <code>on</code> з <code>Data.Function</code>. <code>on</code> визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так що зробити <code>(==) ``on`</code> (&gt; 0)` повертає функцію рівності, що виглядає як <code>\x y -&gt; (x &gt; 0) == (y &gt; 0)</code>. <code>on</code> використовується з функціями <code>By</code>, бо з ним ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вочевидь гарно читається! Ви можете прочитати це вголос: згрупувати це за рівністю, що настає коли елементи більші нуля.</p></div>
<div class="paragraph"><p>Подібним чином <code>sort</code>, <code>insert</code>, <code>maximum</code> та <code>minimum</code> також мають свої більш загальні еквіваленти. Функції як <code>groupBy</code> беруть функцію, що визначає, коли два елементи рівні. <code>sortBy</code>, <code>insertBy</code>, <code>maximumBy</code> та <code>minimumBy</code> беруть функцію, що визначає, чи елемент більший, меньший або рівний до іншого. Сигнатура типу <code>sortBy</code> є <code>sortBy::( a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>. Якщо ви пам'ятаєте з попереднього, тип <code>Ordering</code> має значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. <code>sort</code> еквівалентна до <code>sortBy compare</code>, оскільки тільки приймає два елементи, чиї типи в типокласі <code>Ord</code>, та повертає їх відношення впорядкування.</p></div>
<div class="paragraph"><p>Списки можуть бути порівняні, пле при цьому вони порівнюються лексографічно. Що, коли ми маємо список списків, та ми бажаємо сортувати їх не на основі їх вмісту, а на основі їх довжини? Так, ви майже здогадались, ми будемо використовувати функцію <code>sortBy</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Неймовірно! <code>compare `on`</code> <code>length</code> &#8230; це читається майже як англійська! Якщо ви не впевнені, як саме це тут робить, <code>compare `on`</code> <code>length</code> еквівалентне до <code>\x y -&gt; length x `compare`</code> <code>length y</code>. Коли ви маєте справу з функціями <code>By</code>, що приймають функцію рівності, ви зазвичай робите <code>(==) `on`</code> <code>something</code>, та коли ви маєте справу з функціями <code>By</code>, що приймають функцію впорядкування, ви зазвичай робите <code>compare `on`</code> <code>something</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/legochar.png" alt="images/legochar.png" />
</span>
Модуль <code>Data.Char</code> робить те, на що натякає його ім'я. Він експортує функції, що мають справи з символами. Це також корисне при фільтруванні та відображенні з рядками, бо вони є лише списками символів.</p></div>
<div class="paragraph"><p><code>Data.Char</code> експортує декілька предикатів над символами. Тобто функцій, що приймають символ, та кажуть, чи справджується деяке припущення щодо нього. Ось як це виглядає:</p></div>
<div class="paragraph"><p><code>isControl</code> перевіряє, чи символ є символом керування.</p></div>
<div class="paragraph"><p><code>isSpace</code> перевіряє, чи символ є проміжком. Це включає проміжки, табуляції, нові рядки, тощо.</p></div>
<div class="paragraph"><p><code>isLower</code> перевіряє, чи символ в нижньому реєстрі.</p></div>
<div class="paragraph"><p><code>isUpper</code> перевіряє, чи символ в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAlpha</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isAlphaNum</code> перевіряє, чи символ є літерою або цифрою.</p></div>
<div class="paragraph"><p><code>isPrint</code> перевіряє, чи символ є друкованим. Наприклад, керівні символи не друкуються.</p></div>
<div class="paragraph"><p><code>isDigit</code> перевіряє, чи символ є цифрою.</p></div>
<div class="paragraph"><p><code>isOctDigit</code> перевіряє, чи символ є восьмиричним символом.</p></div>
<div class="paragraph"><p><code>isHexDigit</code> перевіряє, чи символ є шістнацятиричною цифрою.</p></div>
<div class="paragraph"><p><code>isLetter</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isMark</code> перевіряє щодо символів маркування Unicode. Це символи, що комбінуються з попередніми символами для формування літер з наголосами та умулятами. Використовуйте це, якщо ви француз.</p></div>
<div class="paragraph"><p><code>isNumber</code> перевіряє, чи символ є числом.</p></div>
<div class="paragraph"><p><code>isPunctuation</code> перевіряє, чи символ є пунктуацією.</p></div>
<div class="paragraph"><p><code>isSymbol</code> перевіряє, чи символ є незвичайним математичним або символом валют.</p></div>
<div class="paragraph"><p><code>isSeparator</code> перевіряє на проміжки та роздільники Unicode.</p></div>
<div class="paragraph"><p><code>isAscii</code> перевіряє, чи символ підпадає в перші 128 символів набору символів Unicode.</p></div>
<div class="paragraph"><p><code>isLatin1</code> перевіряє, чи символ підпадає в перші 256 символів Unicode.</p></div>
<div class="paragraph"><p><code>isAsciiUpper</code> перевіряє, чи символ ASCII в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAsciiLower</code> перевіряє, чи символ ASCII в нижньому реєстрі.</p></div>
<div class="paragraph"><p>Всі ці предикати мають сигнатуру типу <code>Char -&gt; Bool</code>. Більшість часу ви будете використовувати їх для фільтрування рядків або чогось подібного. Наприклад, скажімо, ми робимо програму, що приймає ім'я користувачи, та це ім'я може складатись тільки з літер та цифр. Ми можемо використовувати функцію <code>Data.List</code> <code>all</code> в комбінації з предикатами <code>Data.Char</code> для визначення, чи ім'я користувача в порядку.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Круто. В випадку якщо ви не пам'ятаєте, <code>all</code> приймає предикат та список, та повертає <code>True</code> тільки якщо предикат дотримується для всіх елементів в списку.</p></div>
<div class="paragraph"><p>Ми також можемо використовувати <code>isSpace</code> для симуляції функції <code>Data.List</code> <code>words</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Хмм, гарно, це робить майже те саме що робить <code>words</code>, але ми залишились з елементами, що містять тільки проміжки. Хмм, то що ми маємо робити? Я знаю, просто відфільтруемо цей непотріб.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ось так.</p></div>
<div class="paragraph"><p><code>Data.Char</code> також імпортує тип даних що подібний до <code>Ordering</code>. Тип <code>Ordering</code> може мати значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. Це різновид переліку. Він описує декілька можливих результатів, що можуть виникнути від порівняння двох елементів. Тип <code>GeneralCategory</code> також є переліком. Він презентує декілька можливих категорій, до яких може належати символ. Головна функція для отримання загальної категорії символа є <code>generalCategory</code>. Вона має тип <code>generalCategory ::Char -&gt; GeneralCategory</code>. Існує близько <code>31</code> категорій, так що ми не будемо перелічувати їх тут, але пограємось з функцією.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки тип <code>GeneralCategory</code> є частиною типокласу <code>Eq</code>, ми можемо також перевірити дещо, наприклад <code>generalCategory c == Space</code>.</p></div>
<div class="paragraph"><p><code>toUpper</code> конвертує символ в верхній реєстр. Проміжки, числа та все подібне залишається без змін.</p></div>
<div class="paragraph"><p><code>toLower</code> конвертує символи в нижній реєстр.</p></div>
<div class="paragraph"><p><code>toTitle</code> конвертує символ в заглавні. Для більшості символів це те саме, що верхній реєстр.</p></div>
<div class="paragraph"><p><code>digitToInt</code> конвертує символ до <code>Int</code>. Щоб це було успішним символ має бути в диапазоні <code>'0'..'9'</code>, <code>'a'..'f'</code> або <code>'A'..'F'</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>intToDigit</code> є інверсною функцією до <code>digitToInt</code>. Вона приймає <code>Int</code> в диапазоні <code>0..15</code> та конвертує його в символ нижнього реєстра.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функції <code>ord</code> та <code>chr</code> конвертують символи до відповідних чисел та навпаки:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Різниця між <code>ord</code> значеннями двох символів дорівнює тому, як далеко вони в таблиці Unicode.</p></div>
<div class="paragraph"><p>Шифр Цезаря є примітивним методом кодування повідомлень, зсуваючи кожний символ в повідомленні на фіксований число позицій в абетці. Ми можемо просто створити різновид шифра Цезаря, тільки ми не будемо обмежувати себе абеткою.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут ми зпочатку конвертуємо рядок в список чисел. Потім ми додаємо сзув до кожного значення перед конвертації списку назад до символів. Якщо ви ковбой композиції, ви можете записати тіло цієї функції як <code>map (chr . (+ shift) . ord) msg</code>. Давайте спробуємо закодувати декілька повідомлень.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Все закодовується гарно. Декодування повідомлення є в основному зсув назад на число позицій, на яке воно було спочатку зсунуте.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Асоціативні списки (також називаються словниками) є списками, що використовуються для зберігання пар ключ-значення, коли порядок не має значення. Наприклад, ми можемо використовувати асоціативний список для зберігання номерів телефонів, де номери телефонів будуть значеннями, а імена людей будуть ключами. Нам байдуже в якому порядку вони зберігаються, ми просто хочемо отримати правильний номер телефону для певної особи.</p></div>
<div class="paragraph"><p>Найбільш очевидний шлях представити асоціативні списки в Haskell буде використання списку пар. Перший компонент в парі буде ключем, другий компонент значення. Ось приклад асоціативного списку з номерами телефонів:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Не зважаючи на ці досить дивні відступи це все ще пари рядків. Найбільш загальна задача коли маємо справу з асоціативними списками є пошук значення по ключу. Давайте створимо функцію, що шукає деяке значення по ключу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить просто. Функція, що бере ключ та список, фільтрує список так, що залишаються лише співпадаючі ключі, бере першу пару ключ-значення та повертає значення. Але що трапляється, якщо ключ що ми шукаємо відсутній в асоціативному списку? Хмм. В даному випадку якщо ключа немає в списку ми скінчимо беручи <code>head</code> від порожнього списку, що закидає помилку часу виконання. Однак нам слідує уникати таких простих катастроф нашої програми, так що використаємо тип даних <code>Maybe</code>. Якщо ми не знайшли ключ ми повертаємо <code>Nothing</code>. Якщо ми знайшли його, ми повертаємо <code>Just</code> дещо, де дещо це значення, що відповідає ключу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Подивіться на декларацію типу. Вона приймає ключ, що може бути порівняний, асоціативний список, і потім, вірогідно, продукує значення. Виглядає правильним.</p></div>
<div class="paragraph"><p>Це класична рекурсивна функція, що оперує зі списком. Граничний випадок, поділення списку на голову та хвіст, рекурсивні виклики - вони всі тут. Це класичний шаблон <code>fold</code>, так що давайте подивимось, як це може бути реалізовано через згортання.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Note: Зазвичай краще використовувати згортки для цього стандартного шаблону рекурсії по списку, замість явного написання рекурсії, бо це краще читати та розпізнавати. Всі знають що це згортання, коли вони бачать виклик <code>foldr</code>, але читання явної рекурсії займає деякий час.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/legomap.png" alt="images/legomap.png" />
</span>
Робить чудово! Якщо ми маємо номер телефону дівчини, ми <code>Just</code> отримуємо номер, інакше ми отримуємо <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Ми тільки що реалізували функцію пошуку з <code>Data.List</code>. Якщо ми бажаємо знайти відповідне до ключа значення, ми маємо пройти всі елементи списка, доки ми не знайдемо його. Модуль <code>Data.Map</code> пропонує асоціативні списки, що значно швидші (оскільки вони внутрішньо реалізовані як дерева), і також вона провадить багато допоміжних функцій. Відтепер ми будемо казати, що ми робимо з мапами замість асоціативних списків.</p></div>
<div class="paragraph"><p>Оскільки <code>Data.Map</code> експортує функції, що перетинаються з такими з <code>Prelude</code> та <code>Data.List</code>, ми будемо робити кваліфікований імпорт.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Покладемо це твердження в скрипт, та потім завантажимо скрипт через  <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Давайте пійдемо далі, та побачимо, що має для нас <code>Data.Map</code>! Ось базовий огляд його функцій.</p></div>
<div class="paragraph"><p>Функція <code>fromList</code> бере асоціативний список (в формі списка) і повертає мапу з тими самими асоціаціями.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо в оригінальному асоціативному списку є дублікати ключів, дублікати просто відкидаються. Ось сигнатура типу для <code>fromList</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вона каже, що береться список пар типів <code>k</code> та <code>v</code>, та повертається мапа, що відображує тип <code>k</code> на тип <code>v</code>. Зауважте, що коли ми робимо асоціативні списки з нормальними списками, ключі тільки мають проходити порівняння на рівність (їх тип належить до типокласу <code>Eq</code>), але тепер вони мають впорядковуватись. Це основний контраст в модулі <code>Data.Map</code>. Він вимагає щоб ключі впорядковувались, і тоді він зможе вистроїти їх в дерево.</p></div>
<div class="paragraph"><p>Вам слідує завжди використовувати <code>Data.Map</code> для асоціацій ключ-значення, тільки якщо ви не маєте ключів, що не є частиною типокласу <code>Ord</code>.</p></div>
<div class="paragraph"><p><code>empty</code> представляє порожню мапу. Вона не приймає аргументів, вона просто повертає порожню мапу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>insert</code> бере ключ, значення та мапу, і повертає нову мапу, що така сама, тільки з доданим ключем та значенням.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми можемо реалізувати наш власний <code>fromList</code> через використання порожньої мапи, <code>insert</code> та <code>fold</code>. Дивіться:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це досить прямолінійне згортання. Ми починаємо з порожньої мапи, і ми згортаємо її зправа, включаючи пари ключ значення в акумулятор по мірі проходження.</p></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи мапа є порожня.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>size</code> повідомляє про розмір мапи.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>singleton</code> бере ключ та значення, та створює мапу, що має одне відображення.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>lookup</code> робить як <code>Data.List</code> <code>lookup</code>, тільки він оперує з мапами. Він повертає <code>Just</code> дещо, якщо він знаходить дещо для ключі, і <code>Nothing</code> якщо ні.</p></div>
<div class="paragraph"><p><code>member</code> є предикатом, що приймає ключ і мапу, та повідомляє, чи ключ в мапі або ні.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>map</code> та <code>filter</code> роблять як їх еквіваленти для списків.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>toList</code> є зворотнім до <code>fromList</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>keys</code> та <code>elems</code> повертають списки ключів та значень відповідно. <code>keys</code> є еквівалентом до <code>map fst . Map.toList</code> та <code>elems</code> є еквівалентом до <code>map snd . Map.toList</code>.</p></div>
<div class="paragraph"><p><code>fromListWith</code> є милою маленькою функцією. Вона діє як <code>fromList</code>, тільки вона не відкидає дублікати ключів, але використовує надану функцію для вирішення, що з ними робити. Скажімо, дівчина має декілька номерів, і ми маємо асоціативний список приблизно такого вигляду.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер, якщо ми просто використовуємо <code>fromList</code> щоб перенести це в мапу, ми втратимо декілька номерів! Так що ось як ми будемо робити:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми знайдемо дублікований ключ, функція, яку ми передали, буде використана для комбінації ціх значень для ключа в деяке інше значення. Ми можемо також спочатку створити для всіх значень в асоціативному списку списки синглтони, і потім ми можемо використати <code>++</code> для комбінації чисел.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Дуже добре! Інший випадок це коли ми робимо мапу з асоціативного списку чисел, і коли трапляється дублікований ключ, ми бажаємо зберігти більше значення для ключа.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Або ми можемо скласти разом значення по тому самому ключу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>insertWith</code> те саме до <code>insert</code>, що <code>fromListWith</code> до <code>fromList</code>. Вона вставляє пару ключ-значення в мапу, але якщо мапа вже містить ключ, вона використовує передану функцію для визначення того, що треба робити.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це було лише декілька функцій з <code>Data.Map</code>. Повний список функцій ви можете побачити в документації.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/legosets.png" alt="images/legosets.png" />
</span>
Модуль <code>Data.Set</code> пропонує нам множини. Це як множини в математиці. Множини як скрещені списки з мапами. Всі елементи в множині унікальні. І оскільки вони внутрішньо реалізовані за допомогою дерев (як мапи в <code>Data.Map</code>), вони впорядковані. Перевірка на членство, вставка, видалення, тощо значно швидші, ніж робити ті самі речі зі списками. Найбільш загальні операції при роботі з множинами є вставка в множину, перевірка членства та перетворення множини на список.</p></div>
<div class="paragraph"><p>Оскільки імена в <code>Data.Set</code> перетинаються значною мірою з іменами в  <code>Prelude</code> та <code>Data.List</code>, ми робимо кваліфікований імпорт.</p></div>
<div class="paragraph"><p>Покладіть твердження <code>import</code> в скрипт:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І потім завантажте скрипт через <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Скажімо ми маємо два шматки тексту. Ми бажаємо з'ясувати, які символи використовуються в кожному з них.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функція <code>fromList</code> робить майже як ви могли очікувати. Вона бере список та конвертуж його в множину.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи впорядковані і кожний елемент унікальний. Тепер давайте використаємо функцію <code>intersection</code> щоб побачити, які елементи поділяють обоє.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми можемо використовувати функцію <code>difference</code> щоб побачити, які літери в першій множині, але не в другій, і навпаки.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Або ми можемо бачити всі унікальні літери в обох послідовностях з використанням <code>union</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функції <code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code> та <code>delete</code> всі роблять як ви могли цього очікувати.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми також можемо перевірити підмножини. Множина <code>A</code> є підмножиною <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code>. Множина <code>A</code> є власне підмножиною множини <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code> ,але також і інші елементи.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми також можемо відображати множини і фільтрувати їх.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Множини часто використовуються для позбавлення списків від дублікатів, спершу перетворивши їх на множину за допомогою <code>fromList</code>, та потім перетворивши її на список за допомогою <code>toList</code>. Функція <code>Data.List</code> <code>nub</code> вже робить це, але зачистка дублікатів для великих списків значно швидша, якщо ви перекачаєте його в множину, ніж якщо використаєте <code>nub</code>. Але викорастання <code>nub</code> вимагає тільки щоб тип елементів списку був частиною типокласу <code>Eq</code>, натомість якщо ви бажаєте перевести елементи в множину, тип списку має бути в <code>Ord</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>setNub</code> загалом швидша, ніж <code>nub</code> на великих списках, але як ви бачите, <code>nub</code> зберігає впорядкування елемнтів списку, тоді як <code>setNub</code> ні.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/making_modules.png" alt="images/making_modules.png" />
</span>
Ми вже подивились на деякі круті модулі, то як нам зробити наш власний модуль? Майже кожна мова програмування дозволяє вам поділити ваш код не декілька файлів, і Haskell не є виключенням. При створенні програм є гарною практикою брати функції і типи, що служать деяким подібним цілям, і покладати їх в модуль. Таким чином ви легко можете використати ці функції в інших програмах, просто імпортувавши ваш модуль.</p></div>
<div class="paragraph"><p>Давайте подивимось, як ви можете створити ваші власні модулі, створивши невеликий модуль, що провадить деякі функції для обчислення об'єму та площі декількох геометричних об'єктів. Ми почнемо зі створення файла з назвою <code>Geometry.hs</code>.</p></div>
<div class="paragraph"><p>Ми кажемо, що модуль експортує функції. Це означає те, що коли я імпортує модуль, я можу використовувати функції, які він експортує. Він може визначати функції, що його функції використовують внутрішньо, але ми можемо бачити та використовувати лише ті, що експортуються.</p></div>
<div class="paragraph"><p>На початку модуля ми вказуємо ім'я модуля. Якщо ми маємо файл з назвою <code>Geometry.hs</code>, тоді ми маємо назвати наш модуль <code>Geometry</code>. Потім ми вказуємо функції, які він експортує, і після цього ми починаємо писати функції. Так що ми почнемо з цього.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ми бачимо, ми робимо площі та об'єми для сфер, кубів та кубоїдів. Ідемо далі і визначаємо функції:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тут досить стандартна геометрія. Деякі речі мають прийти на думку. Оскільки куб лише особливий випадок кубоїду, ми визначили його площу та об'єм через трактування його як кубоїда, в якого всі сторони рівної довжини. Ми також визначили допоміжну функцію з назвою <code>rectangleArea</code>, що обчислює площу прямокутника на основі довжини сторін. Вона скоріше тривіальна, бо це лише множення. Зауважте, що ми використали її в наших функціях в модулі (а саме <code>cuboidArea</code> та <code>cuboidVolume</code>), але ми не експортували її! Оскільки ми лише бажаємо, щоб наш модуль представляв лише функції, що мають справу з тривимірними об'єктами, ми використали <code>rectangleArea</code>, але ми не експортували її.</p></div>
<div class="paragraph"><p>При створенні модуля ми зазвичай експортуємо тільки ті функції, що діють як різновид інтерфейсу до нашого модуля, так що сама релалізація прохована. Якщо дехто використовує наш модуль <code>Geometry</code>, вони не мають обтяжувати себе функціями, які ми не експортуємо. Ми можемо вирішити змінити ці функції повністю, або видалити їх в новій версії (ми можемо видалити <code>rectangleArea</code> та замість поставити лише <code>*</code>), і ніхто не перейматиметься, бо ми для початку не експортували їх.</p></div>
<div class="paragraph"><p>Щоб використати наш модуль ми просто робимо:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Geometry.hs</code> повинен бути в тій же папці, що і програма, до якої ми його імпортуємо.</p></div>
<div class="paragraph"><p>Модулі також можуть бути взяті як ієрархічні структури. Кожний модуль може мати декілька субмодулів, і ті також можуть мати власні субмодулі. Давайте поділимо ці функції, так що <code>Geometry</code> буде модулем, що має три субмодулі, по одному для кожного типу об'єктів.</p></div>
<div class="paragraph"><p>Спочатку створимо папку з назвою <code>Geometry</code>. Подумайте про велику  <code>G</code>. В цій папці розташуємо три файли: <code>Sphere.hs</code>, <code>Cuboid.hs</code>, та <code>Cube.hs</code>. Ось що будуть містити файли:</p></div>
<div class="paragraph"><p><code>Sphere.hs</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Cuboid.hs</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>Cube.hs</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гаразд! Перше <code>Geometry.Sphere</code>. Зауважте, як ми поклали його в папку з назвою <code>Geometry</code>, та потім визначили модуль на ім'я <code>Geometry.Sphere</code>. Ми зробили те саме для кубоїда. Також зауважте, як в усіх трьох субмодулях ми визначили функції з тими самими назвами. Ми можемо зробити це, оскільки вони в окремих модулях. Ми бажаємо використати функції з <code>Geometry.Cuboid</code> в <code>Geometry.Cube</code>, але ми не можемо напряму зробити імпорт <code>Geometry.Cuboid</code>, оскільки він експортує функції з тими самими іменами, що і <code>Geometry.Cube</code>. Ось чому ми зробили кваліфікований імпорт, і все гаразд.</p></div>
<div class="paragraph"><p>Так що коли ми в файлі на тому самому рівні, що і папка <code>Geometry</code>, ми можемо зробити, скажімо, таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>area</code> та <code>volume</code>, і вони даватимуть нам площу та об'єм сфери. Але якщо ми бажаємо жанглювати двома або більше з ціх модулів, ми маємо робити кваліфікований імпорт, оскільки вони експортують функції з тіма самими іменами. Так що ми робимо дещо таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>Sphere.area</code>, <code>Sphere.volume</code>, <code>Cuboid.area</code>, тощо, і кожний буде обчислювати площу та об'єм для свого відповідного об'єкту.</p></div>
<div class="paragraph"><p>Наступного разу, коли ви будете писати файл, що дійсно великий, та має безліч функцій, спробуйте визначити, які функції служать якімось загальним цілям, і потім розгляньте, як покласти ці функції у свій власний модуль. Ви будете в змозі просто імпортувати ваш власний модуль наступного разу, коли ви писатимите програму, що потребує тої самої функціональності.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p>В попередніх главах ми розглядали деякі існуючі типи та типокласи Haskell. В цій главі ми навчимось як створювати свої власні, та як змусити їх робити!</p></div>
<div class="paragraph"><p>Досі ми зустрічали багато типів даних. <code>Bool</code>, <code>Int</code>, <code>Char</code>, <code>Maybe</code>,тощо. Але як ми створюємо свої власні? Гаразд, один спосіб є використання ключового слова <code>data</code> для визначення типу. Давайте подивимось, як визначений тип <code>Bool</code> в стандартній бібліотеці.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>data</code> означає, що ми визначаємо новий тип даних. Частина перед <code>=</code> означає тип, що є <code>Bool</code>. Частини після <code>=</code> є конструкторами значень. Вони вказують різні значення, що може мати тип. <code>|</code> читається як <em>або</em>. Так що ми можемо читати це так: тип <code>Bool</code> може мати тип значення <code>True</code> або <code>False</code>. Обоє, им'я типу та конструктори значення, мають бути з великої літери.</p></div>
<div class="paragraph"><p>В подібному стилі ми можемо думати про тип <code>Int</code>, як визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/caveman.png" alt="images/caveman.png" />
</span>
Перший та останній конструктори значень є мінімальне та максимальне можливі значення для <code>Int</code>. Насправді це не визначено таким чином, три крапки, що стоять тут, через те, що ми пропустили безліч чисел, так що все це тільки для цілей ілюстрації.</p></div>
<div class="paragraph"><p>Тепер давайте подумаємо про те, як ми можемо представити фігуру в Haskell. Один спосіб може бути використання таплів. Коло може бути позначено як <code>(43.1, 55.0, 10.4)</code>, де перші два поля є координати центру, а третє поле є радіус. Звучить OK, але це може представляти 3D вектор або будь-що ще. Краще рішення може бути зробити ваш власний тип для представлення фігури. Скажімо, фігури, що може бути колом або прямокутником. Ось вона:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що це тепер? Думайте про це так. Конструктор значення <code>Circle</code> має три поля, що приймають числа з плаваючою крапкою. Так що коли ми пишемо конструктор значення, ми можемо опціонально додати деякі типи після нього, і ці типи визначають значення, що він міститиме. Тут перші два поля є координатами його центру, третя є радіусом. Конструктор значення <code>Rectangle</code> має чотири поля, що приймають плаваючу крапку. Перші два є координатами його верхнього лівого кута, та другі два є координати його нижнього правого кута.</p></div>
<div class="paragraph"><p>Тепер, коли я кажу поля, я насправді маю на увазі параметри. Конструктори значень насправді є функціями, що кінець кінцем повертають значення типу даних. Давайте поглянемо на сигнатури типів для ціх двох конструкторів.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Круть, так що конструктори значень є функціями як всі інші. Хто б міг подумати? Давайте створимо функцію, що приймає фігуру та повертає її поверхню.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Перша помітна річ тут є декларація типу. Вона каже, що функція приймає фігуру та повертає число. Ми не можемо написати декларацію типу <code>Circle -&gt; Float</code>, оскільки <code>Circle</code> не є типом, але <code>Shape</code> так. Це так само, як ми не можемо написати функцію з декларацією типу <code>True -&gt; Int</code>. Наступна річ, яку ми відмітимо тут, є те, що ми можемо робити порівняння шаблонів до конструкторів. Ми порівнювали шаблони проти конструкторів до цього (насправді весь час), коли ми порівнювали шаблони проти значень як <code>[]</code> або <code>False</code> або <code>5</code>, тількі ці значення не мали жодних полів. Ми тільки що написали конструктор, та потім прикріпили його поля до імен. Оскільки ми зацікавлені в радіусі, ми насправді не зацікавлені в перших двох полях, що кажуть нам, де знаходиться коло.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Вау, це робить! Але якщо ви спробуєте просто надрукувати <code>Circle 10 20 5</code> в підказці, ми отримаємо помилку. Це тому, що Haskell не знає, як відображувати наші типи даних як рядок (доки). Згадайте, коли ми намагаємось друкувати значення в підказці, Haskell спочатку виконує функцію <code>show</code> для отримання рядкової репрезентації нашого значення, та потім він друкує це на термінал. Щоб зробити наш тип <code>Shape</code> частиною типокласа <code>Show</code>, ми модифікуємо його таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми доки не будемо заморочувати себе <code>deriving</code> дуже сильно. Давайте просто скажемо, що якщо ми додаємо <code>deriving (Show)</code> в кінці декларації даних, Haskell автомагічно робить цей тип частиною типокласу <code>Show</code>. Так що зараз ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Конструктори значень є функціями, так що ми можемо відображати їх та частково застосовувати їх, і все інше. Якщо ми бажаємо список концентричних з різними радіусами, ми можемо зробити це.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Наш тип даних гарний, хоча він міг би бути кращим. Давайте створимо проміжний тип даних, що визначає точку в двовимірному просторі. Потім ми можемо використовувати це для створення наших фігур більш зрозумілим способом.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, що коли визначали точку, ми використали те саме ім'я для типу даних та значення конструктора. Це не має особливого значення, хоча це загально використовувати те саме ім'я що і тип, якщо це конструктор одного значення. Так що тепер <code>Circle</code> має два поля, один має тип <code>Point</code>, та інше тип <code>Float</code>. Це спрощує розуміння того, що є що. Те саме стосується і прямокутника. Ми маємо налаштувати нашу функцію <code>surface</code> для відзеркалення ціх змін.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Одна річ, що ми маємо змініти, це шаблони. Ми зневажили цілу точку в шаблоні кола. В шаблоні прямокутника ми просто використовували вкладене порівняння шаблонів, щоб отримати поля точок. Якщо ми б бажали посилатись на самі точки з якоїсь причини, ми могли б використати <code>as</code>-шаблони.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як щодо функції, що рухає фігуру? Вона бере фігуру, величину руху по осі <code>x</code>, величину руху по осі <code>y</code>, та потім повертає нову фігуру, що має ті самі розміри, але розміщений в іншому місці.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить прямолінійно. Ми додаємо зсув до точок, що відповідають за позицію фігури.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми не бажаємо мати справу напряму з точками, ми можемо зробити деякі додаткові функції, що створюють фігури деякого розміру з нульовими координатами, та потім рухати їх.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Звичайно, ви можете експортувати ваші типи даних в ваші модулі. Щоб зробити це, просто напишіть ваші типи разом з функціями, що ви експортуємо, та потім додайте деякі дужки, і в них вкажіть конструктори значень, що ви бажаєте експортувати для них, розділені комами. Якщо ви бажаєте експортувати всі конструктори значень для даного типу, просто напишіть <code>..</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте експортувати функції та типи, що ми визначили тут, в модулі, ми можемо почати, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Роблячи <code>Shape(..)</code>, ми експортуємо всі конструктори значень для <code>Shape</code>, і це означає, що коли дехто імпортує наш модуль, він зможе створювати фігури, використовуючи конструктори значень <code>Rectangle</code> та <code>Circle</code>. Це те саме, що написати <code>Shape (Rectangle, Circle)</code>.</p></div>
<div class="paragraph"><p>Ми також можемо вирішити не експортувати жодних конструкторів значень для <code>Shape</code>, просто написавши <code>Shape</code> в твердженні <code>export</code>. Таким чином, той, хто імпортує наш модуль, зможе створювати фігури через використання додаткових функцій <code>baseCircle</code> та <code>baseRect</code>. <code>Data.Map</code> використовує цей підхід. Ви не можете створити мапу, зробивши <code>Map.Map [(1,2),(3,4)]</code>, оскільки він не експортує конструктор значень. Однак ви можете створити відображення через використання однієї з додаткових функцій як <code>Map.fromList</code>. Згадайте,що конструктори є тільки функціями, що приймають поля як параметри, та повертає значення деякого типу (як <code>Shape</code>) в якості результату. Так що коли ми обираємо не експортувати їх, ми просто не даємо тому, хто імпортує наш модуль, використосувати ці функції, але якщо деякі інші функції, що експортуються, повертають тип, ми можемо використовувати їх для створення значень наших власних типів даних.</p></div>
<div class="paragraph"><p>Не-експортування конструкторів значень типів даних робить їх більш абстрактними в той спосіб, що ми приховуємо їх реалізацію. Також той, хто користується нашими типами, не зможе робити порівняння шаблонів до конструкторів значень.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/record.png" alt="images/record.png" />
</span>
OK, ми отримали завдання створити тип даних, що описував би осообу. Інформація, що ми бажаємо зберігати щодо особи, наступна: ім'я, фамілія, вік, зріст, номер телефону та улюблений сорт морозива. Не знаю як щодо вас, але це все, що я будь-коли бажав знати про людину. Давайте дамо цьому хід!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Окей. Перше поле є першим ім'ям, друге фамілія, третє вік і так далі. Давайте створимо особу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це дещо круте, але трохи не читається. Що, коли ми бажаємо створити функцію для отримання окремої інформації про особу? Функцію, що отримує ім'я, фамілію, вік, тощо. Гаразд, ми маємо визначити її таким чином.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Хух! Я напевне не був радий написати це! Не зважаючи на плутанину і СКУКУ під час написання, цей метод робить.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Має бути кращий спосіб, скажете ви! Ні, немає, пробачайте.</p></div>
<div class="paragraph"><p>Я шуткую, він є. Гигиги! Творці Haskell були досить розумні та передбачили цей сценарій. Вони включили альтернативний спосіб для написання типів даних. Ось як ми можемо досягти ту ж функціональність за допомогою синтаксису запису.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так що замість називати типи полів один за одним, та розділяти їх проміжками ми використовуємо фігурні дужки. Спочатку ми пишемо ім'я поля, наприклад <code>firstName</code>, та потім ми пишемо дві двокрапки <code>::</code> (що також називається <code>Paamayim Nekudotayim</code>, ахаха - <em>насправді це саме подвійна двокрапка на івриті, назва з'явилась вперше в PHP3 як кваліфікатор поля зору. прим.перекл.</em>), і потім ми задаємо тип. Результуючий тип даних саме такий. Головна перевага цього в тому, що він створює функції, що шукають поля в типі даних. Через використання синтаксису полів для створення цього типу даних, Haskell автоматично створює ці функції: <code>firstName</code>, <code>lastName</code>, <code>age</code>, <code>height</code>, <code>phoneNumber</code> та <code>flavor</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Є інша вигода використовувати синтаксис записів. Коли ви наслідуєте  <code>Show</code> для типа, він відображує його по різному, якщо ми використоауємо синтаксис запису при визначенні і створенні екземпляру типу. Скажімо ми маємо тип, що представляє машину. Ми бажаємо відслідковувати компанію, що виробляє її, назву моделі, та рік її виробництва. Дивіться.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми використаємо синтаксис запису, ми можемо створити нову машину таким чином.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми створюємо машину, ми не обов'язково покладаємо поля в певному порядку, доки ми вказуємо їх всі. Але якщо ми не використовуємо синтаксис запису, ми маємо вказувати їх по порядку.</p></div>
<div class="paragraph"><p>Використовуйте синтаксис записів, коли конструктор має декілька полів, і не очевидне, яке поле є яке. Якщо ми створюємо тип даних для тривимірного вектора, роблячи <code>data Vector = Vector Int Int Int</code>, є досить очевидним, що поля є компонентами вектора. Але в наших типах <code>Person</code> та <code>Car</code> це не буде таким очевидним, і ми отримаємо велику вигоду, використовуючи синтаксис запису.</p></div>
<div class="paragraph"><p>Конструктор значення може приймати деякі параметри значення, та потім продукувати нове значення. Наприклад, конструктор <code>Car</code> бере три значення і продукує значення машини. В подібний спосіб конструктори типів можуть приймати типи та продукувати нові типи. Спочатку це може виглядати трохи абстрактним, але це не так складно. Якщо ви знайомі з шаблонами в C++, ви побачите деякі паралелі. Щоб отримати ясну картину як діють параметри типів насправді, давайте поглянемо, як реалізовані типи, з якими ми вже зустрічались.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/yeti.png" alt="images/yeti.png" />
</span>
Тут <code>a</code> є параметром типу. І оскільки задіяно параметр типу, ми викликаємо конструктор типу <code>Maybe</code>. В залежності від того, який тип даних ми бажаємо містити, коли це не <code>Nothing</code>, цей конструктор може кінець кінцем продукувати тип <code>Maybe Int</code>, <code>Maybe Car</code>, <code>Maybe String</code>, тощо. Жодне значення не може мати тип просто <code>Maybe</code>, оскільки це не тип як такий, це конструктор типів. Щоб це стало реальним типом, частиною якого може бути значення, він має заповнити всі свої параметри типів.</p></div>
<div class="paragraph"><p>Так що коли ми передамо <code>Char</code> як параметр типів до <code>Maybe</code>, ми отримаємо тип <code>Maybe Char</code>. Значення <code>Just 'a'</code> має тип <code>Maybe Char</code>, як для прикладу.</p></div>
<div class="paragraph"><p>Ви могли цього не знати, але ми використовували тип, що мав параметр типу, перед тим як ми використовували <code>Maybe</code>. Цей тип є тип списку. Хоча тут задієний деякий синтаксичний цукор, тип списку приймає параметр для утворення певного типу. Значення можуть мати тип <code>[Int]</code>, тип <code>[Char]</code>, тип <code>[[String]]</code>, але ви не можете мати значення, що має просто тип <code>[]</code>.</p></div>
<div class="paragraph"><p>Давайте пограємось з типом <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Параметри типів корисні, оскільки ми можемо робити різні типи з їх допомогою, в залежності від того, який тип ми бажаємо щоб містився в нашому типі даних. Коли ми робимо <code>:t Just "Haha"</code>, рушій виводу типів здогадується, що тип має бути <code>Maybe [Char]</code>, бо якщо <code>a</code> в  <code>Just</code> є рядком, тоді <code>a</code> в <code>Maybe</code> також має бути рядком.</p></div>
<div class="paragraph"><p>Зауважте, що тип <code>Nothing</code> є <code>Maybe a</code>. Його тип поліморфний. Якщо деяка функція потребує <code>Maybe Int</code> в якості параметра, ми можемо дати їй <code>Nothing</code>, оскільки <code>Nothing</code> все одно не містить значення, так що воно не має значення. Тип <code>Maybe a</code> може діяти як <code>Maybe Int</code> в разі потреби, так само, як <code>5</code> може діяти як <code>Int</code> або <code>Double</code>. Подібним чином тип порожнього списку є <code>[a]</code>. Порожній список може діяти як список будь чого. Ось чому ми можемо робити <code>[1,2,3] ++ []</code> та <code>["ha","ha","ha"] ++ []</code>.</p></div>
<div class="paragraph"><p>Використання параметрів типів дуже корисні, але тільки якщо їх використання має сенс. Зазвичай ми використовуємо їх, коли наш тип даних буде робити незалежно від типа значення, що буде міститись в ньому. Якщо наш тип діє як свого роду ящик, буде гарно використати його. Ми можемо змінити наш тип даних <code>Car</code> з такого:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>До такого:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Але чи буде з цього користь? Відповідь така: мабуть ні, бо ми лише скінчимо визначенням функцій, що роблять на типі <code>Car String String Int</code>. Наприклад, беручи наше перше визначення <code>Car</code>, ми можемо створити функцію, що показує властивості машини в вигляді невеликого гарного тексту.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Мила мала функція! Декларація типу мила і вона робить гарно. Тепер що буде, коли б <code>Car</code> був <code>Car a b c</code>?</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми б мали примушувати цю функцію приймати тип <code>Car</code> <code>(Show a) =&gt; Car String String a</code>. Ви бачите що ця сигнатура типу більш ускладнена, і дійсно може бути корисною, коли б могли використовувати любий тип, що є примірником типокласу <code>Show</code>, як тип для <code>c</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/meekrat.png" alt="images/meekrat.png" />
</span>
Однак в реальному житті ми будемо в більшості випадків використовувати <code>Car String String Int</code>, так що параметризація типів типу <code>Car</code> насправді не варта цього. Ми звичайно використовуємо параметри типів, коли тип, що міститься в різних конструкторах типу даних насправді не такий важливий для роботи типу. Список речей є список речей, і немає значення, якого типу є ці речі - він все одне буде робити. Якщо ви бажаєте отримати суму чисел, ми можемо вказати візніше в функції суми, що нам потрібен список чисел. Те саме і щодо <code>Maybe</code>. <code>Maybe</code> представляє опцію або не мати нічого, або мати одне щось. Не має значення, якого типу є це дещо.</p></div>
<div class="paragraph"><p>Інший тип параметризованого типу є те, з чим ми вже стикались, і це <code>Map k v</code> з <code>Data.Map</code>. <code>k</code> є типом ключів в мапі, і <code>v</code> є типом значень. Це гарний приклад того, де параметри типів дуже корисні. Маючі параметризовані мапи дозволяє нам робити відображення з любого типу на інший тип, доки тип ключа є частиною типокласу <code>Ord</code>. Якщо ми визначили тип відображення, ми можемо додати обмеження типокласу в декларації даних:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Однак існує дуже сильна домовленість в Haskell ніколи не додавати обмеження типокласів в декларації даних. Чому? Гаразд, бо ми не отримаємо багато вигоди, але ми закінчимо написанням додаткових класових обмежень, навіть якщо не потребуємо їх. Якщо ми покладемо, або не покладемо обмеження <code>Ord k</code> в декларацію даних для <code>Map k v</code>, ми матимемо покладати обмеження в функції, що очікують, що ключі в мапі можуть бути впорядковані. Але якщо ми не покладемо обмеження в декларацію даних, ми не маємо ставити <code>(Ord k) =&gt;</code> в декларації типу функцій, що не переймаються через впорядкованість ключів. Прикладом такої функції є <code>toList</code>, що просто бере відображення, та конвертує його в асоціативний список. Її сигнатура типу є <code>toList ::Map k a -&gt; [(k, a)]</code>. Якщо <code>Map k v</code> має обмеження типу в своїй декларації типу, тип для <code>toList</code> має бути <code>toList ::(Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, навіть якщо функція не робить жодних порівнянь ключів за порядком.</p></div>
<div class="paragraph"><p>Так що не покладайте обмеження типу в визначення даних, навіть якщо це виглядає як маюче сенс, бо ви матимете покладати їх в декларації типів функцій в жодному випадку.</p></div>
<div class="paragraph"><p>Давайте реалізуємо тип 3D вектора, і додамо до нього деякі операції. Ми будемо використовувати параметризований тип, бо якщо він звичайно буде містити числові типи, він все одно буде підтримувати декілька з них.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><code>vplus</code> існує для додавання разом двох векторів. Два вектори додаються просто через додавання своїх відповідних компонент. <code>scalarMult</code> є для скалярнрного множення двох векторів, і <code>vectMult</code> для множення вектора на скаляр. Ці методи можуть оперувати на типах <code>Vector Int</code>, <code>Vector Integer</code>, <code>Vector Float</code>, та будь-чого, доки  <code>a</code> в <code>Vector a</code> належить з типокласу <code>Num</code>. Також, якщо ви перевірите декларації типів для ціх функцій, ви побачите, що вони можуть оперувати тільки на векторах одного типу, і задіяні числа також мають бути одного типу, що міститься в векторах. Зауважте, що ми не покладаємо обмеження класу <code>Num</code> в декларацію даних, бо ми  все одно повторюємо його в функціях.</p></div>
<div class="paragraph"><p>І ще раз: дуже важливо розрізняти конструктор типу і конструктор значення. При декларації типу даних, частина перед <code>=</code> є конструктором типу, і конструктори після нього (можливо розділені <code>|</code>) є конструкторами значення. Беручи функцію типу <code>Vector t t t -&gt; Vector t t t -&gt; t</code> буде помилкою, оскільки ми маємо покладати типи в декларації типів, і конструктор типу вектора приймає тільки один параметр, тоді як конструктор значення бере три. Давайте пограємось з нашими векторами.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/gob.png" alt="images/gob.png" />
</span>
В розділі Типокласи 101 ми пояснили основи типокласів. Ми пояснили, що типокласи є різновидом інтерфейса, що визначає деяку поведінку. Тип може бути зроблений примірником типокласу, якщо він підтримує цю поведінку. Приклад: тип <code>Int</code> є примірником типокласу <code>Eq</code>, оскільки типоклас <code>Eq</code> визначає поведінку для речей, що можуть бути рівними. І оскільки можливо порівняти цілі, <code>Int</code> є частиною типокласу <code>Eq</code>. Реальна користь іде від функцій, що діють як інтерфейс для <code>Eq</code>, а саме <code>==</code> та <code>/=</code>. Якщо тип є частиною типокласу <code>Eq</code>, ми можемо використовувати функції <code>==</code> зі значенням цього типу. Ось чому вирази як <code>4 == 4</code> та <code>"foo" /= "bar"</code> проходять перевірку типів.</p></div>
<div class="paragraph"><p>Ми також зазначали, що вони часто плутаються з класами в мовах як Java, Python, C++ і тому подібних, що потім бентежить багато людей. В ціх мовах класи є калькою, з якої потім створюються об'єкти, що мають стан та можуть виконувати деякі дії. Типокласи більше подібні до інтерфейсів. Ми не створюємо дані з типокласів. Замість цього ми створюємо наші типи даних, і потім ми думаємо, як вони можуть діяти. Якщо вони можуть діяти як дещо, що можливо порівняти, ми робимо його примірником типокласа <code>Eq</code>. Якщо воно діє як дещо, що можливо впорядкувати, ми робимо його примірником типокласу <code>Ord</code>.</p></div>
<div class="paragraph"><p>В наступному розділі ми поглянемо, як ми можемо вручну зробити наші типи примірниками типокласів, через реалізацію функцій, визначених в типокласах. Але прямо зараз давайте поглянемо, як Haskell може автоматично зробити наш тип примірником наступних типокласів: <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code>, <code>Read</code>. Haskell може вивести поведінку наших типів в ціх контекстах, якщо ми використовуємо ключове слово <code>deriving</code> при створенні нашого типу даних.</p></div>
<div class="paragraph"><p>Розглянемо цей тип даних:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Він описує особу. Уявімо, що жодні дві людини не мають ту саму комбінацію імені, фамілії та віку. Тепер, якщо ми маємо записи про двох людей, чи матиме сенс перевірити, що вони представляють ту саму особу? Напевне що так. Ми можемо спробувати порівняти їх, щоб побачити, чи воні однакові чи ні. Ось чому має сенс для цього типу бути частиною типокласу <code>Eq</code>. Ми виведемо примірник.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми виводимо примірник <code>Eq</code> для типа, і потім намагаємось порівняти два значення цього типу за допомогою <code>==</code> або <code>/=</code>, Haskell подивиться, чи співпадають конструктори значень (в нас тільки один конструктор значень), і потім він перевірить, що всі дані, які містяться всередині співпадають, через перевірку пар полів за допомогою <code>==</code>. Однак є одна пастка: типи всіх полів також мають бути частиною типокласу <code>Eq</code>. Але оскільки обоє, <code>String</code> та <code>Int</code> - так, то в нас все гаразд. Давайте перевіримо наш примірник <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Звичайно, оскільки <code>Person</code> тепер в <code>Eq</code>, ми можемо використовувати його для всіх функцій, що мають обмеження класу <code>Eq</code> в своїй сигнатурі типу, таких як <code>elem</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Типокласи <code>Show</code> та <code>Read</code> призначені для речей, що можуть бути перетворені на або з рядків, відповідно. Так само, як для <code>Eq</code>, якщо конструктор типу має поля, їх тип має бути частиною <code>Show</code> або <code>Read</code>, якщо ми бажаємо зробити наш тип їх примірником. Давайте зробимо наш тип даних <code>Person</code> частиною також <code>Show</code> та <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер ми можемо друкувати дані про особу на терміналі.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли б ми спробували друкувати особу на термінал, перед тим, як зробити тип даних <code>Person</code> частиною <code>Show</code>, Haskell би поскаржився на нас, кажучи що не може представити особу як рядок. Але тепер, коли ми вивели примірник <code>Show</code> для цього, він вже знає.</p></div>
<div class="paragraph"><p><code>Read</code> є достатньо повною протилежністю до типокласу <code>Show</code>. <code>Show</code> служить перетворенню значень нашого типу до рядка, <code>Read</code> для перетворення рядків до значень нашого типу. Однак пам'ятайте, коли ми використовуємо функцію читання, ми маємо використовувати явну анотацію типу, щоб сказати Haskell, який тип ми бажаємо отримати як результат. Якщо ми не зробимо бажаний тип явним, Haskell не знатиме, який тип ми бажаємо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми використовуємо результат нашого читання пізніше в спосіб, що Haskell зможе вивести, що прочитане має використовуватись як особа, ми не повинні використовувати анотацію типу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми також можемо читати параметризовані типи, але ми повинні заповнити параметри типів. Так що ми не можемо робити <code>read "Just 't'" ::Maybe a</code>, але можемо зробити <code>read "Just 't'" ::Maybe Char</code>.</p></div>
<div class="paragraph"><p>Ми можемо вивести примірники для типокласу <code>Ord</code>, що є для типів, значення яких можна впорядкувати. Якщо ми порівняємо два значення того самого типу, що були створені з використанням різних конструкторів, значення, що було створене за допомогою конструктора, що був визначений раніше, вважається меньшим. Наприклад, розглянемо тип <code>Bool</code>, що має значення або <code>False</code> або <code>True</code>. Для наших цілей побачити їх поведінку при порівнянні, будемо вважати що вони реалізовані таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки конструктор значення <code>False</code> вказаний першим, і конструктор значення <code>True</code> вказаний після цього, ми розглядаємо <code>True</code> як більше за <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В типі даних <code>Maybe</code> конструктор значення <code>Nothing</code> вказаний перед конструктором <code>Just</code>, так що <code>Nothing</code> завжди меньший, ніж значення <code>Just</code> дещо, навіть як це дещо мінус мільярд трильйонів. Але якщо ми порівняємо два <code>Just</code> значення, тоді відбудеться порівняння того, що в них.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Але ми не можемо робити дещо як <code>Just (*3) &gt; Just (*2)</code>, оскільки <code>(*3)</code> та <code>(*2)</code> є функціями, що не є примірниками <code>Ord</code>.</p></div>
<div class="paragraph"><p>Ми можемо просто використовувати алгебраїчні типи даних для створення переліків, і типокласи <code>Enum</code> та <code>Bounded</code> допомагають нам з цім. Розглянемо наступний тип даних:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки всі конструктори даних мають нульову арність (не мають параметрів, тобто полів), ми можемо зробити його типокласу <code>Enum</code>. Типоклас <code>Enum</code> призначений для речей, що мають попередників та наступників. Ми також можемо зробити його частиною типокласу <code>Bounded</code>, що існує для речей, що мають найменьше можливе значення та найбільше можливе значення. І доки ми поряд з цім, давайте також зробимо його примірником всіх інших виведених типокласів, і побачимо, що ми можемо з цім зробити.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки це є частиною типокласів <code>Show</code> та <code>Read</code>, ми можемо перетворити значення цього типу на та з рядків.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Оскільки це є частиною типокласу <code>Eq</code> та <code>Ord</code>, ми можемо порівняти або перевірити дні на рівність.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це також є частиною <code>Bounded</code>, так що ми можемо отримати найменьший та найбільший день.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це також є примірником <code>Enum</code>. Ми можемо отримати попередні та наступні дні, та ми можемо створити диапазони з них!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це досить чудово.</p></div>
<div class="paragraph"><p>До цього ми згадували, що при написанні типів <code>[Char]</code> та <code>String</code> еквівалентні та взаємозамінні. Це зроблено за допомогою синонимів типів. Синоніми типів насправді нічого не роблять як такі, вони тільки надають деяким типам різні імена, так що вони мають більше сенсу при читанні коду або документації. Ось як стандартна бібліотека визначає <code>String</code> як синонім для <code>[Char]</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/chicken.png" alt="images/chicken.png" />
</span>
Ми вводили ключове слово <code>type</code>. Ключове слово може декого ввесвти в оману, бо насправді ми не створюємо нічого нового (ми робимо це за допомогою ключового слова <code>data</code>), але ми лише створюємо синонім для вже існуючого типу.</p></div>
<div class="paragraph"><p>Якщо ми створимо функцію, що конвертує рядок в верхній реєстр, та назвемо її <code>toUpperString</code> або якось ще, ми можемо надати їй декларацію типу <code>toUpperString ::[Char] -&gt; [Char]</code> або <code>toUpperString ::String -&gt; String</code>. Обоє з них будуть по суті одне і те ж, тільки останню приємнише читати.</p></div>
<div class="paragraph"><p>Коли ми мали справу з модулем <code>Data.Map</code>, ми спочатку представили телефонний довідник за допомогою асоціативного списку, перед перетворенням його на мапу. Як ми вже з'ясували, асоціативний список є списком пар ключ-значення. Давайте подивимось на телефонний довідник, що в нас є.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми бачимо, що тип довідника <code>phoneBook</code> є <code>[(String,String)]</code>. Це каже нам, що це асоціативний список, що відображує рядки на рядки, але нічого більше. Давайте створимо синонім типу, щоб передати дещо більше інформації в декларації типу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер декларація типу для нашого довідника може бути <code>phoneBook ::PhoneBook</code>. Давайте створимо синонім типу також і для <code>String</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Надати синонім типу для <code>String</code> є дещо, що програмісти Haskell роблять, коли вони бажають передати більше інформації щодо того, що будуть робити рядки в їх функціях, і що вони представляють.</p></div>
<div class="paragraph"><p>Так що тепер, коли ми реалізуємо функцію, що приймає ім'я і номер, і перевіряємо, що комбінація імені і номера є в нашому довіднику, ми можемо надати їй дуже гарну і описову декларацію типу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Якщо ми оберемо не використовувати синоніми, наша функція мала б тип <code>String -&gt; String -&gt; [(String,String)] -&gt; Bool</code>. В цьому випадку декларація типу, що користується перевагами синонимів, простіша для розуміння. Але з ними не треба передати куті меду. Ми вводимо синоніми типів або для опису, що саме представляє тип в наших функціях (і таким чином наші декларації типів стають кращою документацією), або коли дещо має задовгий тип, що представляє багато чого (як <code>[(String,String)]</code>), але являє собою дещо більш специфічне в контексті нашої функції.</p></div>
<div class="paragraph"><p>Синоніми типів також можуть бути параметризованими. Якщо ви бажаєте мати тип, що представляє асоціативний список, але також бажаєте зробити його загальним, так щоб ви могли використовувати любі типи для ключів та значень, ми можемо зробити таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер функція, що отримує значення по ключу в асоціативному списку може мати тип <code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>. <code>AssocList</code> є конструктором типу, що приймає два типи і продукує конкретний тип, як наприклад <code>AssocList Int String</code>.</p></div>
<div class="paragraph"><p>Фонзі каже: Йо! Коли я казав про конкретні типи, я мав на увазі повністю застосовані типи, як <code>Map Int String</code>, або якщо ми мали справу з однією з тих поліморфних функцій, <code>[a]</code> або <code>(Ord a) =&gt; Maybe a</code>. І подібно до цього, я і хлопці кажуть, що <code>Maybe</code> є типом, але ми не маємо це на увазі, бо кожний ідіот знає, що <code>Maybe</code> є конструктором типів. Коли я застосовую додатковий тип до <code>Maybe</code>, як <code>Maybe String</code>, тоді я маю конкретний тип. Ви знаєте, що значення можуть мати тільки тип якщо він конкретний! Так що підсумовуючи - живіть швидко, любіть кріпко і не дозволяйте комусь іншому використовувати ваш гребінець!</p></div>
<div class="paragraph"><p>Так само, як ми можемо частково застосувати функції, так що ми отримуємо нові функції, так само ми можемо вказати конструктор типів з недостатньою кількістю параметрів типів, та отримати новий конструктор типів. Якщо ми бажаємо тип, що представляє мапу (від <code>Data.Map</code>) від цілих до чогось іншого, ми однаково можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Або ми можемо зробити це так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В жодному разі конструктор типів <code>IntMap</code> приймає один параметр, і це тип того, на що будуть вказувати наші цілі.</p></div>
<div class="paragraph"><p>О так. Якщо ви бажаєте спробувати і реалізувати це, ви можливо збираєтесь зробити кваліфікований імпорт <code>Data.Map</code>. Коли ви робите кваліфікований імпорт, конструктори типів також повинні мати перед собою ім'я модуля. Так що ви напишете <code>type IntMap = Map.Map Int</code>. Переконайтесь, що ви дійсно розумієте різницю між конструкторами типів і конструкторами значень. Тільки через те, що ми зробили синонім типу з назвою <code>IntMap</code> або <code>AssocList</code>, це не означає, що ми можемо робити речі, як <code>AssocList [(1,2),(4,5),(7,9)]</code>. Все що це означає, що ми можемо посилатись до його типу з використанням інших імен. Ми можемо робити <code>[(1,2),(3,5),(8,9)] ::AssocList Int Int</code>, що буде очікувати тип <code>Int</code> всередині, але ми можемо все ще використовувати цей список якби це був звичайний список з цілими всередині. Синоніми типів (і взагалі типи) можуть бути використані в частині типів в Haskell. Ми в типовій частині Haskell коли ми визначаємо нові типи (тобто в визначеннях даних та типів), або коли ми знаходимось за <code>::</code>. <code>::</code> є деккларація або анотація типу.</p></div>
<div class="paragraph"><p>Інший крутий тип даних, що приймає два типи як параметри, є тип <code>Either a b</code>. Грубо кажучи він визначений так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Він має два конструктори значень. Якщо використовується <code>Left</code>, тоді його компоненти типу <code>a</code>, і коли використовується <code>Right</code>, тоді його вміст типу <code>b</code>. Так що ми можемо використовувати цей тип для інкапсуляції значення одного або іншого типу, і тоді, коли ми отримуємо значення <code>Either a b</code>, ми звичайно порівнюємо з шаблоном на обох, <code>Left</code> та <code>Right</code>, і ми відрізняємо речі на основі того, який з двох типів він має.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досі ми бачили, що <code>Maybe</code> здебільшого використовувався для представлення обчислень, що могли або схибити, або ні. Але іноді <code>Maybe</code> не досить гарний, оскільки <code>Nothing</code> насправді не передає досить інформації, окрім того що дещо схибило. Це добре для функцій, що можуть схибити тільки в один спосіб, або якщо нас не цікавить, як вони схибили. Пошук <code>Data.Map</code> буде невдалий тільки якщо ключ не буде знайдений в мапі, так що ми точно знаємо, що скоїлось. Однак якщо ми зацікавлені, як саме функція схибила та чому, ми зазвичай використовуємо результат типу <code>Either a b</code>, де <code>a</code> є деяким різновидом типу, що може сказати дещо про можливий збій, та <code>b</code> є типом вдалого обчислення. Таким чином помилки використовують конструктор значення <code>Left</code>, тоді як результати використовують <code>Right</code>.</p></div>
<div class="paragraph"><p>Приклад: вища школа має роздягальні, так що студенти мають місце для наліплювання своїх плакатів Guns&#8217;n'Roses. Кожна комірка має свою кодову комбінацію. Коли студент бажає нову роздягальну, він каже наглядачеві роздягальні, який номер він бажає, і той дає йому код. Але якщо хтось вже використовує цю комірку, він не може скзати код від тієї комірки, і вони мають обрати інший. Ми будемо використовувати мапу від <code>Data.Map</code> для представлення комірок. Мапа буде відображати номери комірок на пару, того чи комірка вже зайнята або ні, і код комірки.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Прості речі. Ми ввели новий тип даних для представлення того, чи комірка вільна чи ні,  і ми створили синонім для коду комірки. Ми також створили синонім типу для типу, що відображує цілі на пари зі стану та коду комірки. І тепер ми збираємось створити функцію, що шукатиме код в мапі комірок. Ми збираємось використати тип <code>Either String Code</code> для представлення нашого результату, оскільки наш результат може бути невдалим в два способи — комірка може бути зайнятою, в якому випадку ми кажемо код, або номер комірки може взагалі не існувати. Якщо пошук схибив, ми просто збираємось використати <code>String</code>, щоб сказати що трапилось.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми тут робимо звичайний пошук по мапі. Якщо ми отримаємо <code>Nothing</code>, ми повертаємо значення типу <code>Left String</code>, що каже, що комірка не існує взагалі. Якщо ми знайдемо її, тоді ми робимо додаткову перевірку, щоб перевірити, чи комірка зайнята. Якщо це так, повертаємо <code>Left</code>, що каже, що вона зайнята. Якщо це не так, тоді повертаємо значення типу <code>Right Code</code>, в якому ми надаємо студентові коректний код комірки. Насправді це <code>Right String</code>, але ми ввели новий синонім типу, щоб додати деяку додаткову документацію до декларації типу. Ось приклад мапи:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Тепер давайте спробуємо пошукати деякі коди комірок.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми могли б використати <code>Maybe</code> для представлення результату, але тоді ми б не знали, чому ми не змогли отримати код. Але тепер ми маємо інформацію щодо збою в нашому результуючому типі.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/thefonz.png" alt="images/thefonz.png" />
</span>
Як ми бачили, конструктор в алгебраїчному типі даних може мати декілька (або взагалі жодного) полів, і кожне поле повинно бути деякого конкретного типу. З цім на думці ми можемо створити типи, конструктори якого матимуть поля, що будуть того самого типу! Використовуючи це ми можемо створити рекурсивні типи даних, коли одне значення того самого типу містить значення цього типу, що, в свою чергу, містить ще більше значень того ж типу, і так далі.</p></div>
<div class="paragraph"><p>Подумайте про цей список: <code>[5]</code>. Це тільки синтаксичний цукор для <code>5:[]</code>. З лівого боку від <code>:</code> знаходиться значення, та з правого боку список. І в цьому порядку це порожній список. Тепер як щодо списку <code>[4,5]</code>? Гаразд, це розцукровується до <code>4:(5:[])</code>. Дивлячись на перше <code>:</code> ми бачимо, що він також має елемент з лівої сторони, і список <code>(5:[])</code> з правої сторони. Те саме зі списками як <code>3:(4:(5:6:[]))</code>, що може бути записане також як <code>3:4:5:6:[]</code> (оскільки <code>:</code> право-асоциативне), або <code>[3,4,5,6]</code>.</p></div>
<div class="paragraph"><p>Ми можемо сказати, що список може бути порожнім списком, або це може бути елемент, приєднаний разом через <code>:</code> з іншим списком (що також може бути порожнім списком, або ні).</p></div>
<div class="paragraph"><p>Давайте використаємо алгебраїчні типи даних для реалізації нашого власного типу!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це читається так само, як наше визначення списків з одного з наших попередніх параграфів. Це або порожній список, або комбінація голови в вигляді деякого значення, та списку. Якщо ви стурбовані цім, ви можете знайти простішим зрозуміти синтаксис запису.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ви також можете бути стурбовані щодо наведеного тут конструктора <code>Cons</code>. <code>cons</code> є інша слово для <code>:</code>. Ви бачите, що в списках <code>:</code> насправді є конструктором, що приймає значення та інший список, та повертає список. Ми вже використали наш власний тип списку! В інших словах, він має два поля. Одне поле має тип <code>a</code>, і інше має тип <code>[a]</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми викликали наш конструктор <code>Cons</code> в інфіксній манері, так що ми можемо бачити, наскільки це просто <code>:</code>. <code>Empty</code> як <code>[]</code>, і <code>4 `Cons</code> (5 <code>Cons</code> Empty)` як <code>4:(5:[])</code>.</p></div>
<div class="paragraph"><p>Ми можемо визначати функції, що автоматично будуть інфіксними, якщо вони будуть складатись тільки зі спеціальних символів. Ми можемо зробити те саме з конструкторами, бо вони є лише функціями, що повертають тип даних. Перевіримо це.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Поперше ми помічаємо нову синтаксичну конструкцію, декларацію фіксіті. Коли ми визначаємо функції як оператори, ми можемо використовувати це для надання фіксіті (але не маємо робити це). Фіксіті вказує, як сильно оператор прикріплюється, та чи є він ліво-асоціативним або право-асоціативним. Наприклад, фіксіті <code>*</code> є <code>infixl 7 *</code> та фіксіті <code>+</code> є <code>infixl 6</code>. Це означає, що вони обоє ліво-асоціативні <code>(4 * 3 * 2 is (4 * 3) * 2)</code>, але * прикріплюється краще, ніж <code>+</code>, бо він має більшу фіксіті, так що <code>5 * 4 + 3 is (5 * 4) + 3</code>.</p></div>
<div class="paragraph"><p>Так що ми пишемо просто <code>a :-: (List a)</code>, замість <code>Cons a (List a)</code>. Тепер ми можемо записати наші списки з нашим типом ось так:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми виводимо <code>Show</code> для нашого типу, Haskell все ще буде відображувати його так, якби конструктор був префіксною функцією, ось чому ми бачимо дужки коло оператора (згадайте, <code>4 + 3</code> є <code>(+) 4 3</code>).</p></div>
<div class="paragraph"><p>Давайте створимо функцію, що додає два наші списки разом. Ось як <code>++</code> визначений для звичайних списків:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так що ми просто вкрадемо його для нашого списку. Ми назвемо функцію <code>.++</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І давайте подивимось, чи буде це робити &#8230;</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гарно. Це гарно. Якщо б ми побажали, ми б реалізували всі функції, що оперують на списках, для нашого власного типу списків.</p></div>
<div class="paragraph"><p>Зауважте, як ми порівняли шаблон на <code>(x :-: xs)</code>. Це робить, бо порівняння шаблонів насправді має справу з порівнянням конструкторів. Ми можемо порівнювати на <code>:-:</code>, бо це конструктор для нашого власного типу списка, і ми також можемо порівнювати на <code>:</code>, бо це також конструктор для вбудованого типу списка. Те саме і для <code>[]</code>. Оскільки порівняння шаблонів робить (тільки) на конструкторах, ми можемо порівнювати на таких речах, звичайних префіксних конструкторах або такому, як <code>8</code> або <code>'a'</code>, що загалом конструктори для числових та символьних типах, відповідно.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/binarytree.png" alt="images/binarytree.png" />
</span>
Тепер ми збираємось реалізувати двійникове дерево пошуку. Якщо ви не знайомі з такими деревами з мов як C, ось цо вони таке: елемент вказує на два елемента, один сліва і один зправа. Елемент зліва меньший, елемент зправа більший. Кожний з ціх елементів також може вказувати на два елементи (або один, або на жодний). Ефективно кожний елемент має два під-дерева. І крута річ щодо двійникових дерев пошуку в тому, що ми знаємо, що всі елементи на лівому суб-дереві для, скажімо, <code>5</code>, будуть меньшими за <code>5</code>. Елементи в правому суб-дереві будуть більшими. Так що коли нам треба знайти <code>8</code> в нашому дереві, ми починаємо з <code>5</code>, та потім, через те, що <code>8</code> більше <code>5</code>, ми йдемо направо. Тепер ми на <code>7</code>, і оскільки <code>8</code> більше <code>7</code>, ми знову йдемо направо. І ми знайшли наш елемент за три стрибка! Тепер, якщо б це був список (або дерево, але дуже розбалансоване), це зайняло сім стрибків замість трьох, щоб побачити <code>8</code>.</p></div>
<div class="paragraph"><p>Множини та мапи від <code>Data.Set</code> та <code>Data.Map</code> реалізовані за допомогою дерев, тільки замість звичайних двійникових дерев пошуку вони використовують збалансовані двійникові дерева, що весь час збалансовані. Але зараз ми реалізуємо тільки звичайне двійнікове дерево пошуку.</p></div>
<div class="paragraph"><p>Ось що ми збираємось тут сказати: дерево або порожнє дерево, або це елемент, що містить деяке значення та два дерева. Звучить як ідеально підходяще для алгебраїчних типів даних!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так, гарно, це гарно. Замість побудови дерева вручну ми збираємось створити функцію, що приймає дерево і елемент, і вставляє елемент. Ми робимо це через порівняння значення, яке ми бажаємо вставити до кореневого вузла, і коли воно меньше, ми йдемо наліво, або якщо більше - направо. Ми робимо те саме для кожного наступного вузла, доки не дойдемо до порожнього дерева. Як тільки ми дійшли до порожнього дерева, ми просто вставляємо вузол з вставляємим значення замість порожнього дерева.</p></div>
<div class="paragraph"><p>В таких мовах, як C, ми робили б це через модифікацію вказівників та значень в дереві. В Haskell ми насправді не можемо модифікувати наше дерево, так що нам треба створити нове суб-дерево кожний раз, коли ми вирішуємо пійти наліво або направо, і кінець кінцем функція вставки повертає повністю нове дерево, бо насправді Haskell не має концепції вказівника, тільки значення. Таким чином, тип для нашої функції вставки буде щось <code>a -&gt; Tree a - &gt; Tree a</code>. Вона приймає елемент та дерево, та повертає нове дерево, що має в собі цей елемент. Це може виглядати як неефективне, але лінивість потурбується про цю проблему.</p></div>
<div class="paragraph"><p>Так, ось дві функції. Одна функція допоміжна, для створення синглтона дерева (вузол тільки з одним елементом), та функція для вставляння елементу в дерево.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Функція <code>singleton</code> є просто скороченням для створення вузла, що містить дещо, та потім ще два порожні суб-дерева. В функції вставляння ми спочатку маємо граничну умову в якості шаблона. Якщо ми досягли порожнього суб-дерева, що означає що ми там де треба, і замість порожнього дерева ми покладаємо синглтон дерево з нашим елементом. Якщо ми не вставляємо в порожньє дерево, тоді ми маємо перевірити декілька речей. Спочатку, якщо елемент, що ми вставляємо, дорівнює кореневому елементу, просто повертаємо дерево, що є тим самим. Якщо значення меньше, повертаємо дерево, що має той самий корінь і значення, те саме праве суб-дерево, але замість лівого суб-дерева покладаємо дерево з вставленим нашим елементом. Те саме (але навпаки) відбувається, коли значення більше, ніж кореневий елемент.</p></div>
<div class="paragraph"><p>Далі ми збираємось створити функцію, що перевіряє, чи деякий елемент знаходиться в нашому дереві. Спочатку давайте визначимо граничну умову. Якщо ми шукаємо елемент в порожньому дереві, його там напевне не буде. Гаразд. Зауважте, наскільки це те саме, що і гранична умова при пошуку елементів в списку. Якщо ми шукаємо елемент в порожньому списку, його там нема. В любому разі, якщо ми не шукаємо елемент в порожньому дереві, тоді ми перевіряємо деякі речі. Якщо елемент в кореневому вузлі є те, що ми шукаємо, чудово! Якщо ні, що тоді? Гаразд, ми можемо отримати вигоду від знання, що всі елементи меньші, ніж в кореневому вузлі. Так що якщо ми шукаємо меньший елемент, ніж кореневий, перевіряємо, чи може він знаходиться в лівому суб-дереві. Якщо значення більше, шукаємо його в правому суб-дереві.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Все що нам знадобилось, це записати попередній параграф в коді. Давайте розважимось з нашими деревами! Замість вручну будувати дерево (хоча ми можемо), ми використаємо згортку для побудови дерева зі списка. Пам'ятайте, що майже все, що проходить по списку одне по одному, та потім повертає деякий різновид значення, може бути реалізовано як згортка! Ми збираємось почати з порожнього дерева, та потім проходити список зправа, і просто включати елемент за елементом в наше акумулююче дерево.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>В цьому <code>foldr</code> функція <code>treeInsert</code> була функцією згортки (вона приймає дерево і елемент списку, і продукує нове дерево), і <code>EmptyTree</code> було початковим аккумулятором. <code>nums</code>, звичайно, було списком, по якому ми робили згортку.</p></div>
<div class="paragraph"><p>Потім ми друкуємо наше дерево на консолі, це не дуже читається, але якщо ми спробуємо, ми можемо відтворити нашу структуру. Ми бачимо, що кореневий вузол є <code>5</code>, та потім має два суб-дерева, один з яких має кореневий вузол <code>3</code>, а інший <code>7</code>, тощо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Перевірка на членство також робить гарно. Круто.</p></div>
<div class="paragraph"><p>Так що, як ви можете бачити, алгебраїчні структури даних насправді крута і потужна конецепція в Haskell. Ми можемо використовувати їх для створення будь-чого, від логічних значень та переліку днів тижня до двійникових дерев пошуку і більше!</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/trafficlight.png" alt="images/trafficlight.png" />
</span>
Досі ми вивчили щодо стандартних типокласів Haskell, і ми побачили, які класи належать до них. Ми також навчились, як автоматично створювати примірники наших класів для стандартних типокласів, щоб Haskell виводив примірники для нас. В цьому розділі ми збираємось вивчити, як створювати свої власні типокласи, та як робити їх типи примірники руками.</p></div>
<div class="paragraph"><p>Швидке нагадування про типокласи: типокласи як інтерфейси. Типоклас визначає деяку поведінку (як порівняння на рівність, порівняння на впорядкованість, перелік), і потім типи, що можуть поводитись в цей спосіб, складають примірники цього типокласу. Поведінка типокласу досягається через визначення функцій, або тільки декларацій типів, які ми реалізуємо. Так що коли ми кажемо, що тип є примірником типокласу, це означає, що ми можемо використовувати функції, що типоклас визначає за допомогою цього типу.</p></div>
<div class="paragraph"><p>Типокласи не мають нічого спільного з класами в мовах як Java або Python. Це бентежить багатьох людей, так що я бажаю, щоб ви забули все, що ви знаєте про класи в імперативних мовах, прямо зараз.</p></div>
<div class="paragraph"><p>Наприклад типоклас <code>Eq</code> є для речей, що можуть бути рівними. Він визначає функції <code>==</code> та <code>/=</code>. Якщо ми маємо тип, (скажімо, <code>Car</code>), і порівняння двох машин функцією <code>==</code> має сенс, тоді <code>Car</code> буде примірником <code>Eq</code>.</p></div>
<div class="paragraph"><p>Ось як клас <code>Eq</code> визначений в стандартному <code>prelude</code>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ой, ой, ой! Якійсь новий дивний синтаксис і ключові слова! Не турбуйтесь, все з'ясується за секунду. Для початку, коли ми пишемо <code>class Eq a where</code>, це означає, що ми визначаємо новий типоклас, і він має назву <code>Eq</code>. <code>a</code> є змінною типа, і це означає, що вона буде відігравати роль типа, що скоро буде створювати примірник <code>Eq</code>. Вона не має називатись <code>a</code>, вона навіть не має складатись з однієї літери, вона лише повинна бути словом в нижньому реєстрі. Потім ми визначаємо декілька функцій. Не є обов'язковим самому реалізувати тіла функцій, ми тільки маємо вказати декларації типів для функцій.</p></div>
<div class="paragraph"><p>Деякі люди можуть зрозуміти це краще, якщо ми запишемо <code>class Eq equatable where</code> і потім вкажемо декларації типів, як <code>(==) ::equatable -&gt; equatable -&gt; Bool</code>.</p></div>
<div class="paragraph"><p>В жодному разі ми реалізували тіла функції для функцій, що визначає <code>Eq</code>, тільки ми визначили їх в термінах взаємної рекурсії. Ми кажемо, що два примірника <code>Eq</code> рівні, якщо вони не різні, і вони різні, якщо вони не рівні. Насправді ми не мали цього робити, але ми зробили і ми побачимо, як це скоро нам допоможе.</p></div>
<div class="paragraph"><p>Якщо ми сказали <code>class Eq a where</code>, та потім визначили декларацію типу в класі, як <code>(==) ::a -&gt; -a -&gt; Bool</code>, тоді коли ми після цього перевіряємо тип цієї функції, вона буде мати тип <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>.</p></div>
<div class="paragraph"><p>Так,  коли ми одного разу створили клас, що ми можемо робити з ним? Гаразд, насправді не багато. Але як тільки ми починаємо створювати примірники типів цього класу, ми починаємо отримувати деяку милу функціональність. Так що перевірте цей тип:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Він визначає стан світлофора. Зауважте, як ми не виводили жодних примірників класу для нього. Це тому, що ми збираємось написати деякі примірники вручну, навіть якщо ми можемо вивести їх для типів як <code>Eq</code> та <code>Show</code>. Ось як ми робимо його примірником <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ми зробили це, використовуючи ключове слово <code>instance</code>. Так що клас для визначення нових типокласів, та примірник для перетворення наших класів на примірники типокласів. Коли ми визначаємо <code>Eq</code>, ми пишемо <code>class Eq a where</code>, і ми сказали, що <code>a</code> грає роль того самого типу, примірник якого ми пізніше створюємо. Ми можемо бачити це ясно тут, бо коли ми створюємо примірник, ми пишемо <code>instance Eq TrafficLight where</code>. Ми заміняємо <code>a</code> на справжній тип.</p></div>
<div class="paragraph"><p>Через те, що <code>==</code> було визначено в термінах <code>/=</code>, і навпаки, в декларації класа, нам треба тільки переписати один з них в декларації примірника. Це називається мінімально повним визначенням для типокласу — мінімум функцій, що нам треба реалізувати, так що наш тип зможе поводитись так, як проголошує клас. Щоб задовільнити мінімальному повному визначенню для <code>Eq</code>, ми маємо переписати одне, або <code>==</code> або <code>/=</code>. Якщо <code>Eq</code> було визначено просто як:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>ми б мали реалізовувати обоє ці функції, коли робимо тип примірником класу, оскільки Haskell не має гадки, що ці дві функції пов'язані. Мінімальне повне визначення буде обоє, <code>==</code> та <code>/=</code>.</p></div>
<div class="paragraph"><p>Ви можете бачити, що ми реалізували <code>==</code> просто через порівняння шаблону. Оскільки існує значно більше випадків, коли два світла не рівні, ми вказали ті що рівні, і потім просто зробили шаблон спіймати-всіх, що каже, що якщо це не жодна з попередніх комбінацій, тоді світло не те саме.</p></div>
<div class="paragraph"><p>Давайте також вручну зробимо його примірником <code>Show</code>. Щоб задовільнити мінімальному повному визначенню для <code>Show</code>, ми тільки маємо реалізувати його функцію <code>show</code>, що приймає значення, та перетворює його на рядок.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І знову, ми використали порівняння шаблонів для досягнення наших цілей. Давайте побачимо, як це робить в дії:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Мило. Ми могли просто вивести <code>Eq</code>, і це мало б такий самий ефект (але ми не зробили це для цілей навчання). Однак вивід <code>Show</code> був би прямо трансльований від конструкторів на рядки. Але якщо ви бажаєте, щоб світло виглядало як "Red light", тоді нам треба зробити декларацію примірника вручну.</p></div>
<div class="paragraph"><p>Ви також можете створити типокласи, що є субкласами інших типокласів. Декларація класу для <code>Num</code> трохи задовга, але ось перша частина:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Як ми вказували до цього, існує багато місць, де ми можемо впихнути обмеження класу. Так що це як написати <code>class Num a where</code>, тільки ми стверджуємо, що наш тип має бути примірником <code>Eq</code>. В основному ми кажемо, що нам треба зробити тип примірником <code>Eq</code>, перед тим, як ми зможемо зробити його примірником <code>Num</code>. Перед тим, як деякий тип може розглядатись як число, має сенс визначитись, чи значення цього типу можуть бути рівними, чи ні. Це і все, що тут відносно субкласів: це просто обмеження на декларації класу! Коли визначаємо тіла функцій в декларації класу, або коли визначаємо їх в деклараціях примірника, ми можемо вважати, що <code>a</code> є частиною <code>Eq</code>, так що ми можемо використовувати <code>==</code> на значеннях цього типу.</p></div>
<div class="paragraph"><p>Але як <code>Maybe</code> або типи списків стають примірниками типокласів? Що робить <code>Maybe</code> іншим від, скажімо, <code>TrafficLight</code>, це те, <code>Maybe</code> сам по собі не є конкретним типом, це конструктор типу, що приймає один параметр типу (як <code>Char</code> або будь-що інше) для продукування конкретного типу (як <code>Maybe Char</code>). Давайте поглянемо на типоклас <code>Eq</code> знову:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>З декларації типу ми бачимо, що <code>a</code> використовується як конкретний тип, бо всі типи в функціях мають бути конкретними (пам'ятаєте, ви не можете мати функцію типу <code>a -&gt; Maybe</code>, але ви можете мати функцію <code>a -&gt; Maybe a</code> або <code>Maybe Int -&gt; Maybe String</code>). Ось чому ми не можемо робити щось таке</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Бо, як ми бачили, <code>a</code> має бути конкретним типом, але <code>Maybe</code> не є конкретним типом. Це конструктор типу, що бере один параметр, і потім продукує конкретний тип. Також буде обтяжливо написати <code>instance Eq (Maybe Int) where</code>, instance Eq (Maybe Char) where, тощо. для кожного існуючого класу. Так що ми можемо записати це таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Це як сказати, що ми бажаємо зробити всі типи в формі <code>Maybe</code> дещо примірниками <code>Eq</code>. Ми насправді можемо записати <code>(Maybe something)</code>, але ми зазвичай обираємо одну літеру, щоб бути в стилі Haskell. Тут <code>(Maybe m)</code> грає роль <code>a</code> в <code>class Eq a where</code>. Хоча <code>Maybe</code> і не конкретний тип, <code>Maybe m</code> вже так. Задаючи параметр типу (<code>m</code>, що в нижньому реєстрі), ми кажемо, що ми бажаємо, щоб всі типи, що мають форму <code>Maybe m</code>, де <code>m</code> є довільний тип, були примірниками <code>Eq</code>.</p></div>
<div class="paragraph"><p>Однак з цім є одна проблема. Чи ви помітили її? Ми використовуємо  <code>==</code> на вмісті <code>Maybe</code>, але в нас немає гарантій, що вміст <code>Maybe</code> може бути використаний з <code>Eq</code>! Ось чому ми маємо модифікувати нашу декларацію примірника таким чином:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Нам знадобилось додати обмеження класу! З цією декларацією примірника ми кажемо: ми бажаємо, щоб всі типи в формі <code>Maybe m</code> були частиною типокласу <code>Eq</code>, але тільки ті типи, де <code>m</code> (тобто те, що міститься в <code>Maybe</code>) також є частиною <code>Eq</code>. Це насправді те, як Haskell буде виводити примірник, також.</p></div>
<div class="paragraph"><p>В більшості випадків обмеження класу в деклараціях класу використовуються щоб зробити типоклас субкласом іншого типокласу, та обмеження класу в деклараціях примірника використовуються для вираження вимог щодо вміста деякого типу. Наприклад, тут ми вимагаємо, щоб вміст <code>Maybe</code> також був частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Коли створюєте примірники, якщо ви бачите, що тип використовується як конкретний тип в деклараціях типу (як <code>a</code> в <code>a -&gt; a -&gt; Bool</code>), ви маєте надати параметри типу, та додати дужки, так щоб у вас утворився конкретний тип.</p></div>
<div class="paragraph"><p>Прийміть до уваги, що тип, який ви намагаєтесь зробити примірником,буде заміщати параметр в декларації класу. <code>a</code> з <code>class Eq a where</code> буде замінений на реальний тип, коли ви створюватимете примірник, так що спробуйте подумки покласти ваш тип в декларації типу функцій, також. <code>(==) ::Maybe -&gt; Maybe -&gt; Bool</code> не має багато сенсу, але <code>(==) ::(Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool</code> так. Але це тільки ще одне, про що треба подумати, бо <code>==</code> буде завжди мати тип <code>(==) ::(Eq a) =&gt; a -&gt; a -&gt; Bool</code>, не важливо, які примірники ми створюємо.</p></div>
<div class="paragraph"><p>О, ще одна річ, перевірте це! Якщо ви бажаєте побачити, які примірники є в типокласа, просто зробіть <code>:info YourTypeClass</code> в GHCI. Так що набравши <code>:info Num</code> покаже вам, які функції визначає типоклас, і це також видасть вам список типів в типокласі. <code>:info</code> робить для типів, і також для конструкторів. Якщо ви робите <code>:info Maybe</code>, воно покаже вам всі типокласи, для яких <code>Maybe</code> є примірником. Також <code>:info</code> може показати декларацію типу для функції. Я думаю це досить круто.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/yesno.png" alt="images/yesno.png" />
</span>
В JavaScript та деяких інших слабо типізованих мовах ви можете покласти майже будь-що в вираз <code>if</code>. Наприклад, ви можете зробити все з наступного: <code>if (0) alert("YEAH!") else alert("NO!")</code>, <code>if ("") alert ("YEAH!") else alert("NO!")</code>, <code>if (false) alert("YEAH") else alert("NO!)</code>, etc., і все це буде викликати <code>alert NO!</code>. Якщо ви зробите <code>if ("WHAT") alert ("YEAH") else alert("NO!")</code>, буде виконане <code>alert YEAH!</code>, оскільки JavaScript розглядає непорожні рядки як різновид правдо-подібних значень.</p></div>
<div class="paragraph"><p>Навіть якщо пряме використання <code>Bool</code> для логічної семантики робить краще в Haskell, давайте спробуємо і реалізуємо цю JavaScript подібну поведінку все одно. Для розваги! Давайте почнемо з декларації класу.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить просто. Типоклас <code>YesNo</code> визначає одну функцію. Ця функція бере одне значення типу <code>a</code>, що може розгядатись як емність деякої концепції правдивості, і каже нам напевне, чи це правда, чи ні. Зауважте, що з того, в який спосіб ми використовуємо <code>a</code> в функції, це має бути конкретним типом.</p></div>
<div class="paragraph"><p>Далі давайте визначимо деякі примірники. Для чисел ми вважаємо, що (подібно до JavaScript) любе число, що не є <code>0</code>, є правдивим, та <code>0</code> є лживим.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Порожні списки (і по розширенню рядки) є ні-значеннями, тоді як непорожні списки є так-значеннями.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зауважте, як ми просто поклали в параметр типу <code>a</code>, щоб зробити список конкретним типом, навіть якщо ми не робимо жодних припущень щодо типу, що міститься в списку. Що ще, хм &#8230; Я знаю, <code>Bool</code> сам по собі містить правдивість та неправдивість, і це досить очевидно щодо цього.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Так, що за <code>id</code>? Це тільки функція стандартної бібліотеки, що приймає параметр, та повертає ту саму річ, що саме те, що ми бажаємо тут написати.</p></div>
<div class="paragraph"><p>Давайте також зробимо примірником <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Нам не треба обмеження типу, оскільки ми не маємо припущень щодо вмісту <code>Maybe</code>. Ми тільки що сказали, що ми правдиві коли маємо <code>Just</code> значення, та ні коли <code>Nothing</code>. Ми все ще маємо писати <code>(Maybe a)</code> замість просто <code>Maybe</code>, оскільки, якщо ви про це подумаєте, функція <code>Maybe -&gt; Bool</code> не може існувати (оскільки <code>Maybe</code> не є конкретним типом), тоді як <code>Maybe a -&gt; Bool</code> добре і елегантно. Це вже досить круто, бо зараз любий тип в формі <code>Maybe</code> дещо є частиною <code>YesNo</code>, і це не має значення, що є це дещо.</p></div>
<div class="paragraph"><p>До цього ми визначили тип <code>Tree a</code>, що представляв дерево двійникового пошуку. Ми можемо сказати, що порожнє дерево фальшиве, і непорожнє дерево є правдивим.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Чи може світло світлофора бути значенням так або ні? Звичайно. Якщо світло червоне, ви зупиняєтесь. Якщо світло зелене, ви йдете. Якщо воно жовте? Ну так, зазвичай я біжу на жовтий, бо я живу на адреналіні.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Круто, тепер, коли ми маємо декілька примірників, давайте гратись!</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Все вірно, це робить! Давайте створимо функцію, що копіює твердження <code>if</code>, але робить зі значеннями <code>YesNo</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досить прямолінійно. Вона приймає значення <code>yes-no</code> та дві речі. Якщо значення скоріше <code>yes</code>, повертається перша з двох речей, інакше повертається друга річ.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Досі ми зустрічали багато типокласів в стандартній бібліотеці. Ми грали з <code>Ord</code>, що призначений для речей, що можуть бути впорядковані. Ми намотали на вус щодо <code>Eq</code>, що є для речей, які можуть бути рівними. Ми бачили <code>Show</code>, що представляє інтерфейс для типів, чиї значення можуть бути відображені як рядки. Наш гарний друг <code>Read</code> був поряд, коли нам треба конвертувати рядок на значення деякого типу. І тепер ми збираємось подивитись на типоклас <code>Functor</code>, що в основному для речей, по яких можна робити відображення. Можливо, ви зараз думаєте про списки, оскільки відображення по списках є домінантною ідіомою в Haskell. І ви праві, тип списку є частиною типокласу <code>Functor</code>.</p></div>
<div class="paragraph"><p>Що може бути кращим способом отримати знання про типоклас <code>Functor</code>, ніж побачити його реалізацію? Давайте поглянемо.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/functor.png" alt="images/functor.png" />
</span>
Гаразд, ми бачимо що це визначає функцію, <code>fmap</code>, і не провадимо жодної реалізації по замовчанню для неї. Тип <code>fmap</code> є цікавим. Досі в визначеннях типокласів змінна типу, що грала роль типу в типокласі, була конкретного типу, як <code>a</code> в <code>(==) ::(Eq a) =&gt; a -&gt; a -&gt; Bool</code>. Але тепер <code>f</code> не є конкретним типом (тип, що може містити <code>a</code>, як <code>Int</code>, <code>Bool</code> або <code>Maybe String</code>), але це конструктор типу, що приймає один параметр типу. Швидке нагадування: <code>Maybe Int</code> є конкретним типом, але <code>Maybe</code> є конструктором типу, що приймає один тип в якості параметра. В жодному разі, ми бачимо що <code>fmap</code> бере функцію з одного типу до іншого, і функтор, застосований з одного типу та повертає функтор, застосований з іншим типом.</p></div>
<div class="paragraph"><p>Не турбуйтесь, якщо це виглядає трохи збентежливо. Все швидко викриється, коли ми побачимо декілька прикладів. Хм, ця декларація типу <code>fmap</code> нагадує мені щось. Якщо ви не знаєте, якого типу є сигнатура <code>map</code>, вона така: <code>map ::(a -&gt; b) -&gt; [a] -&gt; [b]</code>.</p></div>
<div class="paragraph"><p>А, цікаво! Це бере функцію від одного типу до іншого, і список одного типу і повертає список іншого типу. Мої друзі, ми маємо з вами функтор! Фактично, <code>map</code> є просто <code>fmap</code>, що робить на списках. Ось як список є примірником типокласу <code>Functor</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>І це все! Зауважте, що ми не писали <code>instance Functor [a] where</code>, бо з <code>fmap ::(a -&gt; b) -&gt; f a -&gt; f b</code>, ми бачимо, що <code>f</code> має бути конструктором типів, що приймає один тип. <code>[a]</code> є вже конкретним типом (списком з деяким списком всередині), тоді як <code>[]</code> є конструтором типів, що приймає один тип, і може продукувати типи як  <code>[Int]</code>, <code>[String]</code> або навіть <code>[[String]]</code>.</p></div>
<div class="paragraph"><p>Оскільки для списків <code>fmap</code> є просто <code>map</code>, ми отримуємо ті самі результати, коли використовуємо його на списках.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Що трапиться, коли ми зробимо <code>map</code> або <code>fmap</code> на порожньому списку? Гаразд, звичайно ми отримаємо порожній список. Вони просто перетворюють порожній список типу <code>[a]</code> в порожній список типу <code>[b]</code>.</p></div>
<div class="paragraph"><p>Типи, що можуть діяти як бокси, можуть бути функторами. Ви можете думати про список як про бокс, що має безліч малих компонент, і всі вони можуть бути порожні, один з них може бути повним а інші порожні, або декілька можуть бути повні. Так, що інше має властивості бути як бокс? Для початку це <code>Maybe</code>. В деякому смислі це як бокс, що може або нічого не містити, і в цьому випадку це значення <code>Nothing</code>, або він може містити один елемент, як <code>"HAHA"</code>, в якому випадку він має значення <code>Just "HAHA"</code>. Ось як <code>Maybe</code> є функтором.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Знову, зауважте, як ми пишемо <code>instance Functor Maybe where</code> замість <code>instance Functor (Maybe m) where</code>, як ми робили, коли мали справи з <code>Maybe</code> та <code>YesNo</code>. <code>Functor</code> бажає конструктора типу, що приймає один тип, а не конкретний тип. Якщо ви подумки заміните <code>f</code> на <code>Maybe</code>, <code>fmap</code> діє як <code>(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code> для цього типу предикату, що виглядає OK. Але якщо ви заміните <code>f</code> на <code>(Maybe m)</code>, тоді воно діятиме як <code>(a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b</code>, що не має жодного дідькова сенсу, оскільки <code>Maybe</code> бере тільки один параметр типу.</p></div>
<div class="paragraph"><p>В жодному разі, реалізція <code>fmap</code> досить проста. Якщо це порожнє значення <code>Nothing</code>, тоді просто повертаємо <code>Nothing</code>. Якщо ми відображуємо порожній бокс, ми отримуємо порожній бокс. Це має сенс. Так само, як ми робимо <code>map</code> по порожньому списку, ми знову отримуємо порожній список. Якщо це не порожнє значення, але скоріше поодиноке значення, запаковане в <code>Just</code>, тоді ми застосовуємо функцію на вмісті цього <code>Just</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Інша річ, по якій можна робити відображення та створити примірник <code>Functor</code> є наш тип <code>Tree</code>. Це можна промислити як свого роду бокс (містить декілька або жодних значень), і конструктор типу <code>Tree</code> бере рівно один параметр типу. Якщо ви подивитесь на <code>fmap</code>, так якби це було функцією, створеною тільки для <code>Tree</code>, його сигнатура типу виглядала б як <code>(a -&gt; b) -&gt; Tree a -&gt; Tree b</code>. Ми збираємось використати рекурсію для цього. Відображення по порожньому дереву буде продукувати порожнє дерево. Відображення по непорожньому дереву буде дерево, що складається з нашої функції, застосованої до кореневого значення, та його ліве та праве субдерево будуть попередніми субдеревами, з відображенням нашої функції по них.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Мило! Тепер як щодо <code>Either a b</code>? Чи може це бути перетворене на функтор? Типоклас <code>Functor</code> бажає конструктор типу, що бере тільки один параметр, але <code>Either</code> бере два. Хммм! Я знаю, ми будемо частково застосовувати <code>Either</code>, подаючи йому один параметр, так що він матиме лише один вільний параметр. Ось як <code>Either</code> є функтором в стандартних бібліотеках:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гаразд-гаразд, що ми тут зробили? Ви можете бачити, як ми зробили примірником <code>Either a</code>, замість просто <code>Either</code>. Це тому, що <code>Either a</code> є конструктором типу, що бере один параметр, тоді як <code>Either</code> бере два. Якщо б <code>fmap</code> була особливою для <code>Either a</code>, тип сигнатури був би <code>(b -&gt; c) -&gt; Either a b -&gt; Either a c</code>, оскільки це те саме, що і <code>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</code>. В реалізації ми відображуємо ми робимо відображення в випадку конструктора значення <code>Right</code>, але не робимо в випадку <code>Left</code>. Чому це так? Гаразд, коли ми подивимось назад на те, як реалізований тип <code>Either a b</code>, це буде щось таке:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Гаразд, якщо ви бажаєте відобразити одну функцію по обох з них, <code>a</code> та <code>b</code> мали б бути того самого типу. Я маю на увазі, якщо ми спробуємо відобразити функцію, що бере рядок та повертає рядок, та <code>b</code> був би рядком, але <code>a</code> був би числом, це не мало б працювати. Також від спостереження, що якщо тип <code>fmap</code> був би такий, що робив би тільки на значеннях <code>Either</code>, ми побачимо що перший параметр має залишатись тим самим, коли другий може змінюватись, і перший параметр актуалізований конструктором значення <code>Left</code>.</p></div>
<div class="paragraph"><p>Це також гарно проходить з нашою аналогією боксу, якщо ми подумаємо про частину <code>Left</code> як про різновид порожнього боксу з повідомленням помилки, що лише сповіщає нам, чому тут порожнє.</p></div>
<div class="paragraph"><p>Мапи від <code>Data.Map</code> також може бути зроблене функтором, бо вони містять значення (або ні!). В випадку <code>Map k v</code> <code>fmap</code> буде функцією відображення <code>v -&gt; v'</code> по мапі типу <code>Map k v</code>, та повертає мапу типу <code>Map k v'</code>.</p></div>
<div class="paragraph"><p>Зауважте, що <code>'</code> не має особливого значення в типах, так само, як це не має особливого значення при іменуванні значень. Це використовується для позначення речей, що є подібними, але досить зміненими.</p></div>
<div class="paragraph"><p>Спробуйте самостійно уявити, як <code>Map k</code> перетворюється на примірник <code>Functor</code>!</p></div>
<div class="paragraph"><p>З типокласом <code>Functor</code> ми побачили, як типокласи можуть представляти досить круті концепції вищих порядків. Ми також мали деяку додаткову практику з частково застосованими типами, та створенням примірників. В одному з наступних глав ми також поглянемо на деякі закони, що стосуються функторів.</p></div>
<div class="paragraph"><p>Тільки ще одна річ! Функтори повинні підкорюватись деяким законам, так що вони можуть мати деякі властивості, на які ми можемо розраховувати, і не сильно цім перейматись. Якщо ми використовуємо <code>fmap (+1)</code> на списку <code>[1,2,3,4]</code>, ми очікуємо що результат буде <code>[2,3,4,5]</code>, а не навпаки, <code>[5,4,3,2]</code>. Якщо ми використовуємо <code>fmap (\a -&gt; a)</code> (функція ідентичності, що просто повертає параметр) для деякого списку, ми очікуємо отримати назад той самий список як результат. Наприклад, якщо ми отримаємо помилковий примірник функтора для типу <code>Tree</code>, використання <code>fmap</code> до дерева, у якого ліве субдерево вузла має елементи, що меньші ніж вузол, і праве субдерево має елементи, що більші ніж вузол, зможе продукувати дерево, де це не дотримується. Ми пройдемо по законах функторів більш детально в одній з наступних глав.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/typefoo.png" alt="images/typefoo.png" />
</span>
Конструктори типів беруть інші типи як параметри, щоб при нагоді утворити конкретні типи. Це дещо нагадує мені функції, що приймають значення як параметри, щоб зпродукувати значення. Ми бачили, що конструктори типів можуть бути застосовані частково (<code>Either String</code> є типом, що бере один тип і продукує конкретний тип, як <code>Either String Int</code>), так само як це може функція. Таким чином все це дуже цікаво. В цьому розділі ми поглянемо на формальне визначення, як типи застосовуються до конструкторів типів, так само як ми дивились на формальне визначення, як значення застосовуються до функцій, через використання декларацій типу. Насправді ви не маєте читати цей розділ, щоб продовжити наш магічний квест Haskell, і якщо ви його не зрозумієте не турбуйтесь про це. Однак якщо ви зрозумієте це, ви отримаєте дуже глибоке розуміння системи типів.</p></div>
<div class="paragraph"><p>Так ось, значення як <code>3</code>, <code>"YEAH"</code> або <code>takeWhile</code> (функції також є значеннями, бо ми можемо передавати їх і таке інше), кожний має свій власний тип. Типи є маленькими мітками, що носять на собі значення, так що ми можемо розмірковувати щодо значень. Але типи мають власні маленькі мітки, що називаються різновидами. Різновид є більш-менш типом типу. Це може виглядати трохи збоченим і збентежливим, але насправді це дійсно крута концепція.</p></div>
<div class="paragraph"><p>Що таке різновиди і для чого вони гарні? Гаразд, давайте дослідимо різновиди типу з використанням команди <code>:k</code> в GHCI.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Зірочка? Як мило. Що це може значити? <code>*</code> означає що тип є конкретним. Конкретний тип є типом, що не приймає жодних параметрів типу, та значення можуть мати тільки типи, що є конкретними типами. Якщо я б читав` * `вголос (досі я не робив цього), я б сказав <em>зірка</em> або просто <em>тип</em>.</p></div>
<div class="paragraph"><p>Гаразд, давайте подивимось, який різновид у <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Конструктор типу <code>Maybe</code> бере один конкретний тип (такий як <code>Int</code>), та потім повертає конкретний тип, як <code>Maybe Int</code>. І це те, що каже нам цей різновид. Так само, як <code>Int -&gt; Int</code> означає, що функція бере <code>Int</code> і повертає <code>Int</code>, <code>* -&gt; *</code> означає, що конструктор типу бере один конкретний тип, та повертає конкретний тип. Давайте застосуємо параметр типу до <code>Maybe</code>, та побачити, який різновид має цей тип.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Саме так як я очікував! Ми застосували параметр типу до <code>Maybe</code>, та отримали назад конкретний тип (ось що означає <code>* -&gt; *</code>. Це можна порівняти (хоча це не те саме, типи і різновиди є різними речами) з тим, як ми робимо <code>:t isUpper</code> та <code>:t isUpper 'A'</code>. <code>isUpper</code> має тип <code>Char -&gt; Bool</code>, та <code>isUpper 'A'</code> має тип <code>Bool</code>, оскільки його значення в основному є <code>True</code>. Однак обоє ці типи мають різновид` * `.</p></div>
<div class="paragraph"><p>Ми використовували <code>:k</code> на типі для отримання його різновиду, так само, як ми можемо використовувати <code>:t</code> на значенні для отримання його типу. Як ми казали, типи є мітками на значеннях, і різновиди є мітками на типах, і є параллелі між ціма двома.</p></div>
<div class="paragraph"><p>Давайте поглянемо на інші різновиди.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ага, це каже нам, що <code>Either</code> бере два конкретні типи як параметри типів для продукування конкретного типу. Це також дещо виглядає як декларація типу, що приймає два значення, та повертає дещо. Конструктори типів каровані (так само як функції), так що ми можемо застосовувати їх частково.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Коли ми бажали зробити <code>Either</code> частиною типокласу <code>Functor</code>, ми мали частково застосувати його, оскільки <code>Functor</code> бажає типи, що беруть тільки один параметр, тоді як <code>Either</code> приймає два. Іншими словами <code>Functor</code> бажає типи <code>* -&gt; *</code>, так що ми мали частково застосувати <code>Either</code>, щоб отримати тип різновиду` * &#8594; *` замість оригінального різновиду ` * &#8594; * &#8594; *<code>. Якщо ми подивимось знову на визначення `Functor</code></p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>ми побачимо, що змінна типу <code>f</code> використовується як тип, що бере один конкретний тип для продукування конкретного типу. Ми знаємо, що він має продукувати конкретний тип, оскільки він використовується як тип як тип значення в функції. І з цього ми можемо вивести, що типи, що бажають товарішувати з <code>Functor</code> повинні мати різновид <code>* -&gt; *</code>.</p></div>
<div class="paragraph"><p>Тепер давайте проробимо деяке тип-фу. Поглянемо на цей типоклас, що я маю намір створити прямо зараз:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Чоловіче, це виглядає збочено. Як ми можемо створити тип, що може бути примірником цього дивного типокласу? Гаразд, давайте подивимось якого різновиду має це буде. Оскільки <code>j a</code> використовується як тип значення, що приймає функція <code>tofu</code> як параметр, <code>j a</code> повинно мати різновид <code>* `. Ми очікуємо `* ` для `a</code>, так що ми можемо вивести, що <code>j</code> повинне мати різновид <code>* -&gt; * `. Ми бачимо, що `t</code> повинно продукувати конкретне значення також, і що воно бере два типи. І занючи що <code>a</code> має різновид <code>* ` та `j</code> має різновид <code>* -&gt; * `, ми виводимо що `t</code> повинно мати різновид <code>* -&gt; (* -&gt; *) -&gt; *</code>. Так що він приймає конкретний тип (<code>a</code>), деякий конструктор типів, що приймає один конкретний тип (<code>j</code>) і продукує новий тип. Вау.</p></div>
<div class="paragraph"><p>Гаразд, давайте створимо тип з різновидом <code>* -&gt; (* -&gt; *) -&gt; *</code>. Ось один спосіб зробити це.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
data Frank a b  = Frank {frankField 
</dt>
<dd>
<p>
b a} deriving (Show)
How do we know this type has a kind of * &#8594; (* &#8594; <strong>) - &gt; *? Well, fields in ADTs are made to hold values, so they must be of kind *, obviously. We assume * for a, which means that b takes one type parameter and so its kind is * &#8594; *. Now we know the kinds of both a and b and because they&#8217;re parameters for Frank, we see that Frank has a kind of * &#8594; (</strong> &#8594; <strong>) &#8594; * The first * represents a and the (</strong> &#8594; *) represents b. Let&#8217;s make some Frank values and check out their types.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Hmm. Because frankField has a type of form a b, its values must have types that are of a similar form as well. So they can be Just "HAHA", which has a type of Maybe [Char] or it can have a value of [<em>Y</em>,<em>E</em>,<em>S</em>], which has a type of [Char] (if we used our own list type for this, it would have a type of List Char). And we see that the types of the Frank values correspond with the kind for Frank. [Char] has a kind of * and Maybe has a kind of * &#8594; *. Because in order to have a value, it has to be a concrete type and thus has to be fully applied, every value of Frank blah blaah has a kind of *.</p></div>
<div class="paragraph"><p>Making Frank an instance of Tofu is pretty simple. We see that tofu takes a j a (so an example type of that form would be Maybe Int) and returns a t a j. So if we replace Frank with j, the result type would be Frank Int Maybe.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Not very useful, but we did flex our type muscles. Let&#8217;s do some more type-foo. We have this data type:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>And now we want to make it an instance of Functor. Functor wants types of kind * &#8594; * but Barry doesn&#8217;t look like it has that kind. What is the kind of Barry? Well, we see it takes three type parameters, so it&#8217;s going to be something &#8594; something &#8594; something &#8594; <strong>. It&#8217;s safe to say that p is a concrete type and thus has a kind of *. For k, we assume * and so by extension, t has a kind of * &#8594; *. Now let&#8217;s just replace those kinds with the somethings that we used as placeholders and we see it has a kind of (</strong> &#8594; *) &#8594; * &#8594; * &#8594; *. Let&#8217;s check that with GHCI.</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ah, we were right. How satisfying. Now, to make this type a part of Functor we have to partially apply the first two type parameters so that we&#8217;re left with * &#8594; *. That means that the start of the instance declaration will be: instance Functor (Barry a b) where. If we look at fmap as if it was made specifically for Barry, it would have a type of fmap 
</dt>
<dd>
<p>
(a &#8594; b) &#8594; Barry c d a &#8594; Barry c d b, because we just replace the Functor&#8217;s f with Barry c d. The third type parameter from Barry will have to change and we see that it&#8217;s conviniently in its own field.
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Ось ми де! Ми тільки но відобразили <code>f</code> по першому полю.</p></div>
<div class="paragraph"><p>В цьому розділі ми зробили гарний погляд на те, як роблять параметри типів, і як це дещо формалізовано за допомогою різновидів, так само як ми формалізували параметри функцій за допомогою декларацій типів. Ми побачили, що є цікаві параллелі між функціями та конструкторами типів. Однак вони є повністю відмінними речами. При роботі з реальним Haskell, ви зазвичай не матимете судрувати з різновидами, і робити вивід різновидов вручну, як ми робили це. Зазвичай ви будете просто частково застосовувати ваш власний тип до <code>* -&gt; *</code> або `* `, коли робите його примірником одного зі стандартних типокласів, але гарно знати, як і чому це дійсно робить. Також цікаво побачити, що типи мають свої маленькі типи. Знову, ви насправді не маєте розуміти все що ви тут прочитали, але якщо ви розумієте, як роблять різновиди, є шанси, що ви маєте дуже солідну хватку до системи типів Haskell.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
</div></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-10-06 23:42:57 EEST
</div>
</div>
</body>
</html>
