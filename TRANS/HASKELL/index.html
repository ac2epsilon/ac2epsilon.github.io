<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Miran Lipovača</p></div>
<div class="paragraph"><p><sub>Переклад українською Арсеній Чеботарьов 2019</sub></p></div>
<div class="paragraph"><p>Запрошуємо до Learn You a Haskell for Great Good! Якщо ви читаєте це, є шанси, що ви бажаєте вивчити Haskell. Так, ви опинились в правильному місці, але спершу давайте поговоримо про сам цей туторіал.</p></div>
<div class="paragraph"><p>Я вирішив написати це, бо я хотів покращити моє влане знання Haskell, і оскільки я думав, що можу допомогти новим до Haskell людям вивчати його з моєї перспективи. Існує досить небагато туторіалів по Haskell, що плавають в інтернеті. Коли я починав з Haskell, я не навчався тільки з одного ресурсу. Спосіб, яким я навчався, було читання декількох різних туторіалів та статей, оскільки кожний пояснював дещо в інший спосіб, ніж інший. Проходячи по різним ресурсам я був в змозі скласти разом частини, та все займало своє місце. Так що це спроба додати інший корисний ресурс для вивчення Haskell, так що ви маєте більший шанс знайти те, що вам сподобається.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/bird.png" alt="images/bird.png" />
</span>
Цей туторіал націлений на людей, що мають досвід з імперативними мовами програмування (C, C++, Java, Python …), але досі не програмували на функціональних мовах (Haskell, ML, OCaml …). Хоча  я можу поспорити, що навіть якщо ви не маєте жодного значного програмного досвіду, розумна людина, як ви, буде в змозі відслідковувати хід подій та навчиться Haskell.</p></div>
<div class="paragraph"><p>Канал <code>#haskell</code> в мережі <code>freenode</code> є чудовим місцем запитувати питання, якщо ви почуваєтесь розгубленим. Люди там вкрай милі, терплячі та розуміють початківців.</p></div>
<div class="paragraph"><p>Я не зміг вивчити Haskell приблизно два рази, перед тим як нарешті підхопив його, оскільки все це виглядало дуже збоченим, і я не міг зрозуміти. Але одного разу воно просто "клацнуло", і після продирання через початкові хащі це видалось досі спокійне плавання. Як мені здається я намагаюсь сказати: Haskell чудовий, і якщо ви дійсно зацікавлені в програмуванні, вам слід дійсно вивчити його, навіть якщо спочатку він виглядає збоченим. Вивчення Haskell більш подібне на навчання програмування з самого початку — це весело! Це дозволяє вам мислити інакше, що відносить нас в другий розділ …</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/fx.png" alt="images/fx.png" />
</span>
Haskell є <strong>чисто функціональна мова програмування</strong>. В імперативних мовах ви отримуєте речі зробленими через надання комп'ютеру послідовність завдань, та потів виконуєте їх. При їх виконанні це може змінювати стан. Наприклад, ви встановили змінну в <code>5</code>, потім робили дещо, та потім встановили її в дещо інше. Ви маєте структури керування потоком, щоб виконати деяку дію декілька раз. В чисто функціональному програмуванні ви не кажете комп'ютеру, що робити як таке, але скоріше ви кажете, що має бути. Факторіал числа є добуток всіх чисел від 1 до цього числа, сума списка чисел є перше число, плюс сума інших чисел, і так далі. Ви виражаєте це в формі функцій. Ви також не можете змінну в дещо, і пізніше встановити її в дещо інше. Якщо ви кажете, що <code>a</code> є <code>5</code>, ви не можете пізніше сказати що це щось інше, бо ви сказали що це <code>5</code>. Ви що, якийсь брехун? Так що в повністю функціональних мовах функція не має побічних ефектів. Єдина річ, що може робити функція, це обчислювати дещо і повертати це як результат. Спочатку це виглядає як деяке обмеження, але насправді має дуже милі наслідки: якщо функція викликається два рази з тими самими параметрами, вона гарантовано повертає той самий результат. Це називаеться посилковою прозорістю, і не тільки дозволяє компілятору промислювати поведінку програми, але також дозволяє просто доходити висновку (та навіть доводити), що функція коректна, та потім будувати більш складні функції, через склеювання простих функцій разом.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lazy.png" alt="images/lazy.png" />
</span>
Haskell <strong>лінивий</strong>. Це означає, що якщо спеціально не сказане інше,Haskell не виконуватиме функцій та не обчислюватиме речі, коли його дійсно не змусить це робити, щоб показати вам результат. Це гарно пасує до прозорості посилань, і це дозволяє вам думати про програми як про серії перетворень даних. Це також дозволяє круті речі, такі як безкінечні структури даних. Скажімо, ви маєте незмінний список чисел <code>xs = [1,2,3,4,5,6,7,8]</code>, та функцію <code>doubleMe</code>, що множить кожний елемент на <code>2</code>, та потім повертає новий список. Якщо ми б захотіли помножити весь список на 8 в імперативній мові, та зробити <code>doubleMe(doubleMe(doubleMe(xs)))</code>, це можливо пройшло б по списку один раз, та зробило копію, щоб повернути її. Потім це пройшло б по списку ще два рази, та повернуло результат. В лінивій мові виклик <code>doubleMe</code> на списку без примусу показати вам результат скінчиться тим, що програма скаже вам щось накшталт "Так-так, я зроблю це пізніше!". Але коли ви захочете побачити результат, перший <code>doubleMe</code> каже другому, що він хоче результат, негайно! Другий каже те саме до третього, і третій похопцем повертає подвоєні <code>1</code>, що є <code>2</code>. Другий отримує це і повертає <code>4</code> першому. Перший виклик бачить це і повертає вам <code>8</code>. Так що відбувається тільки один прохід по списку, і тільки тоді, коли вам це дійсно треба. Таким чином, коли ви бажаєте дещо від лінивої мови, ви можете просто взяти початкові дані, і ефективно перетворити та полагодити, так, щоб воно відтворювале те, що ви бажаєте мати в кінці.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/boat.png" alt="images/boat.png" />
</span>
Haskell є <strong>статично типізованим</strong>. Коли ви компілюєте вашу програму, компілятор знає, яка частина коду є числом, яка є рядком і так далі. Це означає, що багато з можливих помилок будуть виловлені під час компіляції. Якщо ви спробуєте додати разом число та рядок, компілятор буде скиглити на вас. Haskell використовую дуже гарну систему типів, що має вивід типів. Це означає, що вам не треба насправді явно помічати кожний кусок коду типом, бо система типів може розумно здогадатись більшість з них. Якщо ви кажете <code>a = 5 + 4</code>, ви не маєте казати Haskell, що <code>a</code> є числом, він сам може про це здогадатись. Вивід типів також дозволяє вашому коду бути більш загальним. Якщо функція, що ви створюєте, приймає два параметри, та додає їх разом, та ви явно не встановили їх тип, функція буде робити на любих двох параметрах, що поводяться як числа.</p></div>
<div class="paragraph"><p>Haskell є <strong>елегантним та стислим</strong>. Оскільки він використовує багато концепцій високого рівня, програми Haskell звичайно коротші, ніж їх імперативні еквіваленти. Та коротші програми простіше підтримувати, ніж довгі, та мати меньшн вад.</p></div>
<div class="paragraph"><p>Haskell був зроблений <strong>дійсно розумними хлопцями</strong> (з науковими ступенями). Робота над Haskell почалась в 1987му році, коли комітет розробників зібрався разом щоб розробити несамовиту мову. В 2003 був опублікований Haskell Report, що визначає стабільну версію мови.</p></div>
<div class="paragraph"><p>Текстовий редактор та компілятор Haskell. Ви, можливо, вже маєте ваш улюблений текстовий редактор встановленим, так що ми не витрачатимемо не це час. Для цілей цього туторіала ми будемо використовувати GHC, найбільш широко уживаний компілятор Haskell. Кращий шлях розпочати - завантажити <em>Haskell Platform</em>, що в основному той самий Haskell в комплекті з батарейками.</p></div>
<div class="paragraph"><p>GHC може прийняти Haskell скрипт (вони звичайно мають розширення <code>.hs</code>), та компілювати його, але він також має інтерактивний режим, що дозволяє вам інтерактивно взаємодіяти зі скриптами. Інтерактивно. Ви можете викликати функції зі скриптів, що ви завантажуєте, і результати відображуються безпосередньо. Для навчання це значно простіше і швидше, ніж компілювати кожного разу щоб зробити зміну, та потім виконувати програму з консольної підказки. Інтерактивний режим викликається запуском <code>ghci</code> в підказці консолі. Якщо ви визначили деякі функції в викликаному файлі, скажімо, <code>myfunctions.hs</code>, ви завантажуєте ці функції через набір <code>:l myfunctions</code>, і потім граєтесь з ними, вважаючи, що <code>myfunctions.hs</code> в тому самому файлі, з якого був запущений <code>ghci</code>. Якщо ви зміните <code>.hs</code> скрипт, просто виконайте <code>:l myfunctions</code> знову, або зробіть <code>:r</code>, що еквівалентно, оскільки це перевантажує поточний скрипт. Звичайна послідовність для мене, коли я граюсь з деякими речами, це створення деяких функцій в <code>.hs</code> файлі, завантаження їх, та забавки з ними, та потім зміна файла <code>.hs</code>, завантаження його знову, і так далі. Це також те, що ми будемо тут з вами робити.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/startingout.png" alt="images/startingout.png" />
</span>
Гаразд, давайте розпочнемо! Якщо ви з тих жахливих людей, що не читають інструкцій до речей, і пропускаєте їх, в жодному разі ви маєте прочитати останній розділ зі вступу, оскільки він пояснює, що вам треба, щоб слідувати цьому туторіалу, і як ми збираємось завантажувати функції. Перша річ, що ми збираємось зробити, це виконати <code>ghc</code> в інтерактивному режимі, та викликати деякі функції, щоб отримати дуже базове відчуття <code>haskell</code>. Відкрийте ваш термінал та наберіть <code>ghci</code>. Ви отримаєте привітання, подібне до наступного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">GHCi</span><span class="p">,</span> <span class="n">version</span> <span class="mf">6.8</span><span class="o">.</span><span class="mi">2</span><span class="kt">:</span> <span class="n">http</span><span class="kt">://</span><span class="n">www</span><span class="o">.</span><span class="n">haskell</span><span class="o">.</span><span class="n">org</span><span class="o">/</span><span class="n">ghc</span><span class="o">/</span>  <span class="kt">:?</span> <span class="n">for</span> <span class="n">help</span>
<span class="kt">Loading</span> <span class="n">package</span> <span class="n">base</span> <span class="o">...</span> <span class="n">linking</span> <span class="o">...</span> <span class="n">done</span><span class="o">.</span>
<span class="kt">Prelude</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вітаємо, ви в GHCI! Тут підказка <code>Prelude&gt;</code>, але оскільки вона може стати довшою коли ви завантажите дещо в сессії, ми збираємось використовувати <code>ghci&gt;</code>. Якщо ви бажаєте мати таку саму підказку, просто наберіть <code>:set prompt "ghci&gt; "</code>.</p></div>
<div class="paragraph"><p>Ось деяка проста арифметика.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">15</span>
<span class="mi">17</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">49</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">4900</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1892</span> <span class="o">-</span> <span class="mi">1472</span>
<span class="mi">420</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">2</span>
<span class="mf">2.5</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить пояснює себе. Ми також можемо використовувати декілька операторів в одному рядку, і вони будуть підкорюватись звичайним правилам преоритетів. Ми можемо використовувати дужки, щоб зробити преоритети явними, або щоб змінити їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">50</span> <span class="o">*</span> <span class="p">(</span><span class="mi">100</span> <span class="o">-</span> <span class="mi">4999</span><span class="p">)</span>
<span class="o">-</span><span class="mi">244950</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить круто, чи не так? Так, я знаю що ні, але повірте мені. Невелика пастка тут - подивитись як змінюється знак чисел. Якщо ви бажаєте мати від'ємне число, завжди краще оточити його в дужки. робити <code>5 * -3</code> змусить GHCI скаржитись на вас, але якщо зробити <code>5 * (-3)</code>, це буде робити добре.</p></div>
<div class="paragraph"><p>Логічна алгебра також досить прямолінійна. Як ви ,вірогідно, знаєте, <code>&amp;&amp;</code> позначає логічне <code>AND</code>, <code>||</code> позначає логічне <code>OR</code>. <code>not</code> обертає <code>True</code> або <code>False</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">False</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">False</span> <span class="o">||</span> <span class="kt">True</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">not</span> <span class="p">(</span><span class="kt">True</span> <span class="o">&amp;&amp;</span> <span class="kt">True</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевірка на рівність робиться так.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">4</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">==</span> <span class="s">&quot;hello&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо зробити  <code>5 + "llama"</code> або <code>5 == True</code>? Гаразд, якщо ми спробуємо перший фрагмент, ми отримаємо велике і жахливе повідомлення про помилку!</p></div>
<div class="listingblock">
<div class="content">
<pre><code>No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama"</code></pre>
</div></div>
<div class="paragraph"><p>Такої! Що тут GHCI каже нам, це те, що <code>"llama"</code> не є числом, і так він не знає, як додати його до <code>5</code>. Навіть якщо це б було не <code>"llama"</code>, а <code>"four"</code> або <code>"4"</code>, Haskell все одно не може дійти висновку, що це число. <code>+</code> очікує, що зправа та зліва від нього числа. Якщо ви спробуєте зробити <code>True == 5</code>, GHCI скаже нам, що типи не співпадають. Хоча <code>+</code> робить тільки на речах, що розглядаються як числа, <code>==</code> робить на любих двох речах, що можна порівняти. Але зачіпка в тому, що вони обоє мають бути одним типом речей. Ви не можете порівняти яблука та помаранчі. Ми зробимо ближчий погляд на типи пізніше. Зауваження: ви можете робити <code>5 + 4.0</code>, оскільки <code>5</code> хитра, і може діяти як ціле або число з плаваючою крапкою. <code>4.0</code> не може діяти як ціле, так що <code>5</code> єдине, що має пристосовуватись.</p></div>
<div class="paragraph"><p>Можиливо ви не знали це, але ми використовували функції весь цей час. Наприклад, <code>*</code> є функцією, що приймає два числа, та перемножує їх. Як ви бачили, ми використовували її, утворивши сендвіч з них. Це те, що ми називаємо інфіксною функцією. Більшість функцій, що не використовуються з числами, є префіксні функції. Давайте поглянемо на них.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/phoen.png" alt="images/phoen.png" />
</span>
Функції звичайно ідуть як префікс, такщо від тепер ми не будемо явно вказувати, що функція має префіксну форму, ми будемо просто вважати що це так. В багатьої імперативних мовах функції викликаються через запис імені функції, та потім її параметри в дужках, звичайно розділені комами. В Haskell функції викликаються записом ім'я функції, проміжок, і розділені проміжками параметри. Для початку ми спробуємо викликати одну зі скучніших функцій в Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">8</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>succ</code> приймає будь-що, що має визначений наступний, та повертає це наступне. Як ви можете бачити, ми просто відділили ім'я функції від параметра проміжком. Виклик функції з декількома параметрами також просте. Функції <code>min</code> та <code>max</code> приймають дві речі, що можуть бути впорядковані (як числа!). <code>min</code> повертає те, що меньше, та <code>max</code> повертає те, що більше. Дивіться самі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">min</span> <span class="mf">3.4</span> <span class="mf">3.2</span>
<span class="mf">3.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">100</span> <span class="mi">101</span>
<span class="mi">101</span>
</pre></div></div></div>
<div class="paragraph"><p>Застосування функції (виклик функції через покладання проміжку пісня неї, та потім набір параметрів) має найвищий преоритет з них усіх. Це означає, що наступні два твердження еквівалентні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="mi">9</span> <span class="o">+</span> <span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">succ</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">max</span> <span class="mi">5</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
<span class="mi">16</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ми бажаємо отримати наступний до добутку чисел <code>9</code> та <code>10</code>, ми не можемо записати  <code>succ 9 * 10</code>, оскільки це отримання послідовника для <code>9</code>, що потім буде помножений на <code>10</code>. Тобто <code>100</code>. Ми маємо писати <code>succ (9 * 10)</code> щоб отримати <code>91</code>.</p></div>
<div class="paragraph"><p>Якщо функція прийма два параметри, ми також можемо викликати її як інфіксну функцію, оточивши її зворотніми апострофами. Наприклад, функція <code>div</code> приймає два цілі, та робить ціле ділення першого на друге. Обчислення <code>div 92 10</code> дає результат <code>9</code>. Але коли ми викликаємо її таким чином, може бути деякий сумнів, яке число є чисельник і яке займенник. Так що ми можемо викликати її як інфіксну функцію, зробивши <code>92 ``div`</code> 10`, і миттєво все стає зрозуміло.</p></div>
<div class="paragraph"><p>Багато людей, які прийшли з імперативних мов, маю схильність приставати на нотацію, де дужки мають позначати застосування функції. Наприклад в C ви виокристовуєте дужки для виклику функції, як <code>foo()</code>, <code>bar(1)</code> або <code>baz(3, "haha")</code>. Як ми казали, в Haskell для застосування функції ми використовуємо дужки. Так що ці функції в Haskell будуть <code>foo</code>, <code>bar 1</code> та <code>baz 3 "haha"</code>. Так що якщо ви бачите що подібне до <code>bar (bar 3)</code>, це не означає, що <code>bar</code> викликається з <code>bar</code> та <code>3</code> в якості параметрів. Це означає, що спочатку ми викликаємо <code>bar</code> з <code>3</code> в якості параметра, щоб отримати якесь число, та потім ми викликаємо <code>bar</code> знову з цім числом. В C це буде щось подібне до <code>bar(bar(3))</code>.</p></div>
<div class="paragraph"><p>В попередньому розділі ми отримали базове відчуття щодо виклику функцій. Тепер давайте спробуємо створити свої власні! Відкрийте ваш улюблений текстовий редактор, і видайте таку функцію, що приймає число та множить його на два.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції визначають в спосіб, подібний до їх виклику. Ім'я функції іде перед параметрами, розділені проміжками. Але коли функція визначається, існує знак <code>=</code> , та після нього визначення того, що робить функція. Збережіть це як <code>baby.hs</code> або будь-як інакше. Тепер перейдіть туди, де ви збереглись, і запустіть там <code>ghci</code>. Всередині  GHCI зробіть <code>:l baby</code>. Тепер, коли наш скрипт завантажений, ми можемо гратись з функцією, яку ми визначили.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">l</span> <span class="n">baby</span>
<span class="p">[</span><span class="mi">1</span> <span class="kr">of</span> <span class="mi">1</span><span class="p">]</span> <span class="kt">Compiling</span> <span class="kt">Main</span>             <span class="p">(</span> <span class="n">baby</span><span class="o">.</span><span class="n">hs</span><span class="p">,</span> <span class="n">interpreted</span> <span class="p">)</span>
<span class="kt">Ok</span><span class="p">,</span> <span class="n">modules</span> <span class="n">loaded</span><span class="kt">:</span> <span class="kt">Main</span><span class="o">.</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mi">9</span>
<span class="mi">18</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleMe</span> <span class="mf">8.3</span>
<span class="mf">16.6</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки <code>+</code> робить на цілих, так само як і на числах з плаваючою крапкою (насправді на будь-чому, що може розглядатись як число), наша функція також може робити з любими числами. Давайте зробимо функцію, що приймає два числа, та перемножує їх на два, і потім складає результати разом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Просто. Ми також могли визначити це як <code>doubleUs x y = x + x + y + y</code>. Тестування продукує досить передбачувані результати (пам'ятайте додати цю функцію до файлу  <code>baby.hs</code>, збережіть його, та потім зробіть <code>:l baby</code> в GHCI).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">4</span> <span class="mi">9</span>
<span class="mi">26</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mf">2.3</span> <span class="mf">34.2</span>
<span class="mf">73.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">doubleUs</span> <span class="mi">28</span> <span class="mi">88</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="mi">123</span>
<span class="mi">478</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, ви можете викликати ваші власні функції з інших функцій, які ви створили. Маючи це на увазі, ви можете перевизначити <code>doubleUs</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleUs</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">doubleMe</span> <span class="n">x</span> <span class="o">+</span> <span class="n">doubleMe</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дуже простий приклад загального шаблону, що ви бачитимете повсякчас в Haskell. Створення простих функцій, що вочевидь коректні, та потім комбінування їх в більш складні функції. Таким чином ви також уникаєте повторень. Що, коли деякий математик дійде висновку, що <code>2</code> насправді <code>3</code>, і ви маєте змінити програму? Ви можете просто перевизначити <code>doubleMe</code> як <code>x + x + x</code>, і оскільки <code>doubleUs</code> викликає <code>doubleMe</code>, вона також буде автоматично робити в цьому дивному світі, де <code>2</code> є <code>3</code>.</p></div>
<div class="paragraph"><p>Функції в Haskell не мають іти в якомусь певному порядку, так що не має значення, якщо ви визначите <code>doubleMe</code> спочатку, та потім <code>doubleUs</code>, або ви зробите це навпаки.</p></div>
<div class="paragraph"><p>Тепер ми збираємось створити функцію, що множить число на <code>2</code>, але тільки якщо число меньше або рівне <code>100</code>, бо числа більше ніж <code>100</code> досить великі як вони є!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span>
                        <span class="kr">then</span> <span class="n">x</span>
                        <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/baby.png" alt="images/baby.png" />
</span>
Прямо зараз ми ввели Haskell твердження <code>if</code>. Ви, можливо, знайомі з <code>if</code> твердженнями в інших мовах. Різниця між Haskell твердженням <code>if</code>, та твердженнями <code>if</code> в імперативних мовах в тому, що частина <code>else</code> обов'язкова в Haskell. В імперативних мовах ви можете просто пропустити пару кроків, якщо умова не задовільняється, але в Haskell кожний вираз та функція має щось повертати. Ми можемо також записати твердження <code>if</code> в один рядок, але я вважаю цей спосіб значно читабельніше. Інша річ щодо твердження <code>if</code> в Haskell в тому, що це вираз. Вираз загалом це шматок коду, що повертає значення. <code>5</code> є виразом, бо воно повертає <code>5</code>, <code>4 + 8</code> також вираз, <code>x + y</code> також вираз, бо він повертає суму <code>x</code> та <code>y</code>. Оскільки <code>else</code> обов'язкове, твердження <code>if</code> буде завжди  щось повертати, і ось чому це також вираз. Якщо ми бажаємо додавати одиницю до кожного числа, що спродуковане в нашій попередній функції, ми маємо записати тіло таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">doubleSmallNumber&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">100</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми б пропустили дужки, воно додавало одиницю тільки якщо <code>x</code> не було б більше <code>100</code>. Зауважте <code>'</code> наприкінці імені функції. Цей апостроф не має жодного спеціального значення в синтаксисі Haskell. Це валідний символ для використання в іменах функцій. Ми зазвичай використовуємо <code>'</code> для позначення суворої версії функції (що не є лінива), або трохи модифікованої версії функції або змінної. Оскільки <code>'</code> валідний символ в функціях, ми можемо зробити функцію таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">conanO&#39;Brien</span> <span class="ow">=</span> <span class="s">&quot;It&#39;s a-me, Conan O&#39;Brien!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут дві речі, варті уваги. Перша в тому, що в назві функції ми не пишемо ім'я Конана з великої литери. Це тому, що функції не можуть починатись з великої літери. Пізніше ми побачимо чому. Друга річ в тому, що ця функція не приймає жодних параметрів. Коли функція не приймає жодних параметрів, ми кажемо що це визначення (або ім'я). Оскільки ми не можемо змінити те, що імена (та функції) означають після того, як ми їх визначили, <code>conanO'Brien</code> та рядок <code>"It's a-me, Conan O'Brien!"</code> можна використовувати взаємозамінно.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/list.png" alt="images/list.png" />
</span>
Здебільшого так само, як списки покупок в реальному світі, списки в Haskell дуже корисні. Це найбільш використовувана структура даних, і вона може бути використана в безлічі різних способів, щоб моделювати та вирішувати цілу кіпу проблем. Списки ТАКІ неймовірні. В цьому розділі ми побачимо на основи списків, рядкі (що є списками) та осяжність списків.</p></div>
<div class="paragraph"><p>В Haskell списки є гомогенними структурами даних. Вони зберігають декілька елементів одного типу. Це означає, що ми можемо мати список цілих та список символів, але ми не можемо мати список, що має трохи цілих, та трохи символів. І тепер - список!</p></div>
<div class="paragraph"><p>Note: Ми можемо використовувати ключове слово <code>let</code> для визначення імені прямо в GHCI. Зробити <code>let a = 1</code> в GHCI еквівалентно до написання <code>a = 1</code> в скрипті, та потім його завантаження.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">lostNumbers</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lostNumbers</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">42</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, списки позначаються квадратними дужками, та значення в списках розділяються комами. Якщо ми спробуємо список <code>[1,2,'a',3,'b','c',4]</code>, Haskell буде скаржитись, що символи (що, проміж іншого, позначаються символами в поодиноких лапках) не є числами. Кажучи про символи, рядки є тільки списками символів. <code>"hello"</code> є тільки синтаксичним цукром для <code>['h','e','l','l','o']</code>. Оскільки рядки є списками, ми можемо використовувати функції для спискив з рядками, що дійсно зручно.</p></div>
<div class="paragraph"><p>Загальна задача є складання двох списків разом. Це робиться за допомогою оператора <code>++</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="s">&quot;world&quot;</span>
<span class="s">&quot;hello world&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;w&#39;</span><span class="p">,</span><span class="sc">&#39;o&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="sc">&#39;t&#39;</span><span class="p">]</span>
<span class="s">&quot;woot&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Пильнуйте, коли постійно використовуєте оператор <code>++</code> на довгих рядках. Коли ми складаємо разом два списки (навіть якщо ми додаємо синглтон список до списку, наприклад: <code>[1,2,3] ++ [4]</code>), внутрішньо Haskell має пройти по всьому списку злівого боку від <code>++</code>. Це не проблема, коли маємо справи зі списками, що не дуже великі. Але покладання дечого в кінець списку, що має п'ядесят мільйонів елементів в довжину таки займе деякий ча. Однак покладання дечого на початок списку з використанням оператора <code>:</code> (також називається <code>cons</code> оператором) є миттєвим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;A&#39;</span><span class="kt">:</span><span class="s">&quot; SMALL CAT&quot;</span>
<span class="s">&quot;A SMALL CAT&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span><span class="kt">:</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, як <code>:</code> приймає число і список чисел, або символ та список символів, тоді як <code>++</code> приймає два списки. Навіть якщо ви додаєте один елемент в кінець списку за допомогою <code>++</code>, ви маєте оточити його в квадратні дужки, так щоб він став списком.</p></div>
<div class="paragraph"><p><code>[1,2,3]</code> насправді є тільки синтаксичним цукром для <code>1:2:3:[]</code>. <code>[]</code> це порожній список. Якщо перед ним добавити <code>3</code> це перетвориться на <code>[3]</code>. Якщо перед цім поставити <code>2</code>, стане <code>[2,3]</code>, і так далі.</p></div>
<div class="paragraph"><p>Note: <code>[]</code>, <code>[[]]</code> та <code>[[],[],[]]</code> все різні речі. Перше це порожній список, друге це список, що містить один порожній список, третій список містить три порожні списки.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте отримати елемент зі списку по індексу, використовуйте <code>!!</code>. Індекси починаються з <code>0</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Steve Buscemi&quot;</span> <span class="o">!!</span> <span class="mi">6</span>
<span class="sc">&#39;B&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">9.4</span><span class="p">,</span><span class="mf">33.2</span><span class="p">,</span><span class="mf">96.2</span><span class="p">,</span><span class="mf">11.2</span><span class="p">,</span><span class="mf">23.25</span><span class="p">]</span> <span class="o">!!</span> <span class="mi">1</span>
<span class="mf">33.2</span>
</pre></div></div></div>
<div class="paragraph"><p>Але якщо ви намагатиметесь отримати шостий елемент зі списку, що має тільки чотири елементи, ви отримаєте помилку, так що будьте уважні!</p></div>
<div class="paragraph"><p>Списки також можуть містити списки. Вони також можуть містити списки, що містять списки, що містять списки …</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">++</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="kt">:</span><span class="n">b</span>
<span class="p">[[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">!!</span> <span class="mi">2</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Списки в списку можуть бути різної довжини, але вони не можуть бути різних типів. Так само, як ви не можете мати список, що містить деякі числаі деяки символи, ви не можете мати деякі списки з символами, і деякі списки з числами.</p></div>
<div class="paragraph"><p>Списки можливо порівняти, якщо те, що вони містять, може бути порівняно. Коли використовуються <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> та <code>&gt;=</code> для порівняння списків, вони порівнюються в лексографічному порядку. Спочатку порівнюються голови. Якщо вони рівні, порівнюються другі елементи, і так далі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p>Що ще можна робити зі списками? Ось деякі базові функції, що оперують на списках.</p></div>
<div class="paragraph"><p><code>head</code> бере список, та повертає його голову. Голова списку це його перший елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>tail</code> бере список, та повертає його хвіст. Іншими словами вона відрубає йому голову.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tail</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>last</code> бере список, та повертає останній елемент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">last</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p><code>init</code> бере список, та повератє все, крім останнього елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">init</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви вважаєте, що список це монстр, тоді вам сподобається таке.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/listmonster.png" alt="images/listmonster.png" />
</div>
</div>
<div class="paragraph"><p>Але що трапиться, якщо ми спробуємо отримати голову порожнього списку?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="kt">[]</span>
<span class="o">***</span> <span class="kt">Exception:</span> <span class="kt">Prelude</span><span class="o">.</span><span class="n">head</span><span class="kt">:</span> <span class="n">empty</span> <span class="n">list</span>
</pre></div></div></div>
<div class="paragraph"><p>Матінко рідна! Все це вибухнуло нам у лице! Якщо немає монстра, в нього немає голови. Коли використовуєте <code>head</code>, <code>tail</code>, <code>last</code> та <code>init</code>, будьте уважні не використовувати їх на порожніх списках. Ця помилка не може бути перехоплена під час компіляції, так що завжди гарна практика докласти перестороги супроти випадкового прохання до Haskell отримати елементи з порожнього списку.</p></div>
<div class="paragraph"><p><code>length</code> бере список, та повертає його довжину, очевидно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">length</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи список порожній. Якщо це так, він повертає <code>True</code>, інакше <code>False</code>. Використовуйте цю функцію замість <code>xs == []</code> (якщо ви маєте список з назвою <code>xs</code>)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">null</span> <span class="kt">[]</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>reverse</code> обертає список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">reverse</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>take</code> бере число і список. Він виділяє таку кількість з початку списка. Дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">5</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите, якщо ми намагаємось взяти більше елементів, ніє є в списку, він просто повертає список. Якщо ми намагаємось взяти <code>0</code> повертається порожній список.</p></div>
<div class="paragraph"><p><code>drop</code> робить подібним чином, тільки він відкидає число елементів з початку списка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">drop</span> <span class="mi">100</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>maximum</code> бере список дечого, що може бути впорядковане, і повертає найбільший елемент.</p></div>
<div class="paragraph"><p><code>minimum</code> повертає найменьший.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minimum</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maximum</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">9</span>
</pre></div></div></div>
<div class="paragraph"><p><code>sum</code> бере список чисел, та повертає його суму.</p></div>
<div class="paragraph"><p><code>product</code> бере список чисел, та повертає його добуток.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="mi">31</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">24</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elem</code> бере річ та список речей, та каже нам, чи є такий елемент в списку. Це звичайно викликається як інфіксна функція, оскільки так воно краще читається.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Це були декілька базових функцій, що оперують на списках. Ми побачимо більше спискових функцій пізніше.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cowboy.png" alt="images/cowboy.png" />
</span>
Що, коли ми бажаємо перелічити всі числа від 1 до 20? Звичайно, ми можемо просто надрукувати їх всі разом, але вочевидь це не рішення для джентельмена, що вимагає досконалості від своїх мов програмування. Замість цього ми використовуємо диапазони. Диапазони - це спосіб створювати списки, що є арифметичними послідовностями елементів, що можуть бути перелічені. Числа можуть бути перелічені. Один, два, три, чотири, тощо. Символи можути бути перелічені. Абетка є перелік літер від <code>A</code> до <code>Z</code>. Імена не можуть бути перелічені. Що іде після <code>"John"</code>? Я не знаю.</p></div>
<div class="paragraph"><p>Щоб зробити список, що містить всі натуральні числа від 1 до 20 ви можете записати<code>[1..20]</code>. Це еквівалентно до написання <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code>, і немає різниці між написанням одного чи іншого, за винятком того, що написання довгих послідовностей переліку вручну є дурнею.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">19</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;K&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]</span>
<span class="s">&quot;KLMNOPQRSTUVWXYZ&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Диапазони круті, оскільки ви можете задати крок. Що, якщо ми бажаємо всі парні числа між 1 та 20? Або навіть тожне третє між 1 та 20?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="o">..</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">18</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це просто справа розділення перших двох елементів комою, та потім вказати вищий ліміт. Хоча це досить розумне, диапазони з кроками не такі розумні, ніє деяки люди бажали б їх бачити. Ви не можете зробити <code>[1,2,4,8,16..100]</code>, та очікувати отримання всіх ступеней <code>2</code>. Для початку тому що ви можете вказати один крок. Та подруге через те, що деякі неарифметичні послідовності неоднозначні, якщо задати тільки декілька з перших членів послідовності.</p></div>
<div class="paragraph"><p>Щоб зробити список з усіх чисел від 20 до 1, ви не можете записати тільки <code>[20..1]</code>, ви маєте зробити <code>[20,19..1]</code>.</p></div>
<div class="paragraph"><p>Слідкуйте за використанням чисел з плаваючою крапкою в диапазонах! Завдяки тому, що вони не повністю точні (по визначенню), їх використання може дати деякі досить дивні результаті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span> <span class="o">..</span> <span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.7</span><span class="p">,</span><span class="mf">0.8999999999999999</span><span class="p">,</span><span class="mf">1.0999999999999999</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Моя порада не використовувати їх в спискових диапазонах.</p></div>
<div class="paragraph"><p>Ви також можете використовувати диапазони для створення безкінечних списків, просто не задаючи верню межу. Пізніше ми дійдемо до більших деталей щодо безкінечних списків. Тепер давайте перевіримо, як ви можете отримати перші <code>24</code> добутки числа <code>13</code>. Звичайно, ви можете зробити <code>[13,26..24*13]</code>. Але є кращий шлях: <code>take 24 [13,26..]</code>. Оскільки Haskell лінивий, він не буде намагатись обчислити безкінечний список безпосередньо, бо це ніколи не скінчиться. Він буде чекати, що ви бажаєте отримати з цього безкінечного списку. І тут він бачить, що ви бажаєте отримати лише перші <code>24</code> елементи, на що він легко погоджується.</p></div>
<div class="paragraph"><p>Декілька фунцій, що продукують безкінечні списки:</p></div>
<div class="paragraph"><p><code>cycle</code> бере список, та в циклі перетворює його в безкінечний список. Якщо ви спробуєте тільки отримати результат, це триматиме вічність, тому ви маєте перерватись десь.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">cycle</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">12</span> <span class="p">(</span><span class="n">cycle</span> <span class="s">&quot;LOL &quot;</span><span class="p">)</span>
<span class="s">&quot;LOL LOL LOL &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>repeat</code> бере елемент, та продукує безкінечний список тільки з цього елемента. Це як цикл по списку тільки з одного елемента.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="p">(</span><span class="n">repeat</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча це простіше просто використовувати фуункцію <code>replicate</code>, якщо ви бажаєте деяке число одного елемента в списку. <code>replicate 3 10</code> повертає <code>[10,10,10]</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/kermit.png" alt="images/kermit.png" />
</span>
Якщо ви колись вивчали курс з математики, ви, можливо, натрапляли на осяжності множин (прим.перекл. Насправді термін <em>comprehension</em> погано або майже не перекладається одинм словом. Суть в процедурному породженні множини, так би мовити делегація вирішення питання належності до деякого функціоналу - фактично, <em>comprehension</em> легше зрозуміти з боку функціонального програмування). Вони звичайно використовуються для побудови більш специфічних множин на основі більш загальних. Базова осяжність для множини, що містить перші десять парних натуральних чисел є нотація множини.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/setnotation.png" alt="images/setnotation.png" />
</span>
Частина перед рискою називається функцією виводу, <code>x</code> це змінна, <code>N</code> є вхідна множина, та <code>x &lt;= 10</code> є предикат. Це означає, що множина містить подвоєння всіх натуральних чисел, що задовільняють предикату.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте записати це в Haskell, ви можете зробити щось подібне до <code>10 [2,4..]</code>. Але що, якщо ви не бажаєте подвоєння перших <code>10</code> натуральних чисел, але деякий різновид більш складної функції, застосованої до них? Ми можемо застосувати для цього осяжність множини. Ми покі пристанемо до отримання перших <code>10</code> парних чисел. Осяжність списків, яку ми ми можемо використати, це <code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> береться з <code>[1..10]</code>, і для кожного елемента в <code>[1..10]</code> (який ми прив'язуємо до <code>x</code>), ми отримуємо цей елемент, тільки подвоєний. Ось осяжність в дії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, ми отримали бажаний результат. Тепер давайте додамо умову (або предикат) до осяжності. Предикати ідуть після частини прив'язування, та відокремлюються від них комою. Скажімо, ми бажаємо тільки елементи, що, вже подвоїні, більші або рівні до <code>12</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="mi">2</span> <span class="o">&gt;=</span> <span class="mi">12</span><span class="p">]</span>
<span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто, це робить. Що, коли ми бажаємо всі числа від <code>50</code> до <code>100</code>, чий залишок, коли поділений на число <code>7</code>, є <code>3</code>? Легко.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">50</span><span class="o">..</span><span class="mi">100</span><span class="p">],</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">7</span> <span class="o">==</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">52</span><span class="p">,</span><span class="mi">59</span><span class="p">,</span><span class="mi">66</span><span class="p">,</span><span class="mi">73</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">87</span><span class="p">,</span><span class="mi">94</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Успіх! Зауважте, що пропускання списків через предикати також називається фільтрацією. Ми беремо список з чисел, і ми фільтруємо його предикатом. Тепер інший приклад. Скажімо, ми бажаємо осяжність, що замінює кожне непарне число, більше ніж <code>10</code> на <code>"BANG!"</code>, та кожне непарне, що меньше ніж <code>10</code> на <code>"BOOM!"</code>. Якщо число не непарне, ми відкидаємо його зі списку. Для зручності ми покладемо цю осяжність в функцію, так що ми можемо легко використовувати її декілька раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">boomBangs</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="kr">then</span> <span class="s">&quot;BOOM!&quot;</span> <span class="kr">else</span> <span class="s">&quot;BANG!&quot;</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">odd</span> <span class="n">x</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Остання частина осяжності є предикат. Функція <code>odd</code> повертає <code>True</code> на непарних числах, та <code>False</code> на парних. Елемент включається в список тільки якщо всі його предикати обчислюються до <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boomBangs</span> <span class="p">[</span><span class="mi">7</span><span class="o">..</span><span class="mi">13</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BOOM!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо включити декілька предикатів. Якщо ми бажаємо всі числа від <code>10</code> до <code>20</code>, що не є <code>13</code>, <code>15</code> або <code>19</code>, ми робимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">10</span><span class="o">..</span><span class="mi">20</span><span class="p">],</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">13</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">x</span> <span class="o">/=</span> <span class="mi">19</span><span class="p">]</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">17</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не тільки можете мати декілька предикатів в осяжностях списків (елемент має задовільняти всім предикатам щоб бути включеним в результуючий список), ми також можемо вибирати з декількох списків. Коли здаєте з кількох списків, осяжність продукує всі комбінації з наданих списків, та потім поєднує їх в вихідній функції, яку ми надаємо. Список, вироблений осяжністю, що вибирає з двох списків довжиною <code>4</code>, буде мати довжину <code>16</code>, якщо вважати, що ми нічого не фільтруємо. Якщо ми маємо два списки, <code>[2,5,10]</code> та <code>[8,10,11]</code>, та бажаємо спродукувати всі можливі комбінації між числами в ціх списках, ось як ми це робимо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">16</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">22</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як очікувалось, довжина нового списку є <code>9</code>. Що, коли ми бажаємо всі можливі добутки, що більші за <code>50</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],</span> <span class="n">y</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">],</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">50</span><span class="p">]</span>
<span class="p">[</span><span class="mi">55</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо осяжності списку, що комбінує список прикметників та список іменників … заради епічної втіхи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">nouns</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;hobo&quot;</span><span class="p">,</span><span class="s">&quot;frog&quot;</span><span class="p">,</span><span class="s">&quot;pope&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">adjectives</span> <span class="ow">=</span> <span class="p">[</span><span class="s">&quot;lazy&quot;</span><span class="p">,</span><span class="s">&quot;grouchy&quot;</span><span class="p">,</span><span class="s">&quot;scheming&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">adjective</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">noun</span> <span class="o">|</span> <span class="n">adjective</span> <span class="ow">&lt;-</span> <span class="n">adjectives</span><span class="p">,</span> <span class="n">noun</span> <span class="ow">&lt;-</span> <span class="n">nouns</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;lazy hobo&quot;</span><span class="p">,</span><span class="s">&quot;lazy frog&quot;</span><span class="p">,</span><span class="s">&quot;lazy pope&quot;</span><span class="p">,</span><span class="s">&quot;grouchy hobo&quot;</span><span class="p">,</span><span class="s">&quot;grouchy frog&quot;</span><span class="p">,</span>
<span class="s">&quot;grouchy pope&quot;</span><span class="p">,</span><span class="s">&quot;scheming hobo&quot;</span><span class="p">,</span><span class="s">&quot;scheming frog&quot;</span><span class="p">,</span><span class="s">&quot;scheming pope&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Я знаю! Давайте напишемо свою власну версію <code>length</code>! Ми назвемо її <code>length'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">length&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">[</span><span class="mi">1</span> <span class="o">|</span> <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>_</code> означає, що нам байдуже, що ми витягнули зі списку, так що замість писати ім'я змінної, що ніколи не буде використовуватись, ми просто пишемо _. Ця функція заміняє кожний елемент в списку на <code>1</code>, та потім підсумовує їх. Це означає, що отримана сума буде рівною довжині нашого списка.</p></div>
<div class="paragraph"><p>Просто дружнє нагадування: оскільки рядки є списками, ми можемо використовувати осяжності списків для обробки та продукування рядків. Ось функція, що бере рядок, та видаляє будь-що, за винятком великих літер.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Testing it out:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;Hahaha! Ahahaha!&quot;</span>
<span class="s">&quot;HA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">removeNonUppercase</span> <span class="s">&quot;IdontLIKEFROGS&quot;</span>
<span class="s">&quot;ILIKEFROGS&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут предикат робить всю роботу. Він каже, що символи будуть включені в новий список, тільки якщо вони є елементами списку <code>['A'..'Z']</code>. Вкладені осяжності списків також можливі, якщо ви оперуєте зі списками, що містять списки. Список містить декілька списків чисел. Давайте видалимо всі непарні числа без вирівнювання списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xxs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">[</span> <span class="n">x</span> <span class="o">|</span> <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">even</span> <span class="n">x</span> <span class="p">]</span> <span class="o">|</span> <span class="n">xs</span> <span class="ow">&lt;-</span> <span class="n">xxs</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете записувати осяжності списків на декількох рядках. Так що якщо ви не в GHCI, краще розділити довші осяжності списків на декілька рядків, особливо якщо вони вкладені.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/tuples.png" alt="images/tuples.png" />
</span>
В деякий спосіб тапли як списки — вони є спосіб зберігати декілька значень в одному значенні. Але є декілька фундаментальних відмінностей. Список чисел є список чисел. Це його тип, і не має значення, чи він має лише одне число в собі, або безкінечне іисло чисел. Однак тапли використовуються, коли ви напевне знаєте, скільки значень ви бажаєте скомбінувати, та їх тип залежить від того, як багато компонент, та який їх тип. Вони позначаються дужками, та їх компоненти розділені комами.</p></div>
<div class="paragraph"><p>Інша ключова відмінність в тому, що вони не мають бути гомогенними. На відміну від списків, тапл може містити комбінацію декількох типів.</p></div>
<div class="paragraph"><p>Подумайте про те, як ми представляємо дво-вимірний вектор в Haskell. Один спосіб може бути список. Це має деяк робити. То що, якщо ми бажаємо покласти пару векторів в список, щоб представляти точки фігури на дво-мірній площині? Ми маємо зробити щось таке: <code>[[1,2],[8,11],[4,5]]</code>. Проблема з цім методом в тому, що ми також можемо робити такі речі: <code>[[1,2],[8,11,5],[4,5]]</code>, з чим Haskell не матиме проблем, бо це також список списків з числами, але це щось таке, що не має сенсу. Але тапл розміром два (що також має назву <code>pair</code>) є власним типом, що означає, що список не може мати декілька пар, і потім <code>triple</code> (тапл розміром три), так що давайте краще використовувати пари. Замість оточувати вектори квадратними дужками, ми використовуємо дужки: <code>[(1,2),(8,11),(4,5)]</code>. Що, коли ми спробуємо зробити фігуру як <code>[(1,2),(8,11,5),(4,5)]</code>? Гаразд, ми отримаємо таку помилку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]</code></pre>
</div></div>
<div class="paragraph"><p>Це каже нам, що ми спробували використовувати пару та трійку в одному списку, що не мало б статись. Ви також не можете зробити список як <code>[(1,2),("One",2)]</code>, оскільки перший елемент в списку є парою чисел, і другий елемент є парою, що складається з рядка та числа. Тапли також можуть використовуватись для представлення широкого різноманіття даних. Наприклад, якщо ми бажаємо представити чиєсь ім'я і вік в Haskell, ми можемо використовувати <code>triple</code>: <code>("Christopher", "Walken", 55)</code>. Як бачимо в цьому прикладі, тапли також можуть містити списки.</p></div>
<div class="paragraph"><p>Використовуйте тапли, коли ви знаєте заздалегідь, як багато компонент буде мати деякий шматок даних. Тапли значно більш обмежені, оскільки кожни інший розмір тапла є власним типом, так що ви не можете написати загальну функцію для додавання елементу до тапла — ви маєте писати функцію для додавання до пари, одну функцію для додавання до трійці, одну для додавання до четвірки і так далі.</p></div>
<div class="paragraph"><p>Хоча є списки синглтони, немає такої речі як синглтон тапл. Це не має багато сенсу, якщо ви поміркуєте про це. Синглтон тапл є тільки значення, що він містить, і це не дає нам жодних переваг.</p></div>
<div class="paragraph"><p>Як списки, тапли можуть бути порівняні один з одним, якщо їх компоненти можуть бути порівняні. Ви не можете порівняти два тапла різного розміру, хоча ви можете порівняти два списки різного розміру. Дві корисні функції для операцій на парах:</p></div>
<div class="paragraph"><p><code>fst</code> бере пару, та повертає перший компонент.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">8</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fst</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="s">&quot;Wow&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>snd</code> бере пару, та повертає другий компонент. Сюрприз!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">)</span>
<span class="mi">11</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">snd</span> <span class="p">(</span><span class="s">&quot;Wow&quot;</span><span class="p">,</span> <span class="kt">False</span><span class="p">)</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: ці функції оперують тільки на парах. Вони не працюватимуть на трійках, четвірках, п'ятірках, тощо. Ми дійдемо до отримання даних з таплів в різний спосіб трохи пізніше.</p></div>
<div class="paragraph"><p>Крута функція, що продукує список пар: <code>zip</code>. Вона приймає список з двох списків, та потім поєднує їх разом в один список, через поєднання елементів з одним індексом в пари. Це насправді проста функція, але вона має безліч застосувань. Вона особливо корисна, коли ви бажаєте скомбінувати два списки в цей спосіб, або пересуватись по обох списках одночасно. Ось демонстрація.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">,</span> <span class="s">&quot;three&quot;</span><span class="p">,</span> <span class="s">&quot;four&quot;</span><span class="p">,</span> <span class="s">&quot;five&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;one&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;two&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;three&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;four&quot;</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;five&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це спаровує елементи та продукує новий список. Перший елемент з першим, другий з другим, і так далі. Зауважте, що оскільки пари можуть мати різні типи в собі, <code>zip</code> може приймати два списка, що містять різні типи, та поєднати їх разом. Що трапиться, якщо довжина списків не співпаде?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;im&quot;</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">5</span><span class="p">,</span><span class="s">&quot;im&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;a&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;turtle&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Довший список просто буде обрізаний, щоб співпадати по довжині з коротшим. Оскільки Haskell лінивий, ми можемо поєднувати скінчені списки з безкінечними списками:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;apple&quot;</span><span class="p">,</span> <span class="s">&quot;orange&quot;</span><span class="p">,</span> <span class="s">&quot;cherry&quot;</span><span class="p">,</span> <span class="s">&quot;mango&quot;</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="s">&quot;apple&quot;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="s">&quot;orange&quot;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="s">&quot;cherry&quot;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="s">&quot;mango&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/pythag.png" alt="images/pythag.png" />
</span>
Ось проблема, що поєднує тапли та осяжності списків: який правильний трикутник, що має цілими всі сторони, і всі сторони меньше або рівні <code>10</code>, має периметр <code>24</code>? Перше, давайте спробуємо генерувати всі трикутники, зі сторонами меньшими ніж <code>10</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">triangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми тільки но тягнемо з трьох списків, і наша вихідна функція є поєднання їх в трійцю. Якщо ви обчислите це, набравши <code>triangles</code>  в GHCI, ви отримаєте список всіх можливих трикутників зі сторонами довжиною <code>10</code> або меньше. Далі ми додамо умову, щоб всі вони були правильними трикутниками. Ми також будемо модифікувати цю функцію, приймаючи до уваги, що сторона <code>b</code> не більша за гіпотенузу, і що сторона <code>a</code> не більша за сторону <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми майже скінчили. Тепер ми тільки модифікуємо функцію, сказавши, що ми бажаємо тільки коли периметр дорівнює <code>24</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">rightTriangles&#39;</span> <span class="ow">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">c</span><span class="p">],</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">b</span><span class="p">],</span> <span class="n">a</span><span class="o">^</span><span class="mi">2</span> <span class="o">+</span> <span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">==</span> <span class="n">c</span><span class="o">^</span><span class="mi">2</span><span class="p">,</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span> <span class="o">==</span> <span class="mi">24</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">rightTriangles&#39;</span>
<span class="p">[(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>А ось і відповідь! Це загальних шаблон функціонального програмування. Ви берете стартовий набір рішень, та потім ви застосовуєте трансформації до ціх рішень, та фільтруєте їх, доки ви не отримаєте потрібні.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/cow.png" alt="images/cow.png" />
</span>
Раніше ми згадували, що Haskell має статичну систему типів. Тип кожного виразу відомий під час компіляції, що призводить до безпечнішого коду. Якщо ви напишете програму, де ви спробуєте поділити логічний тип на деяке число, вона навіть не скомпілюється. Це добре, бо краще перехоплювати такі помилки під час компіляції, замість отримати крах вашої програми. Все в Haskell має тип, так що компілятор може міркувати щодо вашої програми, перед тим як скомпілювати її.</p></div>
<div class="paragraph"><p>На відміну від Java або Pascal, Haskell має вивід типів. Якщо ви пишете число, ви не маєте казати Haskell, що це число. Він може вивести це сам, так що нам не треба явно писати типи наших функцій та виразів, щоб все робилось відповідно. Ми розглянули деяки з основ Haskell, тільки зверньо поглянувши на типи. Однак розуміння системи типів є дуже важливою частиною в вивченні Haskell.</p></div>
<div class="paragraph"><p>Тип є різновидом мітки, що має кожен вираз. Він каже нам, до якої категорії речей належить вираз. Вираз <code>True</code> є логічним, <code>"hello"</code> є рядком, тощо.</p></div>
<div class="paragraph"><p>Зараз ми будемо використовувати GHCI для перевірки типів деяких виразів. Ми будемо робити це, використовуючи команду <code>:t</code>, яка, якщо стоїть перед валідним виразом, каже його тип. Дамо йому вир.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="sc">&#39;a&#39;</span>
<span class="sc">&#39;a&#39;</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">True</span>
<span class="kt">True</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="s">&quot;HELLO!&quot;</span>
<span class="s">&quot;HELLO!&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span>
<span class="mi">4</span> <span class="o">==</span> <span class="mi">5</span> <span class="ow">::</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bomb.png" alt="images/bomb.png" />
</span>
Тут ми бачимо, що робити <code>:t</code> на виразі друкує вираз, за яким іде <code>::</code> та його тип. <code>::</code> читається як "має певний тип". Явні типи завжди позначаються першою літерою верхнього реєству. <code>'a'</code>, як можна бачити, має тип <code>Char</code>. Не важко зробити висновок, що це позначає символ. <code>True</code> має тип <code>Bool</code> (логічний тип, названий за розробником логічної алгебри предикатів, Буля. прим.перекл). Це має сенс. Але що це? Дослідження типу <code>"HELLO!"</code> дає <code>[Char]</code>. Квадратні дужки позначають список. Так що ми читаємо це як список символів. На відміну від списків кожна довжина таплу має власний тип. Так що вираз <code>(True, 'a')</code> має тип <code>(Bool, Char)</code>, тоді як вираз як <code>('a','b','c')</code> матиме тип <code>(Char, Char, Char)</code>. <code>4 == 5</code> завжди повертатиме <code>False</code>, так що його тип <code>Bool</code>.</p></div>
<div class="paragraph"><p>Функції також мають типи. Коли ми пишемо власні функції, ми можемо обрати надавати їм явні декларації типів. Це загалом розглядається як гарна практика, за винятком коли ми пишемо дуже малі функції. Звідси і надалі ми надаватимемо функції, що мають явні декларації типів. Згадайте осяжності списків, що ми робили до цього, що фільтрували рядки, що мають лише великі літери? Ось як це виглядає з декларацією типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">removeNonUppercase</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">removeNonUppercase</span> <span class="n">st</span> <span class="ow">=</span> <span class="p">[</span> <span class="n">c</span> <span class="o">|</span> <span class="n">c</span> <span class="ow">&lt;-</span> <span class="n">st</span><span class="p">,</span> <span class="n">c</span> <span class="p">`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>removeNonUppercase</code> має тип <code>[Char] -&gt; [Char]</code>, що каже, що вона відзеркалює рядок на рядок. Це тому, що вона бере один рядок як параметр, та повертає інший як результат. Тип <code>[Char]</code> є синонімом до <code>String</code>, так що буде яснішим, якщо ми напишемо <code>removeNonUppercase    \:\: String -&gt; String</code>. Ми не маємо надавати цій функції декларацію типу, оскільки компілятор може вивести це самостійно, що це функція рядка до рядка, ала ми зробили це все одно. Але як записати тип функції, що приймає декілька параметрів? Ось проста функція, що приймає три цілі та складає їх разом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addThree</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри розділені позначкою <code>-&gt;</code>, і немає особливої різниці між параметрами та типом повернення. Тип повернення є останнім елементом в декларації, та параметри перші три. Пізніше ми побачимо, чому вони всі розділені <code>-&gt;</code>, замість мати деякий більш явний спосіб розрізнення між типом повернення та параметрами, як <code>Int, Int, Int -&gt; Int</code>, або щось таке.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте надати вашій функції декларацію типу, але не впевнені, що це має бути, ви можете тільки написати функцію без нього, та потім перевірити її за допомогою <code>:t</code>. Функції також є виразами, так що <code>:t</code> робить на них без проблем.</p></div>
<div class="paragraph"><p>Ось огляд деяких загальних типів.</p></div>
<div class="paragraph"><p><code>Int</code> означає цілі. Він використовується для цілих чисел. <code>7</code> може бути <code>Int</code>, але <code>7.2</code> ні. <code>Int</code> обмежене, що означає, що вони мають мінімум та максимальне значення. Зазвичай на 32-бітних машинах максимально можливе <code>Int</code> є <code>2147483647</code>, та мінімальне є <code>-2147483648</code>.</p></div>
<div class="paragraph"><p><code>Integer</code> позначає також, хм … також ціле. Головна різниця в тому, що він не прив'язаний до меж, і він може використовуватись для представлення насправді великих чисел. Я маю на увазі що дійсно великіх. Однак <code>Int</code> більш ефективний.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">factorial</span> <span class="ow">::</span> <span class="kt">Integer</span> <span class="ow">-&gt;</span> <span class="kt">Integer</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">product</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">factorial</span> <span class="mi">50</span>
<span class="mi">30414093201713378043612608166064768844377641568960512000000000000</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Float</code> є дійсне плаваюче з одинарною точністю.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">circumference</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference</span> <span class="mf">4.0</span>
<span class="mf">25.132742</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Double</code> є дійсне плаваюче з подвійною точністю!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">circumference&#39;</span> <span class="ow">::</span> <span class="kt">Double</span> <span class="ow">-&gt;</span> <span class="kt">Double</span>
<span class="nf">circumference&#39;</span> <span class="n">r</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">circumference&#39;</span> <span class="mf">4.0</span>
<span class="mf">25.132741228718345</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Bool</code> є логічний тип. Він може мати тільки два значення: <code>True</code> та <code>False</code>.</p></div>
<div class="paragraph"><p><code>Char</code> представляє символ. Він позначається поодинокими лапками. Список символів є рядком.</p></div>
<div class="paragraph"><p>Тапли є типами, але вони залежні від своєї довжини, так само, як і від типів своїх компонентів, так що теоретично є безліч типів таплів, що забагато, щоб накрити в цьому туторіалу. Зауважте, що порожній тапл <code>()</code> також є типом, що може мати одне значення: <code>()</code>.</p></div>
<div class="paragraph"><p>Який, як ви думаєте, є тип функції <code>head</code>? Оскільки <code>head</code> приймає список любого типу, та повертає перший елемент, то що це має бути? Давайте перевіримо!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">head</span>
<span class="nf">head</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/box.png" alt="images/box.png" />
</span>
Хмм! Що є це <code>a</code>? Чи це є тип? Згадайте, що дотепер ми стверджували, що типи записуються з великої літери, так що це не може в точності бути типом. Оскільки це не велика літера, це насправді змінна типу. Це значить, що це може бути любий тип. Це здебільшого як дженеріки в інших мовах, але в Haskell це значно більш потужне, оскільки це дозволяє нам просто писати любі загальні функції, тільки якщо вони не використовують деяку особливу специфічну поведінку на типах в своєму складі. Функції, що мають змінні типів, називаються поліморфними функціями. Декларація типу <code>head</code> стверджує, що вона приймає список любого типу, та повертає один елемент цього типу.</p></div>
<div class="paragraph"><p>Хоча змінні типів можуть мати ім'я, довші за один символ, ми зазвичай даємо їм імена <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> …</p></div>
<div class="paragraph"><p>Пам'ятаєте <code>fst</code>? Він повертає перший компонент з пари. Давайте дослідимо його тип.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">fst</span>
<span class="nf">fst</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми бачимо, що <code>fst</code> бере тапл, що має два типи, і повертає елемент, чий тип такий самий, що і тип першого компонента з пари. Ось чому ми можемо використовувати <code>fst</code> на парі, що містить два довільні типи. Зауважте, що тільки через те, що <code>a</code> та <code>b</code> є різними змінними типів, вони не мають бути різними типами. Це типами стверджує, що тип першого компоненту та тип значення повернення є тим самим.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/classes.png" alt="images/classes.png" />
</span>
Типоклас є деяким різновидом інтерфейсу, що визначає деяку поведінку. Якщо тип є частиною типокласу, це означає, що він підтримує та реалізує поведінку, яку описує типоклас. Багато людей, що приходять з OOP, спантеличені типокласами, бо вважають їх подібними до класів в об'єктно орієнтовних мовах. Гараз, це не так. Ви можете думати про них, як про різновид Java інтерфейсів, тільки кращіх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">==</span><span class="p">)</span>
<span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: оператор еквівалентності <code>==</code> є функцією. Так само, як <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code>, та майже всі інші оператори. Якщо функція складається тільки зі спеціальних символів, вона розглядається як інфіксна функція по замовчанню. Якщо ми бажаємо перевірити її тип, передати її до іншої функції, або викликати як префіксну функцію, ми маємо оточити її дужками.</p></div>
<div class="paragraph"><p>Цікаво. Ми бачимо тут нову річ, символ <code>=&gt;</code>. Все перед символом <code>=&gt;</code> має назву класової константи. Ми можемо прочитати попередню декларацію типу таким чином: Функція еквівалентності бере два значення, що мають однаковий тип, та повертає <code>Bool</code>. Тип ціх значень мусить бути типом класу <code>Eq</code> (це була класова константа).</p></div>
<div class="paragraph"><p>Типоклас <code>Eq</code> провадить інтерфейс для перевірки на рівність. Кожний клас, коли має сенс перевірка на рівність між двома елементами для цього типу, мав би бути членом класу <code>Eq</code>. Всі стандартні типи Haskell, за винятком IO (тип для роботи з вводом та виводом), та функції є частиною типокласу <code>Eq</code>.</p></div>
<div class="paragraph"><p>Функція <code>elem</code> має тип <code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>, оскільки він використовує <code>==</code> по списку, щоб перевірити, чи деяке значення, яке ми шукаємо, знаходиться в списку.</p></div>
<div class="paragraph"><p><code>Eq</code> використовується для типів, що підтримують перевірку на рівність. Функції, що реалізують його члени є <code>==</code> та <code>/=</code>. Так що якщо є обмеження класу <code>Eq</code> для змінної типу в функції, вона використовує <code>==</code> або <code>/=</code> десь в своїй декларації. Всі типи, що ми згадували до цього, за винятком функцій, є частинами <code>Eq</code>, так що вони можуть бути перевірені на рівність.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">==</span> <span class="mi">5</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">/=</span> <span class="mi">5</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39;a&#39;</span> <span class="o">==</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Ho Ho&quot;</span> <span class="o">==</span> <span class="s">&quot;Ho Ho&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mf">3.432</span> <span class="o">==</span> <span class="mf">3.432</span>
<span class="kt">True</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Ord</code> призначений для типів, що мають впорядкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="o">&gt;</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі типи, що ми розглядали досі, за винятком функцій, є частиною <code>Ord</code>. <code>Ord</code> покриває всі стандартні функції порівняння, такі як <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> та <code>&lt;=</code>. Функції порівнянь беруть два члени <code>Ord</code> того самого типу, і повертають впорядкування <code>Ordering</code>. <code>Ordering</code> є типом, що може бути <code>GT</code>, <code>LT</code> або <code>EQ</code>, що відповідно означає більше ніж, меньше ніж, або дорівнює.</p></div>
<div class="paragraph"><p>Щоб бути членом <code>Ord</code> тип має зпочатку мати членство в престижному та ексклюзивному клубі <code>Eq</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="o">&lt;</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Abrakadabra&quot;</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="s">&quot;Zebra&quot;</span>
<span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">5</span> <span class="p">`</span><span class="n">compare</span><span class="p">`</span> <span class="mi">3</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Show</code> можуть бути представлені як рядкі. Всі типи, що розглядались досі, за винятком функцій, є частиною <code>Show</code>. Найбільш уживана функція, що має справу з типокласом <code>Show</code> є <code>show</code>. Вона бере значення, чий тип є членом <code>Show</code>, та представляє його нам як рядок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mi">3</span>
<span class="s">&quot;3&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="mf">5.334</span>
<span class="s">&quot;5.334&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">show</span> <span class="kt">True</span>
<span class="s">&quot;True&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Read</code> є дещо протилежним типокласом до <code>Show</code>. Функція <code>read</code> бере рядок, та повертає тип, який є членом <code>Read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;True&quot;</span> <span class="o">||</span> <span class="kt">False</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;8.2&quot;</span> <span class="o">+</span> <span class="mf">3.8</span>
<span class="mf">12.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="o">-</span> <span class="mi">2</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="o">++</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Доки досить. Знову, всі типи, розглянуті до сих пір, знаходяться в цьому типокласі. Але що відбудеться, якщо ми тільки зробимо <code>read "4"</code>?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;4&quot;</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">Ambiguous</span> <span class="kr">type</span> <span class="n">variable</span> <span class="p">`</span><span class="n">a&#39;</span> <span class="kr">in</span> <span class="n">the</span> <span class="n">constraint</span><span class="kt">:</span>
      <span class="p">`</span><span class="kt">Read</span> <span class="n">a&#39;</span> <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">read&#39;</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">7</span>
    <span class="kt">Probable</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">a</span> <span class="kr">type</span> <span class="n">signature</span> <span class="n">that</span> <span class="n">fixes</span> <span class="n">these</span> <span class="kr">type</span> <span class="n">variable</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Що GHCI тут нам каже, це те, що він не знає, що ми бажаємо повернути. Зауважте, що в попередніх використаннях <code>read</code> ми робили дещо з результатом після цього. Таким чином, GHCI міг вивести, який тип результату ми бажали від <code>read</code>. Якщо ми б використовували це як логічне, він би знав, що треба повертати <code>Bool</code>. Але тепер він знає, що ми бажаємо деякий тип, що є частиною класу <code>Read</code>, він тільки не знає, який саме. Давайте поглянемо на сигнатуру типу <code>read</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">read</span>
<span class="nf">read</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Read</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Бачите? Він повертає тип, що є частиною <code>Read</code>, але якщо ми потім не спробуємо використати його якось далі, немає шляху дізнатись, що саме цей тип. Ось чому ми можемо використовувати явні анотації типів. Анотації типів є шлях явно сказати, яким має бути тип виразу. Ми робимо це, додаючи <code>::</code> наприкінці виразу, та потім вказавши тип. Дивіться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">read</span> <span class="s">&quot;5&quot;</span> <span class="ow">::</span> <span class="kt">Float</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;[1,2,3,4]&quot;</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">read</span> <span class="s">&quot;(3, &#39;a&#39;)&quot;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість виразів такі, що компілятор може вивести їх тип самотужки. Але іноді компілятор не знає, чи треба повертати значення типу <code>Int</code> або <code>Float</code> для виразів як <code>read "5"</code>. Щоб побачити, який тип є насправді, Haskell мав би насправді обчислити <code>read "5"</code>. Але оскільки Haskell є статично типізованою мовою, він має знати всі типи перед компіляцією кода (або в випадку GHCI, обчисленням). Так що ми маємо сказати Haskell: "Йо, цей вираз має бути такого типу, в випадку якщо ти не знаєш!".</p></div>
<div class="paragraph"><p><code>Enum</code> члени є послідовно впорядкованими типами — вони можуть бути перелічені. Головна перевага типокласу <code>Enum</code> в тому, що ми можемо використовувати його типи як диапазони списків. Вони також мають визначені попередників та послідовників, що ви можете отримати функціями <code>succ</code> та <code>pred</code>. Типи в цьому класі: <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> та <code>Double</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;e&#39;</span><span class="p">]</span>
<span class="s">&quot;abcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kt">LT</span> <span class="o">..</span> <span class="kt">GT</span><span class="p">]</span>
<span class="p">[</span><span class="kt">LT</span><span class="p">,</span><span class="kt">EQ</span><span class="p">,</span><span class="kt">GT</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">3</span> <span class="o">..</span> <span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">succ</span> <span class="sc">&#39;B&#39;</span>
<span class="sc">&#39;C&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Члени <code>Bounded</code> мають верхню та нижню межу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="o">-</span><span class="mi">2147483648</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Char</span>
<span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">minBound</span> <span class="ow">::</span> <span class="kt">Bool</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>minBound</code> та <code>maxBound</code> є цікаві, бо вони мають тип <code>(Bounded a) =&gt; a</code>. В деякому сенсі вони є поліморфними константами.</p></div>
<div class="paragraph"><p>Всі тапли також є частиною <code>Bounded</code>, якщо в ньому також їх компоненти.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">maxBound</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Bool</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Char</span><span class="p">)</span>
<span class="p">(</span><span class="kt">True</span><span class="p">,</span><span class="mi">2147483647</span><span class="p">,</span><span class="sc">&#39;</span><span class="se">\1114111</span><span class="sc">&#39;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Num</code> є числовим типокласом. Його члени мають властивість діяти як числа. Давайте дослідимо тип числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="mi">20</span>
<span class="mi">20</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Виглядає так, що цілі числа також є поліморфними константами. Вони можуть діяти як любий тип, що є членом типокласу <code>Num</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="mi">20</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Float</span>
<span class="mf">20.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">20</span> <span class="ow">::</span> <span class="kt">Double</span>
<span class="mf">20.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Це ті типи, що належать до типокласа <code>Num</code>. Якщо ми перевіримо тип <code>*</code>, ми побачимо, що він приймає всі числа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Він приймає всі числа того самого типу, та повертає число того ж типу. Ось чому <code>(5 :: Int) * (6 :: Integer)</code> призведе до посилки типу, тоді як `5 * (6 
</dt>
<dd>
<p>
Integer)` буде робити досить добре, та спродукує <code>Integer</code>, оскільки <code>5</code> може діяти як <code>Integer</code> або <code>Int</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Щоб поєднати <code>Num</code>, тип має вже бути друзями з <code>Show</code> та <code>Eq</code>.</p></div>
<div class="paragraph"><p><code>Integral</code> є також числовим типокласом. <code>Num</code> включає всі числа, включаючи дійсні числа та цілі числа, <code>Integral</code> включає тільки цілі числа. В цьому типокласі <code>Int</code> та <code>Integer</code>.</p></div>
<div class="paragraph"><p><code>Floating</code> включає тільки числа з плаваючою крапкою, <code>Float</code> та <code>Double</code>.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Дуже корисна функція для справ з числами є <code>fromIntegral</code>. Вона має декларацію типу <code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. З цієї декларації типів ми бачимо, що він приймає ціле число, та перетворює його в більш загальне число. Це корисно, коли ви бажаєте, щоб цілі та з плаваючою крапкою гарно робили поспіль. Наприклад, функція <code>length</code> має декларацію типу <code>length :: [a] -&gt; Int</code>, замість мати більш загальний тип `(Num b) &#8658; length 
</dt>
<dd>
<p>
[a] &#8594; b`. Я думаю, це має історичні причини або щось таке, хоча, як до мене, це дурниці. В жодному разі, якщо ви отримаєте довжину списку, та потім додасте її до <code>3.2</code>, ми отримаємо помилку, бо ми намагались додати разом <code>Int</code> та число з плаваючою крапкою. Щоб уникнути цього ми робимо <code>fromIntegral (length [1,2,3,4]) + 3.2</code>, і тоді це буде робити.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Зауважте, що <code>fromIntegral</code> має декілька класових обмежень в своїй сигнатурі типу. Це повністю валідне, та як ви можете бачити, обмеження класів відокремлені комами в дужках.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/pattern.png" alt="images/pattern.png" />
</span>
Ця глава дослідить деякі з крутих синтаксичних конструкцій Haskell, і ми почнемо зі співпадіння шаблонів. Співпадіння шаблонів складається з вказання шаблонів, яким мають відповідати деякі дані, та потім перевірити, чи це так, та деконструювати дані відповідно до ціх шаблонів.</p></div>
<div class="paragraph"><p>Коли визначаєте функції, ви можете визначити окремі тіла функції для різних шаблонів. Це призводить до дійсно милого коду, що простий та читається. Ви можете перевіряти шаблони на кожному типі — числах, символах, списках, таплах, тощо. Давайте зробимо насправді тривіальну функцію, що перевіряє, чи надане нами число сімка, або ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">lucky</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lucky</span> <span class="mi">7</span> <span class="ow">=</span> <span class="s">&quot;LUCKY NUMBER SEVEN!&quot;</span>
<span class="nf">lucky</span> <span class="n">x</span> <span class="ow">=</span> <span class="s">&quot;Sorry, you&#39;re out of luck, pal!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми викликаємо <code>lucky</code>, шаблони будуть перевірятись згори донизу, і коли шаблон буде задовільнятись, відповідне тіло буде використовуватись. Єдиний спосіб, як число може задовільніти першому шаблону - якщо це <code>7</code>. Якщо ні, керування провалюється до другого шаблону, що співпадає з будь чим, та прикріпляє його до <code>x</code>. Ця функція також може бути реалізованою через використання твердження <code>if</code>. Але що, коли ми бажаємо функцію, що каже числа від <code>1</code> до <code>5</code>, та каже "Not between 1 and 5" для любого іншого числа? Без співпадіння шаблоній ми будемо швидко втягнуті в дерево <code>if then else</code>. Однак з шаблонами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sayMe</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">sayMe</span> <span class="mi">1</span> <span class="ow">=</span> <span class="s">&quot;One!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">2</span> <span class="ow">=</span> <span class="s">&quot;Two!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">3</span> <span class="ow">=</span> <span class="s">&quot;Three!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">4</span> <span class="ow">=</span> <span class="s">&quot;Four!&quot;</span>
<span class="nf">sayMe</span> <span class="mi">5</span> <span class="ow">=</span> <span class="s">&quot;Five!&quot;</span>
<span class="nf">sayMe</span> <span class="n">x</span> <span class="ow">=</span> <span class="s">&quot;Not between 1 and 5&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо ми перемістмо останній шаблон (спіймати все) догори, він завжди буде казати "Not between 1 and 5", оскільки він буде ловити всі числа без шансу провалитись, та перевірити всі інші шаблони.</p></div>
<div class="paragraph"><p>Згадайте функцію факторіала, що ми реалізували до цього? Ми визначали <code>factorial</code> числа <code>n</code> як добуток <code>[1..n]</code>. Ми також можемо визначити функцію факториала рекурсивно, спосіб, що зазвичай використовується в математиці. Ми починаємо, кажучи що факторіал <code>0</code> є <code>1</code>. Потім ми кажемо, що факторіал любого позитивного цілого є це ціле, помножене на факторіал свого попередника. Ось як це виглядає, перекладене в терміни Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">factorial</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">factorial</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це перший раз, коли ми визначили функцію рекурсивно. Рекурсія важлива в Haskell, і пізніше ми поглянемо на неї ближче. Але ось що відбувається, коли ми беремо факторіал, скажімо, <code>3</code>. Він намагаться обчислити <code>3 * factorial 2</code>. Факторіал 2 є <code>2 * factorial 1</code>, так що досі ми маємо <code>3 * (2 * factorial 1)</code>. <code>factorial 1</code> є <code>1 * factorial 0</code>, так що ми маємо <code>3 * (2 * (1 * factorial 0))</code>. Тепер настає час трюку — ми визначили факторіал <code>0</code> як просто <code>1</code>, та оскільки це підпадає під той шаблон, що іде до загального випадка, він просто повертає <code>1</code>. Так що остаточний результат еквівалентний до <code>3 * (2 * (1 * 1))</code>. Якщо б ми написали другий шаблон над першим, він би відловлював всі числа, включаючи 0, і наші обчислення ніколи б не закінчились. Ось чому порядок важливий, коли вкзуєте шаблони, і завжди краще вказувати найбільш специфічні першими, та більш загальні потім.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може схибити. Якщо ми визначимо функцію ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">charName</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">charName</span> <span class="sc">&#39;a&#39;</span> <span class="ow">=</span> <span class="s">&quot;Albert&quot;</span>
<span class="nf">charName</span> <span class="sc">&#39;b&#39;</span> <span class="ow">=</span> <span class="s">&quot;Broseph&quot;</span>
<span class="nf">charName</span> <span class="sc">&#39;c&#39;</span> <span class="ow">=</span> <span class="s">&quot;Cecil&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>та потім спробуємо викликати її маючи на вході щось неочікуване, ось що трапиться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;a&#39;</span>
<span class="s">&quot;Albert&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;b&#39;</span>
<span class="s">&quot;Broseph&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;h&#39;</span>
<span class="s">&quot;*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона скаржиться, що ми маємо невиключні шаблони, і це так і є насправді. При створенні шаблонів нам слідує завжди включати загальні шаблони, так що наша програма не завалиться, якщо ми отримаємо неочікуваний вхід.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може використовувати тапли. Що, коли ми бажаємо створити функцію, що приймає два вектори в 2D просторі (що є в формі пар), та додає їх разом? Щоб додати разом два вектори, ми додаємо їх <code>x</code> компоненти окремо, та потім їх <code>y</code> компоненти окремо. Ось що ми можемо зробити, якщо ви не знаємо про співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addVectors</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">addVectors</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="n">fst</span> <span class="n">a</span> <span class="o">+</span> <span class="n">fst</span> <span class="n">b</span><span class="p">,</span> <span class="n">snd</span> <span class="n">a</span> <span class="o">+</span> <span class="n">snd</span> <span class="n">b</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, це робить, але існує кращий шлях, щоб зробити це. Давайте модифікуємо функцію, так щоб вона використовувала співпадіння шаблонів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addVectors</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
<span class="nf">addVectors</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="p">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ось так! Значно краще. Зауважте, що це все ще загальний шаблон. Тип <code>addVectors</code> (в обох випадках) є `addVectors 
</dt>
<dd>
<p>
(Num a) &#8658; (a, a) &#8594; (a, a) - &gt; (a, a)`, так що ми гарантовано отримуємо дві пари як параметри.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>fst</code> та <code>snd</code> виділяють компоненти з пар. Але що з трійками? Гаразд, немає готової функції, щоб зробити це, але ми можемо створити власну.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">first</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">first</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>

<span class="nf">second</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">second</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">y</span>

<span class="nf">third</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">third</span> <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="kr">_</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Знак <code>_</code> означає ту саму річ, що він робить в осяжностях списків. Це означає, що насправді нам байдуже, що є в цій частині, так що пи просто пишемо <code>_</code>.</p></div>
<div class="paragraph"><p>Що нагадує мені, що ви також можете робити співпадіння в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="n">a</span><span class="o">+</span><span class="n">b</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли співпадіння схибить, він буде тільки переходити на наступний елемент.</p></div>
<div class="paragraph"><p>Самі списки також можуть використовуватись в співпадінні шаблонів. Ви можете порівнювати з порожнім списком <code>[]</code>, або любим шаблоном, що включає <code>:</code> та порожній список. Але оскільки <code>[1,2,3]</code> є тільки синтаксичним цукром для <code>1:2:3:[]</code>, ви також можете використовувати і такий шаблон. Шаблон як <code>x:xs</code> буде прикріпляти голову списку до <code>x</code>, та залишок до <code>xs</code>, навіть якщо був один елемент, так що <code>xs</code> в кінці буде порожнім списком.</p></div>
<div class="paragraph"><p>Note: Шаблон <code>x:xs</code> багато використовується, особливо з рекурсивними функціями. Але шаблони, що мають в собі <code>:</code>, співпадають тільки зі списками довжини 1 або більше.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте прикріпити, скажімо, перші три елементи до змінних, та залишок до іншої змінної, ви можете використовувати щось подібне до <code>x:y:z:zs</code>. Це буде співпадати тільки зі списками, що мають три елементи або більше.</p></div>
<div class="paragraph"><p>Тепер ми знаємо, як порівнювати шаблони зі списками, давайте створими нашу власну реалізацію функції <code>head</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;Can&#39;t call head on an empty list, dummy!&quot;</span>
<span class="nf">head&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевіримо, чи вона робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head&#39;</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="mi">4</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head&#39;</span> <span class="s">&quot;Hello&quot;</span>
<span class="sc">&#39;H&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарно! Зауважте, що якщо ви бажаєте прикріпити декілька змінних (навіть якщо одна з них просто <code>_</code>, та взагалі нічого не прикріплює), ми маємо оточити їх в дужки. Також зауважте функцію <code>error</code>, яку ми використовуємо. Вона приймає рядок та генерує помилку часу виконання, використовуючи рядок як інформацію щодо різновиду виникшої помилки. Це призводить до падіння програми, так що недобре використовувати її дуже багато. Але виклик <code>head</code> на порожньому списку не має сенсу.</p></div>
<div class="paragraph"><p>Давайте створимо тривіальну функцію, що каже нам перші елементи списку в зручній англійській формі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">tell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Show</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tell</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="s">&quot;The list is empty&quot;</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:[]</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The list has one element: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:[]</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The list has two elements: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span class="nf">tell</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">y</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;This list is long. The first two elements are: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція безпечна, оскільки вона турбується про порожній список, список синглтон, список з двома елементами, та списки з більше двох елементів. Зауважте, що <code>(x:[])</code> та <code>(x:y:[])</code> можуть бути переписані як <code>[x]</code> та <code>[x,y]</code> (завдяки синтаксичному цукру нам не потрібні дужки). Ми не можемо переписати <code>(x:y:_)</code> з квадратними дужками, оскільки він співпадає зі списком довжини 2 або більше.</p></div>
<div class="paragraph"><p>Ми вже реалізовали нашу власну функцію <code>length</code> використовуючи осяжність списків. Тепер ми зробимо це, використовуючи співпадіння шаблонів та трохи рекурсії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">length&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">b</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">length&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">length&#39;</span> <span class="p">(</span><span class="kr">_</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Це подібно до функції <code>factorial</code>, що ми писали раніше. Спочатку ми визначили результат для відомого входу — порожнього списку. Це також відомо як гранична умова. Потім в другому шаблоні ми розбиваємо список на частки, відділяючи голову та хвіст. Ми кажемо, що довжина дорівнює 1 плюс довжина хвоста. Ми використовуємо <code>_</code> для співпадіння з головою, оскільки нам насправді байдуже, що це. Також зауважте, що ми потурбувались про всі можливі шаблони для списку. Перший шаблон співпадає з порожнім списком, та другий співпадає з будь чим, що не є порожнім списком.</p></div>
<div class="paragraph"><p>Давайте подивимось, що коли ми викличемо <code>length'</code> на <code>"ham"</code>. Спочатку ми перевіримо, чи це порожній список, і через те, що це не так, ми провалимось до другого шаблону. Це співпадає з другим шаблоном, і каже, що довжина є <code>1 + length' "am"</code>, оскільки ми розбили рядок на голову і хвіст, та відкинули голову. Гаразд. Довжина <code>length'</code> від <code>"am"</code> подібним чином є <code>1 + length' "m"</code>. Так що прямо зараз ми маємо <code>1 + (1 + length' "m")</code>. <code>length' "m"</code> є <code>1 + length' ""</code> (також можна записати як <code>1 + length' []</code>). І ми визначили <code>length' []</code> як <code>0</code>. Так що в кінці ми маємо <code>1 + (1 + (1 + 0))</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо <code>sum</code>. Ми знаємо, що сума порожнього списку є 0. Запишемо це в вигляді шаблону. І ми також знаємо, що сума списку є голова, плюс сума залишку списку. Коли ми запишемо все це, ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sum&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є така річ, що називається <code>as</code> шаблонами. Це зручний спосіб розбити щось відповідно до шаблону, та прикріпити частки до імен, при цьому зберігаючи посилання на цілу річ. Ви робите це, покладаючи ім'я та знак <code>@</code> перед шаблоном. Наприклад, шаблон <code>xs@(x:y:ys)</code>. Цей шаблон буде співпадати точно з тією самою річчю, що і <code>x:y:ys</code>, але ви можете просто отримати цілий список через <code>xs</code>, замість повторювати себе через повторний набір <code>x:y:ys</code> в тілі функції. Ось швидкий та брудний приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">capital</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">capital</span> <span class="s">&quot;&quot;</span> <span class="ow">=</span> <span class="s">&quot;Empty string, whoops!&quot;</span>
<span class="nf">capital</span> <span class="n">all</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;The first letter of &quot;</span> <span class="o">++</span> <span class="n">all</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">capital</span> <span class="s">&quot;Dracula&quot;</span>
<span class="s">&quot;The first letter of Dracula is D&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно ми використовуємо шаблони щоб уникнути повторення себе, коли порівнення з більшим шаблоном, коли ми використовуємо цілу річ в тілі функції.</p></div>
<div class="paragraph"><p>Ще одна річ — ви не можете використовувати <code>++</code> в співпадіннях шаблонів. Якщо ви спробуєте порівняти шаблон з <code>(xs ++ ys)</code>, що буде першим списком, та що буде другим списком? Це не має великого сенсу. Буде мати сенс порівняти з <code>(xs ++ [x,y,z])</code> або просто <code>(xs ++ [x])</code>, але завдяки природі списків ви не можете зробити цього.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/guards.png" alt="images/guards.png" />
</span>
В той час, коли шаблони є шляхом переконатись, що значення відповідає деякій формі, та деконструкції, охоронці є шляхом перевірити, чи деяка властивість значення (або декілька з них) є <code>true</code> або <code>false</code>. Це звучить як твердження <code>if</code>, і є дуже подібним. Річ в тому, що охоронці значно легше читаються, коли ви маєте декілька умов, і вони грають добре в команді з шаблонами.</p></div>
<div class="paragraph"><p>Замість пояснення їх синтаксису, давайте просто зануримось, та створимо функцію з використанням охоронців. Ми збираємось створити просту функцію, що кваліфікує вас відповідно до вашого індексу BMI (body mass index). Ваш BMI дорівнює вашій вазі, поділеній на ваш зріст в квадраті. Якщо ваш BMI менший за 18.5, в вас недостатньо ваги. Якщо ви десь між 18.5 до 25, ви відповідаєте нормі. Від 25 до 30 є надмірною вагою, і більше 30 це ожиріння. Так що ось функція (ми не будемо обчислювати прямо зараз, ця функція обчислює BMI та каже результат):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">bmi</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Охоронці позначаються стовпчиками, що слідують за ім'ям функції та її параметрами. Зазвичай вони відступають трохи вправо, та відрівняні між собою. Охоронець в основі є логічний вираз. Якщо він обчислюється до <code>True</code>, тоді використовується відповідне тіло функції. Якщо він обчислюється до <code>False</code>, перевірка переходить до наступного охоронця і так далі. Якщо ми викличемо цю функцію з 24.3, вона спочатку перевірить, чи це меньше або рівне ніж 18.5. Оскільки це ні, переходимо до наступного охоронця. Перевірка каже, що другій охоронець пропускає, бо 24.3 меньше ніж 25.0, і повертається другий рядок.</p></div>
<div class="paragraph"><p>Це дуже нагадує велике дерево з <code>if</code> <code>else</code> в імперативних мовах, тільки це значно краще і гарно читається. Хоча великі дерева <code>if else</code> звичайно не схвалюються, іноді проблема виражена в такий дискретний спосіб, що ви не можете це обійти. Охоронці є гарною альтернативою для цього.</p></div>
<div class="paragraph"><p>Дуже часто останній охоронець є <code>otherwise</code>. <code>otherwise</code> визначене просто як <code>otherwise = True</code>, і відловлює все. Це дуже подібне до шаблонів, тільки вони превірять, чи задовільняє вхід шаблону, а охоронці перевіряють логічні умови. Якщо всі охоронці функції обчислюються до <code>False</code> (і ми не надали загального охоронця <code>otherwise</code>), обчислення провалюється до наступного шаблону. Ось як шаблони та охоронці гарно грають разом. Якщо не знайдено підходящого охоронця або шаблона закидається помилка.</p></div>
<div class="paragraph"><p>Звичайно, ми можемо використовувати охоронців з функціями, що приймають так багато параметрів, як нам треба. Замість того, щоб користувач обчислював власний BMI перед викликом функції, давайте модифікуємо цю функцію, так що вона братиме висоту та вагу, та розрахує все за нас.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>                 <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивимось, чи я гладкий &#8230;</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">bmiTell</span> <span class="mi">85</span> <span class="mf">1.90</span>
<span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау! Я не товстий! Але Haskell все одно назвав мене огидним. Чортзна що!</p></div>
<div class="paragraph"><p>Зауважте, що немає <code>=</code> прямо після імені функції та її параметрами, перед першим охоронцем. Багато новачків отримують синтаксичну помилку, оскільки вони часто ставлять там рівняння.</p></div>
<div class="paragraph"><p>Інший дуже простий приклад: давайте реалізуєма власну функцію <code>max</code>. Якщо ви пам'ятаєте, вона приймає дві речі, що можна порівняти, та повертає більше з них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">max&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">max&#39;</span> <span class="n">a</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>     <span class="ow">=</span> <span class="n">a</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Охоронці можуть бути записані в один рядок, хоча я не раджу цього, оскільки це менш читається, навіть для дуже коротких функцій. Але для демонстрації запишемо <code>max'</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">max&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">max&#39;</span> <span class="n">a</span> <span class="n">b</span> <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Йо! Не читається взагалі! Рухаємось далі: давайте реалізуємо власну <code>compare</code> через використання охоронців.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">myCompare</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">a</span> <span class="p">`</span><span class="n">myCompare</span><span class="p">`</span> <span class="n">b</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span>     <span class="ow">=</span> <span class="kt">GT</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>    <span class="ow">=</span> <span class="kt">EQ</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kt">LT</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="p">`</span><span class="n">myCompare</span><span class="p">`</span> <span class="mi">2</span>
<span class="kt">GT</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: ми не тільки можемо викликати функції інфіксно з апострофами, ми також можемо визначати їх з апострофами. Іноді так їх легше прочитати.</p></div>
<div class="paragraph"><p>В попередньому розділі ми визначили калькулятор BMI таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>                   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що ми повторили себе тут три рази поспіль. Ми повторили себе три рази. Повторити себе (три рази) при програмуванні так само бажано, як вдаритись головою. Оскільки ми повторили вираз три рази, було б ідеальним, щоб ми могли обчислити його один раз, прікріпити до імені, і потім використовувати це ім'я замість виразу. Гаразд, ми можемо модифікувати нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми поклали ключове слово <code>where</code> після охоронців (зазвичай краще відступити так само, як здвинуті риски), та потім ми визначаємо декікька імен або функцій. Ці імена видимі в охоронцях, та дають нам перевагу не мати повторювати самих себе. Якщо ми вирішимо, що треба обчислювати BMI трохи інакше, ми маємо змінити це тільки один раз.  Це також покращує читабельність, надаючи імена речам, і може зробити наші програми видшими, оскільки такі речі, як наша змінна <code>bmi</code>, обчислюються тільки один раз. Ми можемо піти трохи далі, та представити нашу функцію таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">bmiTell</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">bmiTell</span> <span class="n">weight</span> <span class="n">height</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">skinny</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">normal</span> <span class="ow">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="n">fat</span>    <span class="ow">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>     <span class="ow">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
          <span class="n">skinny</span> <span class="ow">=</span> <span class="mf">18.5</span>
          <span class="n">normal</span> <span class="ow">=</span> <span class="mf">25.0</span>
          <span class="n">fat</span> <span class="ow">=</span> <span class="mf">30.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Імена, які ми визначили в розділі <code>where</code> функції, видимі тількі в цій функції, так що ми не маємо турбуватись щодо забруднення простору імен інших функцій. Зауважте, що всі ці імена вирівнені в один стовпчик. Якщо ми не вирівняємо їх гарно і відповідно, Haskell буде засмучений, оскільки він не знатиме, що все це частини одного блоку.</p></div>
<div class="paragraph"><p>Прикріплення <code>where</code> не поділяються між тілами функцій для різних шаблонів. Якщо ви бажаєте, щоб декілька шаблонів однієї функції мали доступ до одного імені, ви маєте визначити його глобально.</p></div>
<div class="paragraph"><p>Ви також можете використовувати прикріплення <code>where</code> до порівняння шаблонів! Ви можете переписати розділ <code>where</code> попередньої функції таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="kr">where</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
      <span class="p">(</span><span class="n">skinny</span><span class="p">,</span> <span class="n">normal</span><span class="p">,</span> <span class="n">fat</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">18.5</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">30.0</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте створимо іншу, досить тривіальну функці, де ми отримуємо перше та останнє ім'я, та повертаємо ініціали.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">initials</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">initials</span> <span class="n">firstname</span> <span class="n">lastname</span> <span class="ow">=</span> <span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">++</span> <span class="s">&quot;. &quot;</span> <span class="o">++</span> <span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">++</span> <span class="s">&quot;.&quot;</span>
    <span class="kr">where</span> <span class="p">(</span><span class="n">f</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>
          <span class="p">(</span><span class="n">l</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо виконати це співпадіння шаблонів прямо в параметрах функції (вона насправді може бути коротшою та яснішою), але це показує тільки те, що це можливо зробити також в прикріпленнях <code>where</code>.</p></div>
<div class="paragraph"><p>Так само, як ми визначали константи в блоках <code>where</code>, ви також можете визначити функції. Дотримуючись нашої здорової теми програмування, давайте створимо функцію, що приймає список пар вага-висота, та повертає список BMI.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="n">w</span> <span class="n">h</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">]</span>
    <span class="kr">where</span> <span class="n">bmi</span> <span class="n">weight</span> <span class="n">height</span> <span class="ow">=</span> <span class="n">weight</span> <span class="o">/</span> <span class="n">height</span> <span class="o">^</span> <span class="mi">2</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось і все, що ми мали сказати про це! Причина, з якої ми мали ввести  <code>bmi</code> як функцію в цьому прикладі, це те, що ми не можемо обчислити один BMI з параметрів функції. Ми маємо перевіряти список, переданий до функції, і тут буде різний BMI для кожної пари.</p></div>
<div class="paragraph"><p><code>where</code> прикріплення також можуть бути вкладені. Це загальна ідіома, створити функцію, і визначити допоміжну функцію в її твердженні <code>where</code>, і потім надати цім функціям допоміжні функції, також, кожна в своєму власному твердженні <code>where</code>.</p></div>
<div class="paragraph"><p>Дуже подібні до <code>where</code> прикріалень є прикріплення <code>let</code>. <code>Where</code> прикріплення є синтаксичною конструкцією, що дозволяє вам прикріпляти змінні в кінці функції, та ціла функція може бачити їх, включаючи всіх охоронців. <code>Let</code> прикріплення дозволяють вам прикріпляти змінні будь де, та самі є виразами, але є дуже локальними, так що вони не поширюються серед охоронців. Так само, як любі конструкції в Haskell, що використовуються для прикріплення значень до імен, <code>let</code> прикріплення можуть використовуватись для співпадінь шаблонів. Давайте подивимось на це дії! Ось як ви можете визначити функцію, що дає нам площу циліндричної поверхні, базуючись на її висоті та радіусі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">cylinder</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">cylinder</span> <span class="n">r</span> <span class="n">h</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">sideArea</span> <span class="ow">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="n">h</span>
        <span class="n">topArea</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span><span class="mi">2</span>
    <span class="kr">in</span>  <span class="n">sideArea</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">topArea</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/letitbe.png" alt="images/letitbe.png" />
</span>
Форма є <code>let &lt;bindings&gt; in &lt;expression&gt;</code>. Імена дає вам визначити в частині <code>let</code> доступною до виразу в частині <code>in</code>. Як ви можете бачити, ви можете також виразити це як <code>where</code> прив'язку. Зауважте, що імена також вирівняні в один стовпчик. То яка різниця між ціма двома? На тепер виглядає, що <code>let</code> покладає прикріплення першими, та вираз, що використовує їх після, тоді як <code>where</code> робить це навпаки.</p></div>
<div class="paragraph"><p>Різниця в тому, що <code>let</code> прикріплення самі є виразами. <code>where</code> прикріалення є тільки синтаксичніми конструкціями. Згадайте, як ми робили твердження <code>if</code>, та пояснювали, що твердження <code>if else</code> є виразом, і ви можете набивати його маже будь де?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kr">if</span> <span class="mi">5</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="kr">then</span> <span class="s">&quot;Woo&quot;</span> <span class="kr">else</span> <span class="s">&quot;Boo&quot;</span><span class="p">,</span> <span class="kr">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&gt;</span> <span class="sc">&#39;b&#39;</span> <span class="kr">then</span> <span class="s">&quot;Foo&quot;</span> <span class="kr">else</span> <span class="s">&quot;Bar&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;Woo&quot;</span><span class="p">,</span> <span class="s">&quot;Bar&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="kr">if</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="mi">5</span> <span class="kr">then</span> <span class="mi">10</span> <span class="kr">else</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете робити це за допомогою <code>let</code> прикріплень.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="o">*</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">9</span> <span class="kr">in</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
<span class="mi">42</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони також можуть бути використані для введення функцій в локальному полі зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="kr">let</span> <span class="n">square</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="kr">in</span> <span class="p">(</span><span class="n">square</span> <span class="mi">5</span><span class="p">,</span> <span class="n">square</span> <span class="mi">3</span><span class="p">,</span> <span class="n">square</span> <span class="mi">2</span><span class="p">)]</span>
<span class="p">[(</span><span class="mi">25</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми бажаємо прикріпити декілька змінних разом, ми, вочевидь, не можемо вирівняти їх в вигляді стовпчика. Ось чому ми можемо розділити крапками з комою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="n">a</span> <span class="ow">=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">b</span> <span class="ow">=</span> <span class="mi">200</span><span class="p">;</span> <span class="n">c</span> <span class="ow">=</span> <span class="mi">300</span> <span class="kr">in</span> <span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kr">let</span> <span class="n">foo</span><span class="ow">=</span><span class="s">&quot;Hey &quot;</span><span class="p">;</span> <span class="n">bar</span> <span class="ow">=</span> <span class="s">&quot;there!&quot;</span> <span class="kr">in</span> <span class="n">foo</span> <span class="o">++</span> <span class="n">bar</span><span class="p">)</span>
<span class="p">(</span><span class="mi">6000000</span><span class="p">,</span><span class="s">&quot;Hey there!&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви не маєте ставити крапку з комою після останнього прикріплення, але ви можете це зробити, якщо бажаєте. Як ми казали раніше, ви можете робити порівняння шаблонів з <code>let</code> прикріпленнями. Вони дуже корисні для швидкого розбирання тапла на компоненти, та прикріплення їх до імен, або чогось подібного.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="kr">in</span> <span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
<span class="mi">600</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете покласти <code>let</code> прикріплення в осяжності списків. Давайте перепишемо наші попередні приклади обчислення списків пар ваги-висоти, щоб використовувати <code>let</code> в осяжності списків, замість визначення зовнішньої функції за допомогою <code>where</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span> <span class="o">^</span> <span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми включили <code>let</code> в осяжність списків, майже так само як предикат, але він не фільтрує список, але тільки прив'язує імена. Імена, визначені в <code>let</code> всередині осяжності списків, видимий для функції виводу (частина перед <code>|</code>), та всі предикати та розділи, що ідуть після прикріплення. Так що ви можете зробити, щоб функція повертала тільки BMI для товстих людей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">calcBmis</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">RealFloat</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">calcBmis</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[</span><span class="n">bmi</span> <span class="o">|</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="kr">let</span> <span class="n">bmi</span> <span class="ow">=</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span> <span class="o">^</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bmi</span> <span class="o">&gt;=</span> <span class="mf">25.0</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо використовувати ім'я <code>bmi</code> в частині <code>(w, h) &lt;- xs</code>, оскільки вона визначена перед прикріпленням <code>let</code>.</p></div>
<div class="paragraph"><p>Ми оминули частину <code>in</code> прикріалення <code>let</code>, коли ми використовуємо їх в осяжностях списків, оскільки видимість імен тут завжди передвизначена. Однак ми можемо використовувати <code>let</code> в прикріпленні в предикаті, та визначені імена будуть видимі тільки в ціх предикатах. Частину <code>in</code> також можна оминути при визначенні функцій і констант прямо в GHCi. Якщо ми зробимо це, імена будуть видимі на протязі цілої інтерактивної сессії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">zoot</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zoot</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">2</span>
<span class="mi">29</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">boot</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="kr">in</span> <span class="n">boot</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">2</span>
<span class="mi">14</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">boot</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span> <span class="kt">Not</span> <span class="kr">in</span> <span class="n">scope</span><span class="kt">:</span> <span class="p">`</span><span class="n">boot&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо <code>let</code> прикріплення такі круті, ви можете запитати, чому не використовувати їх весь час замість прикріплень <code>where</code>? Гаразд, оскільки <code>let</code> прикріплення є виразами та досить локальні в плані видимості, вони не можуть використовуватись серед охоронців. Деякі люди обирають <code>where</code> прикріалення, оскільки імена ідуть після функції, де вони використовуються. Таким чином, тіло функції ближче до його імені та його типу, і для декого це краще читати.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/case.png" alt="images/case.png" />
</span>
Багато імперативних мов (C, C++, Java, etc.) мають <code>case</code> синтаксис, і якщо ви колись програмували на них, ви можливо знаєте про що іде мова. Береться змінна, та потім виконуються блоки коду для специфічних значень цієї змінної, і можливо включає блок спіймати-всіх на випадок, коли змінна має значення, для якого ми не встановили <code>case</code>.</p></div>
<div class="paragraph"><p>Haskell приймає цю концепцію і покращує її. Як підказує ім'я, <code>case</code> вирази є, гаразд, виразами, подібно до <code>if else</code> виразів та <code>let</code> прикріплень. Ми не тільки можемо обчислювати вирази на основі можливих варіантів змінної, ми також можемо робити співпадіння шаблонів. Хммм, беремо змінну, порівнюємо її з шаблоном, обчислюємо частини коду на основі цього значення, де ми вже це бачили? Так, порівняння шаблонів на параметрах в визначеннях функції! Гаразд, це тільки синтаксичний цукор для <code>case</code>. Ці дві частини коду роблять те саме, і взаємозамінні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;No head for empty lists!&quot;</span>
<span class="nf">head&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="s">&quot;No head for empty lists!&quot;</span>
                      <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="kr">_</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис для <code>case</code> виразів є доволі простий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">expression</span> <span class="kr">of</span> <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="n">pattern</span> <span class="ow">-&gt;</span> <span class="n">result</span>
                   <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>expression</code> порівнюється відносно <code>pattern</code>-ів. Порівняння шаблонів діє як очікується: перший шаблон, що співпадає з виразом, буде використаний. Якщо це провалюється через вираз <code>case</code>, і підходящого шаблону не знайдено, виникає помилка часу виконання.</p></div>
<div class="paragraph"><p>Хоча співпадіння на параметрах функцій може виконуватись тільки при визначенні функції, <code>case</code> вирази можуть бути використані майже будь де. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">describeList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">describeList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;The list is &quot;</span> <span class="o">++</span> <span class="kr">case</span> <span class="n">xs</span> <span class="kr">of</span> <span class="kt">[]</span> <span class="ow">-&gt;</span> <span class="s">&quot;empty.&quot;</span>
<span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="s">&quot;a singleton list.&quot;</span>
<span class="nf">xs</span> <span class="ow">-&gt;</span> <span class="s">&quot;a longer list.&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони корисні для порівняння шаблонів з чимось всередині виразу. Оскільки співпадіння шаблонів в функції є синтаксичним цукром для <code>case</code> виразів, ми можемо також визначити це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">describeList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">describeList</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;The list is &quot;</span> <span class="o">++</span> <span class="n">what</span> <span class="n">xs</span>
    <span class="kr">where</span> <span class="n">what</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="s">&quot;empty.&quot;</span>
          <span class="n">what</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="s">&quot;a singleton list.&quot;</span>
          <span class="n">what</span> <span class="n">xs</span> <span class="ow">=</span> <span class="s">&quot;a longer list.&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/recursion.png" alt="images/recursion.png" />
</span>
Ми коротко згадували рекурсію в попередній главі. В цій главі ми близько розглянемо рекурсію, чому вона важлива для Haskell, та як ми можете виробляти дуже стислі та елегантні рішення до проблем, розмірковуючи рекурсивно.</p></div>
<div class="paragraph"><p>Якщо ви все ще не знаєте що таке рекурсія, прочитайте це речення. Ха! Це просто жарт! Насправді рекурсія є шляхом визначення функцій, в яких функція застосовується в своєму власному визначенні. Визначення в математиці часто даються рекурсивно. Наприклад, послідовність Фібоначчі визначається рекурсивно. Спочатку ми визначаємо перші два числа Фібоначчі нерекурсивно. Ми кажемо, що <code>F(0) = 0</code> та <code>F(1) = 1</code>, що означає, що перший і другий елементи послідовності є <code>0</code> та <code>1</code>, відповідно. Потім ми кажемо, що для кожного іншого натурального числа число Фібоначчі є сумою попередніх двох чисел послідовності. Так що <code>F(n) = F(n-1) + F(n-2)</code>. Таким чином, <code>F(3)</code> є <code>F(2) + F(1)</code>, що є <code>(F(1) + F(0)) + F(1)</code>. Оскільки ми тепер дійшли до тільки нерекурсивно визначених чисел Фібоначчі, ми можемо безпечно сказати, що <code>F(3)</code> є <code>2</code>. Маючи елемент або два в рекурсивньому визначенні, визначені нерекурсивно, (як <code>F(0)</code> та <code>F(1)</code> тут), що також називаються граничними умовами, і важливо, якщо ви бажаєте, щоб ваша рекурсивна функція завершилась. Якщо ви не визначили <code>F(0)</code> та <code>F(1)</code> нерекурсивно, ви ніколи не отримаєте рішення для любого значення, бо дійдете до нуля, та потім пійдете по від'ємним числам. З часом ви дізнаєтесь, що <code>F(-2000)</code> є <code>F(-2001) + F(-2002)</code>, і все ще кінця цьому не буде видно!</p></div>
<div class="paragraph"><p>Рекурсія важлива в Haskell, оскільки на відміну від імперативних мов, ви робите обчислення в Haskell через декларацію, що є дещо, замість декларування того, як це треба отримати. Ось чому немає <code>while</code> циклів або <code>for</code> циклів в Haskell, і замість ми багато раз маємо використовувати рекурсію для декларування, чим є дещо.</p></div>
<div class="paragraph"><p>Функція <code>maximum</code> бере список речей, що можуть бути впорядковані (тобто примірників типокласу <code>Ord</code>), та повертає більший з них. Поміркуйте про те, як би ви реалізували це в імперативний спосіб. Ви б, можливо, встановили змінну для зберігання максимального значення, та потім би додали цикл по елементах списку, та якщо елемент більше, ніж поточне максимальне значення, ви заміщуюте його цім елементом. Максимальне значення, що залишиться в кінці, і є результат. Фу! Це досить багато слів для опису такого простого алгоритму!</p></div>
<div class="paragraph"><p>Тепер давайте подивимось, як ми визначемо це рекурсивно. Ми можемо спочатку встановити граничну умову, та сказати, що максимум синглтон списку дорівнює значенню його єдиного елементу. Потім ми можемо сказати, що максимум довшого списку є голова, якщо голова більша ніж максимум хвоста. Якщо максимум хвоста більший, гаразд, тоді максимум буде цей максимум хвоста. І все! Тепер давайте реалізуємо це в Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">maximum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">maximum&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;maximum of empty list&quot;</span>
<span class="nf">maximum&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">maxTail</span>
    <span class="kr">where</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">maximum&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, порівняння шаблонів гарно пасує до рекурсії! Більшість імперативних мов не мають порівняння шаблонів, так що ви маєте робити багато <code>if else</code> тверджень для перевірки граничних умов. тут ми просто покладаємо їх як шаблони. Так що перша гранична умова каже, якщо список порожній, це крах! Має сенс, оскільки що буде максимумом порожнього списку? Я не знаю. Другий шаблон також окреслює граничну умову. Він каже, що якщо це синглтон список - просто повернути його єдиний елемент.</p></div>
<div class="paragraph"><p>Тепер третій шаблон, де відбувається справжня дія. Ми використовуємо співпадіння шаблонів для поділу списку на голову та хвіст. Це дуже загальна ідиома при виконанні рекурсії зі списками, так що використаємо її. Ми використовуємо <code>where</code> прикріплення для визначення <code>maxTail</code> як максимума залишку списка. Коли ми перевіряємо, чи голова більша ніж максимум залишку списку. Якщо це так, ми повертаємо голову. Інакше ми повертаємо максимум залишку списку.</p></div>
<div class="paragraph"><p>Давайте візьмемо список прикладу, та перевіримо, як це буде робити з ним: <code>[2,5,1]</code>. Якщо ми викличемо для нього <code>maximum'</code>, перші два шаблони не співпадуть. Третій співпаде, і поділить список на <code>2</code> та <code>[5,1]</code>. Твердження <code>where</code> бажає знати максимум від <code>[5,1]</code>, так що ми йдемо цім шляхом. Він знову співпадає з третім шаблоном, та <code>[5,1]</code> ділиться на <code>5</code> та <code>[1]</code>. Знову, твердження <code>where</code> бажає мати максимум від <code>[1]</code>. Оскільки це гранична умова, вона повертає <code>1</code>. Нарешті! Так що підіймаємось на рівень вище, порівнюючи <code>5</code> з максимумом <code>[1]</code> (що є <code>1</code>), і очевидно отримуємо <code>5</code>. Так що ми знаємо, що максимум <code>[5,1]</code> є <code>5</code>. Ми знову підіймаємось на один рівень вище, де ми маємо <code>2</code> та <code>[5,1]</code>. Порівняння <code>2</code> з максимумом <code>[5,1]</code>, що є <code>5</code>, ми обираємо <code>5</code>.</p></div>
<div class="paragraph"><p>Навіть ясніший шлях написати цю функцію є використання <code>max</code>. Якщо ви пам'ятаєте, <code>max</code> є функцією, що приймає два числа, та повертає більше з них. Ось як ми можемо переписати <code>maximum'</code> з використанням <code>max</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">maximum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">maximum&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;maximum of empty list&quot;</span>
<span class="nf">maximum&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">max</span> <span class="n">x</span> <span class="p">(</span><span class="n">maximum&#39;</span> <span class="n">xs</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як це елегантно! В основному, максимум списку є <code>max</code> першого елементу та максимум хвоста.</p></div>
<div class="imageblock">
<div class="content">
<img src="images/maxs.png" alt="images/maxs.png" />
</div>
</div>
<div class="paragraph"><p>Тепер, коли ми знаємо, як загалом мислити рекурсивно, давайте реалізуємо декілька функцій використовуючи рекурсію. Для початку реалізуємо <code>replicate</code>. <code>replicate</code> бере <code>Int</code> та деякий елемент, та повертає список, що має декілька повторень того самого елементу. Наприклад, <code>replicate 3 5</code> повертає <code>[5,5,5]</code>. Давайте думати про граничні умови. Я маю думку, що гранична умова <code>0</code> або меньше. Якщо ми спробуємо повторити дещо нуль раз, це має повертати порожній список. Також і для негативних чисел, оскільки це не має ніякого сернсу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">replicate&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">i</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">replicate&#39;</span> <span class="n">n</span> <span class="n">x</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>    <span class="ow">=</span> <span class="kt">[]</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">replicate&#39;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми використали тут охоронців замість шаблонів, оскільки ми перевіряємо на логічні умови. Якщо <code>n</code> меньше або рівне до <code>0</code>, повертаємо порожній список. Інакше повертаємо список, що має <code>x</code> як перший елемент, та потім <code>x</code>, повторений <code>n-1</code> разів в якості хвоста. З часом частина <code>(n-1)</code> приведе нашу функцію до граничної умови.</p></div>
<div class="paragraph"><p>Note: <code>Num</code> не є субкласом до <code>Ord</code>. Це означає, що те, що належить до чисел, не обов'язково має бути впорядкованим. Ось чому ми маємо вказувати обоє обмеження, класи <code>Num</code> та <code>Ord</code>, і потім робити додавання і віднімання, а також порівняння.</p></div>
<div class="paragraph"><p>Далі ми реалізуємо <code>take</code>. Вона приймає певне число елементів зі списку. Наприклад, <code>take 3 [5,4,3,2,1]</code> буде повертати <code>[5,4,3]</code>. Якщо ми спробуємо взяти <code>0</code> або меньше елементів зі списку ми отримаємо порожній список. Зауважне ці дві граничні умови. Так що давайте запишемо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">take&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">i</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">i</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">i</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">take&#39;</span> <span class="n">n</span> <span class="kr">_</span>
    <span class="o">|</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span>   <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">take&#39;</span> <span class="kr">_</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">take&#39;</span> <span class="n">n</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">take&#39;</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/painter.png" alt="images/painter.png" />
</span>
Перший шаблон задає, що коли ми спробуємо взяти <code>0</code> або від'ємне число елементів, ми отримаємо порожній список. Зауважте, що ми використовуємо <code>_</code> для порівняння списку, оскільки нас насправді не турбує, що це в данному випадку. Також зауважте, що ми використовуємо охоронця, але без частини <code>otherwise</code>. Це означає, що якщо <code>n</code> виявиться більше ніж <code>0</code>, порівняння провалиться до наступного шаблону. Другий шаблон вказує, що якщо ми спробуємо взяти будь-що з порожнього списку, ми отримаємо порожній список. Третій шаблон розбиває список на голову та хвіст. І потім ми стверджуємо, що взяти <code>n</code> елементів зі списку те саме, що список, що має <code>x</code> в якості голови, та список, що бере <code>n-1</code> елементів з хвоста списка. Спробуйте взяти шматок папіру для запису, як виглядає це обчислення, якщо ми, скажімо, беремо <code>3</code> з <code>[4,3,2,1]</code>.</p></div>
<div class="paragraph"><p><code>reverse</code> просто обертає список. Подумайте про граничні умови. Що це буде? Гаразд &#8230; це порожній список! Порожній список обернений дорівнює самому порожньому списку. Окей. Як щодо інших варіантів? Ви можете сказати, що якщо розділити список на голову та хвіст, обернений список дорівнює оберненому хвосту, та потім голова в кінці.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">reverse&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">reverse&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">reverse&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">reverse&#39;</span> <span class="n">xs</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це все!</p></div>
<div class="paragraph"><p>Оскільки Haskell підтримує нескінчені списки, наша рекурсія насправді не обов'язково повинна мати граничну умову. Але якщо вона не має її, вона або буде продовжувати накручувати без кінця, або продукувати безкінечну структуру даних. Гарна річ щодо безкінечних списків в тому, що ми можемо обрізати їх, якщо схочемо. <code>repeat</code> бере елемент, та повертає безкінечний список, що має цей елемент. Рекурсивна реалізація цього дійсно проста, дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">repeat&#39;</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">repeat&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span><span class="kt">:</span><span class="n">repeat&#39;</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик <code>repeat 3</code> дасть нам список, що починається з <code>3</code>, і потім має безкінечну кількість <code>3</code> в хвості. Так що виклик <code>repeat 3</code> буде обчислюватись як <code>3:repeat 3</code>, що є <code>3:(3:repeat 3)</code>, що є <code>3:(3:(3:repeat 3))</code>, тощо. <code>repeat 3</code> ніколи не припинить обчислення, але <code>take 5 (repeat 3)</code> дасть нам список з п'яти трійок. Так що це те саме, що зробити <code>replicate 5 3</code>.</p></div>
<div class="paragraph"><p><code>zip</code> приймає два списки да поєднує їх разом. <code>zip [1,2,3] [2,3]</code> повертає <code>[(1,2),(2,3)]</code>, оскільки вона відсікає довший список до довжини коротшого. Що, коли ми поєднаємо щось з порожнім списком? Тоді ми знову отримаємо порожній список. Так що це наша гранична умова. Однак <code>zip</code> приймає два списки як параметри, так що насправді дві граничні умови.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">zip&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)]</span>
<span class="nf">zip&#39;</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zip&#39;</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zip&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="kt">:</span><span class="n">zip&#39;</span> <span class="n">xs</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Перші два шаблони кажуть, що якщо перший список або другий список порожні ми отримуємо порожній список. Третій каже, що два поєднані списки рівні до пари з їх голів, та потім список з поєднанних хвостів. Поєднання <code>[1,2,3]</code> та <code>['a','b']</code> з часом спробує <code>zip [3]</code> з <code>[]</code>. Гранична умова спрацьовує, і таким чином результат буде <code>(1,'a'):(2,'b'):[]</code>, що точно те саме, що і <code>[(1,'a'),(2,'b')]</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо ще одну функцію зі стандартної бібліотеки — <code>elem</code>. Вона бере елемент та список, та дивиться, чи елемент є в списку. Гранична умова, як в більшості випадків зі списками, це порожній список. Ми знаємо, що порожній список не має елементів, так що він напевне не має того, що ми шукаємо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">elem&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elem&#39;</span> <span class="n">a</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">False</span>
<span class="nf">elem&#39;</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">a</span> <span class="o">==</span> <span class="n">x</span>    <span class="ow">=</span> <span class="kt">True</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">a</span> <span class="p">`</span><span class="n">elem&#39;</span><span class="p">`</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить просто та очікувано. Якщо голова не є нашим елементом, тоді ми перевіряємо хвіст. Якщо ми досягли порожнього списку результатом буде <code>False</code>.</p></div>
<div class="paragraph"><p>Ми маємо з елементів, що може бути відсортований. Їх тип є примірником типокласу <code>Ord</code>. І тепер ми бажаємо відсортувати їх! Існує дуже крутий алгоритм сортування з назвою <code>quicksort</code>. Це дуже розумний спосіб сортувати елементи. Хоча це займає 10 рядків для реалізації <code>quicksort</code> на імперативних мовах, реалізація значно коротша і елегантніша на Haskell. Quicksort став різновидом візитівки для Haskell. Таким чином давайте реалізуємо його тут, навіть не зважаючи на те, що реалізація <code>quicksort</code> на Haskell стала загальним місцем, бо кожний робить її, щоб показати елегантність Haskell.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/quickman.png" alt="images/quickman.png" />
</span>
І так, сигнатура типу має бути <code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>. No surprises there. Гранична умова? Порожній список, як і очікувалось. Відсортований порожній список є порожній список. Тепер іде головний алоритм: сортований список є список, що має всі значення меньші (або еквівалентні до) голови списку спереду (і ці значення відсортовані), потім іде голова списку всередині і потім ідуть всі значення, що більші ніж голова (вони також відсортовані). Зауважте, що ми сказали <em>відсортовані</em> два рази в цьому визначенні, так що ми можливо маємо зробити рекурсивний виклик двічі! Також зауважте, що ми визначили його з використанням дієслова <em>is</em> для визначення алгоритму, замість казати роби це, роби те, потім оце &#8230;. Це краса функціонального програмування! Як ми збираємось фільтрувати список, так щоб він містив тільки елементи, меньші голови нашого списку, та елементи, що більші. Давайте зануримось, та визначимо цю функцію.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">quicksort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">]</span>
        <span class="n">biggerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">[</span><span class="n">a</span> <span class="o">|</span> <span class="n">a</span> <span class="ow">&lt;-</span> <span class="n">xs</span><span class="p">,</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">]</span>
    <span class="kr">in</span>  <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте зробимо невеликий тест щоб побачити, чи це робить коректно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">quicksort</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">quicksort</span> <span class="s">&quot;the quick brown fox jumps over the lazy dog&quot;</span>
<span class="s">&quot;        abcdeeefghhijklmnoooopqrrsttuuvwxyz&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Клац! Ще те, про що я говорив! Так що коли ми маємо, скажімо, <code>[5,1,9,4,6,7,3]</code>, і ми маємо відсортувати його, цей алгоритм спочатку бере голову, що є <code>5</code>, і потім кладе посередині двох списків, тих що меньше та тих що більше. Так що в одній точці ви будете мати <code>[1,4,3] ++ [5] ++ [9,6,7]</code>. Ми знаємо, що коли список буде відсортований повністю, число <code>5</code> буде на четвертому місці, оскільки три числа меньші, та три числа більші ніж воно. Тепер, якщо ми відсортуємо <code>[1,4,3]</code> та <code>[9,6,7]</code>, ми матимемо відсортований список! Ми сортуємо два списки, використовуючи ту саму функцію. З часом ми розіб'ємо їх до того стану, що отримаємо порожні списки, а порожні списки вже відсортовані, хоча і порожні. Ось ілюстрація:</p></div>
<div class="imageblock">
<div class="content">
<img src="images/quicksort.png" alt="images/quicksort.png" />
</div>
</div>
<div class="paragraph"><p>Елемент, що вже на своєму місці, і більше не рухається, представлений помаранчевим. Якщо ви читаєте це зліва направо, ви побачите відсортований список. Хоча ми обрали порівнювати елементи з головою, ми можемо обрати кожний елемент для порівняння. В <code>quicksort</code> елемент, з яким ви порівнюєте має назву точки повороту. Вони тут зелені. Ми обрали їх як голову, бо її просто отримати через порівняння шаблонів. Елементи, що меньші за поворотну точку світло зелені, та більші елементи темно зелені. Жовтуватий градієнт представляє застосування <code>quicksort</code>.</p></div>
<div class="paragraph"><p>Ми вже наробили досі рекурсій, і ви можливо помітили, що тут є шаблон. Зазвичай ви визначаєте граничну умову, та потім ви визначаєте функцію, що робить щось між деяким елементом і функцією, застосованою до залишку. Не має значення, чи це список, дерево або люба інша структура даних. <code>sum</code> в перший елемент списку, плюс <code>sum</code> залишку списку. <code>product</code> списку є перший елемент списку, помножений на <code>product</code> залишку списку. Довжина списку є один плюс довжина хвоста списку. І так далі, і так далі &#8230;</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/brain.png" alt="images/brain.png" />
</span>
Звичайно, також існують граничні умови. Звичайно граничні випадки є деякий сценарій, де рекурсивне застосування не має сенсу. Коли маємо справу зі списками, граничний випадок найбільш часто є порожнім списком. Якщо ви маєте справу з деревами, це часто вузол, що не має жодних дітей.</p></div>
<div class="paragraph"><p>Це подібно до того, коли ви маєте справу з числами рекурсивно. Звичайно ми маєм осправу з деяким числом, і потім функцію, застосовану до модифікації цього числа. Ми робили функцію факторіала раніше, і це добуток числа і факторіала цього числа мінус одиниця. Таке рекурсивне застосування не має сенсу для нуля, оскільки факторіали визначені тільки для позитивних цілих. Часто граничним випадком є значення ідентичності. Для множення це 1, оскільки якщо ви помножите щось на 1, ви отримаєте те саме. Також коли ви робите суму списків, ми визначаємо суму порожнього списку як 0, і 0 є ідентичність для додавання. В <code>quicksort</code> граничний випадок є порожній список, оскільки якщо ви додасте порожній список до списка, ви отримаєте всього лише оригінальний список.</p></div>
<div class="paragraph"><p>Таким чином, коли намагаєтесь думати в рекурсивний спосіб для вирішення проблеми, намагайтесь подумати, коли рекурсивність не може застосовуватись, і побачте, чи ви не можете використати це в якості граничного випадку, подумайте про ідентичності, і подумайте, чи ви можете розбити на частини параметри функції (наприклад, списки зазвичай розбиваються на голову та хвіст через порівняння шаблонів), і на якій частині ви будете застосовувати рекурсивний виклик.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/sun.png" alt="images/sun.png" />
</span>
Функції Haskell можуть приймати функції як параметри, та повертати функції як значення повернення. Функція, що робить щось з цього, називається функцією вищого порядку. Функції вищого порядку є не тільки частиною досвіду Haskell, вони в великій мірі є сам досвід Haskell. З'ясовується, що якщо ви бажаєте визначити обчислення, визначаючи що це таке, замість визначати кроки, що змінюють деякий стан та можливо роблячи цикли, функції вищих порядків незамінні. Вони дійсно є потужним способом вирішення проблем і думати про программи.</p></div>
<div class="paragraph"><p>Кожна функція в Haskell офіційно приймає тільки один параметр. Так як це можливо, що ми визначили декілька функцій, що приймають більше ніж один параметр? Гаразд, це дотепний трюк! Всі функції, що приймають декілька параметрів, були карованими функціями. Що це означає? Ви краще зрозумієте це на прикладі. Давайте візьмемо нашого гарного друга, функцію <code>max</code>. Виглядає, що вона приймає два параметри, та повертає той, що більше. Виконання <code>max 4 5</code> спочатку створює функцію, що приймає параметр, і повертає або <code>4</code>, або цей параметр, в залежності що більше. Потім 5 застосовується до цієї функції, і ця функція продукує наш бажаний результат. Це виглядає як балачка, але насправді це крута концепція. Наступні два виклики еквівалентні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">max</span> <span class="mi">4</span> <span class="mi">5</span>
<span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">max</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/curry.png" alt="images/curry.png" />
</span>
Покладання проміжка між двома речами є просто застосування функції. Проміжок є різновидом оператора, і він має найвищий преоритет. Давайте перевіримо тип <code>max</code>. Це <code>max ::( Ord a) =&gt; a -&gt; a -&gt; a</code>. Він може бути записаний як <code>max ::( Ord a) =&gt; a -&gt; (a -&gt; a)</code>. Це може бути прочитане так: <code>max</code> бере <code>a</code>, та повертає (це <code>-&gt;</code>) функцію, що бере <code>a</code> та повертає <code>a</code>. Ось чому тип повернення та параметри функцій просто розділені стрілками.</p></div>
<div class="paragraph"><p>Погляньте на цю образливо просту функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">multThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">multThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>То як це вигідно для нас? Кажучи просто, якщо ми викликаємо функцію з недостатньою кількістю параметрів, ми отримаємо назад частково застосовану функцію, що приймає стільки параметрів, скльки ми залишили. Використання часткового застосування (виклик функцій з недостатньою кількістю параметрів, якщо бажаєте), є милий спосіб створювати функції на льоту, так що ми можемо передавати їх до інших функцій, або наповнювати їх деякими даними.</p></div>
<div class="paragraph"><p>Що насправді відбувається, коли ми робимо <code>multThree 3 5 9</code> або <code>( (multThree 3) 5) 9</code>? Спочатку <code>3</code> застосовується до <code>multThree</code>, оскільки вони розділені проміжком. Це створює функцію, що приймає один параметр, та повертає функцію. Так що <code>5</code> застосовується до цього, це створює функцію, що буде брати параметр, та множити його на <code>15</code>. <code>9</code> застосовується до цієї функції, та результат буде <code>135</code>, або десь так. Пам'ятайте, що цей тип функції може бути переписаний як <code>multThree ::( Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</code>. Річ перед <code>-&gt;</code> є параметр, що приймає функція, і річ, що йде після цього є те, що вона повертає. Так що наша функція приймає <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; (a -&gt; a)</code>. Подібно до цього, ця функція бере <code>a</code>, та повертає функцію типу <code>(Num a) =&gt; a -&gt; a</code>. І ця функція, нарешті, просто бере <code>a</code> і повертає <code>a</code>. Погляньте на це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multTwoWithNine</span> <span class="ow">=</span> <span class="n">multThree</span> <span class="mi">9</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="mi">54</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">multWithEighteen</span> <span class="ow">=</span> <span class="n">multTwoWithNine</span> <span class="mi">2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multWithEighteen</span> <span class="mi">10</span>
<span class="mi">180</span>
</pre></div></div></div>
<div class="paragraph"><p>Викликаючи функції з недостатніми параметрами, так би мовити, ми створюємо функції на льоту. Що, якщо ми бажаємо створити функцію, що приймає число, та порівнюєте його зі <code>100</code>? Ми можемо зробити щось подібне до наступного:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">compareWithHundred</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">compareWithHundred</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">compare</span> <span class="mi">100</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми викличемо її з <code>99</code>, вона поверне <code>GT</code>. Прості речі. Зауважте, що <code>x</code> зправа по обі сторони від рівності. Тепер давайте подумаємо щодо того, що повертає <code>compare 100</code>. Воно повертає функцію, що бере число, та порівнює його з <code>100</code>. Вау! Чи це не функція, яку ми бажали? Ми можемо переписати це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">compareWithHundred</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Ordering</span>
<span class="nf">compareWithHundred</span> <span class="ow">=</span> <span class="n">compare</span> <span class="mi">100</span>
</pre></div></div></div>
<div class="paragraph"><p>Декларація типу каже те саме, оскільки <code>compare 100</code> повертає функцію. <code>Compare</code> має тип <code>(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code>, та виклик її з <code>100</code> повертає <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. Додаткове обмеження класу присутнє, оскільки <code>100</code> також є частиною типокласу <code>Num</code>.</p></div>
<div class="paragraph"><p>Йо! Переконайтесь, що ви справді розумієте, як роблять каровані функції та робить часткове застосування, бо воні справді важливі!</p></div>
<div class="paragraph"><p>Інфіксні функції також можуть бути частково застосовані з використанням секцій. Для секції інфіксної функції просто оточите її дужками, і надайте параметр тільки з однієї сторони. Це створить функцію, що приймає один параметр, та потім застосовує його до сторони, де відсутній операнд. Образливо тривіальна функція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">divideByTen</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Floating</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">divideByTen</span> <span class="ow">=</span> <span class="p">(</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Виклик, скажімо, <code>divideByTen 200</code> еквівалентне до <code>200 / 10</code>, так само, як зробити <code>(/10) 200</code>. Функція, що перевіряє, що наданий символ є великою літерою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">isUpperAlphanum</span> <span class="ow">::</span> <span class="kt">Char</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isUpperAlphanum</span> <span class="ow">=</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдина особлива річ щодо секцій є використання <code>-</code>. З визначення секцій <code>(-4)</code> має давати результат в вигляді функції, що приймає число, та віднімає <code>4</code> з нього. Однак для зручності <code>(-4)</code> означає мінус чотири. Так що якщо ви бажаєте створити функцію, що віднімає <code>4</code> від часла як параметра, частково застосуйте функцію <code>subtract</code> таким чином: <code>(subtract 4)</code>.</p></div>
<div class="paragraph"><p>Що трапиться, якщо ми спробуємо просто зробити <code>multThree 3 4</code> в GHCI, замість прикріплення її до імені за допомогою <code>let</code>, або передачі її до іншої функції?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">multThree</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="kt">:</span>
    <span class="kt">No</span> <span class="kr">instance</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">))</span>
      <span class="n">arising</span> <span class="n">from</span> <span class="n">a</span> <span class="n">use</span> <span class="kr">of</span> <span class="p">`</span><span class="n">print&#39;</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">interactive</span><span class="o">&gt;:</span><span class="mi">1</span><span class="kt">:</span><span class="mi">0</span><span class="o">-</span><span class="mi">12</span>
    <span class="kt">Possible</span> <span class="n">fix</span><span class="kt">:</span> <span class="n">add</span> <span class="n">an</span> <span class="kr">instance</span> <span class="n">declaration</span> <span class="n">for</span> <span class="p">(</span><span class="kt">Show</span> <span class="p">(</span><span class="n">t</span> <span class="ow">-&gt;</span> <span class="n">t</span><span class="p">))</span>
    <span class="kt">In</span> <span class="n">the</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
    <span class="kt">In</span> <span class="n">a</span> <span class="n">&#39;do&#39;</span> <span class="n">expression</span><span class="kt">:</span> <span class="n">print</span> <span class="n">it</span>
</pre></div></div></div>
<div class="paragraph"><p>GHCI каже нам, що вираз спродукував функцію типу <code>a -&gt; a</code>, але воно не знає, як друкувати її на екрані. Функції не є членами типокласу  <code>Show</code>, так що ви не можете отримати милого рядкового представлення функції. Коли ми робимо, скажімо, <code>1 + 1</code> в підказці GHCI, воно спочатку ообчислює <code>2</code>, та потім викликає <code>show</code> на <code>2</code> для отримання текстуального представлення числа. І текстуальна репрезентація <code>2</code> є просто рядок <code>"2"</code>, що друкується на екрані.</p></div>
<div class="paragraph"><p>Функції можуть приймати функції як параметри і також повертають функції. Щоб проілюстровати це, ми збираємось створити функцію, що приймає функцію, та потім застосовує її двічі до будь-чого!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">applyTwice</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">applyTwice</span> <span class="n">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/bonus.png" alt="images/bonus.png" />
</span>
Для початку зауважте декларацію типу. Перед цім ми не потребували дужок, оскільки <code>-&gt;</code> є право асоціативним. Але тут воно обов'язкове. Це каже, що перший параметр є функція, що приймає дещо, та повертає ту саму річ. Другий параметр є дещо, і цього ж типу також значення повернення. Ми можемо читати цю декларацію типу, але щоб не заморочуватись ми просто скажемо, що ця функція приймає два параметри, та повертає одну річ. Перший параметр є функція (типу <code>a -&gt; a</code>) та другий те саме <code>a</code>. Функція також може бути <code>Int -&gt; Int</code> або <code>String -&gt; String</code>, або будь-що. Але потім другий параметр має також бути того самого типу.</p></div>
<div class="paragraph"><p>Note: Відтепер ми будемо казати, що функції приймають декілька параметрів, незважаючи на те, що кожна функція насправді бере тільки один параметр, та повертає частково застосовані функції, доки ми не досягнемо функцію, що повертає справжнє значення. Так що для спрощення ми кажемо, що <code>a -&gt; a -&gt; a</code> бере два параметри, навіть маючи на увазі, що це відбувається за лаштунками.</p></div>
<div class="paragraph"><p>Тіло функції досить просте. Ми просто використовуємо параметр <code>f</code> як функцію, застосовуючи <code>x</code> до неї, розділяючи їх проміжками, і потім застосовуючи результат знову до <code>f</code>. В любому випадку пограємось з функцією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="mi">10</span>
<span class="mi">16</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot; HAHA&quot;</span><span class="p">)</span> <span class="s">&quot;HEY&quot;</span>
<span class="s">&quot;HEY HAHA HAHA&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="s">&quot;HAHA &quot;</span> <span class="o">++</span><span class="p">)</span> <span class="s">&quot;HEY&quot;</span>
<span class="s">&quot;HAHA HAHA HEY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="n">multThree</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="mi">9</span>
<span class="mi">144</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">applyTwice</span> <span class="p">(</span><span class="mi">3</span><span class="kt">:</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивовижність та корисність часткових функцій є очевидною. Якщо наша функція потребує передати їй функцію, що приймає тільки один параметр, ви можете тільки частково застосувати функцію до тієї точки, коли вона прийматиме тільки один параметр, та потім передати її.</p></div>
<div class="paragraph"><p>Тепер ми збираємось використати програмування вищого порядку для реалізації насправді корисної функції, що є в стандартній бібліотеці. Вона називається <code>zipWith</code>. Вона бере функцію та два списки як параметри, та потім поєднує два списки, застосовуючи функцію між відповідними елементами. Ось як ми реалізуємо її:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">zipWith&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
<span class="nf">zipWith&#39;</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zipWith&#39;</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">zipWith&#39;</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="kt">:</span><span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span> <span class="kt">:</span> <span class="n">zipWith&#39;</span> <span class="n">f</span> <span class="n">xs</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивимось на декларацію типу. Перший параметр є функція, що бере дві речі і повертає третю річ. Вони не мають бути того самого типу, але вони можуть. Другий та третій параметр є списками. Результат також список. Перший має бути списком з <code>a</code>, оскікльки функція поєднання бере <code>a</code> як перший аргумент. Другий має бути списком <code>b</code>, тому що другий параметр функції поєднання має тип <code>b</code>. Результатом є список <code>c</code>. Якщо декларація типу функції каже, що вона сприймає функцію <code>a -&gt; b -&gt; c</code> як параметр, вона також сприйматиме функцію <code>a -&gt; a -&gt; a</code>, але не навпаки! Пам'ятайте, що коли в створюєте функції, особливо вищого порядку, і ви не впевнені щодо типу, ви можете просто оминути декларацію типу, та потім перевірити, що Haskell виводить щодо типу через <code>:t</code>.</p></div>
<div class="paragraph"><p>Дія в функції досить подібна до звичайного <code>zip</code>. Граничні умови ті самі, тільки є додатковий аргумент, функція поєднання, але цей аргумент не має значення в граничних умовах, так що ми використовуємо <code>_</code> щодо цього. Та тіло функції останнього шаблону подібне до <code>zip</code>, але він не робить <code>(x,y)</code>, але <code>f x y</code>. Єдина функція вищого порядку може бути використана для безлічі різних завдань, якщо вона досить загальна. Ось маленька демонстрація всьго різноманіття речей, що може робити наша функція <code>zipWith'</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="n">max</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;foo &quot;</span><span class="p">,</span> <span class="s">&quot;bar &quot;</span><span class="p">,</span> <span class="s">&quot;baz &quot;</span><span class="p">]</span> <span class="p">[</span><span class="s">&quot;fighters&quot;</span><span class="p">,</span> <span class="s">&quot;hoppers&quot;</span><span class="p">,</span> <span class="s">&quot;aldrin&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;foo fighters&quot;</span><span class="p">,</span><span class="s">&quot;bar hoppers&quot;</span><span class="p">,</span><span class="s">&quot;baz aldrin&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">5</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith&#39;</span> <span class="p">(</span><span class="n">zipWith&#39;</span> <span class="p">(</span><span class="o">*</span> <span class="p">))</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">,</span><span class="mi">12</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, єдина функція вищого порядку може бути використана в дуже різноманітний спосіб. Імперативне програмування зазвичай використовує речі як <code>for</code> цикли, <code>while</code> цикли, присвоєння чогось до змінної, перевірка її стану, тощо, щоб досягти певної поведінки та потім огорнути її в інтерфейс, такий як функція. Функціональне програмування використовує функції вищого порядку щоб абстрагувати загальні шаблони, як попарно екзаменувати два списки, та потім робити щось з ціма парами, або отримати набір рішень, та відкинути ті, що нам не потрібні.</p></div>
<div class="paragraph"><p>Давайте реалізуємо іншу функцію, що вже є стандартній бібліотеці, що називається <code>flip</code>. <code>Flip</code> просто бере функцію, та повертає функцію, що подібна до нашої оригінальної функції, тільки два перших аргументи обміняні місцями. Ми можемо реалізувати її таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">g</span>
    <span class="kr">where</span> <span class="n">g</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Читаючи декларацію типу ми кажемо, що вона бере функцію, що приймає <code>a</code> та <code>b</code>, та повертає функцію, що приймає <code>b</code> та <code>a</code>. Але оскільки функції каровані по замовчанню, друга пара дужок не є насправді потрібною, бо <code>-&gt;</code> є право асоціативним по замовчанню. <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> є те саме, що і <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, що те саме, що і <code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. Ми записуємо, що <code>g x y = f y x</code>. Якщо це так, тоді <code>f y x = g x y</code> має також дотримуватись, вірно? Маючи це на увазі, ми можемо визначити цю функцію навіть в ще простіший спосіб.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми отримуємо вигоду від факту, що функція карована. Коли ми в икликаємо <code>flip' f</code> без параметров <code>y</code> та <code>x</code>, вона буде повертати <code>f</code>, що бере ці два параметри, але переставляє їх місцями. Навіть не зважаючи на те, що функції з перестановкою звичайно передаються в інші функції, ви можете отримати перевагу від карування, та потім створювати функції вищих порядків, при цьому розмірковуючи наперед, та написання їх таким чином, щоб остаточний результат був би такий, якби вони були повністю застосовані.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flip&#39;</span> <span class="n">zip</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="s">&quot;hello&quot;</span>
<span class="p">[(</span><span class="sc">&#39;h&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="sc">&#39;e&#39;</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="sc">&#39;l&#39;</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="sc">&#39;o&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="n">flip&#39;</span> <span class="n">div</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>map</code> приймає функцію та список, та застосовує цю функцію до кожного елементу, продукуючи новий список. Давайте подивимось, яка в неї сигнатура типу, та як вона визначена.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Сигнатура типу каже, що вона приймає функцію, що приймає <code>a</code> та повертає <code>b</code>, список <code>a</code> перетворюється на список <code>b</code>. Цікаво, що просто дивлячись на сигнатуру типу функції, ви можете інколи сказати, що вона робить. <code>map</code> одна з ціх дійсно універсальних функцій вищого порядку, що може використовуватись в мільйони різних способів. Ось вона в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;!&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;BIFF&quot;</span><span class="p">,</span> <span class="s">&quot;BANG&quot;</span><span class="p">,</span> <span class="s">&quot;POW&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;BIFF!&quot;</span><span class="p">,</span><span class="s">&quot;BANG!&quot;</span><span class="p">,</span><span class="s">&quot;POW!&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">))</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">9</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">25</span><span class="p">,</span><span class="mi">36</span><span class="p">],[</span><span class="mi">49</span><span class="p">,</span><span class="mi">64</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">fst</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви, можливо, зауважили, що все це можна досягти осяжністю списків. <code>map (+3) [1,5,3,1,6]</code> те саме, що написати <code>[x+3 | x &lt;- [1,5,3,1,6]]</code>. Однак використання <code>map</code> значно краще читається для випадків, коли ви лише застосовуєте функцію до елементів списку, особливо коли ви маєте справу з мапою мап, і тоді ціла річ з багатьма дужками може стати заплутаною.</p></div>
<div class="paragraph"><p><code>filter</code> є функцією, що приймає предикат (предикат є функція, що каже, чи дещо вірно або ні, так що в нашому випадку повертає логічне значення), та список, та потім повертає список елементів, що задовільняє предикату. Сигнатура типу та реалізація виглядають так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">filter</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">filter</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">filter</span> <span class="n">p</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">p</span> <span class="n">x</span>       <span class="ow">=</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">p</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Доволі проста річ. Якщо <code>p x</code> обчислюється до <code>True</code>, елемент буде включений в новий список. Якщо ні, елемент відкидається. Деякі приклади використання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="o">==</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="n">even</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">notNull</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">null</span> <span class="n">x</span><span class="p">)</span> <span class="kr">in</span> <span class="n">filter</span> <span class="n">notNull</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">,</span><span class="kt">[]</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">])</span> <span class="s">&quot;u LaUgH aT mE BeCaUsE I aM diFfeRent&quot;</span>
<span class="s">&quot;uagameasadifeent&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;i lauGh At You BecAuse u r aLL the Same&quot;</span>
<span class="s">&quot;GAYBALLS&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Все це можна досягти за допомогою осяжності списків через використання предикатів. Немає встановленого правила для використання <code>map</code> та <code>filter</code>, проти використання осяжності списків, вам треба просто визначити, що читається краще в залежності від коду та контексту. <code>filter</code> еквівалентно до застосування декількох предикатів в осяжності списків, або фільтруючи дещо декілька раз, або поєднуючи предикати логічною функцією <code>&amp;&amp;</code>.</p></div>
<div class="paragraph"><p>Пам'ятаєте нашу функцію <code>quicksort</code> з минулої глави? Ми використовували осяжність списків для фільтрування елементів списку, що меньші (або рівні), та більше ніж переломна точка. Ми можемо досягти такої самої функціональності в більш читаємий спосіб, за допомогою <code>filter</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">quicksort</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">quicksort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">quicksort</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">smallerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
        <span class="n">biggerSorted</span> <span class="ow">=</span> <span class="n">quicksort</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">x</span><span class="p">)</span> <span class="n">xs</span><span class="p">)</span>
    <span class="kr">in</span>  <span class="n">smallerSorted</span> <span class="o">++</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">++</span> <span class="n">biggerSorted</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/map.png" alt="images/map.png" />
</span>
Відображення та фільтрація є хліб та масло серед інструментів кожного функціонального програміста. Так. Не має значення, чи ви робите це за допомогою функцій <code>map</code> та <code>filter</code>, або осяжністю списків. Згадайте, як ми вірішували проблема пошуку правильних трикутників в певному колі. В імперативному програмуванні ми можемо вирішити це через вкладання трьох циклів, та потім перевіряючи, чи поточна комбінація задовільняю умовам трикутника, що має заданий периметр. Якщо це так, ми можемо роздрукувати це не екрані, або зробити щось інше. В функціональному програмуванні цей шаблон досягається через відображення та фільтрацію. Ви створюєте функцію, що приймає значення та продукує деякий результат. Ми відображуємо цю функцію на списку значень, та потім ми фільтруємо результуючий список щодо результатів, які задовільняють умовам пошуку. Дякуючи лінивості Haskell, навіть якщо ви робите <code>map</code> по списку декілька разів і фільтруєте його декілька раз, він пройде по списку один раз.</p></div>
<div class="paragraph"><p>Давайте знайдемо найбільше число до <code>100,000</code> що ділиться на <code>3829</code>. Щоб зробити це, ми просто відфільтруємо набір можливостей, де за нашими підрахунками знаходяться наші рішення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">largestDivisible</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">largestDivisible</span> <span class="ow">=</span> <span class="n">head</span> <span class="p">(</span><span class="n">filter</span> <span class="n">p</span> <span class="p">[</span><span class="mi">100000</span><span class="p">,</span><span class="mi">99999</span><span class="o">..</span><span class="p">])</span>
    <span class="kr">where</span> <span class="n">p</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">3829</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Спочатку створимо список всіх чисел, меньших <code>100,000</code> від великих до малих. Потім ми фільтруємо його по нашому предикату, і оскільки числа ідуть від великих, найбільше число за нашою умовою буде першим в списку результатів. Нам навіть не треба використовувати скінчений список для початку нашої множини. Це знову лінивість в дії. Оскільки ми закінчуємо використанням голови відфільтрованого списку, не має значення, чи ми фільтруємо скінчений список, або безкінечний. Обчислення зупиняється, коли буде знайдене перше адекватне рішення.</p></div>
<div class="paragraph"><p>Далі ми збираємось знайти суму всіх непарних квадратів, що меньше <code>10,000</code>. Але спочатку, оскільки ми використовуємо її в нашому рішенню, ми збираємось ввести функцію <code>takeWhile</code>. Вона приймає предикат і список, і потім проходить від початку списку, та повертає елемнти, доки предикат повертає істину. Як тільки знайдений елемент, для якого умова не виконується, все завершується. Якщо ви бажаєте отримати перше слово на початку рядка <code>"elephants know how to party"</code>, ми можемо зробити <code>takeWhile (/=' ') "elephants know how to party"</code>, що поверне <code>"elephants"</code>. Гаразд. Сума всіх непарних квадратів, що меньша <code>10,000</code>. Перше, ми почнемо з відображення функції <code>(^2)</code> на безкінечний список <code>[1..]</code>. Потім ми фільтруємо їх, щоб отримати лише непарні. І потім ми беремо елементи з цього списку, доки вони меньші ніж <code>10,000</code>. Нарешті ми отримуємо суму цього списку. Нам навіть немає потреби визначати для цього функцію, ми можемо зробити це в один рядок в GHCI:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">odd</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span>
<span class="mi">166650</span>
</pre></div></div></div>
<div class="paragraph"><p>Блискуче! Ми почали з деяких початкових даних (нескінчений список з усіх натуральних чисел), та потім ми робимо <code>map</code> по них, <code>filter</code> по ньому, та відсікаємо їх, доки він задовільняє нашим потребам, та потім підсумовуємо докупи. Ми можемо також переписати це, використовуючи осяжності списків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">[</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">odd</span> <span class="p">(</span><span class="n">n</span><span class="o">^</span><span class="mi">2</span><span class="p">)])</span>
<span class="mi">166650</span>
</pre></div></div></div>
<div class="paragraph"><p>Те, що ми обираємо, є лише справою смаку. І знову, властивість лінівості Haskell є те, що робить це можливим. Ми можемо робити відображення та фільтрувати по безкінечному списку, оскільки це насправді безпосередньо не робитиме <code>map</code> та <code>filter</code>, ці дії буде відкладено. Тільки коли ми змусимо Haskell показати нам суму буде викликана <code>sum</code>, що зробить <code>takeWhile</code> для отримання ціх чисел. <code>takeWhile</code> змушує виконання фільтрування та відображення, але тільки до тих пір, доки не трапиться число більше або рівне до <code>10,000</code>.</p></div>
<div class="paragraph"><p>Для нашої наступної проблеми ми будемо мати справу з послідовностями <code>Collatz</code>. Ми беремо натуральне число. Якщо число парне, ми ділимо його на два. Якщо воно непарне, ми множимо його на <code>3</code>, і потім додаємо <code>1</code>. Ми беремо результуюче число, та застосовуємо до нього ту саму річ, що продукує нове число, і так далі. В основі ми отримуємо ланцюжок чисел. Є думка, що для всіх початкових чисел ланцюжки закінчуються числом <code>1</code>. Так що якщо ми візьмемо початкове число <code>13</code>,ми отримаємо таку послідовність: <code>13</code>, <code>40</code>, <code>20</code>, <code>10</code>, <code>5</code>, <code>16</code>, <code>8</code>, <code>4</code>, <code>2</code>, <code>1</code>. <code>13*3 + 1</code> дорівнює <code>40</code>. <code>40</code> поділене на <code>2</code> є <code>20</code>, тощо. Ми бачимо, що ланцюжок має <code>10</code> термів.</p></div>
<div class="paragraph"><p>Те, що ми бажаємо знати, є наступним: для всіх початкових чисел між  <code>1</code> та <code>100</code>, як багато ланцюжків мають довжину, більшу ніж <code>15</code>? Спочатку ми напишемо функцію, що продукує ланцюжок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">chain</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Integral</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">chain</span> <span class="mi">1</span> <span class="ow">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">chain</span> <span class="n">n</span>
    <span class="o">|</span> <span class="n">even</span> <span class="n">n</span> <span class="ow">=</span>  <span class="n">n</span><span class="kt">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span>
    <span class="o">|</span> <span class="n">odd</span> <span class="n">n</span>  <span class="ow">=</span>  <span class="n">n</span><span class="kt">:</span><span class="n">chain</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки ланцюжки закінчуються на <code>1</code>, це буде граничний випадок. Це досить стандартна рекурсивна функція.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">10</span>
<span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chain</span> <span class="mi">30</span>
<span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">46</span><span class="p">,</span><span class="mi">23</span><span class="p">,</span><span class="mi">70</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">106</span><span class="p">,</span><span class="mi">53</span><span class="p">,</span><span class="mi">160</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау! Здається це робить коректно. І тепер функцію, що дає відповідь на наше запитання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">numLongChains</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">numLongChains</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="n">isLong</span> <span class="p">(</span><span class="n">map</span> <span class="n">chain</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]))</span>
    <span class="kr">where</span> <span class="n">isLong</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми відображуємо функцію <code>chain</code> до <code>[1..100]</code>, щоб отримати список ланцюжків, що самі представлені як списки. Потім ми фільтруємо їх предикатом, що тільки перевіряє, чи довжина більше ніж <code>15</code>. Як тільки ви виконали фільтрацію, ми бачимо, скільки ланцюжків залишилось в результуючому списку.</p></div>
<div class="paragraph"><p>Note: Ця функція має тип <code>numLongChains ::Int</code>, оскільки <code>length</code> повертає <code>Int</code> замість <code>Num</code> з історичних причин. Якщо ви бажаєте повертати більш загальне <code>Num</code>, ми можемо використати <code>fromIntegral</code> на результуючій довжині.</p></div>
<div class="paragraph"><p>Використовуючи <code>map</code>, ми також можемо робити речі, як <code>map (* ) [0..]</code>, якщо і не з іншої причини, ніж проілюструвати, як робить карування, та як (частково застосовані) функції є реальними значеннями, які ви можете передати по кругу до інших функцій, або покласти в списки (ви тільки не можете перетворити їх на рядки). Досі ми тільки відображали функції, що бере один параметр зі списку, як <code>map (* 2) [0..]</code> для отримання списку типу <code>(Num a) =&gt; [a]</code>, але ми також можемо робити <code>map (* ) [0..]</code> без проблем. Що трапиться тут, це те, що число в списку застосовується до функції <code>* `, що має тип `(Num a) =&gt; a -&gt; a -&gt; a</code>. Застосовуючи тільки один параметр до функції, що приймає два параметра, повертає функцію, що приймає один параметр . Якщо <code>* ` по списку `[0..]</code>, ми отримаємо список функцій, що приймають тільки один параметр, так що <code>(Num a) =&gt; [a -&gt; a]</code>. <code>map (* ) [0..]</code> продукує список, як такий, що ми отримаємо, написавши <code>[(0*),(1*),(2*),(3*),(4*),(5*)..</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">listOfFuns</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span> <span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">listOfFuns</span> <span class="o">!!</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">5</span>
<span class="mi">20</span>
</pre></div></div></div>
<div class="paragraph"><p>Отримавши елемент з індексом <code>4</code> з нашого списку повертаємо функцію, що еквівалентна до <code>(4*)</code>. Та потім ми просто застосовуємо 5 до цієї функції. Так що це як написати <code>(4*) 5</code>, або просто <code>4 * 5</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lambda.png" alt="images/lambda.png" />
</span>
Лямбда в основному анонімні функції, що використовуються, оскільки нам треба деякі функції тільки один раз. Звичайно ми створюємо лямбду з єдиним призначенням передати її в функцію вищого порядку. Щоб створити лямбду ми пишемо <code>\</code> (оскільки це виглядає дещо подібно на грецьку літеру лямбда, якщо придивитись досить сильно), та потім ми пишемо параметри, розділені проміжками. Після цього іде <code>-&gt;</code>, та потім тіло функції. Ми звичайно оточуємо їх в дужки, оскільки інакше вони розширюються весь час вправо.</p></div>
<div class="paragraph"><p>Якщо ви подивитесь на 5 дюймів вище, ви побачите, що ми використовували <code>where</code> прикріплення в нашій функції <code>numLongChains</code> для створення функції <code>isLong</code> для єдиного призначення передати її в фільтр. Гаразд, замість цього ми можемо використати лямбду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">numLongChains</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">numLongChains</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">length</span> <span class="n">xs</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">chain</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">100</span><span class="p">]))</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбди є виразами, і ось чому ми тільки можемо передати їх таким чином. Вираз <code>(\xs -&gt; length xs &gt; 15)</code> повертає функцію, що каже нам, чи довжина списку, переданому до них, більше ніж <code>15</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lamb.png" alt="images/lamb.png" />
</span>
Люди, що не дуже знайомі з тим, як роблять карування та часткове застосування, часто використовують лямбди там, да цього не треба робити. Наприклад, вирази <code>map (+3) [1,6,3,2]</code> та <code>map (\x -&gt; x + 3) [1,6,3,2]</code> еквівалентні, оскільки обоє, <code>(+3)</code> та <code>(\x -&gt; x + 3)</code> є функціями, що приймають число, та додають до нього <code>3</code>. Не треба казати, що створення лямбди в цьому випадку є марним, оскільки використання часткового застосування значно більше читабельне.</p></div>
<div class="paragraph"><p>Як нормальні функції, лямбди можуть приймати любе число параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">a</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="p">[</span><span class="mf">153.0</span><span class="p">,</span><span class="mf">61.5</span><span class="p">,</span><span class="mf">31.0</span><span class="p">,</span><span class="mf">15.75</span><span class="p">,</span><span class="mf">6.6</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Та як це нормальна функція, ви можете робити в лямбді співпадіння шаблонів. Єдина різниця в тому, що ви не можете визначити декілька шаблонів для одного параметру, як зробити <code>[]</code> та <code>(x:xs)</code> шаблони для одного параметру, та потім мати значення, що провалюються. Якщо співпадіння шаблонів схибиться в лямбді, виникне помилка виконання, так що будьте уважні, коли порівнюєте шаблони в лямбдах!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбди зазвичай оточені дужками, якщо тільки ми не хочемо, щоб вони поширювались весь час вправо. Тут є дещо цікаве: через спосіб, як функції каровані по замовчанню, наступні два варіанти еквівівалентні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">addThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">addThree</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
<span class="nf">addThree</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">addThree</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="n">y</span> <span class="ow">-&gt;</span> <span class="nf">\</span><span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо визначити функцію таким чином, стає зрозумілим, чому її декларація типу така, як вона є. Є три <code>-&gt;</code> в обох деклараціях типу і рівності. Але, звичайно, перший спосіб запису функції значно більш читабельний, другий є скоріше трюком для демонстрації карування.</p></div>
<div class="paragraph"><p>Однак є випадки, коли використання цієї нотації є крутим. Я думаю, що функція перестановки <code>flip</code> найбільш зрозуміла, коли записана таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">flip&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">flip&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">y</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть якщо це те саме, що і написати <code>flip' f x y = f y x</code>, ми робимо очевидним, що це буде використане для створення нової функції в більшості випадків. Найбільш загальний випадок використання для <code>flip</code> є виклик її з тільки однією функцією-параметром, та потім передати отриману функцію далі до <code>map</code> або <code>filter</code>. Так що в
икористовуйте лямбди в цей спосіб, коли ви бажаєте зробити явним, щваша функція здебільшого призначена бути частково застосованою та переданою до деякої функції як параметр.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/origami.png" alt="images/origami.png" />
</span>
Раніше, коли мали справу з рекурсією, ми зауважили лейтмотив в більшості рекурсивних функцій, що оперують зі списками. Зазвичай ми маємо граничний випадок для порожнього списку. Ми ввели шаблон <code>x:xs</code>, та потім ми виконували деяку дію, що включає один елемент та залишок списку. З'ясовується, що це дуже загальний шаблон, так що для його енкапсуляції були введені декілька функцій. Ці функції мають назву згорток <code>fold</code>. Вони є деяким різновидом функції <code>map</code>, тільки вони скорочують список до деякого одного значення.</p></div>
<div class="paragraph"><p><code>fold</code> бере двомісну функцію, початкове значення (мені подобається називати її аккумулятором) та список, що треба згорнути. Сама двомісна функція приймає два параметри. Двомісна функція викликається з акумулятором та першим (або останнім) елементом, та продукує новий акумулятор. Потім двомісна функція викликається знову з новим акумулятором та тепер новим першим (або останнім) елементом, і так далі. Коли ми пройшли по всьому списку, залишається лише аккумулятор, і це те, до чого ми скоротили список.</p></div>
<div class="paragraph"><p>Спочатку давайте поглянемо на функцію <code>foldl</code>, що також називають лівою згорткою. Вона згортає список з лівогоо боку. Двомісна функція застосовується між початковим значенням та головою списку. Це продукує нове значення аккумулятора, і двомісна фінкція викликається з цім значенням та наступним елементом, тощо.</p></div>
<div class="paragraph"><p>Давайте знову реалізуємо <code>sum</code>, тільки на цей рез через <code>fold</code> замість явної рекурсії.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">x</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Тестуємо, раз-два-три:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum&#39;</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="mi">11</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/foldl.png" alt="images/foldl.png" />
</span>
Давайте глибоко розглянемо, як відбувається цей <code>fold</code>. <code>\acc x -&gt; acc + x</code> є двомісна функція. <code>0</code> є початкове значення, та <code>xs</code> є список, що згортається. Тепер спочатку <code>0</code> використовується як параметр <code>acc</code> до двомісної функції, та <code>3</code> використовується як параметр <code>x</code> (або поточний елемент). <code>0 + 3</code> продукує <code>3</code> і це стає новим значенням аккумулятора. На наступному кроці <code>3</code> використовується як значення аккумулятора та <code>5</code> як поточний елемент, після цього <code>8</code> стає новим значенням аккумулятора. Рухаючись далі, <code>8</code> є значенням аккумулятора, 2 поточним елементом, нове значення аккумулятора <code>10</code>. Нарешті, це <code>10</code> використовується як значення аккумулятора, <code>1</code> поточний елемент, що продукує <code>11</code>. Вітаємо, ви виконали згортання!</p></div>
<div class="paragraph"><p>Ця професійна діаграма зліва ілюструє як відбувається згортка, крок за кроком (день за днем!). Зеленувате коричневе число є значення аккумулятора. Ви можете бачити, як цей список свого роду споживається з лівого боку акумулятором. Ням-ням-нам! Якщо ви приймете до уваги, що функції каровані, ви можете записати цю реалізацію навіть більш скорочено, десь так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Лямбда функція <code>(\acc x -&gt; acc + x)</code> є те саме, що <code>(+)</code>. Ми можемо уникнути параметра <code>xs</code>, оскільки виклик <code>foldl (+) 0</code> буде повертати функцію, яка приймає список. Загалом, якщо ви маєте функцію, як <code>foo a = bar b a</code>, ви можете переписати її як <code>foo = bar b</code> завдяки каруванню.</p></div>
<div class="paragraph"><p>Так чи інакше, давайте реалізуємо іншу функцію з лівим <code>fold</code> перед тим, як перейти до правих <code>fold</code>. Я впевнений, що ви всі знаєте, що `elem`перевіряє, чи значення є частиною списку, так що я не буду проходитись по цьому ще раз (я знову зробив це!). Давайте зробимо це за допомогою лівої згортки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">elem&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">elem&#39;</span> <span class="n">y</span> <span class="n">ys</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="n">ys</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, гаразд, гаразд, що ми тут маємо? Початкове значення та аккумулятор тут логічні значення. Тип значення аккумулятора та результуючого значення завжди те саме, коли маємо справу зі згортками. Пам'ятайте, що якщо ви колись не знаєте, що використовувати як початкове значення, це дасть вам якусь ідею. Ми розпочинаємо з <code>False</code>. Має сенс використовувати <code>False</code> як стартове значення. Ми вважаємо, що того, що ми шукаємо, тут немає. Також якщо викличемо <code>fold</code> на порожньому списку, результатом буде просто стартове значення. Потім ми перевіряємо поточний елемент, чи є він те, що ми шукаємо. Якщо так, ми встановлюємо аккумулятор в <code>True</code>. Якщо ні, ми просто залишаємо аккумулятор незмінним. Якщо він до цього був <code>False</code>, він залишається таким самим, бо цей елемент не те, що треба. Якщо він був <code>True</code>, ми залишаємо його таким самим.</p></div>
<div class="paragraph"><p>Права згортка, <code>foldr</code>, робить в подібний спосіб як ліва, тільки аккумулятор з'їдає значення зправа. Також двомісна функція лівої згортки має акумулятор як перший параметр, та поточне значення як друге значення (так що <code>\acc x -&gt; ...</code>), двомісна функція правої згортки має поточне значення як перший параметр, та аккумулятор як другий (так що <code>\x acc -&gt; ...</code>). Це має деякий сенс, що права згортка має аккумулятор зправа, оскільки вона згортає з правого боку.</p></div>
<div class="paragraph"><p>Значення аккумулятора (і, таким чином, результат) згортки може бути любого типу. Це може бути число, логічне, або навіть новий список. Ми реалізуємо функцію <code>map</code> за допомогою правої згортки. Аккумулятором буде список, де ми будемо аккумулювати відображений список елемент за елементом. Виходячи з цього є очевидним, що початковим елементом буде порожній список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">map&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map&#39;</span> <span class="n">f</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми відображуемо <code>(+3)</code> до <code>[1,2,3]</code>, ми підходимо до списку з правого боку. Ми беремо останній елемент, що є <code>3</code>, та застосовуємо до нього функцію, що в результаті дає <code>6</code>. Потім ми ставимо його на початок аккумілятора, що був <code>[]</code>. <code>6:[]</code> є <code>[6]</code>, і це тепер значення аккумулятора. Ми застосовуємо <code>(+3)</code> до <code>2</code>, що є <code>5</code>, і ми ставимо його перед <code>(:)</code> аккумулятором, так що аккумулятор тепер <code>[5,6]</code>. Ми застосовуємо <code>(+3)</code> до <code>1</code>, і ставимо його в початок аккумілятора, так що останнє значення є <code>[4,5,6]</code>.</p></div>
<div class="paragraph"><p>Звичайно, ми могли б реалізувати цю функцію за допомогою лівої звертки, також. Це було б <code>map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</code>, але річ в тому, що функція <code>++</code> значно більш коштовна, ніж <code>:</code>, так що зазвичай використовуйте праву звертку коли будуєте нові спискі зі списків.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/washmachine.png" alt="images/washmachine.png" />
</span>
Якщо ви обертаєте список, ви можете робити праве згортання на ньому, так само як робите ліве, і навпаки. Іноді вам навіть не треба робити це. Функція <code>sum</code> може бути реалізована майже так само за допомогою правого або лівого <code>fold</code>. Одна велика різниця в тому, що права згортка робить на безкінечних списках, тоді як ліва ні! Кажучи просто, якщо ви берете безкінечний список в деякій точці, і ви згортаєте його зправа, ви з часом досягнете початку списку. Однак якщо ви візьмете безкінечний список в деякій точці, і спробуєте згорнути його зліва, ви ніколи не досягнете кінця!</p></div>
<div class="paragraph"><p>Згортки можуть бути використані в любій функції, де ви подорожуєте списком один раз, елемент за елементом, та потім повертаєте дещо на основі цього. Коли ви подорожуєте списком, та повертаєте дещо, є шанси, що ви бажаєте виконати згортку. Ось чому згортки, разом з мапами та фільтрами, одни з найкорисніших типів функцій в функціональному програмуванні.</p></div>
<div class="paragraph"><p>Функції <code>foldl1</code> та <code>foldr1</code> роблять в основному як <code>foldl</code> та <code>foldr</code>, тільки вам не треба провадити для них явне початкове значення. Вони вважають, що перший (або останній) елемент списку буде початковим значенням, та потім починає згортання з елемента, що іде за ним. Маючи це на увазі, функція <code>sum</code> може бути реалізована таким чином: <code>sum = foldl1 (+)</code>. Оскільки вони залежать від того, що списки, які згортаються, мають щонайменьше один елемент, вони призводять до помилок виконання, якщо викликаються з порожніми списками. <code>foldl</code> та <code>foldr</code>, з іншого боку, гарно роблять з порожніми списками. Коли робите згортку, подумайте про те, як це діє з порожнім списком. Якщо ваша функція не має сенсу, коли отримує порожній список, ви можливо можете використовувати <code>foldl1</code> або <code>foldr1</code> для її реалізації.</p></div>
<div class="paragraph"><p>Щоб показати, наскільки потужними є згортання, ми збираємось реалізувати декілька функцій зі стандартної бібліотеки з використанням :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">maximum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">maximum&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span>

<span class="nf">reverse&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">reverse&#39;</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="nf">product&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">product&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="o">*</span> <span class="p">)</span>

<span class="nf">filter&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">filter&#39;</span> <span class="n">p</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">p</span> <span class="n">x</span> <span class="kr">then</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">acc</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span>

<span class="nf">head&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">head&#39;</span> <span class="ow">=</span> <span class="n">foldr1</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">last&#39;</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last&#39;</span> <span class="ow">=</span> <span class="n">foldl1</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>head</code> краще реалізується через порівняння шаблонів, але вона тут наведена тільки для демонстрації, ви також можете досягти того ж через згортку. Наше визначення <code>reverse'</code> досить розумне, як я думаю. Ми беремо порожній список в якості початкового значення, та потім проходимо наш список зліва, та ставимо елементи в початок нашого аккумулятора. В кінці кінців ми побудували обернений список. <code>\acc x -&gt; x : acc</code> виглядає як функція <code>:</code>, тільки параметри в іншому порядку. Ось чому ми також можемо записати <code>reverse</code> як <code>foldl (flip (:)) []</code>.</p></div>
<div class="paragraph"><p>Інший шлях змалювати праві і ліві згортки: скажімо, ми маємо праву згортку, двомісну функцію <code>f</code> та початкове значення є <code>z</code>. Якщо ми робимо праве згортання по списку <code>[3,4,5,6]</code>, ми в основному робимо таке: <code>f 3 (f 4 (f 5 (f 6 z)))</code>. <code>f</code> викликається по останньому елементу в списку та аккумулятором, її значення надається як аккумулятор аккумулятор до передостаннього значення, і так далі. Якщо ми в якості <code>f</code> беремо <code>+</code>, та початкове значення аккумулятора буде <code>0</code>, тобто отримуємо <code>3 + (4 + (5 + (6 + 0)))</code>. Або, якщо запишемо <code>+</code> як префіксну функцію, це буде <code>(+) 3 (( +) 4 (( +) 5 (( +) 6 0)))</code>. Подібно до цього, зробити ліве згортання по цьому списку з <code>g</code> в якості двомісної функції та <code>z</code> в якості аккумулятора еквівалентне до до <code>g (g (g (g z 3) 4) 5) 6</code>. Якщо ми використовуємо <code>flip (:)</code> як двомісну функцію, та <code>[]</code> як аккумулятор (так що ми обертаємо список),тоді це еквівалентно до <code>flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</code>. Та будьте впевнені, якщо ви обчислите цей вираз, ви отримаєте <code>[6,5,4,3]</code>.</p></div>
<div class="paragraph"><p><code>scanl</code> та <code>scanr</code> подібні до <code>foldl</code> та <code>foldr</code>, тільки вони доповідають всі проміжні стани аккумулятора в формі списка. Також існують <code>scanl1</code> та <code>scanr1</code>, що аналогічні до <code>foldl1</code> та <code>foldr1</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanr</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">11</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl1</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">acc</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">scanl</span> <span class="p">(</span><span class="n">flip</span> <span class="p">(</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли використовуєте <code>scanl</code>, остаточний результат буде в останньому елементі результуючого списку, тоді як <code>scanr</code> буде покладати результат в голову.</p></div>
<div class="paragraph"><p>Сканування використовуються для моніторингу прогресву функції, що може бути реалізована як згортка. Давайте відповимо на запитання: як багато елементів зайняло б підсумок коренів всіх натуральних чисел, щоб перевищити <code>1000</code>? Щоб отримати корені всіх натуральних чисел ми просто робимо <code>map sqrt [1..]</code>. Тепер для отримання суми ми можемо зробити згортку, але оскільки ми зацікавлені в тому, як сума прогресує, ми збираємось зробити сканування. Як тільки ми зробимо сканування, ми побачимо, як багато сум до <code>1000</code>. Перша сума в списку буде 1, що є природним. Друга буде <code>1</code> плюс корінь квадратний від <code>2</code>. Третя додасть квадратний корінь від <code>3</code>. Якщо буде <code>X</code> сум до <code>1000</code>, тоді це займе <code>X+1</code> елементів, щоб сума перевищила <code>1000</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sqrtSums</span> <span class="ow">::</span> <span class="kt">Int</span>
<span class="nf">sqrtSums</span> <span class="ow">=</span> <span class="n">length</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">)</span> <span class="p">(</span><span class="n">scanl1</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sqrtSums</span>
<span class="mi">131</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">131</span><span class="p">])</span>
<span class="mf">1005.0942035344083</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="p">(</span><span class="n">map</span> <span class="n">sqrt</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">130</span><span class="p">])</span>
<span class="mf">993.6486803921487</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми використовуємо тут <code>takeWhile</code> замість <code>filter</code>, оскільки <code>filter</code> не робить з безкінечними списками. Навіть знаючи, що список зростає, фільтр цього не знає, так що ми використовуємо <code>takeWhile</code>, щоб відрізати список сканування до першого входження суми, більшої ніж <code>1000</code>.</p></div>
<div class="paragraph"><p>Гараз, прийшов час поглянути на функцію <code>$</code>, також названою застосуванням функції. Спочатку подивимось, як вона визначена:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">$</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="nf">f</span> <span class="o">$</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/dollar.png" alt="images/dollar.png" />
</span>
Що за біс? Що це за некорисний оператор? Це просто застосування функції! Гаразд, майже, але не зовсім! Тоді як нормальне застосування функції (покладання проміжку між двома речами) має дійсно високий преоритет, функція <code>$</code> має нижчий преоритет. Застосування функції з проміжком ліво-асоціативне (так що <code>f a b c</code> те саме, що і <code>( (f a) b) c))</code>, застосування функції з <code>$</code> є право-асоциативним.</p></div>
<div class="paragraph"><p>Все це дуже добре, але як це допоможе нам? Більшість часу це зручна функція, так що нам не треба писати стільки багато дужок. Розглянемо вираз <code>sum (map sqrt [1..130])</code>. Оскільки <code>$</code> має такий малий преоритет, ми можемо переписати вираз як  <code>sum $ map sqrt [1..130]</code>, зберігши свої коштовні натискання клавіш! Коли трапляється <code>$</code>, вираз зправа застосовується як параметр до функції зліва. Як щодо <code>sqrt 3 + 4 + 9</code>? Це додає разом <code>9</code>, <code>4</code>, та квадратний корінь від <code>3</code>. Якщо ми бажаємо отримати корінь від <code>3 + 4 + 9</code>, ми маємо записати <code>sqrt (3 + 4 + 9)</code>, або, якщо ми використовуємо <code>$</code>, ми можемо записати це як <code>sqrt $ 3 + 4 + 9</code>, оскільки <code>$</code> має найменьший преоритет відносно любого оператора. Ось чому ви можете уявляти <code>$</code> як різновид еквіваленту написання відкритих дужок, та потім написання закриваючих з самого правого краю виразу.</p></div>
<div class="paragraph"><p>Як щодо <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>? Гаразд, оскільки <code>$</code> є право-асоциативною, <code>f (g (z x))</code> еквівалентне до <code>f $ g $ z x</code>. Так що ми можемо переписати <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code> як <code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>.</p></div>
<div class="paragraph"><p>Але крім покладання краю дужкам <code>$</code> означає, що застосування функції можна розглядати просто як іншу функцію. Таким чином ми можемо, наприклад, відобразити застосування функції на список функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="o">$</span> <span class="mi">3</span><span class="p">)</span> <span class="p">[(</span><span class="mi">4</span><span class="o">+</span><span class="p">),</span> <span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="p">),</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">),</span> <span class="n">sqrt</span><span class="p">]</span>
<span class="p">[</span><span class="mf">7.0</span><span class="p">,</span><span class="mf">30.0</span><span class="p">,</span><span class="mf">9.0</span><span class="p">,</span><span class="mf">1.7320508075688772</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>В математиці композиція (також відома як суперпозиція. прим. перекл.) функцій визначається так:  <code>(f . g)(x) = f(g(x))</code>, що означає, що композиція двох функцій продукує нову функцію, що, коли викликаєтья з параметром, скажімо <code>x</code>, є еквалентним до виклику <code>g</code> з параметром <code>x</code>, та потім виклику <code>f</code> з її результатом.</p></div>
<div class="paragraph"><p>В Haskell композиція функцій є гарною мірою те саме. Ми робимо композицію функції за допомогою функції <code>.</code>, що визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="o">.</span><span class="p">)</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="o">.</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/notes.png" alt="images/notes.png" />
</span>
Подумайте про декларацію типу. <code>f</code> має приймати в якості параметра значення, що має той самий тип, що і тип повернення <code>g</code>. Так що результуюча функція бере параметр того самого типу, що бере <code>g</code>, та повертає значення того самого типу, що повертає <code>f</code>. Вираз <code>negate . (* 3)</code> повертає функцію, що приймає число, множить його на <code>3</code>, та потім змінює знак.</p></div>
<div class="paragraph"><p>Одне з використань композиції функцій є створення функцій на льоту, щоб передати в інші функції. Напевно для цього можливо використовувати лямбди, але в багатьох випадках композиція функцій ясніша та більш стисла. Скажімо, ви маєте список чисел, і ми бажаємо перетворити їх всі в від'ємні числа. Один зі способів буде отримати абсолютне значення кожного числа, та потім обернути його:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">negate</span> <span class="p">(</span><span class="n">abs</span> <span class="n">x</span><span class="p">))</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте лямбду, і як це виглядає як результат композиції функцій, що ми запишемо таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">negate</span> <span class="o">.</span> <span class="n">abs</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="mi">24</span><span class="p">]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">7</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">19</span><span class="p">,</span><span class="o">-</span><span class="mi">24</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дивовижно! Композиція функцій право-асоциативна, так що ми можемо компонувати багато функцій одночасно. Вираз <code>f (g (z x))</code> еквівалентний до <code>(f . g . z) x</code>. Маючи це на думці, ми можемо перетворити</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">xs</span> <span class="ow">-&gt;</span> <span class="n">negate</span> <span class="p">(</span><span class="n">sum</span> <span class="p">(</span><span class="n">tail</span> <span class="n">xs</span><span class="p">)))</span> <span class="p">[[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">27</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>на</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="n">negate</span> <span class="o">.</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">tail</span><span class="p">)</span> <span class="p">[[</span><span class="mi">1</span><span class="o">..</span><span class="mi">5</span><span class="p">],[</span><span class="mi">3</span><span class="o">..</span><span class="mi">6</span><span class="p">],[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]]</span>
<span class="p">[</span><span class="o">-</span><span class="mi">14</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">27</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Але щодо функцій, що приймають декілька параметрів? Гаразд, якщо ми бажаємо використовувати їх в композиції функцій, ми маємо частково застосувати їх, тільки в тій мірі, щоб кожна функція приймала один параметр. <code>sum (replicate 5 (max 6.7 8.9))</code> може бути переписана як <code>(sum . replicate 5 . max 6.7) 8.9</code> або як <code>sum . replicate 5 . max 6.7 $ 8.9</code>. Ось що тут відбувається: створюється функція, що приймає <code>max 6.7</code> бере та застосовує <code>replicate 5</code> до цього. Потім створюється функція, що бере результат від того, та робить суму. Нарешті ця функція викликається з <code>8.9</code>. Але звичайно ви читаєте це просто так: застосувати <code>8.9</code> до <code>max 6.7</code>, потім застосувати <code>replicate 5</code> до цього, та потім застосувати <code>sum</code> до отриманого. Якщо ви бажаєте записати вираз з багатьма дужками через композицію функцій, ви можете почати з покладання останнього параметра самої внутрішньої функції після <code>$</code>, та потім скомпонувати всі інші виклики функцій, записуючи їх без останнього параметру, та ставлячи між ними крапку. Якщо ви маєте <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>, ви можете записати це як <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>. Якщо вираз завершується на три дужки, є шанси що після трансляції в композицію функцій це буде мати три оператори композиції.</p></div>
<div class="paragraph"><p>Інше загальне використання композиції функцій є визначення функцій в так званому стилі вільних крапок (також називається безглуздим стилем). Візьміть для прикладу цю функцію, що ми записали раніше :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">sum&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">sum&#39;</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">0</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p><code>xs</code> з'являється з обох боків. Завдяки каруванню ми можемо уникнути <code>xs</code> з обох боків, оскільки <code>foldl (+) 0</code> створює функцію, що приймає список. Запис функції як <code>sum' = foldl (+) 0</code> називається запис в стилі вільних крапок. Як ми повинні писати в цьому стилі?</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fn</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">ceiling</span> <span class="p">(</span><span class="n">negate</span> <span class="p">(</span><span class="n">tan</span> <span class="p">(</span><span class="n">cos</span> <span class="p">(</span><span class="n">max</span> <span class="mi">50</span> <span class="n">x</span><span class="p">))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми не можемо просто позбутись від <code>x</code> з обох боків. <code>x</code> в тілі функції має дужки за собою. <code>cos (max 50)</code> не матиме сенсу. Ви не можете взяти косінус від функції. Що ми можете зробити, це виразити <code>fn</code> як композицію функцій.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fn</span> <span class="ow">=</span> <span class="n">ceiling</span> <span class="o">.</span> <span class="n">negate</span> <span class="o">.</span> <span class="n">tan</span> <span class="o">.</span> <span class="n">cos</span> <span class="o">.</span> <span class="n">max</span> <span class="mi">50</span>
</pre></div></div></div>
<div class="paragraph"><p>Чудово! В багатьох випадках цей стиль більш читабельний та стислий,оскікльки він дає вам мислити щодо функцій і який тип функцій компонується для отримання результату, замість того, щоб думати про дані і як вони тусуються між собою. Ви можете брати прості функції та використовувати композицію як клей, щоб формувати більш складні функції. Однак в багатьох випадках написання функції в крапках може бути меньш читабельним, якщо функція дуже складна. Ось чому робити довгі ланцюжки з композиції функцій не заохочується, але я визнаю себе винним, що іноді буваю композиціє-щасливим. Бажаний стиль є використання <code>let</code> прив'язок для отримання міток для проміжних результатів, або розділення проблеми на суб-проблеми, та потім збирання їх разом, так щоб функція мала сенс для декого, хто читає її, замість того, щоб робити гігантський ланцюг композиції.</p></div>
<div class="paragraph"><p>В розділі про мапи та фільтри ми вирішили проблему пошуку суми з усіх непарних квадратів, що меньше за <code>10000</code>. Ось як виглядає рішення, коли воно покладено в функцію.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span> <span class="n">sum</span> <span class="p">(</span><span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="p">(</span><span class="n">filter</span> <span class="n">odd</span> <span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">])))</span>
</pre></div></div></div>
<div class="paragraph"><p>Будучи таким фанатом композиції функцій, я міг би можливо записати це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">.</span> <span class="n">filter</span> <span class="n">odd</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо є шанси, що хтось інший буде читати цей код, я б переписав це таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">oddSquareSum</span> <span class="ow">::</span> <span class="kt">Integer</span>
<span class="nf">oddSquareSum</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">oddSquares</span> <span class="ow">=</span> <span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
        <span class="n">belowLimit</span> <span class="ow">=</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="n">oddSquares</span>
    <span class="kr">in</span>  <span class="n">sum</span> <span class="n">belowLimit</span>
</pre></div></div></div>
<div class="paragraph"><p>Це не виграє змагання з кодового гольфу, але дехто читаючи цю функцію винайде її читання простіше, ніж ланцюжок композицій.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/modules.png" alt="images/modules.png" />
</span>
Модуль Haskell є колекцією пов'язаних функцій, типів та типокласів. Програма Haskell є колекцією модулів, де головний модул завантажує інші модулі, та потім використовує функції, визначені в них, щоб зробити дещо. Мати код поділеним на декілька модулів має досить багато переваг. Якщо модуль досить загальний, функції, які він експортує, можуть бути використані в безлічі різних програм. Якщо ваш власний код поділений на само-достатні модулі, що не покладаються один на одний дуже сильно (ми кажемо що вони слабко пов'язані), в падольшому ви можете використовувати їх. Це робить всю справу написання коду більш керованою, маючи поділеним його на окремі частини, кожна з яких має власне призначення.</p></div>
<div class="paragraph"><p>Стандартна бібліотека Haskell поділена на модулі, кожний з них містить функції та типи, які деяким чином пов'язані та служать деякій загальній цілі. Є модуль для маніпуляцій зі списками, модуль для конкурентного програмування, модуль для справ з комплексними числами, тощо. Всі функції, типи та типокласи, з якими ми досі мали справу, були частиною модуля <code>Prelude</code>, що імпортується по замовчанню. В цій главі ми збираємось дослідити декілька корисних модулів та функцій, що вони мають. Але спочатку ми збираємось подивитись, як імпортувати модулі.</p></div>
<div class="paragraph"><p>Синтаксис для імпортування модулів в скрипті Haskell є <code>import &lt;module name&gt;</code>. Це має бути зроблене перед визначенням любих функцій, так що імпорти звичайно робляться зверху файла. Звичайно, один скрипт може імпортувати декілька модулів. Просто покладіть кожний імпорт в окремий рядок. Давайте імпортуємо модуль <code>Data.List</code>, що має декілька корисних функцій для роботи зі списками, та використаємо функцію, що він експортує, для створення функції, що каже нам, як багато унікальних елементів має наш список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span>

<span class="nf">numUniques</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">numUniques</span> <span class="ow">=</span> <span class="n">length</span> <span class="o">.</span> <span class="n">nub</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви робите <code>import Data.List</code>, всі функції, що експортує <code>Data.List</code>, стають доступними в глобальному просторі імен, що значить, що ви можете викликати їх будь-деme в скрипті. <code>nub</code> є функція, визначена в <code>Data.List</code>, що приймає список і відкидає дубліковані елементи. Компонуючи <code>length</code> та <code>nub</code> роблячи <code>length . nub</code> продукує функцію, що еквівалентна до <code>\xs -&gt; length (nub xs)</code>.</p></div>
<div class="paragraph"><p>Ви також можете покласти функції модулів в глобальний простір імен при використанні GHCI. Якщо ви в GHCI, і ви бажаєте бути в змозі викликати функції, експортовані <code>Data.List</code>, зробіть це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте завантажити імена з декількох модулів всередині GHCI, ми не маємо робити <code>:m +</code> декілька раз, ми можемо просто завантажити декілька модулів за один раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">m</span> <span class="o">+</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">List</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Map</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Set</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак якщо ви завантажили скрипт, що вже імпортує модуль, вам не треба використовувати <code>:m +</code> щоб отримати доступ до нього.</p></div>
<div class="paragraph"><p>Якщо вам просто треба пара функцій з модуля, ви можете вибірково імпортувати лише ці функції. Якщо ви бажаєте імпортувати тільки функції <code>nub</code> та <code>sort</code> з <code>Data.List</code>, ми робимо так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="p">(</span><span class="nf">nub</span><span class="p">,</span> <span class="nf">sort</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете також обрати імпорт всіх функцій з модуля, за винятком декількох обраних. Це часто корисно, коли декілька модулів експортують функції з тим самим іменем, і ви бажаєте прибрати заважаючі варіанти. Скажімо, ми вже маємо нашу власну функцію, що називається <code>nub</code>, і ми бажаємо імпортувати всі функції з <code>Data.List</code>, за винятком функції <code>nub</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Data.List</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">nub</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший шлях мати справу з класами з перетином імен - робити кваліфіковані імпорти. Модуль <code>Data.Map</code>, що пропонує структуру даних для пошуку значень по ключу, експортує декілька функцій з тими ж назвами, що і функції <code>Prelude</code>, як <code>filter</code> або <code>null</code>. Так що коли ми імпортуємо <code>Data.Map</code> і потім викликаємо <code>filter</code>, Haskell не знає, яку функцію використовувати. Ось як ми вирішуємо це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить так, що коли ми бажаємо посилатись на функцію <code>Data.Map</code>  <code>filter</code>, ми маємо робити <code>Data.Map.filter</code>, коли тільки <code>filter</code> все ще посилається на нормальний <code>filter</code>, який ми всі знаємо і любимо. Але набір <code>Data.Map</code> перед кожною функцію з цього модуля є дещо обтяжливо. Осі чому ми можемо переіменувати кваліфікований імпорт на дещо коротше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">M</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер для посилання на функцію <code>Data.Map</code> <code>filter</code> ми виристовуємо лише <code>M.filter</code>.</p></div>
<div class="paragraph"><p>Використовуйте це зручне посилання, щоб побачити, які модулі є в стандартній бібліотеці. Гарний спосіб отримати нове знання щодо Haskell є просто клацати по посиланню стандартної бібліотеки, та досліджувати модулі та їх функції. Ви можете також передивлятись джерельний код Haskell для кожного модуля. Читання джерельного коду для деяких модулів є дійсно гарним шляхом вивчати Haskell та отримати солідне відчуття мови.</p></div>
<div class="paragraph"><p>Для пошуку функцій або для пошуку, де вони розташовані, використовуйте <code>Hoogle</code>. Це дійсно неймовірна пошукова система Haskell, ви можете шукати по імені, імені модуля або навіть сигнатурі типу.</p></div>
<div class="paragraph"><p>Модуль <code>Data.List</code> це все про списки, це очевидно. Він провадить деякі дуже корисні функції для роботи з ними. Ми вже зустрічались з деяким з ціх функцій (як <code>map</code> та <code>filter</code>), оскільки модуль <code>Prelude</code> експортує деякі функції з <code>Data.List</code> для зручності. Ви не маєте імпортувати <code>Data.List</code> через кваліфікований імпорт, оскільки його імена не перетинаються з жодними іменами <code>Prelude</code>, за винятком тих, що <code>Prelude</code> вже краде у <code>Data.List</code>. Давайте поглянемо на деякі функції, з якими ми раніше не зустрічались.</p></div>
<div class="paragraph"><p><code>intersperse</code> бере елемент та список, і потім покладає цей елемент між кожною парою елементів списка. Ось демонстрація:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="sc">&#39;.&#39;</span> <span class="s">&quot;MONKEY&quot;</span>
<span class="s">&quot;M.O.N.K.E.Y&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intersperse</span> <span class="mi">0</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intercalate</code> бере лист список списків, і список. Потім він вставляє цей список між всіма ціма списками, і потім сплощує результат.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="s">&quot; &quot;</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there guys&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intercalate</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>transpose</code> траспонує список списків. Якщо ви подивитесь на список списків як на 2D матрицю, стовпчики стають рядками та навпаки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">transpose</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">]</span>
<span class="p">[</span><span class="s">&quot;htg&quot;</span><span class="p">,</span><span class="s">&quot;ehu&quot;</span><span class="p">,</span><span class="s">&quot;yey&quot;</span><span class="p">,</span><span class="s">&quot;rs&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Скажімо, ми маємо поліноми <code>3x2 + 5x + 9</code>, <code>10x3 + 9</code> та <code>8x3 + 5x2 + x - 1</code> і ми бажаємо додати їх разом. Ми можемо використати списки <code>[0,3,5,9]</code>, <code>[10,0,0,9]</code> та <code>[8,5,1,-1]</code> для представлення їх в Haskell. Тепер щоб додати їх, все що треба зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">transpose</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">10</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">9</span><span class="p">],[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">18</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">17</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми транспонуємо ці три списки, три куби опиняться в першому рядку, квадрати в другому, і так далі. Відображуючи <code>sum</code> на це продукує бажаний результат.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/lists.png" alt="images/lists.png" />
</span>
<code>foldl'</code> та <code>foldl1'</code> є суворіші версії відносно до своїх лінивих інкарнацій. Коли використовуються ліниві згортки на дійсно списках, часто ви можете отримати помилку переповнення стеку. Винуватцем цього є те, що через ліниву природу згорток значення аккумулятора насправді не оновлюється по мірі згортки. Що насправді відбувається, це те, що аккумулятор робить свого роду обіцянки, що віе обчислить своє значення, коли попросять дійсно зпродукувати результат (що також називається грім). Це відбувається для кожного проміжного аккумулятора, і всі ці громи переповнюють ваш стек. Сувора згортка не така лінива істота, та насправді обчислює проміжні значення по мірі надходження, замість заповнювати ваш стек. Так що якщо ви колись отримаєте переповнення стеку роблячи ліниві згортки, спробуйте переключитись на їх суворі версії.</p></div>
<div class="paragraph"><p><code>concat</code> зрівнює список списків в просто список елементів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[</span><span class="s">&quot;foo&quot;</span><span class="p">,</span><span class="s">&quot;bar&quot;</span><span class="p">,</span><span class="s">&quot;car&quot;</span><span class="p">]</span>
<span class="s">&quot;foobarcar&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concat</span> <span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Він буде видаляти лише один рівень вкладення. Так що якщо ви бажаете повністю сплющити <code>[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</code>, що є списком списків списків, ви маєте виконати конкатенацію двічі.</p></div>
<div class="paragraph"><p>Виконання <code>concatMap</code> є те саме, що спочатку відобразити функцію на список, та потім конкатувати список <code>concat</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">concatMap</span> <span class="p">(</span><span class="n">replicate</span> <span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>and</code> бере список логічних значень, та повертає <code>True</code> тільки якщо всі значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">and</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>or</code> подібне до <code>and</code>, тільки повертає <code>True</code> якщо любе логічне значення в списку є <code>True</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">or</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>any</code> та <code>all</code> беруть предикат, та потім перевіряють, чи якісь або всі елементи списку задовільняють предикату, відповідно. Звичайно ми використовуємо ці дві функції замість відображення по списку, та потім робити <code>and</code> або <code>or</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">any</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;HEYGUYSwhatsup&quot;</span>
<span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>iterate</code> бере функцію та початкове значення. Вона застосовує функцію до стартового значення, потім вона застосовує цю функцію до результату знову, тощо. Вона повертає всі результати в формі безкінечного списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">10</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">64</span><span class="p">,</span><span class="mi">128</span><span class="p">,</span><span class="mi">256</span><span class="p">,</span><span class="mi">512</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">take</span> <span class="mi">3</span> <span class="o">$</span> <span class="n">iterate</span> <span class="p">(</span><span class="o">++</span> <span class="s">&quot;haha&quot;</span><span class="p">)</span> <span class="s">&quot;haha&quot;</span>
<span class="p">[</span><span class="s">&quot;haha&quot;</span><span class="p">,</span><span class="s">&quot;hahahaha&quot;</span><span class="p">,</span><span class="s">&quot;hahahahahaha&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>splitAt</code> бере число та список. Потім вона розділяє список на це число елементів, повертаючи два списки як тапл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;man&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="mi">100</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;heyman&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">splitAt</span> <span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="s">&quot;heyman&quot;</span>
<span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;heyman&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="ow">=</span> <span class="n">splitAt</span> <span class="mi">3</span> <span class="s">&quot;foobar&quot;</span> <span class="kr">in</span> <span class="n">b</span> <span class="o">++</span> <span class="n">a</span>
<span class="s">&quot;barfoo&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>takeWhile</code> є дійсно корисною невеликою функцією. Вона бере елементи зі списку доки виконується предикат, та коли трепиться елемент, що не задовільняє, вона відсікає всі інші. Як з'ясовується ще дуже корисно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Скажімо, ми бажаємо знати суму всіх третіх ступінів, що є до <code>10000</code>. Ми не можемо зробити <code>map (^3)</code> до <code>[1..]</code>, застосувати <code>filter</code> та потім спробувати підсумувати все це, бо фільтр на безкінечному спіску ніколи не завершиться. Ви можете знати, що всі елементи ідуть по зростанню, але Haskell ні. Ось чому ми можемо зробити це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sum</span> <span class="o">$</span> <span class="n">takeWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">10000</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="o">^</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]</span>
<span class="mi">53361</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми застосовуємо <code>(^3)</code> до безкінечного списку, та потім, коли це буде більше <code>10000</code>, список буде обрізаний. Тепер ми можемо його легко підсумувати.</p></div>
<div class="paragraph"><p><code>dropWhile</code> є подібним, тільки вона відкидає всі елементи, доки виконується предикат. Як тільки предикат дорівнює <code>False</code>, вона повертає залишок списку. Вкрай корисна і мила функція!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot; is a sentence&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">dropWhile</span> <span class="p">(</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми надали список, що представляє значення акцій по даті. Список складається з таплів, чий перший компонент є значення курсу акцій, другий елемент рік, третій місяць а четвертий дата. Ми бажаємо знати, коли значення акцій вперше перевищило тисячу доларів!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">stock</span> <span class="ow">=</span> <span class="p">[(</span><span class="mf">994.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mf">995.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mf">999.2</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mf">998.3</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">head</span> <span class="p">(</span><span class="n">dropWhile</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">)</span> <span class="n">stock</span><span class="p">)</span>
<span class="p">(</span><span class="mf">1001.4</span><span class="p">,</span><span class="mi">2008</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>span</code> дещо як <code>takeWhile</code>, тільки він повертає пару списків. Перший список містить все, що містив би результуючий список <code>takeWhile</code>, коли б ми викликали його з тим самим предикатом та тим самим списком. Другий список містить частину списку, що мала б бути відкинутою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">fw</span><span class="p">,</span> <span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="s">&quot;This is a sentence&quot;</span> <span class="kr">in</span> <span class="s">&quot;First word:&quot;</span> <span class="o">++</span> <span class="n">fw</span> <span class="o">++</span> <span class="s">&quot;, the rest:&quot;</span> <span class="o">++</span> <span class="n">rest</span>
<span class="s">&quot;First word: This, the rest: is a sentence&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Тоді як <code>span</code> поділяє список доки предикат вірний, <code>break</code> перериває коли предикат стає перший раз <code>True</code>. Зробити <code>break p</code> є еквівалентним зробити <code>span (not . p)</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">break</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(</span><span class="o">/=</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>При використанні <code>break</code>, другий список в результаті буде починатись з першого елементу, що задовільняє предикату.</p></div>
<div class="paragraph"><p><code>sort</code> просто сортує список. Тип елементів в списку має бути частиною типокласу <code>Ord</code>, оскільки якщо елементи списку не можуть бути покладені в деякому порядку, тоді такий список неможливо відсортувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sort</span> <span class="s">&quot;This will be sorted soon&quot;</span>
<span class="s">&quot;    Tbdeehiillnooorssstw&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>group</code> бере список та групує сусідні елементи в субсписки, якщо вони рівні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">group</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">5</span><span class="p">],[</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми вортуємо список перед групуванням, ми можемо знайти, скільки разів кожний елемент з'являється в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="n">l</span><span class="o">@</span><span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">length</span> <span class="n">l</span><span class="p">))</span> <span class="o">.</span> <span class="n">group</span> <span class="o">.</span> <span class="n">sort</span> <span class="o">$</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">7</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>inits</code> та <code>tails</code> подібні до <code>init</code> та <code>tail</code>, тільки вони рекурсивно застосовуються до списку, доки нічого не залишиться. Дослідимо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">inits</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">tails</span> <span class="s">&quot;w00t&quot;</span>
<span class="p">[</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">w</span> <span class="ow">=</span> <span class="s">&quot;w00t&quot;</span> <span class="kr">in</span> <span class="n">zip</span> <span class="p">(</span><span class="n">inits</span> <span class="n">w</span><span class="p">)</span> <span class="p">(</span><span class="n">tails</span> <span class="n">w</span><span class="p">)</span>
<span class="p">[(</span><span class="s">&quot;&quot;</span><span class="p">,</span><span class="s">&quot;w00t&quot;</span><span class="p">),(</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="s">&quot;00t&quot;</span><span class="p">),(</span><span class="s">&quot;w0&quot;</span><span class="p">,</span><span class="s">&quot;0t&quot;</span><span class="p">),(</span><span class="s">&quot;w00&quot;</span><span class="p">,</span><span class="s">&quot;t&quot;</span><span class="p">),(</span><span class="s">&quot;w00t&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Давайте використаємо <code>fold</code> для реалізації пошуку підсписку в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">search</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">search</span> <span class="n">needle</span> <span class="n">haystack</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">nlen</span> <span class="ow">=</span> <span class="n">length</span> <span class="n">needle</span>
    <span class="kr">in</span>  <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">acc</span> <span class="n">x</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">take</span> <span class="n">nlen</span> <span class="n">x</span> <span class="o">==</span> <span class="n">needle</span> <span class="kr">then</span> <span class="kt">True</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">False</span> <span class="p">(</span><span class="n">tails</span> <span class="n">haystack</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Спочатку ми викликаємо <code>tails</code> зі списком, в якому ми шукаємо. Потім ми проходимо по кожному хвосту, та дивимось, чи він починається з того, що ми шукаємо.</p></div>
<div class="paragraph"><p>Маючи це, ми насправді лише зробили функцію, що поводиться як <code>isInfixOf</code>. <code>isInfixOf</code> шукає субсписок, та повертає <code>True</code>, якщо субсписок, що ми шукаємо, десь всередині цільового списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Cat&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;cats&quot;</span> <span class="p">`</span><span class="n">isInfixOf</span><span class="p">`</span> <span class="s">&quot;im a cat burglar&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>isPrefixOf</code> та <code>isSuffixOf</code> шукають субсписок напочатку та в кінці списку, відповідно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey&quot;</span> <span class="p">`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there!&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;there!&quot;</span> <span class="p">`</span><span class="n">isSuffixOf</span><span class="p">`</span> <span class="s">&quot;oh hey there&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elem</code> та <code>notElem</code> перевіряють, чи елемент є або його немає в списку.</p></div>
<div class="paragraph"><p><code>partition</code> бере список та предикат, та повертає пару списків. Перший список в результаті містить всі списки, що задовільняють предикату, другий містить всі що не задовільняють.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOBMORGAN&quot;</span><span class="p">,</span><span class="s">&quot;sidneyeddy&quot;</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">partition</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="p">([</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Важливо розуміти, як це відрізняється від <code>span</code> та <code>break</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">span</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;BOBsidneyMORGANeddy&quot;</span>
<span class="p">(</span><span class="s">&quot;BOB&quot;</span><span class="p">,</span><span class="s">&quot;sidneyMORGANeddy&quot;</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли <code>span</code> та <code>break</code> завершуються коли вони натраплять на перший елемент, що не- або задовільняє предикату, <code>partition</code> проходить по цілому списку, та розділяє його відповідно предиката.</p></div>
<div class="paragraph"><p><code>find</code> бере список та предикат, та повертає перший елемент, що задовільняє предикату. Але він повертає цей елемент огорнутим в значення <code>Maybe</code>. Ми будемо розглядати алгебраїчні типи даних більш детально в наступній главі, але доки це все що ви маєте знати: значення <code>Maybe</code> може бути або <code>Just</code> дещо або <code>Nothing</code>. Так само, як список може бути або порожнім, або списком з якимось елементами, значення <code>Maybe</code> може бути або без елементів, або мати один елемент. І так само, як тип списку, скажімо, цілих є <code>[Int]</code>, тип можливо цілого значення є <code>Maybe Int</code>. В жодному разі розкрутимо нашу функцію <code>find</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">find</span> <span class="p">(</span><span class="o">&gt;</span><span class="mi">9</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">find</span>
<span class="nf">find</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте тип <code>find</code>. Його результат є <code>Maybe a</code>. Це майже так само, як мати тип <code>[a]</code>, тільки значення типу <code>Maybe</code> можуть містити або елемент, або нічого, тоді як список може не мати жодного, мати один або мати декілька елементів.</p></div>
<div class="paragraph"><p>Згадайте, як ми шукали, коли перший раз наші акції дійшли більше <code>$1000</code>. Ми робили <code>head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</code>. Згадайте, що <code>head</code> насправді не досить безпечна. Що має трапитись, якщо курс ніколи не доходить за <code>$1000</code>? Наше застосування <code>dropWhile</code> буде повертати порожній список, та отримання <code>head</code> від порожнього списку призведе до помилки. Однак якщо ми перепишемо це як <code>(\(val,y,m,d) -&gt; val &gt; 1000) stock</code>, ми будемо значно безпечніше. Якщо наші акції ніколи не заходять за <code>$1000</code> (так що немає жодного елементу, що задовільняє предикату), ми отримуємо назад <code>Nothing</code>. Але якщо в списку була валідна відповідь в списку, ми б отримали б, скажімо <code>Just (1001.4,2008,9,4)</code>.</p></div>
<div class="paragraph"><p><code>elemIndex</code> є різновидом <code>elem</code>, тільки він не повертає логічне значення. Він можливо повертає індекс елемента, який ми шукаємо. Якщо такого елемента немає в нашому списку, він повертає <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">elemIndex</span>
<span class="nf">elemIndex</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="kt">Int</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">4</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="p">`</span><span class="n">elemIndex</span><span class="p">`</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p><code>elemIndices</code> подібна до <code>elemIndex</code>, тільки вона повертає список індексів, в випадку, коли елемент що ми шукаємо знаходиться в нашому списку декілька раз. Оскільки ми використовуємо список для представлення індексов, нам не треба тип <code>Maybe</code>, тому невдача може бути представлена як порожній список, що є досить синонімичнім до <code>Nothing</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="sc">&#39; &#39;</span> <span class="p">`</span><span class="n">elemIndices</span><span class="p">`</span> <span class="s">&quot;Where are the spaces?&quot;</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>findIndex</code> подібне до <code>find</code>, але вона можливо повертає індекс першого елемента, що задовільняє предикату. <code>findIndices</code> повертає індекси всіх елементів, що задовільняють предикату в формі списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">4</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Just</span> <span class="mi">5</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndex</span> <span class="p">(</span><span class="o">==</span><span class="mi">7</span><span class="p">)</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="kt">Nothing</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findIndices</span> <span class="p">(`</span><span class="n">elem</span><span class="p">`</span> <span class="p">[</span><span class="sc">&#39;A&#39;</span><span class="o">..</span><span class="sc">&#39;Z&#39;</span><span class="p">])</span> <span class="s">&quot;Where Are The Caps?&quot;</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми вже розглядали <code>zip</code> та <code>zipWith</code>. Ми зауважили, що вони поеднують разом два списки, або в тапл, або за допомогою двомісної функції (що означає, що функція приймає два параметра). Але що, коли ви бажаєте поеднати разом три списки? Або поєднати три списки за допомогою функції, що приймає три параметри? Гаразд, для цього ми маємо <code>zip3</code>, <code>zip4</code>, тощо, та <code>zipWith3</code>, <code>zipWith4</code>, etc. Ці варіанти ідуть до <code>7</code>. Хоча це може виглядати як хак, це робить досить гарно, оскільки не дуже часто трапляються випадки, коли вам треба поєднати 8 списків. Також існую розумний спосіб поєднати довільне число списків, але ми не досить просунулись, щоб розглядати його прямо тут.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zipWith3</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">zip4</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Так само, як з нормальним поєднанням, списки, що довші ніж найкоротший список, відсікаються до його розміру.</p></div>
<div class="paragraph"><p><code>lines</code> є корисною функцією, коли маємо справу з файлами або ввод від чогось іншого. Вона приймає рядок, та повертає кожний рядок в окремий список.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">lines</span> <span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line&quot;</span>
<span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span><span class="s">&quot;second line&quot;</span><span class="p">,</span><span class="s">&quot;third line&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>'\n'</code> є символ для нового рядка Юнікс. Зворотні косі мають особливе значення в Haskell рядках та символах.</p></div>
<div class="paragraph"><p><code>unlines</code> є зворотньою до <code>lines</code> функцією. Вона приймає список рядків, та потім поєднує їх разом з використанням <code>'\n'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unlines</span> <span class="p">[</span><span class="s">&quot;first line&quot;</span><span class="p">,</span> <span class="s">&quot;second line&quot;</span><span class="p">,</span> <span class="s">&quot;third line&quot;</span><span class="p">]</span>
<span class="s">&quot;first line</span><span class="se">\n</span><span class="s">second line</span><span class="se">\n</span><span class="s">third line</span><span class="se">\n</span><span class="s">&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>words</code> та <code>unwords</code> призначені для поділу рядка тексту на слова, або поєднання списку слов в текст. Дуже корисно.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these are the words in this sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey these           are    the words in this</span><span class="se">\n</span><span class="s">sentence&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;these&quot;</span><span class="p">,</span><span class="s">&quot;are&quot;</span><span class="p">,</span><span class="s">&quot;the&quot;</span><span class="p">,</span><span class="s">&quot;words&quot;</span><span class="p">,</span><span class="s">&quot;in&quot;</span><span class="p">,</span><span class="s">&quot;this&quot;</span><span class="p">,</span><span class="s">&quot;sentence&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">unwords</span> <span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;there&quot;</span><span class="p">,</span><span class="s">&quot;mate&quot;</span><span class="p">]</span>
<span class="s">&quot;hey there mate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми вже згадували <code>nub</code>. Він бере список та відкидає дублікати елементів, повертаючи список, кожний елемент якого є унікальною сніжинкою! Функція має дещо дивне ім'я. Виявляється, що <code>"nub"</code> означає малу грудку або головну частину чогось. По-моєму для назв функцій треба використовувати справжні слова, замість застарілих.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;Lots of words and stuff&quot;</span>
<span class="s">&quot;Lots fwrdanu&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>delete</code> бере елемент і список, і видаляє перше входження елемента в списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey there ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere ghang!&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">.</span> <span class="n">delete</span> <span class="sc">&#39;h&#39;</span> <span class="o">$</span> <span class="s">&quot;hey there ghang!&quot;</span>
<span class="s">&quot;ey tere gang!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>\\</code> є функцією різниці. Вона діє як різниця множин, в основному. Для кожного елементу зправа вона видаляє елемент в лівому списку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span> <span class="o">\\</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;Im a big baby&quot;</span> <span class="o">\\</span> <span class="s">&quot;big&quot;</span>
<span class="s">&quot;Im a  baby&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зробити <code>[1..10] \\ [2,5,9]</code> це як зробити <code>delete 2 . delete 5 . delete 9 $ [1..10]</code>.</p></div>
<div class="paragraph"><p><code>union</code> також діє як функція на множинах. Вона повертає поєднання двох списків. Вона добряче проходиться по кожному елементу в другому списку, та додає його до першого, якщо його там ще немає. Однак начувайтесь, дублікати видаляються з другого списку!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="s">&quot;hey man&quot;</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="s">&quot;man what&#39;s up&quot;</span>
<span class="s">&quot;hey manwt&#39;sup&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">union</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intersect</code> робить як перетин множин. Вона повертає тільки ті елементи, що знайдені в обох списках.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">7</span><span class="p">]</span> <span class="p">`</span><span class="n">intersect</span><span class="p">`</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insert</code> бере елемент та список, що може бути відсортований, та вставляє його в останню позицію, де він все ще меньший або рівний наступному елементу. Іншими словами <code>insert</code> буде починати на початку списку, та потім продовжувати, доки не знайде елемент, що більше або дорівнює нашому елементу, який він вставляє, і робить вставку перед цім елементом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>4</code> вставлене прямо після <code>3</code> та перед <code>5</code> в першому прикладі, та між <code>3</code> і <code>4</code> в другому прикладі.</p></div>
<div class="paragraph"><p>Якщо ми вставляємо в відсортований список, отриманий список буде також відсортований.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">4</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="sc">&#39;g&#39;</span> <span class="o">$</span> <span class="p">[</span><span class="sc">&#39;a&#39;</span><span class="o">..</span><span class="sc">&#39;f&#39;</span><span class="p">]</span> <span class="o">++</span> <span class="p">[</span><span class="sc">&#39;h&#39;</span><span class="o">..</span><span class="sc">&#39;z&#39;</span><span class="p">]</span>
<span class="s">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">insert</span> <span class="mi">3</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що загального між <code>length</code>, <code>take</code>, <code>drop</code>, <code>splitAt</code>, <code>!!</code> та <code>replicate</code>, це те, що вони приймають <code>Int</code> в якості одного з параметрів (або повертають <code>Int</code>), навіть якщо вони могли б бути більш загальними та корисними, якщо б вони приймали любий тип, що є частиною типокласів <code>Integral</code> або <code>Num</code> (в залежності від функцій). Вони роблять це з історичних причин. Однак виправлення цього можливо зламає безліч існуючого коду. Ось чому <code>Data.List</code> має власні більш загальні еквіваленти, названі <code>genericLength</code>, <code>genericTake</code>, <code>genericDrop</code>, <code>genericSplitAt</code>, <code>genericIndex</code> та <code>genericReplicate</code>. Наприклад, довжина має сигнатуру типу <code>length::[a] -&gt; Int</code>. Якщо ми спробуємо отримати середнє від списку чисел, виконавши <code>let xs = [1..6] in sum xs / length xs</code>, ми отримаємо помилку типу, оскільки ви не можете використовувати <code>/</code> з <code>Int</code>. З іншого боку <code>genericLength</code> має сигнатуру <code>genericLength::(Num a) =&gt; [b] -&gt; a</code>. Оскільки <code>Num</code> може діяти як число з плаваючою крапкою, взяття середнього через виконання <code>let xs = [1..6] in sum xs / genericLength xs</code> робить гарно.</p></div>
<div class="paragraph"><p>Функції <code>nub</code>, <code>delete</code>, <code>union</code>, <code>intersect</code> та <code>group</code> всі мають свої більш загальні варіанти на ім'я <code>nubBy</code>, <code>deleteBy</code>, <code>unionBy</code>, <code>intersectBy</code> та <code>groupBy</code>. Різниця між ними в тому, що перший набір функцій використовує <code>==</code> для перевірки на рівність, тоді як <code>By</code> варіанти також приймають функцію еквівалентності, та потім порівнюють з використанням цієї функції. <code>group</code> є те ж саме, що і <code>groupBy (==)</code>.</p></div>
<div class="paragraph"><p>Наприклда, скажімо ми маємо список, що описує значення функції для кожної секунди. Ми бажаємо поділити її на субсписки, базуючись на тому, чи значення меньше або більше нуля. Якщо ми зробимо лише звичайне групування, це лише згрупує сусідні однакові значення. Але ми бажаємо згрупувати на основі того, чи воні від'ємні чи ні. Ось де з'являється <code>groupBy</code>! Функція еквівалентності, що надається до функцій <code>By</code>, повинні приймати две елементи того самого типу, і повертати <code>True</code>, якщо вони рівні за її стандартами.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">values</span> <span class="ow">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">,</span> <span class="mf">5.9</span><span class="p">,</span> <span class="mf">10.5</span><span class="p">,</span> <span class="mf">29.1</span><span class="p">,</span> <span class="mf">5.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">2.4</span><span class="p">,</span> <span class="o">-</span><span class="mf">14.5</span><span class="p">,</span> <span class="mf">2.9</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>З цього ми ясно бачимо, які частини є додатними, та які від'ємними. Надана функція рівності приймає два елементи, та потім повертає <code>True</code>, тільки якщо обоє є від'ємними або обоє додатними. Цю функцію рівності також можна записати як <code>\x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)</code>, хоча я думаю, що перший варіант краще читається. Навіть ясніший спосіб написати функцію рівності для функцій <code>By</code> є імпортувати функцію <code>on</code> з <code>Data.Function</code>. <code>on</code> визначена таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">on</span> <span class="ow">::</span> <span class="p">(</span><span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">c</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">c</span>
<span class="nf">f</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="n">y</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span> <span class="n">y</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що зробити <code>(==) ``on`</code> (&gt; 0)` повертає функцію рівності, що виглядає як <code>\x y -&gt; (x &gt; 0) == (y &gt; 0)</code>. <code>on</code> використовується з функціями <code>By</code>, бо з ним ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="p">(</span><span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="n">values</span>
<span class="p">[</span> <span class="p">[</span><span class="o">-</span><span class="mf">4.3</span><span class="p">,</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">1.2</span><span class="p">],[</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">2.3</span><span class="p">,</span><span class="mf">5.9</span><span class="p">,</span><span class="mf">10.5</span><span class="p">,</span><span class="mf">29.1</span><span class="p">,</span><span class="mf">5.3</span><span class="p">],[</span><span class="o">-</span><span class="mf">2.4</span><span class="p">,</span><span class="o">-</span><span class="mf">14.5</span><span class="p">],[</span><span class="mf">2.9</span><span class="p">,</span><span class="mf">2.3</span><span class="p">]</span> <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Вочевидь гарно читається! Ви можете прочитати це вголос: згрупувати це за рівністю, що настає коли елементи більші нуля.</p></div>
<div class="paragraph"><p>Подібним чином <code>sort</code>, <code>insert</code>, <code>maximum</code> та <code>minimum</code> також мають свої більш загальні еквіваленти. Функції як <code>groupBy</code> беруть функцію, що визначає, коли два елементи рівні. <code>sortBy</code>, <code>insertBy</code>, <code>maximumBy</code> та <code>minimumBy</code> беруть функцію, що визначає, чи елемент більший, меньший або рівний до іншого. Сигнатура типу <code>sortBy</code> є <code>sortBy::( a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>. Якщо ви пам'ятаєте з попереднього, тип <code>Ordering</code> має значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. <code>sort</code> еквівалентна до <code>sortBy compare</code>, оскільки тільки приймає два елементи, чиї типи в типокласі <code>Ord</code>, та повертає їх відношення впорядкування.</p></div>
<div class="paragraph"><p>Списки можуть бути порівняні, пле при цьому вони порівнюються лексографічно. Що, коли ми маємо список списків, та ми бажаємо сортувати їх не на основі їх вмісту, а на основі їх довжини? Так, ви майже здогадались, ми будемо використовувати функцію <code>sortBy</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">xs</span> <span class="ow">=</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">sortBy</span> <span class="p">(</span><span class="n">compare</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">length</span><span class="p">)</span> <span class="n">xs</span>
<span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>Неймовірно! <code>compare `on`</code> <code>length</code> &#8230; це читається майже як англійська! Якщо ви не впевнені, як саме це тут робить, <code>compare `on`</code> <code>length</code> еквівалентне до <code>\x y -&gt; length x `compare`</code> <code>length y</code>. Коли ви маєте справу з функціями <code>By</code>, що приймають функцію рівності, ви зазвичай робите <code>(==) `on`</code> <code>something</code>, та коли ви маєте справу з функціями <code>By</code>, що приймають функцію впорядкування, ви зазвичай робите <code>compare `on`</code> <code>something</code>.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/legochar.png" alt="images/legochar.png" />
</span>
Модуль <code>Data.Char</code> робить те, на що натякає його ім'я. Він експортує функції, що мають справи з символами. Це також корисне при фільтруванні та відображенні з рядками, бо вони є лише списками символів.</p></div>
<div class="paragraph"><p><code>Data.Char</code> експортує декілька предикатів над символами. Тобто функцій, що приймають символ, та кажуть, чи справджується деяке припущення щодо нього. Ось як це виглядає:</p></div>
<div class="paragraph"><p><code>isControl</code> перевіряє, чи символ є символом керування.</p></div>
<div class="paragraph"><p><code>isSpace</code> перевіряє, чи символ є проміжком. Це включає проміжки, табуляції, нові рядки, тощо.</p></div>
<div class="paragraph"><p><code>isLower</code> перевіряє, чи символ в нижньому реєстрі.</p></div>
<div class="paragraph"><p><code>isUpper</code> перевіряє, чи символ в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAlpha</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isAlphaNum</code> перевіряє, чи символ є літерою або цифрою.</p></div>
<div class="paragraph"><p><code>isPrint</code> перевіряє, чи символ є друкованим. Наприклад, керівні символи не друкуються.</p></div>
<div class="paragraph"><p><code>isDigit</code> перевіряє, чи символ є цифрою.</p></div>
<div class="paragraph"><p><code>isOctDigit</code> перевіряє, чи символ є восьмиричним символом.</p></div>
<div class="paragraph"><p><code>isHexDigit</code> перевіряє, чи символ є шістнацятиричною цифрою.</p></div>
<div class="paragraph"><p><code>isLetter</code> перевіряє, чи символ є літерою.</p></div>
<div class="paragraph"><p><code>isMark</code> перевіряє щодо символів маркування Unicode. Це символи, що комбінуються з попередніми символами для формування літер з наголосами та умулятами. Використовуйте це, якщо ви француз.</p></div>
<div class="paragraph"><p><code>isNumber</code> перевіряє, чи символ є числом.</p></div>
<div class="paragraph"><p><code>isPunctuation</code> перевіряє, чи символ є пунктуацією.</p></div>
<div class="paragraph"><p><code>isSymbol</code> перевіряє, чи символ є незвичайним математичним або символом валют.</p></div>
<div class="paragraph"><p><code>isSeparator</code> перевіряє на проміжки та роздільники Unicode.</p></div>
<div class="paragraph"><p><code>isAscii</code> перевіряє, чи символ підпадає в перші 128 символів набору символів Unicode.</p></div>
<div class="paragraph"><p><code>isLatin1</code> перевіряє, чи символ підпадає в перші 256 символів Unicode.</p></div>
<div class="paragraph"><p><code>isAsciiUpper</code> перевіряє, чи символ ASCII в верхньому реєстрі.</p></div>
<div class="paragraph"><p><code>isAsciiLower</code> перевіряє, чи символ ASCII в нижньому реєстрі.</p></div>
<div class="paragraph"><p>Всі ці предикати мають сигнатуру типу <code>Char -&gt; Bool</code>. Більшість часу ви будете використовувати їх для фільтрування рядків або чогось подібного. Наприклад, скажімо, ми робимо програму, що приймає ім'я користувачи, та це ім'я може складатись тільки з літер та цифр. Ми можемо використовувати функцію <code>Data.List</code> <code>all</code> в комбінації з предикатами <code>Data.Char</code> для визначення, чи ім'я користувача в порядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;bobby283&quot;</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">all</span> <span class="n">isAlphaNum</span> <span class="s">&quot;eddy the fish!&quot;</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Круто. В випадку якщо ви не пам'ятаєте, <code>all</code> приймає предикат та список, та повертає <code>True</code> тільки якщо предикат дотримується для всіх елементів в списку.</p></div>
<div class="paragraph"><p>Ми також можемо використовувати <code>isSpace</code> для симуляції функції <code>Data.List</code> <code>words</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">words</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Хмм, гарно, це робить майже те саме що робить <code>words</code>, але ми залишились з елементами, що містять тільки проміжки. Хмм, то що ми маємо робити? Я знаю, просто відфільтруемо цей непотріб.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">filter</span> <span class="p">(</span><span class="n">not</span> <span class="o">.</span> <span class="n">any</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">.</span> <span class="n">groupBy</span> <span class="p">((</span><span class="o">==</span><span class="p">)</span> <span class="p">`</span><span class="n">on</span><span class="p">`</span> <span class="n">isSpace</span><span class="p">)</span> <span class="o">$</span> <span class="s">&quot;hey guys its me&quot;</span>
<span class="p">[</span><span class="s">&quot;hey&quot;</span><span class="p">,</span><span class="s">&quot;guys&quot;</span><span class="p">,</span><span class="s">&quot;its&quot;</span><span class="p">,</span><span class="s">&quot;me&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось так.</p></div>
<div class="paragraph"><p><code>Data.Char</code> також імпортує тип даних що подібний до <code>Ordering</code>. Тип <code>Ordering</code> може мати значення <code>LT</code>, <code>EQ</code> або <code>GT</code>. Це різновид переліку. Він описує декілька можливих результатів, що можуть виникнути від порівняння двох елементів. Тип <code>GeneralCategory</code> також є переліком. Він презентує декілька можливих категорій, до яких може належати символ. Головна функція для отримання загальної категорії символа є <code>generalCategory</code>. Вона має тип <code>generalCategory ::Char -&gt; GeneralCategory</code>. Існує близько <code>31</code> категорій, так що ми не будемо перелічувати їх тут, але пограємось з функцією.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39; &#39;</span>
<span class="kt">Space</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;A&#39;</span>
<span class="kt">UppercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;a&#39;</span>
<span class="kt">LowercaseLetter</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;.&#39;</span>
<span class="kt">OtherPunctuation</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">generalCategory</span> <span class="sc">&#39;9&#39;</span>
<span class="kt">DecimalNumber</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">generalCategory</span> <span class="s">&quot; </span><span class="se">\t\n</span><span class="s">A9?|&quot;</span>
<span class="p">[</span><span class="kt">Space</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">Control</span><span class="p">,</span><span class="kt">UppercaseLetter</span><span class="p">,</span><span class="kt">DecimalNumber</span><span class="p">,</span><span class="kt">OtherPunctuation</span><span class="p">,</span><span class="kt">MathSymbol</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки тип <code>GeneralCategory</code> є частиною типокласу <code>Eq</code>, ми можемо також перевірити дещо, наприклад <code>generalCategory c == Space</code>.</p></div>
<div class="paragraph"><p><code>toUpper</code> конвертує символ в верхній реєстр. Проміжки, числа та все подібне залишається без змін.</p></div>
<div class="paragraph"><p><code>toLower</code> конвертує символи в нижній реєстр.</p></div>
<div class="paragraph"><p><code>toTitle</code> конвертує символ в заглавні. Для більшості символів це те саме, що верхній реєстр.</p></div>
<div class="paragraph"><p><code>digitToInt</code> конвертує символ до <code>Int</code>. Щоб це було успішним символ має бути в диапазоні <code>'0'..'9'</code>, <code>'a'..'f'</code> або <code>'A'..'F'</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;34538&quot;</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">digitToInt</span> <span class="s">&quot;FF85AB&quot;</span>
<span class="p">[</span><span class="mi">15</span><span class="p">,</span><span class="mi">15</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>intToDigit</code> є інверсною функцією до <code>digitToInt</code>. Вона приймає <code>Int</code> в диапазоні <code>0..15</code> та конвертує його в символ нижнього реєстра.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">15</span>
<span class="sc">&#39;f&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">intToDigit</span> <span class="mi">5</span>
<span class="sc">&#39;5&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції <code>ord</code> та <code>chr</code> конвертують символи до відповідних чисел та навпаки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">ord</span> <span class="sc">&#39;a&#39;</span>
<span class="mi">97</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">chr</span> <span class="mi">97</span>
<span class="sc">&#39;a&#39;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="n">ord</span> <span class="s">&quot;abcdefgh&quot;</span>
<span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Різниця між <code>ord</code> значеннями двох символів дорівнює тому, як далеко вони в таблиці Unicode.</p></div>
<div class="paragraph"><p>Шифр Цезаря є примітивним методом кодування повідомлень, зсуваючи кожний символ в повідомленні на фіксований число позицій в абетці. Ми можемо просто створити різновид шифра Цезаря, тільки ми не будемо обмежувати себе абеткою.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">encode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">encode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span>
    <span class="kr">let</span> <span class="n">ords</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">ord</span> <span class="n">msg</span>
        <span class="n">shifted</span> <span class="ow">=</span> <span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="n">ords</span>
    <span class="kr">in</span>  <span class="n">map</span> <span class="n">chr</span> <span class="n">shifted</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми зпочатку конвертуємо рядок в список чисел. Потім ми додаємо сзув до кожного значення перед конвертації списку назад до символів. Якщо ви ковбой композиції, ви можете записати тіло цієї функції як <code>map (chr . (+ shift) . ord) msg</code>. Давайте спробуємо закодувати декілька повідомлень.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Khhhhh|&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">4</span> <span class="s">&quot;Heeeeey&quot;</span>
<span class="s">&quot;Liiiii}&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">1</span> <span class="s">&quot;abcd&quot;</span>
<span class="s">&quot;bcde&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">5</span> <span class="s">&quot;Marry Christmas! Ho ho ho!&quot;</span>
<span class="s">&quot;Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Все закодовується гарно. Декодування повідомлення є в основному зсув назад на число позицій, на яке воно було спочатку зсунуте.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">decode</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">decode</span> <span class="n">shift</span> <span class="n">msg</span> <span class="ow">=</span> <span class="n">encode</span> <span class="p">(</span><span class="n">negate</span> <span class="n">shift</span><span class="p">)</span> <span class="n">msg</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">encode</span> <span class="mi">3</span> <span class="s">&quot;Im a little teapot&quot;</span>
<span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">3</span> <span class="s">&quot;Lp#d#olwwoh#whdsrw&quot;</span>
<span class="s">&quot;Im a little teapot&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">decode</span> <span class="mi">5</span> <span class="o">.</span> <span class="n">encode</span> <span class="mi">5</span> <span class="o">$</span> <span class="s">&quot;This is a sentence&quot;</span>
<span class="s">&quot;This is a sentence&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Асоціативні списки (також називаються словниками) є списками, що використовуються для зберігання пар ключ-значення, коли порядок не має значення. Наприклад, ми можемо використовувати асоціативний список для зберігання номерів телефонів, де номери телефонів будуть значеннями, а імена людей будуть ключами. Нам байдуже в якому порядку вони зберігаються, ми просто хочемо отримати правильний номер телефону для певної особи.</p></div>
<div class="paragraph"><p>Найбільш очевидний шлях представити асоціативні списки в Haskell буде використання списку пар. Перший компонент в парі буде ключем, другий компонент значення. Ось приклад асоціативного списку з номерами телефонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Не зважаючи на ці досить дивні відступи це все ще пари рядків. Найбільш загальна задача коли маємо справу з асоціативними списками є пошук значення по ключу. Давайте створимо функцію, що шукає деяке значення по ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="n">xs</span> <span class="ow">=</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">head</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span> <span class="o">$</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить просто. Функція, що бере ключ та список, фільтрує список так, що залишаються лише співпадаючі ключі, бере першу пару ключ-значення та повертає значення. Але що трапляється, якщо ключ що ми шукаємо відсутній в асоціативному списку? Хмм. В даному випадку якщо ключа немає в списку ми скінчимо беручи <code>head</code> від порожнього списку, що закидає помилку часу виконання. Однак нам слідує уникати таких простих катастроф нашої програми, так що використаємо тип даних <code>Maybe</code>. Якщо ми не знайшли ключ ми повертаємо <code>Nothing</code>. Якщо ми знайшли його, ми повертаємо <code>Just</code> дещо, де дещо це значення, що відповідає ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">Nothing</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span>
                            <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span>
                            <span class="kr">else</span> <span class="n">findKey</span> <span class="n">key</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Подивіться на декларацію типу. Вона приймає ключ, що може бути порівняний, асоціативний список, і потім, вірогідно, продукує значення. Виглядає правильним.</p></div>
<div class="paragraph"><p>Це класична рекурсивна функція, що оперує зі списком. Граничний випадок, поділення списку на голову та хвіст, рекурсивні виклики - вони всі тут. Це класичний шаблон <code>fold</code>, так що давайте подивимось, як це може бути реалізовано через згортання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">findKey</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Eq</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">k</span> <span class="ow">-&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">v</span>
<span class="nf">findKey</span> <span class="n">key</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kr">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">k</span> <span class="kr">then</span> <span class="kt">Just</span> <span class="n">v</span> <span class="kr">else</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p>Note: Зазвичай краще використовувати згортки для цього стандартного шаблону рекурсії по списку, замість явного написання рекурсії, бо це краще читати та розпізнавати. Всі знають що це згортання, коли вони бачать виклик <code>foldr</code>, але читання явної рекурсії займає деякий час.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;penny&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;853-2492&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;betty&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Just</span> <span class="s">&quot;555-2938&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">findKey</span> <span class="s">&quot;wilma&quot;</span> <span class="n">phoneBook</span>
<span class="kt">Nothing</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/legomap.png" alt="images/legomap.png" />
</span>
Робить чудово! Якщо ми маємо номер телефону дівчини, ми <code>Just</code> отримуємо номер, інакше ми отримуємо <code>Nothing</code>.</p></div>
<div class="paragraph"><p>Ми тільки що реалізували функцію пошуку з <code>Data.List</code>. Якщо ми бажаємо знайти відповідне до ключа значення, ми маємо пройти всі елементи списка, доки ми не знайдемо його. Модуль <code>Data.Map</code> пропонує асоціативні списки, що значно швидші (оскільки вони внутрішньо реалізовані як дерева), і також вона провадить багато допоміжних функцій. Відтепер ми будемо казати, що ми робимо з мапами замість асоціативних списків.</p></div>
<div class="paragraph"><p>Оскільки <code>Data.Map</code> експортує функції, що перетинаються з такими з <code>Prelude</code> та <code>Data.List</code>, ми будемо робити кваліфікований імпорт.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Map</span> <span class="k">as</span> <span class="n">Map</span>
</pre></div></div></div>
<div class="paragraph"><p>Покладемо це твердження в скрипт, та потім завантажимо скрипт через  <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Давайте пійдемо далі, та побачимо, що має для нас <code>Data.Map</code>! Ось базовий огляд його функцій.</p></div>
<div class="paragraph"><p>Функція <code>fromList</code> бере асоціативний список (в формі списка) і повертає мапу з тими самими асоціаціями.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">),(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">),(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо в оригінальному асоціативному списку є дублікати ключів, дублікати просто відкидаються. Ось сигнатура типу для <code>fromList</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона каже, що береться список пар типів <code>k</code> та <code>v</code>, та повертається мапа, що відображує тип <code>k</code> на тип <code>v</code>. Зауважте, що коли ми робимо асоціативні списки з нормальними списками, ключі тільки мають проходити порівняння на рівність (їх тип належить до типокласу <code>Eq</code>), але тепер вони мають впорядковуватись. Це основний контраст в модулі <code>Data.Map</code>. Він вимагає щоб ключі впорядковувались, і тоді він зможе вистроїти їх в дерево.</p></div>
<div class="paragraph"><p>Вам слідує завжди використовувати <code>Data.Map</code> для асоціацій ключ-значення, тільки якщо ви не маєте ключів, що не є частиною типокласу <code>Ord</code>.</p></div>
<div class="paragraph"><p><code>empty</code> представляє порожню мапу. Вона не приймає аргументів, вона просто повертає порожню мапу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insert</code> бере ключ, значення та мапу, і повертає нову мапу, що така сама, тільки з доданим ключем та значенням.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="kt">[]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="p">(</span><span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="p">(</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span>  <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span><span class="p">))</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">600</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="mi">200</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">200</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">600</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо реалізувати наш власний <code>fromList</code> через використання порожньої мапи, <code>insert</code> та <code>fold</code>. Дивіться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">fromList&#39;</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="n">v</span>
<span class="nf">fromList&#39;</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="n">acc</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">v</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
</pre></div></div></div>
<div class="paragraph"><p>Це досить прямолінійне згортання. Ми починаємо з порожньої мапи, і ми згортаємо її зправа, включаючи пари ключ значення в акумулятор по мірі проходження.</p></div>
<div class="paragraph"><p><code>null</code> перевіряє, чи мапа є порожня.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>size</code> повідомляє про розмір мапи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="kt">Map</span><span class="o">.</span><span class="n">empty</span>
<span class="mi">0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="mi">5</span>
</pre></div></div></div>
<div class="paragraph"><p><code>singleton</code> бере ключ та значення, та створює мапу, що має одне відображення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">5</span> <span class="mi">9</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">3</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>lookup</code> робить як <code>Data.List</code> <code>lookup</code>, тільки він оперує з мапами. Він повертає <code>Just</code> дещо, якщо він знаходить дещо для ключі, і <code>Nothing</code> якщо ні.</p></div>
<div class="paragraph"><p><code>member</code> є предикатом, що приймає ключ і мапу, та повідомляє, чи ключ в мапі або ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">member</span> <span class="mi">3</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p><code>map</code> та <code>filter</code> роблять як їх еквіваленти для списків.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">400</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">900</span><span class="p">)]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">filter</span> <span class="n">isUpper</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="sc">&#39;a&#39;</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="sc">&#39;b&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="sc">&#39;A&#39;</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="sc">&#39;B&#39;</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>toList</code> є зворотнім до <code>fromList</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">toList</span> <span class="o">.</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insert</span> <span class="mi">9</span> <span class="mi">2</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">4</span> <span class="mi">3</span>
<span class="p">[(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">9</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>keys</code> та <code>elems</code> повертають списки ключів та значень відповідно. <code>keys</code> є еквівалентом до <code>map fst . Map.toList</code> та <code>elems</code> є еквівалентом до <code>map snd . Map.toList</code>.</p></div>
<div class="paragraph"><p><code>fromListWith</code> є милою маленькою функцією. Вона діє як <code>fromList</code>, тільки вона не відкидає дублікати ключів, але використовує надану функцію для вирішення, що з ними робити. Скажімо, дівчина має декілька номерів, і ми маємо асоціативний список приблизно такого вигляду.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBook</span> <span class="ow">=</span>
    <span class="p">[(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;555-2938&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;betty&quot;</span><span class="p">,</span><span class="s">&quot;342-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;bonnie&quot;</span><span class="p">,</span><span class="s">&quot;452-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;patsy&quot;</span><span class="p">,</span><span class="s">&quot;827-9162&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;lucille&quot;</span><span class="p">,</span><span class="s">&quot;205-2928&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;wendy&quot;</span><span class="p">,</span><span class="s">&quot;939-8282&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;853-2492&quot;</span><span class="p">)</span>
    <span class="p">,(</span><span class="s">&quot;penny&quot;</span><span class="p">,</span><span class="s">&quot;555-2111&quot;</span><span class="p">)</span>
    <span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, якщо ми просто використовуємо <code>fromList</code> щоб перенести це в мапу, ми втратимо декілька номерів! Так що ось як ми будемо робити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="kt">String</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="kt">String</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="nf">\</span><span class="n">number1</span> <span class="n">number2</span> <span class="ow">-&gt;</span> <span class="n">number1</span> <span class="o">++</span> <span class="s">&quot;, &quot;</span> <span class="o">++</span> <span class="n">number2</span><span class="p">)</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;827-9162, 943-2929, 493-2928&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;wendy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;939-8282&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;betty&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="s">&quot;342-2492, 555-2938&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми знайдемо дублікований ключ, функція, яку ми передали, буде використана для комбінації ціх значень для ключа в деяке інше значення. Ми можемо також спочатку створити для всіх значень в асоціативному списку списки синглтони, і потім ми можемо використати <code>++</code> для комбінації чисел.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">phoneBookToMap</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Ord</span> <span class="n">k</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">)]</span> <span class="ow">-&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="kt">Map</span> <span class="n">k</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="nf">phoneBookToMap</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">++</span><span class="p">)</span> <span class="o">$</span> <span class="n">map</span> <span class="p">(</span><span class="nf">\</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">k</span><span class="p">,[</span><span class="n">v</span><span class="p">]))</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">lookup</span> <span class="s">&quot;patsy&quot;</span> <span class="o">$</span> <span class="n">phoneBookToMap</span> <span class="n">phoneBook</span>
<span class="p">[</span><span class="s">&quot;827-9162&quot;</span><span class="p">,</span><span class="s">&quot;943-2929&quot;</span><span class="p">,</span><span class="s">&quot;493-2928&quot;</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Дуже добре! Інший випадок це коли ми робимо мапу з асоціативного списку чисел, і коли трапляється дублікований ключ, ми бажаємо зберігти більше значення для ключа.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="n">max</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ми можемо скласти разом значення по тому самому ключу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromListWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),(</span><span class="mi">2</span><span class="p">,</span><span class="mi">100</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">29</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">11</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">22</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">15</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">2</span><span class="p">,</span><span class="mi">108</span><span class="p">),(</span><span class="mi">3</span><span class="p">,</span><span class="mi">62</span><span class="p">),(</span><span class="mi">4</span><span class="p">,</span><span class="mi">37</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>insertWith</code> те саме до <code>insert</code>, що <code>fromListWith</code> до <code>fromList</code>. Вона вставляє пару ключ-значення в мапу, але якщо мапа вже містить ключ, вона використовує передану функцію для визначення того, що треба робити.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Map</span><span class="o">.</span><span class="n">insertWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="mi">3</span> <span class="mi">100</span> <span class="o">$</span> <span class="kt">Map</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
<span class="nf">fromList</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span><span class="mi">104</span><span class="p">),(</span><span class="mi">5</span><span class="p">,</span><span class="mi">103</span><span class="p">),(</span><span class="mi">6</span><span class="p">,</span><span class="mi">339</span><span class="p">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це було лише декілька функцій з <code>Data.Map</code>. Повний список функцій ви можете побачити в документації.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/legosets.png" alt="images/legosets.png" />
</span>
Модуль <code>Data.Set</code> пропонує нам множини. Це як множини в математиці. Множини як скрещені списки з мапами. Всі елементи в множині унікальні. І оскільки вони внутрішньо реалізовані за допомогою дерев (як мапи в <code>Data.Map</code>), вони впорядковані. Перевірка на членство, вставка, видалення, тощо значно швидші, ніж робити ті самі речі зі списками. Найбільш загальні операції при роботі з множинами є вставка в множину, перевірка членства та перетворення множини на список.</p></div>
<div class="paragraph"><p>Оскільки імена в <code>Data.Set</code> перетинаються значною мірою з іменами в  <code>Prelude</code> та <code>Data.List</code>, ми робимо кваліфікований імпорт.</p></div>
<div class="paragraph"><p>Покладіть твердження <code>import</code> в скрипт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Set</span> <span class="k">as</span> <span class="n">Set</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім завантажте скрипт через <code>GHCI</code>.</p></div>
<div class="paragraph"><p>Скажімо ми маємо два шматки тексту. Ми бажаємо з'ясувати, які символи використовуються в кожному з них.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">text1</span> <span class="ow">=</span> <span class="s">&quot;I just had an anime dream. Anime... Reality... Are they so different?&quot;</span>
<span class="nf">text2</span> <span class="ow">=</span> <span class="s">&quot;The old man left his garbage can out and now his trash is all over my lawn!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція <code>fromList</code> робить майже як ви могли очікувати. Вона бере список та конвертуж його в множину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set1</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">set2</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">text2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot; .?AIRadefhijlmnorstuy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !Tabcdefghilmnorstuvwy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, елементи впорядковані і кожний елемент унікальний. Тепер давайте використаємо функцію <code>intersection</code> щоб побачити, які елементи поділяють обоє.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">intersection</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; adefhilmnorstuy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо використовувати функцію <code>difference</code> щоб побачити, які літери в першій множині, але не в другій, і навпаки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot;.?AIRj&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">difference</span> <span class="n">set2</span> <span class="n">set1</span>
<span class="nf">fromList</span> <span class="s">&quot;!Tbcgvw&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ми можемо бачити всі унікальні літери в обох послідовностях з використанням <code>union</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">union</span> <span class="n">set1</span> <span class="n">set2</span>
<span class="nf">fromList</span> <span class="s">&quot; !.?AIRTabcdefghijlmnorstuvwy&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Функції <code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code> та <code>delete</code> всі роблять як ви могли цього очікувати.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="kt">Set</span><span class="o">.</span><span class="n">empty</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">null</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">size</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="mi">3</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">singleton</span> <span class="mi">9</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">insert</span> <span class="mi">8</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="o">..</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">delete</span> <span class="mi">4</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми також можемо перевірити підмножини. Множина <code>A</code> є підмножиною <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code>. Множина <code>A</code> є власне підмножиною множини <code>B</code>, якщо <code>B</code> містить всі елементи, що і <code>A</code> ,але також і інші елементи.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">True</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isProperSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span> <span class="p">`</span><span class="kt">Set</span><span class="o">.</span><span class="n">isSubsetOf</span><span class="p">`</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
<span class="kt">False</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми також можемо відображати множини і фільтрувати їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">filter</span> <span class="n">odd</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Set</span><span class="o">.</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="nf">fromList</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Множини часто використовуються для позбавлення списків від дублікатів, спершу перетворивши їх на множину за допомогою <code>fromList</code>, та потім перетворивши її на список за допомогою <code>toList</code>. Функція <code>Data.List</code> <code>nub</code> вже робить це, але зачистка дублікатів для великих списків значно швидша, якщо ви перекачаєте його в множину, ніж якщо використаєте <code>nub</code>. Але викорастання <code>nub</code> вимагає тільки щоб тип елементів списку був частиною типокласу <code>Eq</code>, натомість якщо ви бажаєте перевести елементи в множину, тип списку має бути в <code>Ord</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">setNub</span> <span class="n">xs</span> <span class="ow">=</span> <span class="kt">Set</span><span class="o">.</span><span class="n">toList</span> <span class="o">$</span> <span class="kt">Set</span><span class="o">.</span><span class="n">fromList</span> <span class="n">xs</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">setNub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot; ACEHIKLNRSTWY&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nub</span> <span class="s">&quot;HEY WHATS CRACKALACKIN&quot;</span>
<span class="s">&quot;HEY WATSCRKLIN&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>setNub</code> загалом швидша, ніж <code>nub</code> на великих списках, але як ви бачите, <code>nub</code> зберігає впорядкування елемнтів списку, тоді як <code>setNub</code> ні.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/making_modules.png" alt="images/making_modules.png" />
</span>
Ми вже подивились на деякі круті модулі, то як нам зробити наш власний модуль? Майже кожна мова програмування дозволяє вам поділити ваш код не декілька файлів, і Haskell не є виключенням. При створенні програм є гарною практикою брати функції і типи, що служать деяким подібним цілям, і покладати їх в модуль. Таким чином ви легко можете використати ці функції в інших програмах, просто імпортувавши ваш модуль.</p></div>
<div class="paragraph"><p>Давайте подивимось, як ви можете створити ваші власні модулі, створивши невеликий модуль, що провадить деякі функції для обчислення об'єму та площі декількох геометричних об'єктів. Ми почнемо зі створення файла з назвою <code>Geometry.hs</code>.</p></div>
<div class="paragraph"><p>Ми кажемо, що модуль експортує функції. Це означає те, що коли я імпортує модуль, я можу використовувати функції, які він експортує. Він може визначати функції, що його функції використовують внутрішньо, але ми можемо бачити та використовувати лише ті, що експортуються.</p></div>
<div class="paragraph"><p>На початку модуля ми вказуємо ім'я модуля. Якщо ми маємо файл з назвою <code>Geometry.hs</code>, тоді ми маємо назвати наш модуль <code>Geometry</code>. Потім ми вказуємо функції, які він експортує, і після цього ми починаємо писати функції. Так що ми почнемо з цього.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ми бачимо, ми робимо площі та об'єми для сфер, кубів та кубоїдів. Ідемо далі і визначаємо функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry</span>
<span class="p">(</span> <span class="nf">sphereVolume</span>
<span class="p">,</span> <span class="nf">sphereArea</span>
<span class="p">,</span> <span class="nf">cubeVolume</span>
<span class="p">,</span> <span class="nf">cubeArea</span>
<span class="p">,</span> <span class="nf">cuboidArea</span>
<span class="p">,</span> <span class="nf">cuboidVolume</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">sphereVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereVolume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">sphereArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">sphereArea</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>

<span class="nf">cubeVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeVolume</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidVolume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cubeArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cubeArea</span> <span class="n">side</span> <span class="ow">=</span> <span class="n">cuboidArea</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">cuboidVolume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidVolume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">cuboidArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">cuboidArea</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут досить стандартна геометрія. Деякі речі мають прийти на думку. Оскільки куб лише особливий випадок кубоїду, ми визначили його площу та об'єм через трактування його як кубоїда, в якого всі сторони рівної довжини. Ми також визначили допоміжну функцію з назвою <code>rectangleArea</code>, що обчислює площу прямокутника на основі довжини сторін. Вона скоріше тривіальна, бо це лише множення. Зауважте, що ми використали її в наших функціях в модулі (а саме <code>cuboidArea</code> та <code>cuboidVolume</code>), але ми не експортували її! Оскільки ми лише бажаємо, щоб наш модуль представляв лише функції, що мають справу з тривимірними об'єктами, ми використали <code>rectangleArea</code>, але ми не експортували її.</p></div>
<div class="paragraph"><p>При створенні модуля ми зазвичай експортуємо тільки ті функції, що діють як різновид інтерфейсу до нашого модуля, так що сама релалізація прохована. Якщо дехто використовує наш модуль <code>Geometry</code>, вони не мають обтяжувати себе функціями, які ми не експортуємо. Ми можемо вирішити змінити ці функції повністю, або видалити їх в новій версії (ми можемо видалити <code>rectangleArea</code> та замість поставити лише <code>*</code>), і ніхто не перейматиметься, бо ми для початку не експортували їх.</p></div>
<div class="paragraph"><p>Щоб використати наш модуль ми просто робимо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Geometry.hs</code> повинен бути в тій же папці, що і програма, до якої ми його імпортуємо.</p></div>
<div class="paragraph"><p>Модулі також можуть бути взяті як ієрархічні структури. Кожний модуль може мати декілька субмодулів, і ті також можуть мати власні субмодулі. Давайте поділимо ці функції, так що <code>Geometry</code> буде модулем, що має три субмодулі, по одному для кожного типу об'єктів.</p></div>
<div class="paragraph"><p>Спочатку створимо папку з назвою <code>Geometry</code>. Подумайте про велику  <code>G</code>. В цій папці розташуємо три файли: <code>Sphere.hs</code>, <code>Cuboid.hs</code>, та <code>Cube.hs</code>. Ось що будуть містити файли:</p></div>
<div class="paragraph"><p><code>Sphere.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Sphere</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">radius</span> <span class="ow">=</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">3</span><span class="p">)</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">radius</span> <span class="ow">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">radius</span> <span class="o">^</span> <span class="mi">2</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Cuboid.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cuboid</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">a</span> <span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">rectangleArea</span> <span class="n">c</span> <span class="n">b</span> <span class="o">*</span> <span class="mi">2</span>

<span class="nf">rectangleArea</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">rectangleArea</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Cube.hs</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Geometry.Cube</span>
<span class="p">(</span> <span class="nf">volume</span>
<span class="p">,</span> <span class="nf">area</span>
<span class="p">)</span> <span class="kr">where</span>

<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>

<span class="nf">volume</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">volume</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">volume</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>

<span class="nf">area</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">area</span> <span class="n">side</span> <span class="ow">=</span> <span class="kt">Cuboid</span><span class="o">.</span><span class="n">area</span> <span class="n">side</span> <span class="n">side</span> <span class="n">side</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд! Перше <code>Geometry.Sphere</code>. Зауважте, як ми поклали його в папку з назвою <code>Geometry</code>, та потім визначили модуль на ім'я <code>Geometry.Sphere</code>. Ми зробили те саме для кубоїда. Також зауважте, як в усіх трьох субмодулях ми визначили функції з тими самими назвами. Ми можемо зробити це, оскільки вони в окремих модулях. Ми бажаємо використати функції з <code>Geometry.Cuboid</code> в <code>Geometry.Cube</code>, але ми не можемо напряму зробити імпорт <code>Geometry.Cuboid</code>, оскільки він експортує функції з тими самими іменами, що і <code>Geometry.Cube</code>. Ось чому ми зробили кваліфікований імпорт, і все гаразд.</p></div>
<div class="paragraph"><p>Так що коли ми в файлі на тому самому рівні, що і папка <code>Geometry</code>, ми можемо зробити, скажімо, таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">Geometry.Sphere</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>area</code> та <code>volume</code>, і вони даватимуть нам площу та об'єм сфери. Але якщо ми бажаємо жанглювати двома або більше з ціх модулів, ми маємо робити кваліфікований імпорт, оскільки вони експортують функції з тіма самими іменами. Так що ми робимо дещо таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Sphere</span> <span class="k">as</span> <span class="n">Sphere</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cuboid</span> <span class="k">as</span> <span class="n">Cuboid</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Geometry.Cube</span> <span class="k">as</span> <span class="n">Cube</span>
</pre></div></div></div>
<div class="paragraph"><p>І потім ми можемо викликати <code>Sphere.area</code>, <code>Sphere.volume</code>, <code>Cuboid.area</code>, тощо, і кожний буде обчислювати площу та об'єм для свого відповідного об'єкту.</p></div>
<div class="paragraph"><p>Наступного разу, коли ви будете писати файл, що дійсно великий, та має безліч функцій, спробуйте визначити, які функції служать якімось загальним цілям, і потім розгляньте, як покласти ці функції у свій власний модуль. Ви будете в змозі просто імпортувати ваш власний модуль наступного разу, коли ви писатимите програму, що потребує тої самої функціональності.
:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font</p></div>
<div class="paragraph"><p>В попередніх главах ми розглядали деякі існуючі типи та типокласи Haskell. В цій главі ми навчимось як створювати свої власні, та як змусити їх робити!</p></div>
<div class="paragraph"><p>Досі ми зустрічали багато типів даних. <code>Bool</code>, <code>Int</code>, <code>Char</code>, <code>Maybe</code>,тощо. Але як ми створюємо свої власні? Гаразд, один спосіб є використання ключового слова <code>data</code> для визначення типу. Давайте подивимось, як визначений тип <code>Bool</code> в стандартній бібліотеці.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Bool</span> <span class="ow">=</span> <span class="kt">False</span> <span class="o">|</span> <span class="kt">True</span>
</pre></div></div></div>
<div class="paragraph"><p><code>data</code> означає, що ми визначаємо новий тип даних. Частина перед <code>=</code> означає тип, що є <code>Bool</code>. Частини після <code>=</code> є конструкторами значень. Вони вказують різні значення, що може мати тип. <code>|</code> читається як <em>або</em>. Так що ми можемо читати це так: тип <code>Bool</code> може мати тип значення <code>True</code> або <code>False</code>. Обоє, им'я типу та конструктори значення, мають бути з великої літери.</p></div>
<div class="paragraph"><p>В подібному стилі ми можемо думати про тип <code>Int</code>, як визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Int</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">2147483648</span> <span class="o">|</span> <span class="o">-</span><span class="mi">2147483647</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="o">-</span><span class="mi">1</span> <span class="o">|</span> <span class="mi">0</span> <span class="o">|</span> <span class="mi">1</span> <span class="o">|</span> <span class="mi">2</span> <span class="o">|</span> <span class="o">...</span> <span class="o">|</span> <span class="mi">2147483647</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/caveman.png" alt="images/caveman.png" />
</span>
Перший та останній конструктори значень є мінімальне та максимальне можливі значення для <code>Int</code>. Насправді це не визначено таким чином, три крапки, що стоять тут, через те, що ми пропустили безліч чисел, так що все це тільки для цілей ілюстрації.</p></div>
<div class="paragraph"><p>Тепер давайте подумаємо про те, як ми можемо представити фігуру в Haskell. Один спосіб може бути використання таплів. Коло може бути позначено як <code>(43.1, 55.0, 10.4)</code>, де перші два поля є координати центру, а третє поле є радіус. Звучить OK, але це може представляти 3D вектор або будь-що ще. Краще рішення може бути зробити ваш власний тип для представлення фігури. Скажімо, фігури, що може бути колом або прямокутником. Ось вона:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span>
<span class="p">[</span><span class="n">source</span><span class="p">,</span><span class="n">haskell</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Що це тепер? Думайте про це так. Конструктор значення <code>Circle</code> має три поля, що приймають числа з плаваючою крапкою. Так що коли ми пишемо конструктор значення, ми можемо опціонально додати деякі типи після нього, і ці типи визначають значення, що він міститиме. Тут перші два поля є координатами його центру, третя є радіусом. Конструктор значення <code>Rectangle</code> має чотири поля, що приймають плаваючу крапку. Перші два є координатами його верхнього лівого кута, та другі два є координати його нижнього правого кута.</p></div>
<div class="paragraph"><p>Тепер, коли я кажу поля, я насправді маю на увазі параметри. Конструктори значень насправді є функціями, що кінець кінцем повертають значення типу даних. Давайте поглянемо на сигнатури типів для ціх двох конструкторів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Circle</span>
<span class="kt">Circle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Rectangle</span>
<span class="kt">Rectangle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
</pre></div></div></div>
<div class="paragraph"><p>Круть, так що конструктори значень є функціями як всі інші. Хто б міг подумати? Давайте створимо функцію, що приймає фігуру та повертає її поверхню.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перша помітна річ тут є декларація типу. Вона каже, що функція приймає фігуру та повертає число. Ми не можемо написати декларацію типу <code>Circle -&gt; Float</code>, оскільки <code>Circle</code> не є типом, але <code>Shape</code> так. Це так само, як ми не можемо написати функцію з декларацією типу <code>True -&gt; Int</code>. Наступна річ, яку ми відмітимо тут, є те, що ми можемо робити порівняння шаблонів до конструкторів. Ми порівнювали шаблони проти конструкторів до цього (насправді весь час), коли ми порівнювали шаблони проти значень як <code>[]</code> або <code>False</code> або <code>5</code>, тількі ці значення не мали жодних полів. Ми тільки що написали конструктор, та потім прикріпили його поля до імен. Оскільки ми зацікавлені в радіусі, ми насправді не зацікавлені в перших двох полях, що кажуть нам, де знаходиться коло.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">10</span>
<span class="mf">314.15927</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">100</span> <span class="mi">100</span>
<span class="mf">10000.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Вау, це робить! Але якщо ви спробуєте просто надрукувати <code>Circle 10 20 5</code> в підказці, ми отримаємо помилку. Це тому, що Haskell не знає, як відображувати наші типи даних як рядок (доки). Згадайте, коли ми намагаємось друкувати значення в підказці, Haskell спочатку виконує функцію <code>show</code> для отримання рядкової репрезентації нашого значення, та потім він друкує це на термінал. Щоб зробити наш тип <code>Shape</code> частиною типокласа <code>Show</code>, ми модифікуємо його таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми доки не будемо заморочувати себе <code>deriving</code> дуже сильно. Давайте просто скажемо, що якщо ми додаємо <code>deriving (Show)</code> в кінці декларації даних, Haskell автомагічно робить цей тип частиною типокласу <code>Show</code>. Так що зараз ми можемо робити таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span> <span class="mi">5</span>
<span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Rectangle</span> <span class="mi">50</span> <span class="mi">230</span> <span class="mi">60</span> <span class="mi">90</span>
<span class="kt">Rectangle</span> <span class="mf">50.0</span> <span class="mf">230.0</span> <span class="mf">60.0</span> <span class="mf">90.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Конструктори значень є функціями, так що ми можемо відображати їх та частково застосовувати їх, і все інше. Якщо ми бажаємо список концентричних з різними радіусами, ми можемо зробити це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">map</span> <span class="p">(</span><span class="kt">Circle</span> <span class="mi">10</span> <span class="mi">20</span><span class="p">)</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">4.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">5.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">,</span><span class="kt">Circle</span> <span class="mf">10.0</span> <span class="mf">20.0</span> <span class="mf">6.0</span><span class="p">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Наш тип даних гарний, хоча він міг би бути кращим. Давайте створимо проміжний тип даних, що визначає точку в двовимірному просторі. Потім ми можемо використовувати це для створення наших фігур більш зрозумілим способом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що коли визначали точку, ми використали те саме ім'я для типу даних та значення конструктора. Це не має особливого значення, хоча це загально використовувати те саме ім'я що і тип, якщо це конструктор одного значення. Так що тепер <code>Circle</code> має два поля, один має тип <code>Point</code>, та інше тип <code>Float</code>. Це спрощує розуміння того, що є що. Те саме стосується і прямокутника. Ми маємо налаштувати нашу функцію <code>surface</code> для відзеркалення ціх змін.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">surface</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">r</span> <span class="o">^</span> <span class="mi">2</span>
<span class="nf">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="ow">=</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">abs</span> <span class="o">$</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Одна річ, що ми маємо змініти, це шаблони. Ми зневажили цілу точку в шаблоні кола. В шаблоні прямокутника ми просто використовували вкладене порівняння шаблонів, щоб отримати поля точок. Якщо ми б бажали посилатись на самі точки з якоїсь причини, ми могли б використати <code>as</code>-шаблони.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">100</span> <span class="mi">100</span><span class="p">))</span>
<span class="mf">10000.0</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">surface</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">24</span><span class="p">)</span>
<span class="mf">1809.5574</span>
</pre></div></div></div>
<div class="paragraph"><p>Як щодо функції, що рухає фігуру? Вона бере фігуру, величину руху по осі <code>x</code>, величину руху по осі <code>y</code>, та потім повертає нову фігуру, що має ті самі розміри, але розміщений в іншому місці.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">nudge</span> <span class="ow">::</span> <span class="kt">Shape</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="n">r</span>
<span class="nf">nudge</span> <span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">x2</span> <span class="n">y2</span><span class="p">))</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x1</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y1</span><span class="o">+</span><span class="n">b</span><span class="p">))</span> <span class="p">(</span><span class="kt">Point</span> <span class="p">(</span><span class="n">x2</span><span class="o">+</span><span class="n">a</span><span class="p">)</span> <span class="p">(</span><span class="n">y2</span><span class="o">+</span><span class="n">b</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить прямолінійно. Ми додаємо зсув до точок, що відповідають за позицію фігури.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">34</span> <span class="mi">34</span><span class="p">)</span> <span class="mi">10</span><span class="p">)</span> <span class="mi">5</span> <span class="mi">10</span>
<span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">39.0</span> <span class="mf">44.0</span><span class="p">)</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми не бажаємо мати справу напряму з точками, ми можемо зробити деякі додаткові функції, що створюють фігури деякого розміру з нульовими координатами, та потім рухати їх.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">baseCircle</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseCircle</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="n">r</span>

<span class="nf">baseRect</span> <span class="ow">::</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Float</span> <span class="ow">-&gt;</span> <span class="kt">Shape</span>
<span class="nf">baseRect</span> <span class="n">width</span> <span class="n">height</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">width</span> <span class="n">height</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">nudge</span> <span class="p">(</span><span class="n">baseRect</span> <span class="mi">40</span> <span class="mi">100</span><span class="p">)</span> <span class="mi">60</span> <span class="mi">23</span>
<span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">60.0</span> <span class="mf">23.0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mf">100.0</span> <span class="mf">123.0</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, ви можете експортувати ваші типи даних в ваші модулі. Щоб зробити це, просто напишіть ваші типи разом з функціями, що ви експортуємо, та потім додайте деякі дужки, і в них вкажіть конструктори значень, що ви бажаєте експортувати для них, розділені комами. Якщо ви бажаєте експортувати всі конструктори значень для даного типу, просто напишіть <code>..</code>.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте експортувати функції та типи, що ми визначили тут, в модулі, ми можемо почати, наприклад, так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Shapes</span>
<span class="p">(</span> <span class="kt">Point</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="kt">Shape</span><span class="p">(</span><span class="o">..</span><span class="p">)</span>
<span class="p">,</span> <span class="nf">surface</span>
<span class="p">,</span> <span class="nf">nudge</span>
<span class="p">,</span> <span class="nf">baseCircle</span>
<span class="p">,</span> <span class="nf">baseRect</span>
<span class="p">)</span> <span class="kr">where</span>
</pre></div></div></div>
<div class="paragraph"><p>Роблячи <code>Shape(..)</code>, ми експортуємо всі конструктори значень для <code>Shape</code>, і це означає, що коли дехто імпортує наш модуль, він зможе створювати фігури, використовуючи конструктори значень <code>Rectangle</code> та <code>Circle</code>. Це те саме, що написати <code>Shape (Rectangle, Circle)</code>.</p></div>
<div class="paragraph"><p>Ми також можемо вирішити не експортувати жодних конструкторів значень для <code>Shape</code>, просто написавши <code>Shape</code> в твердженні <code>export</code>. Таким чином, той, хто імпортує наш модуль, зможе створювати фігури через використання додаткових функцій <code>baseCircle</code> та <code>baseRect</code>. <code>Data.Map</code> використовує цей підхід. Ви не можете створити мапу, зробивши <code>Map.Map [(1,2),(3,4)]</code>, оскільки він не експортує конструктор значень. Однак ви можете створити відображення через використання однієї з додаткових функцій як <code>Map.fromList</code>. Згадайте,що конструктори є тільки функціями, що приймають поля як параметри, та повертає значення деякого типу (як <code>Shape</code>) в якості результату. Так що коли ми обираємо не експортувати їх, ми просто не даємо тому, хто імпортує наш модуль, використосувати ці функції, але якщо деякі інші функції, що експортуються, повертають тип, ми можемо використовувати їх для створення значень наших власних типів даних.</p></div>
<div class="paragraph"><p>Не-експортування конструкторів значень типів даних робить їх більш абстрактними в той спосіб, що ми приховуємо їх реалізацію. Також той, хто користується нашими типами, не зможе робити порівняння шаблонів до конструкторів значень.</p></div>
<div class="paragraph"><p><span class="image">
<img src="images/record.png" alt="images/record.png" />
</span>
OK, ми отримали завдання створити тип даних, що описував би осообу. Інформація, що ми бажаємо зберігати щодо особи, наступна: ім'я, фамілія, вік, зріст, номер телефону та улюблений сорт морозива. Не знаю як щодо вас, але це все, що я будь-коли бажав знати про людину. Давайте дамо цьому хід!</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kt">Float</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Окей. Перше поле є першим ім'ям, друге фамілія, третє вік і так далі. Давайте створимо особу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">guy</span>
<span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дещо круте, але трохи не читається. Що, коли ми бажаємо створити функцію для отримання окремої інформації про особу? Функцію, що отримує ім'я, фамілію, вік, тощо. Гаразд, ми маємо визначити її таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">firstName</span> <span class="p">(</span><span class="kt">Person</span> <span class="n">firstname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">firstname</span>

<span class="nf">lastName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">lastName</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="n">lastname</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lastname</span>

<span class="nf">age</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">age</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">age</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">age</span>

<span class="nf">height</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">Float</span>
<span class="nf">height</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">height</span> <span class="kr">_</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">height</span>

<span class="nf">phoneNumber</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">phoneNumber</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">number</span>

<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">flavor</span> <span class="p">(</span><span class="kt">Person</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">flavor</span><span class="p">)</span> <span class="ow">=</span> <span class="n">flavor</span>
</pre></div></div></div>
<div class="paragraph"><p>Хух! Я напевне не був радий написати це! Не зважаючи на плутанину і СКУКУ під час написання, цей метод робить.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">guy</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="s">&quot;Buddy&quot;</span> <span class="s">&quot;Finklestein&quot;</span> <span class="mi">43</span> <span class="mf">184.2</span> <span class="s">&quot;526-2928&quot;</span> <span class="s">&quot;Chocolate&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">firstName</span> <span class="n">guy</span>
<span class="s">&quot;Buddy&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">height</span> <span class="n">guy</span>
<span class="mf">184.2</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">flavor</span> <span class="n">guy</span>
<span class="s">&quot;Chocolate&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Має бути кращий спосіб, скажете ви! Ні, немає, пробачайте.</p></div>
<div class="paragraph"><p>Я шуткую, він є. Гигиги! Творці Haskell були досить розумні та передбачили цей сценарій. Вони включили альтернативний спосіб для написання типів даних. Ось як ми можемо досягти ту ж функціональність за допомогою синтаксису запису.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span> <span class="n">firstName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">lastName</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">age</span> <span class="ow">::</span> <span class="kt">Int</span>
                     <span class="p">,</span> <span class="n">height</span> <span class="ow">::</span> <span class="kt">Float</span>
                     <span class="p">,</span> <span class="n">phoneNumber</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">,</span> <span class="n">flavor</span> <span class="ow">::</span> <span class="kt">String</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Так що замість називати типи полів один за одним, та розділяти їх проміжками ми використовуємо фігурні дужки. Спочатку ми пишемо ім'я поля, наприклад <code>firstName</code>, та потім ми пишемо дві двокрапки <code>::</code> (що також називається <code>Paamayim Nekudotayim</code>, ахаха - <em>насправді це саме подвійна двокрапка на івриті, назва з'явилась вперше в PHP3 як кваліфікатор поля зору. прим.перекл.</em>), і потім ми задаємо тип. Результуючий тип даних саме такий. Головна перевага цього в тому, що він створює функції, що шукають поля в типі даних. Через використання синтаксису полів для створення цього типу даних, Haskell автоматично створює ці функції: <code>firstName</code>, <code>lastName</code>, <code>age</code>, <code>height</code>, <code>phoneNumber</code> та <code>flavor</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">flavor</span>
<span class="nf">flavor</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="n">firstName</span>
<span class="nf">firstName</span> <span class="ow">::</span> <span class="kt">Person</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Є інша вигода використовувати синтаксис записів. Коли ви наслідуєте  <code>Show</code> для типа, він відображує його по різному, якщо ми використоауємо синтаксис запису при визначенні і створенні екземпляру типу. Скажімо ми маємо тип, що представляє машину. Ми бажаємо відслідковувати компанію, що виробляє її, назву моделі, та рік її виробництва. Дивіться.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="kt">String</span> <span class="kt">String</span> <span class="kt">Int</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
<span class="kt">Car</span> <span class="s">&quot;Ford&quot;</span> <span class="s">&quot;Mustang&quot;</span> <span class="mi">1967</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми використаємо синтаксис запису, ми можемо створити нову машину таким чином.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span><span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Car</span> <span class="p">{</span><span class="n">company</span><span class="ow">=</span><span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span><span class="ow">=</span><span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span><span class="ow">=</span><span class="mi">1967</span><span class="p">}</span>
<span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="s">&quot;Ford&quot;</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="s">&quot;Mustang&quot;</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="mi">1967</span><span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми створюємо машину, ми не обов'язково покладаємо поля в певному порядку, доки ми вказуємо їх всі. Але якщо ми не використовуємо синтаксис запису, ми маємо вказувати їх по порядку.</p></div>
<div class="paragraph"><p>Використовуйте синтаксис записів, коли конструктор має декілька полів, і не очевидне, яке поле є яке. Якщо ми створюємо тип даних для тривимірного вектора, роблячи <code>data Vector = Vector Int Int Int</code>, є досить очевидним, що поля є компонентами вектора. Але в наших типах <code>Person</code> та <code>Car</code> це не буде таким очевидним, і ми отримаємо велику вигоду, використовуючи синтаксис запису.</p></div>
<div class="paragraph"><p>Конструктор значення може приймати деякі параметри значення, та потім продукувати нове значення. Наприклад, конструктор <code>Car</code> бере три значення і продукує значення машини. В подібний спосіб конструктори типів можуть приймати типи та продукувати нові типи. Спочатку це може виглядати трохи абстрактним, але це не так складно. Якщо ви знайомі з шаблонами в C++, ви побачите деякі паралелі. Щоб отримати ясну картину як діють параметри типів насправді, давайте поглянемо, як реалізовані типи, з якими ми вже зустрічались.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p><span class="image">
<img src="images/yeti.png" alt="images/yeti.png" />
</span>
Тут <code>a</code> є параметром типу. І оскільки задіяно параметр типу, ми викликаємо конструктор типу <code>Maybe</code>. В залежності від того, який тип даних ми бажаємо містити, коли це не <code>Nothing</code>, цей конструктор може кінець кінцем продукувати тип <code>Maybe Int</code>, <code>Maybe Car</code>, <code>Maybe String</code>, тощо. Жодне значення не може мати тип просто <code>Maybe</code>, оскільки це не тип як такий, це конструктор типів. Щоб це стало реальним типом, частиною якого може бути значення, він має заповнити всі свої параметри типів.</p></div>
<div class="paragraph"><p>Так що коли ми передамо <code>Char</code> як параметр типів до <code>Maybe</code>, ми отримаємо тип <code>Maybe Char</code>. Значення <code>Just 'a'</code> має тип <code>Maybe Char</code>, як для прикладу.</p></div>
<div class="paragraph"><p>Ви могли цього не знати, але ми використовували тип, що мав параметр типу, перед тим як ми використовували <code>Maybe</code>. Цей тип є тип списку. Хоча тут задієний деякий синтаксичний цукор, тип списку приймає параметр для утворення певного типу. Значення можуть мати тип <code>[Int]</code>, тип <code>[Char]</code>, тип <code>[[String]]</code>, але ви не можете мати значення, що має просто тип <code>[]</code>.</p></div>
<div class="paragraph"><p>Давайте пограємось з типом <code>Maybe</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span>
<span class="kt">Just</span> <span class="s">&quot;Haha&quot;</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Just</span> <span class="mi">84</span>
<span class="kt">Just</span> <span class="mi">84</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">t</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="kt">Maybe</span> <span class="n">t</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">t</span> <span class="kt">Nothing</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="kt">Just</span> <span class="mi">10</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="kt">Double</span>
<span class="kt">Just</span> <span class="mf">10.0</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметри типів корисні, оскільки ми можемо робити різні типи з їх допомогою, в залежності від того, який тип ми бажаємо щоб містився в нашому типі даних. Коли ми робимо <code>:t Just "Haha"</code>, рушій виводу типів здогадується, що тип має бути <code>Maybe [Char]</code>, бо якщо <code>a</code> в  <code>Just</code> є рядком, тоді <code>a</code> в <code>Maybe</code> також має бути рядком.</p></div>
<div class="paragraph"><p>Зауважте, що тип <code>Nothing</code> є <code>Maybe a</code>. Його тип поліморфний. Якщо деяка функція потребує <code>Maybe Int</code> в якості параметра, ми можемо дати їй <code>Nothing</code>, оскільки <code>Nothing</code> все одно не містить значення, так що воно не має значення. Тип <code>Maybe a</code> може діяти як <code>Maybe Int</code> в разі потреби, так само, як <code>5</code> може діяти як <code>Int</code> або <code>Double</code>. Подібним чином тип порожнього списку є <code>[a]</code>. Порожній список може діяти як список будь чого. Ось чому ми можемо робити <code>[1,2,3] ++ []</code> та <code>["ha","ha","ha"] ++ []</code>.</p></div>
<div class="paragraph"><p>Використання параметрів типів дуже корисні, але тільки якщо їх використання має сенс. Зазвичай ми використовуємо їх, коли наш тип даних буде робити незалежно від типа значення, що буде міститись в ньому. Якщо наш тип діє як свого роду ящик, буде гарно використати його. Ми можемо змінити наш тип даних <code>Car</code> з такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="kt">String</span>
               <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="kt">Int</span>
               <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>До такого:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">Car</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span> <span class="kt">Car</span> <span class="p">{</span> <span class="n">company</span> <span class="ow">::</span> <span class="n">a</span>
                     <span class="p">,</span> <span class="n">model</span> <span class="ow">::</span> <span class="n">b</span>
                     <span class="p">,</span> <span class="n">year</span> <span class="ow">::</span> <span class="n">c</span>
                     <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але чи буде з цього користь? Відповідь така: мабуть ні, бо ми лише скінчимо визначенням функцій, що роблять на типі <code>Car String String Int</code>. Наприклад, беручи наше перше визначення <code>Car</code>, ми можемо створити функцію, що показує властивості машини в вигляді невеликого гарного тексту.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">tellCar</span> <span class="ow">::</span> <span class="kt">Car</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
<span class="nf">tellCar</span> <span class="p">(</span><span class="kt">Car</span> <span class="p">{</span><span class="n">company</span> <span class="ow">=</span> <span class="n">c</span><span class="p">,</span> <span class="n">model</span> <span class="ow">=</span> <span class="n">m</span><span class="p">,</span> <span class="n">year</span> <span class="ow">=</span> <span class="n">y</span><span class="p">})</span> <span class="ow">=</span> <span class="s">&quot;This &quot;</span> <span class="o">++</span> <span class="n">c</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">m</span> <span class="o">++</span> <span class="s">&quot; was made in &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span cl