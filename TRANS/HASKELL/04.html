<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___">Синтаксис в функціях</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__">Співпадіння шаблонів</h3>
<div class="paragraph"><p><span class="image">
<img src="images/pattern.png" alt="images/pattern.png" />
</span>
Ця глава дослідить деякі з крутих синтаксичних конструкцій Haskell, і ми почнемо зі співпадіння шаблонів. Співпадіння шаблонів складається з вказання шаблонів, яким мають відповідати деякі дані, та потім перевірити, чи це так, та деконструювати дані відповідно до ціх шаблонів.</p></div>
<div class="paragraph"><p>Коли визначаєте функції, ви можете визначити окремі тіла функції для різних шаблонів. Це призводить до дійсно милого коду, що простий та читається. Ви можете перевіряти шаблони на кожному типі — числах, символах, списках, таплах, тощо. Давайте зробимо насправді тривіальну функцію, що перевіряє, чи надане нами число сімка, або ні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">lucky</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Integral</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">lucky</span> <span class="mi">7</span> <span class="k">=</span> <span class="s">&quot;LUCKY NUMBER SEVEN!&quot;</span>
<span class="n">lucky</span> <span class="n">x</span> <span class="k">=</span> <span class="s">&quot;Sorry, you&#39;re out of luck, pal!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ми викликаємо <code>lucky</code>, шаблони будуть перевірятись згори донизу, і коли шаблон буде задовільнятись, відповідне тіло буде використовуватись. Єдиний спосіб, як число може задовільніти першому шаблону - якщо це <code>7</code>. Якщо ні, керування провалюється до другого шаблону, що співпадає з будь чим, та прикріпляє його до <code>x</code>. Ця функція також може бути реалізованою через використання твердження <code>if</code>. Але що, коли ми бажаємо функцію, що каже числа від <code>1</code> до <code>5</code>, та каже "Not between 1 and 5" для любого іншого числа? Без співпадіння шаблоній ми будемо швидко втягнуті в дерево <code>if then else</code>. Однак з шаблонами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">sayMe</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Integral</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">sayMe</span> <span class="mi">1</span> <span class="k">=</span> <span class="s">&quot;One!&quot;</span>
<span class="n">sayMe</span> <span class="mi">2</span> <span class="k">=</span> <span class="s">&quot;Two!&quot;</span>
<span class="n">sayMe</span> <span class="mi">3</span> <span class="k">=</span> <span class="s">&quot;Three!&quot;</span>
<span class="n">sayMe</span> <span class="mi">4</span> <span class="k">=</span> <span class="s">&quot;Four!&quot;</span>
<span class="n">sayMe</span> <span class="mi">5</span> <span class="k">=</span> <span class="s">&quot;Five!&quot;</span>
<span class="n">sayMe</span> <span class="n">x</span> <span class="k">=</span> <span class="s">&quot;Not between 1 and 5&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що якщо ми перемістмо останній шаблон (спіймати все) догори, він завжди буде казати "Not between 1 and 5", оскільки він буде ловити всі числа без шансу провалитись, та перевірити всі інші шаблони.</p></div>
<div class="paragraph"><p>Згадайте функцію факторіала, що ми реалізували до цього? Ми визначали <code>factorial</code> числа <code>n</code> як добуток <code>[1..n]</code>. Ми також можемо визначити функцію факториала рекурсивно, спосіб, що зазвичай використовується в математиці. Ми починаємо, кажучи що факторіал <code>0</code> є <code>1</code>. Потім ми кажемо, що факторіал любого позитивного цілого є це ціле, помножене на факторіал свого попередника. Ось як це виглядає, перекладене в терміни Haskell.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">factorial</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Integral</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">factorial</span> <span class="mi">0</span> <span class="k">=</span> <span class="mi">1</span>
<span class="n">factorial</span> <span class="n">n</span> <span class="k">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span> <span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це перший раз, коли ми визначили функцію рекурсивно. Рекурсія важлива в Haskell, і пізніше ми поглянемо на неї ближче. Але ось що відбувається, коли ми беремо факторіал, скажімо, <code>3</code>. Він намагаться обчислити <code>3 * factorial 2</code>. Факторіал 2 є <code>2 * factorial 1</code>, так що досі ми маємо <code>3 * (2 * factorial 1)</code>. <code>factorial 1</code> є <code>1 * factorial 0</code>, так що ми маємо <code>3 * (2 * (1 * factorial 0))</code>. Тепер настає час трюку — ми визначили факторіал <code>0</code> як просто <code>1</code>, та оскільки це підпадає під той шаблон, що іде до загального випадка, він просто повертає <code>1</code>. Так що остаточний результат еквівалентний до <code>3 * (2 * (1 * 1))</code>. Якщо б ми написали другий шаблон над першим, він би відловлював всі числа, включаючи 0, і наші обчислення ніколи б не закінчились. Ось чому порядок важливий, коли вкзуєте шаблони, і завжди краще вказувати найбільш специфічні першими, та більш загальні потім.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може схибити. Якщо ми визначимо функцію ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">charName</span> <span class="o">::</span> <span class="nc">Char</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">charName</span> <span class="sc">&#39;a&#39;</span> <span class="k">=</span> <span class="s">&quot;Albert&quot;</span>
<span class="n">charName</span> <span class="sc">&#39;b&#39;</span> <span class="k">=</span> <span class="s">&quot;Broseph&quot;</span>
<span class="n">charName</span> <span class="sc">&#39;c&#39;</span> <span class="k">=</span> <span class="s">&quot;Cecil&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>та потім спробуємо викликати її маючи на вході щось неочікуване, ось що трапиться:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;a&#39;</span>
<span class="s">&quot;Albert&quot;</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;b&#39;</span>
<span class="s">&quot;Broseph&quot;</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">charName</span> <span class="sc">&#39;h&#39;</span>
<span class="err">&quot;</span><span class="o">***</span> <span class="nc">Exception</span><span class="k">:</span> <span class="kt">tut.hs:</span><span class="o">(</span><span class="err">53</span><span class="o">,</span><span class="err">0</span><span class="o">)-(</span><span class="mi">55</span><span class="o">,</span><span class="mi">21</span><span class="o">)</span><span class="k">:</span> <span class="kt">Non-exhaustive</span> <span class="kt">patterns</span> <span class="kt">in</span> <span class="kt">function</span> <span class="kt">charName</span>
</pre></div></div></div>
<div class="paragraph"><p>Вона скаржиться, що ми маємо невиключні шаблони, і це так і є насправді. При створенні шаблонів нам слідує завжди включати загальні шаблони, так що наша програма не завалиться, якщо ми отримаємо неочікуваний вхід.</p></div>
<div class="paragraph"><p>Співпадіння шаблонів також може використовувати тапли. Що, коли ми бажаємо створити функцію, що приймає два вектори в 2D просторі (що є в формі пар), та додає їх разом? Щоб додати разом два вектори, ми додаємо їх <code>x</code> компоненти окремо, та потім їх <code>y</code> компоненти окремо. Ось що ми можемо зробити, якщо ви не знаємо про співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">addVectors</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
<span class="n">addVectors</span> <span class="n">a</span> <span class="n">b</span> <span class="k">=</span> <span class="o">(</span><span class="n">fst</span> <span class="n">a</span> <span class="o">+</span> <span class="n">fst</span> <span class="n">b</span><span class="o">,</span> <span class="n">snd</span> <span class="n">a</span> <span class="o">+</span> <span class="n">snd</span> <span class="n">b</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Гаразд, це робить, але існує кращий шлях, щоб зробити це. Давайте модифікуємо функцію, так щоб вона використовувала співпадіння шаблонів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">addVectors</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span>
<span class="n">addVectors</span> <span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="n">y1</span><span class="o">)</span> <span class="o">(</span><span class="n">x2</span><span class="o">,</span> <span class="n">y2</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="o">,</span> <span class="n">y1</span> <span class="o">+</span> <span class="n">y2</span><span class="o">)</span>
</pre></div></div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Ось так! Значно краще. Зауважте, що це все ще загальний шаблон. Тип <code>addVectors</code> (в обох випадках) є `addVectors 
</dt>
<dd>
<p>
(Num a) &#8658; (a, a) &#8594; (a, a) - &gt; (a, a)`, так що ми гарантовано отримуємо дві пари як параметри.
</p>
</dd>
</dl></div>
<div class="paragraph"><p><code>fst</code> та <code>snd</code> виділяють компоненти з пар. Але що з трійками? Гаразд, немає готової функції, щоб зробити це, але ми можемо створити власну.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">first</span> <span class="o">::</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">first</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>

<span class="n">second</span> <span class="o">::</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">second</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="n">y</span>

<span class="n">third</span> <span class="o">::</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">c</span>
<span class="n">third</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>Знак <code>_</code> означає ту саму річ, що він робить в осяжностях списків. Це означає, що насправді нам байдуже, що є в цій частині, так що пи просто пишемо <code>_</code>.</p></div>
<div class="paragraph"><p>Що нагадує мені, що ви також можете робити співпадіння в осяжностях списків. Перевірте це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">let</span> <span class="n">xs</span> <span class="k">=</span> <span class="o">[(</span><span class="err">1</span>,<span class="err">3</span><span class="o">)</span>, <span class="o">(</span><span class="err">4</span>,<span class="err">3</span><span class="o">)</span>, <span class="o">(</span><span class="err">2</span>,<span class="err">4</span><span class="o">)</span>, <span class="o">(</span><span class="err">5</span>,<span class="err">3</span><span class="o">)</span>, <span class="o">(</span><span class="err">5</span>,<span class="err">6</span><span class="o">)</span>, <span class="o">(</span><span class="err">3</span>,<span class="err">1</span><span class="o">)]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="o">[</span><span class="kt">a+b</span> <span class="kt">|</span> <span class="o">(</span><span class="kt">a</span>,<span class="kt">b</span><span class="o">)</span> <span class="kt">&lt;-</span> <span class="kt">xs</span><span class="o">]</span>
<span class="o">[</span><span class="err">4</span>,<span class="err">7</span>,<span class="err">6</span>,<span class="err">8</span>,<span class="err">11</span>,<span class="err">4</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли співпадіння схибить, він буде тільки переходити на наступний елемент.</p></div>
<div class="paragraph"><p>Самі списки також можуть використовуватись в співпадінні шаблонів. Ви можете порівнювати з порожнім списком <code>[]</code>, або любим шаблоном, що включає <code>:</code> та порожній список. Але оскільки <code>[1,2,3]</code> є тільки синтаксичним цукром для <code>1:2:3:[]</code>, ви також можете використовувати і такий шаблон. Шаблон як <code>x:xs</code> буде прикріпляти голову списку до <code>x</code>, та залишок до <code>xs</code>, навіть якщо був один елемент, так що <code>xs</code> в кінці буде порожнім списком.</p></div>
<div class="paragraph"><p>Note: Шаблон <code>x:xs</code> багато використовується, особливо з рекурсивними функціями. Але шаблони, що мають в собі <code>:</code>, співпадають тільки зі списками довжини 1 або більше.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте прикріпити, скажімо, перші три елементи до змінних, та залишок до іншої змінної, ви можете використовувати щось подібне до <code>x:y:z:zs</code>. Це буде співпадати тільки зі списками, що мають три елементи або більше.</p></div>
<div class="paragraph"><p>Тепер ми знаємо, як порівнювати шаблони зі списками, давайте створими нашу власну реалізацію функції <code>head</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">head</span><span class="err">&#39;</span> <span class="o">::</span> <span class="o">[</span><span class="kt">a</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">head</span><span class="err">&#39;</span> <span class="o">[]</span> <span class="k">=</span> <span class="n">error</span> <span class="s">&quot;Can&#39;t call head on an empty list, dummy!&quot;</span>
<span class="n">head</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">x</span><span class="k">:_</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span>
</pre></div></div></div>
<div class="paragraph"><p>Перевіримо, чи вона робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">head</span><span class="err">&#39;</span> <span class="o">[</span><span class="err">4</span>,<span class="err">5</span>,<span class="err">6</span><span class="o">]</span>
<span class="mi">4</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">head</span><span class="err">&#39;</span> <span class="s">&quot;Hello&quot;</span>
<span class="sc">&#39;H&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарно! Зауважте, що якщо ви бажаєте прикріпити декілька змінних (навіть якщо одна з них просто <code>_</code>, та взагалі нічого не прикріплює), ми маємо оточити їх в дужки. Також зауважте функцію <code>error</code>, яку ми використовуємо. Вона приймає рядок та генерує помилку часу виконання, використовуючи рядок як інформацію щодо різновиду виникшої помилки. Це призводить до падіння програми, так що недобре використовувати її дуже багато. Але виклик <code>head</code> на порожньому списку не має сенсу.</p></div>
<div class="paragraph"><p>Давайте створимо тривіальну функцію, що каже нам перші елементи списку в зручній англійській формі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">tell</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Show</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">[</span><span class="kt">a</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">tell</span> <span class="o">[]</span> <span class="k">=</span> <span class="s">&quot;The list is empty&quot;</span>
<span class="n">tell</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="err">[]</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;The list has one element: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span>
<span class="n">tell</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:</span><span class="o">[])</span> <span class="k">=</span> <span class="s">&quot;The list has two elements: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
<span class="n">tell</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">y:</span><span class="k">_</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;This list is long. The first two elements are: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">x</span> <span class="o">++</span> <span class="s">&quot; and &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">y</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця функція безпечна, оскільки вона турбується про порожній список, список синглтон, список з двома елементами, та списки з більше двох елементів. Зауважте, що <code>(x:[])</code> та <code>(x:y:[])</code> можуть бути переписані як <code>[x]</code> та <code>[x,y]</code> (завдяки синтаксичному цукру нам не потрібні дужки). Ми не можемо переписати <code>(x:y:_)</code> з квадратними дужками, оскільки він співпадає зі списком довжини 2 або більше.</p></div>
<div class="paragraph"><p>Ми вже реалізовали нашу власну функцію <code>length</code> використовуючи осяжність списків. Тепер ми зробимо це, використовуючи співпадіння шаблонів та трохи рекурсії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">length</span><span class="err">&#39;</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">[</span><span class="kt">a</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">b</span>
<span class="n">length</span><span class="err">&#39;</span> <span class="o">[]</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">length</span><span class="err">&#39;</span> <span class="o">(</span><span class="k">_:</span><span class="kt">xs</span><span class="o">)</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">length</span><span class="err">&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Це подібно до функції <code>factorial</code>, що ми писали раніше. Спочатку ми визначили результат для відомого входу — порожнього списку. Це також відомо як гранична умова. Потім в другому шаблоні ми розбиваємо список на частки, відділяючи голову та хвіст. Ми кажемо, що довжина дорівнює 1 плюс довжина хвоста. Ми використовуємо <code>_</code> для співпадіння з головою, оскільки нам насправді байдуже, що це. Також зауважте, що ми потурбувались про всі можливі шаблони для списку. Перший шаблон співпадає з порожнім списком, та другий співпадає з будь чим, що не є порожнім списком.</p></div>
<div class="paragraph"><p>Давайте подивимось, що коли ми викличемо <code>length'</code> на <code>"ham"</code>. Спочатку ми перевіримо, чи це порожній список, і через те, що це не так, ми провалимось до другого шаблону. Це співпадає з другим шаблоном, і каже, що довжина є <code>1 + length' "am"</code>, оскільки ми розбили рядок на голову і хвіст, та відкинули голову. Гаразд. Довжина <code>length'</code> від <code>"am"</code> подібним чином є <code>1 + length' "m"</code>. Так що прямо зараз ми маємо <code>1 + (1 + length' "m")</code>. <code>length' "m"</code> є <code>1 + length' ""</code> (також можна записати як <code>1 + length' []</code>). І ми визначили <code>length' []</code> як <code>0</code>. Так що в кінці ми маємо <code>1 + (1 + (1 + 0))</code>.</p></div>
<div class="paragraph"><p>Давайте реалізуємо <code>sum</code>. Ми знаємо, що сума порожнього списку є 0. Запишемо це в вигляді шаблону. І ми також знаємо, що сума списку є голова, плюс сума залишку списку. Коли ми запишемо все це, ми отримаємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">sum</span><span class="err">&#39;</span> <span class="o">::</span> <span class="o">(</span><span class="nc">Num</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">[</span><span class="kt">a</span><span class="o">]</span> <span class="o">-&gt;</span> <span class="n">a</span>
<span class="n">sum</span><span class="err">&#39;</span> <span class="o">[]</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">sum</span><span class="err">&#39;</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span><span class="kt">xs</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sum</span><span class="err">&#39;</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є така річ, що називається <code>as</code> шаблонами. Це зручний спосіб розбити щось відповідно до шаблону, та прикріпити частки до імен, при цьому зберігаючи посилання на цілу річ. Ви робите це, покладаючи ім'я та знак <code>@</code> перед шаблоном. Наприклад, шаблон <code>xs@(x:y:ys)</code>. Цей шаблон буде співпадати точно з тією самою річчю, що і <code>x:y:ys</code>, але ви можете просто отримати цілий список через <code>xs</code>, замість повторювати себе через повторний набір <code>x:y:ys</code> в тілі функції. Ось швидкий та брудний приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">capital</span> <span class="o">::</span> <span class="nc">String</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">capital</span> <span class="s">&quot;&quot;</span> <span class="k">=</span> <span class="s">&quot;Empty string, whoops!&quot;</span>
<span class="n">capital</span> <span class="n">all</span><span class="o">@(</span><span class="n">x</span><span class="k">:</span><span class="kt">xs</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;The first letter of &quot;</span> <span class="o">++</span> <span class="n">all</span> <span class="o">++</span> <span class="s">&quot; is &quot;</span> <span class="o">++</span> <span class="o">[</span><span class="kt">x</span><span class="o">]</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">capital</span> <span class="s">&quot;Dracula&quot;</span>
<span class="s">&quot;The first letter of Dracula is D&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно ми використовуємо шаблони щоб уникнути повторення себе, коли порівнення з більшим шаблоном, коли ми використовуємо цілу річ в тілі функції.</p></div>
<div class="paragraph"><p>Ще одна річ — ви не можете використовувати <code>++</code> в співпадіннях шаблонів. Якщо ви спробуєте порівняти шаблон з <code>(xs ++ ys)</code>, що буде першим списком, та що буде другим списком? Це не має великого сенсу. Буде мати сенс порівняти з <code>(xs ++ [x,y,z])</code> або просто <code>(xs ++ [x])</code>, але завдяки природі списків ви не можете зробити цього.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Охорона, охорона!</h3>
<div class="paragraph"><p><span class="image">
<img src="images/guards.png" alt="images/guards.png" />
</span>
В той час, коли шаблони є шляхом переконатись, що значення відповідає деякій формі, та деконструкції, охоронці є шляхом перевірити, чи деяка властивість значення (або декілька з них) є <code>true</code> або <code>false</code>. Це звучить як твердження <code>if</code>, і є дуже подібним. Річ в тому, що охоронці значно легше читаються, коли ви маєте декілька умов, і вони грають добре в команді з шаблонами.</p></div>
<div class="paragraph"><p>Замість пояснення їх синтаксису, давайте просто зануримось, та створимо функцію з використанням охоронців. Ми збираємось створити просту функцію, що кваліфікує вас відповідно до вашого індексу BMI (body mass index). Ваш BMI дорівнює вашій вазі, поділеній на ваш зріст в квадраті. Якщо ваш BMI менший за 18.5, в вас недостатньо ваги. Якщо ви десь між 18.5 до 25, ви відповідаєте нормі. Від 25 до 30 є надмірною вагою, і більше 30 це ожиріння. Так що ось функція (ми не будемо обчислювати прямо зараз, ця функція обчислює BMI та каже результат):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">bmiTell</span> <span class="o">::</span> <span class="o">(</span><span class="nc">RealFloat</span> <span class="n">a</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="nc">String</span>
<span class="n">bmiTell</span> <span class="n">bmi</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">18.5</span> <span class="k">=</span> <span class="s">&quot;You&#39;re underweight, you emo, you!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">25.0</span> <span class="k">=</span> <span class="s">&quot;You&#39;re supposedly normal. Pffft, I bet you&#39;re ugly!&quot;</span>
    <span class="o">|</span> <span class="n">bmi</span> <span class="o">&lt;=</span> <span class="mf">30.0</span> <span class="k">=</span> <span class="s">&quot;You&#39;re fat! Lose some weight, fatty!&quot;</span>
    <span class="o">|</span> <span class="n">otherwise</span>   <span class="k">=</span> <span class="s">&quot;You&#39;re a whale, congratulations!&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Охоронці позначаються стовпчиками, що слідують за ім'ям функції та її параметрами. Зазвичай вони відступають трохи вправо, та відрівняні між собою. Охоронець в основі є логічний вираз. Якщо він обчислюється до <code>True</code>, тоді використовується відповідне тіло функції. Якщо він обчислюється до <code>False</code>, перевірка переходить до наступного охоронця і так далі. Якщо ми викличемо цю функцію з 24.3, вона спочатку перевірить, чи це меньше або рівне ніж 18.5. Оскільки це ні, переходимо до наступного охоронця. Перевірка каже, що другій охоронець пропускає, бо 24.3 меньше ніж 25.0, і повертається другий рядок.</p></div>
<div class="paragraph"><p>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable. While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can&#8217;t get around them. Guards are a very nice alternative for this.</p></div>
<div class="paragraph"><p>Many times, the last guard is otherwise. otherwise is defined simply as otherwise = True and catches everything. This is very similar to patterns, only they check if the input satisfies a pattern but guards check for boolean conditions. If all the guards of a function evaluate to False (and we haven&#8217;t provided an otherwise catch-all guard), evaluation falls through to the next pattern. That&#8217;s how patterns and guards play nicely together. If no suitable guards or patterns are found, an error is thrown.</p></div>
<div class="paragraph"><p>Of course we can use guards with functions that take as many parameters as we want. Instead of having the user calculate his own BMI before calling the function, let&#8217;s modify this function so that it takes a height and weight and calculates it for us.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
bmiTell 
</dt>
<dd>
<p>
(RealFloat a) &#8658; a &#8594; a &#8594; String
bmiTell weight height
    | weight / height <sup> 2 &#8656; 18.5 = "You&#8217;re underweight, you emo, you!"
    | weight / height </sup> 2 &#8656; 25.0 = "You&#8217;re supposedly normal. Pffft, I bet you&#8217;re ugly!"
    | weight / height ^ 2 &#8656; 30.0 = "You&#8217;re fat! Lose some weight, fatty!"
    | otherwise                 = "You&#8217;re a whale, congratulations!"
Let&#8217;s see if I&#8217;m fat &#8230;
</p>
</dd>
</dl></div>
<div class="paragraph"><p>ghci&gt; bmiTell 85 1.90
"You&#8217;re supposedly normal. Pffft, I bet you&#8217;re ugly!"
Yay! I&#8217;m not fat! But Haskell just called me ugly. Whatever!</p></div>
<div class="paragraph"><p>Note that there&#8217;s no = right after the function name and its parameters, before the first guard. Many newbies get syntax errors because they sometimes put it there.</p></div>
<div class="paragraph"><p>Another very simple example: let&#8217;s implement our own max function. If you remember, it takes two things that can be compared and returns the larger of them.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
max' 
</dt>
<dd>
<p>
(Ord a) &#8658; a &#8594; a &#8594; a
max' a b
    | a &gt; b     = a
    | otherwise = b
Guards can also be written inline, although I&#8217;d advise against that because it&#8217;s less readable, even for very short functions. But to demonstrate, we could write max' like this:
</p>
</dd>
<dt class="hdlist1">
max' 
</dt>
<dd>
<p>
(Ord a) &#8658; a &#8594; a &#8594; a
max' a b | a &gt; b = a | otherwise = b
Ugh! Not very readable at all! Moving on: let&#8217;s implement our own compare by using guards.
</p>
</dd>
<dt class="hdlist1">
myCompare 
</dt>
<dd>
<p>
(Ord a) &#8658; a &#8594; a &#8594; Ordering
a <code>myCompare</code> b
    | a &gt; b     = GT
    | a == b    = EQ
    | otherwise = LT
ghci&gt; 3 <code>myCompare</code> 2
GT
Note: Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes it&#8217;s easier to read that way.
Where!?
In the previous section, we defined a BMI calculator function and berator like this:
</p>
</dd>
<dt class="hdlist1">
bmiTell 
</dt>
<dd>
<p>
(RealFloat a) &#8658; a &#8594; a &#8594; String
bmiTell weight height
    | weight / height <sup> 2 &#8656; 18.5 = "You&#8217;re underweight, you emo, you!"
    | weight / height </sup> 2 &#8656; 25.0 = "You&#8217;re supposedly normal. Pffft, I bet you&#8217;re ugly!"
    | weight / height ^ 2 &#8656; 30.0 = "You&#8217;re fat! Lose some weight, fatty!"
    | otherwise                   = "You&#8217;re a whale, congratulations!"
Notice that we repeat ourselves here three times. We repeat ourselves three times. Repeating yourself (three times) while programming is about as desirable as getting kicked inna head. Since we repeat the same expression three times, it would be ideal if we could calculate it once, bind it to a name and then use that name instead of the expression. Well, we can modify our function like this:
</p>
</dd>
<dt class="hdlist1">
bmiTell 
</dt>
<dd>
<p>
(RealFloat a) &#8658; a &#8594; a &#8594; String
bmiTell weight height
    | bmi &#8656; 18.5 = "You&#8217;re underweight, you emo, you!"
    | bmi &#8656; 25.0 = "You&#8217;re supposedly normal. Pffft, I bet you&#8217;re ugly!"
    | bmi &#8656; 30.0 = "You&#8217;re fat! Lose some weight, fatty!"
    | otherwise   = "You&#8217;re a whale, congratulations!"
    where bmi = weight / height ^ 2
We put the keyword where after the guards (usually it&#8217;s best to indent it as much as the pipes are indented) and then we define several names or functions. These names are visible across the guards and give us the advantage of not having to repeat ourselves. If we decide that we want to calculate BMI a bit differently, we only have to change it once. It also improves readability by giving names to things and can make our programs faster since stuff like our bmi variable here is calculated only once. We could go a bit overboard and present our function like this:
</p>
</dd>
<dt class="hdlist1">
bmiTell 
</dt>
<dd>
<p>
(RealFloat a) &#8658; a &#8594; a &#8594; String
bmiTell weight height
    | bmi &#8656; skinny = "You&#8217;re underweight, you emo, you!"
    | bmi &#8656; normal = "You&#8217;re supposedly normal. Pffft, I bet you&#8217;re ugly!"
    | bmi &#8656; fat    = "You&#8217;re fat! Lose some weight, fatty!"
    | otherwise     = "You&#8217;re a whale, congratulations!"
    where bmi = weight / height ^ 2
          skinny = 18.5
          normal = 25.0
          fat = 30.0
The names we define in the where section of a function are only visible to that function, so we don&#8217;t have to worry about them polluting the namespace of other functions. Notice that all the names are aligned at a single column. If we don&#8217;t align them nice and proper, Haskell gets confused because then it doesn&#8217;t know they&#8217;re all part of the same block.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>where bindings aren&#8217;t shared across function bodies of different patterns. If you want several patterns of one function to access some shared name, you have to define it globally.</p></div>
<div class="paragraph"><p>You can also use where bindings to pattern match! We could have rewritten the where section of our previous function as:</p></div>
<div class="paragraph"><p>&#8230;
where bmi = weight / height ^ 2
      (skinny, normal, fat) = (18.5, 25.0, 30.0)
Let&#8217;s make another fairly trivial function where we get a first and a last name and give someone back their initials.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
initials 
</dt>
<dd>
<p>
String &#8594; String &#8594; String
initials firstname lastname = [f] <code> ". " </code> [l] ++ "."
    where (f:_) = firstname
          (l:_) = lastname
We could have done this pattern matching directly in the function&#8217;s parameters (it would have been shorter and clearer actually) but this just goes to show that it&#8217;s possible to do it in where bindings as well.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Just like we&#8217;ve defined constants in where blocks, you can also define functions. Staying true to our healthy programming theme, let&#8217;s make a function that takes a list of weight-height pairs and returns a list of BMIs.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
calcBmis 
</dt>
<dd>
<p>
(RealFloat a) &#8658; [(a, a)] &#8594; [a]
calcBmis xs = [bmi w h | (w, h) &#8592; xs]
    where bmi weight height = weight / height ^ 2
And that&#8217;s all there is to it! The reason we had to introduce bmi as a function in this example is because we can&#8217;t just calculate one BMI from the function&#8217;s parameters. We have to examine the list passed to the function and there&#8217;s a different BMI for every pair in there.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>where bindings can also be nested. It&#8217;s a common idiom to make a function and define some helper function in its where clause and then to give those functions helper functions as well, each with its own where clause.</p></div>
<div class="paragraph"><p>Let it be
Very similar to where bindings are let bindings. Where bindings are a syntactic construct that let you bind to variables at the end of a function and the whole function can see them, including all the guards. Let bindings let you bind to variables anywhere and are expressions themselves, but are very local, so they don&#8217;t span across guards. Just like any construct in Haskell that is used to bind values to names, let bindings can be used for pattern matching. Let&#8217;s see them in action! This is how we could define a function that gives us a cylinder&#8217;s surface area based on its height and radius:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
cylinder 
</dt>
<dd>
<p>
(RealFloat a) &#8658; a &#8594; a &#8594; a
cylinder r h =
    let sideArea = 2 * pi * r * h
        topArea = pi * r ^2
    in  sideArea + 2 * topArea
let it be
The form is let &lt;bindings&gt; in &lt;expression&gt;. The names that you define in the let part are accessible to the expression after the in part. As you can see, we could have also defined this with a where binding. Notice that the names are also aligned in a single column. So what&#8217;s the difference between the two? For now it just seems that let puts the bindings first and the expression that uses them later whereas where is the other way around.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>The difference is that let bindings are expressions themselves. where bindings are just syntactic constructs. Remember when we did the if statement and it was explained that an if else statement is an expression and you can cram it in almost anywhere?</p></div>
<div class="paragraph"><p>ghci&gt; [if 5 &gt; 3 then "Woo" else "Boo", if <em>a</em> &gt; <em>b</em> then "Foo" else "Bar"]</p></div>
<div class="paragraph"><p>ghci&gt; 4 * (if 10 &gt; 5 then 10 else 0) + 2
42
You can also do that with let bindings.</p></div>
<div class="paragraph"><p>ghci&gt; 4 * (let a = 9 in a + 1) + 2
42
They can also be used to introduce functions in a local scope:</p></div>
<div class="paragraph"><p>ghci&gt; [let square x = x * x in (square 5, square 3, square 2)]</p></div>
<div class="paragraph"><p>If we want to bind to several variables inline, we obviously can&#8217;t align them at columns. That&#8217;s why we can separate them with semicolons.</p></div>
<div class="paragraph"><p>ghci&gt; (let a = 100; b = 200; c = 300 in a*b*c, let foo="Hey "; bar = "there!" in foo ++ bar)
(6000000,"Hey there!")
You don&#8217;t have to put a semicolon after the last binding but you can if you want. Like we said before, you can pattern match with let bindings. They&#8217;re very useful for quickly dismantling a tuple into components and binding them to names and such.</p></div>
<div class="paragraph"><p>ghci&gt; (let (a,b,c) = (1,2,3) in a+b+c) * 100
600
You can also put let bindings inside list comprehensions. Let&#8217;s rewrite our previous example of calculating lists of weight-height pairs to use a let inside a list comprehension instead of defining an auxiliary function with a where.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
calcBmis 
</dt>
<dd>
<p>
(RealFloat a) &#8658; [(a, a)] &#8594; [a]
calcBmis xs = [bmi | (w, h) &#8592; xs, let bmi = w / h ^ 2]
We include a let inside a list comprehension much like we would a predicate, only it doesn&#8217;t filter the list, it only binds to names. The names defined in a let inside a list comprehension are visible to the output function (the part before the |) and all predicates and sections that come after of the binding. So we could make our function return only the BMIs of fat people:
</p>
</dd>
<dt class="hdlist1">
calcBmis 
</dt>
<dd>
<p>
(RealFloat a) &#8658; [(a, a)] &#8594; [a]
calcBmis xs = [bmi | (w, h) &#8592; xs, let bmi = w / h ^ 2, bmi &gt;= 25.0]
We can&#8217;t use the bmi name in the (w, h) &#8592; xs part because it&#8217;s defined prior to the let binding.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>We omitted the in part of the let binding when we used them in list comprehensions because the visibility of the names is already predefined there. However, we could use a let in binding in a predicate and the names defined would only be visible to that predicate. The in part can also be omitted when defining functions and constants directly in GHCi. If we do that, then the names will be visible throughout the entire interactive session.</p></div>
<div class="paragraph"><p>ghci&gt; let zoot x y z = x * y + z
ghci&gt; zoot 3 9 2
29
ghci&gt; let boot x y z = x * y + z in boot 3 4 2
14
ghci&gt; boot
&lt;interactive&gt;:1:0: Not in scope: &#8216;boot&#8217;
If let bindings are so cool, why not use them all the time instead of where bindings, you ask? Well, since let bindings are expressions and are fairly local in their scope, they can&#8217;t be used across guards. Some people prefer where bindings because the names come after the function they&#8217;re being used in. That way, the function body is closer to its name and type declaration and to some that&#8217;s more readable.</p></div>
<div class="paragraph"><p>Case expressions
case
Many imperative languages (C, C++, Java, etc.) have case syntax and if you&#8217;ve ever programmed in them, you probably know what it&#8217;s about. It&#8217;s about taking a variable and then executing blocks of code for specific values of that variable and then maybe including a catch-all block of code in case the variable has some value for which we didn&#8217;t set up a case.</p></div>
<div class="paragraph"><p>Haskell takes that concept and one-ups it. Like the name implies, case expressions are, well, expressions, much like if else expressions and let bindings. Not only can we evaluate expressions based on the possible cases of the value of a variable, we can also do pattern matching. Hmmm, taking a variable, pattern matching it, evaluating pieces of code based on its value, where have we heard this before? Oh yeah, pattern matching on parameters in function definitions! Well, that&#8217;s actually just syntactic sugar for case expressions. These two pieces of code do the same thing and are interchangeable:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
head' 
</dt>
<dd>
<p>
[a] &#8594; a
head' [] = error "No head for empty lists!"
head' (x:_) = x
</p>
</dd>
<dt class="hdlist1">
head' 
</dt>
<dd>
<p>
[a] &#8594; a
head' xs = case xs of [] &#8594; error "No head for empty lists!"
                      (x:_) &#8594; x
As you can see, the syntax for case expressions is pretty simple:
</p>
</dd>
</dl></div>
<div class="paragraph"><p>case expression of pattern &#8594; result
                   pattern &#8594; result
                   pattern &#8594; result
                   &#8230;
expression is matched against the patterns. The pattern matching action is the same as expected: the first pattern that matches the expression is used. If it falls through the whole case expression and no suitable pattern is found, a runtime error occurs.</p></div>
<div class="paragraph"><p>Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. For instance:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
describeList 
</dt>
<dd>
<p>
[a] &#8594; String
describeList xs = "The list is " ++ case xs of [] &#8594; "empty."
[x] &#8594; "a singleton list."
xs &#8594; "a longer list."
</p>
</dd>
</dl></div>
<div class="paragraph"><p>They are useful for pattern matching against something in the middle of an expression. Because pattern matching in function definitions is syntactic sugar for case expressions, we could have also defined this like so:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
describeList 
</dt>
<dd>
<p>
[a] &#8594; String
describeList xs = "The list is " ++ what xs
    where what [] = "empty."
          what [x] = "a singleton list."
          what xs = "a longer list."
</p>
</dd>
</dl></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-08-16 02:15:56 EEST
</div>
</div>
</body>
</html>
