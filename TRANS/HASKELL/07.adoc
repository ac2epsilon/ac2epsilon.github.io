include::header.adoc[]

== Модулі

=== Завантаження модулів

image:images/modules.png[]
Модуль Haskell є колекцією пов'язаних функцій, типів та типокласів. Програма Haskell є колекцією модулів, де головний модул завантажує інші модулі, та потім використовує функції, визначені в них, щоб зробити дещо. Мати код поділеним на декілька модулів має досить багато переваг. Якщо модуль досить загальний, функції, які він експортує, можуть бути використані в безлічі різних програм. Якщо ваш власний код поділений на само-достатні модулі, що не покладаються один на одний дуже сильно (ми кажемо що вони слабко пов'язані), в падольшому ви можете використовувати їх. Це робить всю справу написання коду більш керованою, маючи поділеним його на окремі частини, кожна з яких має власне призначення.

Стандартна бібліотека Haskell поділена на модулі, кожний з них містить функції та типи, які деяким чином пов'язані та служать деякій загальній цілі. Є модуль для маніпуляцій зі списками, модуль для конкурентного програмування, модуль для справ з комплексними числами, тощо. Всі функції, типи та типокласи, з якими ми досі мали справу, були частиною модуля `Prelude`, що імпортується по замовчанню. В цій главі ми збираємось дослідити декілька корисних модулів та функцій, що вони мають. Але спочатку ми збираємось подивитись, як імпортувати модулі.

Синтаксис для імпортування модулів в скрипті Haskell є `import <module name>`. Це має бути зроблене перед визначенням любих функцій, так що імпорти звичайно робляться зверху файла. Звичайно, один скрипт може імпортувати декілька модулів. Просто покладіть кожний імпорт в окремий рядок. Давайте імпортуємо модуль `Data.List`, що має декілька корисних функцій для роботи зі списками, та використаємо функцію, що він експортує, для створення функції, що каже нам, як багато унікальних елементів має наш список.

[source,haskell]
----
import Data.List  
  
numUniques :: (Eq a) => [a] -> Int  
numUniques = length . nub  
----

Коли ви робите `import Data.List`, всі функції, що експортує `Data.List`, стають доступними в глобальному просторі імен, що значить, що ви можете викликати їх будь-деme в скрипті. `nub` є функція, визначена в `Data.List`, що приймає список і відкидає дубліковані елементи. Компонуючи `length` та `nub` роблячи `length . nub` продукує функцію, що еквівалентна до `\xs -> length (nub xs)`.

Ви також можете покласти функції модулів в глобальний простір імен при використанні GHCI. Якщо ви в GHCI, і ви бажаєте бути в змозі викликати функції, експортовані `Data.List`, зробіть це:

[source,haskell]
----
ghci> :m + Data.List  
----

Якщо ви бажаєте завантажити імена з декількох модулів всередині GHCI, ми не маємо робити `:m +` декілька раз, ми можемо просто завантажити декілька модулів за один раз.

[source,haskell]
----
ghci> :m + Data.List Data.Map Data.Set  
----

Однак якщо ви завантажили скрипт, що вже імпортує модуль, вам не треба використовувати `:m +` щоб отримати доступ до нього.

Якщо вам просто треба пара функцій з модуля, ви можете вибірково імпортувати лише ці функції. Якщо ви бажаєте імпортувати тільки функції `nub` та `sort` з `Data.List`, ми робимо так:

[source,haskell]
----
import Data.List (nub, sort)  
----

Ви можете також обрати імпорт всіх функцій з модуля, за винятком декількох обраних. Це часто корисно, коли декілька модулів експортують функції з тим самим іменем, і ви бажаєте прибрати заважаючі варіанти. Скажімо, ми вже маємо нашу власну функцію, що називається `nub`, і ми бажаємо імпортувати всі функції з `Data.List`, за винятком функції `nub`:

[source,haskell]
----
import Data.List hiding (nub)  
----

Інший шлях мати справу з класами з перетином імен - робити кваліфіковані імпорти. Модуль `Data.Map`, що пропонує структуру даних для пошуку значень по ключу, експортує декілька функцій з тими ж назвами, що і функції `Prelude`, як `filter` або `null`. Так що коли ми імпортуємо `Data.Map` і потім викликаємо `filter`, Haskell не знає, яку функцію використовувати. Ось як ми вирішуємо це:

[source,haskell]
----
import qualified Data.Map  
----

Це робить так, що коли ми бажаємо посилатись на функцію `Data.Map`  `filter`, ми маємо робити `Data.Map.filter`, коли тільки `filter` все ще посилається на нормальний `filter`, який ми всі знаємо і любимо. Але набір `Data.Map` перед кожною функцію з цього модуля є дещо обтяжливо. Осі чому ми можемо переіменувати кваліфікований імпорт на дещо коротше:

[source,haskell]
----
import qualified Data.Map as M  
----

Тепер для посилання на функцію `Data.Map` `filter` ми виристовуємо лише `M.filter`.

Використовуйте це зручне посилання, щоб побачити, які модулі є в стандартній бібліотеці. Гарний спосіб отримати нове знання щодо Haskell є просто клацати по посиланню стандартної бібліотеки, та досліджувати модулі та їх функції. Ви можете також передивлятись джерельний код Haskell для кожного модуля. Читання джерельного коду для деяких модулів є дійсно гарним шляхом вивчати Haskell та отримати солідне відчуття мови.

Для пошуку функцій або для пошуку, де вони розташовані, використовуйте `Hoogle`. Це дійсно неймовірна пошукова система Haskell, ви можете шукати по імені, імені модуля або навіть сигнатурі типу.

=== Data.List

Модуль `Data.List` це все про списки, це очевидно. Він провадить деякі дуже корисні функції для роботи з ними. Ми вже зустрічались з деяким з ціх функцій (як `map` та `filter`), оскільки модуль `Prelude` експортує деякі функції з `Data.List` для зручності. Ви не маєте імпортувати `Data.List` через кваліфікований імпорт, оскільки його імена не перетинаються з жодними іменами `Prelude`, за винятком тих, що `Prelude` вже краде у `Data.List`. Давайте поглянемо на деякі функції, з якими ми раніше не зустрічались.

`intersperse` бере елемент та список, і потім покладає цей елемент між кожною парою елементів списка. Ось демонстрація:

[source,haskell]
----
ghci> intersperse '.' "MONKEY"  
"M.O.N.K.E.Y"  
ghci> intersperse 0 [1,2,3,4,5,6]  
[1,0,2,0,3,0,4,0,5,0,6]  
----

`intercalate` бере лист список списків, і список. Потім він вставляє цей список між всіма ціма списками, і потім сплощує результат.

[source,haskell]
----
ghci> intercalate " " ["hey","there","guys"]  
"hey there guys"  
ghci> intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]  
[1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]  
----

`transpose` траспонує список списків. Якщо ви подивитесь на список списків як на 2D матрицю, стовпчики стають рядками та навпаки.

[source,haskell]
----
ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]  
[[1,4,7],[2,5,8],[3,6,9]]  
ghci> transpose ["hey","there","guys"]  
["htg","ehu","yey","rs","e"]  
----

Скажімо, ми маємо поліноми `3x2 + 5x + 9`, `10x3 + 9` та `8x3 + 5x2 + x - 1` і ми бажаємо додати їх разом. Ми можемо використати списки `[0,3,5,9]`, `[10,0,0,9]` та `[8,5,1,-1]` для представлення їх в Haskell. Тепер щоб додати їх, все що треба зробити це:

[source,haskell]
----
ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]  
[18,8,6,17]  
----

Коли ми транспонуємо ці три списки, три куби опиняться в першому рядку, квадрати в другому, і так далі. Відображуючи `sum` на це продукує бажаний результат.

image:images/lists.png[]
`foldl'` та `foldl1'` є суворіші версії відносно до своїх лінивих інкарнацій. Коли використовуються ліниві згортки на дійсно списках, часто ви можете отримати помилку переповнення стеку. Винуватцем цього є те, що через ліниву природу згорток значення аккумулятора насправді не оновлюється по мірі згортки. Що насправді відбувається, це те, що аккумулятор робить свого роду обіцянки, що віе обчислить своє значення, коли попросять дійсно зпродукувати результат (що також називається грім). Це відбувається для кожного проміжного аккумулятора, і всі ці громи переповнюють ваш стек. Сувора згортка не така лінива істота, та насправді обчислює проміжні значення по мірі надходження, замість заповнювати ваш стек. Так що якщо ви колись отримаєте переповнення стеку роблячи ліниві згортки, спробуйте переключитись на їх суворі версії.

`concat` зрівнює список списків в просто список елементів.

[source,haskell]
----
ghci> concat ["foo","bar","car"]  
"foobarcar"  
ghci> concat [[3,4,5],[2,3,4],[2,1,1]]  
[3,4,5,2,3,4,2,1,1]  
----

Він буде видаляти лише один рівень вкладення. Так що якщо ви бажаете повністю сплющити `[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]`, що є списком списків списків, ви маєте виконати конкатенацію двічі.

Виконання `concatMap` є те саме, що спочатку відобразити функцію на список, та потім конкатувати список `concat`.

[source,haskell]
----
ghci> concatMap (replicate 4) [1..3]  
[1,1,1,1,2,2,2,2,3,3,3,3]  
----

`and` бере список логічних значень, та повертає `True` тільки якщо всі значення в списку є `True`.

[source,haskell]
----
ghci> and $ map (>4) [5,6,7,8]  
True  
ghci> and $ map (==4) [4,4,4,3,4]  
False  
----

`or` подібне до `and`, тільки повертає `True` якщо любе логічне значення в списку є `True`.

[source,haskell]
----
ghci> or $ map (==4) [2,3,4,5,6,1]  
True  
ghci> or $ map (>4) [1,2,3]  
False  
----

`any` та `all` беруть предикат, та потім перевіряють, чи якісь або всі елементи списку задовільняють предикату, відповідно. Звичайно ми використовуємо ці дві функції замість відображення по списку, та потім робити `and` або `or`.

[source,haskell]
----
ghci> any (==4) [2,3,5,6,1,4]  
True  
ghci> all (>4) [6,9,10]  
True  
ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
False  
ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"  
True  
----

`iterate` бере функцію та початкове значення. Вона застосовує функцію до стартового значення, потім вона застосовує цю функцію до результату знову, тощо. Вона повертає всі результати в формі безкінечного списку.

[source,haskell]
----
ghci> take 10 $ iterate (*2) 1  
[1,2,4,8,16,32,64,128,256,512]  
ghci> take 3 $ iterate (++ "haha") "haha"  
["haha","hahahaha","hahahahahaha"]  
----

`splitAt` бере число та список. Потім вона розділяє список на це число елементів, повертаючи два списки як тапл.

[source,haskell]
----
ghci> splitAt 3 "heyman"  
("hey","man")  
ghci> splitAt 100 "heyman"  
("heyman","")  
ghci> splitAt (-3) "heyman"  
("","heyman")  
ghci> let (a,b) = splitAt 3 "foobar" in b ++ a  
"barfoo"  
----

`takeWhile` є дійсно корисною невеликою функцією. Вона бере елементи зі списку доки виконується предикат, та коли трепиться елемент, що не задовільняє, вона відсікає всі інші. Як з'ясовується ще дуже корисно.

[source,haskell]
----
ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]  
[6,5,4]  
ghci> takeWhile (/=' ') "This is a sentence"  
"This"  
----

Скажімо, ми бажаємо знати суму всіх третіх ступінів, що є до `10000`. Ми не можемо зробити `map (^3)` до `[1..]`, застосувати `filter` та потім спробувати підсумувати все це, бо фільтр на безкінечному спіску ніколи не завершиться. Ви можете знати, що всі елементи ідуть по зростанню, але Haskell ні. Ось чому ми можемо зробити це:

[source,haskell]
----
ghci> sum $ takeWhile (<10000) $ map (^3) [1..]  
53361  
----

Ми застосовуємо `(^3)` до безкінечного списку, та потім, коли це буде більше `10000`, список буде обрізаний. Тепер ми можемо його легко підсумувати.

`dropWhile` є подібним, тільки вона відкидає всі елементи, доки виконується предикат. Як тільки предикат дорівнює `False`, вона повертає залишок списку. Вкрай корисна і мила функція!

[source,haskell]
----
ghci> dropWhile (/=' ') "This is a sentence"  
" is a sentence"  
ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]  
[3,4,5,4,3,2,1]  
----

Ми надали список, що представляє значення акцій по даті. Список складається з таплів, чий перший компонент є значення курсу акцій, другий елемент рік, третій місяць а четвертий дата. Ми бажаємо знати, коли значення акцій вперше перевищило тисячу доларів!

[source,haskell]
----
ghci> let stock = [(994.4,2008,9,1),(995.2,2008,9,2),(999.2,2008,9,3),(1001.4,2008,9,4),(998.3,2008,9,5)]  
ghci> head (dropWhile (\(val,y,m,d) -> val < 1000) stock)  
(1001.4,2008,9,4)  
----

`span` дещо як `takeWhile`, тільки він повертає пару списків. Перший список містить все, що містив би результуючий список `takeWhile`, коли б ми викликали його з тим самим предикатом та тим самим списком. Другий список містить частину списку, що мала б бути відкинутою.

[source,haskell]
----
ghci> let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest  
"First word: This, the rest: is a sentence"  
----

Тоді як `span` поділяє список доки предикат вірний, `break` перериває коли предикат стає перший раз `True`. Зробити `break p` є еквівалентним зробити `span (not . p)`.

[source,haskell]
----
ghci> break (==4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
ghci> span (/=4) [1,2,3,4,5,6,7]  
([1,2,3],[4,5,6,7])  
----

При використанні `break`, другий список в результаті буде починатись з першого елементу, що задовільняє предикату.

`sort` просто сортує список. Тип елементів в списку має бути частиною типокласу `Ord`, оскільки якщо елементи списку не можуть бути покладені в деякому порядку, тоді такий список неможливо відсортувати.

[source,haskell]
----
ghci> sort [8,5,3,2,1,6,4,2]  
[1,2,2,3,4,5,6,8]  
ghci> sort "This will be sorted soon"  
"    Tbdeehiillnooorssstw"  
----

`group` бере список та групує сусідні елементи в субсписки, якщо вони рівні.

[source,haskell]
----
ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]  
----

Якщо ми вортуємо список перед групуванням, ми можемо знайти, скільки разів кожний елемент з'являється в списку.

[source,haskell]
----
ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]  
[(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]  
----

`inits` та `tails` подібні до `init` та `tail`, тільки вони рекурсивно застосовуються до списку, доки нічого не залишиться. Дослідимо.

[source,haskell]
----
ghci> inits "w00t"  
["","w","w0","w00","w00t"]  
ghci> tails "w00t"  
["w00t","00t","0t","t",""]  
ghci> let w = "w00t" in zip (inits w) (tails w)  
[("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]  
----

Давайте використаємо `fold` для реалізації пошуку підсписку в списку.

[source,haskell]
----
search :: (Eq a) => [a] -> [a] -> Bool  
search needle haystack =   
    let nlen = length needle  
    in  foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)  
----

Спочатку ми викликаємо `tails` зі списком, в якому ми шукаємо. Потім ми проходимо по кожному хвосту, та дивимось, чи він починається з того, що ми шукаємо.

Маючи це, ми насправді лише зробили функцію, що поводиться як `isInfixOf`. `isInfixOf` шукає субсписок, та повертає `True`, якщо субсписок, що ми шукаємо, десь всередині цільового списку.

[source,haskell]
----
ghci> "cat" `isInfixOf` "im a cat burglar"  
True  
ghci> "Cat" `isInfixOf` "im a cat burglar"  
False  
ghci> "cats" `isInfixOf` "im a cat burglar"  
False  
----

`isPrefixOf` та `isSuffixOf` шукають субсписок напочатку та в кінці списку, відповідно.

[source,haskell]
----
ghci> "hey" `isPrefixOf` "hey there!"  
True  
ghci> "hey" `isPrefixOf` "oh hey there!"  
False  
ghci> "there!" `isSuffixOf` "oh hey there!"  
True  
ghci> "there!" `isSuffixOf` "oh hey there"  
False  
----

`elem` та `notElem` перевіряють, чи елемент є або його немає в списку.

`partition` бере список та предикат, та повертає пару списків. Перший список в результаті містить всі списки, що задовільняють предикату, другий містить всі що не задовільняють.

[source,haskell]
----
ghci> partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
("BOBMORGAN","sidneyeddy")  
ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]  
([5,6,7],[1,3,3,2,1,0,3])  
----

Важливо розуміти, як це відрізняється від `span` та `break`:

[source,haskell]
----
ghci> span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"  
("BOB","sidneyMORGANeddy")  
----

Коли `span` та `break` завершуються коли вони натраплять на перший елемент, що не- або задовільняє предикату, `partition` проходить по цілому списку, та розділяє його відповідно предиката.

`find` бере список та предикат, та повертає перший елемент, що задовільняє предикату. Але він повертає цей елемент огорнутим в значення `Maybe`. Ми будемо розглядати алгебраїчні типи даних більш детально в наступній главі, але доки це все що ви маєте знати: значення `Maybe` може бути або `Just` дещо або `Nothing`. Так само, як список може бути або порожнім, або списком з якимось елементами, значення `Maybe` може бути або без елементів, або мати один елемент. І так само, як тип списку, скажімо, цілих є `[Int]`, тип можливо цілого значення є `Maybe Int`. В жодному разі розкрутимо нашу функцію `find`.

[source,haskell]
----
ghci> find (>4) [1,2,3,4,5,6]  
Just 5  
ghci> find (>9) [1,2,3,4,5,6]  
Nothing  
ghci> :t find  
find :: (a -> Bool) -> [a] -> Maybe a  
----

Зауважте тип `find`. Його результат є `Maybe a`. Це майже так само, як мати тип `[a]`, тільки значення типу `Maybe` можуть містити або елемент, або нічого, тоді як список може не мати жодного, мати один або мати декілька елементів.

Згадайте, як ми шукали, коли перший раз наші акції дійшли більше `$1000`. Ми робили `head (dropWhile (\(val,y,m,d) -> val < 1000) stock)`. Згадайте, що `head` насправді не досить безпечна. Що має трапитись, якщо курс ніколи не доходить за `$1000`? Наше застосування `dropWhile` буде повертати порожній список, та отримання `head` від порожнього списку призведе до помилки. Однак якщо ми перепишемо це як `(\(val,y,m,d) -> val > 1000) stock`, ми будемо значно безпечніше. Якщо наші акції ніколи не заходять за `$1000` (так що немає жодного елементу, що задовільняє предикату), ми отримуємо назад `Nothing`. Але якщо в списку була валідна відповідь в списку, ми б отримали б, скажімо `Just (1001.4,2008,9,4)`.

`elemIndex` є різновидом `elem`, тільки він не повертає логічне значення. Він можливо повертає індекс елемента, який ми шукаємо. Якщо такого елемента немає в нашому списку, він повертає `Nothing`.

[source,haskell]
----
ghci> :t elemIndex  
elemIndex :: (Eq a) => a -> [a] -> Maybe Int  
ghci> 4 `elemIndex` [1,2,3,4,5,6]  
Just 3  
ghci> 10 `elemIndex` [1,2,3,4,5,6]  
Nothing  
----

`elemIndices` подібна до `elemIndex`, тільки вона повертає список індексів, в випадку, коли елемент що ми шукаємо знаходиться в нашому списку декілька раз. Оскільки ми використовуємо список для представлення індексов, нам не треба тип `Maybe`, тому невдача може бути представлена як порожній список, що є досить синонімичнім до `Nothing`.

[source,haskell]
----
ghci> ' ' `elemIndices` "Where are the spaces?"  
[5,9,13]  
----

`findIndex` подібне до `find`, але вона можливо повертає індекс першого елемента, що задовільняє предикату. `findIndices` повертає індекси всіх елементів, що задовільняють предикату в формі списку.

[source,haskell]
----
ghci> findIndex (==4) [5,3,2,1,6,4]  
Just 5  
ghci> findIndex (==7) [5,3,2,1,6,4]  
Nothing  
ghci> findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"  
[0,6,10,14]  
----

Ми вже розглядали `zip` та `zipWith`. Ми зауважили, що вони поеднують разом два списки, або в тапл, або за допомогою двомісної функції (що означає, що функція приймає два параметра). Але що, коли ви бажаєте поеднати разом три списки? Або поєднати три списки за допомогою функції, що приймає три параметри? Гаразд, для цього ми маємо `zip3`, `zip4`, тощо, та `zipWith3`, `zipWith4`, etc. Ці варіанти ідуть до `7`. Хоча це може виглядати як хак, це робить досить гарно, оскільки не дуже часто трапляються випадки, коли вам треба поєднати 8 списків. Також існую розумний спосіб поєднати довільне число списків, але ми не досить просунулись, щоб розглядати його прямо тут.

[source,haskell]
----
ghci> zipWith3 (\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]  
[7,9,8]  
ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]  
[(2,2,5,2),(3,2,5,2),(3,2,3,2)]  
----

Так само, як з нормальним поєднанням, списки, що довші ніж найкоротший список, відсікаються до його розміру.

`lines` є корисною функцією, коли маємо справу з файлами або ввод від чогось іншого. Вона приймає рядок, та повертає кожний рядок в окремий список.

[source,haskell]
----
ghci> lines "first line\nsecond line\nthird line"  
["first line","second line","third line"]  
----

`'\n'` є символ для нового рядка Юнікс. Зворотні косі мають особливе значення в Haskell рядках та символах.

`unlines` є зворотньою до `lines` функцією. Вона приймає список рядків, та потім поєднує їх разом з використанням `'\n'`.

[source,haskell]
----
ghci> unlines ["first line", "second line", "third line"]  
"first line\nsecond line\nthird line\n"  
----

`words` та `unwords` призначені для поділу рядка тексту на слова, або поєднання списку слов в текст. Дуже корисно.

[source,haskell]
----
ghci> words "hey these are the words in this sentence"  
["hey","these","are","the","words","in","this","sentence"]  
ghci> words "hey these           are    the words in this\nsentence"  
["hey","these","are","the","words","in","this","sentence"]  
ghci> unwords ["hey","there","mate"]  
"hey there mate"  
----

Ми вже згадували `nub`. Він бере список та відкидає дублікати елементів, повертаючи список, кожний елемент якого є унікальною сніжинкою! Функція має дещо дивне ім'я. Виявляється, що `"nub"` означає малу грудку або головну частину чогось. По-моєму для назв функцій треба використовувати справжні слова, замість застарілих.

[source,haskell]
----
ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]  
[1,2,3,4]  
ghci> nub "Lots of words and stuff"  
"Lots fwrdanu"  
----

`delete` бере елемент і список, і видаляє перше входження елемента в списку.

[source,haskell]
----
ghci> delete 'h' "hey there ghang!"  
"ey there ghang!"  
ghci> delete 'h' . delete 'h' $ "hey there ghang!"  
"ey tere ghang!"  
ghci> delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"  
"ey tere gang!"  
----

`\\` є функцією різниці. Вона діє як різниця множин, в основному. Для кожного елементу зправа вона видаляє елемент в лівому списку.

[source,haskell]
----
ghci> [1..10] \\ [2,5,9]  
[1,3,4,6,7,8,10]  
ghci> "Im a big baby" \\ "big"  
"Im a  baby"  
----

Зробити `[1..10] \\ [2,5,9]` це як зробити `delete 2 . delete 5 . delete 9 $ [1..10]`.

`union` також діє як функція на множинах. Вона повертає поєднання двох списків. Вона добряче проходиться по кожному елементу в другому списку, та додає його до першого, якщо його там ще немає. Однак начувайтесь, дублікати видаляються з другого списку!

[source,haskell]
----
ghci> "hey man" `union` "man what's up"  
"hey manwt'sup"  
ghci> [1..7] `union` [5..10]  
[1,2,3,4,5,6,7,8,9,10]  
----

`intersect` робить як перетин множин. Вона повертає тільки ті елементи, що знайдені в обох списках.

[source,haskell]
----
ghci> [1..7] `intersect` [5..10]  
[5,6,7]  
----

`insert` бере елемент та список, що може бути відсортований, та вставляє його в останню позицію, де він все ще меньший або рівний наступному елементу. Іншими словами `insert` буде починати на початку списку, та потім продовжувати, доки не знайде елемент, що більше або дорівнює нашому елементу, який він вставляє, і робить вставку перед цім елементом.

[source,haskell]
----
ghci> insert 4 [3,5,1,2,8,2]  
[3,4,5,1,2,8,2]  
ghci> insert 4 [1,3,4,4,1]  
[1,3,4,4,4,1]  
----

`4` вставлене прямо після `3` та перед `5` в першому прикладі, та між `3` і `4` в другому прикладі.

Якщо ми вставляємо в відсортований список, отриманий список буде також відсортований.

[source,haskell]
----
ghci> insert 4 [ 1,2,3,5,6,7] [1,2,3,4,5,6,7]  
ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']  
"abcdefghijklmnopqrstuvwxyz"  
ghci> insert 3 [1,2,4,3,2,1]  
 [1,2,3,4,3,2,1]  
----

Що загального між `length`, `take`, `drop`, `splitAt`, `!!` та `replicate`, це те, що вони приймають `Int` в якості одного з параметрів (або повертають `Int`), навіть якщо вони могли б бути більш загальними та корисними, якщо б вони приймали любий тип, що є частиною типокласів `Integral` або `Num` (в залежності від функцій). Вони роблять це з історичних причин. Однак виправлення цього можливо зламає безліч існуючого коду. Ось чому `Data.List` має власні більш загальні еквіваленти, названі `genericLength`, `genericTake`, `genericDrop`, `genericSplitAt`, `genericIndex` та `genericReplicate`. Наприклад, довжина має сигнатуру типу `length::[a] -> Int`. Якщо ми спробуємо отримати середнє від списку чисел, виконавши `let xs = [1..6] in sum xs / length xs`, ми отримаємо помилку типу, оскільки ви не можете використовувати `/` з `Int`. З іншого боку `genericLength` має сигнатуру `genericLength::(Num a) => [b] -> a`. Оскільки `Num` може діяти як число з плаваючою крапкою, взяття середнього через виконання `let xs = [1..6] in sum xs / genericLength xs` робить гарно.

Функції `nub`, `delete`, `union`, `intersect` та `group` всі мають свої більш загальні варіанти на ім'я `nubBy`, `deleteBy`, `unionBy`, `intersectBy` та `groupBy`. Різниця між ними в тому, що перший набір функцій використовує `==` для перевірки на рівність, тоді як `By` варіанти також приймають функцію еквівалентності, та потім порівнюють з використанням цієї функції. `group` є те ж саме, що і `groupBy (==)`.

Наприклда, скажімо ми маємо список, що описує значення функції для кожної секунди. Ми бажаємо поділити її на субсписки, базуючись на тому, чи значення меньше або більше нуля. Якщо ми зробимо лише звичайне групування, це лише згрупує сусідні однакові значення. Але ми бажаємо згрупувати на основі того, чи воні від'ємні чи ні. Ось де з'являється `groupBy`! Функція еквівалентності, що надається до функцій `By`, повинні приймати две елементи того самого типу, і повертати `True`, якщо вони рівні за її стандартами.

[source,haskell]
----
ghci> let values = [-4.3, -2.4, -1.2, 0.4, 2.3, 5.9, 10.5, 29.1, 5.3, -2.4, -14.5, 2.9, 2.3]  
ghci> groupBy (\x y -> (x > 0) == (y > 0)) values  
[[-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3]  
----

З цього ми ясно бачимо, які частини є додатними, та які від'ємними. Надана функція рівності приймає два елементи, та потім повертає `True`, тільки якщо обоє є від'ємними або обоє додатними. Цю функцію рівності також можна записати як `\x y -> (x > 0) && (y > 0) || (x <= 0) && (y <= 0)`, хоча я думаю, що перший варіант краще читається. Навіть ясніший спосіб написати функцію рівності для функцій `By` є імпортувати функцію `on` з `Data.Function`. `on` визначена таким чином:

[source,haskell]
----
on :: (b -> b -> c) -> (a -> b) -> a -> a -> c  
f `on` g = \x y -> f (g x) (g y)  
----

Так що зробити `(==) ``on`` (> 0)` повертає функцію рівності, що виглядає як `\x y -> (x > 0) == (y > 0)`. `on` використовується з функціями `By`, бо з ним ми можемо робити таке:

[source,haskell]
----
ghci> groupBy ((==) `on` (> 0)) values  
[ [-4.3,-2.4,-1.2],[0.4,2.3,5.9,10.5,29.1,5.3],[-2.4,-14.5],[2.9,2.3] ]
----

Вочевидь гарно читається! Ви можете прочитати це вголос: згрупувати це за рівністю, що настає коли елементи більші нуля.

Подібним чином `sort`, `insert`, `maximum` та `minimum` також мають свої більш загальні еквіваленти. Функції як `groupBy` беруть функцію, що визначає, коли два елементи рівні. `sortBy`, `insertBy`, `maximumBy` та `minimumBy` беруть функцію, що визначає, чи елемент більший, меньший або рівний до іншого. Сигнатура типу `sortBy` є `sortBy::( a -> a -> Ordering) -> [a] -> [a]`. Якщо ви пам'ятаєте з попереднього, тип `Ordering` має значення `LT`, `EQ` або `GT`. `sort` еквівалентна до `sortBy compare`, оскільки тільки приймає два елементи, чиї типи в типокласі `Ord`, та повертає їх відношення впорядкування.

Списки можуть бути порівняні, пле при цьому вони порівнюються лексографічно. Що, коли ми маємо список списків, та ми бажаємо сортувати їх не на основі їх вмісту, а на основі їх довжини? Так, ви майже здогадались, ми будемо використовувати функцію `sortBy`.

[source,haskell]
----
ghci> let xs = [[5,4,5,4,4],[1,2,3],[3,5,4,3],[],[2],[2,2]]  
ghci> sortBy (compare `on` length) xs  
[[],[2],[2,2],[1,2,3],[3,5,4,3],[5,4,5,4,4]]  
----

Неймовірно! `compare `on`` `length` ... це читається майже як англійська! Якщо ви не впевнені, як саме це тут робить, `compare `on`` `length` еквівалентне до `\x y -> length x `compare`` `length y`. Коли ви маєте справу з функціями `By`, що приймають функцію рівності, ви зазвичай робите `(==) `on`` `something`, та коли ви маєте справу з функціями `By`, що приймають функцію впорядкування, ви зазвичай робите `compare `on`` `something`.

=== Data.Char

image:images/legochar.png[]
Модуль `Data.Char` робить те, на що натякає його ім'я. Він експортує функції, що мають справи з символами. Це також корисне при фільтруванні та відображенні з рядками, бо вони є лише списками символів.

`Data.Char` експортує декілька предикатів над символами. Тобто функцій, що приймають символ, та кажуть, чи справджується деяке припущення щодо нього. Ось як це виглядає:

`isControl` перевіряє, чи символ є символом керування.

`isSpace` перевіряє, чи символ є проміжком. Це включає проміжки, табуляції, нові рядки, тощо.

`isLower` перевіряє, чи символ в нижньому реєстрі.

`isUpper` перевіряє, чи символ в верхньому реєстрі.

`isAlpha` перевіряє, чи символ є літерою.

`isAlphaNum` перевіряє, чи символ є літерою або цифрою.

`isPrint` перевіряє, чи символ є друкованим. Наприклад, керівні символи не друкуються.

`isDigit` перевіряє, чи символ є цифрою.

`isOctDigit` перевіряє, чи символ є восьмиричним символом.

`isHexDigit` перевіряє, чи символ є шістнацятиричною цифрою.

`isLetter` перевіряє, чи символ є літерою.

`isMark` перевіряє щодо символів маркування Unicode. Це символи, що комбінуються з попередніми символами для формування літер з наголосами та умулятами. Використовуйте це, якщо ви француз.

`isNumber` перевіряє, чи символ є числом.

`isPunctuation` перевіряє, чи символ є пунктуацією.

`isSymbol` перевіряє, чи символ є незвичайним математичним або символом валют.

`isSeparator` перевіряє на проміжки та роздільники Unicode.

`isAscii` перевіряє, чи символ підпадає в перші 128 символів набору символів Unicode.

`isLatin1` перевіряє, чи символ підпадає в перші 256 символів Unicode.

`isAsciiUpper` перевіряє, чи символ ASCII в верхньому реєстрі.

`isAsciiLower` перевіряє, чи символ ASCII в нижньому реєстрі.

Всі ці предикати мають сигнатуру типу `Char -> Bool`. Більшість часу ви будете використовувати їх для фільтрування рядків або чогось подібного. Наприклад, скажімо, ми робимо програму, що приймає ім'я користувачи, та це ім'я може складатись тільки з літер та цифр. Ми можемо використовувати функцію `Data.List` `all` в комбінації з предикатами `Data.Char` для визначення, чи ім'я користувача в порядку.

[source,haskell]
----
ghci> all isAlphaNum "bobby283"  
True  
ghci> all isAlphaNum "eddy the fish!"  
False  
----

Круто. В випадку якщо ви не пам'ятаєте, `all` приймає предикат та список, та повертає `True` тільки якщо предикат дотримується для всіх елементів в списку.

Ми також можемо використовувати `isSpace` для симуляції функції `Data.List` `words`.

[source,haskell]
----
ghci> words "hey guys its me"  
["hey","guys","its","me"]  
ghci> groupBy ((==) `on` isSpace) "hey guys its me"  
["hey"," ","guys"," ","its"," ","me"]  
ghci>  
----

Хмм, гарно, це робить майже те саме що робить `words`, але ми залишились з елементами, що містять тільки проміжки. Хмм, то що ми маємо робити? Я знаю, просто відфільтруемо цей непотріб.

[source,haskell]
----
ghci> filter (not . any isSpace) . groupBy ((==) `on` isSpace) $ "hey guys its me"  
["hey","guys","its","me"]  
----

Ось так.

`Data.Char` також імпортує тип даних що подібний до `Ordering`. Тип `Ordering` може мати значення `LT`, `EQ` або `GT`. Це різновид переліку. Він описує декілька можливих результатів, що можуть виникнути від порівняння двох елементів. Тип `GeneralCategory` також є переліком. Він презентує декілька можливих категорій, до яких може належати символ. Головна функція для отримання загальної категорії символа є `generalCategory`. Вона має тип `generalCategory ::Char -> GeneralCategory`. Існує близько `31` категорій, так що ми не будемо перелічувати їх тут, але пограємось з функцією.

[source,haskell]
----
ghci> generalCategory ' '  
Space  
ghci> generalCategory 'A'  
UppercaseLetter  
ghci> generalCategory 'a'  
LowercaseLetter  
ghci> generalCategory '.'  
OtherPunctuation  
ghci> generalCategory '9'  
DecimalNumber  
ghci> map generalCategory " \t\nA9?|"  
[Space,Control,Control,UppercaseLetter,DecimalNumber,OtherPunctuation,MathSymbol]  
----

Оскільки тип `GeneralCategory` є частиною типокласу `Eq`, ми можемо також перевірити дещо, наприклад `generalCategory c == Space`.

`toUpper` конвертує символ в верхній реєстр. Проміжки, числа та все подібне залишається без змін.

`toLower` конвертує символи в нижній реєстр.

`toTitle` конвертує символ в заглавні. Для більшості символів це те саме, що верхній реєстр.

`digitToInt` конвертує символ до `Int`. Щоб це було успішним символ має бути в диапазоні `'0'..'9'`, `'a'..'f'` або `'A'..'F'`.

[source,haskell]
----
ghci> map digitToInt "34538"  
[3,4,5,3,8]  
ghci> map digitToInt "FF85AB"  
[15,15,8,5,10,11]  
----

`intToDigit` є інверсною функцією до `digitToInt`. Вона приймає `Int` в диапазоні `0..15` та конвертує його в символ нижнього реєстра.

[source,haskell]
----
ghci> intToDigit 15  
'f'  
ghci> intToDigit 5  
'5'  
----

Функції `ord` та `chr` конвертують символи до відповідних чисел та навпаки:

[source,haskell]
----
ghci> ord 'a'  
97  
ghci> chr 97  
'a'  
ghci> map ord "abcdefgh"  
[97,98,99,100,101,102,103,104]  
----

Різниця між `ord` значеннями двох символів дорівнює тому, як далеко вони в таблиці Unicode.

Шифр Цезаря є примітивним методом кодування повідомлень, зсуваючи кожний символ в повідомленні на фіксований число позицій в абетці. Ми можемо просто створити різновид шифра Цезаря, тільки ми не будемо обмежувати себе абеткою.

[source,haskell]
----
encode :: Int -> String -> String  
encode shift msg = 
    let ords = map ord msg  
        shifted = map (+ shift) ords  
    in  map chr shifted  
----

Тут ми зпочатку конвертуємо рядок в список чисел. Потім ми додаємо сзув до кожного значення перед конвертації списку назад до символів. Якщо ви ковбой композиції, ви можете записати тіло цієї функції як `map (chr . (+ shift) . ord) msg`. Давайте спробуємо закодувати декілька повідомлень.

[source,haskell]
----
ghci> encode 3 "Heeeeey"  
"Khhhhh|"  
ghci> encode 4 "Heeeeey"  
"Liiiii}"  
ghci> encode 1 "abcd"  
"bcde"  
ghci> encode 5 "Marry Christmas! Ho ho ho!"  
"Rfww~%Hmwnxyrfx&%Mt%mt%mt&"  
----

Все закодовується гарно. Декодування повідомлення є в основному зсув назад на число позицій, на яке воно було спочатку зсунуте.

[source,haskell]
----
decode :: Int -> String -> String  
decode shift msg = encode (negate shift) msg  
ghci> encode 3 "Im a little teapot"  
"Lp#d#olwwoh#whdsrw"  
ghci> decode 3 "Lp#d#olwwoh#whdsrw"  
"Im a little teapot"  
ghci> decode 5 . encode 5 $ "This is a sentence"  
"This is a sentence"  
----

=== Data.Map

Асоціативні списки (також називаються словниками) є списками, що використовуються для зберігання пар ключ-значення, коли порядок не має значення. Наприклад, ми можемо використовувати асоціативний список для зберігання номерів телефонів, де номери телефонів будуть значеннями, а імена людей будуть ключами. Нам байдуже в якому порядку вони зберігаються, ми просто хочемо отримати правильний номер телефону для певної особи.

Найбільш очевидний шлях представити асоціативні списки в Haskell буде використання списку пар. Перший компонент в парі буде ключем, другий компонент значення. Ось приклад асоціативного списку з номерами телефонів:

[source,haskell]
----
phoneBook =   
    [("betty","555-2938")  
    ,("bonnie","452-2928")  
    ,("patsy","493-2928")  
    ,("lucille","205-2928")  
    ,("wendy","939-8282")  
    ,("penny","853-2492")  
    ]  
----

Не зважаючи на ці досить дивні відступи це все ще пари рядків. Найбільш загальна задача коли маємо справу з асоціативними списками є пошук значення по ключу. Давайте створимо функцію, що шукає деяке значення по ключу.

[source,haskell]
----
findKey :: (Eq k) => k -> [(k,v)] -> v  
findKey key xs = snd . head . filter (\(k,v) -> key == k) $ xs  
----

Досить просто. Функція, що бере ключ та список, фільтрує список так, що залишаються лише співпадаючі ключі, бере першу пару ключ-значення та повертає значення. Але що трапляється, якщо ключ що ми шукаємо відсутній в асоціативному списку? Хмм. В даному випадку якщо ключа немає в списку ми скінчимо беручи `head` від порожнього списку, що закидає помилку часу виконання. Однак нам слідує уникати таких простих катастроф нашої програми, так що використаємо тип даних `Maybe`. Якщо ми не знайшли ключ ми повертаємо `Nothing`. Якщо ми знайшли його, ми повертаємо `Just` дещо, де дещо це значення, що відповідає ключу.

[source,haskell]
----
findKey :: (Eq k) => k -> [(k,v)] -> Maybe v  
findKey key [] = Nothing  
findKey key ((k,v):xs) = if key == k  
                            then Just v  
                            else findKey key xs  
----

Подивіться на декларацію типу. Вона приймає ключ, що може бути порівняний, асоціативний список, і потім, вірогідно, продукує значення. Виглядає правильним.

Це класична рекурсивна функція, що оперує зі списком. Граничний випадок, поділення списку на голову та хвіст, рекурсивні виклики - вони всі тут. Це класичний шаблон `fold`, так що давайте подивимось, як це може бути реалізовано через згортання.

[source,haskell]
----
findKey :: (Eq k) => k -> [(k,v)] -> Maybe v  
findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing  
----

Note: Зазвичай краще використовувати згортки для цього стандартного шаблону рекурсії по списку, замість явного написання рекурсії, бо це краще читати та розпізнавати. Всі знають що це згортання, коли вони бачать виклик `foldr`, але читання явної рекурсії займає деякий час.

[source,haskell]
----
ghci> findKey "penny" phoneBook  
Just "853-2492"  
ghci> findKey "betty" phoneBook  
Just "555-2938"  
ghci> findKey "wilma" phoneBook  
Nothing  
----
  
image:images/legomap.png[]
Робить чудово! Якщо ми маємо номер телефону дівчини, ми `Just` отримуємо номер, інакше ми отримуємо `Nothing`.

Ми тільки що реалізували функцію пошуку з `Data.List`. Якщо ми бажаємо знайти відповідне до ключа значення, ми маємо пройти всі елементи списка, доки ми не знайдемо його. Модуль `Data.Map` пропонує асоціативні списки, що значно швидші (оскільки вони внутрішньо реалізовані як дерева), і також вона провадить багато допоміжних функцій. Відтепер ми будемо казати, що ми робимо з мапами замість асоціативних списків.

Оскільки `Data.Map` експортує функції, що перетинаються з такими з `Prelude` та `Data.List`, ми будемо робити кваліфікований імпорт.

[source,haskell]
----
import qualified Data.Map as Map  
----

Покладемо це твердження в скрипт, та потім завантажимо скрипт через  `GHCI`.

Давайте пійдемо далі, та побачимо, що має для нас `Data.Map`! Ось базовий огляд його функцій.

Функція `fromList` бере асоціативний список (в формі списка) і повертає мапу з тими самими асоціаціями.

[source,haskell]
----
ghci> Map.fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]  
fromList [("betty","555-2938"),("bonnie","452-2928"),("lucille","205-2928")]  
ghci> Map.fromList [(1,2),(3,4),(3,2),(5,5)]  
fromList [(1,2),(3,2),(5,5)]  
----

Якщо в оригінальному асоціативному списку є дублікати ключів, дублікати просто відкидаються. Ось сигнатура типу для `fromList`

[source,haskell]
----
Map.fromList :: (Ord k) => [(k, v)] -> Map.Map k v  
----

Вона каже, що береться список пар типів `k` та `v`, та повертається мапа, що відображує тип `k` на тип `v`. Зауважте, що коли ми робимо асоціативні списки з нормальними списками, ключі тільки мають проходити порівняння на рівність (їх тип належить до типокласу `Eq`), але тепер вони мають впорядковуватись. Це основний контраст в модулі `Data.Map`. Він вимагає щоб ключі впорядковувались, і тоді він зможе вистроїти їх в дерево.

Вам слідує завжди використовувати `Data.Map` для асоціацій ключ-значення, тільки якщо ви не маєте ключів, що не є частиною типокласу `Ord`.

`empty` представляє порожню мапу. Вона не приймає аргументів, вона просто повертає порожню мапу.

[source,haskell]
----
ghci> Map.empty  
fromList []  
----

`insert` бере ключ, значення та мапу, і повертає нову мапу, що така сама, тільки з доданим ключем та значенням.

[source,haskell]
----
ghci> Map.empty  
fromList []  
ghci> Map.insert 3 100 Map.empty  
fromList [(3,100)]  
ghci> Map.insert 5 600 (Map.insert 4 200 ( Map.insert 3 100  Map.empty))  
fromList [(3,100),(4,200),(5,600)]  
ghci> Map.insert 5 600 . Map.insert 4 200 . Map.insert 3 100 $ Map.empty  
fromList [(3,100),(4,200),(5,600)]  
----

Ми можемо реалізувати наш власний `fromList` через використання порожньої мапи, `insert` та `fold`. Дивіться:

[source,haskell]
----
fromList' :: (Ord k) => [(k,v)] -> Map.Map k v  
fromList' = foldr (\(k,v) acc -> Map.insert k v acc) Map.empty  
----

Це досить прямолінійне згортання. Ми починаємо з порожньої мапи, і ми згортаємо її зправа, включаючи пари ключ значення в акумулятор по мірі проходження.

`null` перевіряє, чи мапа є порожня.

[source,haskell]
----
ghci> Map.null Map.empty  
True  
ghci> Map.null $ Map.fromList [(2,3),(5,5)]  
False  
----

`size` повідомляє про розмір мапи.

[source,haskell]
----
ghci> Map.size Map.empty  
0  
ghci> Map.size $ Map.fromList [(2,4),(3,3),(4,2),(5,4),(6,4)]  
5  
----

`singleton` бере ключ та значення, та створює мапу, що має одне відображення.

[source,haskell]
----
ghci> Map.singleton 3 9  
fromList [(3,9)]  
ghci> Map.insert 5 9 $ Map.singleton 3 9  
fromList [(3,9),(5,9)]  
----

`lookup` робить як `Data.List` `lookup`, тільки він оперує з мапами. Він повертає `Just` дещо, якщо він знаходить дещо для ключі, і `Nothing` якщо ні.

`member` є предикатом, що приймає ключ і мапу, та повідомляє, чи ключ в мапі або ні.

[source,haskell]
----
ghci> Map.member 3 $ Map.fromList [(3,6),(4,3),(6,9)]  
True  
ghci> Map.member 3 $ Map.fromList [(2,5),(4,5)]  
False  
----

`map` та `filter` роблять як їх еквіваленти для списків.

[source,haskell]
----
ghci> Map.map (*100) $ Map.fromList [(1,1),(2,4),(3,9)]  
fromList [(1,100),(2,400),(3,900)]  
ghci> Map.filter isUpper $ Map.fromList [(1,'a'),(2,'A'),(3,'b'),(4,'B')]  
fromList [(2,'A'),(4,'B')]  
----

`toList` є зворотнім до `fromList`.

[source,haskell]
----
ghci> Map.toList . Map.insert 9 2 $ Map.singleton 4 3  
[(4,3),(9,2)]  
----

`keys` та `elems` повертають списки ключів та значень відповідно. `keys` є еквівалентом до `map fst . Map.toList` та `elems` є еквівалентом до `map snd . Map.toList`.

`fromListWith` є милою маленькою функцією. Вона діє як `fromList`, тільки вона не відкидає дублікати ключів, але використовує надану функцію для вирішення, що з ними робити. Скажімо, дівчина має декілька номерів, і ми маємо асоціативний список приблизно такого вигляду.

[source,haskell]
----
phoneBook =   
    [("betty","555-2938")  
    ,("betty","342-2492")  
    ,("bonnie","452-2928")  
    ,("patsy","493-2928")  
    ,("patsy","943-2929")  
    ,("patsy","827-9162")  
    ,("lucille","205-2928")  
    ,("wendy","939-8282")  
    ,("penny","853-2492")  
    ,("penny","555-2111")  
    ]  
----

Тепер, якщо ми просто використовуємо `fromList` щоб перенести це в мапу, ми втратимо декілька номерів! Так що ось як ми будемо робити:

[source,haskell]
----
phoneBookToMap :: (Ord k) => [(k, String)] -> Map.Map k String  
phoneBookToMap xs = Map.fromListWith (\number1 number2 -> number1 ++ ", " ++ number2) xs  
ghci> Map.lookup "patsy" $ phoneBookToMap phoneBook  
"827-9162, 943-2929, 493-2928"  
ghci> Map.lookup "wendy" $ phoneBookToMap phoneBook  
"939-8282"  
ghci> Map.lookup "betty" $ phoneBookToMap phoneBook  
"342-2492, 555-2938"  
----

Якщо ми знайдемо дублікований ключ, функція, яку ми передали, буде використана для комбінації ціх значень для ключа в деяке інше значення. Ми можемо також спочатку створити для всіх значень в асоціативному списку списки синглтони, і потім ми можемо використати `++` для комбінації чисел.

[source,haskell]
----
phoneBookToMap :: (Ord k) => [(k, a)] -> Map.Map k [a]  
phoneBookToMap xs = Map.fromListWith (++) $ map (\(k,v) -> (k,[v])) xs  
ghci> Map.lookup "patsy" $ phoneBookToMap phoneBook  
["827-9162","943-2929","493-2928"]  
----

Дуже добре! Інший випадок це коли ми робимо мапу з асоціативного списку чисел, і коли трапляється дублікований ключ, ми бажаємо зберігти більше значення для ключа.

[source,haskell]
----
ghci> Map.fromListWith max [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  
fromList [(2,100),(3,29),(4,22)]  
----

Або ми можемо скласти разом значення по тому самому ключу.

[source,haskell]
----
ghci> Map.fromListWith (+) [(2,3),(2,5),(2,100),(3,29),(3,22),(3,11),(4,22),(4,15)]  
fromList [(2,108),(3,62),(4,37)]  
----

`insertWith` те саме до `insert`, що `fromListWith` до `fromList`. Вона вставляє пару ключ-значення в мапу, але якщо мапа вже містить ключ, вона використовує передану функцію для визначення того, що треба робити.

[source,haskell]
----
ghci> Map.insertWith (+) 3 100 $ Map.fromList [(3,4),(5,103),(6,339)]  
fromList [(3,104),(5,103),(6,339)]  
----

Це було лише декілька функцій з `Data.Map`. Повний список функцій ви можете побачити в документації.

=== Data.Set

image:images/legosets.png[]
Модуль `Data.Set` пропонує нам множини. Це як множини в математиці. Множини як скрещені списки з мапами. Всі елементи в множині унікальні. І оскільки вони внутрішньо реалізовані за допомогою дерев (як мапи в `Data.Map`), вони впорядковані. Перевірка на членство, вставка, видалення, тощо значно швидші, ніж робити ті самі речі зі списками. Найбільш загальні операції при роботі з множинами є вставка в множину, перевірка членства та перетворення множини на список.

Оскільки імена в `Data.Set` перетинаються значною мірою з іменами в  `Prelude` та `Data.List`, ми робимо кваліфікований імпорт.

Покладіть твердження `import` в скрипт:

[source,haskell]
----
import qualified Data.Set as Set  
----

І потім завантажте скрипт через `GHCI`.

Скажімо ми маємо два шматки тексту. Ми бажаємо з'ясувати, які символи використовуються в кожному з них.

[source,haskell]
----
text1 = "I just had an anime dream. Anime... Reality... Are they so different?"  
text2 = "The old man left his garbage can out and now his trash is all over my lawn!"  
----

Функція `fromList` робить майже як ви могли очікувати. Вона бере список та конвертуж його в множину.

[source,haskell]
----
ghci> let set1 = Set.fromList text1  
ghci> let set2 = Set.fromList text2  
ghci> set1  
fromList " .?AIRadefhijlmnorstuy"  
ghci> set2  
fromList " !Tabcdefghilmnorstuvwy"  
----

Як ви можете бачити, елементи впорядковані і кожний елемент унікальний. Тепер давайте використаємо функцію `intersection` щоб побачити, які елементи поділяють обоє.

[source,haskell]
----
ghci> Set.intersection set1 set2  
fromList " adefhilmnorstuy"  
----

Ми можемо використовувати функцію `difference` щоб побачити, які літери в першій множині, але не в другій, і навпаки.

[source,haskell]
----
ghci> Set.difference set1 set2  
fromList ".?AIRj"  
ghci> Set.difference set2 set1  
fromList "!Tbcgvw"  
----

Або ми можемо бачити всі унікальні літери в обох послідовностях з використанням `union`.

[source,haskell]
----
ghci> Set.union set1 set2  
fromList " !.?AIRTabcdefghijlmnorstuvwy"  
----

Функції `null`, `size`, `member`, `empty`, `singleton`, `insert` та `delete` всі роблять як ви могли цього очікувати.

[source,haskell]
----
ghci> Set.null Set.empty  
True  
ghci> Set.null $ Set.fromList [3,4,5,5,4,3]  
False  
ghci> Set.size $ Set.fromList [3,4,5,3,4,5]  
3  
ghci> Set.singleton 9  
fromList [9]  
ghci> Set.insert 4 $ Set.fromList [9,3,8,1]  
fromList [1,3,4,8,9]  
ghci> Set.insert 8 $ Set.fromList [5..10]  
fromList [5,6,7,8,9,10]  
ghci> Set.delete 4 $ Set.fromList [3,4,5,4,3,4,5]  
fromList [3,5]  
----

Ми також можемо перевірити підмножини. Множина `A` є підмножиною `B`, якщо `B` містить всі елементи, що і `A`. Множина `A` є власне підмножиною множини `B`, якщо `B` містить всі елементи, що і `A` ,але також і інші елементи.

[source,haskell]
----
ghci> Set.fromList [2,3,4] `Set.isSubsetOf` Set.fromList [1,2,3,4,5] 
True  
ghci> Set.fromList [1,2,3,4,5] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  
True  
ghci> Set.fromList [1,2,3,4,5] `Set.isProperSubsetOf` Set.fromList [1,2,3,4,5]  
False  
ghci> Set.fromList [2,3,4,8] `Set.isSubsetOf` Set.fromList [1,2,3,4,5]  
False  
----

Ми також можемо відображати множини і фільтрувати їх.

[source,haskell]
----
ghci> Set.filter odd $ Set.fromList [3,4,5,6,7,2,3,4]  
fromList [3,5,7]  
ghci> Set.map (+1) $ Set.fromList [3,4,5,6,7,2,3,4]  
fromList [3,4,5,6,7,8]  
----

Множини часто використовуються для позбавлення списків від дублікатів, спершу перетворивши їх на множину за допомогою `fromList`, та потім перетворивши її на список за допомогою `toList`. Функція `Data.List` `nub` вже робить це, але зачистка дублікатів для великих списків значно швидша, якщо ви перекачаєте його в множину, ніж якщо використаєте `nub`. Але викорастання `nub` вимагає тільки щоб тип елементів списку був частиною типокласу `Eq`, натомість якщо ви бажаєте перевести елементи в множину, тип списку має бути в `Ord`.

[source,haskell]
----
ghci> let setNub xs = Set.toList $ Set.fromList xs  
ghci> setNub "HEY WHATS CRACKALACKIN"  
" ACEHIKLNRSTWY"  
ghci> nub "HEY WHATS CRACKALACKIN"  
"HEY WATSCRKLIN"  
----

`setNub` загалом швидша, ніж `nub` на великих списках, але як ви бачите, `nub` зберігає впорядкування елемнтів списку, тоді як `setNub` ні.

=== Створення власних модулей

image:images/making_modules.png[]
Ми вже подивились на деякі круті модулі, то як нам зробити наш власний модуль? Майже кожна мова програмування дозволяє вам поділити ваш код не декілька файлів, і Haskell не є виключенням. При створенні програм є гарною практикою брати функції і типи, що служать деяким подібним цілям, і покладати їх в модуль. Таким чином ви легко можете використати ці функції в інших програмах, просто імпортувавши ваш модуль.

Давайте подивимось, як ви можете створити ваші власні модулі, створивши невеликий модуль, що провадить деякі функції для обчислення об'єму та площі декількох геометричних об'єктів. Ми почнемо зі створення файла з назвою `Geometry.hs`.

Ми кажемо, що модуль експортує функції. Це означає те, що коли я імпортує модуль, я можу використовувати функції, які він експортує. Він може визначати функції, що його функції використовують внутрішньо, але ми можемо бачити та використовувати лише ті, що експортуються.

На початку модуля ми вказуємо ім'я модуля. Якщо ми маємо файл з назвою `Geometry.hs`, тоді ми маємо назвати наш модуль `Geometry`. Потім ми вказуємо функції, які він експортує, і після цього ми починаємо писати функції. Так що ми почнемо з цього.

[source,haskell]
----
module Geometry  
( sphereVolume  
, sphereArea  
, cubeVolume  
, cubeArea  
, cuboidArea  
, cuboidVolume  
) where  
----

Як ми бачимо, ми робимо площі та об'єми для сфер, кубів та кубоїдів. Ідемо далі і визначаємо функції:

[source,haskell]
----
module Geometry  
( sphereVolume  
, sphereArea  
, cubeVolume  
, cubeArea  
, cuboidArea  
, cuboidVolume  
) where  
  
sphereVolume :: Float -> Float  
sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3)  
  
sphereArea :: Float -> Float  
sphereArea radius = 4 * pi * (radius ^ 2)  
  
cubeVolume :: Float -> Float  
cubeVolume side = cuboidVolume side side side  
  
cubeArea :: Float -> Float  
cubeArea side = cuboidArea side side side  
  
cuboidVolume :: Float -> Float -> Float -> Float  
cuboidVolume a b c = rectangleArea a b * c  
  
cuboidArea :: Float -> Float -> Float -> Float  
cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2  
  
rectangleArea :: Float -> Float -> Float  
rectangleArea a b = a * b  
----

Тут досить стандартна геометрія. Деякі речі мають прийти на думку. Оскільки куб лише особливий випадок кубоїду, ми визначили його площу та об'єм через трактування його як кубоїда, в якого всі сторони рівної довжини. Ми також визначили допоміжну функцію з назвою `rectangleArea`, що обчислює площу прямокутника на основі довжини сторін. Вона скоріше тривіальна, бо це лише множення. Зауважте, що ми використали її в наших функціях в модулі (а саме `cuboidArea` та `cuboidVolume`), але ми не експортували її! Оскільки ми лише бажаємо, щоб наш модуль представляв лише функції, що мають справу з тривимірними об'єктами, ми використали `rectangleArea`, але ми не експортували її.

При створенні модуля ми зазвичай експортуємо тільки ті функції, що діють як різновид інтерфейсу до нашого модуля, так що сама релалізація прохована. Якщо дехто використовує наш модуль `Geometry`, вони не мають обтяжувати себе функціями, які ми не експортуємо. Ми можемо вирішити змінити ці функції повністю, або видалити їх в новій версії (ми можемо видалити `rectangleArea` та замість поставити лише `*`), і ніхто не перейматиметься, бо ми для початку не експортували їх.

Щоб використати наш модуль ми просто робимо:

[source,haskell]
----
import Geometry  
----

`Geometry.hs` повинен бути в тій же папці, що і програма, до якої ми його імпортуємо.

Модулі також можуть бути взяті як ієрархічні структури. Кожний модуль може мати декілька субмодулів, і ті також можуть мати власні субмодулі. Давайте поділимо ці функції, так що `Geometry` буде модулем, що має три субмодулі, по одному для кожного типу об'єктів.

Спочатку створимо папку з назвою `Geometry`. Подумайте про велику  `G`. В цій папці розташуємо три файли: `Sphere.hs`, `Cuboid.hs`, та `Cube.hs`. Ось що будуть містити файли:

`Sphere.hs`

[source,haskell]
----
module Geometry.Sphere  
( volume  
, area  
) where  
  
volume :: Float -> Float  
volume radius = (4.0 / 3.0) * pi * (radius ^ 3)  
  
area :: Float -> Float  
area radius = 4 * pi * (radius ^ 2)  
----

`Cuboid.hs`

[source,haskell]
----
module Geometry.Cuboid  
( volume  
, area  
) where  
  
volume :: Float -> Float -> Float -> Float  
volume a b c = rectangleArea a b * c  
  
area :: Float -> Float -> Float -> Float  
area a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2  
  
rectangleArea :: Float -> Float -> Float  
rectangleArea a b = a * b  
----

`Cube.hs`

[source,haskell]
----
module Geometry.Cube  
( volume  
, area  
) where  
  
import qualified Geometry.Cuboid as Cuboid  
  
volume :: Float -> Float  
volume side = Cuboid.volume side side side  
  
area :: Float -> Float  
area side = Cuboid.area side side side  
----

Гаразд! Перше `Geometry.Sphere`. Зауважте, як ми поклали його в папку з назвою `Geometry`, та потім визначили модуль на ім'я `Geometry.Sphere`. Ми зробили те саме для кубоїда. Також зауважте, як в усіх трьох субмодулях ми визначили функції з тими самими назвами. Ми можемо зробити це, оскільки вони в окремих модулях. Ми бажаємо використати функції з `Geometry.Cuboid` в `Geometry.Cube`, але ми не можемо напряму зробити імпорт `Geometry.Cuboid`, оскільки він експортує функції з тими самими іменами, що і `Geometry.Cube`. Ось чому ми зробили кваліфікований імпорт, і все гаразд.

Так що коли ми в файлі на тому самому рівні, що і папка `Geometry`, ми можемо зробити, скажімо, таке:

[source,haskell]
----
import Geometry.Sphere  
----

І потім ми можемо викликати `area` та `volume`, і вони даватимуть нам площу та об'єм сфери. Але якщо ми бажаємо жанглювати двома або більше з ціх модулів, ми маємо робити кваліфікований імпорт, оскільки вони експортують функції з тіма самими іменами. Так що ми робимо дещо таке:

[source,haskell]
----
import qualified Geometry.Sphere as Sphere  
import qualified Geometry.Cuboid as Cuboid  
import qualified Geometry.Cube as Cube  
----

І потім ми можемо викликати `Sphere.area`, `Sphere.volume`, `Cuboid.area`, тощо, і кожний буде обчислювати площу та об'єм для свого відповідного об'єкту.

Наступного разу, коли ви будете писати файл, що дійсно великий, та має безліч функцій, спробуйте визначити, які функції служать якімось загальним цілям, і потім розгляньте, як покласти ці функції у свій власний модуль. Ви будете в змозі просто імпортувати ваш власний модуль наступного разу, коли ви писатимите програму, що потребує тої самої функціональності.