include::header.adoc[]

== Функції вищих порядків

image:images/sun.png[]
Функції Haskell можуть приймати функції як параметри, та повертати функції як значення повернення. Функція, що робить щось з цього, називається функцією вищого порядку. Функції вищого порядку є не тільки частиною досвіду Haskell, вони в великій мірі є сам досвід Haskell. З'ясовується, що якщо ви бажаєте визначити обчислення, визначаючи що це таке, замість визначати кроки, що змінюють деякий стан та можливо роблячи цикли, функції вищих порядків незамінні. Вони дійсно є потужним способом вирішення проблем і думати про программи.

== Каровані функції

Кожна функція в Haskell офіційно приймає тільки один параметр. Так як це можливо, що ми визначили декілька функцій, що приймають більше ніж один параметр? Гаразд, це дотепний трюк! Всі функції, що приймають декілька параметрів, були карованими функціями. Що це означає? Ви краще зрозумієте це на прикладі. Давайте візьмемо нашого гарного друга, функцію `max`. Виглядає, що вона приймає два параметри, та повертає той, що більше. Виконання `max 4 5` спочатку створює функцію, що приймає параметр, і повертає або `4`, або цей параметр, в залежності що більше. Потім 5 застосовується до цієї функції, і ця функція продукує наш бажаний результат. Це виглядає як балачка, але насправді це крута концепція. Наступні два виклики еквівалентні:

[source,scala]
----
ghci> max 4 5  
5  
ghci> (max 4) 5  
5  
----

image:images/curry.png[] 
Покладання проміжка між двома речами є просто застосування функції. Проміжок є різновидом оператора, і він має найвищий преоритет. Давайте перевіримо тип `max`. Це `max :: (Ord a) => a -> a -> a`. Він може бути записаний як `max :: (Ord a) => a -> (a -> a)`. Це може бути прочитане так: `max` бере `a`, та повертає (це ->) функцію, що бере `a` та повертає `a`. Ось чому тип повернення та параметри функцій просто розділені стрілками.

То як це вигідно для нас? Кажучи просто, якщо ми викликаємо функцію з недостатньою кількістю параметрів, ми отримаємо назад частково застосовану функцію, що приймає стільки параметрів, скльки ми залишили. Використання часткового застосування (виклик функцій з недостатньою кількістю параметрів, якщо бажаєте), є милий спосіб створювати функції на льоту, так що ми можемо передавати їх до інших функцій, або наповнювати їх деякими даними.

Погляньте на цю образливо просту функцію:

[source,scala]
----
multThree :: (Num a) => a -> a -> a -> a  
multThree x y z = x * y * z  
----

Що насправді відбувається, коли ми робимо `multThree 3 5 9` або `((multThree 3) 5) 9`? Спочатку `3` застосовується до `multThree`, оскільки вони розділені проміжком. Це створює функцію, що приймає один параметр, та повертає функцію. Так що `5` застосовується до цього, це створює функцію, що буде брати параметр, та множити його на `15`. `9` застосовується до цієї функції, та результат буде `135`, або десь так. Пам'ятайте, що цей тип функції може бути переписаний як `multThree :: (Num a) => a -> (a -> (a -> a))`. Річ перед `->` є параметр, що приймає функція, і річ, що йде після цього є те, що вона повертає. Так що наша функція приймає `a`, та повертає функцію типу `(Num a) => a -> (a -> a)`. Подібно до цього, ця функція бере `a`, та повертає функцію типу `(Num a) => a -> a`. І ця функція, нарешті, просто бере `a` і повертає `a`. Погляньте на це:

[source,scala]
----
ghci> let multTwoWithNine = multThree 9  
ghci> multTwoWithNine 2 3  
54  
ghci> let multWithEighteen = multTwoWithNine 2  
ghci> multWithEighteen 10  
180  
----

Викликаючи функції з недостатніми параметрами, так би мовити, ми створюємо функції на льоту. Що, якщо ми бажаємо створити функцію, що приймає число, та порівнюєте його зі `100`? Ми можемо зробити щось подібне до наступного:

[source,scala]
----
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred x = compare 100 x  
----

Якщо ми викличемо її з `99`, вона поверне `GT`. Прості речі. Зауважте, що `x` зправа по обі сторони від рівності. Тепер давайте подумаємо щодо того, що повертає `compare 100`. Воно повертає функцію, що бере число, та порівнює його з `100`. Вау! Чи це не функція, яку ми бажали? Ми можемо переписати це так:

[source,scala]
----
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred = compare 100  
----

Декларація типу каже те саме, оскільки `compare 100` повертає функцію. `Compare` має тип `(Ord a) => a -> (a -> Ordering)`, та виклик її з `100` повертає `(Num a, Ord a) => a -> Ordering`. Додаткове обмеження класу присутнє, оскільки `100` також є частиною типокласу `Num`.

Йо! Переконайтесь, що ви справді розумієте, як роблять каровані функції та робить часткове застосування, бо воні справді важливі!

Інфіксні функції також можуть бути частково застосовані з використанням секцій. Для секції інфіксної функції просто оточите її дужками, і надайте параметр тільки з однієї сторони. Це створить функцію, що приймає один параметр, та потім застосовує його до сторони, де відсутній операнд. Образливо тривіальна функція:

[source,scala]
----
divideByTen :: (Floating a) => a -> a  
divideByTen = (/10)  
----

Виклик, скажімо, `divideByTen 200` еквівалентне до `200 / 10`, так само, як зробити `(/10) 200`. Функція, що перевіряє, що наданий символ є великою літерою:

[source,scala]
----
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  
----

Єдина особлива річ щодо секцій є використання `-`. З визначення секцій `(-4)` має давати результат в вигляді функції, що приймає число, та віднімає `4` з нього. Однак для зручності `(-4)` означає мінус чотири. Так що якщо ви бажаєте створити функцію, що віднімає `4` від часла як параметра, частково застосуйте функцію `subtract` таким чином: `(subtract 4)`.

Що трапиться, якщо ми спробуємо просто зробити `multThree 3 4` в GHCI, замість прикріплення її до імені за допомогою `let`, або передачі її до іншої функції?

[source,scala]
----
ghci> multThree 3 4  
<interactive>:1:0:  
    No instance for (Show (t -> t))  
      arising from a use of `print' at <interactive>:1:0-12  
    Possible fix: add an instance declaration for (Show (t -> t))  
    In the expression: print it  
    In a 'do' expression: print it  
----

GHCI каже нам, що вираз спродукував функцію типу `a -> a`, але воно не знає, як друкувати її на екрані. Функції не є членами типокласу  `Show`, так що ви не можете отримати милого рядкового представлення функції. Коли ми робимо, скажімо, `1 + 1` в підказці GHCI, воно спочатку ообчислює `2`, та потім викликає `show` на `2` для отримання текстуального представлення числа. І текстуальна репрезентація `2` є просто рядок `"2"`, що друкується на екрані.

=== Деякий високо-порядкізм по порядку

Функції можуть приймати функції як параметри і також повертають функції. Щоб проілюстровати це, ми збираємось створити функцію, що приймає функцію, та потім застосовує її двічі до будь-чого!

[source,scala]
----
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
----

image:images/bonus.png[]
Для початку зауважте декларацію типу. Перед цім ми не потребували дужок, оскільки `->` є право асоціативним. Але тут воно обов'язкове. Це каже, що перший параметр є функція, що приймає дещо, та повертає ту саму річ. Другий параметр є дещо, і цього ж типу також значення повернення. Ми можемо читати цю декларацію типу, але щоб не заморочуватись ми просто скажемо, що ця функція приймає два параметри, та повертає одну річ. Перший параметр є функція (типу `a -> a`) та другий те саме `a`. Функція також може бути `Int -> Int` або `String -> String`, або будь-що. Але потім другий параметр має також бути того самого типу.

Note: Відтепер ми будемо казати, що функції приймають декілька параметрів, незважаючи на те, що кожна функція насправді бере тільки один параметр, та повертає частково застосовані функції, доки ми не досягнемо функцію, що повертає справжнє значення. Так що для спрощення ми кажемо, що `a -> a -> a` бере два параметри, навіть маючи на увазі, що це відбувається за лаштунками.

Тіло функції досить просте. Ми просто використовуємо параметр `f` як функцію, застосовуючи `x` до неї, розділяючи їх проміжками, і потім застосовуючи результат знову до `f`. В любому випадку пограємось з функцією:

[source,scala]
----
ghci> applyTwice (+3) 10  
16  
ghci> applyTwice (++ " HAHA") "HEY"  
"HEY HAHA HAHA"  
ghci> applyTwice ("HAHA " ++) "HEY"  
"HAHA HAHA HEY"  
ghci> applyTwice (multThree 2 2) 9  
144  
ghci> applyTwice (3:) [1]  
[3,3,1]  
----

Дивовижність та корисність часткових функцій є очевидною. Якщо наша функція потребує передати їй функцію, що приймає тільки один параметр, ви можете тільки частково застосувати функцію до тієї точки, коли вона прийматиме тільки один параметр, та потім передати її.

Тепер ми збираємось використати програмування вищого порядку для реалізації насправді корисної функції, що є в стандартній бібліотеці. Вона називається `zipWith`. Вона бере функцію та два списки як параметри, та потім поєднує два списки, застосовуючи функцію між відповідними елементами. Ось як ми реалізуємо її:

[source,scala]
----
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys  
----

Подивимось на декларацію типу. Перший параметр є функція, що бере дві речі і повертає третю річ. Вони не мають бути того самого типу, але вони можуть. Другий та третій параметр є списками. Результат також список. Перший має бути списком з `a`, оскікльки функція поєднання бере `a` як перший аргумент. Другий має бути списком `b`, тому що другий параметр функції поєднання має тип `b`. Результатом є список `c`. Якщо декларація типу функції каже, що вона сприймає функцію `a -> b -> c` як параметр, вона також сприйматиме функцію `a -> a -> a`, але не навпаки! Пам'ятайте, що коли в створюєте функції, особливо вищого порядку, і ви не впевнені щодо типу, ви можете просто оминути декларацію типу, та потім перевірити, що Haskell виводить щодо типу через `:t`.

Дія в функції досить подібна до звичайного `zip`. Граничні умови ті самі, тільки є додатковий аргумент, функція поєднання, але цей аргумент не має значення в граничних умовах, так що ми використовуємо `_` щодо цього. Та тіло функції останнього шаблону подібне до `zip`, але він не робить `(x,y)`, але `f x y`. Єдина функція вищого порядку може бути використана для безлічі різних завдань, якщо вона досить загальна. Ось маленька демонстрація всьго різноманіття речей, що може робити наша функція `zipWith'`:

[source,scala]
----
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci> zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
ghci> zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]  
----

Як ви можете бачити, єдина функція вищого порядку може бути використана в дуже різноманітний спосіб. Імперативне програмування зазвичай використовує речі як `for` цикли, `while` цикли, присвоєння чогось до змінної, перевірка її стану, тощо, щоб досягти певної поведінки та потім огорнути її в інтерфейс, такий як функція. Функціональне програмування використовує функції вищого порядку щоб абстрагувати загальні шаблони, як попарно екзаменувати два списки, та потім робити щось з ціма парами, або отримати набір рішень, та відкинути ті, що нам не потрібні.

Давайте реалізуємо іншу функцію, що вже є стандартній бібліотеці, що називається `flip`. `Flip` просто бере функцію, та повертає функцію, що подібна до нашої оригінальної функції, тільки два перших аргументи обміняні місцями. Ми можемо реалізувати її таким чином:

[source,scala]
----
flip' :: (a -> b -> c) -> (b -> a -> c)  
flip' f = g  
    where g x y = f y x  
----

Читаючи декларацію типу ми кажемо, що вона бере функцію, що приймає `a` та `b`, та повертає функцію, що приймає `b` та `a`. Але оскільки функції каровані по замовчанню, друга пара дужок не є насправді потрібною, бо `->` є право асоціативним по замовчанню. `(a -> b -> c) -> (b -> a -> c)` є те саме, що і `(a -> b -> c) -> (b -> (a -> c))`, що те саме, що і `(a -> b -> c) -> b -> a -> c`. Ми записуємо, що `g x y = f y x`. Якщо це так, тоді `f y x = g x y` має також дотримуватись, вірно? Маючи це на увазі, ми можемо визначити цю функцію навіть в ще простіший спосіб.

[source,scala]
----
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f y x = f x y  
----

Тут ми отримуємо вигоду від факту, що функція карована. Коли ми в икликаємо `flip' f` без параметров `y` та `x`, вона буде повертати `f`, що бере ці два параметри, але переставляє їх місцями. Навіть не зважаючи на те, що функції з перестановкою звичайно передаються в інші функції, ви можете отримати перевагу від карування, та потім створювати функції вищих порядків, при цьому розмірковуючи наперед, та написання їх таким чином, щоб остаточний результат був би такий, якби вони були повністю застосовані.

[source,scala]
----
ghci> flip' zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]  
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]  
[5,4,3,2,1]  
----

=== Мапи та фільтри

`map` приймає функцію та список, та застосовує цю функцію до кожного елементу, продукуючи новий список. Давайте подивимось, яка в неї сигнатура типу, та як вона визначена.

[source,scala]
----
map :: (a -> b) -> [a] -> [b]  
map _ [] = []  
map f (x:xs) = f x : map f xs  
----

Сигнатура типу каже, що вона приймає функцію, що приймає `a` та повертає `b`, список `a` перетворюється на список `b`. Цікаво, що просто дивлячись на сигнатуру типу функції, ви можете інколи сказати, що вона робить. `map` одна з ціх дійсно універсальних функцій вищого порядку, що може використовуватись в мільйони різних способів. Ось вона в дії:

[source,scala]
----
ghci> map (+3) [1,5,3,1,6]  
[4,8,6,4,9]  
ghci> map (++ "!") ["BIFF", "BANG", "POW"]  
["BIFF!","BANG!","POW!"]  
ghci> map (replicate 3) [3..6]  
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  
[[1,4],[9,16,25,36],[49,64]]  
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[1,3,6,2,2]  
----

Ви, можливо, зауважили, що все це можна досягти осяжністю списків. `map (+3) [1,5,3,1,6]` те саме, що написати `[x+3 | x <- [1,5,3,1,6]]`. Однак використання `map` значно краще читається для випадків, коли ви лише застосовуєте функцію до елементів списку, особливо коли ви маєте справу з мапою мап, і тоді ціла річ з багатьма дужками може стати заплутаною.

`filter` є функцією, що приймає предикат (предикат є функція, що каже, чи дещо вірно або ні, так що в нашому випадку повертає логічне значення), та список, та потім повертає список елементів, що задовільняє предикату. Сигнатура типу та реалізація виглядають так:

[source,scala]
----
filter :: (a -> Bool) -> [a] -> [a]  
filter _ [] = []  
filter p (x:xs)   
    | p x       = x : filter p xs  
    | otherwise = filter p xs  
----

Доволі проста річ. Якщо `p x` обчислюється до `True`, елемент буде включений в новий список. Якщо ні, елемент відкидається. Деякі приклади використання:

[source,scala]
----
ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]  
[5,6,4]  
ghci> filter (==3) [1,2,3,4,5]  
[3]  
ghci> filter even [1..10]  
[2,4,6,8,10]  
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
[[1,2,3],[3,4,5],[2,2]]  
ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"  
"uagameasadifeent"  
ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
"GAYBALLS"  
----

Все це можна досягти за допомогою осяжності списків через використання предикатів. Немає встановленого правила для використання `map` та `filter`, проти використання осяжності списків, вам треба просто визначити, що читається краще в залежності від коду та контексту. `filter` еквівалентно до застосування декількох предикатів в осяжності списків, або фільтруючи дещо декілька раз, або поєднуючи предикати логічною функцією `&&`.

Пам'ятаєте нашу функцію `quicksort` з минулої глави? Ми використовували осяжність списків для фільтрування елементів списку, що меньші (або рівні), та більше ніж переломна точка. Ми можемо досягти такої самої функціональності в більш читаємий спосіб, за допомогою `filter`:

[source,scala]
----
quicksort :: (Ord a) => [a] -> [a]    
quicksort [] = []    
quicksort (x:xs) =     
    let smallerSorted = quicksort (filter (<=x) xs)  
        biggerSorted = quicksort (filter (>x) xs)   
    in  smallerSorted ++ [x] ++ biggerSorted  
----

image:images/map.png[]
Відображення та фільтрація є хліб та масло серед інструментів кожного функціонального програміста. Так. Не має значення, чи ви робите це за допомогою функцій `map` та `filter`, або осяжністю списків. Згадайте, як ми вірішували проблема пошуку правильних трикутників в певному колі. В імперативному програмуванні ми можемо вирішити це через вкладання трьох циклів, та потім перевіряючи, чи поточна комбінація задовільняю умовам трикутника, що має заданий периметр. Якщо це так, ми можемо роздрукувати це не екрані, або зробити щось інше. В функціональному програмуванні цей шаблон досягається через відображення та фільтрацію. Ви створюєте функцію, що приймає значення та продукує деякий результат. Ми відображуємо цю функцію на списку значень, та потім ми фільтруємо результуючий список щодо результатів, які задовільняють умовам пошуку. Дякуючи лінивості Haskell, навіть якщо ви робите `map` по списку декілька разів і фільтруєте його декілька раз, він пройде по списку один раз.

Давайте знайдемо найбільше число до `100,000` що ділиться на `3829`. Щоб зробити це, ми просто відфільтруємо набір можливостей, де за нашими підрахунками знаходяться наші рішення.

[source,scala]
----
largestDivisible :: (Integral a) => a  
largestDivisible = head (filter p [100000,99999..])  
    where p x = x `mod` 3829 == 0  
----

Спочатку створимо список всіх чисел, меньших `100,000` від великих до малих. Потім ми фільтруємо його по нашому предикату, і оскільки числа ідуть від великих, найбільше число за нашою умовою буде першим в списку результатів. Нам навіть не треба використовувати скінчений список для початку нашої множини. Це знову лінивість в дії. Оскільки ми закінчуємо використанням голови відфільтрованого списку, не має значення, чи ми фільтруємо скінчений список, або безкінечний. Обчислення зупиняється, коли буде знайдене перше адекватне рішення.

Далі ми збираємось знайти суму всіх непарних квадратів, що меньше `10,000`. Але спочатку, оскільки ми використовуємо її в нашому рішенню, ми збираємось ввести функцію `takeWhile`. Вона приймає предикат і список, і потім проходить від початку списку, та повертає елемнти, доки предикат повертає істину. Як тільки знайдений елемент, для якого умова не виконується, все завершується. Якщо ви бажаєте отримати перше слово на початку рядка `"elephants know how to party"`, ми можемо зробити `takeWhile (/=' ') "elephants know how to party"`, що поверне `"elephants"`. Гаразд. Сума всіх непарних квадратів, що меньша `10,000`. Перше, ми почнемо з відображення функції `(^2)` на безкінечний список `[1..]`. Потім ми фільтруємо їх, щоб отримати лише непарні. І потім ми беремо елементи з цього списку, доки вони меньші ніж `10,000`. Нарешті ми отримуємо суму цього списку. Нам навіть немає потреби визначати для цього функцію, ми можемо зробити це в один рядок в GHCI:

[source,scala]
----
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
166650  
----

Блискуче! Ми почали з деяких початкових даних (нескінчений список з усіх натуральних чисел), та потім ми робимо `map` по них, `filter` по ньому, та відсікаємо їх, доки він задовільняє нашим потребам, та потім підсумовуємо докупи. Ми можемо також переписати це, використовуючи осяжності списків:

[source,scala]
----
ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])  
166650  
----

Те, що ми обираємо, є лише справою смаку. І знову, властивість лінівості Haskell є те, що робить це можливим. Ми можемо робити відображення та фільтрувати по безкінечному списку, оскільки це насправді безпосередньо не робитиме `map` та `filter`, ці дії буде відкладено. Тільки коли ми змусимо Haskell показати нам суму буде викликана `sum`, що зробить `takeWhile` для отримання ціх чисел. `takeWhile` змушує виконання фільтрування та відображення, але тільки до тих пір, доки не трапиться число більше або рівне до `10,000`.

Для нашої наступної проблеми ми будемо мати справу з послідовностями `Collatz`. Ми беремо натуральне число. Якщо число парне, ми ділимо його на два. Якщо воно непарне, ми множимо його на `3`, і потім додаємо `1`. Ми беремо результуюче число, та застосовуємо до нього ту саму річ, що продукує нове число, і так далі. В основі ми отримуємо ланцюжок чисел. Є думка, що для всіх початкових чисел ланцюжки закінчуються числом `1`. Так що якщо ми візьмемо початкове число `13`,ми отримаємо таку послідовність: `13`, `40`, `20`, `10`, `5`, `16`, `8`, `4`, `2`, `1`. `13*3 + 1` дорівнює `40`. `40` поділене на `2` є `20`, тощо. Ми бачимо, що ланцюжок має `10` термів.

Те, що ми бажаємо знати, є наступним: для всіх початкових чисел між  `1` та `100`, як багато ланцюжків мають довжину, більшу ніж `15`? Спочатку ми напишемо функцію, що продукує ланцюжок:

[source,scala]
----
chain :: (Integral a) => a -> [a]  
chain 1 = [1]  
chain n  
    | even n =  n:chain (n `div` 2)  
    | odd n  =  n:chain (n*3 + 1)  
----

Оскільки ланцюжки закінчуються на `1`, це буде граничний випадок. Це досить стандартна рекурсивна функція.

[source,scala]
----
ghci> chain 10  
[10,5,16,8,4,2,1]  
ghci> chain 1  
[1]  
ghci> chain 30  
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]  
----

Вау! Здається це робить коректно. І тепер функцію, що дає відповідь на наше запитання:

[source,scala]
----
numLongChains :: Int  
numLongChains = length (filter isLong (map chain [1..100]))  
    where isLong xs = length xs > 15  
----

Ми відображуємо функцію `chain` до `[1..100]`, щоб отримати список ланцюжків, що самі представлені як списки. Потім ми фільтруємо їх предикатом, що тільки перевіряє, чи довжина більше ніж `15`. Як тільки ви виконали фільтрацію, ми бачимо, скільки ланцюжків залишилось в результуючому списку.

Note: Ця функція має тип `numLongChains :: Int`, оскільки `length` повертає `Int` замість `Num` з історичних причин. Якщо ви бажаєте повертати більш загальне `Num`, ми можемо використати `fromIntegral` на результуючій довжині.

Використовуючи `map`, ми також можемо робити речі, як `map (*) [0..]`, якщо і не з іншої причини, ніж проілюструвати, як робить карування, та як (частково застосовані) функції є реальними значеннями, які ви можете передати по кругу до інших функцій, або покласти в списки (ви тільки не можете перетворити їх на рядки). Досі ми тільки відображали функції, що бере один параметр зі списку, як `map (*2) [0..]` для отримання списку типу `(Num a) => [a]`, але ми також можемо робити `map (*) [0..]` без проблем. Що трапиться тут, це те, що число в списку застосовується до функції `*`, що має тип `(Num a) => a -> a -> a`. Застосовуючи тільки один параметр до функції, що приймає два параметра, повертає функцію, що приймає один параметр . Якщо `*` по списку `[0..]`, ми отримаємо список функцій, що приймають тільки один параметр, так що `(Num a) => [a -> a]`. `map (*) [0..]` продукує список, як такий, що ми отримаємо, написавши `[(0*),(1*),(2*),(3*),(4*),(5*)...`

[source,scala]
----
ghci> let listOfFuns = map (*) [0..]  
ghci> (listOfFuns !! 4) 5  
20  
----

Отримавши елемент з індексом `4` з нашого списку повертаємо функцію, що еквівалентна до `(4*)`. Та потім ми просто застосовуємо 5 до цієї функції. Так що це як написати `(4*) 5`, або просто `4 * 5`.

=== Лямбди

image:images/lambda.png[]
Лямбда в основному анонімні функції, що використовуються, оскільки нам треба деякі функції тільки один раз. Звичайно ми створюємо лямбду з єдиним призначенням передати її в функцію вищого порядку. Щоб створити лямбду ми пишемо `\` (оскільки це виглядає дещо подібно на грецьку літеру лямбда, якщо придивитись досить сильно), та потім ми пишемо параметри, розділені проміжками. Після цього іде `->`, та потім тіло функції. Ми звичайно оточуємо їх в дужки, оскільки інакше вони розширюються весь час вправо.

Якщо ви подивитесь на 5 дюймів вище, ви побачите, що ми використовували `where` прикріплення в нашій функції `numLongChains` для створення функції `isLong` для єдиного призначення передати її в фільтр. Гаразд, замість цього ми можемо використати лямбду:

[source,scala]
----
numLongChains :: Int  
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))  
----

Лямбди є виразами, і ось чому ми тільки можемо передати їх таким чином. Вираз `(\xs -> length xs > 15)` повертає функцію, що каже нам, чи довжина списку, переданому до них, більше ніж `15`.

image:images/lamb.png[]
Люди, що не дуже знайомі з тим, як роблять карування та часткове застосування, часто використовують лямбди там, да цього не треба робити. Наприклад, вирази `map (+3) [1,6,3,2]` та `map (\x -> x + 3) [1,6,3,2]` еквівалентні, оскільки обоє, `(+3)` та `(\x -> x + 3)` є функціями, що приймають число, та додають до нього `3`. Не треба казати, що створення лямбди в цьому випадку є марним, оскільки використання часткового застосування значно більше читабельне.

Як нормальні функції, лямбди можуть приймати любе число параметрів:

[source,scala]
----
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  
[153.0,61.5,31.0,15.75,6.6]  
----

Та як це нормальна функція, ви можете робити в лямбді співпадіння шаблонів. Єдина різниця в тому, що ви не можете визначити декілька шаблонів для одного параметру, як зробити `[]` та `(x:xs)` шаблони для одного параметру, та потім мати значення, що провалюються. Якщо співпадіння шаблонів схибиться в лямбді, виникне помилка виконання, так що будьте уважні, коли порівнюєте шаблони в лямбдах!

[source,scala]
----
ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[3,8,9,8,7]  
----

Лямбди зазвичай оточені дужками, якщо тільки ми не хочемо, щоб вони поширювались весь час вправо. Тут є дещо цікаве: через спосіб, як функції каровані по замовчанню, наступні два варіанти еквівівалентні:

[source,scala]
----
addThree :: (Num a) => a -> a -> a -> a  
addThree x y z = x + y + z  
addThree :: (Num a) => a -> a -> a -> a  
addThree = \x -> \y -> \z -> x + y + z  
----

Якщо визначити функцію таким чином, стає зрозумілим, чому її декларація типу така, як вона є. Є три `->` в обох деклараціях типу і рівності. Але, звичайно, перший спосіб запису функції значно більш читабельний, другий є скоріше трюком для демонстрації карування.

Однак є випадки, коли використання цієї нотації є крутим. Я думаю, що функція перестановки `flip` найбільш зрозуміла, коли записана таким чином:

[source,scala]
----
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f = \x y -> f y x  
----

Навіть якщо це те саме, що і написати `flip' f x y = f y x`, ми робимо очевидним, що це буде використане для створення нової функції в більшості випадків. Найбільш загальний випадок використання для `flip` є виклик її з тільки однією функцією-параметром, та потім передати отриману функцію далі до `map` або `filter`. Так що використовуйте лямбди в цей спосіб, коли ви бажаєте зробити явним, що ваша функція здебільшого призначена бути частково So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.

Only folds and horses
folded bird
Back when we were dealing with recursion, we noticed a theme throughout many of the recursive functions that operated on lists. Usually, we'd have an edge case for the empty list. We'd introduce the x:xs pattern and then we'd do some action that involves a single element and the rest of the list. It turns out this is a very common pattern, so a couple of very useful functions were introduced to encapsulate it. These functions are called folds. They're sort of like the map function, only they reduce the list to some single value.

A fold takes a binary function, a starting value (I like to call it the accumulator) and a list to fold up. The binary function itself takes two parameters. The binary function is called with the accumulator and the first (or last) element and produces a new accumulator. Then, the binary function is called again with the new accumulator and the now new first (or last) element, and so on. Once we've walked over the whole list, only the accumulator remains, which is what we've reduced the list to.

First let's take a look at the foldl function, also called the left fold. It folds the list up from the left side. The binary function is applied between the starting value and the head of the list. That produces a new accumulator value and the binary function is called with that value and the next element, etc.

Let's implement sum again, only this time, we'll use a fold instead of explicit recursion.

sum' :: (Num a) => [a] -> a  
sum' xs = foldl (\acc x -> acc + x) 0 xs  
Testing, one two three:

ghci> sum' [3,5,2,1]  
11  
foldl
Let's take an in-depth look into how this fold happens. \acc x -> acc + x is the binary function. 0 is the starting value and xs is the list to be folded up. Now first, 0 is used as the acc parameter to the binary function and 3 is used as the x (or the current element) parameter. 0 + 3 produces a 3 and it becomes the new accumulator value, so to speak. Next up, 3 is used as the accumulator value and 5 as the current element and 8 becomes the new accumulator value. Moving forward, 8 is the accumulator value, 2 is the current element, the new accumulator value is 10. Finally, that 10 is used as the accumulator value and 1 as the current element, producing an 11. Congratulations, you've done a fold!

This professional diagram on the left illustrates how a fold happens, step by step (day by day!). The greenish brown number is the accumulator value. You can see how the list is sort of consumed up from the left side by the accumulator. Om nom nom nom! If we take into account that functions are curried, we can write this implementation ever more succinctly, like so:

sum' :: (Num a) => [a] -> a  
sum' = foldl (+) 0  
The lambda function (\acc x -> acc + x) is the same as (+). We can omit the xs as the parameter because calling foldl (+) 0 will return a function that takes a list. Generally, if you have a function like foo a = bar b a, you can rewrite it as foo = bar b, because of currying.

Anyhoo, let's implement another function with a left fold before moving on to right folds. I'm sure you all know that elem checks whether a value is part of a list so I won't go into that again (whoops, just did!). Let's implement it with a left fold.

elem' :: (Eq a) => a -> [a] -> Bool  
elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys  
Well, well, well, what do we have here? The starting value and accumulator here is a boolean value. The type of the accumulator value and the end result is always the same when dealing with folds. Remember that if you ever don't know what to use as a starting value, it'll give you some idea. We start off with False. It makes sense to use False as a starting value. We assume it isn't there. Also, if we call a fold on an empty list, the result will just be the starting value. Then we check the current element is the element we're looking for. If it is, we set the accumulator to True. If it's not, we just leave the accumulator unchanged. If it was False before, it stays that way because this current element is not it. If it was True, we leave it at that.

The right fold, foldr works in a similar way to the left fold, only the accumulator eats up the values from the right. Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so \acc x -> ...), the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so \x acc -> ...). It kind of makes sense that the right fold has the accumulator on the right, because it folds from the right side.

The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a boolean or even a new list. We'll be implementing the map function with a right fold. The accumulator will be a list, we'll be accumulating the mapped list element by element. From that, it's obvious that the starting element will be an empty list.

map' :: (a -> b) -> [a] -> [b]  
map' f xs = foldr (\x acc -> f x : acc) [] xs  
If we're mapping (+3) to [1,2,3], we approach the list from the right side. We take the last element, which is 3 and apply the function to it, which ends up being 6. Then, we prepend it to the accumulator, which is was []. 6:[] is [6] and that's now the accumulator. We apply (+3) to 2, that's 5 and we prepend (:) it to the accumulator, so the accumulator is now [5,6]. We apply (+3) to 1 and prepend that to the accumulator and so the end value is [4,5,6].

Of course, we could have implemented this function with a left fold too. It would be map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs, but the thing is that the ++ function is much more expensive than :, so we usually use right folds when we're building up new lists from a list.

fold this up!
If you reverse a list, you can do a right fold on it just like you would have done a left fold and vice versa. Sometimes you don't even have to do that. The sum function can be implemented pretty much the same with a left and right fold. One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!

Folds can be used to implement any function where you traverse a list once, element by element, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold. That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.

The foldl1 and foldr1 functions work much like foldl and foldr, only you don't need to provide them with an explicit starting value. They assume the first (or last) element of the list to be the starting value and then start the fold with the element next to it. With that in mind, the sum function can be implemented like so: sum = foldl1 (+). Because they depend on the lists they fold up having at least one element, they cause runtime errors if called with empty lists. foldl and foldr, on the other hand, work fine with empty lists. When making a fold, think about how it acts on an empty list. If the function doesn't make sense when given an empty list, you can probably use a foldl1 or foldr1 to implement it.

Just to show you how powerful folds are, we're going to implement a bunch of standard library functions by using folds:

maximum' :: (Ord a) => [a] -> a  
maximum' = foldr1 (\x acc -> if x > acc then x else acc)  
  
reverse' :: [a] -> [a]  
reverse' = foldl (\acc x -> x : acc) []  
  
product' :: (Num a) => [a] -> a  
product' = foldr1 (*)  
  
filter' :: (a -> Bool) -> [a] -> [a]  
filter' p = foldr (\x acc -> if p x then x : acc else acc) []  
  
head' :: [a] -> a  
head' = foldr1 (\x _ -> x)  
  
last' :: [a] -> a  
last' = foldl1 (\_ x -> x)  
head is better implemented by pattern matching, but this just goes to show, you can still achieve it by using folds. Our reverse' definition is pretty clever, I think. We take a starting value of an empty list and then approach our list from the left and just prepend to our accumulator. In the end, we build up a reversed list. \acc x -> x : acc kind of looks like the : function, only the parameters are flipped. That's why we could have also written our reverse as foldl (flip (:)) [].

Another way to picture right and left folds is like this: say we have a right fold and the binary function is f and the starting value is z. If we're right folding over the list [3,4,5,6], we're essentially doing this: f 3 (f 4 (f 5 (f 6 z))). f is called with the last element in the list and the accumulator, that value is given as the accumulator to the next to last value and so on. If we take f to be + and the starting accumulator value to be 0, that's 3 + (4 + (5 + (6 + 0))). Or if we write + as a prefix function, that's (+) 3 ((+) 4 ((+) 5 ((+) 6 0))). Similarly, doing a left fold over that list with g as the binary function and z as the accumulator is the equivalent of g (g (g (g z 3) 4) 5) 6. If we use flip (:) as the binary function and [] as the accumulator (so we're reversing the list), then that's the equivalent of flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6. And sure enough, if you evaluate that expression, you get [6,5,4,3].

scanl and scanr are like foldl and foldr, only they report all the intermediate accumulator states in the form of a list. There are also scanl1 and scanr1, which are analogous to foldl1 and foldr1.

ghci> scanl (+) 0 [3,5,2,1]  
[0,3,8,10,11]  
ghci> scanr (+) 0 [3,5,2,1]  
[11,8,3,1,0]  
ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]  
[3,4,5,5,7,9,9,9]  
ghci> scanl (flip (:)) [] [3,2,1]  
[[],[3],[2,3],[1,2,3]]  
When using a scanl, the final result will be in the last element of the resulting list while a scanr will place the result in the head.

Scans are used to monitor the progression of a function that can be implemented as a fold. Let's answer us this question: How many elements does it take for the sum of the roots of all natural numbers to exceed 1000? To get the squares of all natural numbers, we just do map sqrt [1..]. Now, to get the sum, we could do a fold, but because we're interested in how the sum progresses, we're going to do a scan. Once we've done the scan, we just see how many sums are under 1000. The first sum in the scanlist will be 1, normally. The second will be 1 plus the square root of 2. The third will be that plus the square root of 3. If there are X sums under 1000, then it takes X+1 elements for the sum to exceed 1000.

sqrtSums :: Int  
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1  
ghci> sqrtSums  
131  
ghci> sum (map sqrt [1..131])  
1005.0942035344083  
ghci> sum (map sqrt [1..130])  
993.6486803921487  
We use takeWhile here instead of filter because filter doesn't work on infinite lists. Even though we know the list is ascending, filter doesn't, so we use takeWhile to cut the scanlist off at the first occurence of a sum greater than 1000.

Function application with $
Alright, next up, we'll take a look at the $ function, also called function application. First of all, let's check out how it's defined:

($) :: (a -> b) -> a -> b  
f $ x = f x  
dollar
What the heck? What is this useless operator? It's just function application! Well, almost, but not quite! Whereas normal function application (putting a space between two things) has a really high precedence, the $ function has the lowest precedence. Function application with a space is left-associative (so f a b c is the same as ((f a) b) c)), function application with $ is right-associative.

That's all very well, but how does this help us? Most of the time, it's a convenience function so that we don't have to write so many parentheses. Consider the expression sum (map sqrt [1..130]). Because $ has such a low precedence, we can rewrite that expression as sum $ map sqrt [1..130], saving ourselves precious keystrokes! When a $ is encountered, the expression on its right is applied as the parameter to the function on its left. How about sqrt 3 + 4 + 9? This adds together 9, 4 and the square root of 3. If we want get the square root of 3 + 4 + 9, we'd have to write sqrt (3 + 4 + 9) or if we use $ we can write it as sqrt $ 3 + 4 + 9 because $ has the lowest precedence of any operator. That's why you can imagine a $ being sort of the equivalent of writing an opening parentheses and then writing a closing one on the far right side of the expression.

How about sum (filter (> 10) (map (*2) [2..10]))? Well, because $ is right-associative, f (g (z x)) is equal to f $ g $ z x. And so, we can rewrite sum (filter (> 10) (map (*2) [2..10])) as sum $ filter (> 10) $ map (*2) [2..10].

But apart from getting rid of parentheses, $ means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.

ghci> map ($ 3) [(4+), (10*), (^2), sqrt]  
[7.0,30.0,9.0,1.7320508075688772]  
Function composition
In mathematics, function composition is defined like this:  (f . g)(x) = f(g(x)), meaning that composing two functions produces a new function that, when called with a parameter, say, x is the equivalent of calling g with the parameter x and then calling the f with that result.

In Haskell, function composition is pretty much the same thing. We do function composition with the . function, which is defined like so:

(.) :: (b -> c) -> (a -> b) -> a -> c  
f . g = \x -> f (g x)  
notes
Mind the type declaration. f must take as its parameter a value that has the same type as g's return value. So the resulting function takes a parameter of the same type that g takes and returns a value of the same type that f returns. The expression negate . (* 3) returns a function that takes a number, multiplies it by 3 and then negates it.

One of the uses for function composition is making functions on the fly to pass to other functions. Sure, can use lambdas for that, but many times, function composition is clearer and more concise. Say we have a list of numbers and we want to turn them all into negative numbers. One way to do that would be to get each number's absolute value and then negate it, like so:

ghci> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]  
Notice the lambda and how it looks like the result function composition. Using function composition, we can rewrite that as:

ghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]  
Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression f (g (z x)) is equivalent to (f . g . z) x. With that in mind, we can turn

ghci> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]  
into

ghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]  
But what about functions that take several parameters? Well, if we want to use them in function composition, we usually have to partially apply them just so much that each function takes just one parameter. sum (replicate 5 (max 6.7 8.9)) can be rewritten as (sum . replicate 5 . max 6.7) 8.9 or as sum . replicate 5 . max 6.7 $ 8.9. What goes on in here is this: a function that takes what max 6.7 takes and applies replicate 5 to it is created. Then, a function that takes the result of that and does a sum of it is created. Finally, that function is called with 8.9. But normally, you just read that as: apply 8.9 to max 6.7, then apply replicate 5 to that and then apply sum to that. If you want to rewrite an expression with a lot of parentheses by using function composition, you can start by putting the last parameter of the innermost function after a $ and then just composing all the other function calls, writing them without their last parameter and putting dots between them. If you have replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8]))), you can write it as replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]. If the expression ends with three parentheses, chances are that if you translate it into function composition, it'll have three composition operators.

Another common use of function composition is defining functions in the so-called point free style (also called the pointless style). Take for example this function that we wrote earlier:

sum' :: (Num a) => [a] -> a     
sum' xs = foldl (+) 0 xs     
The xs is exposed on both right sides. Because of currying, we can omit the xs on both sides, because calling foldl (+) 0 creates a function that takes a list. Writing the function as sum' = foldl (+) 0 is called writing it in point free style. How would we write this in point free style?

fn x = ceiling (negate (tan (cos (max 50 x))))  
We can't just get rid of the x on both right right sides. The x in the function body has parentheses after it. cos (max 50) wouldn't make sense. You can't get the cosine of a function. What we can do is express fn as a composition of functions.

fn = ceiling . negate . tan . cos . max 50  
Excellent! Many times, a point free style is more readable and concise, because it makes you think about functions and what kind of functions composing them results in instead of thinking about data and how it's shuffled around. You can take simple functions and use composition as glue to form more complex functions. However, many times, writing a function in point free style can be less readable if a function is too complex. That's why making long chains of function composition is discouraged, although I plead guilty of sometimes being too composition-happy. The prefered style is to use let bindings to give labels to intermediary results or split the problem into sub-problems and then put it together so that the function makes sense to someone reading it instead of just making a huge composition chain.

In the section about maps and filters, we solved a problem of finding the sum of all odd squares that are smaller than 10,000. Here's what the solution looks like when put into a function.

oddSquareSum :: Integer  
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))     
Being such a fan of function composition, I would have probably written that like this:

oddSquareSum :: Integer  
oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]  
However, if there was a chance of someone else reading that code, I would have written it like this:

oddSquareSum :: Integer  
oddSquareSum =   
    let oddSquares = filter odd $ map (^2) [1..]  
        belowLimit = takeWhile (<10000) oddSquares  
    in  sum belowLimit  
It wouldn't win any code golf competition, but someone reading the function will probably find it easier to read than a composition chain.
