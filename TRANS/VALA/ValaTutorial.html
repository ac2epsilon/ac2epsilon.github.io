<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Vala Туторіал</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Vala Туторіал</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Відмова від відповідальності: Vala - це постійно прогресуючий проект, і його функції можуть змінюватися. Я намагався, щоб цей підручник був якомога актуальнішим, але я не досконалий. Крім того, я не можу пообіцяти, що методи, які я пропоную, обов'язково є найкращими на практиці. Але знову, я спробую не відставати від цього.</p></div>
<div class="sect2">
<h3 id="___vala">Що таке Vala?</h3>
<div class="paragraph"><p>Vala - нова мова програмування, яка дозволяє використовувати сучасні методи програмування для запису програм, які працюють у бібліотеках виконання GNOME, зокрема <code>GLib</code> та <code>GObject</code>. Ця платформа з самого початку забезпечує дуже повне середовище програмування з такими функціями, як динамічна система типів та допоміжне управління пам’яттю. До Vala єдиними способами програмування для платформи було використання природного  машинного C API, який розкриває багато часто небажаних деталей. Або мовою високого рівня, яка має супутну віртуальну машину, як Python або мова Mono C#. Або, альтернативно, на C ++ через бібліотеку огортки.</p></div>
<div class="paragraph"><p>Vala відрізняється від усіх цих інших прийомів тим, що генерує код C, який можна компілювати для виконання без додаткової бібліотеки підтримки поза платформою GNOME. Це має кілька наслідків, але найголовніше:</p></div>
<div class="ulist"><ul>
<li>
<p>
Програми, написані на Vala, повинні мати схожу ефективність із програмами, написаними безпосередньо на С, при цьому писати та підтримувати їх легше та швидше.
</p>
</li>
<li>
<p>
Додаток Vala не може робити нічого, чого не може зробити еквівалент C. У той час як Vala вводить багато мовних особливостей, недоступних на мові C, всі вони відображаються на C-конструкції, хоча вони часто є складними або витрачають занадто багато часу, щоб писати їх безпосередньо.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Таким чином, хоча Vala - це сучасна мова з усіма можливостями, яких ви очікували, вона отримує свою силу від існуючої платформи і повинна певним чином відповідати встановленим нею правилам.</p></div>
</div>
<div class="sect2">
<h3 id="____">Для кого цей підручник?</h3>
<div class="paragraph"><p>Цей підручник не буде заглиблюватися в основні практики програмування. Він лише коротко пояснить принципи об'єктно-орієнтованого програмування. Натомість зосередиться на тому, як Vala застосовує ці концепції. Таким чином, це буде корисно, якщо ви вже маєте досвід роботи з різними мовами програмування, хоча глибокі знання будь-якої конкретної мови не потрібні.</p></div>
<div class="paragraph"><p>Vala має багато синтаксису від C#, але я постараюся уникати опису функцій з точки зору їх подібності чи відмінності з C# або Java, з метою зробити підручник більш доступним.</p></div>
<div class="paragraph"><p>Корисним буда пристойне розуміння C. Хоча це не потрібно для розуміння Vala per se, важливо усвідомити, що програми Vala виконуються як C, і часто взаємодіють із бібліотеками С. Знання C, безумовно, полегшить глибше розуміння Vala.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Домовленості</h3>
<div class="paragraph"><p>Код в тексті виглядатиме як <code>моноширинний</code>, командам буде передувати <code>$</code>. Крім цього, все повинно бути очевидним. Я схильний кодувати дуже явно, включаючи деяку інформацію, яка насправді може бути опущена. Я спробую пояснити, де деякі речі можна опустити, але це не означає, що я заохочую вас до цього.</p></div>
<div class="paragraph"><p>У якийсь момент я додам посилання на документацію Vala, але це ще не можливо.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Перша програма</h2>
<div class="sectionbody">
<div class="paragraph"><p>На жаль передбачувано, але все ж:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span><span class="p">.</span><span class="n">HelloWorld</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, це програма Vala <code>Hello World</code>. Я сподіваюся, що ви зможете розпізнати деякі її частини досить добре, але щоб бути ретельним, я перегляну код крок за кроком.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span><span class="p">.</span><span class="n">HelloWorld</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей рядок вказує на початок визначення класу. Класи у Vala за концепцією дуже схожі на інші мови. Клас - це в основному тип об'єкта, з якого можуть бути створені екземпляри, що мають однакові властивості. Про реалізацію класових типів опікується бібліотека <code>gobject</code>, але детальна інформація про це не важлива для загального використання.</p></div>
<div class="paragraph"><p>Важливо зазначити, що цей клас спеціально описаний як підклас <code>GLib.Object</code>. Це тому, що Vala допускає інші типи класів, але в більшості випадків це саме той тип, який ви хочете. Насправді, деякі мовні функції Vala доступні лише у тому випадку, якщо ваш клас походить від <code>GLib.Object</code>.</p></div>
<div class="paragraph"><p>В інших частинах цього рядка показані простори імен та повністю кваліфіковані імена, хоча вони будуть пояснені пізніше.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Це початок визначення методу. Метод - це функція, пов'язана з типом об'єкта, яка може бути виконана на об'єкті цього типу. Статичний метод означає, що метод можна викликати, не володіючи конкретним екземпляром типу. Той факт, що цей метод називається <code>main</code> і має певну сигнатуру, означає, що Vala визнає його як вхідну точку програми.</p></div>
<div class="paragraph"><p>Метод <code>main</code> не повинен визначатися всередині класу. Однак якщо він визначений всередині класу, він повинен бути статичним. Не має значення, чи він <code>public</code> чи <code>private</code>. Тип повернення може бути <code>int</code> або <code>void</code>. З типом повернення <code>void</code> програма неявно завершиться з кодом виходу 0. Параметр масиву рядків, що містить аргументи командного рядка, необов'язковий.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><code>stdout</code> - це об'єкт у просторі імен <code>GLib</code>, до якого Vala за потреби забезпечує доступ. Цей рядок доручає Vala виконати метод, який називається <code>printf</code> об'єкта <code>stdout</code>, з рядком привітання в якості аргумента. У Vala це завжди синтаксис, який ви використовуєте для виклику методу на об’єкті, або для доступу до даних об’єкта. <code>\n</code> - <em>ескейп послідовність</em> нового рядка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>return</code> означає повернути значення в точку виклику і припинити виконання методу <code>main</code>, що також припиняє виконання програми. Після цього повернене значення методу <code>main</code> сприймається як <em>код завершення</em> програми.</p></div>
<div class="paragraph"><p>Останні рядки просто закінчують визначення методу та класу.</p></div>
<div class="sect2">
<h3 id="___">Компіляція і виконання</h3>
<div class="paragraph"><p>Якщо припустити, що у вас встановлено Vala, то для компіляції та виконання цієї програми потрібно таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac hello.vala
$ ./hello
</pre></div></div></div>
<div class="paragraph"><p><code>valac</code> - компілятор Vala, який компілює ваш код Vala у двійковий. Отриманий двійковий файл матиме те саме ім'я, що і вихідний файл, і потім може бути безпосередньо виконаний на машині. Ви можете, напевно, здогадатися про результат.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Основи</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="____2">Файли та компіляція</h3>
<div class="paragraph"><p>Код Vala записується у файли з розширеннями <code>.vala</code>. Vala не нав'язує стільки структури, як такі мови, як Java - немає таких самих понять пакетів або файлів класів. Натомість структура визначається текстом всередині кожного файлу, описуючи логічне розташування коду завдяки такими конструкціями, як простори імен. Коли ви хочете компілювати код Vala, ви даєте компілятору список необхідних файлів, і Vala розбереться, як вони пасують разом.</p></div>
<div class="paragraph"><p>Підсумок всього цього полягає в тому, що ви можете помістити стільки класів або функцій у файл, скільки хочете, навіть комбінуючи частини різних просторів імен разом. Це не обов'язково гарна ідея. Є певні умови, яких ви, мабуть, хочете дотримуватися. Хорошим прикладом того, як структурувати проект у Vala, є сам проект Vala.</p></div>
<div class="paragraph"><p>Усі вихідні файли для того ж пакету подаються як параметри командного рядка до компілятора Vala <code>valac</code> разом із флагами компілятора. Це працює аналогічно тому, як компілюється вихідний код Java. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac compiler.vala --pkg libvala
</pre></div></div></div>
<div class="paragraph"><p>буде виробляти двійковий файл на ім'я <code>compiler</code>, який зв'язується з пакунком <code>libvala</code>. Насправді саме так створюється компілятор <code>valac</code>!</p></div>
<div class="paragraph"><p>Якщо ви хочете, щоб двійковий файл мав інше ім’я, або якщо ви передали компілятору кілька вихідних файлів, ви можете вказати ім’я результата явно, за допомогою перемикача <code>-o</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac source1.vala source2.vala -o myprogram
$ ./myprogram
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви надасте <code>valac</code> перемикач <code>-C</code>, він не компілює вашу програму у двійковий файл. Натомість він виведе проміжний код C для кожного з ваших вихідних файлів Vala у відповідний вихідний файл C - у цьому випадку <code>source1.c</code> та <code>source2.c</code>. Якщо ви подивитесь на вміст цих файлів, то можна побачити, що програмування класу у Vala еквівалентно тому самому завданню на C, але набагато більш лаконічним. Ви також помітите, що цей клас динамічно реєструється в запущеній системі. Це хороший приклад потужності платформи GNOME, але, як я вже говорив раніше, вам не потрібно багато знати про це, щоб використовувати Vala.</p></div>
<div class="paragraph"><p>Якщо ви хочете мати файл заголовка С для свого проекту, ви можете використовувати перемикач <code>-H</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac hello.vala -C -H hello.h
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд синтаксису</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис Vala - це амальгама, заснована на С#. Як результат, більша його частина буде знайома програмістам, які знають будь-яку мову, схожу на С, і, зважаючи на це, я резюмував все.</p></div>
<div class="paragraph"><p>Область застосування визначається за допомогою фігурних дужок. Об'єкт або посилання дійсні лише між <code>{</code> і <code>}</code>. Це також роздільники, які використовуються для визначення класів, методів, блоків коду тощо, тому вони автоматично мають власну сферу застосування. Vala не сувора щодо місця декларування змінних.</p></div>
<div class="paragraph"><p>Ідентифікатор визначається його типом та назвою, наприклад <code>int c</code> означає ціле число на ім'я <code>c</code>. У випадку типів значень це також створює об'єкт даного типу. Для типів посилань вони просто визначають нове посилання, яке спочатку не вказує ні на що.</p></div>
<div class="paragraph"><p>Імена ідентифікатора можуть бути будь-якою комбінацією літер (<code>[a-z]</code>, <code>[A-Z]</code>), підкреслення та цифр. Однак, щоб визначити або посилатися на ідентифікатор з іменем, яке або починається з цифри, або є ключовим словом, потрібно встановити його префіксом символ <code>"@"</code>. Цей символ не вважається частиною імені. Наприклад, ви можете назвати метод <code>foreach</code>, написавши <code>@foreach</code>, навіть якщо це зарезервоване ключове слово Vala. Ви можете опустити символ <code>"@"</code>, коли його можна однозначно інтерпретувати як ім'я ідентифікатора, наприклад у <code>foo.foreach ()</code>.</p></div>
<div class="paragraph"><p>Типи посилань ініціюються за допомогою оператора <code>new</code> та назви способу побудови, що зазвичай є лише назвою типу, наприклад <code>Object o = new Object()</code> створює новий <code>Object</code> і робить <code>o</code> посиланням на нього.</p></div>
<div class="sect2">
<h3 id="__4">Коментарі</h3>
<div class="paragraph"><p>Vala дозволяє коментувати в коді різними способами.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Коментар продовжується до кінця рядка</span>

<span class="cm">/* Коментар триває між роздільниками */</span>

<span class="cm">/**</span>
<span class="cm"> * Коментар до документації</span>
<span class="cm"> */</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони обробляються так само, як і в більшості інших мов, тому потребують невеликих пояснень. Зауваження щодо документації насправді не особливі для Vala, але інструмент генерації документації, як Valadoc, розпізнає їх.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___3">Типи даних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Загалом, у Vala є два типи даних: типи посилань та типи значень. Ці імена описують, як екземпляри типів передаються по системі - тип значення копіюється кожного разу, коли він присвоюється новому ідентифікатору, тип посилання не копіюється, натомість новий ідентифікатор - це просто нове посилання на той самий об’єкт.</p></div>
<div class="paragraph"><p>Константа визначається, ставлячи <code>const</code> перед типом. Домовленість іменування констант - <code>ALL_UPPER_CASE</code>.</p></div>
<div class="sect3">
<h4 id="___4">Типи значення</h4>
<div class="paragraph"><p>Vala підтримує набір простих типів, як це робить більшість інших мов.</p></div>
<div class="ulist"><ul>
<li>
<p>
Byte, <code>char</code>, <code>uchar</code>; їхні імена є <code>char</code> з історичних причин.
</p>
</li>
<li>
<p>
Character, <code>unichar</code>; 32-розрядний символ Unicode
</p>
</li>
<li>
<p>
Integer, <code>int</code>, <code>uint</code>
</p>
</li>
<li>
<p>
Long Integer, <code>long</code>, <code>ulong</code>
</p>
</li>
<li>
<p>
Short Integer, <code>short</code>, <code>ushort</code>
</p>
</li>
<li>
<p>
Integer гарантованої довжини, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, так само як їх беззнакові варіанти <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>. Цифри позначають довжину в бітах.
</p>
</li>
<li>
<p>
Float, <code>float</code>, <code>double</code>
</p>
</li>
<li>
<p>
Boolean, <code>bool</code>; можливі значення <code>true</code> та <code>false</code>
</p>
</li>
<li>
<p>
Compound, <code>struct</code>
</p>
</li>
<li>
<p>
Enumeration, <code>enum</code>; представлені цілими значеннями, а не класами, як перерахунки Java
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ось кілька прикладів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="o">*</span> <span class="err">атомарні</span> <span class="err">типи</span> <span class="o">*</span> <span class="o">/</span>
<span class="kt">unichar</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;u&#39;</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">percentile</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="p">;</span>
<span class="kd">const</span> <span class="kt">double</span> <span class="n">MU_BOHR</span> <span class="o">=</span> <span class="mf">927.400915E-26</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">the_box_has_crashed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">визначення</span> <span class="err">структури</span> <span class="o">*</span> <span class="o">/</span>
<span class="kd">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">визначення</span> <span class="k">enum</span> <span class="o">*</span> <span class="o">/</span>
<span class="k">enum</span> <span class="n">WindowType</span> <span class="p">{</span>
    <span class="n">TOPLEVEL</span><span class="p">,</span>
    <span class="n">POPUP</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість цих типів можуть мати різні розміри на різних платформах, за винятком цілих типів із гарантованим розміром. Оператор <code>sizeof</code> повертає розмір, який займає змінна даного типу в байтах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">ulong</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32</span><span class="p">);</span>    <span class="c1">// nbytes складе 4 (= 32 біта)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете визначити мінімальні та максимальні значення числового типу за допомогою <code>.MIN</code> та <code>.MAX</code>, наприклад <code>int.MIN</code> та <code>int.MAX</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__5">Рядки</h4>
<div class="paragraph"><p>Тип даних для рядків - це <code>string</code>. Рядки Vala кодуються UTF-8 та є незмінні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Рядковий літерал&quot;</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala пропонує функцію, яку називають дослівними рядками. Це рядки, в яких ескейп послідовності (наприклад, <code>\n</code>) не інтерпретуються, розриви рядків будуть збережені, а лапки не потрібно маскувати. Вони утворюються потрійними подвійними лапками. Можливі відступи після розриву рядка також є частиною рядка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">verbatim</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Це так званий &quot;</span><span class="err">дослівний</span> <span class="err">рядок</span><span class="s">&quot;.</span>
<span class="err">Дослівні</span> <span class="err">рядки</span> <span class="err">не</span> <span class="err">обробляють</span> <span class="err">ескейп</span> <span class="err">послідовності</span><span class="p">,</span> <span class="err">такі</span> <span class="err">як</span> <span class="err">\</span><span class="n">n</span><span class="p">,</span> <span class="err">\</span><span class="n">t</span><span class="p">,</span> <span class="err">\\</span><span class="p">,</span> <span class="n">etc</span><span class="p">.</span>
<span class="err">Вони</span> <span class="err">можуть</span> <span class="err">містити</span> <span class="err">лапки</span> <span class="err">і</span> <span class="err">охоплювати</span> <span class="err">декілька</span> <span class="err">рядків</span> <span class="err">поспіль</span><span class="p">.</span><span class="s">&quot;&quot;&quot;;</span>
</pre></div></div></div>
<div class="paragraph"><p>Рядки з префіксом <code>"@"</code> - це шаблони рядків. Вони можуть оцінювати вбудовані змінні та вирази з префіксом <code>"$"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">@&quot;$a * $b = $(a * b)&quot;</span><span class="p">;</span>  <span class="c1">// =&gt; &quot;6 * 7 = 42&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператори рівності <code>==</code> і <code>!=</code> порівнюють зміст двох рядків, всупереч поведінці Java, яка в цьому випадку перевіряє рівність посилань.</p></div>
<div class="paragraph"><p>Ви можете нарізати рядок за допомогою <code>[start: end]</code>. Від'ємні значення представляють позиції відносно кінця рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello, world&quot;</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">12</span><span class="p">];</span>        <span class="c1">// =&gt; &quot;world&quot;</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="o">:-</span><span class="mi">2</span><span class="p">];</span>       <span class="c1">// =&gt; &quot;or&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що індекси у Vala починаються з 0, як у більшості інших мов програмування. Починаючи з Vala 0,11, ви можете отримати доступ до одного байта рядка за допомогою <code>[index]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">uint8</span> <span class="n">b</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>             <span class="c1">// =&gt; 0x77</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак ви не можете призначити нове значення байту в цій позиції, оскільки рядки Vala незмінні.</p></div>
<div class="paragraph"><p>Багато основних типів мають розумні методи розбору та перетворення на рядки, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;false&quot;</span><span class="p">);</span>           <span class="c1">// =&gt; false</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;-52&quot;</span><span class="p">);</span>               <span class="c1">// =&gt; -52</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="kt">double</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;6.67428E-11&quot;</span><span class="p">);</span> <span class="c1">// =&gt; 6.67428E-11</span>
<span class="kt">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span>           <span class="c1">// =&gt; &quot;true&quot;</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="mf">21.</span><span class="n">to_string</span><span class="p">();</span>             <span class="c1">// =&gt; &quot;21&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Two useful methods for writing and reading strings to/from the console (and for your first explorations with Vala) are stdout.printf() and stdin.read_line():
Два корисні методи для запису та читання рядків до/з консолі (і для ваших перших досліджень Vala) - <code>stdout.printf()</code> та <code>stdin.read_line ()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %g %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="s">&quot;Vala&quot;</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">input</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">.</span><span class="n">read_line</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">stdin</span><span class="p">.</span><span class="n">read_line</span><span class="p">());</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви вже знаєте <code>stdout.printf()</code> з прикладу Hello World. Насправді він може приймати довільну кількість аргументів різних типів, тоді як перший аргумент - це рядок формату, дотримуючись тих же правил, що і рядки формату C. Якщо потрібно вивести повідомлення про помилку, ви можете використовувати <code>stderr.printf()</code> замість <code>stdout.printf()</code>.</p></div>
<div class="paragraph"><p>Крім того, операція <code>in</code> може бути використана для визначення того, чи містить один рядок інший, наприклад</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="s">&quot;ere&quot;</span> <span class="k">in</span> <span class="s">&quot;Able was I ere I saw Elba.&quot;</span><span class="p">)</span> <span class="p">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Для отримання додаткової інформації, будь ласка, посилайтесь на <a href="http://www.valadoc.org/glib-2.0/string.html">повний огляд класу <code>string</code></a>.</p></div>
<div class="paragraph"><p>Зразок програми, що демонструє використання рядків, <a href="https://wiki.gnome.org/Projects/Vala/StringSample">також доступний</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Масиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Масив оголошується шляхом надання імені типу, за яким слідує <code>[]</code>, і створюється за допомогою оператора <code>new</code>, наприклад <code>int [] a = new int[10]</code> для створення масиву цілих чисел. Довжина такого масиву може бути отримана через змінну <code>length</code>, наприклад <code>int count = a.length</code>. Зауважте, що коли ви пишете <code>Object[] a = new Object[10]</code>, об’єкти не створюватимуться, але тільки масив для їх зберігання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span> <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете нарізати масив за допомогою <code>[start: end]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>     <span class="c1">// =&gt; { 4, 6 }</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарізання масиву призведе до посилання на запитувані дані, а не до копії. Однак присвоєння фрагмента власниковій змінній (як це зроблено вище) призведе до копіювання. Якщо ви хочете уникнути копії, потрібно або призначити фрагмент <code>unowned</code> масиву, або передати його безпосередньо аргументу (аргументи за замовчуванням <code>unowned</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">unowned</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>     <span class="c1">// =&gt; { 4, 6 }</span>
</pre></div></div></div>
<div class="paragraph"><p>Багатовимірні масиви визначаються за допомогою <code>[,]</code> або <code>[,,]</code> тощо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
            <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">}};</span>
<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вид масиву представлений єдиним суміжним блоком пам'яті. Зубчасті багатовимірні масиви (<code>[][]</code>, також відомі як "накладені масиви" або "масиви масивів"), де кожен рядок може мати різну довжину, ще не підтримуються.</p></div>
<div class="paragraph"><p>Щоб знайти довжину кожного виміру в багатовимірному масиві, член <code>length</code> стає масивом, зберігаючи довжину кожного відповідного виміру.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div></div></div>
<div class="paragraph"><p>Зверніть увагу, що ви не можете отримати одновимірний масив з багатовимірного масиву або навіть зрізати багатовимірний масив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span>
                <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}};</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">e</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">f</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// не робить</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додавати елементи масиву динамічно за допомогою оператора <code>+=</code>. Однак це працює лише для локально визначених або приватних масивів. При необхідності масив автоматично перерозподіляється. Внутрішньо це перерозподіл відбувається з розмірами, що зростають ступенями двох, з міркувань ефективності роботи. Однак <code>length</code> містить фактичну кількість елементів, а не внутрішній розмір.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">37</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете змінити розмір масиву, викликавши для нього <code>resize()</code>. Він збереже оригінальний вміст (стільки, скільки вміщається).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете переміщувати елементи в масиві, викликаючи <code>move(src, dest, length)</code> на ньому. Початкові позиції будуть заповнені 0.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="p">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="n">chars</span><span class="p">.</span><span class="n">move</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">print</span> <span class="p">((</span><span class="kt">string</span><span class="p">)</span> <span class="n">chars</span><span class="p">);</span> <span class="c1">// &quot;world &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви поставите квадратні дужки після ідентифікатора разом із зазначенням розміру, ви отримаєте масив фіксованого розміру. Масиви фіксованого розміру розподіляються на стеку (якщо вони використовуються як локальні змінні) або виділяються інлайн (якщо вони використовуються як поля), і ви не можете їх перерозподілити пізніше.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// без &#39;new ...&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala не проводить перевірки меж для доступу до масиву під час виконання. Якщо вам потрібна більша безпека, ви повинні використовувати більш складну структуру даних, як <code>ArrayList</code>. Про це ви дізнаєтесь далі у розділі про колекції.</p></div>
<div class="sect2">
<h3 id="___5">Типи посилань</h3>
<div class="paragraph"><p>Типи посилань - це всі типи, оголошені як клас, незалежно від того, походять вони з <code>Object</code> GLib чи ні. Vala гарантує, що при передачі об'єкта за посиланням система буде відслідковувати кількість посилань, що наразі є активними, щоб керувати пам'яттю для вас. Значення посилання, яке нікуди не вказує, є <code>null</code>. Детальніше про класи та їх особливості в розділі про об’єктно-орієнтоване програмування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cm">/* визначення класу */</span>
<span class="kd">class</span> <span class="nc">Track</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>             <span class="cm">/* субклас &#39;GLib.Object&#39; */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">mass</span><span class="p">;</span>                 <span class="cm">/* публічне поле */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>    <span class="cm">/* публічна властивість */</span>
    <span class="kd">private</span> <span class="kt">bool</span> <span class="n">terminated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>    <span class="cm">/* приватне поле */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">terminate</span><span class="p">()</span> <span class="p">{</span>           <span class="cm">/* публічний метод */</span>
        <span class="n">terminated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Статичне приведення типів</h3>
<div class="paragraph"><p>У Vala ви можете привести змінну від одного типу до іншого. Для приведення статичного типу змінна перетворюється на потрібний, задаючи ім'я типу з дужками. Статичне приведення не накладає перевірки безпеки типу часу виконання. Це працює для всіх типів Vala. Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala підтримує інший механізм приведення під назвою динамічний кастинг, який виконує перевірку типу часу виконання та описаний у розділі про об'єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Виведення типів</h3>
<div class="paragraph"><p>Vala має механізм, який називається виведенням типу, за яким локальна змінна може бути визначена за допомогою <code>var</code> замість надання типу, доки не має сумніву, який тип мається на увазі. Тип виводиться з правого боку присвоєння. Це допомагає зменшити зайву надмірність у вашому коді без шкоди для статичної типізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>     <span class="c1">// те саме: Person p = new Person();</span>
<span class="kd">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>          <span class="c1">// те саме: string s = &quot;hello&quot;;</span>
<span class="kd">var</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// те саме: List&lt;int&gt; l = new List&lt;int&gt;();</span>
<span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>               <span class="c1">// те саме: int i = 10;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це працює лише для локальних змінних. Виведення типу особливо корисне для типів із дженеріками - аргументами типів (докладніше про них пізніше). Порівняйте</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>vs.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____">Визначення нового типу від інших</h3>
<div class="paragraph"><p>Визначення нового типу - це питання вивести його з потрібного. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="o">*</span> <span class="err">Визначення</span> <span class="err">новий</span> <span class="err">тип</span> <span class="err">із</span> <span class="err">контейнера</span> <span class="err">типу</span> <span class="n">GLib</span><span class="p">.</span><span class="n">List</span> <span class="err">з</span> <span class="err">елементами</span> <span class="err">типу</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="o">/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValueList</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GLib</span><span class="p">.</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="p">[</span><span class="nd">CCode</span> <span class="p">(</span><span class="n">has_construct_function</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)]</span>
        <span class="kd">protected</span> <span class="n">ValueList</span> <span class="p">();</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Type</span> <span class="n">get_type</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__7">Оператори</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>=</code>
призначення. Лівий операнд повинен бути ідентифікатором, а правий повинен приводити до значення або посилання відповідно.</p></div>
<div class="paragraph"><p><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>
основна арифметика, застосована до лівого і правого операндів. Оператор <code>+</code> також може об'єднати рядки.</p></div>
<div class="paragraph"><p><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code>, <code>%=</code>
арифметична операція між лівим і правим операндами, де лівий повинен бути ідентифікатором, якому присвоюється результат.</p></div>
<div class="paragraph"><p><code>++</code>, <code>--</code>
операції збільшення та зменшення з неявним призначенням. Вони беруть лише один аргумент, який повинен бути ідентифікатором простого типу даних. Значення буде змінено і присвоєно назад ідентифікатору. Ці оператори можуть бути розміщені або в позиціях префікса, або в постфіксі - при першому оцінене значення оператора буде щойно обчисленим значенням, при другому повертається початкове значення.</p></div>
<div class="paragraph"><p><code>|</code>, <code>^</code>, <code>&amp;</code>, <code>~</code>, <code>|=</code>, <code>&amp;=</code>, <code>^=</code>
побітові операції: або, ексклюзивні або, і, ні. Другий набір включає призначення і є аналогом арифметичних версій. Вони можуть бути застосовані до будь-якого з простих типів значень. (Немає жодного оператора присвоєння, пов'язаного з <code>~</code>, тому що це одномісний оператор. Еквівалентна операція просто <code>a = ~a</code>).</p></div>
<div class="paragraph"><p><code>&lt;&lt;</code>, <code>&gt;&gt;</code>
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда.</p></div>
<div class="paragraph"><p><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда. Лівий операнд повинен бути ідентифікатором, якому присвоюється результат.</p></div>
<div class="paragraph"><p><code>==</code>
тест на рівність. Оцінюється до значення <code>bool</code>, залежно від того, чи рівні лівий і правий операнди. У випадку типів значень це означає, що їх значення рівні, у випадку референсних типів об'єкти - це той самий екземпляр. Виняток із цього правила - тип рядка, який тестується на рівність за значенням.</p></div>
<div class="paragraph"><p><code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>
тести на нерівність. Оцінює значення до <code>bool</code> залежно від того, чи відрізняються лівий і правий операнди описаним способом. Вони дійсні для простих типів даних та типу рядка. Для рядків ці оператори порівнюють лексикографічний порядок.</p></div>
<div class="paragraph"><p><code>!</code>, <code>&amp;&amp;</code>, <code>||</code>
логічні операції: не, і, або. Ці операції можуть бути застосовані до булевих значень - перший приймає лише одне значення, інші - дві.</p></div>
<div class="paragraph"><p><code>? :</code>
ternary conditional operator. Evaluates a condition and returns either the value of the left or the right sub-expression based on whether the condition is true or false: condition ? value if true : value if false
потрійний умовний оператор. Оцінює умову і повертає або значення лівого, або правого підвиразу, виходячи з того, чи є умова істинною чи помилковою: <code>умова ? true значення: false значення</code></p></div>
<div class="paragraph"><p><code>??</code>
оператор <code>null</code> поглинання: <code>a ?? b</code> еквівалентно <code>a != null ? a : b</code>. Цей оператор корисний, наприклад, для надання значення за замовчуванням у випадку, якщо посилання є <code>null</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="o">??</span> <span class="s">&quot;unknown person&quot;</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><code>in</code>
перевіряє, чи містить правий операнд лівий операнд. Цей оператор працює над масивами, рядками, колекціями або будь-яким іншим типом, який має відповідний метод <code>contains()</code>. Для рядків він виконує пошук підрядків.</p></div>
<div class="paragraph"><p>Операторів не можна перевантажувати у Vala. Існують додаткові оператори, які дійсні в контексті лямбда-декларацій та інших конкретних завдань - вони пояснюються в контексті, в якому вони застосовуються.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___7">Структури управління</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде декрементувати повторно, перевіряючи перед кожною ітерацією, що <code>a</code> більше <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">do</span> <span class="p">{</span> <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>буде декрементувати повторно, перевіряючи після кожної ітерації, що <code>a</code> більше <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде ініціалізувати <code>а</code> до <code>0</code>, а потім друкувати повторно, доки <code>а</code> не буде менше <code>10</code>, збільшуючи <code>а</code> після кожної ітерації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="k">in</span> <span class="n">int_array</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде друкувати кожне ціле число в масиві чи іншій ітерабельній колекції. Значення "ітерабельного" буде описано пізніше.</p></div>
<div class="paragraph"><p>Усі чотири попередні типи циклу можуть керуватися ключовими словами <code>break</code> та <code>continue</code>. Інструкція <code>break</code> призведе до негайного завершення циклу, а <code>continue</code> перейде прямо до тестової частини ітерації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is greater than 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is less than 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is equal to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>виконує певний фрагмент коду на основі набору умов. Перша умова, яка відповідає, визначає, який код буде виконуватися, якщо <code>a</code> більше <code>0</code>, не перевірятиметься, чи вона менша за <code>0</code>. Дозволяється будь-яка кількість блоків <code>else if</code>, та нуль або один блок <code>else</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
<span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;two or three</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">default</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>switch</code> виконує рівно один або жодного розділу коду на основі значення, переданого йому. У Vala немає провалів між випадками, крім порожніх. Для того, щоб забезпечити це, кожен непустий випадок повинен закінчуватися <code>break</code>, <code>return</code> або <code>throw</code>. Можна використовувати оператори <code>switch</code> з рядками.</p></div>
<div class="paragraph"><p>Примітка для програмістів на C: умови завжди повинні оцінюватися як булеві значення. Це означає, що якщо ви хочете перевірити змінну на <code>null</code> або <code>0</code>, ви повинні зробити це явно: <code>if (object! = Null) {}</code> або <code>if (number! = 0) {}</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___8">Мовні елементи</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="__8">Методи</h4>
<div class="paragraph"><p>Функції називаються методами у Vala, незалежно від того, визначені вони всередині класу чи ні. Відтепер ми будемо дотримуватися терміну <em>метод</em>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">method_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Object</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код визначає метод, який має ім'я <code>method_name</code>, беручи два аргументи, один ціле число, а другий - <code>Object</code> (перший передається за значенням, другий - як посилання, як описано). Метод поверне ціле число, яке в даному випадку дорівнює <code>1</code>.</p></div>
<div class="paragraph"><p>Усі методи Vala є функцією C, тому беруть довільну кількість аргументів і повертають одне значення (або жодного, якщо метод визнаний <code>void</code>). Вони можуть наблизити більше значень повернення, розміщуючи дані у місцях, відомих коду виклику. Детальніше про те, як це зробити, ви знайдете в розділі "Напрямки параметрів" у розширеній частині цього підручника.</p></div>
<div class="paragraph"><p>Домовленість іменування методів у Vala - це <code>all_lower_case</code>, з підкресленнями в якості роздільника слів. Це може бути трохи незнайоме програмістам на C# або Java, які звикли до імен методів <code>CamelCase</code> або <code>mixedCamelCase</code>. Але з цим стилем ви будете узгоджені з іншими бібліотеками Vala та C/GObject.</p></div>
<div class="paragraph"><p>Неможливо мати кілька методів з тим самим іменем, але різні сигнатури в межах однієї області ("перевантаження методів"):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Shape</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>  <span class="c1">// неможливе</span>
</pre></div></div></div>
<div class="paragraph"><p>Це пов’язано з тим, що бібліотеки, створені з Vala, призначені для використання також для програмістів на C. У Vala ви зробили б щось подібне замість цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">draw_text</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">draw_shape</span><span class="p">(</span><span class="n">Shape</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вибравши трохи інші імена, ви можете уникнути зіткнення імен. В мовах, що підтримують перевантаження методів, це часто використовується для надання зручних методів з меншою кількістю параметрів, що призводить до виклику найбільш загального методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// неможливе</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span> <span class="p">}</span>           <span class="c1">// неможливе</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку ви можете скористатись можливістю надати параметру значення за замовчуванням, щоб досягти подібної поведінки лише одним методом. Ви можете визначити значення за замовчуванням для останніх параметрів методу, так що вам не доведеться їх явно передавати при виклику методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Деякі можливі виклики цього методу можуть бути:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Можна навіть визначити методи з реальними списками аргументів змінної довжини (<code>varargs</code>), такими як <code>stdout.printf()</code>, хоча це не обов'язково рекомендується. Ви дізнаєтесь, як це зробити пізніше.</p></div>
<div class="paragraph"><p>Vala здійснює основну перевірку на <code>null</code>-здатність параметри методу та значення повернення. Якщо припустимо, що параметр методу або значення, що повертається, мають значення <code>null</code>, символ типу повинен бути постфіксований модифікатором <code>?</code>. Ця додаткова інформація допомагає компілятору Vala виконувати статичні перевірки та додавати припущення часу виконання для методів, що може допомогти уникнути пов'язаних помилок, таких як використання <code>null</code> посилання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="o">?</span> <span class="n">method_name</span><span class="p">(</span><span class="kt">string</span><span class="o">?</span> <span class="n">text</span><span class="p">,</span> <span class="n">Foo</span><span class="o">?</span> <span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>In this example text, foo and the return value may be null, however, bar must not be null.
У цьому прикладі <code>text</code>, <code>foo</code> та значення, що повертаються, можуть бути <code>null</code>, проте <code>bar</code> не повинна бути <code>null</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__9">Делегати</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Делегати представляють методи, що дозволяють передавати фрагменти коду як об'єкти. Наведений вище приклад визначає новий тип з назвою <code>DelegateType</code>, який представляє методи, що приймають <code>int</code> та не повертає жодного значення. Будь-який метод, що відповідає цій сигнатурі, може бути призначений змінній цього типу або передаватися як аргумент методу цього типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">DelegateType</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>       <span class="c1">// Виклик делегата</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f2</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// Передача метода як як аргумента делегата в інший метод</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код виконує метод <code>f2</code>, передаючи посилання на метод <code>f1</code> і число <code>5</code>. Потім <code>f2</code> виконає метод <code>f1</code>, передавши йому число.</p></div>
<div class="paragraph"><p>Делегати також можуть створюватися локально. Метод-член також може бути призначений делегату, наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
        <span class="n">DelegateType</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">f1</span><span class="p">;</span>
        <span class="n">d1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="____4">Анонімні методи/замикання</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анонімний метод, також відомий як лямбда-вираз, літеральна функція або замикання, може бути визначений у Vala за допомогою оператора <code>=&gt;</code>. Список параметрів знаходиться з лівої сторони оператора, тіло методу - з правого боку.</p></div>
<div class="paragraph"><p>Анонімний метод, що стоїть сам по собі, як вище, не має особливого сенсу. Він корисний лише в тому випадку, якщо ви призначите його безпосередньо змінній типу делегата або передаєте його як аргумент-метод іншому методу.</p></div>
<div class="paragraph"><p>Зауважте, що ні параметри, ні тип повернення не вказані явно. Натомість типи виводяться з сигнатури делегата, з яким він використовується.</p></div>
<div class="paragraph"><p>Призначення анонімного методу делегатній змінній:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">PrintIntFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PrintIntFunc</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">p1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Фігурні дужки необов’язкові, якщо тіло містить лише одне твердження:</span>
    <span class="n">PrintIntFunc</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">p2</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Передача анонімного методу до іншого методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">int</span> <span class="n">Comparator</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">my_sorting_algorithm</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="n">Comparator</span> <span class="n">compare</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... &#39;compare&#39; називається десь тут ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
    <span class="c1">// Анонімний метод передається як другий аргумент:</span>
    <span class="n">my_sorting_algorithm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анонімні методи - це справжні замикання. Це означає, що ви можете отримати доступ до локальних змінних зовнішнього методу в межах лямбда-виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">int</span> <span class="n">IntOperation</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

<span class="n">IntOperation</span> <span class="n">curried_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// &#39;a&#39; - зовнішня змінна</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;2 + 4 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curried_add</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі <code>curried_add</code> (див. Карування) повертає новостворений метод, який зберігає значення <code>a</code>. Цей повернутий метод викликається безпосередньо після цього, з аргументом <code>4</code>, що призводить до суми двох чисел.</p></div>
</div>
<div class="sect3">
<h4 id="___9">Простори імен</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="nn">NameSpaceName</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все, що знаходиться між дужками в цьому операторі, знаходиться в просторі імен <code>NameSpaceName</code> і на нього має бути посилання. Будь-який код за межами цього простору імен повинен або використовувати кваліфіковані імена для чогось, що знаходиться в межах простору імен, або бути у файлі з відповідною декларацією, щоб імпортувати цю область імен:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">using</span> <span class="nn">NameSpaceName</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, якщо імпорт простору імен Gtk імпортується за допомогою <code>using Gtk;</code> ви можете просто написати <code>Window</code> замість <code>Gtk.Window</code>. Повна кваліфікована назва потрібна буде лише у випадку неоднозначності, наприклад, між <code>GLib.Object</code> та <code>Gtk.Object</code>.</p></div>
<div class="paragraph"><p>Простір імен <code>GLib</code> імпортується за замовчуванням. Уявіть невидимий рядок <code>using GLib;</code> на початку кожного файлу Vala.</p></div>
<div class="paragraph"><p>Все, що ви не помістите в окремий простір імен, потрапить у анонімний глобальний простір імен. Якщо вам доведеться явно посилатися на глобальний простір імен через неоднозначність, ви можете зробити це за допомогою префікса <code>global::</code>.</p></div>
<div class="paragraph"><p>Простори імен можна вкладати або шляхом введення однієї декларації всередину іншої, або наданням імені форми <code>NameSpace1.NameSpace2</code>.</p></div>
<div class="paragraph"><p>Кілька інших типів визначень можуть декларувати себе всередині простору імен, дотримуючись тієї ж форми іменування, наприклад. клас <code>NameSpace1.Test {...}</code>. Зауважте, що після цього кінцевим простором імен визначення буде вкладена декларація, плюс простори імен, оголошені у визначенні.</p></div>
</div>
<div class="sect3">
<h4 id="__10">Структури</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">StructName</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає тип структури, тобто тип складного значення. Структура Vala може мати методи обмеженим чином, а також може мати приватні члени, тобто потрібебн явний модифікатор доступу <code>public</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Color</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">red</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">green</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">blue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як можна ініціалізувати структуру:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// без виводу типу</span>
<span class="n">Color</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span>  <span class="c1">// або Color c1 = {};</span>
<span class="n">Color</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">green</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">};</span>

<span class="c1">// з виводом типу</span>
<span class="kd">var</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span>
<span class="kd">var</span> <span class="n">c5</span> <span class="o">=</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">green</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Структури виділяються в стеку/вбудовано і копіюються при присвоєнні.</p></div>
<div class="paragraph"><p>Щоб визначити масив структур, перегляньте FAQ.</p></div>
</div>
<div class="sect3">
<h4 id="__11">Класи</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ClassName</span> <span class="o">:</span> <span class="n">SuperClassName</span><span class="p">,</span> <span class="n">InterfaceName</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає клас, тобто тип посилання. На відміну від структур, екземпляри класів виділяються в купі. Існує набагато більше синтаксису, пов’язаного з класами, про що більш докладно йдеться у розділі про об’єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect3">
<h4 id="__12">Інтерфейси</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">InterfaceName</span> <span class="o">:</span> <span class="n">SuperInterfaceName</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає інтерфейс, тобто тип, примірник якого не створюється. Для того, щоб створити екземпляр інтерфейсу, ви повинні спочатку реалізувати його абстрактні методи в не-абстрактному класі. Інтерфейси Vala є більш потужними, ніж інтерфейси Java або C#. Насправді їх можна використовувати як міксини. Деталі інтерфейсів описані в розділі про об'єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect3">
<h4 id="___10">Атрибути коду</h4>
<div class="paragraph"><p>Атрибути коду вказують деталі компілятора Vala про те, як повинен працювати код на цільовій платформі. Їх синтаксис є <code>[AttributeName]</code> або <code>[AttributeName (param1 = value1, param2 = value2, ...)]</code>.</p></div>
<div class="paragraph"><p>Вони в основному використовуються для прив’язки у файлах <code>vapi</code>, де <code>[CCode (...)]</code> є найбільш помітним прикладом. Інший приклад - атрибут <code>[DBus (...)]</code> для експорту віддалених інтерфейсів через D-Bus.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____2">Об'єктно-орієнтоване програмування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча Vala не змушує вас працювати з об'єктами, деякі можливості не доступні в будь-який інший спосіб. Таким чином, ви, безсумнівно, захочете програмувати в об'єктно-орієнтованому стилі більшу частину часу. Як і в більшості сучасних мов, для визначення власних типів об'єктів ви пишете визначення класу.</p></div>
<div class="paragraph"><p>Визначення класу вказує, які дані має кожен об'єкт його типу, на які ще типи об'єктів можуть містити посилання та які методи можуть бути виконані на ньому. Визначення може містити назву іншого класу, для якого новий має бути підкласом. Екземпляр класу також є екземпляром усіх суперкласів класу, оскільки він успадковує від них усі їхні методи та дані, хоча він може не мати доступу до всього цього сам по собі. Клас також може реалізовувати будь-яку кількість інтерфейсів, що представляють собою набори визначень методів, які повинні бути реалізовані класом - екземпляр класу також є екземпляром кожного інтерфейсу, реалізованого його класом або суперкласами.</p></div>
<div class="paragraph"><p>Класи у Vala можуть також мати <code>static</code> члени. Цей модифікатор дозволяє визначати або дані, або методи як належні до класу в цілому, а не до конкретного його примірника. До таких членів можна отримати доступ, не маючи примірника класу.</p></div>
<div class="sect2">
<h3 id="__13">Основи</h3>
<div class="paragraph"><p>Простий клас можна визначити так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Поля</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">first_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">second_data</span><span class="p">;</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Конструктор</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="n">TestClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">second_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Метод</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;private data: %d&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">second_data</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">second_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код визначає новий тип (який автоматично реєструється в системі типів бібліотеки <code>gobject</code>), який містить три члени. Є два члени даних, цілі числа, визначені вгорі, і один метод під назвою <code>method_1</code>, який повертає ціле число. У декларації класу зазначено, що цей клас є підкласом <code>GLib.Object</code>, а тому його екземпляри є також <code>Object</code>, і містять також усі члени цього типу. Той факт, що цей клас походить від <code>Object</code>, також означає, що є особливості Vala, які можна використовувати для легкого доступу до деяких властивостей об'єкта.</p></div>
<div class="paragraph"><p>Цей клас описується як загальнодоступний (за замовчуванням класи є внутрішніми). Це означає, що на нього можна посилатися безпосередньо з коду за межами цього файлу - якщо ви програміст C glib/gobject, ви визнаєте це еквівалентом визначення класових інтерфейсів у файлі заголовка, який можна включати в інший код.</p></div>
<div class="paragraph"><p>Члени також описуються як <code>public</code> або <code>private</code>. Член <code>first_data</code> є загальнодоступним, тому його можна побачити безпосередньо будь-якому користувачеві класу, і його можна модифікувати, не повідомляючи про це екземпляр. Другий член даних є приватним і на нього може посилатися лише код, що належить до цього класу. Vala підтримує чотири різні модифікатори доступу:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>public</code> Без обмежень доступу
</p>
</li>
<li>
<p>
<code>private</code> Доступ обмежений визначенням класу/структури. Це за замовчуванням, якщо не вказаний модифікатор доступу
</p>
</li>
<li>
<p>
<code>protected</code> Доступ обмежений визначенням класу та будь-яким класом, який успадковується від класу
</p>
</li>
<li>
<p>
<code>internal</code> Доступ обмежений виключно класами, визначеними в одному пакеті
</p>
</li>
</ul></div>
<div class="paragraph"><p>Конструктор ініціалізує нові екземпляри класу. Він має те саме ім'я, що і клас, може приймати нуль або більше аргументів і визначається без типу повернення.</p></div>
<div class="paragraph"><p>Заключна частина цього класу - визначення методу. Цей метод буде називатися <code>method_1</code>, і він повертає ціле число. Оскільки цей метод не є статичним, він може бути виконаний лише на екземплярі цього класу, а тому може отримати доступ до членів цього екземпляра. Це можна зробити за допомогою посилання <code>this</code>, яке завжди вказує на екземпляр, на якому викликається метод. Якщо немає двозначності, цей ідентифікатор за бажанням можна опустити.</p></div>
<div class="paragraph"><p>Ви можете використовувати цей новий клас наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">TestClass</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">();</span>
<span class="n">t</span><span class="p">.</span><span class="n">first_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">t</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__14">Конструювання</h3>
<div class="paragraph"><p>Vala підтримує дві дещо різні схеми конструкторів: схему конструювання в стилі Java/C#, на якій ми зупинимося на даний момент, та схему конструювання в стилі GObject, яка буде описана в розділі в кінці розділу.</p></div>
<div class="paragraph"><p>Vala не підтримує перевантаження конструктора з тих же причин, з яких немає перевантаження методів, а це означає, що в класі може не бути декількох конструкторів з однаковою назвою. Однак це не проблема, оскільки Vala підтримує іменовані конструктори. Якщо ви хочете запропонувати кілька конструкторів, ви можете дати їм додаткові назви:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Button</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">.</span><span class="n">with_label</span><span class="p">(</span><span class="kt">string</span> <span class="n">label</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">.</span><span class="n">from_stock</span><span class="p">(</span><span class="kt">string</span> <span class="n">stock_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення примірника аналогічне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Button</span><span class="p">();</span>
<span class="k">new</span> <span class="n">Button</span><span class="p">.</span><span class="n">with_label</span><span class="p">(</span><span class="s">&quot;Click me&quot;</span><span class="p">);</span>
<span class="k">new</span> <span class="n">Button</span><span class="p">.</span><span class="n">from_stock</span><span class="p">(</span><span class="n">Gtk</span><span class="p">.</span><span class="n">STOCK_OK</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зціпити конструктори за допомогою <code>this()</code> або <code>this.name_extension()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">.</span><span class="n">polar</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">double</span> <span class="n">angle</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="mf">5.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
    <span class="kd">var</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">.</span><span class="n">polar</span><span class="p">(</span><span class="mf">5.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__15">Знищення</h3>
<div class="paragraph"><p>Хоча Vala управляє пам'яттю для вас, можливо, вам доведеться додати свій власний деструктор, якщо ви вирішите зробити ручне управління пам’яттю за допомогою покажчиків (докладніше про це пізніше) або якщо вам доведеться вивільнити інші ресурси. Синтаксис такий самий, як у C# або C++:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="o">~</span><span class="n">Demo</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;in destructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки управління пам'яттю Vala базується на підрахунку посилань замість відстеження збору сміття, деструктори детерміновані і можуть використовуватися для реалізації схеми RAII для управління ресурсами (закриття потоків, підключень до бази даних, &#8230;).</p></div>
</div>
<div class="sect2">
<h3 id="__16">Сигнали</h3>
<div class="paragraph"><p>Сигнали - це система, що надається класом <code>Object</code> в GLib, і стає легко доступною в Vala для всіх нащадків <code>Object</code>. Сигнали можна пояснити програмістам на C# як події, або програмістам Java як альтернативний спосіб реалізації слухачів подій. Коротше кажучи, сигнал є просто способом виконання довільної кількості зовнішньо однакових методів (тобто тих, що мають однакову сигнатуру) приблизно в один і той же час. Насправді методи виконання є внутрішніми для <code>gobject</code>, і не важливі для програм Vala.</p></div>
<div class="paragraph"><p>Сигнал визначається як член класу і виглядає аналогічно методу без тіла. Потім обробники сигналів можуть бути додані до сигналу за допомогою методу <code>connect()</code>. Для того, щоб зразу перейти до справи, наступний приклад також вводить лямбда-вирази, дуже корисний спосіб написання коду обробки сигналу у Vala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">signal</span> <span class="kt">void</span> <span class="n">sig_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Test</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="p">();</span>

        <span class="n">t1</span><span class="p">.</span><span class="n">sig_1</span><span class="p">.</span><span class="n">connect</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
        <span class="p">});</span>

        <span class="n">t1</span><span class="p">.</span><span class="n">sig_1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код вводить новий клас під назвою <code>Test</code>, використовуючи знайомий синтаксис. Першим членом цього класу є сигнал, який називається <code>sig_1</code> і визначається як передача цілого числа. В методі <code>main</code> цієї програми ми спочатку створюємо екземпляр - це вимога, оскільки сигнали завжди належать до примірників класів. Далі ми призначаємо оброблювач сигналу нашого примірника <code>sig_1</code>, який ми визначаємо у вбудованому вигляді як лямбда-вираз. Визначення зазначає, що метод отримає два аргументи, які ми називаємо <code>"t"</code> і <code>"a"</code>, але не надаємо для них типи. Ми можемо бути такі стислі, оскільки Vala вже знає визначення сигналу і тому може зрозуміти, які типи потрібні.</p></div>
<div class="paragraph"><p>Причина, що для обробника є два параметри, полягає в тому, що щоразу, коли випромінюється сигнал, об'єкт, на який він випромінюється, передається як перший аргумент обробнику. Другий аргумент - той, що надає сигнал.</p></div>
<div class="paragraph"><p>Нарешті ми нетерплячі і вирішуємо випромінити сигнал. Ми робимо це, називаючи сигнал так, ніби це метод нашого класу, і дозволяємо <code>gobject</code> піклуватися про пересилання повідомлення всім доданим обробникам. Розуміння механізму, який використовується для цього, не потрібне щоб використовувати сигнали Vala.</p></div>
<div class="paragraph"><p>NB: Наразі модифікатор доступу <code>public</code> є єдиним можливим варіантом - всі сигнали можуть бути як підключені, так і випромінювані будь-яким фрагментом коду.</p></div>
<div class="paragraph"><p>Примітка. Починаючи з квітня 2010 р. cигнали можна анотувати будь-якою комбінацією прапорів:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[Signal (action=true, detailed=true, run=true, no_recurse=true, no_hooks=true)]
public signal void sig_1 ();</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="__17">Властивості</h3>
<div class="paragraph"><p>Це гарна об'єктно-орієнтована практика програмування, щоб приховувати деталі реалізації від користувачів ваших класів (принцип приховування інформації), щоб потім можна було змінити внутрішні деталі, не порушуючи загальнодоступний API. Однією з практик є створення полів приватними та надання методів доступу для отримання та встановлення їх значень (геттери та сетери).</p></div>
<div class="paragraph"><p>Якщо ви програміст Java, ви, напевно, придумаєте щось подібне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">get_age</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">set_age</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це працює, але Vala може зробити краще. Проблема полягає в тому, що ці методи громіздкі. Припустимо, що ви хочете збільшити вік людини на один рік:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
<span class="n">alice</span><span class="p">.</span><span class="n">set_age</span><span class="p">(</span><span class="n">alice</span><span class="p">.</span><span class="n">get_age</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут вступають властивості:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">_age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>  <span class="c1">// префікс з підкреслення, щоб уникнути конфлікту з властивістю</span>

    <span class="cm">/* Властивість */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_age</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">_age</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей синтаксис повинен бути знайомий програмістам C#. Властивість має блоки <code>get</code> та <code>set</code> для отримання та встановлення. <code>value</code> - це ключове слово, яке представляє нове значення, яке слід призначити властивості.</p></div>
<div class="paragraph"><p>Тепер ви можете отримати доступ до властивості так, ніби це публічне поле. Але за лаштунками виконується код у блоках <code>get</code> і <code>set</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
<span class="n">alice</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">alice</span><span class="p">.</span><span class="n">age</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// або навіть коротше:</span>
<span class="n">alice</span><span class="p">.</span><span class="n">age</span><span class="o">++</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконуєте лише стандартну реалізацію, як показано вище, ви можете записати властивість ще коротше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="cm">/* Property with standard getter and setter and default value */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За допомогою властивостей ви можете змінювати внутрішню роботу класів без зміни загальнодоступного API. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kt">int</span> <span class="n">current_year</span> <span class="o">=</span> <span class="mi">2525</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">year_of_birth</span> <span class="o">=</span> <span class="mi">2493</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current_year</span> <span class="o">-</span> <span class="n">year_of_birth</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">year_of_birth</span> <span class="o">=</span> <span class="n">current_year</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього разу вік обчислюється на льоту від року народження. Зауважте, що ви можете зробити більше, ніж просто простий змінний доступ або призначення в блоках <code>get</code> і <code>set</code>. Ви можете зробити доступ до бази даних, ведення журналів, оновлення кешу тощо.</p></div>
<div class="paragraph"><p>Якщо ви хочете зробити властивість лише для читання для користувачів класу, ви повинні зробити сетер приватним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">private</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ж ви можете залишити встановлений блок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">_age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_age</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Властивості можуть мати не лише ім'я, але й короткий опис (називається нік) та довгий опис (називається пояснення). Ви можете помітити їх спеціальним атрибутом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Description</span><span class="p">(</span><span class="n">nick</span> <span class="o">=</span> <span class="s">&quot;age in years&quot;</span><span class="p">,</span> <span class="n">blurb</span> <span class="o">=</span> <span class="s">&quot;This is the person&#39;s age in years&quot;</span><span class="p">)]</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Властивості та їх додаткові описи можна запитувати під час виконання. Деякі програми, такі як графічний дизайнер інтерфейсу Glade, використовують цю інформацію. Таким чином Glade може представити зрозумілі людині описи властивостей GTK + віджетів.</p></div>
<div class="paragraph"><p>Кожен екземпляр класу, похідного від <code>GLib.Object</code>, має сигнал, який називається <code>notify</code>. Цей сигнал випромінюється щоразу, коли властивість його об'єкта змінюється. Таким чином, ви можете підключитися до цього сигналу, якщо вас взагалі цікавлять сповіщення змін:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">connect</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Property &#39;%s&#39; has changed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p><code>s</code> - джерело сигналу (<code>obj</code> у цьому прикладі), <code>p</code> - інформація про властивості типу <code>ParamSpec</code> для зміненої властивості. Якщо вас цікавлять лише сповіщення про зміну одної властивості, ви можете використовувати цей синтаксис:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">alice</span><span class="p">.</span><span class="n">notify</span><span class="p">[</span><span class="s">&quot;age&quot;</span><span class="p">].</span><span class="n">connect</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;age has changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що в цьому випадку ви повинні використовувати рядкове представлення імені властивості, де підкреслення замінюється тире: <code>my_property_name</code> стає <code>"my-property-name"</code> у цьому поданні, що є домовленістю іменування властивостей в <code>GObject</code>.</p></div>
<div class="paragraph"><p>Повідомлення про зміну можна відключити тегом атрибута <code>CCode</code> безпосередньо перед оголошенням властивості:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyObject</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="p">[</span><span class="nd">CCode</span><span class="p">(</span><span class="n">notify</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)]</span>
<span class="c1">// сигнал сповіщення НЕ випромінюється при зміні властивості</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">without_notification</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// сигнал зміни випромінюється при зміні властивості</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">with_notification</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує ще один тип властивостей, які називаються властивостями конструкції, які описані далі в розділі про побудову в стилі <code>gobject</code>.</p></div>
<div class="paragraph"><p>Примітка: якщо ваш ресурс має тип <code>struct</code>, щоб отримати значення властивості за допомогою <code>Object.get()</code>, ви повинні оголосити свою змінну як приклад нижче</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Color</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kt">uint32</span> <span class="n">argb</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span> <span class="n">argb</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Shape</span><span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="n">Color</span> <span class="n">c</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Color</span><span class="o">?</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">null</span><span class="p">;</span>
    <span class="n">Shape</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Shape</span><span class="p">();</span>
    <span class="n">s</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="k">out</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <code>c</code> - це посилання замість екземпляра <code>Color</code> у стеку. Що ви передали до <code>s.get()</code> - це <code>"Color **"</code> замість <code>"Color *"</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__18">Наслідування</h3>
<div class="paragraph"><p>У Vala клас може походити з одного або нуля інших класів. На практиці це, ймовірно, завжди є одним, хоча неявного спадкування немає, як у мовах, таких як Java.</p></div>
<div class="paragraph"><p>Визначаючи клас, який успадковує від іншого, ви створюєте взаємозв'язок між класами, де екземпляри підкласу також є екземплярами надкласу. Це означає, що операції над екземплярами надкласу також застосовні на екземплярах підкласу. Таким чином, там, де потрібен екземпляр надкласу, може бути підставлений екземпляр підкласу.</p></div>
<div class="paragraph"><p>Під час написання визначення класу можна здійснювати точний контроль над тим, хто може отримати доступ до того, які методи та дані в об’єкті. Наступний приклад демонструє цілий ряд таких варіантів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">SuperClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="n">protected_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">public_static_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="n">SubClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">base</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>data</code> є членом даних екземпляра <code>SuperClass</code>. Воно буде членом цього типу в кожному екземплярі <code>SuperClass</code>, і він оголошений <code>private</code>, тому він буде доступний лише за допомогою коду, що є частиною <code>SuperClass</code>.</p></div>
<div class="paragraph"><p><code>protected_method</code> - це метод екземпляра <code>SuperClass</code>. Ви зможете виконати цей метод лише екземпляром <code>SuperClass</code> або одного з його підкласів, і лише з коду, що належить <code>SuperClass</code> або одного з його підкласів - це останнє правило є результатом модифікатора <code>protected</code>.</p></div>
<div class="paragraph"><p><code>public_static_method</code> має два модифікатори. Модифікатор <code>static</code> означає, що цей метод може бути викликаний без володіння екземпляром <code>SuperClass</code> або одного з його підкласів. Як результат, цей метод не матиме доступу до посилання <code>this</code> при його виконанні. Модифікатор <code>public</code> означає, що цей метод можна викликати з будь-якого коду, незалежно від його зв’язку із <code>SuperClass</code> або його підкласами.</p></div>
<div class="paragraph"><p>З огляду на ці визначення, екземпляр <code>SubClass</code> буде містити всіх трьох членів <code>SuperClass</code>, але матиме змогу отримати доступ лише до не-приватних членів. Зовнішній код зможе отримати доступ лише до публічного методу.</p></div>
<div class="paragraph"><p>За допомогою <code>base</code> конструктор підкласу може звертатись до конструктора базового класу.</p></div>
</div>
<div class="sect2">
<h3 id="___11">Абстрактні класи</h3>
<div class="paragraph"><p>Існує ще один модифікатор методів, який називається <code>abstract</code>. Цей модифікатор дозволяє описати метод, який фактично не реалізований у класі. Натомість він повинен бути реалізований підкласами, перш ніж його можна буде викликати. Це дозволяє визначити операції, які можуть бути викликані у всіх екземплярах типу, забезпечуючи при цьому, щоб всі більш конкретні типи надавати власну версію функціоналу.</p></div>
<div class="paragraph"><p>Клас, що містить абстрактні методи, також повинен бути оголошений абстрактним. Результатом цього є запобігання будь-якої інстанцінацї (створення примірнику) типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*chomp chomp*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tiger</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*roar*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Duck</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*quack*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація абстрактного методу повинна бути позначена <code>override</code>. Властивості також можуть бути абстрактними.</p></div>
<div class="sect3">
<h4 id="___12">Віртуальні методи</h4>
<div class="paragraph"><p>Віртуальний метод дозволяє визначити реалізацію за замовчуванням на абстрактні класи та дозволяє похідним класам перекрити свою поведінку. Це відрізняється від приховування методів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Caller</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">);</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">reset</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;No Name&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContactCV</span> <span class="o">:</span> <span class="n">Caller</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">)</span>
   <span class="p">{</span>
     <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ContactCV - &quot;</span> <span class="o">+</span> <span class="n">new_name</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">reset</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ContactCV-Name&quot;</span><span class="p">;</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CotactCV.reset () implementation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contact</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">)</span>
   <span class="p">{</span>
     <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Contact - &quot;</span> <span class="o">+</span> <span class="n">new_name</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Contact</span> <span class="p">();</span>
      <span class="n">c</span><span class="p">.</span><span class="n">update</span> <span class="p">(</span><span class="s">&quot;John Strauss&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Name: $(c.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">c</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Reset Name: $(c.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

      <span class="kd">var</span> <span class="n">cv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ContactCV</span> <span class="p">();</span>
      <span class="n">cv</span><span class="p">.</span><span class="n">update</span> <span class="p">(</span><span class="s">&quot;Xochitl Calva&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Name: $(cv.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">cv</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Reset Name: $(cv.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите у наведеному вище прикладі, <code>Caller</code> - це абстрактний клас, що визначає як абстрактну властивість, так і метод, але додає віртуальний метод, який може бути замінений похідними класами. Клас <code>Contact</code> реалізує абстрактні методи та властивості <code>Caller</code>, використовуючи при цьому реалізацію за замовчуванням для <code>reset()</code>, уникаючи визначення нового. <code>ContactCV</code> клас реалізує всі абстрактні визначення на <code>Caller</code>, але переосмислює <code>reset()</code>, щоб визначити власну реалізацію.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__19">Інтерфейси</h3>
<div class="paragraph"><p>Клас у Vala може реалізувати будь-яку кількість інтерфейсів. Кожен інтерфейс - це тип, подібний до класу, але такий, примірник якого неможливо створити. "Реалізуючи" один або кілька інтерфейсів, клас може оголосити, що його екземпляри є також екземплярами інтерфейсу, і тому він може використовуватися в будь-якій ситуації, коли очікується екземпляр цього інтерфейсу.</p></div>
<div class="paragraph"><p>Процедура реалізації інтерфейсу така ж, як і для успадкування класів з абстрактними методами - якщо клас повинен бути корисним, він повинен передбачати реалізацію для всіх описаних, але ще не реалізованих, методів.</p></div>
<div class="paragraph"><p>Просте визначення інтерфейсу виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITest</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="n">data_1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код описує інтерфейс <code>ITest</code>, який вимагає <code>GLib.Object</code> як батьківського класу реалізатора і містить два члени. <code>data_1</code> - властивість, як описано вище, за винятком того, що вона оголошена абстрактною. Таким чином, Vala не буде реалізовувати цю властивість, а натомість вимагатиме, щоб класи, що реалізують цей інтерфейс, мали властивість під назвою <code>data_1</code>, яка має обоє аксесори, <code>set</code> та <code>get</code> - потрібно, щоб це було абстрактним, оскільки інтерфейс не може мати членів даних. Другий член <code>method_1</code> - це метод. Тут декларовано, що цей метод повинен бути реалізований класами, які реалізують цей інтерфейс.</p></div>
<div class="paragraph"><p>Найпростіша можлива повна реалізація цього інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test1</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">ITest</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">data_1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>І може використовуватися наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test1</span><span class="p">();</span>
<span class="n">t</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>

<span class="n">ITest</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
<div class="sect3">
<h4 id="___13">Визначення передумов</h4>
<div class="paragraph"><p>Інтерфейси у Vala не можуть успадковувати інші інтерфейси, але вони можуть оголосити інші інтерфейси необхідними умовами, що працює приблизно так само. Наприклад, може бути бажаним сказати, що будь-який клас, який реалізує інтерфейс <code>List</code>, повинен також реалізовувати інтерфейси <code>Collection</code> і <code>Traverable</code>. Синтаксис для цього точно такий же, як для опису реалізації інтерфейсу в класах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span> <span class="o">:</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Traversable</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення <code>List</code> не може бути реалізовано в класі без того, щоб <code>Collection</code> також була реалізована, і тому Vala застосовує наступний стиль декларування для класу, який бажає реалізувати <code>List</code>, де повинні бути описані всі реалізовані інтерфейси:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">List</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерфейси Vala також можуть мати клас як необхідну умову. Якщо ім'я класу вказано у списку передумов, інтерфейс може бути реалізований лише у класах, що походять від цього попереднього класу. Це часто використовується для того, щоб екземпляр інтерфейсу також був підкласом <code>GLib.Object</code>, і тому інтерфейс можна використовувати, наприклад, як тип властивості.</p></div>
<div class="paragraph"><p>Те, що інтерфейси не можуть успадковувати інші інтерфейси, є здебільшого лише технічною відмінністю - на практиці система Vala працює так само, як і інші мови в цій області, але з додатковою особливістю обов'язкових класів.</p></div>
</div>
<div class="sect3">
<h4 id="______">Визначення реалізації за замовчуванням у методах</h4>
<div class="paragraph"><p>Існує ще одна важлива відмінність між інтерфейсами Vala та інтерфейсами Java/C#: інтерфейси Vala можуть мати не-абстрактні методи.</p></div>
<div class="paragraph"><p>Vala фактично дозволяє реалізацію методів в інтерфейсах, і тоді метод із реалізацією за замовчуванням повинен бути оголошений як віртуальний. У зв'язку з цим інтерфейси Vala можуть виступати в ролі міксинів. Це обмежена форма множинного успадкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерфейс <code>Callable</code> визначає абстрактне властивість, що називається <code>answering</code>, де будь-який клас, що реалізує цей інтерфейс, може відстежувати стан виклику, деталі щодо відповіді на виклик є деталями реалізатора, але <code>hang</code> визначає реалізацію за замовчуванням, щоб встановити відповідь на помилку під час покладеної слухавки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Phone</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
    <span class="cm">/* реалізація коду відповіді */</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Phone</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Під час компіляції та запуску ви виявите, що клас <code>Phone</code> насправді не реалізує метод <code>Callable.hang()</code>, але він може його використовувати, тоді результат - повідомлення <code>"Hang done"</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TechPhone</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
     <span class="cm">/* реалізація коду відповіді */</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;TechPhone.hang () implementation!&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку <code>TechPhone</code> - це ще одна реалізація для <code>Callable</code>, тоді при виклику методу <code>hang()</code> на екземплярі <code>TechPhone</code> він завжди поверне помилкове значення та надрукує повідомлення <code>"TechPhone.hang () implementation!"</code></p></div>
</div>
<div class="sect3">
<h4 id="__20">Властивості</h4>
<div class="paragraph"><p>Інтерфейс може визначати властивості, які необхідно реалізувати для класів. Клас реалізатора повинен визначати властивість з однаковим дозволом сигнатури та доступу для <code>get</code> та <code>set</code>.</p></div>
<div class="paragraph"><p>Як і для будь-якої властивості <code>GObject</code>, ви можете визначити тіло <code>set</code> і <code>get</code> в класі реалізатора. Якщо не використовується тіло, <code>set</code> і <code>get</code> отримують значення за замовчуванням. Якщо вказано, ви повинні визначити приватне поле для зберігання значень властивостей, які будуть використовуватися зовні або всередині класу.</p></div>
<div class="paragraph"><p>Визначення інтерфейсу <code>Callable</code> визначає властивість <code>answering</code>. У цьому випадку цей інтерфейс визначає <code>answering</code> із захищеним <code>set</code>, що дозволяє створити властивості лише для читання для будь-якого об'єкта, використовуючи екземпляр <code>Callable</code>, але дозволяє розробникам класів записувати на нього значення, як це робить клас <code>TechPhone</code>, коли реалізує метод <code>hang()</code>.</p></div>
</div>
<div class="sect3">
<h4 id="_____3">Міксин та множинне спадкування</h4>
<div class="paragraph"><p>Як описано вище, Vala, хоча і базується на C і <code>GObject</code>, може забезпечити обмежений механізм множинного успадкування шляхом додавання віртуальних методів до інтерфейсів. Можна додати деякі способи визначення реалізацій методів за замовчуванням у класі реалізатора інтерфейсу, та дозволити похідним класам переосмислити ці методи.</p></div>
<div class="paragraph"><p>Якщо ви визначите віртуальний метод в інтерфейсі і реалізуєте його в класі, ви не можете перекрити метод інтерфейсу, не залишаючи похідні класи не в змозі отримати доступ до методу інтерфейсу за замовчуванням. Розглянемо наступний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">bool</span> <span class="n">default_hang</span> <span class="p">(</span><span class="n">Callable</span> <span class="n">call</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Callable.hang()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">call</span><span class="p">.</span><span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Caller</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
     <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Caller.answer()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
     <span class="n">answering</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
     <span class="n">hang</span> <span class="p">();</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Callable</span><span class="p">.</span><span class="n">default_hang</span> <span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TechPhone</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
        <span class="kd">public</span> <span class="kt">string</span> <span class="n">number</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Phone</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Phone.hang()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Callable</span><span class="p">)</span> <span class="k">new</span> <span class="n">Phone</span> <span class="p">();</span>
      <span class="n">f</span><span class="p">.</span><span class="n">answer</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

      <span class="kd">var</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Callable</span><span class="p">)</span> <span class="k">new</span> <span class="n">TechPhone</span> <span class="p">();</span>
      <span class="n">t</span><span class="p">.</span><span class="n">answer</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Tech Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Tech Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку ми визначили інтерфейс <code>Callable</code> з реалізацією за замовчуванням для <code>abstract bool hang()</code> під назвою <code>default_hang</code>, це може бути статичний або віртуальний метод. Тоді <code>Caller</code> є базовим класом, що реалізує <code>Callable</code> для класів <code>TechPhone</code> і <code>Phone</code>, при чому метод <code>Caller.hang()</code> просто викликає реалізацію <code>Callable</code> за замовчуванням. <code>TechPhone</code> нічого не робить і просто приймає <code>Caller</code> як базовий клас, використовуючи реалізацію методу за замовчуванням; але <code>Phone</code> переосмислює <code>Caller.hang()</code>, і це змушує використовувати його власну реалізацію, що дозволяє завжди викликати її, навіть якщо об'єкт приведений до <code>Callable</code>.</p></div>
</div>
<div class="sect3">
<h4 id="____5">Явна реалізація методу</h4>
<div class="paragraph"><p>Явна реалізація методу інтерфейсу дозволяє реалізувати два інтерфейси, які мають методи (а не властивості) з однаковим іменем. Приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="n">m</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">Bar</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">string</span> <span class="n">m</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Cls</span><span class="o">:</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kt">int</span> <span class="n">Foo</span><span class="p">.</span><span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="kd">public</span> <span class="kt">string</span> <span class="n">Bar</span><span class="p">.</span><span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&quot;bar&quot;</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="n">cls</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cls</span> <span class="p">();</span>
 <span class="n">message</span> <span class="p">(</span><span class="s">&quot;%d %s&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">Foo</span><span class="p">)</span> <span class="n">cls</span><span class="p">).</span><span class="n">m</span><span class="p">(),</span> <span class="p">((</span><span class="n">Bar</span><span class="p">)</span> <span class="n">cls</span><span class="p">).</span><span class="n">m</span><span class="p">());</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Видасть <code>10 bar</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__21">Поліморфізм</h4>
<div class="paragraph"><p>Поліморфізм описує спосіб використання одного і того ж об'єкта, як ніби це більше ніж один окремий тип. Деякі з описаних тут прийомів дозволяють припустити, як це можливо у Vala: екземпляр класу може використовуватися як екземпляр надкласу або будь-яких реалізованих інтерфейсів, не знаючи його фактичного типу.</p></div>
<div class="paragraph"><p>Логічне розширення цієї потужності полягає в тому, щоб дозволити підтипу поводитись по-різному зі своїм батьківським типом, хоча це виглядає точно так само. Це поняття не дуже легко пояснити, тому я розпочну з прикладу того, що станеться, якщо ви безпосередньо не націлитеся на цю мету:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SuperClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SubClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обидва ці класи реалізують метод, який називається <code>method_1</code>, і <code>SubClass</code>, таким чином, містить два методи, звані <code>method_1</code>, оскільки він успадковує один із <code>SuperClass</code>. Кожен із них може бути викликаний, як показує наступний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">SubClass</span> <span class="n">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubClass</span><span class="p">();</span>
<span class="n">o1</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
<span class="n">SuperClass</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">o1</span><span class="p">;</span>
<span class="n">o2</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Це фактично призведе до виклику двох різних методів. Другий рядок вважає, що <code>o1</code> є <code>SubClass</code> і визиває версію методу цього класу. Четвертий рядок вважає, що <code>o2</code> є <code>SuperClass</code> і визиває версію методу цього класу.</p></div>
<div class="paragraph"><p>Проблема, яку розкриває цей приклад, полягає в тому, що будь-який код, що містить посилання на <code>SuperClass</code>, буде викликати методи, фактично описані в цьому класі, навіть якщо насправді об'єкті є підкласом. Спосіб зміни такої поведінки - це використання віртуальних методів. Розглянемо наступну переписану версію останнього прикладу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SuperClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SubClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли цей код використовується так само, як і раніше, <code>method_1</code> з <code>SubClass</code> буде викликаний двічі. Це тому, що ми сказали системі, що <code>method_1</code> - це віртуальний метод, тобто, якщо його буде замінено на підкласі, ця нова версія завжди буде виконуватися на екземплярах цього підкласу, незалежно від знань викликаючого.</p></div>
<div class="paragraph"><p>Ця відмінність, мабуть, знайома програмістам деяких мов, таких як C++, але насправді це протилежність мовам стилю Java, в яких потрібно вжити заходів, щоб запобігти віртуальності методу.</p></div>
<div class="paragraph"><p>Напевно, зараз ви також побачили, що коли метод оголошується абстрактним, він також повинен бути віртуальним. В іншому випадку неможливо виконати цей метод з урахуванням очевидного екземпляра типу, як він був оголошений. При впровадженні абстрактного методу в підкласі, ви можете вирішити оголосити реалізацію як <code>override</code>, передаючи таким чином віртуальний характер методу, і дозволяючи підтипам робити те саме, якщо вони бажають.</p></div>
<div class="paragraph"><p>Також можливо реалізувати методи інтерфейсу таким чином, щоб підкласи могли змінити реалізацію. Процес у цьому випадку полягає у початковій реалізації, щоб оголосити реалізацію методу віртуальною, і тоді підкласи можуть змінювати її за потребою.</p></div>
<div class="paragraph"><p>Під час написання класу прийнято використовувати функціонал, визначений у класі, від якого ви успадкували. Це складно, коли назва методу використовується у дереві спадкування для вашого класу більше одного разу. Для цього Vala надає ключове слово <code>base</code>. Найпоширеніший випадок, коли ви перекрили віртуальний метод, щоб забезпечити додаткову функціональність, але все ж потрібен метод батьківського класу. Наступний приклад показує цей випадок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">method_name</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">base</span><span class="p">.</span><span class="n">method_name</span><span class="p">();</span>
    <span class="n">extra_task</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala також дозволяє властивостям бути віртуальними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">string</span> <span class="n">prop_1</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;SuperClass.prop_1&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">prop_1</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;SubClass.prop_1&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="___14">Приховування методів</h4>
<div class="paragraph"><p>За допомогою модифікатора <code>new</code> ви можете приховати успадкований метод новим методом з тим же ім’ям. Новий метод може мати інший підпис. Приховування методу не слід плутати з перекриттям методу, оскільки приховування методу не проявляє поліморфної поведінки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="k">:</span> <span class="kt">Object</span> <span class="o">{</span>
    <span class="kt">public</span> <span class="kt">void</span> <span class="kt">my_method</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
<span class="o">}</span>

<span class="kt">class</span> <span class="kt">Bar</span> <span class="kt">:</span> <span class="kt">Foo</span> <span class="o">{</span>
    <span class="kt">public</span> <span class="kt">new</span> <span class="kt">void</span> <span class="kt">my_method</span><span class="o">()</span> <span class="o">{</span> <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви все ще можете викликати оригінальний метод, перейшовши на базовий клас або інтерфейс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">bar</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Bar</span><span class="o">();</span>
    <span class="n">bar</span><span class="o">.</span><span class="n">my_method</span><span class="o">();</span>
    <span class="o">(</span><span class="n">bar</span> <span class="n">as</span> <span class="nc">Foo</span><span class="o">).</span><span class="n">my_method</span><span class="o">();</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect2">
<h3 id="______2">Інформація про тип часу виконання</h3>
<div class="paragraph"><p>Оскільки класи Vala реєструються під час виконання і кожен екземпляр несе інформацію про тип, ви можете динамічно перевіряти тип об'єкта за допомогою оператора <code>is</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">bool</span> <span class="n">b</span> <span class="k">=</span> <span class="k">object</span> <span class="nc">is</span> <span class="nc">SomeTypeName</span><span class="o">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете отримати інформацію про типи об'єктів, використовуючи метод <code>get_type()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Type</span> <span class="k">type</span> <span class="o">=</span> <span class="n">object</span><span class="o">.</span><span class="n">get_type</span><span class="o">();</span>
<span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;%s\n&quot;</span><span class="o">,</span> <span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="o">());</span>
</pre></div></div></div>
<div class="paragraph"><p>За допомогою оператора <code>typeof()</code> ви можете отримати інформацію про тип безпосередньо. З цієї інформації про тип можна пізніше створити нові примірники за допомогою <code>Object.new()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Type</span> <span class="k">type</span> <span class="o">=</span> <span class="n">typeof</span><span class="o">(</span><span class="nc">Foo</span><span class="o">);</span>
<span class="nc">Foo</span> <span class="n">foo</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Foo</span><span class="o">)</span> <span class="nc">Object</span><span class="o">.</span><span class="k">new</span><span class="o">(</span><span class="n">type</span><span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Який конструктор буде визиватися? Це блок <code>construct {}</code>, який буде описано в розділі про побудову в стилі <code>gobject</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____6">Динамічне приведення типів</h3>
<div class="paragraph"><p>Для динамічного приведення змінна доповнюється виразом постфікса <code>as DesiredTypeName</code>. Vala включить перевірку типу виконання, щоб переконатися, що цей кастинг є розумним - якщо це нелегальний кастинг, буде повернуто значення <code>null</code>. Однак для цього потрібно, щоб тип джерела, так і цільовий тип, були типами посилання.</p></div>
<div class="paragraph"><p>Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Button</span> <span class="n">b</span> <span class="k">=</span> <span class="n">widget</span> <span class="n">as</span> <span class="nc">Button</span><span class="o">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо з якихось причин клас екземпляра віджета не є класом <code>Button</code> або одним із його підкласів, або не реалізує інтерфейс <code>Button</code>, <code>b</code> буде <code>null</code>. Цей кастинг еквівалентний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Button</span> <span class="n">b</span> <span class="k">=</span> <span class="o">(</span><span class="n">widget</span> <span class="n">is</span> <span class="nc">Button</span><span class="o">)</span> <span class="o">?</span> <span class="o">(</span><span class="nc">Button</span><span class="o">)</span> <span class="n">widget</span> <span class="k">:</span> <span class="kt">null</span><span class="o">;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__22">Дженеріки</h3>
<div class="paragraph"><p>Vala включає систему дженериків часу виконання, за якою конкретний екземпляр класу може бути обмежений певним типом або набором типів, обраних під час створення. Це обмеження зазвичай використовується для того, щоб вимагати, щоб дані, що зберігаються в об'єкті, мали певний тип, наприклад, для реалізації списку об'єктів певного типу. У цьому випадку Vala має переконатись, що до списку можуть бути додані лише об'єкти запитуваного типу, і що при виборці всі об'єкти будуть приведені до цього типу.</p></div>
<div class="paragraph"><p>У Vala дженерики обробляються під час роботи програми. Коли ви визначаєте клас, який може бути обмежений типом, існує лише один клас, але кожен примірник налаштовується індивідуально. Це відрізняється від C ++, що створює новий клас для кожного необхідного обмеження типу - Vala схожий на систему, що використовується Java. Це має різні наслідки, найголовніше: статичні члени загальні за типом у цілому, незалежно від обмежень, що ставляться до кожного екземпляра; і що для класу і підкласу, дженерік, уточнений підкласом, може бути використаний як загальний, уточнений класом.</p></div>
<div class="paragraph"><p>Наступний код демонструє, як використовувати систему дженеріків для визначення мінімального класу обгортки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span> <span class="k">:</span> <span class="kt">GLib.Object</span> <span class="o">{</span>
    <span class="kt">private</span> <span class="kt">G</span> <span class="kt">data</span><span class="o">;</span>

    <span class="kt">public</span> <span class="kt">void</span> <span class="kt">set_data</span><span class="o">(</span><span class="kt">G</span> <span class="kt">data</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">this.data</span> <span class="o">=</span> <span class="kt">data</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">G</span> <span class="n">get_data</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="n">data</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас <code>Wrapper</code> повинен бути обмежений типом, щоб його інстанціювати - у цьому випадку тип буде ідентифікований як <code>G</code>, тому екземпляри цього класу будуть зберігати один об'єкт типу <code>G</code> та мати методи для встановки або отримання цього об’єкта. (Причиною цього конкретного прикладу є надання пояснення, що в даний час ддженерік клас не може використовувати властивості свого типу обмеження, і тому цей клас має прості методи отримання та встановлення.)</p></div>
<div class="paragraph"><p>Для інстанцінації цього класу необхідно вибрати тип, наприклад вбудований тип <code>string</code> (у Vala немає обмежень щодо того, який тип може бути використаний у дженеріку). Щоб створити просто скористайтеся цим класом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">wrapper</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;();</span>
<span class="n">wrapper</span><span class="o">.</span><span class="n">set_data</span><span class="o">(</span><span class="s">&quot;test&quot;</span><span class="o">);</span>
<span class="k">var</span> <span class="n">data</span> <span class="k">=</span> <span class="n">wrapper</span><span class="o">.</span><span class="n">get_data</span><span class="o">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Як бачите, коли дані витягуються з обгортки, вони присвоюються ідентифікатору без явного типу. Це можливо, тому що Vala знає, які об’єкти є у кожному екземплярі обгортки, і тому може зробити цю роботу за вас.</p></div>
<div class="paragraph"><p>Те, що Vala не створює декілька класів із загального визначення, означає, що ви можете кодувати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TestClass</span> <span class="k">:</span> <span class="kt">GLib.Object</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kt">void</span> <span class="kt">accept_object_wrapper</span><span class="o">(</span><span class="kt">Wrapper&lt;Glib.Object&gt;</span> <span class="kt">w</span><span class="o">)</span> <span class="o">{</span>
<span class="o">}</span>

<span class="kt">...</span>
<span class="kt">var</span> <span class="kt">test_wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="nc">TestClass</span><span class="o">&gt;();</span>
<span class="n">accept_object_wrapper</span><span class="o">(</span><span class="n">test_wrapper</span><span class="o">);</span>
<span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки всі екземпляри <code>TestClass</code> є також <code>Objects</code>, метод <code>accept_object_wrapper</code> з радістю прийме об'єкт, який йому передається, і буде розглядати його обгорнутий об'єкт, як екземпляр <code>GLib.Object</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____gobject">Побудова в стилі GObject</h3>
<div class="paragraph"><p>As pointed out before, Vala supports an alternative construction scheme that is slightly different to the one described before, but closer to the way GObject construction works. Which one you prefer depends on whether you come from the GObject side or from the Java or C# side. The gobject-style construction scheme introduces some new syntax elements: construct properties, a special Object(&#8230;) call and a construct block. Let&#8217;s take a look at how this works:
Як було зазначено раніше, Vala підтримує альтернативну схему будівництва, яка дещо відрізняється від описаної раніше, але ближче до того, як працює будівництво <code>GObject</code>. Якій з них ви віддаєте перевагу, залежить від того, чи ви просуваєтесь зі сторони <code>GObject</code>, чи з боку Java чи C#. Схема побудови в стилі <code>gobject</code> вводить деякі нові елементи синтаксису: <em>властивості конструкції</em>, спеціальний виклик <code>Object (...)</code> та блок <code>construct</code>. Давайте розглянемо, як це працює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Person</span> <span class="k">:</span> <span class="kt">Object</span> <span class="o">{</span>

    <span class="kt">/*</span> <span class="kt">Властивості</span> <span class="kt">конструкції</span> <span class="kt">*/</span>
    <span class="kt">public</span> <span class="kt">string</span> <span class="kt">name</span> <span class="o">{</span> <span class="kt">get</span><span class="o">;</span> <span class="kt">construct</span><span class="o">;</span> <span class="o">}</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">age</span> <span class="o">{</span> <span class="n">get</span><span class="o">;</span> <span class="n">construct</span> <span class="n">set</span><span class="o">;</span> <span class="o">}</span>

    <span class="n">public</span> <span class="nc">Person</span><span class="o">(</span><span class="n">string</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="nc">Person</span><span class="o">.</span><span class="n">with_age</span><span class="o">(</span><span class="n">string</span> <span class="n">name</span><span class="o">,</span> <span class="n">int</span> <span class="n">years</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Object</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">name</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">years</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">construct</span> <span class="o">{</span>
        <span class="c1">// робити все інше</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;Welcome %s\n&quot;</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="n">name</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За схемою побудови у стилі <code>gobject</code> кожен метод побудови містить лише виклик <code>Object(...)</code> для встановлення так званих властивостей конструкції. Виклик <code>Object (...)</code> приймає змінну кількість названих аргументів у вигляді <code>властивість: значення</code>. Ці властивості повинні бути оголошені як властивості <code>construct</code> або <code>set</code>. Вони будуть встановлені в задані значення, і після цього будуть викликані всі блоки <code>construct {}</code> в ієрархії від <code>GLib.Object</code> до нашого класу.</p></div>
<div class="paragraph"><p>Гарантовано, що блок <code>construct</code> викликається, коли створюється екземпляр цього класу, навіть якщо він створений як підтип. Він не має ані параметрів, ані зворотного значення. У цьому блоці ви можете викликати інші методи та встановити змінні-члени за потребою.</p></div>
<div class="paragraph"><p>Властивості конструювання визначаються так само, як властивості <code>get</code> і <code>set</code>, і тому вони можуть виконувати довільний код при призначенні. Якщо вам потрібно зробити ініціалізацію на основі однієї властивості конструкції, можна написати властивий <code>construct</code> блок для властивості, який буде виконуватися негайно при призначенні та перед будь-яким іншим кодом побудови.</p></div>
<div class="paragraph"><p>Якщо властивість конструкції оголошується без <code>set</code>, то це так звана властивість лише конструкції, це означає, що вона може бути призначена лише при побудові, але вже не після цього. У наведеному вище  прикладі <code>name</code> є такою властивістю лише часу конструкції.</p></div>
<div class="paragraph"><p>Ось підсумок різних типів властивостей разом із номенклатурою, що як правило, міститься в документації бібліотек на основі <code>gobject</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="n">public</span> <span class="n">int</span> <span class="n">a</span> <span class="o">{</span> <span class="n">get</span><span class="o">;</span> <span class="k">private</span> <span class="n">set</span><span class="o">;</span> <span class="o">}</span>    <span class="c1">// Read</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">b</span> <span class="o">{</span> <span class="k">private</span> <span class="n">get</span><span class="o">;</span> <span class="n">set</span><span class="o">;</span> <span class="o">}</span>    <span class="c1">// Write</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">c</span> <span class="o">{</span> <span class="n">get</span><span class="o">;</span> <span class="n">set</span><span class="o">;</span> <span class="o">}</span>            <span class="c1">// Read / Write</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">d</span> <span class="o">{</span> <span class="n">get</span><span class="o">;</span> <span class="n">set</span> <span class="n">construct</span><span class="o">;</span> <span class="o">}</span>  <span class="c1">// Read / Write / Construct</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">e</span> <span class="o">{</span> <span class="n">get</span><span class="o">;</span> <span class="n">construct</span><span class="o">;</span> <span class="o">}</span>      <span class="c1">// Read / Write-Construct-Only</span>
</pre></div></div></div>
<div class="paragraph"><p>У деяких випадках ви також можете виконати якусь дію - не тоді, коли створюються екземпляри класу, - але коли сам клас створений під час виконання <code>GObject</code>. У термінології <code>GObject</code> ми говоримо про фрагмент коду, який виконується всередині функції <code>class_init</code> для відповідного класу. У Java це відоме як статичні блоки ініціалізатора. У Vala це виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="cm">/* Цей фрагмент коду виконується під час реєстрації</span>
<span class="cm">     * класу в системі типу */</span>
    <span class="n">static</span> <span class="n">construct</span> <span class="o">{</span>
      <span class="o">...</span>
    <span class="o">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___15">Додаткові функції</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_____4">Твердження та контрактне програмування</h3>
<div class="paragraph"><p>З твердженнями, програміст може перевіряти припущення під час виконання. Синтаксис - <code>assert(умова)</code>. Якщо твердження не справжнюється, програма завершиться відповідним повідомленням про помилку. Є ще кілька методів твердження в стандартному просторі імен <code>GLib</code>, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assert_not_reached</span><span class="o">()</span>

<span class="n">return_if_fail</span><span class="o">(</span><span class="n">bool</span> <span class="n">expr</span><span class="o">)</span>

<span class="n">return_if_reached</span><span class="o">()</span>

<span class="n">warn_if_fail</span><span class="o">(</span><span class="n">bool</span> <span class="n">expr</span><span class="o">)</span>

<span class="n">warn_if_reached</span><span class="o">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете спокуситись використовувати твердження, щоб перевірити аргументи методу на <code>null</code>. Однак це не обов'язково, оскільки Vala робить це неявно для всіх параметрів, які не позначені <code>?</code> як можливий <code>null</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">method_name</span><span class="o">(</span><span class="nc">Foo</span> <span class="n">foo</span><span class="o">,</span> <span class="nc">Bar</span> <span class="n">bar</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">/</span> <span class="o">*</span> <span class="nc">Не</span> <span class="n">потрібно</span><span class="o">,</span> <span class="nc">Вала</span> <span class="n">це</span> <span class="n">робить</span> <span class="n">за</span> <span class="n">вас</span><span class="k">:</span>
    <span class="kt">return_if_fail</span><span class="o">(</span><span class="kt">foo</span> <span class="kt">!=</span> <span class="kt">null</span><span class="o">);</span>
    <span class="n">return_if_fail</span><span class="o">(</span><span class="n">bar</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">);</span>
    <span class="o">*/</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala підтримує основні функції контрактного програмування. Метод може мати передумови (<code>requires</code>) та постумови (<code>ensures</code>), які повинні бути виконані на початку або в кінці методу відповідно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">double</span> <span class="n">method_name</span><span class="o">(</span><span class="n">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">double</span> <span class="n">d</span><span class="o">)</span>
        <span class="k">requires</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">)</span>
        <span class="k">requires</span> <span class="o">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="o">)</span>
        <span class="n">ensures</span> <span class="o">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="mf">10.0</span><span class="o">)</span>
<span class="o">{</span>
    <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>result</code> - це спеціальна змінна, що представляє повернене значення.</p></div>
</div>
<div class="sect2">
<h3 id="___16">Обробка помилок</h3>
<div class="paragraph"><p>GLib має систему управління винятками часу виконання, що називається <code>GError</code>. Vala переводить це у форму, звичну для сучасних мов програмування, але її реалізація означає, що вона не зовсім така, як у Java або C#. Важливо врахувати, коли використовувати цей тип обробки помилок - <code>GError</code> значною мірою спеціально розроблений для боротьби з помилками, що відновлюються, тобто факторами, які не відомі до запуску програми в реальній системі, і які не є фатальними для виконання . Не слід використовувати <code>GError</code> для проблем, які можна передбачити, наприклад, повідомлення про те, що методу передане недійсне значення. Якщо метод, наприклад, вимагає в якості параметра числа, що перевищує <code>0</code>, він повинен уникати негативних значень, використовуючи методи контрактного програмування, такі як передумови або твердження, описані в попередньому розділі.</p></div>
<div class="paragraph"><p>Помилки Vala - це так звані перевірені винятки, що означає, що помилки повинні бути оброблені в певний момент. Однак якщо ви не виявите помилку, компілятор Vala видасть лише попередження, не зупиняючи процес компіляції.</p></div>
<div class="paragraph"><p>Використання винятків (або помилок у термінології Vala) - це питання:</p></div>
<div class="paragraph"><p>1) Заявити, що метод може призвести до помилки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">my_method</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">IOError</span> <span class="o">{</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>2) Викидання помилки, коли це доречно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">something_went_wrong</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">IOError</span><span class="o">.</span><span class="nc">FILE_NOT_FOUND</span><span class="o">(</span><span class="s">&quot;Requested file could not be found.&quot;</span><span class="o">);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>3) Перехоплення помилки з коду виклику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
    <span class="n">my_method</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">IOError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;Error: %s\n&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>4) Порівняння коду помилки оператором <code>is</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">IOChannel</span> <span class="n">channel</span><span class="o">;</span>
<span class="k">try</span> <span class="o">{</span>
    <span class="n">channel</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">IOChannel</span><span class="o">.</span><span class="n">file</span><span class="o">(</span><span class="s">&quot;/tmp/my_lock&quot;</span><span class="o">,</span> <span class="s">&quot;w&quot;</span><span class="o">);</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">FileError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">e</span> <span class="n">is</span> <span class="nc">FileError</span><span class="o">.</span><span class="nc">EXIST</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">throw</span> <span class="n">e</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="nc">GLib</span><span class="o">.</span><span class="n">error</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">.</span><span class="n">message</span><span class="o">);</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все це виглядає більш-менш, як і в інших мовах, але визначення типів допущених помилок є досить унікальним. Помилки мають три компоненти, відомі як "домен", "код" та повідомлення. Повідомлення, які ми вже бачили, це просто фрагмент тексту, який надається при створенні помилки. Домени помилок описують тип проблеми та прирівнюється до підкласу <code>Exception</code> в Java або подібних. У наведених вище прикладах ми уявили домен помилки під назвою <code>IOError</code>. Третя частина, код помилки - це уточнення, що описує точну різноманітність виниклої проблеми. Кожен домен помилки має один або кілька кодів помилок - у прикладі є код під назвою <code>FILE_NOT_FOUND</code>.</p></div>
<div class="paragraph"><p>Спосіб визначення цієї інформації про типи помилок пов'язаний з реалізацією в <code>glib</code>. Для того, щоб приклади тут працювали, потрібно таке визначення, як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">errordomain</span> <span class="nc">IOError</span> <span class="o">{</span>
    <span class="nc">FILE_NOT_FOUND</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Під час перехоплення помилки ви надаєте домен помилок, в якому хочете перехопити помилки, і якщо помилка в цьому домені виникає, код у обробнику запускається з помилкою, присвоєною наданому імені. З цього об’єкта помилки ви можете отримати код помилки та повідомлення за потребою. Якщо ви хочете вловлювати помилки з більш ніж одного домену, просто надайте додаткові блоки вилову. Існує також необов'язковий блок, який можна розмістити після <code>try</code> та будь-яких <code>catch</code> блоки, <code>finally</code>. Цей код слід виконувати завжди в кінці розділу, незалежно від того, була помилка викинута чи виконані будь-які блоки перехоплення, навіть якщо помилка насправді не оброблялася та буде закинута знову. Це дозволяє, наприклад, звільняти будь-які ресурси, зарезервовані у блоці <code>try</code>, незалежно від будь-яких помилок. Повний приклад цих функцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">errordomain</span> <span class="nc">ErrorType1</span> <span class="o">{</span>
    <span class="nc">CODE_1A</span>
<span class="o">}</span>

<span class="n">public</span> <span class="n">errordomain</span> <span class="nc">ErrorType2</span> <span class="o">{</span>
    <span class="nc">CODE_2A</span><span class="o">,</span>
    <span class="nc">CODE_2B</span>
<span class="o">}</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Test</span> <span class="k">:</span> <span class="kt">GLib.Object</span> <span class="o">{</span>
    <span class="kt">public</span> <span class="kt">static</span> <span class="kt">void</span> <span class="kt">thrower</span><span class="o">()</span> <span class="kt">throws</span> <span class="kt">ErrorType1</span><span class="o">,</span> <span class="kt">ErrorType2</span> <span class="o">{</span>
        <span class="kt">throw</span> <span class="kt">new</span> <span class="kt">ErrorType1.CODE_1A</span><span class="o">(</span><span class="err">&quot;</span><span class="kt">Error</span><span class="err">&quot;</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">catcher</span><span class="o">()</span> <span class="n">throws</span> <span class="nc">ErrorType2</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">thrower</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ErrorType1</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Робота з ErrorType1</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="c1">// Прибирати</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">static</span> <span class="n">int</span> <span class="n">main</span><span class="o">(</span><span class="n">string</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="n">catcher</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ErrorType2</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// Робота з ErrorType2</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">e</span> <span class="n">is</span> <span class="nc">ErrorType2</span><span class="o">.</span><span class="nc">CODE_2B</span><span class="o">)</span> <span class="o">{</span>
                <span class="c1">// Попрацюйте з цим кодом</span>
            <span class="o">}</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі є два домена помилок, обидві з яких можна перекинути методом <code>thrower</code>. <code>catcher</code> може згенерувати лише помилку другого типу, і так повинен владнати справи з першим типом, якщо <code>thrower</code> закидає його. Нарешті, метод <code>main</code> впорається з будь-якими помилками <code>catcher</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___17">Напрямок параметрів</h3>
<div class="paragraph"><p>Метод у Vala передається нульовим або більше аргументами. Поведінка за замовчуванням при виклику методу є наступним:</p></div>
<div class="ulist"><ul>
<li>
<p>
Будь-які параметри типу значень копіюються у локальне місце для методу під час його виконання.
</p>
</li>
<li>
<p>
Будь-які параметри типу посилання не копіюються, натомість методу просто передається посилання на них.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця поведінка може бути змінена за допомогою модифікаторів <code>ref</code> та <code>out</code>.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>out</code> з боку викликаючого
ви можете передати методу неініціалізовану змінну і, можливо, очікуєте, що вона буде ініціалізована після повернення методу
</p>
</li>
<li>
<p>
<code>out</code> для викликаного
параметр вважається неініціалізованим, і вам доведеться його ініціалізувати
</p>
</li>
<li>
<p>
<code>ref</code> з боку викликаючого
змінна, яку ви передаєте методу, повинна бути ініціалізована, і вона може бути змінена  методом або ні
</p>
</li>
<li>
<p>
<code>ref</code> для викликаного
параметр вважається ініціалізованим, і ви можете його змінити чи ні
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">method_1</span><span class="o">(</span><span class="n">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">out</span> <span class="n">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="n">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="n">void</span> <span class="n">method_2</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">,</span> <span class="n">out</span> <span class="nc">Object</span> <span class="n">p</span><span class="o">,</span> <span class="n">ref</span> <span class="nc">Object</span> <span class="n">q</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці методи можна визвати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">int</span> <span class="n">a</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="n">int</span> <span class="n">b</span><span class="o">;</span>
<span class="n">int</span> <span class="n">c</span> <span class="k">=</span> <span class="mi">3</span><span class="o">;</span>
<span class="n">method_1</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">out</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="n">c</span><span class="o">);</span>

<span class="nc">Object</span> <span class="n">o</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="nc">Object</span> <span class="n">p</span><span class="o">;</span>
<span class="nc">Object</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="n">method_2</span><span class="o">(</span><span class="n">o</span><span class="o">,</span> <span class="n">out</span> <span class="n">p</span><span class="o">,</span> <span class="n">ref</span> <span class="n">q</span><span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Обробка кожної змінної буде такою:</p></div>
<div class="paragraph"><p><code>a</code> - це значення типу. Значення буде скопійовано в нове місце пам'яті, локальне для методу, і тому зміни в ньому не будуть видні викликаючому.</p></div>
<div class="paragraph"><p><code>b</code> також має тип значення, але передається як параметр <code>out</code>. У цьому випадку значення не скопіюється, замість цього методу передається вказівник на дані, і тому будь-яке зміна параметра методу буде видимим для виклику коду.</p></div>
<div class="paragraph"><p><code>c</code> трактується так само, як <code>"b"</code>, єдина зміна полягає у сигналі про наміри методу.</p></div>
<div class="paragraph"><p><code>o</code> має тип посилання. Метод передається посиланням на той самий об'єкт, що і викликаюча сторона. Таким чином, метод може змінити цей об'єкт, але якщо він переприсвоїть параметр, ця зміна не буде видимою для абонента.</p></div>
<div class="paragraph"><p><code>p</code> того самого типу, але передається як параметр <code>out</code>. Це означає, що метод отримає вказівник на посилання на об'єкт. Тому він може замінити посилання на посилання на інший об'єкт, і коли метод повернеться, викликаючий замість старого повинен мати посилання на цей інший об'єкт. Якщо ви використовуєте цей тип параметрів, якщо ви не призначите нове посилання на параметр, він буде встановлений в <code>null</code>.</p></div>
<div class="paragraph"><p><code>q</code> знову того ж типу. Цей випадок трактується як <code>p</code> з важливими відмінностями у тому, що метод може не змінити посилання і може отримати доступ до об'єкта, на який посилається. Vala переконається, що в цьому випадку <code>q</code> насправді посилається на будь-який об'єкт, і воно не буде встановлено на <code>null</code>.</p></div>
<div class="paragraph"><p>Ось приклад того, як реалізувати <code>method_1()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">method_1</span><span class="o">(</span><span class="n">int</span> <span class="n">a</span><span class="o">,</span> <span class="n">out</span> <span class="n">int</span> <span class="n">b</span><span class="o">,</span> <span class="n">ref</span> <span class="n">int</span> <span class="n">c</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">b</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="o">;</span>
    <span class="n">c</span> <span class="k">=</span> <span class="mi">3</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Встановлюючи значення для аргументу <code>out b</code>, Vala переконається, що <code>b</code> не є <code>null</code>. Тож ви можете сміливо передавати <code>null</code> як другий аргумент <code>method_1()</code>, якщо вас це значення не цікавить.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__23">Колекції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Gee - бібліотека колекцій класів, написана у Vala. Усі класи повинні бути знайомі користувачам бібліотек, таких як Java Foundation Classes. Gee складається з набору інтерфейсів і різних типів, які по-різному реалізують їх.</p></div>
<div class="paragraph"><p>Якщо ви хочете використовувати Gee у власному додатку, встановіть бібліотеку окремо у вашій системі. Gee можна отримати на <a href="http://live.gnome.org/Projects/Libgee">http://live.gnome.org/Projects/Libgee</a>. Щоб користуватися бібліотекою, ви повинні компілювати свої програми з <code>--pkg gee-0.8</code>.</p></div>
<div class="paragraph"><p>Основними видами колекції є:</p></div>
<div class="ulist"><ul>
<li>
<p>
Списки: впорядковані колекції предметів, доступні за числовим індексом.
</p>
</li>
<li>
<p>
Набори: невпорядковані колекції без повторів.
</p>
</li>
<li>
<p>
Мапи: Непорядкована колекція предметів, доступна за індексом довільного типу.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Усі списки та набори в бібліотеці реалізують інтерфейс <code>Collection</code>, та всі мапи - інтерфейсу <code>Map</code>. Списки також реалізують <code>List</code> та набори <code>Set</code>. Ці загальні інтерфейси означають не тільки те, що всі колекції подібного типу можуть використовуватися взаємозамінно, але і те, що нові колекції можна писати за допомогою тих самих інтерфейсів, і тому використовувати з існуючим кодом.</p></div>
<div class="paragraph"><p>Також спільним для кожного типу <code>Collection</code> є інтерфейс <code>Iterable</code>. Це означає, що будь-який об’єкт у цій категорії можна повторити за допомогою стандартного набору методів або безпосередньо у Vala, використовуючи синтаксис <code>foreach</code>.</p></div>
<div class="paragraph"><p>Усі класи та інтерфейси використовують систему дженеріків. Це означає, що вони повинні бути реалізовані з примірниками певного типу або набору типів, які вони будуть містити. Система гарантуватиме, що до колекцій можуть бути покладені лише призначені типи, а також, що коли об'єкти будуть отримані, вони повернуться як правильний тип.</p></div>
<div class="paragraph"><p><a href="http://valadoc.org/gee-0.8/index.htm">Повна документація Gee API</a>, <a href="https://wiki.gnome.org/Projects/Vala/GeeSamples">Приклади Gee</a></p></div>
<div class="paragraph"><p>Деякі важливі класи Gee:</p></div>
<div class="sect3">
<h4 id="_arraylist_lt_g_gt">ArrayList&lt;G&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;G&gt;</code>, <code>Collection&lt;G&gt;</code>, <code>List&lt;G&gt;</code></p></div>
<div class="paragraph"><p>Впорядкований список елементів типу <code>G</code>, підкріплений масивом, що динамічно змінюється. Цей тип дуже швидкий для доступу до даних, але потенційно повільний при вставці елементів де-небудь, крім кінця, або при вставці елементів, коли внутрішній масив заповнений.</p></div>
</div>
<div class="sect3">
<h4 id="_hashmap_lt_k_v_gt">HashMap&lt;K,V&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;Entry&lt;K,V&gt;&gt;</code>, <code>Map&lt;K,V&gt;</code></p></div>
<div class="paragraph"><p>Відбраження 1:1 від елементів типу <code>K</code> до елементів типу <code>V</code>. Відображення проводиться шляхом обчислення хеш-значення для кожного ключа - це можна налаштувати шляхом надання покажчиків на функції хешування та тестування рівності ключів певними способами.</p></div>
<div class="paragraph"><p>Ви можете опціонально передавати конструктору власні функції хешу та рівності, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">map</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Gee</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">&lt;</span><span class="nc">Foo</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;(</span><span class="n">foo_hash</span><span class="o">,</span> <span class="n">foo_equal</span><span class="o">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Для рядків і цілих чисел функції хешу і рівності виявляються автоматично, об'єкти відрізняються за посиланнями за замовчуванням. Ви повинні забезпечити користувацькі функції хешу і рівності, лише якщо ви хочете змінити поведінку за замовчуванням.</p></div>
</div>
<div class="sect3">
<h4 id="_hashset_lt_g_gt">HashSet&lt;G&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;G&gt;</code>, <code>Collection&lt;G&gt;</code>, <code>Set&lt;G&gt;</code></p></div>
<div class="paragraph"><p>Набір елементів типу <code>G</code>. Дублікати виявляються за допомогою обчислення хеш-значення для кожного ключа - це можна налаштувати, надаючи покажчики функції хешування та тестуючи рівність ключів певними способами.</p></div>
</div>
<div class="sect3">
<h4 id="_____5">Перегляди лише для читання</h4>
<div class="paragraph"><p>Ви можете отримати представлення колекції лише для читання за допомогою властивості <code>read_only_view</code>, наприклад, <code>my_map.read_only_view</code>. Це поверне обгортку, яка має той самий інтерфейс, що і її первинна колекція, але не дозволить будь-якої форми модифікації або будь-якого доступу до вміщеної колекції.</p></div>
</div>
<div class="sect2">
<h3 id="_____6">Методи з підтримкою синтаксису</h3>
<div class="paragraph"><p>Vala розпізнає деякі методи з певними іменами та підписами та надає їм підтримку синтаксису. Наприклад, якщо тип містить метод <code>contains()</code>, об'єкти цього типу можуть використовуватися з оператором <code>in</code>. У наступній таблиці перераховані ці спеціальні методи. <code>T</code> і <code>Tn</code> є лише заповнювачами типів у цій таблиці і повинні бути замінені реальними типами.</p></div>
<div class="sect3">
<h4 id="__24">Індексатори</h4>
<div class="paragraph"><p><code>T2 get(T1 index)</code> індексний доступ: <code>obj[index]</code></p></div>
<div class="paragraph"><p><code>void set(T1 index, T2 item)</code> індексне призначення: <code>obj[index] = item</code></p></div>
</div>
<div class="sect3">
<h4 id="_____7">Індексатори з декількома індексами</h4>
<div class="paragraph"><p><code>T3 get(T1 index1, T2 index2)</code> індексний доступ: <code>obj[index1, index2]</code></p></div>
<div class="paragraph"><p><code>void set(T1 index1, T2 index2, T3 item)</code> індексне призначення: <code>obj[index1, index2] = item</code></p></div>
<div class="paragraph"><p>(&#8230; і так далі для отримання додаткових індексів)</p></div>
</div>
<div class="sect3">
<h4 id="__25">Інші</h4>
<div class="paragraph"><p><code>T slice(long start, long end)</code> фрагментація: <code>obj[start:end]</code></p></div>
<div class="paragraph"><p><code>bool contains(T needle)</code> оператор <code>in</code>: <code>bool b = needle in obj</code></p></div>
<div class="paragraph"><p><code>string to_string()</code> підтримка через рядкові шаблони: <code>@"$obj"</code></p></div>
<div class="paragraph"><p><code>Iterator iterator()</code> інерабельне через <code>foreach</code></p></div>
<div class="paragraph"><p><code>T1 size { get; }</code>  інерабельне через <code>foreach</code></p></div>
<div class="paragraph"><p>Тип <code>Iterator</code> може мати будь-яке ім'я і повинен реалізувати один з цих двох протоколів:</p></div>
<div class="paragraph"><p><code>bool next()</code>, <code>T get()</code> стандартний протокол ітератора: ітерація, поки <code>.next()</code> не поверне значення <code>false</code>. Поточний елемент витягується через <code>.get()</code>.</p></div>
<div class="paragraph"><p><code>T? next_value()</code> альтернативний протокол ітератора: якщо об’єкт ітератора має функцію <code>.next_value()</code>, яка повертає null-здатний тип, то ми повторюємо, викликаючи цю функцію, поки вона не поверне <code>null</code>.</p></div>
<div class="paragraph"><p>Цей приклад реалізує деякі з цих методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">EvenNumbers</span> <span class="o">{</span>
    <span class="n">public</span> <span class="n">int</span> <span class="n">get</span><span class="o">(</span><span class="n">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">bool</span> <span class="n">contains</span><span class="o">(</span><span class="n">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">string</span> <span class="n">to_string</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="s">&quot;[This object enumerates even numbers]&quot;</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="nc">Iterator</span> <span class="n">iterator</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Iterator</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="k">class</span> <span class="nc">Iterator</span> <span class="o">{</span>
        <span class="k">private</span> <span class="n">int</span> <span class="n">index</span><span class="o">;</span>
        <span class="k">private</span> <span class="nc">EvenNumbers</span> <span class="n">even</span><span class="o">;</span>

        <span class="n">public</span> <span class="nc">Iterator</span><span class="o">(</span><span class="nc">EvenNumbers</span> <span class="n">even</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="n">even</span> <span class="k">=</span> <span class="n">even</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">public</span> <span class="n">bool</span> <span class="n">next</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="n">public</span> <span class="n">int</span> <span class="n">get</span><span class="o">()</span> <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="n">index</span><span class="o">++;</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="n">even</span><span class="o">[</span><span class="kt">this.index</span> <span class="kt">-</span> <span class="err">1</span><span class="o">];</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">void</span> <span class="n">main</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">even</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">EvenNumbers</span><span class="o">();</span>
    <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;%d\n&quot;</span><span class="o">,</span> <span class="n">even</span><span class="o">[</span><span class="err">5</span><span class="o">]);</span>   <span class="c1">// get()</span>
    <span class="k">if</span> <span class="o">(</span><span class="mi">4</span> <span class="n">in</span> <span class="n">even</span><span class="o">)</span> <span class="o">{</span>                  <span class="c1">// contains()</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(@</span><span class="s">&quot;$even\n&quot;</span><span class="o">);</span>    <span class="c1">// to_string()</span>
    <span class="o">}</span>
    <span class="n">foreach</span> <span class="o">(</span><span class="n">int</span> <span class="n">i</span> <span class="n">in</span> <span class="n">even</span><span class="o">)</span> <span class="o">{</span>         <span class="c1">// iterator()</span>
        <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;%d\n&quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">20</span><span class="o">)</span> <span class="n">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__26">Багатопоточність</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="___vala_2">Потоки у Vala</h3>
<div class="paragraph"><p>Програма, написана у Vala, може мати кілька потоків виконання, що дозволяє їй робити більше, ніж одну справу. Точно, як цим керувати, виходить за межі Vala - потоки можуть мати спільне ядро ​​процесора чи ні, залежно від середовища.</p></div>
<div class="paragraph"><p>Потік у Vala не визначається під час компіляції, натомість це просто частина коду Vala, яку вимагають під час виконання виконувати як новий потік. Це робиться за допомогою статичних методів класу <code>Thread</code> в GLib, як показано в наступному (дуже спрощеному) прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">void</span><span class="o">*</span> <span class="n">thread_func</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">stdout</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;Thread running.\n&quot;</span><span class="o">);</span>
    <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
<span class="o">}</span>

<span class="n">int</span> <span class="n">main</span><span class="o">(</span><span class="n">string</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(!</span><span class="nc">Thread</span><span class="o">.</span><span class="n">supported</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">stderr</span><span class="o">.</span><span class="n">printf</span><span class="o">(</span><span class="s">&quot;Cannot run without threads.\n&quot;</span><span class="o">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">try</span> <span class="o">{</span>
        <span class="nc">Thread</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">thread_func</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ThreadError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця коротка програма запитує створення та виконання нового потоку. Код, який слід запустити, знаходиться в <code>thread_func</code>. Також зверніть увагу на тест на початку методу <code>main</code> - програма Vala не зможе використовувати потоки, якщо не буде скомпільована належним чином, тож якщо ви побудуєте цей приклад звичайним способом, він просто відобразить помилку і перестане працювати. Можливість перевірити підтримку потоку під час виконання дозволяє будувати програму для запуску з потоками або без них, як треба. Для того, щоб побудувати з підтримкою потоку, запустіть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">$</span> <span class="n">valac</span> <span class="o">--</span><span class="n">thread</span> <span class="n">threading</span><span class="o">-</span><span class="n">sample</span><span class="o">.</span><span class="n">vala</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде включати необхідні бібліотеки та забезпечити ініціалізацію системи потоків, коли це можливо.</p></div>
<div class="paragraph"><p>Тепер програма буде працювати без помилок сегментації, але вона все ще не буде діяти так, як очікувалося. Без будь-якого циклу подій програма Vala припиняється, коли закінчується її основний потік (той, що створений для запуску <code>main</code>). Щоб контролювати таку поведінку, ви можете дозволити потокам співпрацювати. Це можна зробити потужно за допомогою циклів подій та асинхронних черг, але в цьому вступі до потоків ми просто покажемо основні можливості потоків.</p></div>
<div class="paragraph"><p>Потік може сказати системі, що в даний момент його немає необхідності виконувати, і тим самим запропонувати замість цього запустити інший потік. Це робиться за допомогою статичного методу <code>Thread.yield()</code>. Якщо це твердження було розміщено в кінці вищезгаданого методу <code>main</code>, система часу виконання призупинить основний потік і перевірить, чи є інші потоки, які можна запустити - після знаходження новоствореного потоку в стані, який можна виконати, він буде запустіть це замість нього, поки він не буде закінчений - і програма діятиме так, як здається, повинна. Однак немає гарантії, що це все ж таки відбудеться. Система здатна вирішувати, коли запускаються потоки, і, як такий, може не дозволити новому потоку закінчитися до перезапуску первинного потоку та закінчення програми.</p></div>
<div class="paragraph"><p>Для того, щоб чекати, коли нитка повністю закінчиться, існує метод <code>join()</code>. Виклик цього методу на об'єкті <code>Thread</code> змушує викликаючий потік зачекати, поки закінчиться інший потік, перш ніж продовжувати. Це також дозволяє потоку отримувати повернене значення іншого, якщо це корисно. Щоб реалізувати з'єднувальні нитки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="o">{</span>
    <span class="n">unowned</span> <span class="nc">Thread</span> <span class="n">thread</span> <span class="k">=</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">create</span><span class="o">(</span><span class="n">thread_func</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
    <span class="n">thread</span><span class="o">.</span><span class="n">join</span><span class="o">();</span>
<span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">ThreadError</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього разу, коли ми створюємо потік, ми додаємо <code>true</code> як останній аргумент. Це позначає нитку як "приєднану". Ми також пам’ятаємо значення, повернене в результаті створення - <code>unowned</code> посилання на об’єкт <code>Thread</code> (<code>unowned</code> посилання пояснюються пізніше і не є життєво важливими для цього розділу.) За допомогою цього посилання можна приєднати новий потік до первинного потоку. З цією версією програми гарантується, що новоствореному потоку буде дозволено повністю виконатись до продовження первинного потоку та припинення програми.</p></div>
<div class="paragraph"><p>Усі ці приклади мають потенційну проблему в тому, що новостворений потік не знає контексту, в якому він повинен працювати. У C ви б надали методу створення потоку деякі дані, у Vala замість статичного методу ви зазвичай передаєте метод екземпляра <code>Thread.create</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___18">Контроль ресурсів</h3>
<div class="paragraph"><p>Кожного разу, коли одночасно виконується більше ніж один потік виконання, є ймовірність, що дані мають одночасний доступ. Це може призвести до умов перегонів, де результат залежить від того, коли система вирішить перемикатися між потоками.</p></div>
<div class="paragraph"><p>Щоб контролювати цю ситуацію, ви можете використовувати ключове слово <code>lock</code>, щоб гарантувати, що певні блоки коду не будуть перервані іншими потоками, яким потрібно отримати доступ до тих самих даних. Найкращий спосіб показати це, мабуть, на прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">Test</span> <span class="k">:</span> <span class="kt">GLib.Object</span> <span class="o">{</span>

    <span class="kt">private</span> <span class="kt">int</span> <span class="kt">a</span> <span class="o">{</span> <span class="kt">get</span><span class="o">;</span> <span class="kt">set</span><span class="o">;</span> <span class="o">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">action_1</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">int</span> <span class="n">tmp</span> <span class="k">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">++;</span>
            <span class="n">a</span> <span class="k">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="n">public</span> <span class="n">void</span> <span class="n">action_2</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">lock</span> <span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">int</span> <span class="n">tmp</span> <span class="k">=</span> <span class="n">a</span><span class="o">;</span>
            <span class="n">tmp</span><span class="o">--;</span>
            <span class="n">a</span> <span class="k">=</span> <span class="n">tmp</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас визначає два методи, коли обом потрібно змінити значення <code>a</code>. Якби тут не було записів про блокування, вказівки в цих методах могли б переплестись, і отримана зміна на <code>а</code> була б фактично випадковою. Оскільки тут є заяви про блокування, Vala гарантує, що якщо одна нитка заблокувала <code>a</code>, інший потік, який потребує такого ж блокування, повинен буде дочекатися своєї черги.</p></div>
<div class="paragraph"><p>У Vala можна лише заблокувати членів об'єкта, який виконує код. Це може здатися головним обмеженням, але насправді стандартне використання цієї методики повинно включати класи, які індивідуально відповідають за управління ресурсом, і тому все блокування дійсно буде внутрішнім для класу. Так само, у наведеному вище прикладі всі звернення до <code>а</code> інкапсульовані у класі.</p></div>
</div>
<div class="sect2">
<h3 id="___19">Основний цикл</h3>
<div class="paragraph"><p>GLib includes a system for running an event loop, in the classes around MainLoop. The purpose of this system is to allow you to write a program that waits for events and responds to them, instead of having to constantly check conditions. This is the model that GTK+ uses, so that a program can wait for user interaction without having to have any currently running code.</p></div>
<div class="paragraph"><p>The following program creates and starts a MainLoop, and then attaches a source of events to it. In this case the source is a simple timer, that will execute the given method after 2000ms. The method will in fact just stop the main loop, which will in this case exit the program.</p></div>
<div class="paragraph"><p>void main() {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>var loop = new MainLoop();
var time = new TimeoutSource(2000);</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>time.set_callback(() =&gt; {
    stdout.printf("Time!\n");
    loop.quit();
    return false;
});</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>time.attach(loop.get_context());</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    loop.run();
}
When using GTK+, a main loop will be created automatically, and will be started when you call the `Gtk.main()' method. This marks the point where the program is ready to run and start accepting events from the user or elsewhere. The code in GTK+ is equivalent to the short example above, and so you may add event sources in much the same way, although of course you need to use the GTK+ methods to control the main loop.</code></pre>
</div></div>
<div class="paragraph"><p>void main(string[] args) {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Gtk.init(ref args);
var time = new TimeoutSource(2000);</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>time.set_callback(() =&gt; {
    stdout.printf("Time!\n");
    Gtk.main_quit();
    return false;
});</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>time.attach(null);</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    Gtk.main();
}
A common requirement in GUI programs is to execute some code as soon as possible, but only when it will not disturb the user. For this, you use IdleSource instances. These send events to the programs main loop, but request they only be dealt with when there is nothing more important to do.</code></pre>
</div></div>
<div class="paragraph"><p>For more information about event loops, see the GLib and GTK+ documentation.</p></div>
<div class="paragraph"><p>Asynchronous Methods
Asynchronous methods are methods whose execution can be paused and resumed under the control of the programmer. They are often used in the main thread of an application where a method needs to wait for an external slow task to complete, but must not stop other processing from happening. (For example, one slow operation must not freeze the whole GUI). When the method has to wait, it gives control of the CPU back to its caller (i.e. it yields), but it arranges to be called back to resume execution when data becomes ready. External slow tasks that async methods might wait for include: waiting for data from a remote server, or waiting for calculations in another thread to complete, or waiting for data to load from a disk drive.</p></div>
<div class="paragraph"><p>Asynchronous methods are normally used with a GLib main loop running, because idle callbacks are used to handle some of the internal callbacks. However under certain conditions async may be used without the GLib main loop, for example if the async methods always yield and Idle.add() is never used. (FIXME: Check what are the exact conditions.)</p></div>
<div class="paragraph"><p>Asynchronous methods are designed for interleaving the processing of many different long-lived operations within a single thread. They do not by themselves spread the load out over different threads. However, an async method may be used to control a background thread and to wait for it to complete, or to queue operations for a background thread to process.</p></div>
<div class="paragraph"><p>Async methods in Vala use the GIO library to handle the callbacks, so must be built with the --pkg=gio-2.0 option.</p></div>
<div class="paragraph"><p>An asynchronous method is defined with the async keyword. For example:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  async void display_jpeg(string fnam) {
     // Load JPEG in a background thread and display it when loaded
     [...]
  }
or:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  async int fetch_webpage(string url, out string text) throws IOError {
     // Fetch a webpage asynchronously and when ready return the
     // HTTP status code and put the page contents in 'text'
     [...]
     text = result;
     return status;
  }
The method may take arguments and return a value like any other method. It may use a yield statement at any time to give control of the CPU back to its caller.</code></pre>
</div></div>
<div class="paragraph"><p>An async method may be called with either of these two forms:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  display_jpeg.begin("test.jpg");
  display_jpeg.begin("test.jpg", (obj, res) =&gt; {
      display_jpeg.end(res);
  });
Both forms starts the async method running with the given arguments. The second form in addition registers an AsyncReadyCallback which is executed when the method finishes. The callback takes a source object, obj, and an instance of GAyncResult, res, as arguments. In the callback the .end() method should be called to receive the return value of the asynchronous method if it has one. If the async method can throw an exception, the .end() call is where the exception arrives and must be caught. If the method has out arguments, then these should be omitted from the .begin() call and added to the .end() call instead.</code></pre>
</div></div>
<div class="paragraph"><p>For example:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  fetch_webpage.begin("http://www.example.com/", (obj, res) =&gt; {
      try {
          string text;
          var status = fetch_webpage.end(res, out text);
          // Result of call is in 'text' and 'status' ...
      } catch (IOError e) {
          // Problem ...
      }
  });
When an asynchronous method starts running, it takes control of the CPU until it reaches its first yield statement, at which point it returns to the caller. When the method is resumed, it continues execution immediately after that yield statement. There are several common ways to use yield:</code></pre>
</div></div>
<div class="paragraph"><p>This form gives up control, but arranges for the GLib main loop to resume the method when there are no more events to process:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  Idle.add(fetch_webpage.callback);
  yield;
This form gives up control, and stores the callback details for some other code to use to resume the method's execution:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  SourceFunc callback = fetch_webpage.callback;
  [... store 'callback' somewhere ...]
  yield;
Some code elsewhere must now call the stored SourceFunc in order for the method to be resumed. This could be done by scheduling the GLib main loop to run it:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  Idle.add((owned) callback);
or alternatively a direct call may be made if the caller is running in the main thread:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  callback();
If the direct call above is used, then the resumed asynchronous method takes control of the CPU immediately and runs until its next yield before returning to the code that executed callback(). The Idle.add() method is useful if the callback must be made from a background thread, e.g. to resume the async method after completion of some background processing. (The (owned) cast is necessary to avoid a warning about copying delegates.)</code></pre>
</div></div>
<div class="paragraph"><p>The third common way of using yield is when calling another asynchronous method, for example:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  yield display_jpeg(fnam);
or</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  var status = yield fetch_webpage(url, out text);
In both cases, the calling method gives up control of the CPU and does not resume until the called method completes. The yield statement automatically registers a callback with the called method to make sure that the caller resumes correctly. The automatic callback also collects the return value from the called method.</code></pre>
</div></div>
<div class="paragraph"><p>When this yield statement executes, control of the CPU first passes to the called method which runs until its first yield and then drops back to the calling method, which completes the yield statement itself, and then gives back control to its own caller.</p></div>
<div class="paragraph"><p>Examples
See Async Method Samples for examples of different ways that async may be used.</p></div>
<div class="paragraph"><p>Weak References
Vala&#8217;s memory management is based on automatic reference counting. Each time an object is assigned to a variable its internal reference count is increased by 1, each time a variable referencing an object goes out of scope its internal reference count is decreased by 1. If the reference count reaches 0 the object will be freed.</p></div>
<div class="paragraph"><p>However, it is possible to form a reference cycle with your data structures. For example, with a tree data structure where a child node holds a reference to its parent and vice versa, or a doubly-linked list where each element holds a reference to its predecessor and the predecessor holds a reference to its successor.</p></div>
<div class="paragraph"><p>In these cases objects could keep themselves alive simply by referencing to each other, even though they should be freed. To break such a reference cycle you can use the weak modifier for one of the references:</p></div>
<div class="paragraph"><p>class Node {
    public weak Node prev;
    public Node next;
}
This topic is explained in detail on this page: Vala&#8217;s Memory Management Explained.</p></div>
<div class="paragraph"><p>Ownership
Unowned References
Normally when creating an object in Vala you are returned a reference to it. Specifically this means that as well as being passed a pointer to the object in memory, it is also recorded in the object itself that this pointer exists. Similarly, whenever another reference to the object is created, this is also recorded. As an object knows how many references there are to it, it can automatically be removed when needed. This is the basis of Vala&#8217;s memory management.</p></div>
<div class="paragraph"><p>Methods ownership
Unowned references conversely are not recorded in the object they reference. This allows the object to be removed when it logically should be, regardless of the fact that there might be still references to it. The usual way to achieve this is with a method defined to return an unowned reference, e.g.:</p></div>
<div class="paragraph"><p>class Test {
    private Object o;</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    public unowned Object get_unowned_ref() {
        this.o = new Object();
        return this.o;
    }
}
When calling this method, in order to collect a reference to the returned object, you must expect to receive a weak reference:</code></pre>
</div></div>
<div class="paragraph"><p>unowned Object o = get_unowned_ref();
The reason for this seemingly over complicated example because of the concept of ownership.</p></div>
<div class="paragraph"><p>If the Object "o" was not stored in the class, then when the method "get_unowned_ref" returned, "o" would become unowned (i.e. there would be no references to it). If this were the case, the object would be deleted and the method would never return a valid reference.
If the return value was not defined as unowned, the ownership would pass to the calling code. The calling code is, however, expecting an unowned reference, which cannot receive the ownership.
If the calling code is written as</p></div>
<div class="paragraph"><p>Object o = get_unowned_ref();
Vala will try to either obtain a reference of or a duplicate of the instance the unowned reference pointing to.</p></div>
<div class="paragraph"><p>Properties ownership
In contrast to normal methods, properties always have unowned return value. That means you can&#8217;t return a new object created within the get method. That also means, you can&#8217;t use an owned return value from a method call. The somewhat irritating fact is because of that a property value is owned by the object that HAS this property. A call to obtain this property value should not steal or reproduce (by duplicating, or increasing the reference count of) the value from the object side.</p></div>
<div class="paragraph"><p>As such, the following example will result in a compilation error</p></div>
<div class="paragraph"><p>public Object property {
    get {
        return new Object();   // WRONG: property returns an unowned reference,
                               // the newly created object will be deleted when
                               // the getter scope ends the caller of the
                               // getter ends up receiving an invalid reference
                               // to a deleted object.
    }
}
nor can you do this</p></div>
<div class="paragraph"><p>public string property {
    get {
        return getter_method();   // WRONG: for the same reason above.
    }
}</p></div>
<div class="paragraph"><p>public string getter_method() {
    return "some text"; // "some text" is duplicated and returned at this point.
}
on the other hand, this is perfectly fine</p></div>
<div class="paragraph"><p>public string property {
    get {
        return getter_method();   // GOOD: getter_method returns an unowned value
    }
}</p></div>
<div class="paragraph"><p>public unowned string getter_method() {
    return "some text";
    // Don&#8217;t be alarmed that the text is not assigned to any strong variable.
    // Literal strings in Vala are always owned by the program module itself,
    // and exist as long as the module is in memory
}
The unowned modifier can be used to make automatic property&#8217;s storage unowned. That means</p></div>
<div class="paragraph"><p>public unowned Object property { get; private set; }
is identical to</p></div>
<div class="paragraph"><p>private unowned Object _property;</p></div>
<div class="paragraph"><p>public Object property {
    get { return _property; }
}
The keyword owned can be used to specifically ask a property to return a owned reference of the value, therefore causing the property value be reproduced in the object side. Think twice before adding the owned keyword. Is it a property or simply a get_xxx method? There may also be problems in your design. Anyways, the following code is a correct segment,</p></div>
<div class="paragraph"><p>public owned Object property { owned get { return new Object(); } }
Unowned references play a similar role to pointers which are described later. They are however much simpler to use than pointers, as they can be easily converted to normal references. However, in general they should not be widely used in the programs unless you know what you are doing.</p></div>
<div class="paragraph"><p>Ownership Transfer
The keyword owned is used to transfer ownership.</p></div>
<div class="paragraph"><p>As a prefix of a parameter type, it means that ownership of the object is transferred into this code context.
As an type conversion operator, it can be used to avoid duplicating non-reference counting classes, which is usually impossible in Vala. For example,</p></div>
<div class="paragraph"><p>Foo foo = (owned) bar;
This means that bar will be set to null and foo inherits the reference/ownership of the object bar references.</p></div>
<div class="paragraph"><p>Variable-Length Argument Lists
Vala supports C-style variable-length argument lists ("varargs") for methods. They are declared with an ellipsis ("&#8230;") in the method signature. A method with varargs requires at least one fixed argument:</p></div>
<div class="paragraph"><p>void method_with_varargs(int x, &#8230;) {
    var l = va_list();
    string s = l.arg();
    int i = l.arg();
    stdout.printf("%s: %d\n", s, i);
}
In this example x is a fixed argument to meet the requirements. You obtain the varargs list with va_list(). Then you can retrieve the arguments one after another by calling the generic method arg&lt;T&gt;() sequently on this list, with T being the type that the argument should be interpreted as. If the type is evident from the context (as in our example) the type is inferred automatically and you can just call arg() without the generic type argument.</p></div>
<div class="paragraph"><p>This example parses an arbitrary number of string - double argument pairs:</p></div>
<div class="paragraph"><p>void method_with_varargs(int fixed, &#8230;) {
    var l = va_list();
    while (true) {
        string? key = l.arg();
        if (key == null) {
            break;  // end of the list
        }
        double val = l.arg();
        stdout.printf("%s: %g\n", key, val);
    }
}</p></div>
<div class="paragraph"><p>void main() {
    method_with_varargs(42, "foo", 0.75, "bar", 0.25, "baz", 0.32);
}
It checks for null as a sentinel to recognize the end of the varargs list. Vala always implicitly passes null as the last argument of a varargs method call.</p></div>
<div class="paragraph"><p>Varargs have a serious drawback that you should be aware of: they are not type-safe. The compiler can&#8217;t tell you whether you are passing arguments of the right type to the method or not. That&#8217;s why you should consider using varargs only if you have a good reason, for example: providing a convenience function for C programmers using your Vala library, binding a C function. Often an array argument is a better choice.</p></div>
<div class="paragraph"><p>A common pattern with varargs is to expect alternating string - value pairs as arguments, usually meaning gobject property - value. In this case you can write property: value instead, e.g.:</p></div>
<div class="paragraph"><p>actor.animate (AnimationMode.EASE_OUT_BOUNCE, 3000, x: 100.0, y: 200.0, rotation_angle_z: 500.0, opacity: 0);
is equivalent to:</p></div>
<div class="paragraph"><p>actor.animate (AnimationMode.EASE_OUT_BOUNCE, 3000, "x", 100.0, "y", 200.0, "rotation-angle-z", 500.0, "opacity", 0);
Pointers
Pointers are Vala&#8217;s way of allowing manual memory management. Normally when you create an instance of a type you receive a reference to it, and Vala will take care of destroying the instance when there are no more references left to it. By requesting instead a pointer to an instance, you take responsibility for destroying the instance when it is no longer wanted, and therefore get greater control over how much memory is used.</p></div>
<div class="paragraph"><p>This functionality is not necessarily needed most of the time, as modern computers are usually fast enough to handle reference counting and have enough memory that small inefficiencies are not important. The times when you might resort to manual memory management are:</p></div>
<div class="paragraph"><p>When you specifically want to optimise part of a program and unowned references are insufficient.</p></div>
<div class="paragraph"><p>When you are dealing with an external library that does not implement reference counting for memory management (probably meaning one not based on gobject.)
In order to create an instance of a type, and receive a pointer to it:</p></div>
<div class="paragraph"><p>Object* o = new Object();
In order to access members of that instance:</p></div>
<div class="paragraph"><p>o&#8594;method_1();
o&#8594;data_1;
In order to free the memory pointed to:</p></div>
<div class="paragraph"><p>delete o;
Vala also supports the address-of (&amp;) and indirection (*) operators known from C:</p></div>
<div class="paragraph"><p>int i = 42;
int* i_ptr = &i;    // address-of
int j = *i_ptr;     // indirection</p></div>
<div class="paragraph"><p>The behavior is a bit different with reference types, you can omit the address-of and indirection operator on assignment:</p></div>
<div class="paragraph"><p>Foo f = new Foo();
Foo* f_ptr = f;    // address-of
Foo g = f_ptr;     // indirection</p></div>
<div class="paragraph"><p>unowned Foo f_weak = f;  // equivalent to the second line</p></div>
<div class="paragraph"><p>The usage of reference-type pointers is equivalent to the use of unowned references.</p></div>
<div class="paragraph"><p>Non-Object classes
Classes defined as not being descended from GLib.Object are treated as a special case. They are derived directly from GLib&#8217;s type system and therefore much lighter in weight. In a more recent Vala compiler, one can also implement interfaces, signals and properties with these classes.</p></div>
<div class="paragraph"><p>One obvious case of using these non-Object classes stays in the GLib bindings. Because GLib is at a lower level than GObject, most classes defined in the binding are of this kind. Also, as mentioned before, the lighter weight of non-object classes make them useful in many practical situations (e.g. the Vala compiler itself). However the detailed usage of non-Object classes are outside the scope of this tutorial. Be aware that these classes are fundamentally different from structs.</p></div>
<div class="paragraph"><p>D-Bus Integration
D-Bus is tightly integrated into the language and has never been easier than with Vala.</p></div>
<div class="paragraph"><p>To export a custom class as a D-Bus service you just need to annotate it with the DBus code attribute and register an instance of this class with your local D-Bus session.</p></div>
<div class="paragraph"><p>public class DemoService : Object {
    /* Private field, not exported via D-Bus */
    int counter;</p></div>
<div class="literalblock">
<div class="content">
<pre><code>/* Public field, not exported via D-Bus */
public int status;</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>/* Public property, exported via D-Bus */
public int something { get; set; }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>/* Public signal, exported via D-Bus
 * Can be emitted on the server side and can be connected to on the client side.
 */
public signal void sig1();</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>/* Public method, exported via D-Bus */
public void some_method() {
    counter++;
    stdout.printf("heureka! counter = %d\n", counter);
    sig1();  // emit signal
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    /* Public method, exported via D-Bus and showing the sender who is
       is calling the method (not exported in the D-Bus interface) */
    public void some_method_sender(string message, GLib.BusName sender) {
        counter++;
        stdout.printf("heureka! counter = %d, '%s' message from sender %s\n",
                      counter, message, sender);
    }
}
Register an instance of the service and start a main loop:</code></pre>
</div></div>
<div class="paragraph"><p>void on_bus_aquired (DBusConnection conn) {
    try {
        // start service and register it as dbus object
        var service = new DemoService();
        conn.register_object ("/org/example/demo", service);
    } catch (IOError e) {
        stderr.printf ("Could not register service: %s\n", e.message);
    }
}</p></div>
<div class="paragraph"><p>void main () {
    // try to register service name in session bus
    Bus.own_name (BusType.SESSION, "org.example.DemoService", /* name to register <strong>/
                  BusNameOwnerFlags.NONE, /</strong> flags <strong>/
                  on_bus_aquired, /</strong> callback function on registration succeeded <strong>/
                  () &#8658; {}, /</strong> callback on name register succeeded <strong>/
                  () &#8658; stderr.printf ("Could not acquire name\n"));
                                                     /</strong> callback on name lost */</p></div>
<div class="literalblock">
<div class="content">
<pre><code>    // start main loop
    new MainLoop ().run ();
}
You must compile this example with the gio-2.0 package:</code></pre>
</div></div>
<div class="paragraph"><p>$ valac --pkg gio-2.0 dbus-demo-service.vala
$ ./dbus-demo-service
All member names are automatically mangled from Vala&#8217;s lower_case_with_underscores naming convention to D-Bus CamelCase names. The exported D-Bus interface of this example will have a property Something, a signal Sig1 and a method SomeMethod. You can open a new terminal window and call the method from command line with:</p></div>
<div class="paragraph"><p>$ dbus-send --type=method_call                   \
            --dest=org.example.DemoService       \
            /org/example/demo                    \
            org.example.DemoService.SomeMethod
or</p></div>
<div class="paragraph"><p>$ dbus-send --type=method_call                   \
            --dest=org.example.DemoService       \
            /org/example/demo                    \
            org.example.DemoService.SomeMethodSender \
            string:'hello world'
You can also use a graphical D-Bus debugger like D-Feet to browse your D-Bus interfaces and call methods.</p></div>
<div class="paragraph"><p>Some comprehensive examples: DBus Client Samples and DBus Server Sample</p></div>
<div class="paragraph"><p>Profiles
Vala supports a couple of different profiles:</p></div>
<div class="paragraph"><p>gobject (default)
posix
dova
A profile determines what language features are available and on which libraries the resulting C-Code will depend.</p></div>
<div class="paragraph"><p>To select a different profile use valac&#8217;s --profile switch, e.g.:</p></div>
<div class="paragraph"><p>valac --profile=posix somecode.vala
Experimental Features
Some features of Vala are experimental. This means they are not fully tested and might be subject to changes in future versions.</p></div>
<div class="paragraph"><p>Chained Relational Expressions
This feature allows you to write complex relational expressions like</p></div>
<div class="paragraph"><p>if (1 &lt; a &amp;&amp; a &lt; 5) {}</p></div>
<div class="paragraph"><p>if (0 &lt; a &amp;&amp; a &lt; b &amp;&amp; b &lt; c &amp;&amp; c &lt; d &amp;&amp; d &lt; 255) {
    // do something
}
in a more natural way:</p></div>
<div class="paragraph"><p>if (1 &lt; a &lt; 5) {}</p></div>
<div class="paragraph"><p>if (0 &lt; a &lt; b &lt; c &lt; d &lt; 255) {
    // do something
}
Regular Expression Literals
Regular expressions are a powerful technique for pattern matching in strings. Vala has experimental support for regular expression literals (/regex/). Example:</p></div>
<div class="paragraph"><p>string email = "tux@kernel.org";
if (/^<code><span class="A-Z0-9._%+-">@[A-Z0-9.-]</span></code>\.[A-Z]{2,4}$/i.match(email)) {
    stdout.printf("Valid email address\n");
}
The trailing i makes the expression case insensitive. You can store a regular expression in a variable of type Regex:</p></div>
<div class="paragraph"><p>Regex regex = /foo/;
A example of regular expression replacement:</p></div>
<div class="paragraph"><p>var r = /(foo|bar|cow)/;
var o = r.replace ("this foo is great", -1, 0, "thing");
print ("%s\n", o);
The following trailing characters can be used:</p></div>
<div class="paragraph"><p>i, letters in the pattern match both upper- and lowercase letters</p></div>
<div class="paragraph"><p>m, the "start of line" and "end of line" constructs match immediately following or immediately before any newline in the string, respectively, as well as at the very start and end.</p></div>
<div class="paragraph"><p>s, a dot metacharater . in the pattern matches all characters, including newlines. Without it, newlines are excluded.</p></div>
<div class="paragraph"><p>x, whitespace data characters in the pattern are totally ignored except when escaped or inside a character class.</p></div>
<div class="paragraph"><p>Strict Non-Null Mode
If you compile your code with --enable-experimental-non-null the Vala compiler will run in strict non-null type checking mode and consider every type to be not nullable by default unless it is explicitly declared nullable by marking it with a question mark:</p></div>
<div class="paragraph"><p>Object o1 = new Object();     // not nullable
Object? o2 = new Object();    // nullable</p></div>
<div class="paragraph"><p>The compiler will perform a static compile-time analysis to ensure that no nullable reference is assigned to a non-nullable reference, e.g. this won&#8217;t be possible:</p></div>
<div class="paragraph"><p>o1 = o2;
o2 could be null and o1 was declared non-nullable, so this assignment is forbidden. However, you can override this behaviour with an explicit non-null cast if you&#8217;re sure that o2 is not null:</p></div>
<div class="paragraph"><p>o1 = (!) o2;
The strict non-null mode helps in avoiding unwanted null dereferencing errors. This feature would come to full potential if the nullability of all return types in bindings was marked correctly, which is currently not always the case.</p></div>
<div class="paragraph"><p>Libraries
At the system level, a Vala library is exactly a C library, and so the same tools are used. In order to make the process simpler, and so that the Vala compiler can understand the process there is then an extra level of Vala specific information.</p></div>
<div class="paragraph"><p>A "Vala library" is therefore, the system part:</p></div>
<div class="paragraph"><p>A system library (e.g. libgee.so)</p></div>
<div class="paragraph"><p>A pkg-config entry (e.g. gee-1.0.pc)</p></div>
<div class="paragraph"><p>Both of which are installed in the standard locations. And the Vala specific files:</p></div>
<div class="paragraph"><p>A VAPI file (e.g. gee-1.0.vapi)</p></div>
<div class="paragraph"><p>An optional dependency file (e.g. gee-1.0.deps)</p></div>
<div class="paragraph"><p>These files are explained later in this section. It should be noted that the library names are the same in the Vala specific files as in the pkg-config files.</p></div>
<div class="paragraph"><p>Using Libraries
Using a library in Vala is largely automated if you use the valac compiler. The Vala specific library files make up what is known as a package. You tell the compiler that a package is needed by your program as follows:</p></div>
<div class="paragraph"><p>$ valac --pkg gee-1.0 test.vala
This command means your program can use any of the definitions in the gee-1.0.vapi file, and also any in any of the packages that gee-1.0 depends on. These dependencies would be be listed in gee-1.0.deps if there were any. In this example valac is set to build all the way to binary, and will therefore incorporate information from pkg-config to link the correct libraries. This is why the pkg-config names are also used for Vala package names.</p></div>
<div class="paragraph"><p>Packages are generally used with namespaces, but they are not technically related. This means that even though your application is built with reference to the package, you must still include the required using statements in each file as appropriate, or else use the fully qualified names of all symbols.</p></div>
<div class="paragraph"><p>It is also possible to treat a local library (one that is not installed) as a package. For comparison, Vala itself uses an internal version of Gee. When valac is built it creates a VAPI file of this internal library and uses it roughly as follows:</p></div>
<div class="paragraph"><p>$ valac --vapidir ../gee --pkg gee &#8230;
For details on how to generate this library, see the next section or the example.</p></div>
<div class="paragraph"><p>Creating a Library
Using Autotools
It is possible to use Autotools to create a library written in Vala. A library is created by using C code generated by Vala compiler, linked and installed as any other library. Then you need tell which C files must be used to create the library and which of them must be distributable, allowing others to compile a tarball without Vala using standard Autotools commands: configure, make and make install.</p></div>
<div class="paragraph"><p>Example
This example was taken from GXml recent additions. GXmlDom is a library aimed to have a GObject based libxml2 replacement; is written in Vala and originally used to use WAF to build.</p></div>
<div class="paragraph"><p>valac can be used to generate C code and headers from Vala sources. At this time is possible to generate a GObjectIntrospection and the VAPI file from the vala sources too.</p></div>
<div class="paragraph"><p>gxml.vala.stamp is used as the code sources for our library.</p></div>
<div class="paragraph"><p>Is important to add --pkg switches in order to valac to success and set all CFLAGS and LIBS required by the C library to compile and link against.</p></div>
<div class="paragraph"><p>Toggle line numbers
   1 NULL =
   2
   3
   4 AM_CPPFLAGS = \
   5         -DPACKAGE_LOCALE_DIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
   6         -DPACKAGE_SRC_DIR=\""$(srcdir)"\" \
   7         -DPACKAGE_DATA_DIR=\""$(datadir)"\"
   8
   9 BUILT_SOURCES = gxml.vala.stamp
  10 CLEANFILES = gxml.vala.stamp
  11
  12 AM_CFLAGS =\
  13          -Wall\
  14          -g \
  15         $(GLIB_CFLAGS) \
  16         $(LIBXML_CFLAGS) \
  17         $(GIO_CFLAGS) \
  18         $(GEE_CFLAGS) \
  19         $(VALA_CFLAGS) \
  20         $(NULL)
  21
  22 lib_LTLIBRARIES = libgxml.la
  23
  24 VALAFLAGS = \
  25     $(top_srcdir)/vapi/config.vapi \
  26     --vapidir=$(top_srcdir)/vapi \
  27     --pkg libxml-2.0 \
  28     --pkg gee-1.0 \
  29     --pkg gobject-2.0 \
  30     --pkg gio-2.0 \
  31     $(NULL)
  32
  33 libgxml_la_VALASOURCES = \
  34         Attr.vala \
  35         BackedNode.vala \
  36         CDATASection.vala \
  37         CharacterData.vala \
  38         Comment.vala \
  39         Document.vala \
  40         DocumentFragment.vala \
  41         DocumentType.vala \
  42         DomError.vala \
  43         Element.vala \
  44         Entity.vala \
  45         EntityReference.vala \
  46         Implementation.vala \
  47         NamespaceAttr.vala \
  48         NodeList.vala \
  49         NodeType.vala \
  50         Notation.vala \
  51         ProcessingInstruction.vala \
  52         Text.vala \
  53         XNode.vala \
  54         $(NULL)
  55
  56 libgxml_la_SOURCES = \
  57         gxml.vala.stamp \
  58         $(libgxml_la_VALASOURCES:.vala=.c) \
  59         $(NULL)
  60
  61 # Generate C code and headers, including GObject Introspection GIR files and VAPI file
  62 gxml-1.0.vapi gxml.vala.stamp GXml-1.0.gir: $(libgxml_la_VALASOURCES)
  63         $(VALA_COMPILER) $(VALAFLAGS) -C -H $(top_builddir)/gxml/gxml-dom.h --gir=GXmlDom-1.0.gir  --library gxmldom-1.0 $^
  64         @touch $@
  65
  66
  67 # Library configuration
  68 libgxml_la_LDFLAGS =
  69
  70 libgxml_la_LIBADD = \
  71         $(GLIB_LIBS) \
  72         $(LIBXML_LIBS) \
  73         $(GIO_LIBS) \
  74         $(GEE_LIBS) \
  75         $(VALA_LIBS) \
  76         $(NULL)
  77
  78 include_HEADERS = \
  79         gxml.h \
  80         $(NULL)
  81
  82
  83 pkgconfigdir = $(libdir)/pkgconfig
  84 pkgconfig_DATA = libgxml-1.0.pc
  85
  86 gxmlincludedir=$(includedir)/libgxml-1.0/gxml
  87 gxmlinclude_HEADERS= gxml-dom.h
  88
  89 # GObject Introspection
  90
  91 if ENABLE_GI_SYSTEM_INSTALL
  92 girdir = $(INTROSPECTION_GIRDIR)
  93 typelibsdir = $(INTROSPECTION_TYPELIBDIR)
  94 else
  95 girdir = $(datadir)/gir-1.0
  96 typelibsdir = $(libdir)/girepository-1.0
  97 endif
  98
  99 # GIR files are generated automatically by Valac so is not necessary to scan source code to generate it
 100 INTROSPECTION_GIRS =
 101 INTROSPECTION_GIRS += GXmlDom-1.0.gir
 102 INTROSPECTION_COMPILER_ARGS = \
 103     --includedir=. \
 104     --includedir=$(top_builddir)/gxml
 105
 106 GXmlDom-1.0.typelib: $(INTROSPECTION_GIRS)
 107         $(INTROSPECTION_COMPILER) $(INTROSPECTION_COMPILER_ARGS)  $&lt; -o $@
 108
 109 gir_DATA = $(INTROSPECTION_GIRS)
 110 typelibs_DATA = GXmlDom-1.0.typelib
 111
 112 vapidir = $(VALA_VAPIDIR)
 113 vapi_DATA=gxmldom-1.0.vapi
 114
 115 CLEANFILES += $(INTROSPECTION_GIRS) $(typelibs_DATA) gxml-1.0.vapi
 116
 117 EXTRA_DIST = \
 118         libgxml-1.0.pc.in \
 119         $(libgxml_la_VALASOURCES) \
 120         $(typelibs_DATA) \
 121         $(INTROSPECTION_GIRS) \
 122         gxml.vala.stamp
Compilation and linking using Command Line
Vala is not yet capable of directly creating dynamic or static libraries. To create a library, proceed with the -c (compile only) switch and link the object files with your favourite linker, i.e. libtool or ar.</p></div>
<div class="paragraph"><p>$ valac -c &#8230;(source files)
$ ar cx &#8230;(object files)
or by compiling the intermediate C code with gcc</p></div>
<div class="paragraph"><p>$ valac -C &#8230;(source files)
$ gcc -o my-best-library.so --shared -fPIC &#8230;(compiled C code files)&#8230;
Example
The following is an example of how to write a simple library in Vala, and also to compile and test it locally without having to install it first.</p></div>
<div class="paragraph"><p>Save the following code to a file test.vala. This is the actual library code, containing the functions we want to call from our main program.</p></div>
<div class="paragraph"><p>public class MyLib : Object {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>public void hello() {
    stdout.printf("Hello World, MyLib\n");
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    public int sum(int x, int y) {
        return x + y;
    }
}
Use the next command to generate test.c, test.h and test.vapi files. These are the C versions of the library to be compiled, and the VAPI file representing the library's public interface.</code></pre>
</div></div>
<div class="paragraph"><p>$ valac -C -H test.h --library test test.vala --basedir ./
Now compile the library:</p></div>
<div class="paragraph"><p>$ gcc --shared -fPIC -o libtest.so $(pkg-config --cflags --libs gobject-2.0) test.c
Save the following code to a file called hello.vala. This is the code that will use the library we have created.</p></div>
<div class="paragraph"><p>void main() {
    var test = new MyLib();
    test.hello();
    int x = 4, y = 5;
    stdout.printf("The sum of %d and %d is %d\n", x, y, test.sum(x, y));
}
Now compile the application code, telling the compiler that we want to link against the library we just created.</p></div>
<div class="paragraph"><p>$ valac -X -I. -X -L. -X -ltest -o hello hello.vala test.vapi --basedir ./
We can now run the program. This command states that any required libraries will be found in the current directory.</p></div>
<div class="paragraph"><p>$ LD_LIBRARY_PATH=$PWD ./hello
The output of the program should be:</p></div>
<div class="paragraph"><p>Hello World, MyLib
The sum of 4 and 5 is 9
You can also create a GObjectIntrospection GIR file for your library with the --gir option:</p></div>
<div class="paragraph"><p>valac -C test.vala --library test --gir Test-1.0.gir
GIR files are XML descriptions of the API.</p></div>
<div class="paragraph"><p>Binding Libraries with VAPI Files
VAPI files are descriptions of the public interface of external Vala libraries. When a library is written in Vala, this file is created by the Vala compiler, and basically an amalgamation of all public definitions from all Vala source files. For a library written in C, the VAPI file gets more complicated, particular if the naming conventions of the library do not follow the GLib convention. The VAPI file will in this case contain many annotations describing how the standardised Vala interface mangles onto the C version.</p></div>
<div class="paragraph"><p>This process of creating this generally amounts to three steps,</p></div>
<div class="paragraph"><p>Running vala-gen-introspect to extract metadata from the C library.</p></div>
<div class="paragraph"><p>Adding extra metadata to standardise the interface or make various other changes.
Generating a VAPI file from the above sources using vapigen.</p></div>
<div class="paragraph"><p>Specific instructions on how to generate bindings are in the Vala Bindings Tutorial</p></div>
<div class="paragraph"><p>Tools
The Vala distribution includes several programs to help you build and work with Vala applications. For more details of each tool, see the man pages.</p></div>
<div class="paragraph"><p>valac
valac is the Vala compiler. It&#8217;s primary function is to transform Vala code into compilable C code, though it can also automate the entire build and link project in simple cases.</p></div>
<div class="paragraph"><p>The simple case for use is:</p></div>
<div class="paragraph"><p>$ valac -o appname --pkg gee-1.0 file_name_1.vala file_name_2.vala
The -o switch requests that an object file is created, rather than just outputting C source files. The --pkg option says that this build needs information from the gee-1.0 package. You do not need to specify details about what libraries to link in, the package has this information internally. Finally, a list of source files is given. If you need a more complicated build process, use the -C switch to generate C files instead of a binary, and continue the process manually, or through a script.</p></div>
<div class="paragraph"><p>vapigen
vapigen is a tool to make bindings. It creates a VAPI files from a library&#8217;s metadata and any extra information required. See also Vala Bindings Tutorial.</p></div>
<div class="paragraph"><p>vala-gen-introspect
vala-gen-introspect is a tool for extracting metainformation about GObject based libraries. Nowadays, the preferred method is to use GObjectIntrospection instead, as vapigen can use GIR files directly. See also Vala Bindings Tutorial.</p></div>
<div class="paragraph"><p>Techniques
Debugging
For demonstration purposes we will create a buggy program by intentionally dereferencing a null reference, which will result in a segmentation fault:</p></div>
<div class="paragraph"><p>class Foo : Object {
    public int field;
}</p></div>
<div class="paragraph"><p>void main() {
    Foo? foo = null;
    stdout.printf("%d\n", foo.field);
}</p></div>
<div class="paragraph"><p>$ valac debug-demo.vala
$ ./debug-demo
Segmentation fault
So how do we debug this program? The -g command line option tells the Vala compiler to include Vala source code line information in the compiled binary, --save-temps keeps the temporary C source files:</p></div>
<div class="paragraph"><p>$ valac -g --save-temps debug-demo.vala
Vala programs can be debugged with the GNU Debugger gdb or one of its graphical front-ends, e.g. Nemiver.</p></div>
<div class="paragraph"><p>$ nemiver debug-demo
A sample gdb session:</p></div>
<div class="paragraph"><p>$ gdb debug-demo
(gdb) run
Starting program: /home/valacoder/debug-demo</p></div>
<div class="paragraph"><p>Program received signal SIGSEGV, Segmentation fault.
0x0804881f in _main () at debug-demo.vala:7
7           stdout.printf("%d\n", foo.field);
(gdb)
Using GLib
GLib includes a large set of utilities, including wrappers for most of the standard libc functions and more. These tools are available on all Vala platforms, even those which are not POSIX compliant. For a complete description of all that GLib provides, see the GLib Reference Manual. That reference is related to the C API for GLib, but it is mainly very simple to work out how to translate into Vala.</p></div>
<div class="paragraph"><p>The GLib functions are available in Vala through the following naming convention:</p></div>
<div class="paragraph"><p>C API</p></div>
<div class="paragraph"><p>Vala</p></div>
<div class="paragraph"><p>Example</p></div>
<div class="paragraph"><p>g_topic_foobar()</p></div>
<div class="paragraph"><p>GLib.Topic.foobar()</p></div>
<div class="paragraph"><p>GLib.Path.get_basename()</p></div>
<div class="paragraph"><p>The GLib types can be used similarly:</p></div>
<div class="paragraph"><p>Instantiate with</p></div>
<div class="paragraph"><p>Call an object member with</p></div>
<div class="paragraph"><p>GLib.Foo foo = new GLib.Foo();</p></div>
<div class="paragraph"><p>foo.bar();</p></div>
<div class="paragraph"><p>The APIs are not identical between C and Vala, but these naming rules should mean you can find the functions you need in the GLib VAPI files shipped with Vala, and from there find the parameters. This will hopefully suffice until more Vala documentation can be generated.</p></div>
<div class="paragraph"><p>File Handling
For flexible file I/O and file handling see GIO Samples.</p></div>
<div class="paragraph"><p>You can also use FileUtils.get_contents to load a file into a string.</p></div>
<div class="paragraph"><p>string content;
FileUtils.get_contents("file.vala", out content);</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-03-05 08:22:53 EET
</div>
</div>
</body>
</html>
