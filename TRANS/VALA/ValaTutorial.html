<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Vala Туторіал</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Vala Туторіал</h1>
</div>
<div id="content">
<div class="sect1">
<h2 id="_">Вступ</h2>
<div class="sectionbody">
<div class="paragraph"><p>Відмова від відповідальності: Vala - це постійно прогресуючий проект, і його функції можуть змінюватися. Я намагався, щоб цей підручник був якомога актуальнішим, але я не досконалий. Крім того, я не можу пообіцяти, що методи, які я пропоную, обов'язково є найкращими на практиці. Але знову, я спробую не відставати від цього.</p></div>
<div class="sect2">
<h3 id="___vala">Що таке Vala?</h3>
<div class="paragraph"><p>Vala - нова мова програмування, яка дозволяє використовувати сучасні методи програмування для запису програм, які працюють у бібліотеках виконання GNOME, зокрема <code>GLib</code> та <code>GObject</code>. Ця платформа з самого початку забезпечує дуже повне середовище програмування з такими функціями, як динамічна система типів та допоміжне управління пам’яттю. До Vala єдиними способами програмування для платформи було використання природного  машинного C API, який розкриває багато часто небажаних деталей. Або мовою високого рівня, яка має супутну віртуальну машину, як Python або мова Mono C#. Або, альтернативно, на C ++ через бібліотеку огортки.</p></div>
<div class="paragraph"><p>Vala відрізняється від усіх цих інших прийомів тим, що генерує код C, який можна компілювати для виконання без додаткової бібліотеки підтримки поза платформою GNOME. Це має кілька наслідків, але найголовніше:</p></div>
<div class="ulist"><ul>
<li>
<p>
Програми, написані на Vala, повинні мати схожу ефективність із програмами, написаними безпосередньо на С, при цьому писати та підтримувати їх легше та швидше.
</p>
</li>
<li>
<p>
Додаток Vala не може робити нічого, чого не може зробити еквівалент C. У той час як Vala вводить багато мовних особливостей, недоступних на мові C, всі вони відображаються на C-конструкції, хоча вони часто є складними або витрачають занадто багато часу, щоб писати їх безпосередньо.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Таким чином, хоча Vala - це сучасна мова з усіма можливостями, яких ви очікували, вона отримує свою силу від існуючої платформи і повинна певним чином відповідати встановленим нею правилам.</p></div>
</div>
<div class="sect2">
<h3 id="____">Для кого цей підручник?</h3>
<div class="paragraph"><p>Цей підручник не буде заглиблюватися в основні практики програмування. Він лише коротко пояснить принципи об'єктно-орієнтованого програмування. Натомість зосередиться на тому, як Vala застосовує ці концепції. Таким чином, це буде корисно, якщо ви вже маєте досвід роботи з різними мовами програмування, хоча глибокі знання будь-якої конкретної мови не потрібні.</p></div>
<div class="paragraph"><p>Vala має багато синтаксису від C#, але я постараюся уникати опису функцій з точки зору їх подібності чи відмінності з C# або Java, з метою зробити підручник більш доступним.</p></div>
<div class="paragraph"><p>Корисним буда пристойне розуміння C. Хоча це не потрібно для розуміння Vala per se, важливо усвідомити, що програми Vala виконуються як C, і часто взаємодіють із бібліотеками С. Знання C, безумовно, полегшить глибше розуміння Vala.</p></div>
</div>
<div class="sect2">
<h3 id="__2">Домовленості</h3>
<div class="paragraph"><p>Код в тексті виглядатиме як <code>моноширинний</code>, командам буде передувати <code>$</code>. Крім цього, все повинно бути очевидним. Я схильний кодувати дуже явно, включаючи деяку інформацію, яка насправді може бути опущена. Я спробую пояснити, де деякі речі можна опустити, але це не означає, що я заохочую вас до цього.</p></div>
<div class="paragraph"><p>У якийсь момент я додам посилання на документацію Vala, але це ще не можливо.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Перша програма</h2>
<div class="sectionbody">
<div class="paragraph"><p>На жаль передбачувано, але все ж:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span><span class="p">.</span><span class="n">HelloWorld</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, це програма Vala <code>Hello World</code>. Я сподіваюся, що ви зможете розпізнати деякі її частини досить добре, але щоб бути ретельним, я перегляну код крок за кроком.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span><span class="p">.</span><span class="n">HelloWorld</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей рядок вказує на початок визначення класу. Класи у Vala за концепцією дуже схожі на інші мови. Клас - це в основному тип об'єкта, з якого можуть бути створені екземпляри, що мають однакові властивості. Про реалізацію класових типів опікується бібліотека <code>gobject</code>, але детальна інформація про це не важлива для загального використання.</p></div>
<div class="paragraph"><p>Важливо зазначити, що цей клас спеціально описаний як підклас <code>GLib.Object</code>. Це тому, що Vala допускає інші типи класів, але в більшості випадків це саме той тип, який ви хочете. Насправді, деякі мовні функції Vala доступні лише у тому випадку, якщо ваш клас походить від <code>GLib.Object</code>.</p></div>
<div class="paragraph"><p>В інших частинах цього рядка показані простори імен та повністю кваліфіковані імена, хоча вони будуть пояснені пізніше.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
</pre></div></div></div>
<div class="paragraph"><p>Це початок визначення методу. Метод - це функція, пов'язана з типом об'єкта, яка може бути виконана на об'єкті цього типу. Статичний метод означає, що метод можна викликати, не володіючи конкретним екземпляром типу. Той факт, що цей метод називається <code>main</code> і має певну сигнатуру, означає, що Vala визнає його як вхідну точку програми.</p></div>
<div class="paragraph"><p>Метод <code>main</code> не повинен визначатися всередині класу. Однак якщо він визначений всередині класу, він повинен бути статичним. Не має значення, чи він <code>public</code> чи <code>private</code>. Тип повернення може бути <code>int</code> або <code>void</code>. З типом повернення <code>void</code> програма неявно завершиться з кодом виходу 0. Параметр масиву рядків, що містить аргументи командного рядка, необов'язковий.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><code>stdout</code> - це об'єкт у просторі імен <code>GLib</code>, до якого Vala за потреби забезпечує доступ. Цей рядок доручає Vala виконати метод, який називається <code>printf</code> об'єкта <code>stdout</code>, з рядком привітання в якості аргумента. У Vala це завжди синтаксис, який ви використовуєте для виклику методу на об’єкті, або для доступу до даних об’єкта. <code>\n</code> - <em>ескейп послідовність</em> нового рядка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>return</code> означає повернути значення в точку виклику і припинити виконання методу <code>main</code>, що також припиняє виконання програми. Після цього повернене значення методу <code>main</code> сприймається як <em>код завершення</em> програми.</p></div>
<div class="paragraph"><p>Останні рядки просто закінчують визначення методу та класу.</p></div>
<div class="sect2">
<h3 id="___">Компіляція і виконання</h3>
<div class="paragraph"><p>Якщо припустити, що у вас встановлено Vala, то для компіляції та виконання цієї програми потрібно таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac hello.vala
$ ./hello
</pre></div></div></div>
<div class="paragraph"><p><code>valac</code> - компілятор Vala, який компілює ваш код Vala у двійковий. Отриманий двійковий файл матиме те саме ім'я, що і вихідний файл, і потім може бути безпосередньо виконаний на машині. Ви можете, напевно, здогадатися про результат.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__3">Основи</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="____2">Файли та компіляція</h3>
<div class="paragraph"><p>Код Vala записується у файли з розширеннями <code>.vala</code>. Vala не нав'язує стільки структури, як такі мови, як Java - немає таких самих понять пакетів або файлів класів. Натомість структура визначається текстом всередині кожного файлу, описуючи логічне розташування коду завдяки такими конструкціями, як простори імен. Коли ви хочете компілювати код Vala, ви даєте компілятору список необхідних файлів, і Vala розбереться, як вони пасують разом.</p></div>
<div class="paragraph"><p>Підсумок всього цього полягає в тому, що ви можете помістити стільки класів або функцій у файл, скільки хочете, навіть комбінуючи частини різних просторів імен разом. Це не обов'язково гарна ідея. Є певні умови, яких ви, мабуть, хочете дотримуватися. Хорошим прикладом того, як структурувати проект у Vala, є сам проект Vala.</p></div>
<div class="paragraph"><p>Усі вихідні файли для того ж пакету подаються як параметри командного рядка до компілятора Vala <code>valac</code> разом із флагами компілятора. Це працює аналогічно тому, як компілюється вихідний код Java. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac compiler.vala --pkg libvala
</pre></div></div></div>
<div class="paragraph"><p>буде виробляти двійковий файл на ім'я <code>compiler</code>, який зв'язується з пакунком <code>libvala</code>. Насправді саме так створюється компілятор <code>valac</code>!</p></div>
<div class="paragraph"><p>Якщо ви хочете, щоб двійковий файл мав інше ім’я, або якщо ви передали компілятору кілька вихідних файлів, ви можете вказати ім’я результата явно, за допомогою перемикача <code>-o</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac source1.vala source2.vala -o myprogram
$ ./myprogram
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви надасте <code>valac</code> перемикач <code>-C</code>, він не компілює вашу програму у двійковий файл. Натомість він виведе проміжний код C для кожного з ваших вихідних файлів Vala у відповідний вихідний файл C - у цьому випадку <code>source1.c</code> та <code>source2.c</code>. Якщо ви подивитесь на вміст цих файлів, то можна побачити, що програмування класу у Vala еквівалентно тому самому завданню на C, але набагато більш лаконічним. Ви також помітите, що цей клас динамічно реєструється в запущеній системі. Це хороший приклад потужності платформи GNOME, але, як я вже говорив раніше, вам не потрібно багато знати про це, щоб використовувати Vala.</p></div>
<div class="paragraph"><p>Якщо ви хочете мати файл заголовка С для свого проекту, ви можете використовувати перемикач <code>-H</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac hello.vala -C -H hello.h
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Огляд синтаксису</h2>
<div class="sectionbody">
<div class="paragraph"><p>Синтаксис Vala - це амальгама, заснована на С#. Як результат, більша його частина буде знайома програмістам, які знають будь-яку мову, схожу на С, і, зважаючи на це, я резюмував все.</p></div>
<div class="paragraph"><p>Область застосування визначається за допомогою фігурних дужок. Об'єкт або посилання дійсні лише між <code>{</code> і <code>}</code>. Це також роздільники, які використовуються для визначення класів, методів, блоків коду тощо, тому вони автоматично мають власну сферу застосування. Vala не сувора щодо місця декларування змінних.</p></div>
<div class="paragraph"><p>Ідентифікатор визначається його типом та назвою, наприклад <code>int c</code> означає ціле число на ім'я <code>c</code>. У випадку типів значень це також створює об'єкт даного типу. Для типів посилань вони просто визначають нове посилання, яке спочатку не вказує ні на що.</p></div>
<div class="paragraph"><p>Імена ідентифікатора можуть бути будь-якою комбінацією літер (<code>[a-z]</code>, <code>[A-Z]</code>), підкреслення та цифр. Однак, щоб визначити або посилатися на ідентифікатор з іменем, яке або починається з цифри, або є ключовим словом, потрібно встановити його префіксом символ <code>"@"</code>. Цей символ не вважається частиною імені. Наприклад, ви можете назвати метод <code>foreach</code>, написавши <code>@foreach</code>, навіть якщо це зарезервоване ключове слово Vala. Ви можете опустити символ <code>"@"</code>, коли його можна однозначно інтерпретувати як ім'я ідентифікатора, наприклад у <code>foo.foreach ()</code>.</p></div>
<div class="paragraph"><p>Типи посилань ініціюються за допомогою оператора <code>new</code> та назви способу побудови, що зазвичай є лише назвою типу, наприклад <code>Object o = new Object()</code> створює новий <code>Object</code> і робить <code>o</code> посиланням на нього.</p></div>
<div class="sect2">
<h3 id="__4">Коментарі</h3>
<div class="paragraph"><p>Vala дозволяє коментувати в коді різними способами.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Коментар продовжується до кінця рядка</span>

<span class="cm">/* Коментар триває між роздільниками */</span>

<span class="cm">/**</span>
<span class="cm"> * Коментар до документації</span>
<span class="cm"> */</span>
</pre></div></div></div>
<div class="paragraph"><p>Вони обробляються так само, як і в більшості інших мов, тому потребують невеликих пояснень. Зауваження щодо документації насправді не особливі для Vala, але інструмент генерації документації, як Valadoc, розпізнає їх.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___3">Типи даних</h2>
<div class="sectionbody">
<div class="paragraph"><p>Загалом, у Vala є два типи даних: типи посилань та типи значень. Ці імена описують, як екземпляри типів передаються по системі - тип значення копіюється кожного разу, коли він присвоюється новому ідентифікатору, тип посилання не копіюється, натомість новий ідентифікатор - це просто нове посилання на той самий об’єкт.</p></div>
<div class="paragraph"><p>Константа визначається, ставлячи <code>const</code> перед типом. Домовленість іменування констант - <code>ALL_UPPER_CASE</code>.</p></div>
<div class="sect3">
<h4 id="___4">Типи значення</h4>
<div class="paragraph"><p>Vala підтримує набір простих типів, як це робить більшість інших мов.</p></div>
<div class="ulist"><ul>
<li>
<p>
Byte, <code>char</code>, <code>uchar</code>; їхні імена є <code>char</code> з історичних причин.
</p>
</li>
<li>
<p>
Character, <code>unichar</code>; 32-розрядний символ Unicode
</p>
</li>
<li>
<p>
Integer, <code>int</code>, <code>uint</code>
</p>
</li>
<li>
<p>
Long Integer, <code>long</code>, <code>ulong</code>
</p>
</li>
<li>
<p>
Short Integer, <code>short</code>, <code>ushort</code>
</p>
</li>
<li>
<p>
Integer гарантованої довжини, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, так само як їх беззнакові варіанти <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>. Цифри позначають довжину в бітах.
</p>
</li>
<li>
<p>
Float, <code>float</code>, <code>double</code>
</p>
</li>
<li>
<p>
Boolean, <code>bool</code>; можливі значення <code>true</code> та <code>false</code>
</p>
</li>
<li>
<p>
Compound, <code>struct</code>
</p>
</li>
<li>
<p>
Enumeration, <code>enum</code>; представлені цілими значеннями, а не класами, як перерахунки Java
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ось кілька прикладів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="o">*</span> <span class="err">атомарні</span> <span class="err">типи</span> <span class="o">*</span> <span class="o">/</span>
<span class="kt">unichar</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">&#39;u&#39;</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">percentile</span> <span class="o">=</span> <span class="mf">0.75f</span><span class="p">;</span>
<span class="kd">const</span> <span class="kt">double</span> <span class="n">MU_BOHR</span> <span class="o">=</span> <span class="mf">927.400915E-26</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">the_box_has_crashed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">визначення</span> <span class="err">структури</span> <span class="o">*</span> <span class="o">/</span>
<span class="kd">struct</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">визначення</span> <span class="k">enum</span> <span class="o">*</span> <span class="o">/</span>
<span class="k">enum</span> <span class="n">WindowType</span> <span class="p">{</span>
    <span class="n">TOPLEVEL</span><span class="p">,</span>
    <span class="n">POPUP</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Більшість цих типів можуть мати різні розміри на різних платформах, за винятком цілих типів із гарантованим розміром. Оператор <code>sizeof</code> повертає розмір, який займає змінна даного типу в байтах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">ulong</span> <span class="n">nbytes</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int32</span><span class="p">);</span>    <span class="c1">// nbytes складе 4 (= 32 біта)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете визначити мінімальні та максимальні значення числового типу за допомогою <code>.MIN</code> та <code>.MAX</code>, наприклад <code>int.MIN</code> та <code>int.MAX</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__5">Рядки</h4>
<div class="paragraph"><p>Тип даних для рядків - це <code>string</code>. Рядки Vala кодуються UTF-8 та є незмінні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;Рядковий літерал&quot;</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala пропонує функцію, яку називають дослівними рядками. Це рядки, в яких ескейп послідовності (наприклад, <code>\n</code>) не інтерпретуються, розриви рядків будуть збережені, а лапки не потрібно маскувати. Вони утворюються потрійними подвійними лапками. Можливі відступи після розриву рядка також є частиною рядка.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">verbatim</span> <span class="o">=</span> <span class="s">&quot;&quot;&quot;Це так званий &quot;</span><span class="err">дослівний</span> <span class="err">рядок</span><span class="s">&quot;.</span>
<span class="err">Дослівні</span> <span class="err">рядки</span> <span class="err">не</span> <span class="err">обробляють</span> <span class="err">ескейп</span> <span class="err">послідовності</span><span class="p">,</span> <span class="err">такі</span> <span class="err">як</span> <span class="err">\</span><span class="n">n</span><span class="p">,</span> <span class="err">\</span><span class="n">t</span><span class="p">,</span> <span class="err">\\</span><span class="p">,</span> <span class="n">etc</span><span class="p">.</span>
<span class="err">Вони</span> <span class="err">можуть</span> <span class="err">містити</span> <span class="err">лапки</span> <span class="err">і</span> <span class="err">охоплювати</span> <span class="err">декілька</span> <span class="err">рядків</span> <span class="err">поспіль</span><span class="p">.</span><span class="s">&quot;&quot;&quot;;</span>
</pre></div></div></div>
<div class="paragraph"><p>Рядки з префіксом <code>"@"</code> - це шаблони рядків. Вони можуть оцінювати вбудовані змінні та вирази з префіксом <code>"$"</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">@&quot;$a * $b = $(a * b)&quot;</span><span class="p">;</span>  <span class="c1">// =&gt; &quot;6 * 7 = 42&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператори рівності <code>==</code> і <code>!=</code> порівнюють зміст двох рядків, всупереч поведінці Java, яка в цьому випадку перевіряє рівність посилань.</p></div>
<div class="paragraph"><p>Ви можете нарізати рядок за допомогою <code>[start: end]</code>. Від'ємні значення представляють позиції відносно кінця рядка:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">greeting</span> <span class="o">=</span> <span class="s">&quot;hello, world&quot;</span><span class="p">;</span>
<span class="kt">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">7</span><span class="o">:</span><span class="mi">12</span><span class="p">];</span>        <span class="c1">// =&gt; &quot;world&quot;</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="o">:-</span><span class="mi">2</span><span class="p">];</span>       <span class="c1">// =&gt; &quot;or&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що індекси у Vala починаються з 0, як у більшості інших мов програмування. Починаючи з Vala 0,11, ви можете отримати доступ до одного байта рядка за допомогою <code>[index]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">uint8</span> <span class="n">b</span> <span class="o">=</span> <span class="n">greeting</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>             <span class="c1">// =&gt; 0x77</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак ви не можете призначити нове значення байту в цій позиції, оскільки рядки Vala незмінні.</p></div>
<div class="paragraph"><p>Багато основних типів мають розумні методи розбору та перетворення на рядки, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;false&quot;</span><span class="p">);</span>           <span class="c1">// =&gt; false</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;-52&quot;</span><span class="p">);</span>               <span class="c1">// =&gt; -52</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="kt">double</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="s">&quot;6.67428E-11&quot;</span><span class="p">);</span> <span class="c1">// =&gt; 6.67428E-11</span>
<span class="kt">string</span> <span class="n">s1</span> <span class="o">=</span> <span class="nb">true</span><span class="p">.</span><span class="n">to_string</span><span class="p">();</span>           <span class="c1">// =&gt; &quot;true&quot;</span>
<span class="kt">string</span> <span class="n">s2</span> <span class="o">=</span> <span class="mf">21.</span><span class="n">to_string</span><span class="p">();</span>             <span class="c1">// =&gt; &quot;21&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Two useful methods for writing and reading strings to/from the console (and for your first explorations with Vala) are stdout.printf() and stdin.read_line():
Два корисні методи для запису та читання рядків до/з консолі (і для ваших перших досліджень Vala) - <code>stdout.printf()</code> та <code>stdin.read_line ()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, world</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %g %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">,</span> <span class="s">&quot;Vala&quot;</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">input</span> <span class="o">=</span> <span class="n">stdin</span><span class="p">.</span><span class="n">read_line</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">stdin</span><span class="p">.</span><span class="n">read_line</span><span class="p">());</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви вже знаєте <code>stdout.printf()</code> з прикладу Hello World. Насправді він може приймати довільну кількість аргументів різних типів, тоді як перший аргумент - це рядок формату, дотримуючись тих же правил, що і рядки формату C. Якщо потрібно вивести повідомлення про помилку, ви можете використовувати <code>stderr.printf()</code> замість <code>stdout.printf()</code>.</p></div>
<div class="paragraph"><p>Крім того, операція <code>in</code> може бути використана для визначення того, чи містить один рядок інший, наприклад</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="s">&quot;ere&quot;</span> <span class="k">in</span> <span class="s">&quot;Able was I ere I saw Elba.&quot;</span><span class="p">)</span> <span class="p">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Для отримання додаткової інформації, будь ласка, посилайтесь на <a href="http://www.valadoc.org/glib-2.0/string.html">повний огляд класу <code>string</code></a>.</p></div>
<div class="paragraph"><p>Зразок програми, що демонструє використання рядків, <a href="https://wiki.gnome.org/Projects/Vala/StringSample">також доступний</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__6">Масиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Масив оголошується шляхом надання імені типу, за яким слідує <code>[]</code>, і створюється за допомогою оператора <code>new</code>, наприклад <code>int [] a = new int[10]</code> для створення масиву цілих чисел. Довжина такого масиву може бути отримана через змінну <code>length</code>, наприклад <code>int count = a.length</code>. Зауважте, що коли ви пишете <code>Object[] a = new Object[10]</code>, об’єкти не створюватимуться, але тільки масив для їх зберігання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span> <span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете нарізати масив за допомогою <code>[start: end]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>     <span class="c1">// =&gt; { 4, 6 }</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарізання масиву призведе до посилання на запитувані дані, а не до копії. Однак присвоєння фрагмента власниковій змінній (як це зроблено вище) призведе до копіювання. Якщо ви хочете уникнути копії, потрібно або призначити фрагмент <code>unowned</code> масиву, або передати його безпосередньо аргументу (аргументи за замовчуванням <code>unowned</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">unowned</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="o">:</span><span class="mi">3</span><span class="p">];</span>     <span class="c1">// =&gt; { 4, 6 }</span>
</pre></div></div></div>
<div class="paragraph"><p>Багатовимірні масиви визначаються за допомогою <code>[,]</code> або <code>[,,]</code> тощо.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">},</span>
            <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">},</span>
            <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">}};</span>
<span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей вид масиву представлений єдиним суміжним блоком пам'яті. Зубчасті багатовимірні масиви (<code>[][]</code>, також відомі як "накладені масиви" або "масиви масивів"), де кожен рядок може мати різну довжину, ще не підтримуються.</p></div>
<div class="paragraph"><p>Щоб знайти довжину кожного виміру в багатовимірному масиві, член <code>length</code> стає масивом, зберігаючи довжину кожного відповідного виміру.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">.</span><span class="n">length</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div></div></div>
<div class="paragraph"><p>Зверніть увагу, що ви не можете отримати одновимірний масив з багатовимірного масиву або навіть зрізати багатовимірний масив:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[,]</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">},</span>
                <span class="p">{</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}};</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">b</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">c</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">,];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">d</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="o">:</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">e</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">];</span>  <span class="c1">// не робить</span>
<span class="kt">int</span><span class="p">[,]</span> <span class="n">f</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="o">:</span><span class="mi">1</span><span class="p">];</span>  <span class="c1">// не робить</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете додавати елементи масиву динамічно за допомогою оператора <code>+=</code>. Однак це працює лише для локально визначених або приватних масивів. При необхідності масив автоматично перерозподіляється. Внутрішньо це перерозподіл відбувається з розмірами, що зростають ступенями двох, з міркувань ефективності роботи. Однак <code>length</code> містить фактичну кількість елементів, а не внутрішній розмір.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">e</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">12</span><span class="p">;</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">e</span> <span class="o">+=</span> <span class="mi">37</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете змінити розмір масиву, викликавши для нього <code>resize()</code>. Він збереже оригінальний вміст (стільки, скільки вміщається).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
<span class="n">a</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">12</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете переміщувати елементи в масиві, викликаючи <code>move(src, dest, length)</code> на ньому. Початкові позиції будуть заповнені 0.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">uint8</span><span class="p">[]</span> <span class="n">chars</span> <span class="o">=</span> <span class="s">&quot;hello world&quot;</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
<span class="n">chars</span><span class="p">.</span><span class="n">move</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">print</span> <span class="p">((</span><span class="kt">string</span><span class="p">)</span> <span class="n">chars</span><span class="p">);</span> <span class="c1">// &quot;world &quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви поставите квадратні дужки після ідентифікатора разом із зазначенням розміру, ви отримаєте масив фіксованого розміру. Масиви фіксованого розміру розподіляються на стеку (якщо вони використовуються як локальні змінні) або виділяються інлайн (якщо вони використовуються як поля), і ви не можете їх перерозподілити пізніше.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">// без &#39;new ...&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala не проводить перевірки меж для доступу до масиву під час виконання. Якщо вам потрібна більша безпека, ви повинні використовувати більш складну структуру даних, як <code>ArrayList</code>. Про це ви дізнаєтесь далі у розділі про колекції.</p></div>
<div class="sect2">
<h3 id="___5">Типи посилань</h3>
<div class="paragraph"><p>Типи посилань - це всі типи, оголошені як клас, незалежно від того, походять вони з <code>Object</code> GLib чи ні. Vala гарантує, що при передачі об'єкта за посиланням система буде відслідковувати кількість посилань, що наразі є активними, щоб керувати пам'яттю для вас. Значення посилання, яке нікуди не вказує, є <code>null</code>. Детальніше про класи та їх особливості в розділі про об’єктно-орієнтоване програмування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cm">/* визначення класу */</span>
<span class="kd">class</span> <span class="nc">Track</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>             <span class="cm">/* субклас &#39;GLib.Object&#39; */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">mass</span><span class="p">;</span>                 <span class="cm">/* публічне поле */</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>    <span class="cm">/* публічна властивість */</span>
    <span class="kd">private</span> <span class="kt">bool</span> <span class="n">terminated</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>    <span class="cm">/* приватне поле */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">terminate</span><span class="p">()</span> <span class="p">{</span>           <span class="cm">/* публічний метод */</span>
        <span class="n">terminated</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Статичне приведення типів</h3>
<div class="paragraph"><p>У Vala ви можете привести змінну від одного типу до іншого. Для приведення статичного типу змінна перетворюється на потрібний, задаючи ім'я типу з дужками. Статичне приведення не накладає перевірки безпеки типу часу виконання. Це працює для всіх типів Vala. Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">i</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala підтримує інший механізм приведення під назвою динамічний кастинг, який виконує перевірку типу часу виконання та описаний у розділі про об'єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Виведення типів</h3>
<div class="paragraph"><p>Vala має механізм, який називається виведенням типу, за яким локальна змінна може бути визначена за допомогою <code>var</code> замість надання типу, доки не має сумніву, який тип мається на увазі. Тип виводиться з правого боку присвоєння. Це допомагає зменшити зайву надмірність у вашому коді без шкоди для статичної типізації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>     <span class="c1">// те саме: Person p = new Person();</span>
<span class="kd">var</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>          <span class="c1">// те саме: string s = &quot;hello&quot;;</span>
<span class="kd">var</span> <span class="n">l</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// те саме: List&lt;int&gt; l = new List&lt;int&gt;();</span>
<span class="kd">var</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>               <span class="c1">// те саме: int i = 10;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це працює лише для локальних змінних. Виведення типу особливо корисне для типів із дженеріками - аргументами типів (докладніше про них пізніше). Порівняйте</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>vs.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyFoo</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="n">MyBar</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">();</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____">Визначення нового типу від інших</h3>
<div class="paragraph"><p>Визначення нового типу - це питання вивести його з потрібного. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">/</span> <span class="o">*</span> <span class="err">Визначення</span> <span class="err">новий</span> <span class="err">тип</span> <span class="err">із</span> <span class="err">контейнера</span> <span class="err">типу</span> <span class="n">GLib</span><span class="p">.</span><span class="n">List</span> <span class="err">з</span> <span class="err">елементами</span> <span class="err">типу</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Value</span> <span class="o">*</span> <span class="o">/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ValueList</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">List</span><span class="o">&lt;</span><span class="n">GLib</span><span class="p">.</span><span class="n">Value</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="p">[</span><span class="nd">CCode</span> <span class="p">(</span><span class="n">has_construct_function</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)]</span>
        <span class="kd">protected</span> <span class="n">ValueList</span> <span class="p">();</span>
        <span class="kd">public</span> <span class="kd">static</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Type</span> <span class="n">get_type</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__7">Оператори</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>=</code>
призначення. Лівий операнд повинен бути ідентифікатором, а правий повинен приводити до значення або посилання відповідно.</p></div>
<div class="paragraph"><p><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>%</code>
основна арифметика, застосована до лівого і правого операндів. Оператор <code>+</code> також може об'єднати рядки.</p></div>
<div class="paragraph"><p><code>+=</code>, <code>-=</code>, <code>/=</code>, <code>*=</code>, <code>%=</code>
арифметична операція між лівим і правим операндами, де лівий повинен бути ідентифікатором, якому присвоюється результат.</p></div>
<div class="paragraph"><p><code>++</code>, <code>--</code>
операції збільшення та зменшення з неявним призначенням. Вони беруть лише один аргумент, який повинен бути ідентифікатором простого типу даних. Значення буде змінено і присвоєно назад ідентифікатору. Ці оператори можуть бути розміщені або в позиціях префікса, або в постфіксі - при першому оцінене значення оператора буде щойно обчисленим значенням, при другому повертається початкове значення.</p></div>
<div class="paragraph"><p><code>|</code>, <code>^</code>, <code>&amp;</code>, <code>~</code>, <code>|=</code>, <code>&amp;=</code>, <code>^=</code>
побітові операції: або, ексклюзивні або, і, ні. Другий набір включає призначення і є аналогом арифметичних версій. Вони можуть бути застосовані до будь-якого з простих типів значень. (Немає жодного оператора присвоєння, пов'язаного з <code>~</code>, тому що це одномісний оператор. Еквівалентна операція просто <code>a = ~a</code>).</p></div>
<div class="paragraph"><p><code>&lt;&lt;</code>, <code>&gt;&gt;</code>
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда.</p></div>
<div class="paragraph"><p><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда. Лівий операнд повинен бути ідентифікатором, якому присвоюється результат.</p></div>
<div class="paragraph"><p><code>==</code>
тест на рівність. Оцінюється до значення <code>bool</code>, залежно від того, чи рівні лівий і правий операнди. У випадку типів значень це означає, що їх значення рівні, у випадку референсних типів об'єкти - це той самий екземпляр. Виняток із цього правила - тип рядка, який тестується на рівність за значенням.</p></div>
<div class="paragraph"><p><code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>
тести на нерівність. Оцінює значення до <code>bool</code> залежно від того, чи відрізняються лівий і правий операнди описаним способом. Вони дійсні для простих типів даних та типу рядка. Для рядків ці оператори порівнюють лексикографічний порядок.</p></div>
<div class="paragraph"><p><code>!</code>, <code>&amp;&amp;</code>, <code>||</code>
логічні операції: не, і, або. Ці операції можуть бути застосовані до булевих значень - перший приймає лише одне значення, інші - дві.</p></div>
<div class="paragraph"><p><code>? :</code>
ternary conditional operator. Evaluates a condition and returns either the value of the left or the right sub-expression based on whether the condition is true or false: condition ? value if true : value if false
потрійний умовний оператор. Оцінює умову і повертає або значення лівого, або правого підвиразу, виходячи з того, чи є умова істинною чи помилковою: <code>умова ? true значення: false значення</code></p></div>
<div class="paragraph"><p><code>??</code>
оператор <code>null</code> поглинання: <code>a ?? b</code> еквівалентно <code>a != null ? a : b</code>. Цей оператор корисний, наприклад, для надання значення за замовчуванням у випадку, якщо посилання є <code>null</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="o">??</span> <span class="s">&quot;unknown person&quot;</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><code>in</code>
перевіряє, чи містить правий операнд лівий операнд. Цей оператор працює над масивами, рядками, колекціями або будь-яким іншим типом, який має відповідний метод <code>contains()</code>. Для рядків він виконує пошук підрядків.</p></div>
<div class="paragraph"><p>Операторів не можна перевантажувати у Vala. Існують додаткові оператори, які дійсні в контексті лямбда-декларацій та інших конкретних завдань - вони пояснюються в контексті, в якому вони застосовуються.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___7">Структури управління</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде декрементувати повторно, перевіряючи перед кожною ітерацією, що <code>a</code> більше <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">do</span> <span class="p">{</span> <span class="n">a</span><span class="o">--</span><span class="p">;</span> <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>буде декрементувати повторно, перевіряючи після кожної ітерації, що <code>a</code> більше <code>b</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде ініціалізувати <code>а</code> до <code>0</code>, а потім друкувати повторно, доки <code>а</code> не буде менше <code>10</code>, збільшуючи <code>а</code> після кожної ітерації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="k">in</span> <span class="n">int_array</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде друкувати кожне ціле число в масиві чи іншій ітерабельній колекції. Значення "ітерабельного" буде описано пізніше.</p></div>
<div class="paragraph"><p>Усі чотири попередні типи циклу можуть керуватися ключовими словами <code>break</code> та <code>continue</code>. Інструкція <code>break</code> призведе до негайного завершення циклу, а <code>continue</code> перейде прямо до тестової частини ітерації.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is greater than 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is less than 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
<span class="k">else</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a is equal to 0</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>виконує певний фрагмент коду на основі набору умов. Перша умова, яка відповідає, визначає, який код буде виконуватися, якщо <code>a</code> більше <code>0</code>, не перевірятиметься, чи вона менша за <code>0</code>. Дозволяється будь-яка кількість блоків <code>else if</code>, та нуль або один блок <code>else</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;one</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
<span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;two or three</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">default</span><span class="o">:</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;unknown</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>switch</code> виконує рівно один або жодного розділу коду на основі значення, переданого йому. У Vala немає провалів між випадками, крім порожніх. Для того, щоб забезпечити це, кожен непустий випадок повинен закінчуватися <code>break</code>, <code>return</code> або <code>throw</code>. Можна використовувати оператори <code>switch</code> з рядками.</p></div>
<div class="paragraph"><p>Примітка для програмістів на C: умови завжди повинні оцінюватися як булеві значення. Це означає, що якщо ви хочете перевірити змінну на <code>null</code> або <code>0</code>, ви повинні зробити це явно: <code>if (object! = Null) {}</code> або <code>if (number! = 0) {}</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="___8">Мовні елементи</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="__8">Методи</h4>
<div class="paragraph"><p>Функції називаються методами у Vala, незалежно від того, визначені вони всередині класу чи ні. Відтепер ми будемо дотримуватися терміну <em>метод</em>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">method_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">arg1</span><span class="p">,</span> <span class="n">Object</span> <span class="n">arg2</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код визначає метод, який має ім'я <code>method_name</code>, беручи два аргументи, один ціле число, а другий - <code>Object</code> (перший передається за значенням, другий - як посилання, як описано). Метод поверне ціле число, яке в даному випадку дорівнює <code>1</code>.</p></div>
<div class="paragraph"><p>Усі методи Vala є функцією C, тому беруть довільну кількість аргументів і повертають одне значення (або жодного, якщо метод визнаний <code>void</code>). Вони можуть наблизити більше значень повернення, розміщуючи дані у місцях, відомих коду виклику. Детальніше про те, як це зробити, ви знайдете в розділі "Напрямки параметрів" у розширеній частині цього підручника.</p></div>
<div class="paragraph"><p>Домовленість іменування методів у Vala - це <code>all_lower_case</code>, з підкресленнями в якості роздільника слів. Це може бути трохи незнайоме програмістам на C# або Java, які звикли до імен методів <code>CamelCase</code> або <code>mixedCamelCase</code>. Але з цим стилем ви будете узгоджені з іншими бібліотеками Vala та C/GObject.</p></div>
<div class="paragraph"><p>Неможливо мати кілька методів з тим самим іменем, але різні сигнатури в межах однієї області ("перевантаження методів"):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">draw</span><span class="p">(</span><span class="n">Shape</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>  <span class="c1">// неможливе</span>
</pre></div></div></div>
<div class="paragraph"><p>Це пов’язано з тим, що бібліотеки, створені з Vala, призначені для використання також для програмістів на C. У Vala ви зробили б щось подібне замість цього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">draw_text</span><span class="p">(</span><span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">draw_shape</span><span class="p">(</span><span class="n">Shape</span> <span class="n">shape</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Вибравши трохи інші імена, ви можете уникнути зіткнення імен. В мовах, що підтримують перевантаження методів, це часто використовується для надання зручних методів з меншою кількістю параметрів, що призводить до виклику найбільш загального методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">);</span> <span class="p">}</span>  <span class="c1">// неможливе</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span><span class="p">);</span> <span class="p">}</span>           <span class="c1">// неможливе</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку ви можете скористатись можливістю надати параметру значення за замовчуванням, щоб досягти подібної поведінки лише одним методом. Ви можете визначити значення за замовчуванням для останніх параметрів методу, так що вам не доведеться їх явно передавати при виклику методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Деякі можливі виклики цього методу можуть бути:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;hi&quot;</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Можна навіть визначити методи з реальними списками аргументів змінної довжини (<code>varargs</code>), такими як <code>stdout.printf()</code>, хоча це не обов'язково рекомендується. Ви дізнаєтесь, як це зробити пізніше.</p></div>
<div class="paragraph"><p>Vala здійснює основну перевірку на <code>null</code>-здатність параметри методу та значення повернення. Якщо припустимо, що параметр методу або значення, що повертається, мають значення <code>null</code>, символ типу повинен бути постфіксований модифікатором <code>?</code>. Ця додаткова інформація допомагає компілятору Vala виконувати статичні перевірки та додавати припущення часу виконання для методів, що може допомогти уникнути пов'язаних помилок, таких як використання <code>null</code> посилання.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span><span class="o">?</span> <span class="n">method_name</span><span class="p">(</span><span class="kt">string</span><span class="o">?</span> <span class="n">text</span><span class="p">,</span> <span class="n">Foo</span><span class="o">?</span> <span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>In this example text, foo and the return value may be null, however, bar must not be null.
У цьому прикладі <code>text</code>, <code>foo</code> та значення, що повертаються, можуть бути <code>null</code>, проте <code>bar</code> не повинна бути <code>null</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__9">Делегати</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Делегати представляють методи, що дозволяють передавати фрагменти коду як об'єкти. Наведений вище приклад визначає новий тип з назвою <code>DelegateType</code>, який представляє методи, що приймають <code>int</code> та не повертає жодного значення. Будь-який метод, що відповідає цій сигнатурі, може бути призначений змінній цього типу або передаватися як аргумент методу цього типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f2</span><span class="p">(</span><span class="n">DelegateType</span> <span class="n">d</span><span class="p">,</span> <span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">d</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>       <span class="c1">// Виклик делегата</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f2</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>  <span class="c1">// Передача метода як як аргумента делегата в інший метод</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код виконує метод <code>f2</code>, передаючи посилання на метод <code>f1</code> і число <code>5</code>. Потім <code>f2</code> виконає метод <code>f1</code>, передавши йому число.</p></div>
<div class="paragraph"><p>Делегати також можуть створюватися локально. Метод-член також може бути призначений делегату, наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">delegate</span> <span class="kt">void</span> <span class="n">DelegateType</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
        <span class="n">DelegateType</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">foo</span><span class="p">.</span><span class="n">f1</span><span class="p">;</span>
        <span class="n">d1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="____4">Анонімні методи/замикання</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анонімний метод, також відомий як лямбда-вираз, літеральна функція або замикання, може бути визначений у Vala за допомогою оператора <code>=&gt;</code>. Список параметрів знаходиться з лівої сторони оператора, тіло методу - з правого боку.</p></div>
<div class="paragraph"><p>Анонімний метод, що стоїть сам по собі, як вище, не має особливого сенсу. Він корисний лише в тому випадку, якщо ви призначите його безпосередньо змінній типу делегата або передаєте його як аргумент-метод іншому методу.</p></div>
<div class="paragraph"><p>Зауважте, що ні параметри, ні тип повернення не вказані явно. Натомість типи виводяться з сигнатури делегата, з яким він використовується.</p></div>
<div class="paragraph"><p>Призначення анонімного методу делегатній змінній:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">void</span> <span class="n">PrintIntFunc</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">PrintIntFunc</span> <span class="n">p1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="p">};</span>
    <span class="n">p1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Фігурні дужки необов’язкові, якщо тіло містить лише одне твердження:</span>
    <span class="n">PrintIntFunc</span> <span class="n">p2</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="n">p2</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Передача анонімного методу до іншого методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">int</span> <span class="n">Comparator</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">my_sorting_algorithm</span><span class="p">(</span><span class="kt">int</span><span class="p">[]</span> <span class="n">data</span><span class="p">,</span> <span class="n">Comparator</span> <span class="n">compare</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... &#39;compare&#39; називається десь тут ...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span><span class="p">[]</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">5</span> <span class="p">};</span>
    <span class="c1">// Анонімний метод передається як другий аргумент:</span>
    <span class="n">my_sorting_algorithm</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анонімні методи - це справжні замикання. Це означає, що ви можете отримати доступ до локальних змінних зовнішнього методу в межах лямбда-виразу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">delegate</span> <span class="kt">int</span> <span class="n">IntOperation</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>

<span class="n">IntOperation</span> <span class="n">curried_add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>  <span class="c1">// &#39;a&#39; - зовнішня змінна</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;2 + 4 = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">curried_add</span><span class="p">(</span><span class="mi">2</span><span class="p">)(</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі <code>curried_add</code> (див. Карування) повертає новостворений метод, який зберігає значення <code>a</code>. Цей повернутий метод викликається безпосередньо після цього, з аргументом <code>4</code>, що призводить до суми двох чисел.</p></div>
</div>
<div class="sect3">
<h4 id="___9">Простори імен</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">namespace</span> <span class="nn">NameSpaceName</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все, що знаходиться між дужками в цьому операторі, знаходиться в просторі імен <code>NameSpaceName</code> і на нього має бути посилання. Будь-який код за межами цього простору імен повинен або використовувати кваліфіковані імена для чогось, що знаходиться в межах простору імен, або бути у файлі з відповідною декларацією, щоб імпортувати цю область імен:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">using</span> <span class="nn">NameSpaceName</span><span class="p">;</span>
<span class="c1">// ...</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, якщо імпорт простору імен Gtk імпортується за допомогою <code>using Gtk;</code> ви можете просто написати <code>Window</code> замість <code>Gtk.Window</code>. Повна кваліфікована назва потрібна буде лише у випадку неоднозначності, наприклад, між <code>GLib.Object</code> та <code>Gtk.Object</code>.</p></div>
<div class="paragraph"><p>Простір імен <code>GLib</code> імпортується за замовчуванням. Уявіть невидимий рядок <code>using GLib;</code> на початку кожного файлу Vala.</p></div>
<div class="paragraph"><p>Все, що ви не помістите в окремий простір імен, потрапить у анонімний глобальний простір імен. Якщо вам доведеться явно посилатися на глобальний простір імен через неоднозначність, ви можете зробити це за допомогою префікса <code>global::</code>.</p></div>
<div class="paragraph"><p>Простори імен можна вкладати або шляхом введення однієї декларації всередину іншої, або наданням імені форми <code>NameSpace1.NameSpace2</code>.</p></div>
<div class="paragraph"><p>Кілька інших типів визначень можуть декларувати себе всередині простору імен, дотримуючись тієї ж форми іменування, наприклад. клас <code>NameSpace1.Test {...}</code>. Зауважте, що після цього кінцевим простором імен визначення буде вкладена декларація, плюс простори імен, оголошені у визначенні.</p></div>
</div>
<div class="sect3">
<h4 id="__10">Структури</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">StructName</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає тип структури, тобто тип складного значення. Структура Vala може мати методи обмеженим чином, а також може мати приватні члени, тобто потрібебн явний модифікатор доступу <code>public</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Color</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">red</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">green</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">blue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як можна ініціалізувати структуру:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// без виводу типу</span>
<span class="n">Color</span> <span class="n">c1</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span>  <span class="c1">// або Color c1 = {};</span>
<span class="n">Color</span> <span class="n">c2</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">Color</span> <span class="n">c3</span> <span class="o">=</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">green</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">};</span>

<span class="c1">// з виводом типу</span>
<span class="kd">var</span> <span class="n">c4</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span>
<span class="kd">var</span> <span class="n">c5</span> <span class="o">=</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">red</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">green</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span>
    <span class="n">blue</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Структури виділяються в стеку/вбудовано і копіюються при присвоєнні.</p></div>
<div class="paragraph"><p>Щоб визначити масив структур, перегляньте FAQ.</p></div>
</div>
<div class="sect3">
<h4 id="__11">Класи</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">ClassName</span> <span class="o">:</span> <span class="n">SuperClassName</span><span class="p">,</span> <span class="n">InterfaceName</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає клас, тобто тип посилання. На відміну від структур, екземпляри класів виділяються в купі. Існує набагато більше синтаксису, пов’язаного з класами, про що більш докладно йдеться у розділі про об’єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect3">
<h4 id="__12">Інтерфейси</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">InterfaceName</span> <span class="o">:</span> <span class="n">SuperInterfaceName</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>визначає інтерфейс, тобто тип, примірник якого не створюється. Для того, щоб створити екземпляр інтерфейсу, ви повинні спочатку реалізувати його абстрактні методи в не-абстрактному класі. Інтерфейси Vala є більш потужними, ніж інтерфейси Java або C#. Насправді їх можна використовувати як міксини. Деталі інтерфейсів описані в розділі про об'єктно-орієнтоване програмування.</p></div>
</div>
<div class="sect3">
<h4 id="___10">Атрибути коду</h4>
<div class="paragraph"><p>Атрибути коду вказують деталі компілятора Vala про те, як повинен працювати код на цільовій платформі. Їх синтаксис є <code>[AttributeName]</code> або <code>[AttributeName (param1 = value1, param2 = value2, ...)]</code>.</p></div>
<div class="paragraph"><p>Вони в основному використовуються для прив’язки у файлах <code>vapi</code>, де <code>[CCode (...)]</code> є найбільш помітним прикладом. Інший приклад - атрибут <code>[DBus (...)]</code> для експорту віддалених інтерфейсів через D-Bus.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____2">Об'єктно-орієнтоване програмування</h2>
<div class="sectionbody">
<div class="paragraph"><p>Хоча Vala не змушує вас працювати з об'єктами, деякі можливості не доступні в будь-який інший спосіб. Таким чином, ви, безсумнівно, захочете програмувати в об'єктно-орієнтованому стилі більшу частину часу. Як і в більшості сучасних мов, для визначення власних типів об'єктів ви пишете визначення класу.</p></div>
<div class="paragraph"><p>Визначення класу вказує, які дані має кожен об'єкт його типу, на які ще типи об'єктів можуть містити посилання та які методи можуть бути виконані на ньому. Визначення може містити назву іншого класу, для якого новий має бути підкласом. Екземпляр класу також є екземпляром усіх суперкласів класу, оскільки він успадковує від них усі їхні методи та дані, хоча він може не мати доступу до всього цього сам по собі. Клас також може реалізовувати будь-яку кількість інтерфейсів, що представляють собою набори визначень методів, які повинні бути реалізовані класом - екземпляр класу також є екземпляром кожного інтерфейсу, реалізованого його класом або суперкласами.</p></div>
<div class="paragraph"><p>Класи у Vala можуть також мати <code>static</code> члени. Цей модифікатор дозволяє визначати або дані, або методи як належні до класу в цілому, а не до конкретного його примірника. До таких членів можна отримати доступ, не маючи примірника класу.</p></div>
<div class="sect2">
<h3 id="__13">Основи</h3>
<div class="paragraph"><p>Простий клас можна визначити так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Поля</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">first_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">second_data</span><span class="p">;</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Конструктор</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="n">TestClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">second_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="o">/</span> <span class="o">*</span> <span class="err">Метод</span> <span class="o">*</span> <span class="o">/</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;private data: %d&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">second_data</span><span class="p">);</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">second_data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код визначає новий тип (який автоматично реєструється в системі типів бібліотеки <code>gobject</code>), який містить три члени. Є два члени даних, цілі числа, визначені вгорі, і один метод під назвою <code>method_1</code>, який повертає ціле число. У декларації класу зазначено, що цей клас є підкласом <code>GLib.Object</code>, а тому його екземпляри є також <code>Object</code>, і містять також усі члени цього типу. Той факт, що цей клас походить від <code>Object</code>, також означає, що є особливості Vala, які можна використовувати для легкого доступу до деяких властивостей об'єкта.</p></div>
<div class="paragraph"><p>Цей клас описується як загальнодоступний (за замовчуванням класи є внутрішніми). Це означає, що на нього можна посилатися безпосередньо з коду за межами цього файлу - якщо ви програміст C glib/gobject, ви визнаєте це еквівалентом визначення класових інтерфейсів у файлі заголовка, який можна включати в інший код.</p></div>
<div class="paragraph"><p>Члени також описуються як <code>public</code> або <code>private</code>. Член <code>first_data</code> є загальнодоступним, тому його можна побачити безпосередньо будь-якому користувачеві класу, і його можна модифікувати, не повідомляючи про це екземпляр. Другий член даних є приватним і на нього може посилатися лише код, що належить до цього класу. Vala підтримує чотири різні модифікатори доступу:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>public</code> Без обмежень доступу
</p>
</li>
<li>
<p>
<code>private</code> Доступ обмежений визначенням класу/структури. Це за замовчуванням, якщо не вказаний модифікатор доступу
</p>
</li>
<li>
<p>
<code>protected</code> Доступ обмежений визначенням класу та будь-яким класом, який успадковується від класу
</p>
</li>
<li>
<p>
<code>internal</code> Доступ обмежений виключно класами, визначеними в одному пакеті
</p>
</li>
</ul></div>
<div class="paragraph"><p>Конструктор ініціалізує нові екземпляри класу. Він має те саме ім'я, що і клас, може приймати нуль або більше аргументів і визначається без типу повернення.</p></div>
<div class="paragraph"><p>Заключна частина цього класу - визначення методу. Цей метод буде називатися <code>method_1</code>, і він повертає ціле число. Оскільки цей метод не є статичним, він може бути виконаний лише на екземплярі цього класу, а тому може отримати доступ до членів цього екземпляра. Це можна зробити за допомогою посилання <code>this</code>, яке завжди вказує на екземпляр, на якому викликається метод. Якщо немає двозначності, цей ідентифікатор за бажанням можна опустити.</p></div>
<div class="paragraph"><p>Ви можете використовувати цей новий клас наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">TestClass</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TestClass</span><span class="p">();</span>
<span class="n">t</span><span class="p">.</span><span class="n">first_data</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">t</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__14">Конструювання</h3>
<div class="paragraph"><p>Vala підтримує дві дещо різні схеми конструкторів: схему конструювання в стилі Java/C#, на якій ми зупинимося на даний момент, та схему конструювання в стилі GObject, яка буде описана в розділі в кінці розділу.</p></div>
<div class="paragraph"><p>Vala не підтримує перевантаження конструктора з тих же причин, з яких немає перевантаження методів, а це означає, що в класі може не бути декількох конструкторів з однаковою назвою. Однак це не проблема, оскільки Vala підтримує іменовані конструктори. Якщо ви хочете запропонувати кілька конструкторів, ви можете дати їм додаткові назви:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Button</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">.</span><span class="n">with_label</span><span class="p">(</span><span class="kt">string</span> <span class="n">label</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Button</span><span class="p">.</span><span class="n">from_stock</span><span class="p">(</span><span class="kt">string</span> <span class="n">stock_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Створення примірника аналогічне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="n">Button</span><span class="p">();</span>
<span class="k">new</span> <span class="n">Button</span><span class="p">.</span><span class="n">with_label</span><span class="p">(</span><span class="s">&quot;Click me&quot;</span><span class="p">);</span>
<span class="k">new</span> <span class="n">Button</span><span class="p">.</span><span class="n">from_stock</span><span class="p">(</span><span class="n">Gtk</span><span class="p">.</span><span class="n">STOCK_OK</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете зціпити конструктори за допомогою <code>this()</code> або <code>this.name_extension()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">x</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="n">y</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Point</span><span class="p">.</span><span class="n">polar</span><span class="p">(</span><span class="kt">double</span> <span class="n">radius</span><span class="p">,</span> <span class="kt">double</span> <span class="n">angle</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">.</span><span class="n">rectangular</span><span class="p">(</span><span class="mf">5.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
    <span class="kd">var</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Point</span><span class="p">.</span><span class="n">polar</span><span class="p">(</span><span class="mf">5.7</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__15">Знищення</h3>
<div class="paragraph"><p>Хоча Vala управляє пам'яттю для вас, можливо, вам доведеться додати свій власний деструктор, якщо ви вирішите зробити ручне управління пам’яттю за допомогою покажчиків (докладніше про це пізніше) або якщо вам доведеться вивільнити інші ресурси. Синтаксис такий самий, як у C# або C++:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Demo</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="o">~</span><span class="n">Demo</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;in destructor&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки управління пам'яттю Vala базується на підрахунку посилань замість відстеження збору сміття, деструктори детерміновані і можуть використовуватися для реалізації схеми RAII для управління ресурсами (закриття потоків, підключень до бази даних, &#8230;).</p></div>
</div>
<div class="sect2">
<h3 id="__16">Сигнали</h3>
<div class="paragraph"><p>Сигнали - це система, що надається класом <code>Object</code> в GLib, і стає легко доступною в Vala для всіх нащадків <code>Object</code>. Сигнали можна пояснити програмістам на C# як події, або програмістам Java як альтернативний спосіб реалізації слухачів подій. Коротше кажучи, сигнал є просто способом виконання довільної кількості зовнішньо однакових методів (тобто тих, що мають однакову сигнатуру) приблизно в один і той же час. Насправді методи виконання є внутрішніми для <code>gobject</code>, і не важливі для програм Vala.</p></div>
<div class="paragraph"><p>Сигнал визначається як член класу і виглядає аналогічно методу без тіла. Потім обробники сигналів можуть бути додані до сигналу за допомогою методу <code>connect()</code>. Для того, щоб зразу перейти до справи, наступний приклад також вводить лямбда-вирази, дуже корисний спосіб написання коду обробки сигналу у Vala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">signal</span> <span class="kt">void</span> <span class="n">sig_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Test</span> <span class="n">t1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test</span><span class="p">();</span>

        <span class="n">t1</span><span class="p">.</span><span class="n">sig_1</span><span class="p">.</span><span class="n">connect</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
        <span class="p">});</span>

        <span class="n">t1</span><span class="p">.</span><span class="n">sig_1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код вводить новий клас під назвою <code>Test</code>, використовуючи знайомий синтаксис. Першим членом цього класу є сигнал, який називається <code>sig_1</code> і визначається як передача цілого числа. В методі <code>main</code> цієї програми ми спочатку створюємо екземпляр - це вимога, оскільки сигнали завжди належать до примірників класів. Далі ми призначаємо оброблювач сигналу нашого примірника <code>sig_1</code>, який ми визначаємо у вбудованому вигляді як лямбда-вираз. Визначення зазначає, що метод отримає два аргументи, які ми називаємо <code>"t"</code> і <code>"a"</code>, але не надаємо для них типи. Ми можемо бути такі стислі, оскільки Vala вже знає визначення сигналу і тому може зрозуміти, які типи потрібні.</p></div>
<div class="paragraph"><p>Причина, що для обробника є два параметри, полягає в тому, що щоразу, коли випромінюється сигнал, об'єкт, на який він випромінюється, передається як перший аргумент обробнику. Другий аргумент - той, що надає сигнал.</p></div>
<div class="paragraph"><p>Нарешті ми нетерплячі і вирішуємо випромінити сигнал. Ми робимо це, називаючи сигнал так, ніби це метод нашого класу, і дозволяємо <code>gobject</code> піклуватися про пересилання повідомлення всім доданим обробникам. Розуміння механізму, який використовується для цього, не потрібне щоб використовувати сигнали Vala.</p></div>
<div class="paragraph"><p>NB: Наразі модифікатор доступу <code>public</code> є єдиним можливим варіантом - всі сигнали можуть бути як підключені, так і випромінювані будь-яким фрагментом коду.</p></div>
<div class="paragraph"><p>Примітка. Починаючи з квітня 2010 р. cигнали можна анотувати будь-якою комбінацією прапорів:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>[Signal (action=true, detailed=true, run=true, no_recurse=true, no_hooks=true)]
public signal void sig_1 ();</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="__17">Властивості</h3>
<div class="paragraph"><p>Це гарна об'єктно-орієнтована практика програмування, щоб приховувати деталі реалізації від користувачів ваших класів (принцип приховування інформації), щоб потім можна було змінити внутрішні деталі, не порушуючи загальнодоступний API. Однією з практик є створення полів приватними та надання методів доступу для отримання та встановлення їх значень (геттери та сетери).</p></div>
<div class="paragraph"><p>Якщо ви програміст Java, ви, напевно, придумаєте щось подібне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">get_age</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">set_age</span><span class="p">(</span><span class="kt">int</span> <span class="n">age</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">age</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це працює, але Vala може зробити краще. Проблема полягає в тому, що ці методи громіздкі. Припустимо, що ви хочете збільшити вік людини на один рік:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
<span class="n">alice</span><span class="p">.</span><span class="n">set_age</span><span class="p">(</span><span class="n">alice</span><span class="p">.</span><span class="n">get_age</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут вступають властивості:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">_age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>  <span class="c1">// префікс з підкреслення, щоб уникнути конфлікту з властивістю</span>

    <span class="cm">/* Властивість */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_age</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">_age</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей синтаксис повинен бути знайомий програмістам C#. Властивість має блоки <code>get</code> та <code>set</code> для отримання та встановлення. <code>value</code> - це ключове слово, яке представляє нове значення, яке слід призначити властивості.</p></div>
<div class="paragraph"><p>Тепер ви можете отримати доступ до властивості так, ніби це публічне поле. Але за лаштунками виконується код у блоках <code>get</code> і <code>set</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">alice</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">();</span>
<span class="n">alice</span><span class="p">.</span><span class="n">age</span> <span class="o">=</span> <span class="n">alice</span><span class="p">.</span><span class="n">age</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// або навіть коротше:</span>
<span class="n">alice</span><span class="p">.</span><span class="n">age</span><span class="o">++</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви виконуєте лише стандартну реалізацію, як показано вище, ви можете записати властивість ще коротше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="cm">/* Property with standard getter and setter and default value */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За допомогою властивостей ви можете змінювати внутрішню роботу класів без зміни загальнодоступного API. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">static</span> <span class="kt">int</span> <span class="n">current_year</span> <span class="o">=</span> <span class="mi">2525</span><span class="p">;</span>

<span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">year_of_birth</span> <span class="o">=</span> <span class="mi">2493</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current_year</span> <span class="o">-</span> <span class="n">year_of_birth</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">set</span> <span class="p">{</span> <span class="n">year_of_birth</span> <span class="o">=</span> <span class="n">current_year</span> <span class="o">-</span> <span class="n">value</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього разу вік обчислюється на льоту від року народження. Зауважте, що ви можете зробити більше, ніж просто простий змінний доступ або призначення в блоках <code>get</code> і <code>set</code>. Ви можете зробити доступ до бази даних, ведення журналів, оновлення кешу тощо.</p></div>
<div class="paragraph"><p>Якщо ви хочете зробити властивість лише для читання для користувачів класу, ви повинні зробити сетер приватним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">private</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ж ви можете залишити встановлений блок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">_age</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_age</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Властивості можуть мати не лише ім'я, але й короткий опис (називається нік) та довгий опис (називається пояснення). Ви можете помітити їх спеціальним атрибутом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Description</span><span class="p">(</span><span class="n">nick</span> <span class="o">=</span> <span class="s">&quot;age in years&quot;</span><span class="p">,</span> <span class="n">blurb</span> <span class="o">=</span> <span class="s">&quot;This is the person&#39;s age in years&quot;</span><span class="p">)]</span>
<span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="mi">32</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Властивості та їх додаткові описи можна запитувати під час виконання. Деякі програми, такі як графічний дизайнер інтерфейсу Glade, використовують цю інформацію. Таким чином Glade може представити зрозумілі людині описи властивостей GTK + віджетів.</p></div>
<div class="paragraph"><p>Кожен екземпляр класу, похідного від <code>GLib.Object</code>, має сигнал, який називається <code>notify</code>. Цей сигнал випромінюється щоразу, коли властивість його об'єкта змінюється. Таким чином, ви можете підключитися до цього сигналу, якщо вас взагалі цікавлять сповіщення змін:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">obj</span><span class="p">.</span><span class="n">notify</span><span class="p">.</span><span class="n">connect</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Property &#39;%s&#39; has changed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p><code>s</code> - джерело сигналу (<code>obj</code> у цьому прикладі), <code>p</code> - інформація про властивості типу <code>ParamSpec</code> для зміненої властивості. Якщо вас цікавлять лише сповіщення про зміну одної властивості, ви можете використовувати цей синтаксис:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">alice</span><span class="p">.</span><span class="n">notify</span><span class="p">[</span><span class="s">&quot;age&quot;</span><span class="p">].</span><span class="n">connect</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;age has changed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що в цьому випадку ви повинні використовувати рядкове представлення імені властивості, де підкреслення замінюється тире: <code>my_property_name</code> стає <code>"my-property-name"</code> у цьому поданні, що є домовленістю іменування властивостей в <code>GObject</code>.</p></div>
<div class="paragraph"><p>Повідомлення про зміну можна відключити тегом атрибута <code>CCode</code> безпосередньо перед оголошенням властивості:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyObject</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="p">[</span><span class="nd">CCode</span><span class="p">(</span><span class="n">notify</span> <span class="o">=</span> <span class="nb">false</span><span class="p">)]</span>
<span class="c1">// сигнал сповіщення НЕ випромінюється при зміні властивості</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">without_notification</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// сигнал зміни випромінюється при зміні властивості</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">with_notification</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Існує ще один тип властивостей, які називаються властивостями конструкції, які описані далі в розділі про побудову в стилі <code>gobject</code>.</p></div>
<div class="paragraph"><p>Примітка: якщо ваш ресурс має тип <code>struct</code>, щоб отримати значення властивості за допомогою <code>Object.get()</code>, ви повинні оголосити свою змінну як приклад нижче</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">struct</span> <span class="nc">Color</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kt">uint32</span> <span class="n">argb</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">Color</span><span class="p">()</span> <span class="p">{</span> <span class="n">argb</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Shape</span><span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="n">Color</span> <span class="n">c</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="k">default</span> <span class="o">=</span> <span class="n">Color</span><span class="p">();</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Color</span><span class="o">?</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">null</span><span class="p">;</span>
    <span class="n">Shape</span> <span class="n">s</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Shape</span><span class="p">();</span>
    <span class="n">s</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="k">out</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Таким чином, <code>c</code> - це посилання замість екземпляра <code>Color</code> у стеку. Що ви передали до <code>s.get()</code> - це <code>"Color **"</code> замість <code>"Color *"</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__18">Наслідування</h3>
<div class="paragraph"><p>У Vala клас може походити з одного або нуля інших класів. На практиці це, ймовірно, завжди є одним, хоча неявного спадкування немає, як у мовах, таких як Java.</p></div>
<div class="paragraph"><p>Визначаючи клас, який успадковує від іншого, ви створюєте взаємозв'язок між класами, де екземпляри підкласу також є екземплярами надкласу. Це означає, що операції над екземплярами надкласу також застосовні на екземплярах підкласу. Таким чином, там, де потрібен екземпляр надкласу, може бути підставлений екземпляр підкласу.</p></div>
<div class="paragraph"><p>Під час написання визначення класу можна здійснювати точний контроль над тим, хто може отримати доступ до того, які методи та дані в об’єкті. Наступний приклад демонструє цілий ряд таких варіантів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">public</span> <span class="n">SuperClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">protected</span> <span class="kt">void</span> <span class="n">protected_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">public_static_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="n">SubClass</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">base</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>data</code> є членом даних екземпляра <code>SuperClass</code>. Воно буде членом цього типу в кожному екземплярі <code>SuperClass</code>, і він оголошений <code>private</code>, тому він буде доступний лише за допомогою коду, що є частиною <code>SuperClass</code>.</p></div>
<div class="paragraph"><p><code>protected_method</code> - це метод екземпляра <code>SuperClass</code>. Ви зможете виконати цей метод лише екземпляром <code>SuperClass</code> або одного з його підкласів, і лише з коду, що належить <code>SuperClass</code> або одного з його підкласів - це останнє правило є результатом модифікатора <code>protected</code>.</p></div>
<div class="paragraph"><p><code>public_static_method</code> має два модифікатори. Модифікатор <code>static</code> означає, що цей метод може бути викликаний без володіння екземпляром <code>SuperClass</code> або одного з його підкласів. Як результат, цей метод не матиме доступу до посилання <code>this</code> при його виконанні. Модифікатор <code>public</code> означає, що цей метод можна викликати з будь-якого коду, незалежно від його зв’язку із <code>SuperClass</code> або його підкласами.</p></div>
<div class="paragraph"><p>З огляду на ці визначення, екземпляр <code>SubClass</code> буде містити всіх трьох членів <code>SuperClass</code>, але матиме змогу отримати доступ лише до не-приватних членів. Зовнішній код зможе отримати доступ лише до публічного методу.</p></div>
<div class="paragraph"><p>За допомогою <code>base</code> конструктор підкласу може звертатись до конструктора базового класу.</p></div>
</div>
<div class="sect2">
<h3 id="___11">Абстрактні класи</h3>
<div class="paragraph"><p>Існує ще один модифікатор методів, який називається <code>abstract</code>. Цей модифікатор дозволяє описати метод, який фактично не реалізований у класі. Натомість він повинен бути реалізований підкласами, перш ніж його можна буде викликати. Це дозволяє визначити операції, які можуть бути викликані у всіх екземплярах типу, забезпечуючи при цьому, щоб всі більш конкретні типи надавати власну версію функціоналу.</p></div>
<div class="paragraph"><p>Клас, що містить абстрактні методи, також повинен бути оголошений абстрактним. Результатом цього є запобігання будь-якої інстанцінацї (створення примірнику) типу.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">eat</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*chomp chomp*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Tiger</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*roar*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Duck</span> <span class="o">:</span> <span class="n">Animal</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">say_hello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;*quack*</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація абстрактного методу повинна бути позначена <code>override</code>. Властивості також можуть бути абстрактними.</p></div>
<div class="sect3">
<h4 id="___12">Віртуальні методи</h4>
<div class="paragraph"><p>Віртуальний метод дозволяє визначити реалізацію за замовчуванням на абстрактні класи та дозволяє похідним класам перекрити свою поведінку. Це відрізняється від приховування методів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Caller</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">);</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">reset</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;No Name&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ContactCV</span> <span class="o">:</span> <span class="n">Caller</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">)</span>
   <span class="p">{</span>
     <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ContactCV - &quot;</span> <span class="o">+</span> <span class="n">new_name</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">reset</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;ContactCV-Name&quot;</span><span class="p">;</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;CotactCV.reset () implementation!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Contact</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">update</span> <span class="p">(</span><span class="kt">string</span> <span class="n">new_name</span><span class="p">)</span>
   <span class="p">{</span>
     <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;Contact - &quot;</span> <span class="o">+</span> <span class="n">new_name</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Contact</span> <span class="p">();</span>
      <span class="n">c</span><span class="p">.</span><span class="n">update</span> <span class="p">(</span><span class="s">&quot;John Strauss&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Name: $(c.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">c</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Reset Name: $(c.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

      <span class="kd">var</span> <span class="n">cv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ContactCV</span> <span class="p">();</span>
      <span class="n">cv</span><span class="p">.</span><span class="n">update</span> <span class="p">(</span><span class="s">&quot;Xochitl Calva&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Name: $(cv.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">cv</span><span class="p">.</span><span class="n">reset</span> <span class="p">();</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;Reset Name: $(cv.name)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите у наведеному вище прикладі, <code>Caller</code> - це абстрактний клас, що визначає як абстрактну властивість, так і метод, але додає віртуальний метод, який може бути замінений похідними класами. Клас <code>Contact</code> реалізує абстрактні методи та властивості <code>Caller</code>, використовуючи при цьому реалізацію за замовчуванням для <code>reset()</code>, уникаючи визначення нового. <code>ContactCV</code> клас реалізує всі абстрактні визначення на <code>Caller</code>, але переосмислює <code>reset()</code>, щоб визначити власну реалізацію.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__19">Інтерфейси</h3>
<div class="paragraph"><p>Клас у Vala може реалізувати будь-яку кількість інтерфейсів. Кожен інтерфейс - це тип, подібний до класу, але такий, примірник якого неможливо створити. "Реалізуючи" один або кілька інтерфейсів, клас може оголосити, що його екземпляри є також екземплярами інтерфейсу, і тому він може використовуватися в будь-якій ситуації, коли очікується екземпляр цього інтерфейсу.</p></div>
<div class="paragraph"><p>Процедура реалізації інтерфейсу така ж, як і для успадкування класів з абстрактними методами - якщо клас повинен бути корисним, він повинен передбачати реалізацію для всіх описаних, але ще не реалізованих, методів.</p></div>
<div class="paragraph"><p>Просте визначення інтерфейсу виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITest</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="n">data_1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей код описує інтерфейс <code>ITest</code>, який вимагає <code>GLib.Object</code> як батьківського класу реалізатора і містить два члени. <code>data_1</code> - властивість, як описано вище, за винятком того, що вона оголошена абстрактною. Таким чином, Vala не буде реалізовувати цю властивість, а натомість вимагатиме, щоб класи, що реалізують цей інтерфейс, мали властивість під назвою <code>data_1</code>, яка має обоє аксесори, <code>set</code> та <code>get</code> - потрібно, щоб це було абстрактним, оскільки інтерфейс не може мати членів даних. Другий член <code>method_1</code> - це метод. Тут декларовано, що цей метод повинен бути реалізований класами, які реалізують цей інтерфейс.</p></div>
<div class="paragraph"><p>Найпростіша можлива повна реалізація цього інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test1</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">ITest</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">data_1</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>І може використовуватися наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">t</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Test1</span><span class="p">();</span>
<span class="n">t</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>

<span class="n">ITest</span> <span class="n">i</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="n">i</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
<div class="sect3">
<h4 id="___13">Визначення передумов</h4>
<div class="paragraph"><p>Інтерфейси у Vala не можуть успадковувати інші інтерфейси, але вони можуть оголосити інші інтерфейси необхідними умовами, що працює приблизно так само. Наприклад, може бути бажаним сказати, що будь-який клас, який реалізує інтерфейс <code>List</code>, повинен також реалізовувати інтерфейси <code>Collection</code> і <code>Traverable</code>. Синтаксис для цього точно такий же, як для опису реалізації інтерфейсу в класах:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">List</span> <span class="o">:</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Traversable</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначення <code>List</code> не може бути реалізовано в класі без того, щоб <code>Collection</code> також була реалізована, і тому Vala застосовує наступний стиль декларування для класу, який бажає реалізувати <code>List</code>, де повинні бути описані всі реалізовані інтерфейси:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ListClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">List</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерфейси Vala також можуть мати клас як необхідну умову. Якщо ім'я класу вказано у списку передумов, інтерфейс може бути реалізований лише у класах, що походять від цього попереднього класу. Це часто використовується для того, щоб екземпляр інтерфейсу також був підкласом <code>GLib.Object</code>, і тому інтерфейс можна використовувати, наприклад, як тип властивості.</p></div>
<div class="paragraph"><p>Те, що інтерфейси не можуть успадковувати інші інтерфейси, є здебільшого лише технічною відмінністю - на практиці система Vala працює так само, як і інші мови в цій області, але з додатковою особливістю обов'язкових класів.</p></div>
</div>
<div class="sect3">
<h4 id="______">Визначення реалізації за замовчуванням у методах</h4>
<div class="paragraph"><p>Існує ще одна важлива відмінність між інтерфейсами Vala та інтерфейсами Java/C#: інтерфейси Vala можуть мати не-абстрактні методи.</p></div>
<div class="paragraph"><p>Vala фактично дозволяє реалізацію методів в інтерфейсах, і тоді метод із реалізацією за замовчуванням повинен бути оголошений як віртуальний. У зв'язку з цим інтерфейси Vala можуть виступати в ролі міксинів. Це обмежена форма множинного успадкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Інтерфейс <code>Callable</code> визначає абстрактне властивість, що називається <code>answering</code>, де будь-який клас, що реалізує цей інтерфейс, може відстежувати стан виклику, деталі щодо відповіді на виклик є деталями реалізатора, але <code>hang</code> визначає реалізацію за замовчуванням, щоб встановити відповідь на помилку під час покладеної слухавки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Phone</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
    <span class="cm">/* реалізація коду відповіді */</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Phone</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Під час компіляції та запуску ви виявите, що клас <code>Phone</code> насправді не реалізує метод <code>Callable.hang()</code>, але він може його використовувати, тоді результат - повідомлення <code>"Hang done"</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TechPhone</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
     <span class="cm">/* реалізація коду відповіді */</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;TechPhone.hang () implementation!&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку <code>TechPhone</code> - це ще одна реалізація для <code>Callable</code>, тоді при виклику методу <code>hang()</code> на екземплярі <code>TechPhone</code> він завжди поверне помилкове значення та надрукує повідомлення <code>"TechPhone.hang () implementation!"</code></p></div>
</div>
<div class="sect3">
<h4 id="__20">Властивості</h4>
<div class="paragraph"><p>Інтерфейс може визначати властивості, які необхідно реалізувати для класів. Клас реалізатора повинен визначати властивість з однаковим дозволом сигнатури та доступу для <code>get</code> та <code>set</code>.</p></div>
<div class="paragraph"><p>Як і для будь-якої властивості <code>GObject</code>, ви можете визначити тіло <code>set</code> і <code>get</code> в класі реалізатора. Якщо не використовується тіло, <code>set</code> і <code>get</code> отримують значення за замовчуванням. Якщо вказано, ви повинні визначити приватне поле для зберігання значень властивостей, які будуть використовуватися зовні або всередині класу.</p></div>
<div class="paragraph"><p>Визначення інтерфейсу <code>Callable</code> визначає властивість <code>answering</code>. У цьому випадку цей інтерфейс визначає <code>answering</code> із захищеним <code>set</code>, що дозволяє створити властивості лише для читання для будь-якого об'єкта, використовуючи екземпляр <code>Callable</code>, але дозволяє розробникам класів записувати на нього значення, як це робить клас <code>TechPhone</code>, коли реалізує метод <code>hang()</code>.</p></div>
</div>
<div class="sect3">
<h4 id="_____3">Міксин та множинне спадкування</h4>
<div class="paragraph"><p>Як описано вище, Vala, хоча і базується на C і <code>GObject</code>, може забезпечити обмежений механізм множинного успадкування шляхом додавання віртуальних методів до інтерфейсів. Можна додати деякі способи визначення реалізацій методів за замовчуванням у класі реалізатора інтерфейсу, та дозволити похідним класам переосмислити ці методи.</p></div>
<div class="paragraph"><p>Якщо ви визначите віртуальний метод в інтерфейсі і реалізуєте його в класі, ви не можете перекрити метод інтерфейсу, не залишаючи похідні класи не в змозі отримати доступ до методу інтерфейсу за замовчуванням. Розглянемо наступний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Callable</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">();</span>
   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">bool</span> <span class="n">default_hang</span> <span class="p">(</span><span class="n">Callable</span> <span class="n">call</span><span class="p">)</span>
   <span class="p">{</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Callable.hang()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">call</span><span class="p">.</span><span class="n">answering</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Caller</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span><span class="p">,</span> <span class="n">Callable</span>
<span class="p">{</span>
   <span class="kd">public</span> <span class="kt">bool</span> <span class="n">answering</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">protected</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
   <span class="kd">public</span> <span class="kt">void</span> <span class="n">answer</span> <span class="p">()</span>
   <span class="p">{</span>
     <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Caller.answer()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
     <span class="n">answering</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
     <span class="n">hang</span> <span class="p">();</span>
   <span class="p">}</span>
   <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Callable</span><span class="p">.</span><span class="n">default_hang</span> <span class="p">(</span><span class="k">this</span><span class="p">);</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">TechPhone</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
        <span class="kd">public</span> <span class="kt">string</span> <span class="n">number</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Phone</span> <span class="o">:</span> <span class="n">Caller</span> <span class="p">{</span>
   <span class="kd">public</span> <span class="kd">override</span> <span class="kt">bool</span> <span class="n">hang</span> <span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;At Phone.hang()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">main</span> <span class="p">()</span>
   <span class="p">{</span>
      <span class="kd">var</span> <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Callable</span><span class="p">)</span> <span class="k">new</span> <span class="n">Phone</span> <span class="p">();</span>
      <span class="n">f</span><span class="p">.</span><span class="n">answer</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

      <span class="kd">var</span> <span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="n">Callable</span><span class="p">)</span> <span class="k">new</span> <span class="n">TechPhone</span> <span class="p">();</span>
      <span class="n">t</span><span class="p">.</span><span class="n">answer</span> <span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="n">hang</span> <span class="p">())</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Tech Hand done.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="k">else</span>
         <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Tech Hand Error!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
      <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;END</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому випадку ми визначили інтерфейс <code>Callable</code> з реалізацією за замовчуванням для <code>abstract bool hang()</code> під назвою <code>default_hang</code>, це може бути статичний або віртуальний метод. Тоді <code>Caller</code> є базовим класом, що реалізує <code>Callable</code> для класів <code>TechPhone</code> і <code>Phone</code>, при чому метод <code>Caller.hang()</code> просто викликає реалізацію <code>Callable</code> за замовчуванням. <code>TechPhone</code> нічого не робить і просто приймає <code>Caller</code> як базовий клас, використовуючи реалізацію методу за замовчуванням; але <code>Phone</code> переосмислює <code>Caller.hang()</code>, і це змушує використовувати його власну реалізацію, що дозволяє завжди викликати її, навіть якщо об'єкт приведений до <code>Callable</code>.</p></div>
</div>
<div class="sect3">
<h4 id="____5">Явна реалізація методу</h4>
<div class="paragraph"><p>Явна реалізація методу інтерфейсу дозволяє реалізувати два інтерфейси, які мають методи (а не властивості) з однаковим іменем. Приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">interface</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">int</span> <span class="n">m</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">interface</span> <span class="nc">Bar</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kd">abstract</span> <span class="kt">string</span> <span class="n">m</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Cls</span><span class="o">:</span> <span class="n">Foo</span><span class="p">,</span> <span class="n">Bar</span> <span class="p">{</span>
 <span class="kd">public</span> <span class="kt">int</span> <span class="n">Foo</span><span class="p">.</span><span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
 <span class="p">}</span>

 <span class="kd">public</span> <span class="kt">string</span> <span class="n">Bar</span><span class="p">.</span><span class="n">m</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="s">&quot;bar&quot;</span><span class="p">;</span>
 <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
 <span class="kd">var</span> <span class="n">cls</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cls</span> <span class="p">();</span>
 <span class="n">message</span> <span class="p">(</span><span class="s">&quot;%d %s&quot;</span><span class="p">,</span> <span class="p">((</span><span class="n">Foo</span><span class="p">)</span> <span class="n">cls</span><span class="p">).</span><span class="n">m</span><span class="p">(),</span> <span class="p">((</span><span class="n">Bar</span><span class="p">)</span> <span class="n">cls</span><span class="p">).</span><span class="n">m</span><span class="p">());</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Видасть <code>10 bar</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__21">Поліморфізм</h4>
<div class="paragraph"><p>Поліморфізм описує спосіб використання одного і того ж об'єкта, як ніби це більше ніж один окремий тип. Деякі з описаних тут прийомів дозволяють припустити, як це можливо у Vala: екземпляр класу може використовуватися як екземпляр надкласу або будь-яких реалізованих інтерфейсів, не знаючи його фактичного типу.</p></div>
<div class="paragraph"><p>Логічне розширення цієї потужності полягає в тому, щоб дозволити підтипу поводитись по-різному зі своїм батьківським типом, хоча це виглядає точно так само. Це поняття не дуже легко пояснити, тому я розпочну з прикладу того, що станеться, якщо ви безпосередньо не націлитеся на цю мету:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SuperClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SubClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Обидва ці класи реалізують метод, який називається <code>method_1</code>, і <code>SubClass</code>, таким чином, містить два методи, звані <code>method_1</code>, оскільки він успадковує один із <code>SuperClass</code>. Кожен із них може бути викликаний, як показує наступний код:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">SubClass</span> <span class="n">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SubClass</span><span class="p">();</span>
<span class="n">o1</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
<span class="n">SuperClass</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">o1</span><span class="p">;</span>
<span class="n">o2</span><span class="p">.</span><span class="n">method_1</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Це фактично призведе до виклику двох різних методів. Другий рядок вважає, що <code>o1</code> є <code>SubClass</code> і визиває версію методу цього класу. Четвертий рядок вважає, що <code>o2</code> є <code>SuperClass</code> і визиває версію методу цього класу.</p></div>
<div class="paragraph"><p>Проблема, яку розкриває цей приклад, полягає в тому, що будь-який код, що містить посилання на <code>SuperClass</code>, буде викликати методи, фактично описані в цьому класі, навіть якщо насправді об'єкті є підкласом. Спосіб зміни такої поведінки - це використання віртуальних методів. Розглянемо наступну переписану версію останнього прикладу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SuperClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">method_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;SubClass.method_1()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли цей код використовується так само, як і раніше, <code>method_1</code> з <code>SubClass</code> буде викликаний двічі. Це тому, що ми сказали системі, що <code>method_1</code> - це віртуальний метод, тобто, якщо його буде замінено на підкласі, ця нова версія завжди буде виконуватися на екземплярах цього підкласу, незалежно від знань викликаючого.</p></div>
<div class="paragraph"><p>Ця відмінність, мабуть, знайома програмістам деяких мов, таких як C++, але насправді це протилежність мовам стилю Java, в яких потрібно вжити заходів, щоб запобігти віртуальності методу.</p></div>
<div class="paragraph"><p>Напевно, зараз ви також побачили, що коли метод оголошується абстрактним, він також повинен бути віртуальним. В іншому випадку неможливо виконати цей метод з урахуванням очевидного екземпляра типу, як він був оголошений. При впровадженні абстрактного методу в підкласі, ви можете вирішити оголосити реалізацію як <code>override</code>, передаючи таким чином віртуальний характер методу, і дозволяючи підтипам робити те саме, якщо вони бажають.</p></div>
<div class="paragraph"><p>Також можливо реалізувати методи інтерфейсу таким чином, щоб підкласи могли змінити реалізацію. Процес у цьому випадку полягає у початковій реалізації, щоб оголосити реалізацію методу віртуальною, і тоді підкласи можуть змінювати її за потребою.</p></div>
<div class="paragraph"><p>Під час написання класу прийнято використовувати функціонал, визначений у класі, від якого ви успадкували. Це складно, коли назва методу використовується у дереві спадкування для вашого класу більше одного разу. Для цього Vala надає ключове слово <code>base</code>. Найпоширеніший випадок, коли ви перекрили віртуальний метод, щоб забезпечити додаткову функціональність, але все ж потрібен метод батьківського класу. Наступний приклад показує цей випадок:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">override</span> <span class="kt">void</span> <span class="n">method_name</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">base</span><span class="p">.</span><span class="n">method_name</span><span class="p">();</span>
    <span class="n">extra_task</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala також дозволяє властивостям бути віртуальними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">SuperClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">virtual</span> <span class="kt">string</span> <span class="n">prop_1</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;SuperClass.prop_1&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">SubClass</span> <span class="o">:</span> <span class="n">SuperClass</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">override</span> <span class="kt">string</span> <span class="n">prop_1</span> <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">&quot;SubClass.prop_1&quot;</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="___14">Приховування методів</h4>
<div class="paragraph"><p>За допомогою модифікатора <code>new</code> ви можете приховати успадкований метод новим методом з тим же ім’ям. Новий метод може мати інший підпис. Приховування методу не слід плутати з перекриттям методу, оскільки приховування методу не проявляє поліморфної поведінки.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">my_method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nc">Bar</span> <span class="o">:</span> <span class="n">Foo</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="k">new</span> <span class="kt">void</span> <span class="n">my_method</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви все ще можете викликати оригінальний метод, перейшовши на базовий клас або інтерфейс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">bar</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Bar</span><span class="p">();</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">my_method</span><span class="p">();</span>
    <span class="p">(</span><span class="n">bar</span> <span class="k">as</span> <span class="n">Foo</span><span class="p">).</span><span class="n">my_method</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
<div class="sect2">
<h3 id="______2">Інформація про тип часу виконання</h3>
<div class="paragraph"><p>Оскільки класи Vala реєструються під час виконання і кожен екземпляр несе інформацію про тип, ви можете динамічно перевіряти тип об'єкта за допомогою оператора <code>is</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="n">b</span> <span class="o">=</span> <span class="n">object</span> <span class="k">is</span> <span class="n">SomeTypeName</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете отримати інформацію про типи об'єктів, використовуючи метод <code>get_type()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Type</span> <span class="n">type</span> <span class="o">=</span> <span class="n">object</span><span class="p">.</span><span class="n">get_type</span><span class="p">();</span>
<span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">type</span><span class="p">.</span><span class="n">name</span><span class="p">());</span>
</pre></div></div></div>
<div class="paragraph"><p>За допомогою оператора <code>typeof()</code> ви можете отримати інформацію про тип безпосередньо. З цієї інформації про тип можна пізніше створити нові примірники за допомогою <code>Object.new()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Type</span> <span class="n">type</span> <span class="o">=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Foo</span><span class="p">);</span>
<span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="n">Foo</span><span class="p">)</span> <span class="n">Object</span><span class="p">.</span><span class="k">new</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Який конструктор буде визиватися? Це блок <code>construct {}</code>, який буде описано в розділі про побудову в стилі <code>gobject</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____6">Динамічне приведення типів</h3>
<div class="paragraph"><p>Для динамічного приведення змінна доповнюється виразом постфікса <code>as DesiredTypeName</code>. Vala включить перевірку типу виконання, щоб переконатися, що цей кастинг є розумним - якщо це нелегальний кастинг, буде повернуто значення <code>null</code>. Однак для цього потрібно, щоб тип джерела, так і цільовий тип, були типами посилання.</p></div>
<div class="paragraph"><p>Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Button</span> <span class="n">b</span> <span class="o">=</span> <span class="n">widget</span> <span class="k">as</span> <span class="n">Button</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо з якихось причин клас екземпляра віджета не є класом <code>Button</code> або одним із його підкласів, або не реалізує інтерфейс <code>Button</code>, <code>b</code> буде <code>null</code>. Цей кастинг еквівалентний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Button</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">widget</span> <span class="k">is</span> <span class="n">Button</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Button</span><span class="p">)</span> <span class="n">widget</span> <span class="o">:</span> <span class="nb">null</span><span class="p">;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__22">Дженеріки</h3>
<div class="paragraph"><p>Vala включає систему дженериків часу виконання, за якою конкретний екземпляр класу може бути обмежений певним типом або набором типів, обраних під час створення. Це обмеження зазвичай використовується для того, щоб вимагати, щоб дані, що зберігаються в об'єкті, мали певний тип, наприклад, для реалізації списку об'єктів певного типу. У цьому випадку Vala має переконатись, що до списку можуть бути додані лише об'єкти запитуваного типу, і що при виборці всі об'єкти будуть приведені до цього типу.</p></div>
<div class="paragraph"><p>У Vala дженерики обробляються під час роботи програми. Коли ви визначаєте клас, який може бути обмежений типом, існує лише один клас, але кожен примірник налаштовується індивідуально. Це відрізняється від C ++, що створює новий клас для кожного необхідного обмеження типу - Vala схожий на систему, що використовується Java. Це має різні наслідки, найголовніше: статичні члени загальні за типом у цілому, незалежно від обмежень, що ставляться до кожного екземпляра; і що для класу і підкласу, дженерік, уточнений підкласом, може бути використаний як загальний, уточнений класом.</p></div>
<div class="paragraph"><p>Наступний код демонструє, як використовувати систему дженеріків для визначення мінімального класу обгортки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="n">G</span><span class="o">&gt;</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="n">G</span> <span class="n">data</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">set_data</span><span class="p">(</span><span class="n">G</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">G</span> <span class="n">get_data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас <code>Wrapper</code> повинен бути обмежений типом, щоб його інстанціювати - у цьому випадку тип буде ідентифікований як <code>G</code>, тому екземпляри цього класу будуть зберігати один об'єкт типу <code>G</code> та мати методи для встановки або отримання цього об’єкта. (Причиною цього конкретного прикладу є надання пояснення, що в даний час ддженерік клас не може використовувати властивості свого типу обмеження, і тому цей клас має прості методи отримання та встановлення.)</p></div>
<div class="paragraph"><p>Для інстанцінації цього класу необхідно вибрати тип, наприклад вбудований тип <code>string</code> (у Vala немає обмежень щодо того, який тип може бути використаний у дженеріку). Щоб створити просто скористайтеся цим класом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">wrapper</span><span class="p">.</span><span class="n">set_data</span><span class="p">(</span><span class="s">&quot;test&quot;</span><span class="p">);</span>
<span class="kd">var</span> <span class="n">data</span> <span class="o">=</span> <span class="n">wrapper</span><span class="p">.</span><span class="n">get_data</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Як бачите, коли дані витягуються з обгортки, вони присвоюються ідентифікатору без явного типу. Це можливо, тому що Vala знає, які об’єкти є у кожному екземплярі обгортки, і тому може зробити цю роботу за вас.</p></div>
<div class="paragraph"><p>Те, що Vala не створює декілька класів із загального визначення, означає, що ви можете кодувати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">TestClass</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">accept_object_wrapper</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">Glib</span><span class="p">.</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="kd">var</span> <span class="n">test_wrapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Wrapper</span><span class="o">&lt;</span><span class="n">TestClass</span><span class="o">&gt;</span><span class="p">();</span>
<span class="n">accept_object_wrapper</span><span class="p">(</span><span class="n">test_wrapper</span><span class="p">);</span>
<span class="p">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки всі екземпляри <code>TestClass</code> є також <code>Objects</code>, метод <code>accept_object_wrapper</code> з радістю прийме об'єкт, який йому передається, і буде розглядати його обгорнутий об'єкт, як екземпляр <code>GLib.Object</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____gobject">Побудова в стилі GObject</h3>
<div class="paragraph"><p>As pointed out before, Vala supports an alternative construction scheme that is slightly different to the one described before, but closer to the way GObject construction works. Which one you prefer depends on whether you come from the GObject side or from the Java or C# side. The gobject-style construction scheme introduces some new syntax elements: construct properties, a special Object(&#8230;) call and a construct block. Let&#8217;s take a look at how this works:
Як було зазначено раніше, Vala підтримує альтернативну схему будівництва, яка дещо відрізняється від описаної раніше, але ближче до того, як працює будівництво <code>GObject</code>. Якій з них ви віддаєте перевагу, залежить від того, чи ви просуваєтесь зі сторони <code>GObject</code>, чи з боку Java чи C#. Схема побудови в стилі <code>gobject</code> вводить деякі нові елементи синтаксису: <em>властивості конструкції</em>, спеціальний виклик <code>Object (...)</code> та блок <code>construct</code>. Давайте розглянемо, як це працює:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="cm">/* Властивості конструкції */</span>
    <span class="kd">public</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">construct</span><span class="p">;</span> <span class="p">}</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">construct</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Person</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Object</span><span class="p">(</span><span class="n">name</span><span class="o">:</span> <span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Person</span><span class="p">.</span><span class="n">with_age</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">years</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Object</span><span class="p">(</span><span class="n">name</span><span class="o">:</span> <span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="o">:</span> <span class="n">years</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">construct</span> <span class="p">{</span>
        <span class="c1">// робити все інше</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Welcome %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>За схемою побудови у стилі <code>gobject</code> кожен метод побудови містить лише виклик <code>Object(...)</code> для встановлення так званих властивостей конструкції. Виклик <code>Object (...)</code> приймає змінну кількість названих аргументів у вигляді <code>властивість: значення</code>. Ці властивості повинні бути оголошені як властивості <code>construct</code> або <code>set</code>. Вони будуть встановлені в задані значення, і після цього будуть викликані всі блоки <code>construct {}</code> в ієрархії від <code>GLib.Object</code> до нашого класу.</p></div>
<div class="paragraph"><p>Гарантовано, що блок <code>construct</code> викликається, коли створюється екземпляр цього класу, навіть якщо він створений як підтип. Він не має ані параметрів, ані зворотного значення. У цьому блоці ви можете викликати інші методи та встановити змінні-члени за потребою.</p></div>
<div class="paragraph"><p>Властивості конструювання визначаються так само, як властивості <code>get</code> і <code>set</code>, і тому вони можуть виконувати довільний код при призначенні. Якщо вам потрібно зробити ініціалізацію на основі однієї властивості конструкції, можна написати властивий <code>construct</code> блок для властивості, який буде виконуватися негайно при призначенні та перед будь-яким іншим кодом побудови.</p></div>
<div class="paragraph"><p>Якщо властивість конструкції оголошується без <code>set</code>, то це так звана властивість лише конструкції, це означає, що вона може бути призначена лише при побудові, але вже не після цього. У наведеному вище  прикладі <code>name</code> є такою властивістю лише часу конструкції.</p></div>
<div class="paragraph"><p>Ось підсумок різних типів властивостей разом із номенклатурою, що як правило, міститься в документації бібліотек на основі <code>gobject</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="kd">public</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>    <span class="c1">// Read</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">{</span> <span class="kd">private</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>    <span class="c1">// Write</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">c</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>            <span class="c1">// Read / Write</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">d</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span> <span class="k">construct</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// Read / Write / Construct</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">e</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">construct</span><span class="p">;</span> <span class="p">}</span>      <span class="c1">// Read / Write-Construct-Only</span>
</pre></div></div></div>
<div class="paragraph"><p>У деяких випадках ви також можете виконати якусь дію - не тоді, коли створюються екземпляри класу, - але коли сам клас створений під час виконання <code>GObject</code>. У термінології <code>GObject</code> ми говоримо про фрагмент коду, який виконується всередині функції <code>class_init</code> для відповідного класу. У Java це відоме як статичні блоки ініціалізатора. У Vala це виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="cm">/* Цей фрагмент коду виконується під час реєстрації</span>
<span class="cm">     * класу в системі типу */</span>
    <span class="kd">static</span> <span class="k">construct</span> <span class="p">{</span>
      <span class="p">...</span>
    <span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___15">Додаткові функції</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_____4">Твердження та контрактне програмування</h3>
<div class="paragraph"><p>З твердженнями, програміст може перевіряти припущення під час виконання. Синтаксис - <code>assert(умова)</code>. Якщо твердження не справжнюється, програма завершиться відповідним повідомленням про помилку. Є ще кілька методів твердження в стандартному просторі імен <code>GLib</code>, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">assert_not_reached</span><span class="p">()</span>

<span class="n">return_if_fail</span><span class="p">(</span><span class="kt">bool</span> <span class="n">expr</span><span class="p">)</span>

<span class="n">return_if_reached</span><span class="p">()</span>

<span class="n">warn_if_fail</span><span class="p">(</span><span class="kt">bool</span> <span class="n">expr</span><span class="p">)</span>

<span class="n">warn_if_reached</span><span class="p">()</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете спокуситись використовувати твердження, щоб перевірити аргументи методу на <code>null</code>. Однак це не обов'язково, оскільки Vala робить це неявно для всіх параметрів, які не позначені <code>?</code> як можливий <code>null</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">method_name</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">,</span> <span class="n">Bar</span> <span class="n">bar</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">/</span> <span class="o">*</span> <span class="err">Не</span> <span class="err">потрібно</span><span class="p">,</span> <span class="err">Вала</span> <span class="err">це</span> <span class="err">робить</span> <span class="err">за</span> <span class="err">вас</span><span class="o">:</span>
    <span class="n">return_if_fail</span><span class="p">(</span><span class="n">foo</span> <span class="o">!=</span> <span class="nb">null</span><span class="p">);</span>
    <span class="n">return_if_fail</span><span class="p">(</span><span class="n">bar</span> <span class="o">!=</span> <span class="nb">null</span><span class="p">);</span>
    <span class="o">*/</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala підтримує основні функції контрактного програмування. Метод може мати передумови (<code>requires</code>) та постумови (<code>ensures</code>), які повинні бути виконані на початку або в кінці методу відповідно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">double</span> <span class="n">method_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
        <span class="kd">requires</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span>
        <span class="kd">requires</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="kd">ensures</span> <span class="p">(</span><span class="n">result</span> <span class="o">&gt;=</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span> <span class="n">result</span> <span class="o">&lt;=</span> <span class="mf">10.0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">d</span> <span class="o">*</span> <span class="n">x</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>result</code> - це спеціальна змінна, що представляє повернене значення.</p></div>
</div>
<div class="sect2">
<h3 id="___16">Обробка помилок</h3>
<div class="paragraph"><p>GLib має систему управління винятками часу виконання, що називається <code>GError</code>. Vala переводить це у форму, звичну для сучасних мов програмування, але її реалізація означає, що вона не зовсім така, як у Java або C#. Важливо врахувати, коли використовувати цей тип обробки помилок - <code>GError</code> значною мірою спеціально розроблений для боротьби з помилками, що відновлюються, тобто факторами, які не відомі до запуску програми в реальній системі, і які не є фатальними для виконання . Не слід використовувати <code>GError</code> для проблем, які можна передбачити, наприклад, повідомлення про те, що методу передане недійсне значення. Якщо метод, наприклад, вимагає в якості параметра числа, що перевищує <code>0</code>, він повинен уникати негативних значень, використовуючи методи контрактного програмування, такі як передумови або твердження, описані в попередньому розділі.</p></div>
<div class="paragraph"><p>Помилки Vala - це так звані перевірені винятки, що означає, що помилки повинні бути оброблені в певний момент. Однак якщо ви не виявите помилку, компілятор Vala видасть лише попередження, не зупиняючи процес компіляції.</p></div>
<div class="paragraph"><p>Використання винятків (або помилок у термінології Vala) - це питання:</p></div>
<div class="paragraph"><p>1) Заявити, що метод може призвести до помилки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">my_method</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">IOError</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>2) Викидання помилки, коли це доречно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">something_went_wrong</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="n">IOError</span><span class="p">.</span><span class="n">FILE_NOT_FOUND</span><span class="p">(</span><span class="s">&quot;Requested file could not be found.&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>3) Перехоплення помилки з коду виклику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
    <span class="n">my_method</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Error: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>4) Порівняння коду помилки оператором <code>is</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">IOChannel</span> <span class="n">channel</span><span class="p">;</span>
<span class="k">try</span> <span class="p">{</span>
    <span class="n">channel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IOChannel</span><span class="p">.</span><span class="n">file</span><span class="p">(</span><span class="s">&quot;/tmp/my_lock&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">FileError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">e</span> <span class="k">is</span> <span class="n">FileError</span><span class="p">.</span><span class="n">EXIST</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">e</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">GLib</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Все це виглядає більш-менш, як і в інших мовах, але визначення типів допущених помилок є досить унікальним. Помилки мають три компоненти, відомі як "домен", "код" та повідомлення. Повідомлення, які ми вже бачили, це просто фрагмент тексту, який надається при створенні помилки. Домени помилок описують тип проблеми та прирівнюється до підкласу <code>Exception</code> в Java або подібних. У наведених вище прикладах ми уявили домен помилки під назвою <code>IOError</code>. Третя частина, код помилки - це уточнення, що описує точну різноманітність виниклої проблеми. Кожен домен помилки має один або кілька кодів помилок - у прикладі є код під назвою <code>FILE_NOT_FOUND</code>.</p></div>
<div class="paragraph"><p>Спосіб визначення цієї інформації про типи помилок пов'язаний з реалізацією в <code>glib</code>. Для того, щоб приклади тут працювали, потрібно таке визначення, як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">errordomain</span> <span class="nc">IOError</span> <span class="p">{</span>
    <span class="n">FILE_NOT_FOUND</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Під час перехоплення помилки ви надаєте домен помилок, в якому хочете перехопити помилки, і якщо помилка в цьому домені виникає, код у обробнику запускається з помилкою, присвоєною наданому імені. З цього об’єкта помилки ви можете отримати код помилки та повідомлення за потребою. Якщо ви хочете вловлювати помилки з більш ніж одного домену, просто надайте додаткові блоки вилову. Існує також необов'язковий блок, який можна розмістити після <code>try</code> та будь-яких <code>catch</code> блоки, <code>finally</code>. Цей код слід виконувати завжди в кінці розділу, незалежно від того, була помилка викинута чи виконані будь-які блоки перехоплення, навіть якщо помилка насправді не оброблялася та буде закинута знову. Це дозволяє, наприклад, звільняти будь-які ресурси, зарезервовані у блоці <code>try</code>, незалежно від будь-яких помилок. Повний приклад цих функцій:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">errordomain</span> <span class="nc">ErrorType1</span> <span class="p">{</span>
    <span class="n">CODE_1A</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">errordomain</span> <span class="nc">ErrorType2</span> <span class="p">{</span>
    <span class="n">CODE_2A</span><span class="p">,</span>
    <span class="n">CODE_2B</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">thrower</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">ErrorType1</span><span class="p">,</span> <span class="n">ErrorType2</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="n">ErrorType1</span><span class="p">.</span><span class="n">CODE_1A</span><span class="p">(</span><span class="s">&quot;Error&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="n">catcher</span><span class="p">()</span> <span class="kd">throws</span> <span class="n">ErrorType2</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">thrower</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ErrorType1</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Робота з ErrorType1</span>
        <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
            <span class="c1">// Прибирати</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="n">catcher</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ErrorType2</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Робота з ErrorType2</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="k">is</span> <span class="n">ErrorType2</span><span class="p">.</span><span class="n">CODE_2B</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Попрацюйте з цим кодом</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі є два домена помилок, обидві з яких можна перекинути методом <code>thrower</code>. <code>catcher</code> може згенерувати лише помилку другого типу, і так повинен владнати справи з першим типом, якщо <code>thrower</code> закидає його. Нарешті, метод <code>main</code> впорається з будь-якими помилками <code>catcher</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___17">Напрямок параметрів</h3>
<div class="paragraph"><p>Метод у Vala передається нульовим або більше аргументами. Поведінка за замовчуванням при виклику методу є наступним:</p></div>
<div class="ulist"><ul>
<li>
<p>
Будь-які параметри типу значень копіюються у локальне місце для методу під час його виконання.
</p>
</li>
<li>
<p>
Будь-які параметри типу посилання не копіюються, натомість методу просто передається посилання на них.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ця поведінка може бути змінена за допомогою модифікаторів <code>ref</code> та <code>out</code>.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>out</code> з боку викликаючого
ви можете передати методу неініціалізовану змінну і, можливо, очікуєте, що вона буде ініціалізована після повернення методу
</p>
</li>
<li>
<p>
<code>out</code> для викликаного
параметр вважається неініціалізованим, і вам доведеться його ініціалізувати
</p>
</li>
<li>
<p>
<code>ref</code> з боку викликаючого
змінна, яку ви передаєте методу, повинна бути ініціалізована, і вона може бути змінена  методом або ні
</p>
</li>
<li>
<p>
<code>ref</code> для викликаного
параметр вважається ініціалізованим, і ви можете його змінити чи ні
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">method_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kd">ref</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">method_2</span><span class="p">(</span><span class="n">Object</span> <span class="n">o</span><span class="p">,</span> <span class="k">out</span> <span class="n">Object</span> <span class="n">p</span><span class="p">,</span> <span class="kd">ref</span> <span class="n">Object</span> <span class="n">q</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці методи можна визвати наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">method_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">out</span> <span class="n">b</span><span class="p">,</span> <span class="kd">ref</span> <span class="n">c</span><span class="p">);</span>

<span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
<span class="n">Object</span> <span class="n">p</span><span class="p">;</span>
<span class="n">Object</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
<span class="n">method_2</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="k">out</span> <span class="n">p</span><span class="p">,</span> <span class="kd">ref</span> <span class="n">q</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Обробка кожної змінної буде такою:</p></div>
<div class="paragraph"><p><code>a</code> - це значення типу. Значення буде скопійовано в нове місце пам'яті, локальне для методу, і тому зміни в ньому не будуть видні викликаючому.</p></div>
<div class="paragraph"><p><code>b</code> також має тип значення, але передається як параметр <code>out</code>. У цьому випадку значення не скопіюється, замість цього методу передається вказівник на дані, і тому будь-яке зміна параметра методу буде видимим для виклику коду.</p></div>
<div class="paragraph"><p><code>c</code> трактується так само, як <code>"b"</code>, єдина зміна полягає у сигналі про наміри методу.</p></div>
<div class="paragraph"><p><code>o</code> має тип посилання. Метод передається посиланням на той самий об'єкт, що і викликаюча сторона. Таким чином, метод може змінити цей об'єкт, але якщо він переприсвоїть параметр, ця зміна не буде видимою для абонента.</p></div>
<div class="paragraph"><p><code>p</code> того самого типу, але передається як параметр <code>out</code>. Це означає, що метод отримає вказівник на посилання на об'єкт. Тому він може замінити посилання на посилання на інший об'єкт, і коли метод повернеться, викликаючий замість старого повинен мати посилання на цей інший об'єкт. Якщо ви використовуєте цей тип параметрів, якщо ви не призначите нове посилання на параметр, він буде встановлений в <code>null</code>.</p></div>
<div class="paragraph"><p><code>q</code> знову того ж типу. Цей випадок трактується як <code>p</code> з важливими відмінностями у тому, що метод може не змінити посилання і може отримати доступ до об'єкта, на який посилається. Vala переконається, що в цьому випадку <code>q</code> насправді посилається на будь-який об'єкт, і воно не буде встановлено на <code>null</code>.</p></div>
<div class="paragraph"><p>Ось приклад того, як реалізувати <code>method_1()</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">method_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kd">ref</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Встановлюючи значення для аргументу <code>out b</code>, Vala переконається, що <code>b</code> не є <code>null</code>. Тож ви можете сміливо передавати <code>null</code> як другий аргумент <code>method_1()</code>, якщо вас це значення не цікавить.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__23">Колекції</h2>
<div class="sectionbody">
<div class="paragraph"><p>Gee - бібліотека колекцій класів, написана у Vala. Усі класи повинні бути знайомі користувачам бібліотек, таких як Java Foundation Classes. Gee складається з набору інтерфейсів і різних типів, які по-різному реалізують їх.</p></div>
<div class="paragraph"><p>Якщо ви хочете використовувати Gee у власному додатку, встановіть бібліотеку окремо у вашій системі. Gee можна отримати на <a href="http://live.gnome.org/Projects/Libgee">http://live.gnome.org/Projects/Libgee</a>. Щоб користуватися бібліотекою, ви повинні компілювати свої програми з <code>--pkg gee-0.8</code>.</p></div>
<div class="paragraph"><p>Основними видами колекції є:</p></div>
<div class="ulist"><ul>
<li>
<p>
Списки: впорядковані колекції предметів, доступні за числовим індексом.
</p>
</li>
<li>
<p>
Набори: невпорядковані колекції без повторів.
</p>
</li>
<li>
<p>
Мапи: Непорядкована колекція предметів, доступна за індексом довільного типу.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Усі списки та набори в бібліотеці реалізують інтерфейс <code>Collection</code>, та всі мапи - інтерфейсу <code>Map</code>. Списки також реалізують <code>List</code> та набори <code>Set</code>. Ці загальні інтерфейси означають не тільки те, що всі колекції подібного типу можуть використовуватися взаємозамінно, але і те, що нові колекції можна писати за допомогою тих самих інтерфейсів, і тому використовувати з існуючим кодом.</p></div>
<div class="paragraph"><p>Також спільним для кожного типу <code>Collection</code> є інтерфейс <code>Iterable</code>. Це означає, що будь-який об’єкт у цій категорії можна повторити за допомогою стандартного набору методів або безпосередньо у Vala, використовуючи синтаксис <code>foreach</code>.</p></div>
<div class="paragraph"><p>Усі класи та інтерфейси використовують систему дженеріків. Це означає, що вони повинні бути реалізовані з примірниками певного типу або набору типів, які вони будуть містити. Система гарантуватиме, що до колекцій можуть бути покладені лише призначені типи, а також, що коли об'єкти будуть отримані, вони повернуться як правильний тип.</p></div>
<div class="paragraph"><p><a href="http://valadoc.org/gee-0.8/index.htm">Повна документація Gee API</a>, <a href="https://wiki.gnome.org/Projects/Vala/GeeSamples">Приклади Gee</a></p></div>
<div class="paragraph"><p>Деякі важливі класи Gee:</p></div>
<div class="sect3">
<h4 id="_arraylist_lt_g_gt">ArrayList&lt;G&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;G&gt;</code>, <code>Collection&lt;G&gt;</code>, <code>List&lt;G&gt;</code></p></div>
<div class="paragraph"><p>Впорядкований список елементів типу <code>G</code>, підкріплений масивом, що динамічно змінюється. Цей тип дуже швидкий для доступу до даних, але потенційно повільний при вставці елементів де-небудь, крім кінця, або при вставці елементів, коли внутрішній масив заповнений.</p></div>
</div>
<div class="sect3">
<h4 id="_hashmap_lt_k_v_gt">HashMap&lt;K,V&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;Entry&lt;K,V&gt;&gt;</code>, <code>Map&lt;K,V&gt;</code></p></div>
<div class="paragraph"><p>Відбраження 1:1 від елементів типу <code>K</code> до елементів типу <code>V</code>. Відображення проводиться шляхом обчислення хеш-значення для кожного ключа - це можна налаштувати шляхом надання покажчиків на функції хешування та тестування рівності ключів певними способами.</p></div>
<div class="paragraph"><p>Ви можете опціонально передавати конструктору власні функції хешу та рівності, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">map</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gee</span><span class="p">.</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Foo</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span><span class="p">(</span><span class="n">foo_hash</span><span class="p">,</span> <span class="n">foo_equal</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Для рядків і цілих чисел функції хешу і рівності виявляються автоматично, об'єкти відрізняються за посиланнями за замовчуванням. Ви повинні забезпечити користувацькі функції хешу і рівності, лише якщо ви хочете змінити поведінку за замовчуванням.</p></div>
</div>
<div class="sect3">
<h4 id="_hashset_lt_g_gt">HashSet&lt;G&gt;</h4>
<div class="paragraph"><p>Реалізує: <code>Iterable&lt;G&gt;</code>, <code>Collection&lt;G&gt;</code>, <code>Set&lt;G&gt;</code></p></div>
<div class="paragraph"><p>Набір елементів типу <code>G</code>. Дублікати виявляються за допомогою обчислення хеш-значення для кожного ключа - це можна налаштувати, надаючи покажчики функції хешування та тестуючи рівність ключів певними способами.</p></div>
</div>
<div class="sect3">
<h4 id="_____5">Перегляди лише для читання</h4>
<div class="paragraph"><p>Ви можете отримати представлення колекції лише для читання за допомогою властивості <code>read_only_view</code>, наприклад, <code>my_map.read_only_view</code>. Це поверне обгортку, яка має той самий інтерфейс, що і її первинна колекція, але не дозволить будь-якої форми модифікації або будь-якого доступу до вміщеної колекції.</p></div>
</div>
<div class="sect2">
<h3 id="_____6">Методи з підтримкою синтаксису</h3>
<div class="paragraph"><p>Vala розпізнає деякі методи з певними іменами та підписами та надає їм підтримку синтаксису. Наприклад, якщо тип містить метод <code>contains()</code>, об'єкти цього типу можуть використовуватися з оператором <code>in</code>. У наступній таблиці перераховані ці спеціальні методи. <code>T</code> і <code>Tn</code> є лише заповнювачами типів у цій таблиці і повинні бути замінені реальними типами.</p></div>
<div class="sect3">
<h4 id="__24">Індексатори</h4>
<div class="paragraph"><p><code>T2 get(T1 index)</code> індексний доступ: <code>obj[index]</code></p></div>
<div class="paragraph"><p><code>void set(T1 index, T2 item)</code> індексне призначення: <code>obj[index] = item</code></p></div>
</div>
<div class="sect3">
<h4 id="_____7">Індексатори з декількома індексами</h4>
<div class="paragraph"><p><code>T3 get(T1 index1, T2 index2)</code> індексний доступ: <code>obj[index1, index2]</code></p></div>
<div class="paragraph"><p><code>void set(T1 index1, T2 index2, T3 item)</code> індексне призначення: <code>obj[index1, index2] = item</code></p></div>
<div class="paragraph"><p>(&#8230; і так далі для отримання додаткових індексів)</p></div>
</div>
<div class="sect3">
<h4 id="__25">Інші</h4>
<div class="paragraph"><p><code>T slice(long start, long end)</code> фрагментація: <code>obj[start:end]</code></p></div>
<div class="paragraph"><p><code>bool contains(T needle)</code> оператор <code>in</code>: <code>bool b = needle in obj</code></p></div>
<div class="paragraph"><p><code>string to_string()</code> підтримка через рядкові шаблони: <code>@"$obj"</code></p></div>
<div class="paragraph"><p><code>Iterator iterator()</code> інерабельне через <code>foreach</code></p></div>
<div class="paragraph"><p><code>T1 size { get; }</code>  інерабельне через <code>foreach</code></p></div>
<div class="paragraph"><p>Тип <code>Iterator</code> може мати будь-яке ім'я і повинен реалізувати один з цих двох протоколів:</p></div>
<div class="paragraph"><p><code>bool next()</code>, <code>T get()</code> стандартний протокол ітератора: ітерація, поки <code>.next()</code> не поверне значення <code>false</code>. Поточний елемент витягується через <code>.get()</code>.</p></div>
<div class="paragraph"><p><code>T? next_value()</code> альтернативний протокол ітератора: якщо об’єкт ітератора має функцію <code>.next_value()</code>, яка повертає null-здатний тип, то ми повторюємо, викликаючи цю функцію, поки вона не поверне <code>null</code>.</p></div>
<div class="paragraph"><p>Цей приклад реалізує деякі з цих методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EvenNumbers</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="k">get</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">index</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">bool</span> <span class="n">contains</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">string</span> <span class="n">to_string</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="s">&quot;[This object enumerates even numbers]&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="n">Iterator</span> <span class="n">iterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Iterator</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">class</span> <span class="nc">Iterator</span> <span class="p">{</span>
        <span class="kd">private</span> <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
        <span class="kd">private</span> <span class="n">EvenNumbers</span> <span class="n">even</span><span class="p">;</span>

        <span class="kd">public</span> <span class="n">Iterator</span><span class="p">(</span><span class="n">EvenNumbers</span> <span class="n">even</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">even</span> <span class="o">=</span> <span class="n">even</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="kt">bool</span> <span class="n">next</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kd">public</span> <span class="kt">int</span> <span class="k">get</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">index</span><span class="o">++</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">even</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">even</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EvenNumbers</span><span class="p">();</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">even</span><span class="p">[</span><span class="mi">5</span><span class="p">]);</span>   <span class="c1">// get()</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="k">in</span> <span class="n">even</span><span class="p">)</span> <span class="p">{</span>                  <span class="c1">// contains()</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">@&quot;$even</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>    <span class="c1">// to_string()</span>
    <span class="p">}</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="k">in</span> <span class="n">even</span><span class="p">)</span> <span class="p">{</span>         <span class="c1">// iterator()</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">20</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__26">Багатопоточність</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="___vala_2">Потоки у Vala</h3>
<div class="paragraph"><p>Програма, написана у Vala, може мати кілька потоків виконання, що дозволяє їй робити більше, ніж одну справу. Точно, як цим керувати, виходить за межі Vala - потоки можуть мати спільне ядро ​​процесора чи ні, залежно від середовища.</p></div>
<div class="paragraph"><p>Потік у Vala не визначається під час компіляції, натомість це просто частина коду Vala, яку вимагають під час виконання виконувати як новий потік. Це робиться за допомогою статичних методів класу <code>Thread</code> в GLib, як показано в наступному (дуже спрощеному) прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span> <span class="n">thread_func</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Thread running.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Thread</span><span class="p">.</span><span class="n">supported</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">stderr</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Cannot run without threads.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">try</span> <span class="p">{</span>
        <span class="n">Thread</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ThreadError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця коротка програма запитує створення та виконання нового потоку. Код, який слід запустити, знаходиться в <code>thread_func</code>. Також зверніть увагу на тест на початку методу <code>main</code> - програма Vala не зможе використовувати потоки, якщо не буде скомпільована належним чином, тож якщо ви побудуєте цей приклад звичайним способом, він просто відобразить помилку і перестане працювати. Можливість перевірити підтримку потоку під час виконання дозволяє будувати програму для запуску з потоками або без них, як треба. Для того, щоб побудувати з підтримкою потоку, запустіть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">valac</span> <span class="o">--</span><span class="n">thread</span> <span class="n">threading</span><span class="o">-</span><span class="n">sample</span><span class="p">.</span><span class="n">vala</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде включати необхідні бібліотеки та забезпечити ініціалізацію системи потоків, коли це можливо.</p></div>
<div class="paragraph"><p>Тепер програма буде працювати без помилок сегментації, але вона все ще не буде діяти так, як очікувалося. Без будь-якого циклу подій програма Vala припиняється, коли закінчується її основний потік (той, що створений для запуску <code>main</code>). Щоб контролювати таку поведінку, ви можете дозволити потокам співпрацювати. Це можна зробити потужно за допомогою циклів подій та асинхронних черг, але в цьому вступі до потоків ми просто покажемо основні можливості потоків.</p></div>
<div class="paragraph"><p>Потік може сказати системі, що в даний момент його немає необхідності виконувати, і тим самим запропонувати замість цього запустити інший потік. Це робиться за допомогою статичного методу <code>Thread.yield()</code>. Якщо це твердження було розміщено в кінці вищезгаданого методу <code>main</code>, система часу виконання призупинить основний потік і перевірить, чи є інші потоки, які можна запустити - після знаходження новоствореного потоку в стані, який можна виконати, він буде запустіть це замість нього, поки він не буде закінчений - і програма діятиме так, як здається, повинна. Однак немає гарантії, що це все ж таки відбудеться. Система здатна вирішувати, коли запускаються потоки, і, як такий, може не дозволити новому потоку закінчитися до перезапуску первинного потоку та закінчення програми.</p></div>
<div class="paragraph"><p>Для того, щоб чекати, коли нитка повністю закінчиться, існує метод <code>join()</code>. Виклик цього методу на об'єкті <code>Thread</code> змушує викликаючий потік зачекати, поки закінчиться інший потік, перш ніж продовжувати. Це також дозволяє потоку отримувати повернене значення іншого, якщо це корисно. Щоб реалізувати з'єднувальні нитки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">try</span> <span class="p">{</span>
    <span class="kd">unowned</span> <span class="n">Thread</span> <span class="n">thread</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">thread_func</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">thread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">ThreadError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цього разу, коли ми створюємо потік, ми додаємо <code>true</code> як останній аргумент. Це позначає нитку як "приєднану". Ми також пам’ятаємо значення, повернене в результаті створення - <code>unowned</code> посилання на об’єкт <code>Thread</code> (<code>unowned</code> посилання пояснюються пізніше і не є життєво важливими для цього розділу.) За допомогою цього посилання можна приєднати новий потік до первинного потоку. З цією версією програми гарантується, що новоствореному потоку буде дозволено повністю виконатись до продовження первинного потоку та припинення програми.</p></div>
<div class="paragraph"><p>Усі ці приклади мають потенційну проблему в тому, що новостворений потік не знає контексту, в якому він повинен працювати. У C ви б надали методу створення потоку деякі дані, у Vala замість статичного методу ви зазвичай передаєте метод екземпляра <code>Thread.create</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___18">Контроль ресурсів</h3>
<div class="paragraph"><p>Кожного разу, коли одночасно виконується більше ніж один потік виконання, є ймовірність, що дані мають одночасний доступ. Це може призвести до умов перегонів, де результат залежить від того, коли система вирішить перемикатися між потоками.</p></div>
<div class="paragraph"><p>Щоб контролювати цю ситуацію, ви можете використовувати ключове слово <code>lock</code>, щоб гарантувати, що певні блоки коду не будуть перервані іншими потоками, яким потрібно отримати доступ до тих самих даних. Найкращий спосіб показати це, мабуть, на прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Test</span> <span class="o">:</span> <span class="n">GLib</span><span class="p">.</span><span class="n">Object</span> <span class="p">{</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">action_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">tmp</span><span class="o">++</span><span class="p">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">action_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">tmp</span><span class="o">--</span><span class="p">;</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей клас визначає два методи, коли обом потрібно змінити значення <code>a</code>. Якби тут не було записів про блокування, вказівки в цих методах могли б переплестись, і отримана зміна на <code>а</code> була б фактично випадковою. Оскільки тут є заяви про блокування, Vala гарантує, що якщо одна нитка заблокувала <code>a</code>, інший потік, який потребує такого ж блокування, повинен буде дочекатися своєї черги.</p></div>
<div class="paragraph"><p>У Vala можна лише заблокувати члени об'єкта, який виконує код. Це може здатися головним обмеженням, але насправді стандартне використання цієї методики повинно включати класи, які індивідуально відповідають за управління ресурсом, і тому все блокування дійсно буде внутрішнім для класу. Так само, у наведеному вище прикладі всі звернення до <code>а</code> інкапсульовані у класі.</p></div>
</div>
<div class="sect2">
<h3 id="___19">Основний цикл</h3>
<div class="paragraph"><p>GLib включає систему для запуску циклу подій у класах навколо <code>MainLoop</code>. Призачення цієї системи - дозволити вам написати програму, яка чекає подій та реагує на них, замість того, щоб постійно перевіряти умови. Це модель, яку використовує GTK +, щоб програма могла чекати взаємодії з користувачем, не виконуючи жодного поточного коду.</p></div>
<div class="paragraph"><p>Наступна програма створює та запускає <code>MainLoop</code>, а потім додає до нього джерело подій. У цьому випадку джерелом є простий таймер, який виконає даний метод через 2000 мс. Метод насправді просто зупинить основний цикл, який у цьому випадку вийде з програми.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="kd">var</span> <span class="n">loop</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MainLoop</span><span class="p">();</span>
    <span class="kd">var</span> <span class="n">time</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TimeoutSource</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>

    <span class="n">time</span><span class="p">.</span><span class="n">set_callback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Time!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">loop</span><span class="p">.</span><span class="n">quit</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">time</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="n">loop</span><span class="p">.</span><span class="n">get_context</span><span class="p">());</span>

    <span class="n">loop</span><span class="p">.</span><span class="n">run</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>При використанні GTK + основний цикл буде створений автоматично, і він буде запущений при виклику методу <code>Gtk.main()</code>. Це означає, що програма готова запуститись і почати приймати події від користувача чи з іншого джерела. Код в GTK + еквівалентний короткому прикладу, наведеному вище, і тому ви можете додавати джерела подій приблизно так само, хоча, звичайно, вам потрібно використовувати методи GTK+ для управління основним циклом.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">Gtk</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="kd">ref</span> <span class="n">args</span><span class="p">);</span>
    <span class="kd">var</span> <span class="n">time</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TimeoutSource</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span>

    <span class="n">time</span><span class="p">.</span><span class="n">set_callback</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Time!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="n">Gtk</span><span class="p">.</span><span class="n">main_quit</span><span class="p">();</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">});</span>

    <span class="n">time</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span><span class="nb">null</span><span class="p">);</span>

    <span class="n">Gtk</span><span class="p">.</span><span class="n">main</span><span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Поширена вимога програм GUI полягає в тому, щоб виконувати якийсь код якомога швидше, але лише тоді, коли він не заважатиме користувачеві. Для цього ви використовуєте екземпляри <code>IdleSource</code>. Вони надсилають події в основний цикл програм, але вимагають, щоб з вони розглядалися лише тоді, коли нема нічого важливішого.</p></div>
<div class="paragraph"><p>Для отримання додаткової інформації про циклі подій див. Документацію GLib та GTK+.</p></div>
</div>
<div class="sect2">
<h3 id="___20">Асинхронні методи</h3>
<div class="paragraph"><p>Асинхронні методи - це методи, виконання яких можна призупинити та відновити під контролем програміста. Вони часто використовуються в головному потоці програми, де методу потрібно чекати, коли зовнішнє повільне завдання завершиться, але не повинно перешкоджати іншій обробці. (Наприклад, одна повільна робота не повинна заморожувати весь графічний інтерфейс). Коли методу доводиться чекати, він повертає керування процесором назад своєму абоненту (тобто він поступається), але він впорядковує виклик для відновлення виконання, коли дані стануть готовими. Зовнішні повільні завдання, які можуть чекати методи асинхронізації, включають: очікування даних з віддаленого сервера або очікування завершення обчислень в іншому потоці або очікування завантаження даних з дискового прикладу.</p></div>
<div class="paragraph"><p>Асинхронні методи, як правило, використовуються для основного циклу GLib, оскільки зворотні виклики використовуються для обробки деяких внутрішніх зворотних викликів. Однак за певних умов <code>async</code> може використовуватися без основного циклу GLib, наприклад, якщо методи асинхронізації завжди поступаються, а <code>Idle.add()</code> ніколи не використовується. (FIXME: Перевірте, які точні умови).</p></div>
<div class="paragraph"><p>Асинхронні методи призначені для переплетення обробки багатьох різних довготривалих операцій у межах однієї нитки. Вони самі по собі не розподіляють навантаження на різні нитки. Однак метод асинхронізації може бути використаний для керування фоновою ниткою та дочекання її завершення або для виконання операцій черги для обробки фонового потоку.</p></div>
<div class="paragraph"><p>Методи асинхронізації у Vala використовують бібліотеку GIO для обробки зворотних викликів, тому повинні бути побудовані за допомогою параметра <code>--pkg = gio-2.0</code>.</p></div>
<div class="paragraph"><p>Асинхронний метод визначається за допомогою ключового слова <code>async</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">async</span> <span class="kt">void</span> <span class="n">display_jpeg</span><span class="p">(</span><span class="kt">string</span> <span class="n">fnam</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Завантажте JPEG у фонову нитку та відображайте його при завантаженні</span>
     <span class="p">[...]</span>
  <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>або:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">async</span> <span class="kt">int</span> <span class="n">fetch_webpage</span><span class="p">(</span><span class="kt">string</span> <span class="n">url</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">text</span><span class="p">)</span> <span class="kd">throws</span> <span class="n">IOError</span> <span class="p">{</span>
<span class="c1">// Виберіть веб-сторінку асинхронно, і коли будете готові, поверніть</span>
<span class="c1">// код статусу HTTP та вміст сторінки помістіть у &quot;текст&quot;</span>
     <span class="p">[...]</span>
     <span class="n">text</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">status</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод може приймати аргументи і повертати значення, як і будь-який інший метод. Він може в будь-який час використовувати <code>yield</code>, щоб повернути керування процесором своєму абоненту.</p></div>
<div class="paragraph"><p>Метод <code>async</code> може бути викликаний будь-якою з цих двох форм:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">display_jpeg</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="s">&quot;test.jpg&quot;</span><span class="p">);</span>
  <span class="n">display_jpeg</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="s">&quot;test.jpg&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="n">display_jpeg</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">res</span><span class="p">);</span>
  <span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Обидві форми запускають метод асинхронізації, що працює із заданими аргументами. Крім того, друга форма реєструє <code>AsyncReadyCallback</code>, який виконується після завершення методу. Зворотний виклик бере в якості аргументів вихідний об'єкт, <code>obj</code>, та екземпляр <code>GAyncResult</code>, <code>res</code>. У зворотному виклику повинен бути викликаний метод <code>.end()</code>, щоб отримати значення повернення асинхронного методу, якщо він має його. Якщо метод асинхронізації може кинути виняток, виклик <code>.end()</code> - це місце, де виняток надходить, і його потрібно спіймати. Якщо у методу є <code>out</code> аргументи, їх слід опустити з виклику <code>.begin()</code> і замість цього додати до виклику <code>.end()</code>.</p></div>
<div class="paragraph"><p>Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">fetch_webpage</span><span class="p">.</span><span class="n">begin</span><span class="p">(</span><span class="s">&quot;http://www.example.com/&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
          <span class="kt">string</span> <span class="n">text</span><span class="p">;</span>
          <span class="kd">var</span> <span class="n">status</span> <span class="o">=</span> <span class="n">fetch_webpage</span><span class="p">.</span><span class="n">end</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="k">out</span> <span class="n">text</span><span class="p">);</span>
<span class="c1">// Результат виклику в тексті та в статусі ...</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Проблема ...</span>
      <span class="p">}</span>
  <span class="p">});</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли асинхронний метод починає працювати, він бере контроль над процесором до тих пір, поки не досягне своєї першої заяви <code>yield</code> про вихід, після чого повертається до абонента. Коли метод відновлено, він продовжує виконання відразу після цього твердження про вихід. Існує кілька загальних способів використання <code>yield</code>:</p></div>
<div class="paragraph"><p>Ця форма відмовляється від контролю, але впорядковує, щоб основний цикл GLib відновив метод, коли немає більше подій для обробки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">Idle</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">fetch_webpage</span><span class="p">.</span><span class="n">callback</span><span class="p">);</span>
  <span class="k">yield</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця форма відмовляється від керування та зберігає дані про зворотний виклик для іншого коду, який слід використовувати для відновлення виконання методу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">SourceFunc</span> <span class="n">callback</span> <span class="o">=</span> <span class="n">fetch_webpage</span><span class="p">.</span><span class="n">callback</span><span class="p">;</span>
  <span class="p">[...</span> <span class="n">store</span> <span class="err">&#39;</span><span class="n">callback</span><span class="err">&#39;</span> <span class="n">somewhere</span> <span class="p">...]</span>
  <span class="k">yield</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Деякий код в іншому місці тепер повинен викликати збережений <code>SourceFunc</code>, щоб метод відновився. Це можна зробити, запланувавши основний цикл GLib для його запуску:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">Idle</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="kd">owned</span><span class="p">)</span> <span class="n">callback</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>або альтернативно, може здійснюватися прямий виклик, якщо абонент працює в основному потоці:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">callback</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо використовується прямий виклик, зазначений вище, то відновлений асинхронний метод негайно приймає контроль над процесором і працює до наступного виходу <code>yield</code>, перш ніж повернутися до коду, який виконував <code>callback()</code>. Метод <code>Idle.add()</code> корисний, якщо зворотний виклик повинен здійснюватися з фонового потоку, наприклад відновити метод асинхронізації після завершення деякої фонової обробки. (Твердження <code>(owned)</code> необхідне, щоб уникнути попередження про копіювання делегатів).</p></div>
<div class="paragraph"><p>Третій поширений спосіб використання <code>yield</code> - це виклик іншого асинхронного методу, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">yield</span> <span class="n">display_jpeg</span><span class="p">(</span><span class="n">fnam</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>або</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="kd">var</span> <span class="n">status</span> <span class="o">=</span> <span class="k">yield</span> <span class="n">fetch_webpage</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="k">out</span> <span class="n">text</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>В обох випадках метод виклику відмовляється від управління процесором і не поновлюється до завершення викликаного методу. Твердження <code>yield</code> автоматично реєструє зворотний виклик методом виклику, щоб переконатися, що абонент поновлюється правильно. Автоматичний зворотний виклик також отримує повернене значення від викликаного методу.</p></div>
<div class="paragraph"><p>Коли цей оператор <code>yield</code> виконується, керування процесором спочатку переходить до викликаного методу, який працює до його першого <code>yield</code>, а потім переходить до виклику методу, який сам завершує <code>yield</code>, а потім повертає управління власному виклику.</p></div>
<div class="sect3">
<h4 id="__27">Приклади</h4>
<div class="paragraph"><p>Див. <a href="https://wiki.gnome.org/Projects/Vala/AsyncSamples">Зразки методів асинхронізації</a> для прикладів різних способів використання <code>async</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___21">Слабкі посилання</h3>
<div class="paragraph"><p>Управління пам'яттю Vala засноване на автоматичному підрахунку посилань. Кожного разу, коли об'єкт присвоюється змінній, його внутрішній лічильник посилань збільшується на 1, кожен раз, коли змінна, що посилається на об'єкт, виходить за межі, його внутрішній лічильник посилання зменшується на 1. Якщо число посилань досягає 0, об'єкт буде звільнений.</p></div>
<div class="paragraph"><p>Однак можна створити циклічні посилання зі своїми структурами даних. Наприклад, зі структурою даних дерев, де дочірній вузол містить посилання на його батьківський і навпаки, або подвійно пов'язаний список, де кожен елемент містить посилання на свого попередника, а попередник містить посилання на свого наступника.</p></div>
<div class="paragraph"><p>У цих випадках об'єкти можуть залишатися живими, просто посилаючись один на одного, хоча вони повинні бути звільнені. Для розірвання такого циклу посилань можна використовувати модифікатор <code>weak</code> для однієї з посилань:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kd">weak</span> <span class="n">Node</span> <span class="n">prev</span><span class="p">;</span>
    <span class="kd">public</span> <span class="n">Node</span> <span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця тема детально пояснена на цій сторінці: <a href="https://wiki.gnome.org/Projects/Vala/ReferenceHandling">Пояснення управління пам’яттю Vala</a>.</p></div>
</div>
<div class="sect2">
<h3 id="__28">Власність</h3>
<div class="sect3">
<h4 id="___22">Нічийні посилання</h4>
<div class="paragraph"><p>Зазвичай при створенні об'єкта у Vala вам повертається посилання на нього. Зокрема, це означає, що, незважаючи на те, що він передається вказівником на об'єкт в пам'яті, він також записує в самому об'єкті, що цей покажчик існує. Аналогічно, щоразу, коли створюється інше посилання на об'єкт, це також записується. Оскільки об’єкт знає, скільки посилань на нього є, він може бути автоматично видалений при необхідності. Це основа управління пам’яттю Vala.</p></div>
</div>
<div class="sect3">
<h4 id="___23">Власність методів</h4>
<div class="paragraph"><p>Нічийні посилання навпаки не реєструються в об'єкті, на який вони посилаються. Це дозволяє вилучити об'єкт, коли це буде логічно, незалежно від того, що на нього все ще можуть бути посилання. Звичайний спосіб досягти цього - це метод, визначений для повернення нічийного посилання, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Test</span> <span class="p">{</span>
    <span class="kd">private</span> <span class="n">Object</span> <span class="n">o</span><span class="p">;</span>

    <span class="kd">public</span> <span class="kd">unowned</span> <span class="n">Object</span> <span class="n">get_unowned_ref</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">o</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Для виклику цього методу, щоб отримати посилання на повернутий об'єкт, потрібно очікувати отримання слабкої посилання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">unowned</span> <span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">get_unowned_ref</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Причина цього, здавалося б, складного прикладу через концепцію власності.</p></div>
<div class="paragraph"><p>Якщо <code>Object o</code> не зберігався у класі, тоді, коли метод <code>get_unowned_ref</code> повернувся, <code>o</code> стане нічийним (тобто на нього не було б посилань). Якби це було так, об’єкт буде видалено, і метод ніколи не повертав дійсне посилання.</p></div>
<div class="paragraph"><p>Якщо значення повернення не було визначено як <code>unowned</code>, право власності перейшло б до коду виклику. Однак код виклику очікує <code>unowned</code> посилання, яке не може отримати право власності.</p></div>
<div class="paragraph"><p>Якщо код виклику записаний як</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Object</span> <span class="n">o</span> <span class="o">=</span> <span class="n">get_unowned_ref</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala намагатиметься отримати посилання або копію екземпляра, на яку вказує <code>unowned</code> посилання.</p></div>
</div>
<div class="sect3">
<h4 id="____7">Власності на властивості</h4>
<div class="paragraph"><p>На відміну від звичайних методів властивості завжди мають <code>unowned</code> значення повернення. Це означає, що ви не можете повернути новий об’єкт, створений у методі <code>get</code>. Це також означає, що ви не можете використовувати <code>owned</code> повернене значення з виклику методу. Дещо дратівливий факт пояснюється тим, що значення властивості належить об'єкту, який має цю власність. Виклик для отримання цього значення властивості не повинен красти або відтворювати (шляхом дублювання або збільшення опорного числа) значення з боку об'єкта.</p></div>
<div class="paragraph"><p>Наступний приклад призведе до помилки компіляції</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="n">Object</span> <span class="n">property</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
<span class="c1">// НЕВІРНО: властивість повертає unowned посилання,</span>
<span class="c1">// новостворений об’єкт буде видалено, коли</span>
<span class="c1">// область геттера закінчує виклик</span>
<span class="c1">// геттера матиме отримання недійсного посилання</span>
<span class="c1">// до видаленого об’єкта.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>і також не можна робити цього</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">string</span> <span class="n">property</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getter_method</span><span class="p">();</span>
<span class="c1">// НЕВІРНО: з тієї ж причини вище.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kt">string</span> <span class="n">getter_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;some text&quot;</span><span class="p">;</span>
<span class="c1">// &quot;some text&quot; дублюється і повертається в цей момент.</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>з іншого боку, це цілком добре</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kt">string</span> <span class="n">property</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">getter_method</span><span class="p">();</span>
<span class="c1">// ГАРНО: getter_method повертає unowned значення</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">unowned</span> <span class="kt">string</span> <span class="n">getter_method</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;some text&quot;</span><span class="p">;</span>
<span class="c1">// Не турбуйтеся, що текст не присвоєний жодній сильній змінній.</span>
<span class="c1">// Літеральні рядки у Vala завжди належать самому програмному модулю,</span>
<span class="c1">// і існують до тих пір, поки модуль знаходиться в пам&#39;яті</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Модифікатор <code>unowned</code> можна використовувати для автоматичного зберігання сховища власності. Це означає</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">unowned</span> <span class="n">Object</span> <span class="n">property</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="kd">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>тотожне</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">private</span> <span class="kd">unowned</span> <span class="n">Object</span> <span class="n">_property</span><span class="p">;</span>

<span class="kd">public</span> <span class="n">Object</span> <span class="n">property</span> <span class="p">{</span>
    <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_property</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ключове слово <code>owned</code> може бути використане для конкретного запиту властивості для повернення власного посилання на значення, внаслідок чого значення властивості відтворюється на стороні об'єкта. Подумайте двічі, перш ніж додавати ключове слово <code>owned</code>. Це властивість чи просто метод <code>get_xxx</code>? Також можуть виникнути проблеми у вашому дизайні. У будь-якому разі наступний код - це коректний сегмент,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">owned</span> <span class="n">Object</span> <span class="n">property</span> <span class="p">{</span> <span class="kd">owned</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span> <span class="p">}</span> <span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Unowned</code> посилання грають схожу роль на покажчики, описані раніше. Однак вони набагато простіші у використанні, ніж покажчики, оскільки їх можна легко перетворити на звичайні посилання. Однак в цілому вони не повинні широко використовуватися в програмах, якщо ви не знаєте, що робите.</p></div>
</div>
<div class="sect3">
<h4 id="___24">Передача власності</h4>
<div class="paragraph"><p>Ключове слово <code>owned</code> використовується для передачі права власності.</p></div>
<div class="paragraph"><p>Як префікс типу параметра він означає, що право власності на об'єкт передається в цей контекст коду.</p></div>
<div class="paragraph"><p>Як оператор перетворення типів, його можна використовувати, щоб уникнути дублювання нереференційних класів підрахунку, що, як правило, у Vala неможливо. Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Foo</span> <span class="n">foo</span> <span class="o">=</span> <span class="p">(</span><span class="kd">owned</span><span class="p">)</span> <span class="n">bar</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Це означає, що <code>bar</code> буде встановлено на <code>null</code>, а <code>foo</code> успадковує посилання/право власності на посилання об'єкта <code>bar</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_____8">Списки аргументів змінної довжини</h3>
<div class="paragraph"><p>Vala підтримує списки аргументів змінної довжини у стилі C ("varargs") для методів. Вони оголошуються еліпсисом (<code>"..."</code>) у сигнатурі методу. Метод з <code>varargs</code> вимагає принаймні одного фіксованого аргументу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">method_with_varargs</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">l</span> <span class="o">=</span> <span class="n">va_list</span><span class="p">();</span>
    <span class="kt">string</span> <span class="n">s</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">arg</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">arg</span><span class="p">();</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>У цьому прикладі <code>х` є фіксованим аргументом для задоволення вимог. Список `varargs</code> ви отримуєте з <code>va_list()</code>. Потім ви можете отримати аргументи один за одним, викликаючи дженерік метод <code>arg&lt;T&gt;()</code> послідовно у цьому списку, причому <code>T</code> є типом, який слід інтерпретувати як аргумент. Якщо тип очевидний з контексту (як у нашому прикладі), тип виводиться автоматично, і ви можете просто викликати <code>arg()</code> без дженерік-аргументу типу.</p></div>
<div class="paragraph"><p>Цей приклад аналізує довільну кількість пар аргументів <code>string?</code>-<code>double</code>  :</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">method_with_varargs</span><span class="p">(</span><span class="kt">int</span> <span class="n">fixed</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">l</span> <span class="o">=</span> <span class="n">va_list</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">string</span><span class="o">?</span> <span class="n">key</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">arg</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">==</span> <span class="nb">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>  <span class="c1">// end of the list</span>
        <span class="p">}</span>
        <span class="kt">double</span> <span class="n">val</span> <span class="o">=</span> <span class="n">l</span><span class="p">.</span><span class="n">arg</span><span class="p">();</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s: %g</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">method_with_varargs</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s">&quot;baz&quot;</span><span class="p">,</span> <span class="mf">0.32</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Він перевіряє на <code>null</code> як на орієнтир, щоб визнати кінець списку <code>varargs</code>. Vala завжди неявно передає <code>null</code> як останній аргумент виклику методу <code>varargs</code>.</p></div>
<div class="paragraph"><p><code>Varargs</code> мають серйозний недолік, про який слід пам’ятати: вони не є безпечними по типу. Компілятор не може сказати вам, передаєте ви методу аргументи правильного типу чи ні. Ось чому ви повинні розглянути можливість використання <code>varargs</code> лише у випадку, коли у вас є вагомі причини, наприклад: надання зручності для програмістів C за допомогою вашої бібліотеки Vala, прив’язуючи функцію C. Часто аргумент масиву є кращим вибором.</p></div>
<div class="paragraph"><p>Поширений зразок з <code>varargs</code> - це очікувати чергування пар рядків-значень як аргументів, що зазвичай означає властивість <code>gobject</code> - значення. У цьому випадку ви можете замість цього записати властивість: значення, напр .:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">actor</span><span class="p">.</span><span class="n">animate</span> <span class="p">(</span><span class="n">AnimationMode</span><span class="p">.</span><span class="n">EASE_OUT_BOUNCE</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="n">x</span><span class="o">:</span> <span class="mf">100.0</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="mf">200.0</span><span class="p">,</span> <span class="n">rotation_angle_z</span><span class="o">:</span> <span class="mf">500.0</span><span class="p">,</span> <span class="n">opacity</span><span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">actor</span><span class="p">.</span><span class="n">animate</span> <span class="p">(</span><span class="n">AnimationMode</span><span class="p">.</span><span class="n">EASE_OUT_BOUNCE</span><span class="p">,</span> <span class="mi">3000</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="s">&quot;y&quot;</span><span class="p">,</span> <span class="mf">200.0</span><span class="p">,</span> <span class="s">&quot;rotation-angle-z&quot;</span><span class="p">,</span> <span class="mf">500.0</span><span class="p">,</span> <span class="s">&quot;opacity&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__29">Покажчики</h3>
<div class="paragraph"><p>Покажчики - це спосіб Vala, що дозволяє вручну керувати пам'яттю. Зазвичай, коли ви створюєте екземпляр типу, ви отримуєте посилання на нього, і Vala подбає про знищення екземпляра, коли на нього не залишиться більше посилань. Запросивши замість цього вказівник на екземпляр, ви берете на себе відповідальність за знищення екземпляра, коли він більше не потрібен, і, отже, отримуєте більший контроль над тим, скільки пам'яті використовується.</p></div>
<div class="paragraph"><p>Ця функціональність не обов'язково потрібна більшу частину часу, оскільки сучасні комп'ютери, як правило, досить швидкі для обліку підрахунку посилань, і мають достатню кількість пам'яті, що трохи неефективності не завадить. Випадки, коли ви можете вдатися до ручного управління пам'яттю, такі:</p></div>
<div class="ulist"><ul>
<li>
<p>
Коли ви конкретно хочете оптимізувати частину програми, і <code>unowned</code> посилань недостатньо.
</p>
</li>
<li>
<p>
Коли ви маєте справу із зовнішньою бібліотекою, яка не реалізує підрахунок посилань для управління пам'яттю (можливо, це означає, що вона не заснована на <code>gobject</code>).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Щоб створити екземпляр типу та отримати вказівник на нього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Object</span><span class="o">*</span> <span class="n">o</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>
</pre></div></div></div>
<div class="paragraph"><p>Для доступу до членів цього примірника:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">o</span><span class="o">-&gt;</span><span class="n">method_1</span><span class="p">();</span>
<span class="n">o</span><span class="o">-&gt;</span><span class="n">data_1</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб звільнити пам'ять по показчику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">delete</span> <span class="n">o</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Vala також підтримує оператори адреси (<code>&amp;</code>) та розіменування (<code>*</code>), відомі з C:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">i_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">;</span>    <span class="c1">// отримати адресу</span>
<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">i_ptr</span><span class="p">;</span>     <span class="c1">// розіменування</span>
</pre></div></div></div>
<div class="paragraph"><p>Поведінка трохи відрізняється від типів посилань. Ви можете опустити оператор адреси та розіменування при призначенні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Foo</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Foo</span><span class="p">();</span>
<span class="n">Foo</span><span class="o">*</span> <span class="n">f_ptr</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>    <span class="c1">// отримати адресу</span>
<span class="n">Foo</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f_ptr</span><span class="p">;</span>     <span class="c1">// розіменування</span>

<span class="kd">unowned</span> <span class="n">Foo</span> <span class="n">f_weak</span> <span class="o">=</span> <span class="n">f</span><span class="p">;</span>  <span class="c1">// еквівалент другого рядка</span>
</pre></div></div></div>
<div class="paragraph"><p>Використання покажчиків референсного типу еквівалентно використанню <code>unowned</code> посилань.</p></div>
</div>
<div class="sect2">
<h3 id="____8">Необ'єктні класи</h3>
<div class="paragraph"><p>Класи, визначені як такі, що не походять з <code>GLib.Object</code>, трактуються як окремий випадок. Вони отримані безпосередньо з системи типів GLib, і тому набагато легші за вагою. У більш пізньому компіляторі Vala можна також реалізувати інтерфейси, сигнали та властивості з цими класами.</p></div>
<div class="paragraph"><p>Один очевидний випадок використання цих <code>non-Object</code> класів залишається у прив'язках <code>GLib</code>. Оскільки <code>GLib</code> знаходиться на нижчому рівні, ніж <code>GObject</code>, більшість класів, визначених у зв'язуванні, є такого роду. Також, як згадувалося раніше, менша вага класів, що не є об'єктами, робить їх корисними у багатьох практичних ситуаціях (наприклад, сам компілятор Vala). Однак детальне використання класів, що не належать до об'єктів, виходять за межі цього підручника. Майте на увазі, що ці класи принципово відрізняються від структур.</p></div>
</div>
<div class="sect2">
<h3 id="__d_bus">Інтеграція D-Bus</h3>
<div class="paragraph"><p>D-Bus тісно інтегрований у мову і ніколи не був простішим, ніж з Vala.</p></div>
<div class="paragraph"><p>To export a custom class as a D-Bus service you just need to annotate it with the DBus code attribute and register an instance of this class with your local D-Bus session.
Щоб експортувати спеціальний клас як послугу D-Bus, вам просто потрібно анотувати його атрибутом коду DBus та зареєструвати екземпляр цього класу в локальному сеансі D-Bus.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">DBus</span><span class="p">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;org.example.DemoService&quot;</span><span class="p">)]</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DemoService</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
<span class="cm">/* Приватне поле, не експортується через D-Bus */</span>
    <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>

<span class="cm">/* Загальнодоступне поле, не експортується через D-Bus */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>

<span class="cm">/* Публічеа власність, експортована через D-Bus */</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">something</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="cm">/* Загальнодоступний сигнал, експортований через D-Bus</span>
<span class="cm">*  Може випромінюватися на стороні сервера і може</span>
<span class="cm">*  бути підключено до клієнтської сторони.</span>
<span class="cm">*/</span>
    <span class="kd">public</span> <span class="kd">signal</span> <span class="kt">void</span> <span class="n">sig1</span><span class="p">();</span>

<span class="cm">/* Публічний метод, експортований через D-Bus */</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">some_method</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;heureka! counter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
        <span class="n">sig1</span><span class="p">();</span>  <span class="c1">// подати сигнал</span>
    <span class="p">}</span>

<span class="cm">/* Публічний метод, експортований через D-Bus та показує відправника, хто це</span>
<span class="cm">*  викликає метод (не експортується в інтерфейс D-Bus)</span>
<span class="cm">*/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="n">some_method_sender</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">,</span> <span class="n">GLib</span><span class="p">.</span><span class="n">BusName</span> <span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">counter</span><span class="o">++</span><span class="p">;</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;heureka! counter = %d, &#39;%s&#39; message from sender %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
                      <span class="n">counter</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">sender</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зареєструйте примірник служби та запустіть основний цикл:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">on_bus_aquired</span> <span class="p">(</span><span class="n">DBusConnection</span> <span class="n">conn</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
<span class="c1">// запустити сервіс та зареєструвати його як об’єкт dbus</span>
        <span class="kd">var</span> <span class="n">service</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DemoService</span><span class="p">();</span>
        <span class="n">conn</span><span class="p">.</span><span class="n">register_object</span> <span class="p">(</span><span class="s">&quot;/org/example/demo&quot;</span><span class="p">,</span> <span class="n">service</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOError</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">stderr</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Could not register service: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span> <span class="p">()</span> <span class="p">{</span>
<span class="c1">// спроба зареєструвати ім’я служби в шині сеансу</span>
    <span class="n">Bus</span><span class="p">.</span><span class="n">own_name</span> <span class="p">(</span><span class="n">BusType</span><span class="p">.</span><span class="n">SESSION</span><span class="p">,</span> <span class="s">&quot;org.example.DemoService&quot;</span><span class="p">,</span> <span class="cm">/* ім&#39;я реєстрації */</span>
                  <span class="n">BusNameOwnerFlags</span><span class="p">.</span><span class="n">NONE</span><span class="p">,</span> <span class="cm">/* прапорці */</span>
                  <span class="n">on_bus_aquired</span><span class="p">,</span> <span class="cm">/* колбек вдалої реєстрації */</span>
                  <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{},</span> <span class="cm">/* колбек вдалої реєстрації імені */</span>
                  <span class="p">()</span> <span class="o">=&gt;</span> <span class="n">stderr</span><span class="p">.</span><span class="n">printf</span> <span class="p">(</span><span class="s">&quot;Could not acquire name</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">));</span>
                                                     <span class="cm">/* колбек втрати імені */</span>

    <span class="c1">// запуск головного циклу</span>
    <span class="k">new</span> <span class="n">MainLoop</span> <span class="p">().</span><span class="n">run</span> <span class="p">();</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви повинні зібрати цей приклад з пакетом <code>gio-2.0</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac --pkg gio-2.0 dbus-demo-service.vala
$ ./dbus-demo-service
</pre></div></div></div>
<div class="paragraph"><p>Усі імена членів автоматично додаються до імені D-Bus CamelCase від імені D-Bus, що визначає назву D-Bus. Експортований інтерфейс D-Bus у цьому прикладі матиме властивість <code>Something</code>, сигнал <code>Sig1</code> та метод <code>SomeMethod</code>. Ви можете відкрити нове вікно терміналу та викликати метод із командного рядка за допомогою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ dbus-send --type<span class="o">=</span>method_call                   <span class="se">\</span>
            --dest<span class="o">=</span>org.example.DemoService       <span class="se">\</span>
            /org/example/demo                    <span class="se">\</span>
            org.example.DemoService.SomeMethod
</pre></div></div></div>
<div class="paragraph"><p>або</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ dbus-send --type<span class="o">=</span>method_call                   <span class="se">\</span>
            --dest<span class="o">=</span>org.example.DemoService       <span class="se">\</span>
            /org/example/demo                    <span class="se">\</span>
            org.example.DemoService.SomeMethodSender <span class="se">\</span>
            string:<span class="s1">&#39;hello world&#39;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви також можете використовувати графічний налагоджувач D-Bus на зразок D-Feet для перегляду інтерфейсів D-Bus та методів виклику.</p></div>
<div class="paragraph"><p>Деякі вичерпні приклади: зразки клієнта DBus та вибірки сервера DBus</p></div>
</div>
<div class="sect2">
<h3 id="__30">Профілі</h3>
<div class="paragraph"><p>Vala підтримує декілька різних профілів:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>gobject (default)
posix
dova</code></pre>
</div></div>
<div class="paragraph"><p>Профіль визначає, які мовні функції доступні та від яких бібліотек залежатиме отриманий C-код.</p></div>
<div class="paragraph"><p>Щоб вибрати інший профіль, використовуйте перемикач <code>valac --profile</code>, наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>valac --profile<span class="o">=</span>posix somecode.vala
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___25">Експериментальні можливості</h2>
<div class="sectionbody">
<div class="paragraph"><p>Деякі особливості Vala експериментальні. Це означає, що вони не пройшли повну перевірку і можуть зазнати змін у майбутніх версіях.</p></div>
<div class="sect2">
<h3 id="____9">Зціплені реляційні вирази</h3>
<div class="paragraph"><p>Ця функція дозволяє записувати складні реляційні вирази на зразок</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&amp;&amp;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// робити щось</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>більш природним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mi">255</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// робити щось</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____10">Літерали регулярних виразів</h3>
<div class="paragraph"><p>Регулярні вирази - це потужна техніка зіставлення шаблонів у рядках. Vala має експериментальну підтримку літералів регулярного виразу (<code>/ regex /</code>). Приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">email</span> <span class="o">=</span> <span class="s">&quot;tux@kernel.org&quot;</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="o">/^</span><span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">Z0</span><span class="o">-</span><span class="mf">9.</span><span class="n">_</span><span class="o">%+-</span><span class="p">]</span><span class="o">+</span><span class="err">@</span><span class="p">[</span><span class="n">A</span><span class="o">-</span><span class="n">Z0</span><span class="o">-</span><span class="mf">9.</span><span class="o">-</span><span class="p">]</span><span class="o">+</span><span class="err">\</span><span class="p">.[</span><span class="n">A</span><span class="o">-</span><span class="n">Z</span><span class="p">]{</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span><span class="err">$</span><span class="o">/</span><span class="n">i</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">email</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Valid email address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Заключе <code>i</code> робить вираз нечутливим до реєстру. Ви можете зберігати регулярний вираз у змінній типу <code>Regex</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Regex</span> <span class="n">regex</span> <span class="o">=</span> <span class="o">/</span><span class="n">foo</span><span class="o">/</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Приклад виразу заміни:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="n">r</span> <span class="o">=</span> <span class="o">/</span><span class="p">(</span><span class="n">foo</span><span class="o">|</span><span class="n">bar</span><span class="o">|</span><span class="n">cow</span><span class="p">)</span><span class="o">/</span><span class="p">;</span>
<span class="kd">var</span> <span class="n">o</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">replace</span> <span class="p">(</span><span class="s">&quot;this foo is great&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;thing&quot;</span><span class="p">);</span>
<span class="n">print</span> <span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">o</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Наступні символи можуть бути використані:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>i</code>, літери в шаблоні збігаються як з великої, так і малої літери
</p>
</li>
<li>
<p>
<code>m</code>, конструкції "початок рядка" і "кінець рядка" збігаються безпосередньо після будь-якого нового рядка в рядку відповідно, а також на самому початку і в кінці.
</p>
</li>
<li>
<p>
<code>s</code>, точковий метасимвол, у шаблоні збігаються всі символи, включаючи нові рядки. Без нього виключаються нові рядки.
</p>
</li>
<li>
<p>
<code>x</code>, символи даних пробілів у шаблоні повністю ігноруються, за винятком випадків, коли вони переходять або всередині класу символів.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="__non_null_">Суворий Non-Null режим</h3>
<div class="paragraph"><p>Якщо ви компілюєте свій код з <code>--enable-experimental-non-null</code>, компілятор Vala запуститься в суворому режимі перевірки ненульових типів і вважає, що кожен тип за замовчуванням не зводиться до нуля, якщо він явно не оголошений нульовим, позначаючи його знаком питання:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">Object</span> <span class="n">o1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span>  <span class="c1">// не nullable</span>
<span class="n">Object</span><span class="o">?</span> <span class="n">o2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Object</span><span class="p">();</span> <span class="c1">// nullable</span>
</pre></div></div></div>
<div class="paragraph"><p>The compiler will perform a static compile-time analysis to ensure that no nullable reference is assigned to a non-nullable reference, e.g. this won&#8217;t be possible:
Компілятор виконає статичний аналіз часу компіляції, щоб переконатися, що жодне зведене посилання не присвоюється ненульовій посиланню, наприклад. це неможливо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">o1</span> <span class="o">=</span> <span class="n">o2</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>o2</code> може бути нульовим, а <code>o1</code> оголошено ненульовим, тому це призначення заборонено. Однак ви Лможете змінити цю поведінку з явним ненульовим складом, якщо ви впевнені, що <code>o2</code> не є нульовим:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">o1</span> <span class="o">=</span> <span class="p">(</span><span class="o">!</span><span class="p">)</span> <span class="n">o2</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Суворий ненульовий режим допомагає уникнути небажаних помилок нульового перенаправлення. Ця особливість набула б повного потенціалу, якби нульовість усіх типів повернення у прив’язках була позначена правильно, що в даний час не завжди так.</p></div>
</div>
<div class="sect2">
<h3 id="__31">Бібліотеки</h3>
<div class="paragraph"><p>На системному рівні бібліотека Vala - це саме бібліотека С, тому використовуються ті самі інструменти. Для того, щоб зробити процес простішим і щоб компілятор Vala міг зрозуміти процес, тоді є додатковий рівень конкретної інформації Vala.</p></div>
<div class="paragraph"><p>Отже, "бібліотека Vala" є системною частиною:</p></div>
<div class="ulist"><ul>
<li>
<p>
Системна бібліотека (наприклад, libgee.so)
</p>
</li>
<li>
<p>
Запис у форматі <code>pkg-config</code> (наприклад, gee-1.0.pc)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Обидва вони встановлені у стандартних місцях. І конкретні файли Vala:</p></div>
<div class="ulist"><ul>
<li>
<p>
Файл VAPI (наприклад, gee-1.0.vapi)
</p>
</li>
<li>
<p>
Опціональний файл залежності (наприклад, gee-1.0.deps)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці файли будуть пояснені пізніше в цьому розділі. Слід зазначити, що імена бібліотек у файлах конкретного Vala такі ж, як у файлах pkg-config.</p></div>
</div>
<div class="sect2">
<h3 id="___26">Використання бібліотек</h3>
<div class="paragraph"><p>Використання бібліотеки у Vala значною мірою автоматизоване, якщо ви використовуєте компілятор <code>valac</code>. Файли бібліотеки Vala складають те, що називають пакетом. Ви повідомляєте компілятору, що пакет потрібен вашій програмі так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">valac</span> <span class="o">--</span><span class="n">pkg</span> <span class="n">gee</span><span class="o">-</span><span class="mf">1.0</span> <span class="n">test</span><span class="p">.</span><span class="n">vala</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця команда означає, що ваша програма може використовувати будь-яке визначення у файлі <code>gee-1.0.vapi</code>, а також будь-яке в будь-якому з пакетів, від яких залежить <code>gee-1.0</code>. Ці залежності були б занесені до <code>gee-1.0.deps</code>, якби вони були. У цьому прикладі <code>valac</code> налаштований так, щоб будувати весь шлях до двійкового образу, і тому буде включати інформацію з <code>pkg-config</code> для зв'язку правильних бібліотек. Ось чому імена <code>pkg-config</code> також використовуються для імен пакетів Vala.</p></div>
<div class="paragraph"><p>Пакети зазвичай використовуються з просторами імен, але вони технічно не пов'язані. Це означає, що незважаючи на те, що ваша програма побудована з посиланням на пакет, ви все одно повинні включати необхідні, використовуючи оператори у кожному файлі, як це доречно, або ж використовувати повністю кваліфіковані імена всіх символів.</p></div>
<div class="paragraph"><p>Також можна розглядати локальну бібліотеку (таку, яка не встановлена) як пакет. Для порівняння, Vala сама використовує внутрішню версію Gee. Коли вбудований <code>valac</code>, він створює файл VAPI цієї внутрішньої бібліотеки і використовує його приблизно так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">valac</span> <span class="o">--</span><span class="n">vapidir</span> <span class="p">..</span><span class="o">/</span><span class="n">gee</span> <span class="o">--</span><span class="n">pkg</span> <span class="n">gee</span> <span class="p">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Детальніше про те, як створити цю бібліотеку, див. У наступному розділі чи прикладі.</p></div>
</div>
<div class="sect2">
<h3 id="___27">Створення бібліотеки</h3>
<div class="sect3">
<h4 id="__autotools">Використання Autotools</h4>
<div class="paragraph"><p>Можна використовувати Autotools для створення бібліотеки, написаної у Vala. Бібліотека створюється за допомогою коду С, згенерованого компілятором Vala, пов'язаного та встановленого як будь-яка інша бібліотека. Тоді вам потрібно сказати, які файли C повинні бути використані для створення бібліотеки, і які з них повинні бути розповсюджуваними, дозволяючи іншим складати тарбол без Vala, використовуючи стандартні команди Autotools: <code>configure</code>, <code>make</code> і <code>make install</code>.</p></div>
</div>
<div class="sect3">
<h4 id="__32">Приклад</h4>
<div class="paragraph"><p>Цей приклад взятий з останніх доповнень <code>GXml</code>. <code>GXmlDom</code> - це бібліотека, спрямована на заміну <code>libxml2</code> на основі <code>GObject</code>; написано у Vala і спочатку використовувалося для використання WAF для побудови.</p></div>
<div class="paragraph"><p><code>valac</code> можна використовувати для створення коду С та заголовків із джерел Vala. У цей час можливо генерувати <code>GObjectIntrospection</code> і файл VAPI також з джерел <code>vala</code>.</p></div>
<div class="paragraph"><p><code>gxml.vala.stamp</code> використовується як джерело коду для нашої бібліотеки.</p></div>
<div class="paragraph"><p>Is important to add --pkg switches in order to valac to success and set all CFLAGS and LIBS required by the C library to compile and link against.
Важливо додати <code>--pkg</code> перемикачі, щоб домогтися успіху та встановити всі CFLAGS та LIBS, необхідні бібліотеці С для компіляції та зв'язування.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Toggle line numbers
   1 NULL =
   2
   3
   4 AM_CPPFLAGS = \
   5         -DPACKAGE_LOCALE_DIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
   6         -DPACKAGE_SRC_DIR=\""$(srcdir)"\" \
   7         -DPACKAGE_DATA_DIR=\""$(datadir)"\"
   8
   9 BUILT_SOURCES = gxml.vala.stamp
  10 CLEANFILES = gxml.vala.stamp
  11
  12 AM_CFLAGS =\
  13          -Wall\
  14          -g \
  15         $(GLIB_CFLAGS) \
  16         $(LIBXML_CFLAGS) \
  17         $(GIO_CFLAGS) \
  18         $(GEE_CFLAGS) \
  19         $(VALA_CFLAGS) \
  20         $(NULL)
  21
  22 lib_LTLIBRARIES = libgxml.la
  23
  24 VALAFLAGS = \
  25     $(top_srcdir)/vapi/config.vapi \
  26     --vapidir=$(top_srcdir)/vapi \
  27     --pkg libxml-2.0 \
  28     --pkg gee-1.0 \
  29     --pkg gobject-2.0 \
  30     --pkg gio-2.0 \
  31     $(NULL)
  32
  33 libgxml_la_VALASOURCES = \
  34         Attr.vala \
  35         BackedNode.vala \
  36         CDATASection.vala \
  37         CharacterData.vala \
  38         Comment.vala \
  39         Document.vala \
  40         DocumentFragment.vala \
  41         DocumentType.vala \
  42         DomError.vala \
  43         Element.vala \
  44         Entity.vala \
  45         EntityReference.vala \
  46         Implementation.vala \
  47         NamespaceAttr.vala \
  48         NodeList.vala \
  49         NodeType.vala \
  50         Notation.vala \
  51         ProcessingInstruction.vala \
  52         Text.vala \
  53         XNode.vala \
  54         $(NULL)
  55
  56 libgxml_la_SOURCES = \
  57         gxml.vala.stamp \
  58         $(libgxml_la_VALASOURCES:.vala=.c) \
  59         $(NULL)
  60
  61 # Generate C code and headers, including GObject Introspection GIR files and VAPI file
  62 gxml-1.0.vapi gxml.vala.stamp GXml-1.0.gir: $(libgxml_la_VALASOURCES)
  63         $(VALA_COMPILER) $(VALAFLAGS) -C -H $(top_builddir)/gxml/gxml-dom.h --gir=GXmlDom-1.0.gir  --library gxmldom-1.0 $^
  64         @touch $@
  65
  66
  67 # Library configuration
  68 libgxml_la_LDFLAGS =
  69
  70 libgxml_la_LIBADD = \
  71         $(GLIB_LIBS) \
  72         $(LIBXML_LIBS) \
  73         $(GIO_LIBS) \
  74         $(GEE_LIBS) \
  75         $(VALA_LIBS) \
  76         $(NULL)
  77
  78 include_HEADERS = \
  79         gxml.h \
  80         $(NULL)
  81
  82
  83 pkgconfigdir = $(libdir)/pkgconfig
  84 pkgconfig_DATA = libgxml-1.0.pc
  85
  86 gxmlincludedir=$(includedir)/libgxml-1.0/gxml
  87 gxmlinclude_HEADERS= gxml-dom.h
  88
  89 # GObject Introspection
  90
  91 if ENABLE_GI_SYSTEM_INSTALL
  92 girdir = $(INTROSPECTION_GIRDIR)
  93 typelibsdir = $(INTROSPECTION_TYPELIBDIR)
  94 else
  95 girdir = $(datadir)/gir-1.0
  96 typelibsdir = $(libdir)/girepository-1.0
  97 endif
  98
  99 # GIR files are generated automatically by Valac so is not necessary to scan source code to generate it
 100 INTROSPECTION_GIRS =
 101 INTROSPECTION_GIRS += GXmlDom-1.0.gir
 102 INTROSPECTION_COMPILER_ARGS = \
 103     --includedir=. \
 104     --includedir=$(top_builddir)/gxml
 105
 106 GXmlDom-1.0.typelib: $(INTROSPECTION_GIRS)
 107         $(INTROSPECTION_COMPILER) $(INTROSPECTION_COMPILER_ARGS)  $&lt; -o $@
 108
 109 gir_DATA = $(INTROSPECTION_GIRS)
 110 typelibs_DATA = GXmlDom-1.0.typelib
 111
 112 vapidir = $(VALA_VAPIDIR)
 113 vapi_DATA=gxmldom-1.0.vapi
 114
 115 CLEANFILES += $(INTROSPECTION_GIRS) $(typelibs_DATA) gxml-1.0.vapi
 116
 117 EXTRA_DIST = \
 118         libgxml-1.0.pc.in \
 119         $(libgxml_la_VALASOURCES) \
 120         $(typelibs_DATA) \
 121         $(INTROSPECTION_GIRS) \
 122         gxml.vala.stamp</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="________">Компіляція та зв'язування за допомогою командного рядка</h4>
<div class="paragraph"><p>Vala ще не здатний безпосередньо створювати динамічні або статичні бібліотеки. Щоб створити бібліотеку, перейдіть до перемикача <code>-c</code> (лише компілювати) та зв’яжіть файли об'єктів із улюбленим лінкером, тобто <code>libtool</code> або <code>ar</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">valac</span> <span class="o">-</span><span class="n">c</span> <span class="p">...(</span><span class="n">source</span> <span class="n">files</span><span class="p">)</span>
<span class="err">$</span> <span class="n">ar</span> <span class="n">cx</span> <span class="p">...(</span><span class="n">object</span> <span class="n">files</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або шляхом складання проміжного коду С за допомогою gcc</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="err">$</span> <span class="n">valac</span> <span class="o">-</span><span class="n">C</span> <span class="p">...(</span><span class="n">source</span> <span class="n">files</span><span class="p">)</span>
<span class="err">$</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">my</span><span class="o">-</span><span class="n">best</span><span class="o">-</span><span class="n">library</span><span class="p">.</span><span class="n">so</span> <span class="o">--</span><span class="n">shared</span> <span class="o">-</span><span class="n">fPIC</span> <span class="p">...(</span><span class="n">compiled</span> <span class="n">C</span> <span class="n">code</span> <span class="n">files</span><span class="p">)...</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="__33">Приклад</h4>
<div class="paragraph"><p>Далі наведено приклад того, як написати просту бібліотеку у Vala, а також скласти та перевірити її локально, не встановлюючи її.</p></div>
<div class="paragraph"><p>Збережіть наступний код у файлі <code>test.vala</code>. Це власне код бібліотеки, що містить функції, які ми хочемо викликати з нашої основної програми.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyLib</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="n">hello</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World, MyLib</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуйте наступну команду для створення файлів <code>test.c</code>, <code>test.h</code> та <code>test.vapi</code>. Це С версії бібліотеки, що підлягає компіляції, та файл VAPI, що представляє публічний інтерфейс бібліотеки.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ valac -C -H test.h --library test test.vala --basedir ./</code></pre>
</div></div>
<div class="paragraph"><p>Тепер складіть бібліотеку:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ gcc --shared -fPIC -o libtest.so $(pkg-config --cflags --libs gobject-2.0) test.c</code></pre>
</div></div>
<div class="paragraph"><p>Збережіть наступний код у файлі під назвою <code>hello.vala</code>. Це код, який використовуватиме створена нами бібліотека.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MyLib</span><span class="p">();</span>
    <span class="n">test</span><span class="p">.</span><span class="n">hello</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;The sum of %d and %d is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">test</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер компілюємо код програми, повідомляючи компілятору, що ми хочемо зв’язатись із створеною нами бібліотекою.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ valac -X -I. -X -L. -X -ltest -o hello hello.vala test.vapi --basedir ./</code></pre>
</div></div>
<div class="paragraph"><p>Зараз ми можемо запустити програму. Ця команда зазначає, що будь-які необхідні бібліотеки будуть знайдені в поточному каталозі.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ LD_LIBRARY_PATH=$PWD ./hello</code></pre>
</div></div>
<div class="paragraph"><p>Вихід програми повинен бути:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Hello World, MyLib
The sum of 4 and 5 is 9</code></pre>
</div></div>
<div class="paragraph"><p>Ви також можете створити файл GIR <code>GObjectIntrospection</code> для своєї бібліотеки за допомогою параметра <code>--gir</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>valac -C test.vala --library test --gir Test-1.0.gir</code></pre>
</div></div>
<div class="paragraph"><p>Файли GIR - це XML-описи API.</p></div>
</div>
<div class="sect3">
<h4 id="______vapi">Пов'язування бібліотек з файлами VAPI</h4>
<div class="paragraph"><p>Файли VAPI - це описи публічного інтерфейсу зовнішніх бібліотек Vala. Коли бібліотека записується у Vala, цей файл створюється компілятором Vala, і в основному це об'єднання всіх публічних визначень з усіх вихідних файлів Vala. Для бібліотеки, написаної на C, файл VAPI стає складнішим, особливо якщо конвенції про іменування бібліотеки не відповідають конвенції GLib. У цьому випадку файл VAPI міститиме багато приміток, що описують, як стандартизований інтерфейс Vala перетворюється на версію C.</p></div>
<div class="paragraph"><p>Цей процес створення в цілому становить три етапи,</p></div>
<div class="ulist"><ul>
<li>
<p>
Запуск <code>vala-gen-introspect</code> для вилучення метаданих з бібліотеки С.
</p>
</li>
<li>
<p>
Додавання додаткових метаданих для стандартизації інтерфейсу або внесення різних інших змін.
</p>
</li>
<li>
<p>
Генерування файлу VAPI з вищезазначених джерел за допомогою <code>vapigen</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Конкретні вказівки щодо створення зв'язків містяться у навчальному посібнику з прив'язки до Vala.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__34">Інструменти</h3>
<div class="paragraph"><p>Дистрибутив Vala включає кілька програм, які допоможуть вам створити та працювати з програмами Vala. Докладніше про кожен інструмент див. На сторінках man.</p></div>
<div class="paragraph"><p><code>valac</code> - компілятор Vala. Його основна функція полягає в перетворенні коду Vala в компільований код C, хоча він може також автоматизувати весь проект збірки та зв’язку в простих випадках.</p></div>
<div class="paragraph"><p>Простий чохол для використання:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ valac -o appname --pkg gee-1.0 file_name_1.vala file_name_2.vala</code></pre>
</div></div>
<div class="paragraph"><p>Перемикач <code>-o</code> вимагає створення об’єктного файлу, а не просто виведення вихідних файлів C. Опція <code>--pkg</code> говорить, що для цієї збірки потрібна інформація з пакета <code>gee-1.0</code>. Вам не потрібно вказувати деталі про те, до яких бібліотек слід зв’язатись, пакет містить цю інформацію внутрішньо. Нарешті, наведено список вихідних файлів. Якщо вам потрібен більш складний процес збирання, використовуйте перемикач <code>-C</code>, щоб генерувати файли C замість бінарних, і продовжуйте процес вручну або через скрипт.</p></div>
<div class="paragraph"><p><code>vapigen</code> - це інструмент для виготовлення прив'язок. Він створює файли VAPI з метаданих бібліотеки та будь-якої необхідної додаткової інформації. Дивіться також навчальний посібник щодо зв'язків з Vala.</p></div>
<div class="paragraph"><p><code>vala-gen-introspect</code> - це інструмент для отримання метеаформації про бібліотеки на основі <code>GObject</code>. В даний час кращим методом є використання <code>GObjectIntrospection</code> замість цього, оскільки <code>vapigen</code> може використовувати файли GIR безпосередньо. Дивіться також навчальний посібник щодо зв'язків з Vala.</p></div>
</div>
<div class="sect2">
<h3 id="__35">Техніки</h3>
<div class="sect3">
<h4 id="__36">Налагодження</h4>
<div class="paragraph"><p>Для демонстраційних цілей ми створимо програму-баг, навмисно використовуючи нульове посилання, що призведе до помилки сегментації:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kd">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="n">Object</span> <span class="p">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="n">field</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Foo</span><span class="o">?</span> <span class="n">foo</span> <span class="o">=</span> <span class="nb">null</span><span class="p">;</span>
    <span class="n">stdout</span><span class="p">.</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">.</span><span class="n">field</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac debug-demo.vala
$ ./debug-demo
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="___28">Помилка сегментації</h4>
<div class="paragraph"><p>То як ми налагоджуємо цю програму? Параметр командного рядка <em>-g</em> повідомляє компілятору Vala включати інформацію про рядок вихідного коду Vala у складений бінарний файл, <code>--save-temps</code> зберігає тимчасові вихідні файли C:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ valac -g --save-temps debug-demo.vala
</pre></div></div></div>
<div class="paragraph"><p>Vala programs can be debugged with the GNU Debugger gdb or one of its graphical front-ends, e.g. Nemiver.
Програми Vala можна налагодити за допомогою налагоджувача GNU <code>gdb</code> або одного з його графічних фронтендів, наприклад <code>Nemiver</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span> nemiver debug-demo
</pre></div></div></div>
<div class="paragraph"><p>Зразок сеансу <code>gdb</code>:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>$ gdb debug-demo
(gdb) run
Starting program: /home/valacoder/debug-demo

Program received signal SIGSEGV, Segmentation fault.
0x0804881f in _main () at debug-demo.vala:7
7           stdout.printf("%d\n", foo.field);
(gdb)</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="__glib">Використання GLib</h4>
<div class="paragraph"><p>GLib включає великий набір утиліт, включаючи обгортки для більшості стандартних функцій <code>libc</code> та багато іншого. Ці інструменти доступні на всіх платформах Vala, навіть тих, які не відповідають стандартам POSIX. Повний опис всього, що надає GLib, див. У довідковому посібнику GLib. Це посилання пов'язане з API C для GLib, але розробити, як перекласти на Vala, в основному дуже просто.</p></div>
<div class="paragraph"><p>Функції GLib доступні у Vala завдяки такій умові іменування:</p></div>
</div>
<div class="sect3">
<h4 id="__37">Приклад</h4>
<div class="listingblock">
<div class="content">
<pre><code>g_topic_foobar()

GLib.Topic.foobar()

GLib.Path.get_basename()</code></pre>
</div></div>
<div class="paragraph"><p>Типи GLib можна використовувати аналогічно:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>GLib.Foo foo = new GLib.Foo();
foo.bar();</code></pre>
</div></div>
<div class="paragraph"><p>API не ідентичне між C і Vala, але ці правила іменування повинні означати, що ви можете знайти потрібні функції у файлах GLib VAPI, що постачаються з Vala, і звідти знайти параметри. Цього, сподіваємось, буде достатньо, доки не вдасться створити більше документації Vala.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___29">Обробка файлів</h3>
<div class="paragraph"><p>Про гнучкі I/O файлів та обробку файлів див. Зразки GIO.</p></div>
<div class="paragraph"><p>Ви також можете використовувати FileUtils.get_contents для завантаження файлу в рядок.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">string</span> <span class="n">content</span><span class="p">;</span>
<span class="n">FileUtils</span><span class="p">.</span><span class="n">get_contents</span><span class="p">(</span><span class="s">&quot;file.vala&quot;</span><span class="p">,</span> <span class="k">out</span> <span class="n">content</span><span class="p">);</span>
</pre></div></div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-04-14 09:00:36 EEST
</div>
</div>
</body>
</html>
