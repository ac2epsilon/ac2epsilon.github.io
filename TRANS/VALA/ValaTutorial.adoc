include::headers.adoc[]

= Vala Туторіал 

== Вступ

Відмова від відповідальності: Vala - це постійно прогресуючий проект, і його функції можуть змінюватися. Я намагався, щоб цей підручник був якомога актуальнішим, але я не досконалий. Крім того, я не можу пообіцяти, що методи, які я пропоную, обов'язково є найкращими на практиці. Але знову, я спробую не відставати від цього.

=== Що таке Vala?

Vala - нова мова програмування, яка дозволяє використовувати сучасні методи програмування для запису програм, які працюють у бібліотеках виконання GNOME, зокрема `GLib` та `GObject`. Ця платформа з самого початку забезпечує дуже повне середовище програмування з такими функціями, як динамічна система типів та допоміжне управління пам’яттю. До Vala єдиними способами програмування для платформи було використання природного  машинного C API, який розкриває багато часто небажаних деталей. Або мовою високого рівня, яка має супутну віртуальну машину, як Python або мова Mono C#. Або, альтернативно, на C ++ через бібліотеку огортки.

Vala відрізняється від усіх цих інших прийомів тим, що генерує код C, який можна компілювати для виконання без додаткової бібліотеки підтримки поза платформою GNOME. Це має кілька наслідків, але найголовніше:

* Програми, написані на Vala, повинні мати схожу ефективність із програмами, написаними безпосередньо на С, при цьому писати та підтримувати їх легше та швидше.
* Додаток Vala не може робити нічого, чого не може зробити еквівалент C. У той час як Vala вводить багато мовних особливостей, недоступних на мові C, всі вони відображаються на C-конструкції, хоча вони часто є складними або витрачають занадто багато часу, щоб писати їх безпосередньо.

Таким чином, хоча Vala - це сучасна мова з усіма можливостями, яких ви очікували, вона отримує свою силу від існуючої платформи і повинна певним чином відповідати встановленим нею правилам.

=== Для кого цей підручник?

Цей підручник не буде заглиблюватися в основні практики програмування. Він лише коротко пояснить принципи об'єктно-орієнтованого програмування. Натомість зосередиться на тому, як Vala застосовує ці концепції. Таким чином, це буде корисно, якщо ви вже маєте досвід роботи з різними мовами програмування, хоча глибокі знання будь-якої конкретної мови не потрібні.

Vala має багато синтаксису від C#, але я постараюся уникати опису функцій з точки зору їх подібності чи відмінності з C# або Java, з метою зробити підручник більш доступним.

Корисним буда пристойне розуміння C. Хоча це не потрібно для розуміння Vala per se, важливо усвідомити, що програми Vala виконуються як C, і часто взаємодіють із бібліотеками С. Знання C, безумовно, полегшить глибше розуміння Vala. 

=== Домовленості

Код в тексті виглядатиме як `моноширинний`, командам буде передувати `$`. Крім цього, все повинно бути очевидним. Я схильний кодувати дуже явно, включаючи деяку інформацію, яка насправді може бути опущена. Я спробую пояснити, де деякі речі можна опустити, але це не означає, що я заохочую вас до цього.

У якийсь момент я додам посилання на документацію Vala, але це ще не можливо.

== Перша програма

На жаль передбачувано, але все ж:

[source,vala]
----
class Demo.HelloWorld : GLib.Object {
    public static int main(string[] args) {
        stdout.printf("Hello, World\n");
        return 0;
    }
}
----

Звичайно, це програма Vala `Hello World`. Я сподіваюся, що ви зможете розпізнати деякі її частини досить добре, але щоб бути ретельним, я перегляну код крок за кроком.

[source,vala]
----
class Demo.HelloWorld : GLib.Object {
----

Цей рядок вказує на початок визначення класу. Класи у Vala за концепцією дуже схожі на інші мови. Клас - це в основному тип об'єкта, з якого можуть бути створені екземпляри, що мають однакові властивості. Про реалізацію класових типів опікується бібліотека `gobject`, але детальна інформація про це не важлива для загального використання.

Важливо зазначити, що цей клас спеціально описаний як підклас `GLib.Object`. Це тому, що Vala допускає інші типи класів, але в більшості випадків це саме той тип, який ви хочете. Насправді, деякі мовні функції Vala доступні лише у тому випадку, якщо ваш клас походить від `GLib.Object`.

В інших частинах цього рядка показані простори імен та повністю кваліфіковані імена, хоча вони будуть пояснені пізніше.

[source,vala]
----
public static int main(string[] args) {
----

Це початок визначення методу. Метод - це функція, пов'язана з типом об'єкта, яка може бути виконана на об'єкті цього типу. Статичний метод означає, що метод можна викликати, не володіючи конкретним екземпляром типу. Той факт, що цей метод називається `main` і має певну сигнатуру, означає, що Vala визнає його як вхідну точку програми.

Метод `main` не повинен визначатися всередині класу. Однак якщо він визначений всередині класу, він повинен бути статичним. Не має значення, чи він `public` чи `private`. Тип повернення може бути `int` або `void`. З типом повернення `void` програма неявно завершиться з кодом виходу 0. Параметр масиву рядків, що містить аргументи командного рядка, необов'язковий.

[source,vala]
----
stdout.printf("Hello, World\n");
----

`stdout` - це об'єкт у просторі імен `GLib`, до якого Vala за потреби забезпечує доступ. Цей рядок доручає Vala виконати метод, який називається `printf` об'єкта `stdout`, з рядком привітання в якості аргумента. У Vala це завжди синтаксис, який ви використовуєте для виклику методу на об’єкті, або для доступу до даних об’єкта. `\n` - _ескейп послідовність_ нового рядка.

[source,vala]
----
return 0;
----

`return` означає повернути значення в точку виклику і припинити виконання методу `main`, що також припиняє виконання програми. Після цього повернене значення методу `main` сприймається як _код завершення_ програми.

Останні рядки просто закінчують визначення методу та класу.

=== Компіляція і виконання

Якщо припустити, що у вас встановлено Vala, то для компіляції та виконання цієї програми потрібно таке:

[source,bash]
----
$ valac hello.vala
$ ./hello
----

`valac` - компілятор Vala, який компілює ваш код Vala у двійковий. Отриманий двійковий файл матиме те саме ім'я, що і вихідний файл, і потім може бути безпосередньо виконаний на машині. Ви можете, напевно, здогадатися про результат.

== Основи

=== Файли та компіляція

Код Vala записується у файли з розширеннями `.vala`. Vala не нав'язує стільки структури, як такі мови, як Java - немає таких самих понять пакетів або файлів класів. Натомість структура визначається текстом всередині кожного файлу, описуючи логічне розташування коду завдяки такими конструкціями, як простори імен. Коли ви хочете компілювати код Vala, ви даєте компілятору список необхідних файлів, і Vala розбереться, як вони пасують разом.

Підсумок всього цього полягає в тому, що ви можете помістити стільки класів або функцій у файл, скільки хочете, навіть комбінуючи частини різних просторів імен разом. Це не обов'язково гарна ідея. Є певні умови, яких ви, мабуть, хочете дотримуватися. Хорошим прикладом того, як структурувати проект у Vala, є сам проект Vala.

Усі вихідні файли для того ж пакету подаються як параметри командного рядка до компілятора Vala `valac` разом із флагами компілятора. Це працює аналогічно тому, як компілюється вихідний код Java. Наприклад:

[source,bash]
----
$ valac compiler.vala --pkg libvala
----

буде виробляти двійковий файл на ім'я `compiler`, який зв'язується з пакунком `libvala`. Насправді саме так створюється компілятор `valac`!

Якщо ви хочете, щоб двійковий файл мав інше ім’я, або якщо ви передали компілятору кілька вихідних файлів, ви можете вказати ім’я результата явно, за допомогою перемикача `-o`:

[source,bash]
----
$ valac source1.vala source2.vala -o myprogram
$ ./myprogram
----

Якщо ви надасте `valac` перемикач `-C`, він не компілює вашу програму у двійковий файл. Натомість він виведе проміжний код C для кожного з ваших вихідних файлів Vala у відповідний вихідний файл C - у цьому випадку `source1.c` та `source2.c`. Якщо ви подивитесь на вміст цих файлів, то можна побачити, що програмування класу у Vala еквівалентно тому самому завданню на C, але набагато більш лаконічним. Ви також помітите, що цей клас динамічно реєструється в запущеній системі. Це хороший приклад потужності платформи GNOME, але, як я вже говорив раніше, вам не потрібно багато знати про це, щоб використовувати Vala.

Якщо ви хочете мати файл заголовка С для свого проекту, ви можете використовувати перемикач `-H`:

[source,bash]
----
$ valac hello.vala -C -H hello.h
----

== Огляд синтаксису

Синтаксис Vala - це амальгама, заснована на С#. Як результат, більша його частина буде знайома програмістам, які знають будь-яку мову, схожу на С, і, зважаючи на це, я резюмував все.

Область застосування визначається за допомогою фігурних дужок. Об'єкт або посилання дійсні лише між `{` і `}`. Це також роздільники, які використовуються для визначення класів, методів, блоків коду тощо, тому вони автоматично мають власну сферу застосування. Vala не сувора щодо місця декларування змінних.

Ідентифікатор визначається його типом та назвою, наприклад `int c` означає ціле число на ім'я `c`. У випадку типів значень це також створює об'єкт даного типу. Для типів посилань вони просто визначають нове посилання, яке спочатку не вказує ні на що.

Імена ідентифікатора можуть бути будь-якою комбінацією літер (`[a-z]`, `[A-Z]`), підкреслення та цифр. Однак, щоб визначити або посилатися на ідентифікатор з іменем, яке або починається з цифри, або є ключовим словом, потрібно встановити його префіксом символ `"@"`. Цей символ не вважається частиною імені. Наприклад, ви можете назвати метод `foreach`, написавши `@foreach`, навіть якщо це зарезервоване ключове слово Vala. Ви можете опустити символ `"@"`, коли його можна однозначно інтерпретувати як ім'я ідентифікатора, наприклад у `foo.foreach ()`.

Типи посилань ініціюються за допомогою оператора `new` та назви способу побудови, що зазвичай є лише назвою типу, наприклад `Object o = new Object()` створює новий `Object` і робить `o` посиланням на нього.

=== Коментарі

Vala дозволяє коментувати в коді різними способами.

[source,vala]
----
// Коментар продовжується до кінця рядка

/* Коментар триває між роздільниками */

/**
 * Коментар до документації
 */
----

Вони обробляються так само, як і в більшості інших мов, тому потребують невеликих пояснень. Зауваження щодо документації насправді не особливі для Vala, але інструмент генерації документації, як Valadoc, розпізнає їх.

== Типи даних

Загалом, у Vala є два типи даних: типи посилань та типи значень. Ці імена описують, як екземпляри типів передаються по системі - тип значення копіюється кожного разу, коли він присвоюється новому ідентифікатору, тип посилання не копіюється, натомість новий ідентифікатор - це просто нове посилання на той самий об’єкт.

Константа визначається, ставлячи `const` перед типом. Домовленість іменування констант - `ALL_UPPER_CASE`.

==== Типи значення

Vala підтримує набір простих типів, як це робить більшість інших мов.

* Byte, `char`, `uchar`; їхні імена є `char` з історичних причин.
* Character, `unichar`; 32-розрядний символ Unicode
* Integer, `int`, `uint`
* Long Integer, `long`, `ulong`
* Short Integer, `short`, `ushort`
* Integer гарантованої довжини, `int8`, `int16`, `int32`, `int64`, так само як їх беззнакові варіанти `uint8`, `uint16`, `uint32`, `uint64`. Цифри позначають довжину в бітах.
* Float, `float`, `double`
* Boolean, `bool`; можливі значення `true` та `false`
* Compound, `struct`
* Enumeration, `enum`; представлені цілими значеннями, а не класами, як перерахунки Java

Ось кілька прикладів.

[source,vala]
----
/ * атомарні типи * /
unichar c = 'u';
float percentile = 0.75f;
const double MU_BOHR = 927.400915E-26;
bool the_box_has_crashed = false;

/ * визначення структури * /
struct Vector {
    public double x;
    public double y;
    public double z;
}

/ * визначення enum * /
enum WindowType {
    TOPLEVEL,
    POPUP
}
----

Більшість цих типів можуть мати різні розміри на різних платформах, за винятком цілих типів із гарантованим розміром. Оператор `sizeof` повертає розмір, який займає змінна даного типу в байтах:

[source,vala]
----
ulong nbytes = sizeof(int32);    // nbytes складе 4 (= 32 біта)
----

Ви можете визначити мінімальні та максимальні значення числового типу за допомогою `.MIN` та `.MAX`, наприклад `int.MIN` та `int.MAX`.

==== Рядки

Тип даних для рядків - це `string`. Рядки Vala кодуються UTF-8 та є незмінні.

[source,vala]
----
string text = "Рядковий літерал";
----

Vala пропонує функцію, яку називають дослівними рядками. Це рядки, в яких ескейп послідовності (наприклад, `\n`) не інтерпретуються, розриви рядків будуть збережені, а лапки не потрібно маскувати. Вони утворюються потрійними подвійними лапками. Можливі відступи після розриву рядка також є частиною рядка.

[source,vala]
----
string verbatim = """Це так званий "дослівний рядок".
Дослівні рядки не обробляють ескейп послідовності, такі як \n, \t, \\, etc.
Вони можуть містити лапки і охоплювати декілька рядків поспіль.""";
----

Рядки з префіксом `"@"` - це шаблони рядків. Вони можуть оцінювати вбудовані змінні та вирази з префіксом `"$"`:

[source,vala]
----
int a = 6, b = 7;
string s = @"$a * $b = $(a * b)";  // => "6 * 7 = 42"
----

Оператори рівності `==` і `!=` порівнюють зміст двох рядків, всупереч поведінці Java, яка в цьому випадку перевіряє рівність посилань.

Ви можете нарізати рядок за допомогою `[start: end]`. Від'ємні значення представляють позиції відносно кінця рядка:

[source,vala]
----
string greeting = "hello, world";
string s1 = greeting[7:12];        // => "world"
string s2 = greeting[-4:-2];       // => "or"
----

Зауважте, що індекси у Vala починаються з 0, як у більшості інших мов програмування. Починаючи з Vala 0,11, ви можете отримати доступ до одного байта рядка за допомогою `[index]`:

[source,vala]
----
uint8 b = greeting[7];             // => 0x77
----

Однак ви не можете призначити нове значення байту в цій позиції, оскільки рядки Vala незмінні.

Багато основних типів мають розумні методи розбору та перетворення на рядки, наприклад:

[source,vala]
----
bool b = bool.parse("false");           // => false
int i = int.parse("-52");               // => -52
double d = double.parse("6.67428E-11"); // => 6.67428E-11
string s1 = true.to_string();           // => "true"
string s2 = 21.to_string();             // => "21"
----

Two useful methods for writing and reading strings to/from the console (and for your first explorations with Vala) are stdout.printf() and stdin.read_line():
Два корисні методи для запису та читання рядків до/з консолі (і для ваших перших досліджень Vala) - `stdout.printf()` та `stdin.read_line ()`:

[source,vala]
----
stdout.printf("Hello, world\n");
stdout.printf("%d %g %s\n", 42, 3.1415, "Vala");
string input = stdin.read_line();
int number = int.parse(stdin.read_line());
----

Ви вже знаєте `stdout.printf()` з прикладу Hello World. Насправді він може приймати довільну кількість аргументів різних типів, тоді як перший аргумент - це рядок формату, дотримуючись тих же правил, що і рядки формату C. Якщо потрібно вивести повідомлення про помилку, ви можете використовувати `stderr.printf()` замість `stdout.printf()`.

Крім того, операція `in` може бути використана для визначення того, чи містить один рядок інший, наприклад

[source,vala]
----
if ("ere" in "Able was I ere I saw Elba.") ...
----

Для отримання додаткової інформації, будь ласка, посилайтесь на http://www.valadoc.org/glib-2.0/string.html[повний огляд класу `string`].

Зразок програми, що демонструє використання рядків, https://wiki.gnome.org/Projects/Vala/StringSample[також доступний].

== Масиви

Масив оголошується шляхом надання імені типу, за яким слідує `[]`, і створюється за допомогою оператора `new`, наприклад `int [] a = new int[10]` для створення масиву цілих чисел. Довжина такого масиву може бути отримана через змінну `length`, наприклад `int count = a.length`. Зауважте, що коли ви пишете `Object[] a = new Object[10]`, об’єкти не створюватимуться, але тільки масив для їх зберігання.

[source,vala]
----
int[] a = new int[10];
int[] b = { 2, 4, 6, 8 };
----

Ви можете нарізати масив за допомогою `[start: end]`:

[source,vala]
----
int[] c = b[1:3];     // => { 4, 6 }
----

Нарізання масиву призведе до посилання на запитувані дані, а не до копії. Однак присвоєння фрагмента власниковій змінній (як це зроблено вище) призведе до копіювання. Якщо ви хочете уникнути копії, потрібно або призначити фрагмент `unowned` масиву, або передати його безпосередньо аргументу (аргументи за замовчуванням `unowned`):

[source,vala]
----
unowned int[] c = b[1:3];     // => { 4, 6 }
----

Багатовимірні масиви визначаються за допомогою `[,]` або `[,,]` тощо.

[source,vala]
----
int[,] c = new int[3,4];
int[,] d = {{2, 4, 6, 8},
            {3, 5, 7, 9},
            {1, 3, 5, 7}};
d[2,3] = 42;
----

Цей вид масиву представлений єдиним суміжним блоком пам'яті. Зубчасті багатовимірні масиви (`[][]`, також відомі як "накладені масиви" або "масиви масивів"), де кожен рядок може мати різну довжину, ще не підтримуються.

Щоб знайти довжину кожного виміру в багатовимірному масиві, член `length` стає масивом, зберігаючи довжину кожного відповідного виміру.

[source,vala]
----
int[,] arr = new int[4,5];
int r = arr.length[0];
int c = arr.length[1];
----

Зверніть увагу, що ви не можете отримати одновимірний масив з багатовимірного масиву або навіть зрізати багатовимірний масив:

[source,vala]
----
int[,] arr = {{1,2},
                {3,4}};
int[] b = arr[0];  // не робить
int[] c = arr[0,];  // не робить
int[] d = arr[:,0];  // не робить
int[] e = arr[0:1,0];  // не робить
int[,] f = arr[0:1,0:1];  // не робить
----

Ви можете додавати елементи масиву динамічно за допомогою оператора `+=`. Однак це працює лише для локально визначених або приватних масивів. При необхідності масив автоматично перерозподіляється. Внутрішньо це перерозподіл відбувається з розмірами, що зростають ступенями двох, з міркувань ефективності роботи. Однак `length` містить фактичну кількість елементів, а не внутрішній розмір.

[source,vala]
----
int[] e = {};
e += 12;
e += 5;
e += 37;
----

Ви можете змінити розмір масиву, викликавши для нього `resize()`. Він збереже оригінальний вміст (стільки, скільки вміщається).

[source,vala]
----
int[] a = new int[5];
a.resize(12);
----

Ви можете переміщувати елементи в масиві, викликаючи `move(src, dest, length)` на ньому. Початкові позиції будуть заповнені 0.

[source,vala]
----
uint8[] chars = "hello world".data;
chars.move (6, 0, 5);
print ((string) chars); // "world "
----

Якщо ви поставите квадратні дужки після ідентифікатора разом із зазначенням розміру, ви отримаєте масив фіксованого розміру. Масиви фіксованого розміру розподіляються на стеку (якщо вони використовуються як локальні змінні) або виділяються інлайн (якщо вони використовуються як поля), і ви не можете їх перерозподілити пізніше.

[source,vala]
----
int f[10]; // без 'new ...'
----

Vala не проводить перевірки меж для доступу до масиву під час виконання. Якщо вам потрібна більша безпека, ви повинні використовувати більш складну структуру даних, як `ArrayList`. Про це ви дізнаєтесь далі у розділі про колекції.

=== Типи посилань

Типи посилань - це всі типи, оголошені як клас, незалежно від того, походять вони з `Object` GLib чи ні. Vala гарантує, що при передачі об'єкта за посиланням система буде відслідковувати кількість посилань, що наразі є активними, щоб керувати пам'яттю для вас. Значення посилання, яке нікуди не вказує, є `null`. Детальніше про класи та їх особливості в розділі про об’єктно-орієнтоване програмування.

[source,vala]
----
/* визначення класу */
class Track : GLib.Object {             /* субклас 'GLib.Object' */
    public double mass;                 /* публічне поле */
    public double name { get; set; }    /* публічна властивість */
    private bool terminated = false;    /* приватне поле */
    public void terminate() {           /* публічний метод */
        terminated = true;
    }
}
----

=== Статичне приведення типів

У Vala ви можете привести змінну від одного типу до іншого. Для приведення статичного типу змінна перетворюється на потрібний, задаючи ім'я типу з дужками. Статичне приведення не накладає перевірки безпеки типу часу виконання. Це працює для всіх типів Vala. Наприклад,

[source,vala]
----
int i = 10;
float j = (float) i;
----

Vala підтримує інший механізм приведення під назвою динамічний кастинг, який виконує перевірку типу часу виконання та описаний у розділі про об'єктно-орієнтоване програмування.

=== Виведення типів

Vala має механізм, який називається виведенням типу, за яким локальна змінна може бути визначена за допомогою `var` замість надання типу, доки не має сумніву, який тип мається на увазі. Тип виводиться з правого боку присвоєння. Це допомагає зменшити зайву надмірність у вашому коді без шкоди для статичної типізації:

[source,vala]
----
var p = new Person();     // те саме: Person p = new Person();
var s = "hello";          // те саме: string s = "hello";
var l = new List<int>();  // те саме: List<int> l = new List<int>();
var i = 10;               // те саме: int i = 10;
----

Це працює лише для локальних змінних. Виведення типу особливо корисне для типів із дженеріками - аргументами типів (докладніше про них пізніше). Порівняйте

[source,vala]
----
MyFoo<string, MyBar<string, int>> foo = new MyFoo<string, MyBar<string, int>>();
----

vs.

[source,vala]
----
var foo = new MyFoo<string, MyBar<string, int>>();
----

=== Визначення нового типу від інших

Визначення нового типу - це питання вивести його з потрібного. Ось приклад:

[source,vala]
----
/ * Визначення новий тип із контейнера типу GLib.List з елементами типу GLib.Value * /
public class ValueList : GLib.List<GLib.Value> {
        [CCode (has_construct_function = false)]
        protected ValueList ();
        public static GLib.Type get_type ();
}
----

== Оператори

`=`
призначення. Лівий операнд повинен бути ідентифікатором, а правий повинен приводити до значення або посилання відповідно.

`+`, `-`, `/`, `*`, `%`
основна арифметика, застосована до лівого і правого операндів. Оператор `+` також може об'єднати рядки.

`+=`, `-=`, `/=`, `*=`, `%=`
арифметична операція між лівим і правим операндами, де лівий повинен бути ідентифікатором, якому присвоюється результат.

`++`, `--`
операції збільшення та зменшення з неявним призначенням. Вони беруть лише один аргумент, який повинен бути ідентифікатором простого типу даних. Значення буде змінено і присвоєно назад ідентифікатору. Ці оператори можуть бути розміщені або в позиціях префікса, або в постфіксі - при першому оцінене значення оператора буде щойно обчисленим значенням, при другому повертається початкове значення.

`|`, `^`, `&`, `~`, `|=`, `&=`, `^=`
побітові операції: або, ексклюзивні або, і, ні. Другий набір включає призначення і є аналогом арифметичних версій. Вони можуть бути застосовані до будь-якого з простих типів значень. (Немає жодного оператора присвоєння, пов'язаного з `~`, тому що це одномісний оператор. Еквівалентна операція просто `a = ~a`).

`<<`, `>>`
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда.

`<<=`, `>>=`
операції з переміщенням бітів, зміщуючи лівий операнд на кілька бітів відповідно до правого операнда. Лівий операнд повинен бути ідентифікатором, якому присвоюється результат.

`==`
тест на рівність. Оцінюється до значення `bool`, залежно від того, чи рівні лівий і правий операнди. У випадку типів значень це означає, що їх значення рівні, у випадку референсних типів об'єкти - це той самий екземпляр. Виняток із цього правила - тип рядка, який тестується на рівність за значенням.

`<`, `>`, `>=`, `<=`, `!=`
тести на нерівність. Оцінює значення до `bool` залежно від того, чи відрізняються лівий і правий операнди описаним способом. Вони дійсні для простих типів даних та типу рядка. Для рядків ці оператори порівнюють лексикографічний порядок.

`!`, `&&`, `||`
логічні операції: не, і, або. Ці операції можуть бути застосовані до булевих значень - перший приймає лише одне значення, інші - дві.

`? :`
ternary conditional operator. Evaluates a condition and returns either the value of the left or the right sub-expression based on whether the condition is true or false: condition ? value if true : value if false
потрійний умовний оператор. Оцінює умову і повертає або значення лівого, або правого підвиразу, виходячи з того, чи є умова істинною чи помилковою: `умова ? true значення: false значення`

`??`
оператор `null` поглинання: `a ?? b` еквівалентно `a != null ? a : b`. Цей оператор корисний, наприклад, для надання значення за замовчуванням у випадку, якщо посилання є `null`:

[source,vala]
----
stdout.printf("Hello, %s!\n", name ?? "unknown person");
----

`in`
перевіряє, чи містить правий операнд лівий операнд. Цей оператор працює над масивами, рядками, колекціями або будь-яким іншим типом, який має відповідний метод `contains()`. Для рядків він виконує пошук підрядків.

Операторів не можна перевантажувати у Vala. Існують додаткові оператори, які дійсні в контексті лямбда-декларацій та інших конкретних завдань - вони пояснюються в контексті, в якому вони застосовуються.

== Структури управління

[source,vala]
----
while (a > b) { a--; }
----

буде декрементувати повторно, перевіряючи перед кожною ітерацією, що `a` більше `b`.

[source,vala]
----
do { a--; } while (a > b);
----

буде декрементувати повторно, перевіряючи після кожної ітерації, що `a` більше `b`.

[source,vala]
----
for (int a = 0; a < 10; a++) { stdout.printf("%d\n", a); }
----

буде ініціалізувати `а` до `0`, а потім друкувати повторно, доки `а` не буде менше `10`, збільшуючи `а` після кожної ітерації.

[source,vala]
----
foreach (int a in int_array) { stdout.printf("%d\n", a); }
----

буде друкувати кожне ціле число в масиві чи іншій ітерабельній колекції. Значення "ітерабельного" буде описано пізніше.

Усі чотири попередні типи циклу можуть керуватися ключовими словами `break` та `continue`. Інструкція `break` призведе до негайного завершення циклу, а `continue` перейде прямо до тестової частини ітерації.

[source,vala]
----
if (a > 0) { stdout.printf("a is greater than 0\n"); }
else if (a < 0) { stdout.printf("a is less than 0\n"); }
else { stdout.printf("a is equal to 0\n"); }
----

виконує певний фрагмент коду на основі набору умов. Перша умова, яка відповідає, визначає, який код буде виконуватися, якщо `a` більше `0`, не перевірятиметься, чи вона менша за `0`. Дозволяється будь-яка кількість блоків `else if`, та нуль або один блок `else`.

[source,vala]
----
switch (a) {
case 1:
    stdout.printf("one\n");
    break;
case 2:
case 3:
    stdout.printf("two or three\n");
    break;
default:
    stdout.printf("unknown\n");
    break;
}
----

Оператор `switch` виконує рівно один або жодного розділу коду на основі значення, переданого йому. У Vala немає провалів між випадками, крім порожніх. Для того, щоб забезпечити це, кожен непустий випадок повинен закінчуватися `break`, `return` або `throw`. Можна використовувати оператори `switch` з рядками.

Примітка для програмістів на C: умови завжди повинні оцінюватися як булеві значення. Це означає, що якщо ви хочете перевірити змінну на `null` або `0`, ви повинні зробити це явно: `if (object! = Null) {}` або `if (number! = 0) {}`.

== Мовні елементи

==== Методи

Функції називаються методами у Vala, незалежно від того, визначені вони всередині класу чи ні. Відтепер ми будемо дотримуватися терміну _метод_.

[source,vala]
----
int method_name(int arg1, Object arg2) {
    return 1;
}
----

Цей код визначає метод, який має ім'я `method_name`, беручи два аргументи, один ціле число, а другий - `Object` (перший передається за значенням, другий - як посилання, як описано). Метод поверне ціле число, яке в даному випадку дорівнює `1`.

Усі методи Vala є функцією C, тому беруть довільну кількість аргументів і повертають одне значення (або жодного, якщо метод визнаний `void`). Вони можуть наблизити більше значень повернення, розміщуючи дані у місцях, відомих коду виклику. Детальніше про те, як це зробити, ви знайдете в розділі "Напрямки параметрів" у розширеній частині цього підручника.

Домовленість іменування методів у Vala - це `all_lower_case`, з підкресленнями в якості роздільника слів. Це може бути трохи незнайоме програмістам на C# або Java, які звикли до імен методів `CamelCase` або `mixedCamelCase`. Але з цим стилем ви будете узгоджені з іншими бібліотеками Vala та C/GObject.

Неможливо мати кілька методів з тим самим іменем, але різні сигнатури в межах однієї області ("перевантаження методів"):

[source,vala]
----
void draw(string text) { }
void draw(Shape shape) { }  // неможливе
----

Це пов’язано з тим, що бібліотеки, створені з Vala, призначені для використання також для програмістів на C. У Vala ви зробили б щось подібне замість цього:

[source,vala]
----
void draw_text(string text) { }
void draw_shape(Shape shape) { }
----

Вибравши трохи інші імена, ви можете уникнути зіткнення імен. В мовах, що підтримують перевантаження методів, це часто використовується для надання зручних методів з меншою кількістю параметрів, що призводить до виклику найбільш загального методу:

[source,vala]
----
void f(int x, string s, double z) { }
void f(int x, string s) { f(x, s, 0.5); }  // неможливе
void f(int x) { f(x, "hello"); }           // неможливе
----

У цьому випадку ви можете скористатись можливістю надати параметру значення за замовчуванням, щоб досягти подібної поведінки лише одним методом. Ви можете визначити значення за замовчуванням для останніх параметрів методу, так що вам не доведеться їх явно передавати при виклику методу:

[source,vala]
----
void f(int x, string s = "hello", double z = 0.5) { }
----

Деякі можливі виклики цього методу можуть бути:

[source,vala]
----
f(2);
f(2, "hi");
f(2, "hi", 0.75);
----

Можна навіть визначити методи з реальними списками аргументів змінної довжини (`varargs`), такими як `stdout.printf()`, хоча це не обов'язково рекомендується. Ви дізнаєтесь, як це зробити пізніше.

Vala здійснює основну перевірку на `null`-здатність параметри методу та значення повернення. Якщо припустимо, що параметр методу або значення, що повертається, мають значення `null`, символ типу повинен бути постфіксований модифікатором `?`. Ця додаткова інформація допомагає компілятору Vala виконувати статичні перевірки та додавати припущення часу виконання для методів, що може допомогти уникнути пов'язаних помилок, таких як використання `null` посилання.

[source,vala]
----
string? method_name(string? text, Foo? foo, Bar bar) {
    // ...
}
----

In this example text, foo and the return value may be null, however, bar must not be null.
У цьому прикладі `text`, `foo` та значення, що повертаються, можуть бути `null`, проте `bar` не повинна бути `null`.

==== Делегати

[source,vala]
----
delegate void DelegateType(int a);
----

Делегати представляють методи, що дозволяють передавати фрагменти коду як об'єкти. Наведений вище приклад визначає новий тип з назвою `DelegateType`, який представляє методи, що приймають `int` та не повертає жодного значення. Будь-який метод, що відповідає цій сигнатурі, може бути призначений змінній цього типу або передаватися як аргумент методу цього типу.

[source,vala]
----
delegate void DelegateType(int a);

void f1(int a) {
    stdout.printf("%d\n", a);
}

void f2(DelegateType d, int a) {
    d(a);       // Виклик делегата
}

void main() {
    f2(f1, 5);  // Передача метода як як аргумента делегата в інший метод
}
----

Цей код виконує метод `f2`, передаючи посилання на метод `f1` і число `5`. Потім `f2` виконає метод `f1`, передавши йому число.

Делегати також можуть створюватися локально. Метод-член також може бути призначений делегату, наприклад,

[source,vala]
----
class Foo {

    public void f1(int a) {
        stdout.printf("a = %d\n", a);
    }

    delegate void DelegateType(int a);

    public static int main(string[] args) {
        Foo foo = new Foo();
        DelegateType d1 = foo.f1;
        d1(10);
        return 0;
    }
}
----

==== Анонімні методи/замикання

[source,vala]
----
(a) => { stdout.printf("%d\n", a); }
----

Анонімний метод, також відомий як лямбда-вираз, літеральна функція або замикання, може бути визначений у Vala за допомогою оператора `=>`. Список параметрів знаходиться з лівої сторони оператора, тіло методу - з правого боку.

Анонімний метод, що стоїть сам по собі, як вище, не має особливого сенсу. Він корисний лише в тому випадку, якщо ви призначите його безпосередньо змінній типу делегата або передаєте його як аргумент-метод іншому методу.

Зауважте, що ні параметри, ні тип повернення не вказані явно. Натомість типи виводяться з сигнатури делегата, з яким він використовується.

Призначення анонімного методу делегатній змінній:

[source,vala]
----
delegate void PrintIntFunc(int a);

void main() {
    PrintIntFunc p1 = (a) => { stdout.printf("%d\n", a); };
    p1(10);

    // Фігурні дужки необов’язкові, якщо тіло містить лише одне твердження:
    PrintIntFunc p2 = (a) => stdout.printf("%d\n", a);
    p2(20);
}
----

Передача анонімного методу до іншого методу:

[source,vala]
----
delegate int Comparator(int a, int b);

void my_sorting_algorithm(int[] data, Comparator compare) {
    // ... 'compare' називається десь тут ...
}

void main() {
    int[] data = { 3, 9, 2, 7, 5 };
    // Анонімний метод передається як другий аргумент:
    my_sorting_algorithm(data, (a, b) => {
        if (a < b) return -1;
        if (a > b) return 1;
        return 0;
    });
}
----

Анонімні методи - це справжні замикання. Це означає, що ви можете отримати доступ до локальних змінних зовнішнього методу в межах лямбда-виразу:

[source,vala]
----
delegate int IntOperation(int i);

IntOperation curried_add(int a) {
    return (b) => a + b;  // 'a' - зовнішня змінна
}

void main() {
    stdout.printf("2 + 4 = %d\n", curried_add(2)(4));
}
----

У цьому прикладі `curried_add` (див. Карування) повертає новостворений метод, який зберігає значення `a`. Цей повернутий метод викликається безпосередньо після цього, з аргументом `4`, що призводить до суми двох чисел.

==== Простори імен

[source,vala]
----
namespace NameSpaceName {
    // ...
}
----

Все, що знаходиться між дужками в цьому операторі, знаходиться в просторі імен `NameSpaceName` і на нього має бути посилання. Будь-який код за межами цього простору імен повинен або використовувати кваліфіковані імена для чогось, що знаходиться в межах простору імен, або бути у файлі з відповідною декларацією, щоб імпортувати цю область імен:

[source,vala]
----
using NameSpaceName;
// ...
----

Наприклад, якщо імпорт простору імен Gtk імпортується за допомогою `using Gtk;` ви можете просто написати `Window` замість `Gtk.Window`. Повна кваліфікована назва потрібна буде лише у випадку неоднозначності, наприклад, між `GLib.Object` та `Gtk.Object`.

Простір імен `GLib` імпортується за замовчуванням. Уявіть невидимий рядок `using GLib;` на початку кожного файлу Vala.

Все, що ви не помістите в окремий простір імен, потрапить у анонімний глобальний простір імен. Якщо вам доведеться явно посилатися на глобальний простір імен через неоднозначність, ви можете зробити це за допомогою префікса `global::`.

Простори імен можна вкладати або шляхом введення однієї декларації всередину іншої, або наданням імені форми `NameSpace1.NameSpace2`.

Кілька інших типів визначень можуть декларувати себе всередині простору імен, дотримуючись тієї ж форми іменування, наприклад. клас `NameSpace1.Test {...}`. Зауважте, що після цього кінцевим простором імен визначення буде вкладена декларація, плюс простори імен, оголошені у визначенні.

==== Структури

[source,vala]
----
struct StructName {
    public int a;
}
----

визначає тип структури, тобто тип складного значення. Структура Vala може мати методи обмеженим чином, а також може мати приватні члени, тобто потрібебн явний модифікатор доступу `public`.

[source,vala]
----
struct Color {
    public double red;
    public double green;
    public double blue;
}
----

Ось як можна ініціалізувати структуру:

[source,vala]
----
// без виводу типу
Color c1 = Color();  // або Color c1 = {};
Color c2 = { 0.5, 0.5, 1.0 };
Color c3 = Color() {
    red = 0.5,
    green = 0.5,
    blue = 1.0
};

// з виводом типу
var c4 = Color();
var c5 = Color() {
    red = 0.5,
    green = 0.5,
    blue = 1.0
};
----

Структури виділяються в стеку/вбудовано і копіюються при присвоєнні.

Щоб визначити масив структур, перегляньте FAQ.

==== Класи

[source,vala]
----
class ClassName : SuperClassName, InterfaceName {
}
----

визначає клас, тобто тип посилання. На відміну від структур, екземпляри класів виділяються в купі. Існує набагато більше синтаксису, пов’язаного з класами, про що більш докладно йдеться у розділі про об’єктно-орієнтоване програмування.

==== Інтерфейси

[source,vala]
----
interface InterfaceName : SuperInterfaceName {
}
----

визначає інтерфейс, тобто тип, примірник якого не створюється. Для того, щоб створити екземпляр інтерфейсу, ви повинні спочатку реалізувати його абстрактні методи в не-абстрактному класі. Інтерфейси Vala є більш потужними, ніж інтерфейси Java або C#. Насправді їх можна використовувати як міксини. Деталі інтерфейсів описані в розділі про об'єктно-орієнтоване програмування.

==== Атрибути коду

Атрибути коду вказують деталі компілятора Vala про те, як повинен працювати код на цільовій платформі. Їх синтаксис є `[AttributeName]` або `[AttributeName (param1 = value1, param2 = value2, ...)]`.

Вони в основному використовуються для прив’язки у файлах `vapi`, де `[CCode (...)]` є найбільш помітним прикладом. Інший приклад - атрибут `[DBus (...)]` для експорту віддалених інтерфейсів через D-Bus.

== Об'єктно-орієнтоване програмування

Хоча Vala не змушує вас працювати з об'єктами, деякі можливості не доступні в будь-який інший спосіб. Таким чином, ви, безсумнівно, захочете програмувати в об'єктно-орієнтованому стилі більшу частину часу. Як і в більшості сучасних мов, для визначення власних типів об'єктів ви пишете визначення класу.

Визначення класу вказує, які дані має кожен об'єкт його типу, на які ще типи об'єктів можуть містити посилання та які методи можуть бути виконані на ньому. Визначення може містити назву іншого класу, для якого новий має бути підкласом. Екземпляр класу також є екземпляром усіх суперкласів класу, оскільки він успадковує від них усі їхні методи та дані, хоча він може не мати доступу до всього цього сам по собі. Клас також може реалізовувати будь-яку кількість інтерфейсів, що представляють собою набори визначень методів, які повинні бути реалізовані класом - екземпляр класу також є екземпляром кожного інтерфейсу, реалізованого його класом або суперкласами.

Класи у Vala можуть також мати `static` члени. Цей модифікатор дозволяє визначати або дані, або методи як належні до класу в цілому, а не до конкретного його примірника. До таких членів можна отримати доступ, не маючи примірника класу.

=== Основи

Простий клас можна визначити так:

[source,vala]
----
public class TestClass : GLib.Object {

    / * Поля * /
    public int first_data = 0;
    private int second_data;

    / * Конструктор * /
    public TestClass() {
        this.second_data = 5;
    }

    / * Метод * /
    public int method_1() {
        stdout.printf("private data: %d", this.second_data);
        return this.second_data;
    }
}
----

Цей код визначає новий тип (який автоматично реєструється в системі типів бібліотеки `gobject`), який містить три члени. Є два члени даних, цілі числа, визначені вгорі, і один метод під назвою `method_1`, який повертає ціле число. У декларації класу зазначено, що цей клас є підкласом `GLib.Object`, а тому його екземпляри є також `Object`, і містять також усі члени цього типу. Той факт, що цей клас походить від `Object`, також означає, що є особливості Vala, які можна використовувати для легкого доступу до деяких властивостей об'єкта.

Цей клас описується як загальнодоступний (за замовчуванням класи є внутрішніми). Це означає, що на нього можна посилатися безпосередньо з коду за межами цього файлу - якщо ви програміст C glib/gobject, ви визнаєте це еквівалентом визначення класових інтерфейсів у файлі заголовка, який можна включати в інший код.

Члени також описуються як `public` або `private`. Член `first_data` є загальнодоступним, тому його можна побачити безпосередньо будь-якому користувачеві класу, і його можна модифікувати, не повідомляючи про це екземпляр. Другий член даних є приватним і на нього може посилатися лише код, що належить до цього класу. Vala підтримує чотири різні модифікатори доступу:

* `public` Без обмежень доступу
* `private` Доступ обмежений визначенням класу/структури. Це за замовчуванням, якщо не вказаний модифікатор доступу
* `protected` Доступ обмежений визначенням класу та будь-яким класом, який успадковується від класу
* `internal` Доступ обмежений виключно класами, визначеними в одному пакеті

Конструктор ініціалізує нові екземпляри класу. Він має те саме ім'я, що і клас, може приймати нуль або більше аргументів і визначається без типу повернення.

Заключна частина цього класу - визначення методу. Цей метод буде називатися `method_1`, і він повертає ціле число. Оскільки цей метод не є статичним, він може бути виконаний лише на екземплярі цього класу, а тому може отримати доступ до членів цього екземпляра. Це можна зробити за допомогою посилання `this`, яке завжди вказує на екземпляр, на якому викликається метод. Якщо немає двозначності, цей ідентифікатор за бажанням можна опустити.

Ви можете використовувати цей новий клас наступним чином:

[source,vala]
----
TestClass t = new TestClass();
t.first_data = 5;
t.method_1();
----

=== Конструювання

Vala підтримує дві дещо різні схеми конструкторів: схему конструювання в стилі Java/C#, на якій ми зупинимося на даний момент, та схему конструювання в стилі GObject, яка буде описана в розділі в кінці розділу.

Vala не підтримує перевантаження конструктора з тих же причин, з яких немає перевантаження методів, а це означає, що в класі може не бути декількох конструкторів з однаковою назвою. Однак це не проблема, оскільки Vala підтримує іменовані конструктори. Якщо ви хочете запропонувати кілька конструкторів, ви можете дати їм додаткові назви:

[source,vala]
----
public class Button : Object {

    public Button() {
    }

    public Button.with_label(string label) {
    }

    public Button.from_stock(string stock_id) {
    }
}
----

Створення примірника аналогічне:

[source,vala]
----
new Button();
new Button.with_label("Click me");
new Button.from_stock(Gtk.STOCK_OK);
----

Ви можете зціпити конструктори за допомогою `this()` або `this.name_extension()`:

[source,vala]
----
public class Point : Object {
    public double x;
    public double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public Point.rectangular(double x, double y) {
        this(x, y);
    }

    public Point.polar(double radius, double angle) {
        this.rectangular(radius * Math.cos(angle), radius * Math.sin(angle));
    }
}

void main() {
    var p1 = new Point.rectangular(5.7, 1.2);
    var p2 = new Point.polar(5.7, 1.2);
}
----

=== Знищення

Хоча Vala управляє пам'яттю для вас, можливо, вам доведеться додати свій власний деструктор, якщо ви вирішите зробити ручне управління пам’яттю за допомогою покажчиків (докладніше про це пізніше) або якщо вам доведеться вивільнити інші ресурси. Синтаксис такий самий, як у C# або C++:

[source,vala]
----
class Demo : Object {
    ~Demo() {
        stdout.printf("in destructor");
    }
}
----

Оскільки управління пам'яттю Vala базується на підрахунку посилань замість відстеження збору сміття, деструктори детерміновані і можуть використовуватися для реалізації схеми RAII для управління ресурсами (закриття потоків, підключень до бази даних, ...).

=== Сигнали

Сигнали - це система, що надається класом `Object` в GLib, і стає легко доступною в Vala для всіх нащадків `Object`. Сигнали можна пояснити програмістам на C# як події, або програмістам Java як альтернативний спосіб реалізації слухачів подій. Коротше кажучи, сигнал є просто способом виконання довільної кількості зовнішньо однакових методів (тобто тих, що мають однакову сигнатуру) приблизно в один і той же час. Насправді методи виконання є внутрішніми для `gobject`, і не важливі для програм Vala.

Сигнал визначається як член класу і виглядає аналогічно методу без тіла. Потім обробники сигналів можуть бути додані до сигналу за допомогою методу `connect()`. Для того, щоб зразу перейти до справи, наступний приклад також вводить лямбда-вирази, дуже корисний спосіб написання коду обробки сигналу у Vala:

[source,vala]
----
public class Test : GLib.Object {

    public signal void sig_1(int a);

    public static int main(string[] args) {
        Test t1 = new Test();

        t1.sig_1.connect((t, a) => {
            stdout.printf("%d\n", a);
        });

        t1.sig_1(5);

        return 0;
    }
}
----

Цей код вводить новий клас під назвою `Test`, використовуючи знайомий синтаксис. Першим членом цього класу є сигнал, який називається `sig_1` і визначається як передача цілого числа. В методі `main` цієї програми ми спочатку створюємо екземпляр - це вимога, оскільки сигнали завжди належать до примірників класів. Далі ми призначаємо оброблювач сигналу нашого примірника `sig_1`, який ми визначаємо у вбудованому вигляді як лямбда-вираз. Визначення зазначає, що метод отримає два аргументи, які ми називаємо `"t"` і `"a"`, але не надаємо для них типи. Ми можемо бути такі стислі, оскільки Vala вже знає визначення сигналу і тому може зрозуміти, які типи потрібні.

Причина, що для обробника є два параметри, полягає в тому, що щоразу, коли випромінюється сигнал, об'єкт, на який він випромінюється, передається як перший аргумент обробнику. Другий аргумент - той, що надає сигнал.

Нарешті ми нетерплячі і вирішуємо випромінити сигнал. Ми робимо це, називаючи сигнал так, ніби це метод нашого класу, і дозволяємо `gobject` піклуватися про пересилання повідомлення всім доданим обробникам. Розуміння механізму, який використовується для цього, не потрібне щоб використовувати сигнали Vala.

NB: Наразі модифікатор доступу `public` є єдиним можливим варіантом - всі сигнали можуть бути як підключені, так і випромінювані будь-яким фрагментом коду.

Примітка. Починаючи з квітня 2010 р. cигнали можна анотувати будь-якою комбінацією прапорів:

    [Signal (action=true, detailed=true, run=true, no_recurse=true, no_hooks=true)]
    public signal void sig_1 ();

=== Властивості

Це гарна об'єктно-орієнтована практика програмування, щоб приховувати деталі реалізації від користувачів ваших класів (принцип приховування інформації), щоб потім можна було змінити внутрішні деталі, не порушуючи загальнодоступний API. Однією з практик є створення полів приватними та надання методів доступу для отримання та встановлення їх значень (геттери та сетери).

Якщо ви програміст Java, ви, напевно, придумаєте щось подібне:

[source,vala]
----
class Person : Object {
    private int age = 32;

    public int get_age() {
        return this.age;
    }

    public void set_age(int age) {
        this.age = age;
    }
}
----

Це працює, але Vala може зробити краще. Проблема полягає в тому, що ці методи громіздкі. Припустимо, що ви хочете збільшити вік людини на один рік:

[source,vala]
----
var alice = new Person();
alice.set_age(alice.get_age() + 1);
----

Тут вступають властивості:

[source,vala]
----
class Person : Object {
    private int _age = 32;  // префікс з підкреслення, щоб уникнути конфлікту з властивістю

    /* Властивість */
    public int age {
        get { return _age; }
        set { _age = value; }
    }
}
----

Цей синтаксис повинен бути знайомий програмістам C#. Властивість має блоки `get` та `set` для отримання та встановлення. `value` - це ключове слово, яке представляє нове значення, яке слід призначити властивості.

Тепер ви можете отримати доступ до властивості так, ніби це публічне поле. Але за лаштунками виконується код у блоках `get` і `set`.

[source,vala]
----
var alice = new Person();
alice.age = alice.age + 1;  // або навіть коротше:
alice.age++;
----

Якщо ви виконуєте лише стандартну реалізацію, як показано вище, ви можете записати властивість ще коротше:

[source,vala]
----
class Person : Object {
    /* Property with standard getter and setter and default value */
    public int age { get; set; default = 32; }
}
----

За допомогою властивостей ви можете змінювати внутрішню роботу класів без зміни загальнодоступного API. Наприклад:

[source,vala]
----
static int current_year = 2525;

class Person : Object {
    private int year_of_birth = 2493;

    public int age {
        get { return current_year - year_of_birth; }
        set { year_of_birth = current_year - value; }
    }
}
----

Цього разу вік обчислюється на льоту від року народження. Зауважте, що ви можете зробити більше, ніж просто простий змінний доступ або призначення в блоках `get` і `set`. Ви можете зробити доступ до бази даних, ведення журналів, оновлення кешу тощо.

Якщо ви хочете зробити властивість лише для читання для користувачів класу, ви повинні зробити сетер приватним:

[source,vala]
----
public int age { get; private set; default = 32; }
----

Або ж ви можете залишити встановлений блок:

[source,vala]
----
class Person : Object {
    private int _age = 32;

    public int age {
        get { return _age; }
    }
}
----

Властивості можуть мати не лише ім'я, але й короткий опис (називається нік) та довгий опис (називається пояснення). Ви можете помітити їх спеціальним атрибутом:

[source,vala]
----
[Description(nick = "age in years", blurb = "This is the person's age in years")]
public int age { get; set; default = 32; }
----

Властивості та їх додаткові описи можна запитувати під час виконання. Деякі програми, такі як графічний дизайнер інтерфейсу Glade, використовують цю інформацію. Таким чином Glade може представити зрозумілі людині описи властивостей GTK + віджетів.

Кожен екземпляр класу, похідного від `GLib.Object`, має сигнал, який називається `notify`. Цей сигнал випромінюється щоразу, коли властивість його об'єкта змінюється. Таким чином, ви можете підключитися до цього сигналу, якщо вас взагалі цікавлять сповіщення змін:

[source,vala]
----
obj.notify.connect((s, p) => {
    stdout.printf("Property '%s' has changed!\n", p.name);
});
----

`s` - джерело сигналу (`obj` у цьому прикладі), `p` - інформація про властивості типу `ParamSpec` для зміненої властивості. Якщо вас цікавлять лише сповіщення про зміну одної властивості, ви можете використовувати цей синтаксис:

[source,vala]
----
alice.notify["age"].connect((s, p) => {
    stdout.printf("age has changed\n");
});
----

Зауважте, що в цьому випадку ви повинні використовувати рядкове представлення імені властивості, де підкреслення замінюється тире: `my_property_name` стає `"my-property-name"` у цьому поданні, що є домовленістю іменування властивостей в `GObject`.

Повідомлення про зміну можна відключити тегом атрибута `CCode` безпосередньо перед оголошенням властивості:

[source,vala]
----
public class MyObject : Object {
    [CCode(notify = false)]
// сигнал сповіщення НЕ випромінюється при зміні властивості
    public int without_notification { get; set; }
// сигнал зміни випромінюється при зміні властивості
    public int with_notification { get; set; }
}
----

Існує ще один тип властивостей, які називаються властивостями конструкції, які описані далі в розділі про побудову в стилі `gobject`.

Примітка: якщо ваш ресурс має тип `struct`, щоб отримати значення властивості за допомогою `Object.get()`, ви повинні оголосити свою змінну як приклад нижче

[source,vala]
----
struct Color
{
    public uint32 argb;

    public Color() { argb = 0x12345678; }
}

class Shape: GLib.Object
{
    public Color c { get; set; default = Color(); }
}

int main()
{
    Color? c = null;
    Shape s = new Shape();
    s.get("c", out c);
}
----

Таким чином, `c` - це посилання замість екземпляра `Color` у стеку. Що ви передали до `s.get()` - це `"Color **"` замість `"Color *"`.

=== Наслідування

У Vala клас може походити з одного або нуля інших класів. На практиці це, ймовірно, завжди є одним, хоча неявного спадкування немає, як у мовах, таких як Java.

Визначаючи клас, який успадковує від іншого, ви створюєте взаємозв'язок між класами, де екземпляри підкласу також є екземплярами надкласу. Це означає, що операції над екземплярами надкласу також застосовні на екземплярах підкласу. Таким чином, там, де потрібен екземпляр надкласу, може бути підставлений екземпляр підкласу.

Під час написання визначення класу можна здійснювати точний контроль над тим, хто може отримати доступ до того, які методи та дані в об’єкті. Наступний приклад демонструє цілий ряд таких варіантів:

[source,vala]
----
class SuperClass : GLib.Object {

    private int data;

    public SuperClass(int data) {
        this.data = data;
    }

    protected void protected_method() {
    }

    public static void public_static_method() {
    }
}

class SubClass : SuperClass {

    public SubClass() {
        base(10);
    }
}
----

`data` є членом даних екземпляра `SuperClass`. Воно буде членом цього типу в кожному екземплярі `SuperClass`, і він оголошений `private`, тому він буде доступний лише за допомогою коду, що є частиною `SuperClass`.

`protected_method` - це метод екземпляра `SuperClass`. Ви зможете виконати цей метод лише екземпляром `SuperClass` або одного з його підкласів, і лише з коду, що належить `SuperClass` або одного з його підкласів - це останнє правило є результатом модифікатора `protected`.

`public_static_method` має два модифікатори. Модифікатор `static` означає, що цей метод може бути викликаний без володіння екземпляром `SuperClass` або одного з його підкласів. Як результат, цей метод не матиме доступу до посилання `this` при його виконанні. Модифікатор `public` означає, що цей метод можна викликати з будь-якого коду, незалежно від його зв’язку із `SuperClass` або його підкласами.

З огляду на ці визначення, екземпляр `SubClass` буде містити всіх трьох членів `SuperClass`, але матиме змогу отримати доступ лише до не-приватних членів. Зовнішній код зможе отримати доступ лише до публічного методу.

За допомогою `base` конструктор підкласу може звертатись до конструктора базового класу.

=== Абстрактні класи

Існує ще один модифікатор методів, який називається `abstract`. Цей модифікатор дозволяє описати метод, який фактично не реалізований у класі. Натомість він повинен бути реалізований підкласами, перш ніж його можна буде викликати. Це дозволяє визначити операції, які можуть бути викликані у всіх екземплярах типу, забезпечуючи при цьому, щоб всі більш конкретні типи надавати власну версію функціоналу.

Клас, що містить абстрактні методи, також повинен бути оголошений абстрактним. Результатом цього є запобігання будь-якої інстанцінацї (створення примірнику) типу.

[source,vala]
----
public abstract class Animal : Object {

    public void eat() {
        stdout.printf("*chomp chomp*\n");
    }

    public abstract void say_hello();
}

public class Tiger : Animal {

    public override void say_hello() {
        stdout.printf("*roar*\n");
    }
}

public class Duck : Animal {

    public override void say_hello() {
        stdout.printf("*quack*\n");
    }
}
----

Реалізація абстрактного методу повинна бути позначена `override`. Властивості також можуть бути абстрактними.

==== Віртуальні методи

Віртуальний метод дозволяє визначити реалізацію за замовчуванням на абстрактні класи та дозволяє похідним класам перекрити свою поведінку. Це відрізняється від приховування методів.

[source,vala]
----
public abstract class Caller : GLib.Object {
   public abstract string name { get; protected set; }
   public abstract void update (string new_name);
   public virtual bool reset ()
   {
      name = "No Name";
      return true;
   }
}

public class ContactCV : Caller
{
   public override string name { get; protected set; }
   public override void update (string new_name)
   {
     name = "ContactCV - " + new_name;
   }
   public override bool reset ()
   {
      name = "ContactCV-Name";
      stdout.printf ("CotactCV.reset () implementation!\n");
      return true;
   }
}

public class Contact : Caller {
   public override string name { get; protected set; }
   public override void update (string new_name)
   {
     name = "Contact - " + new_name;
   }
   
   public static void main ()
   {
      var c = new Contact ();
      c.update ("John Strauss");
      stdout.printf(@"Name: $(c.name)\n");
      c.reset ();
      stdout.printf(@"Reset Name: $(c.name)\n");
      
      var cv = new ContactCV ();
      cv.update ("Xochitl Calva");
      stdout.printf(@"Name: $(cv.name)\n");
      cv.reset ();
      stdout.printf(@"Reset Name: $(cv.name)\n");
      stdout.printf("END\n");
   }
}
----

Як ви бачите у наведеному вище прикладі, `Caller` - це абстрактний клас, що визначає як абстрактну властивість, так і метод, але додає віртуальний метод, який може бути замінений похідними класами. Клас `Contact` реалізує абстрактні методи та властивості `Caller`, використовуючи при цьому реалізацію за замовчуванням для `reset()`, уникаючи визначення нового. `ContactCV` клас реалізує всі абстрактні визначення на `Caller`, але переосмислює `reset()`, щоб визначити власну реалізацію.

=== Інтерфейси

Клас у Vala може реалізувати будь-яку кількість інтерфейсів. Кожен інтерфейс - це тип, подібний до класу, але такий, примірник якого неможливо створити. "Реалізуючи" один або кілька інтерфейсів, клас може оголосити, що його екземпляри є також екземплярами інтерфейсу, і тому він може використовуватися в будь-якій ситуації, коли очікується екземпляр цього інтерфейсу.

Процедура реалізації інтерфейсу така ж, як і для успадкування класів з абстрактними методами - якщо клас повинен бути корисним, він повинен передбачати реалізацію для всіх описаних, але ще не реалізованих, методів.

Просте визначення інтерфейсу виглядає так:

[source,vala]
----
public interface ITest : GLib.Object {
    public abstract int data_1 { get; set; }
    public abstract void method_1();
}
----

Цей код описує інтерфейс `ITest`, який вимагає `GLib.Object` як батьківського класу реалізатора і містить два члени. `data_1` - властивість, як описано вище, за винятком того, що вона оголошена абстрактною. Таким чином, Vala не буде реалізовувати цю властивість, а натомість вимагатиме, щоб класи, що реалізують цей інтерфейс, мали властивість під назвою `data_1`, яка має обоє аксесори, `set` та `get` - потрібно, щоб це було абстрактним, оскільки інтерфейс не може мати членів даних. Другий член `method_1` - це метод. Тут декларовано, що цей метод повинен бути реалізований класами, які реалізують цей інтерфейс.

Найпростіша можлива повна реалізація цього інтерфейсу:

[source,vala]
----
public class Test1 : GLib.Object, ITest {
    public int data_1 { get; set; }
    public void method_1() {
    }
}
----

І може використовуватися наступним чином:

[source,vala]
----
var t = new Test1();
t.method_1();

ITest i = t;
i.method_1();
----

==== Визначення передумов

Інтерфейси у Vala не можуть успадковувати інші інтерфейси, але вони можуть оголосити інші інтерфейси необхідними умовами, що працює приблизно так само. Наприклад, може бути бажаним сказати, що будь-який клас, який реалізує інтерфейс `List`, повинен також реалізовувати інтерфейси `Collection` і `Traverable`. Синтаксис для цього точно такий же, як для опису реалізації інтерфейсу в класах:

[source,vala]
----
public interface List : Collection, Traversable {
}
----

Це визначення `List` не може бути реалізовано в класі без того, щоб `Collection` також була реалізована, і тому Vala застосовує наступний стиль декларування для класу, який бажає реалізувати `List`, де повинні бути описані всі реалізовані інтерфейси:

[source,vala]
----
public class ListClass : GLib.Object, Collection, List {
}
----

Інтерфейси Vala також можуть мати клас як необхідну умову. Якщо ім'я класу вказано у списку передумов, інтерфейс може бути реалізований лише у класах, що походять від цього попереднього класу. Це часто використовується для того, щоб екземпляр інтерфейсу також був підкласом `GLib.Object`, і тому інтерфейс можна використовувати, наприклад, як тип властивості.

Те, що інтерфейси не можуть успадковувати інші інтерфейси, є здебільшого лише технічною відмінністю - на практиці система Vala працює так само, як і інші мови в цій області, але з додатковою особливістю обов'язкових класів.

==== Визначення реалізації за замовчуванням у методах

Існує ще одна важлива відмінність між інтерфейсами Vala та інтерфейсами Java/C#: інтерфейси Vala можуть мати не-абстрактні методи.

Vala фактично дозволяє реалізацію методів в інтерфейсах, і тоді метод із реалізацією за замовчуванням повинен бути оголошений як віртуальний. У зв'язку з цим інтерфейси Vala можуть виступати в ролі міксинів. Це обмежена форма множинного успадкування.

[source,vala]
----
public interface Callable : GLib.Object {
   public abstract bool answering { get; protected set; }
   public abstract void answer ();
   public virtual bool hang ()
   {
      answering = false;
      return true;
   }
}
----

Інтерфейс `Callable` визначає абстрактне властивість, що називається `answering`, де будь-який клас, що реалізує цей інтерфейс, може відстежувати стан виклику, деталі щодо відповіді на виклик є деталями реалізатора, але `hang` визначає реалізацію за замовчуванням, щоб встановити відповідь на помилку під час покладеної слухавки.

[source,vala]
----
public class Phone : GLib.Object, Callable {
   public bool answering { get; protected set; }
   public void answer ()
   {
    /* реалізація коду відповіді */
   }
   
   public static void main ()
   {
      var f = new Phone ();
      if (f.hang ())
         stdout.printf("Hand done.\n");
      else
         stdout.printf("Hand Error!\n");
      stdout.printf("END\n");
   }
}
----

Під час компіляції та запуску ви виявите, що клас `Phone` насправді не реалізує метод `Callable.hang()`, але він може його використовувати, тоді результат - повідомлення `"Hang done"`.

[source,vala]
----
public class TechPhone : GLib.Object, Callable
{
   public bool answering { get; protected set; }
   public void answer ()
   {
     /* реалізація коду відповіді */
   }
   public bool hang ()
   {
      answering = false;
      stdout.printf ("TechPhone.hang () implementation!");
      return false;
   }
}
----

У цьому випадку `TechPhone` - це ще одна реалізація для `Callable`, тоді при виклику методу `hang()` на екземплярі `TechPhone` він завжди поверне помилкове значення та надрукує повідомлення `"TechPhone.hang () implementation!"`

==== Властивості

Інтерфейс може визначати властивості, які необхідно реалізувати для класів. Клас реалізатора повинен визначати властивість з однаковим дозволом сигнатури та доступу для `get` та `set`.

Як і для будь-якої властивості `GObject`, ви можете визначити тіло `set` і `get` в класі реалізатора. Якщо не використовується тіло, `set` і `get` отримують значення за замовчуванням. Якщо вказано, ви повинні визначити приватне поле для зберігання значень властивостей, які будуть використовуватися зовні або всередині класу.

Визначення інтерфейсу `Callable` визначає властивість `answering`. У цьому випадку цей інтерфейс визначає `answering` із захищеним `set`, що дозволяє створити властивості лише для читання для будь-якого об'єкта, використовуючи екземпляр `Callable`, але дозволяє розробникам класів записувати на нього значення, як це робить клас `TechPhone`, коли реалізує метод `hang()`.

==== Міксин та множинне спадкування

Як описано вище, Vala, хоча і базується на C і `GObject`, може забезпечити обмежений механізм множинного успадкування шляхом додавання віртуальних методів до інтерфейсів. Можна додати деякі способи визначення реалізацій методів за замовчуванням у класі реалізатора інтерфейсу, та дозволити похідним класам переосмислити ці методи.

Якщо ви визначите віртуальний метод в інтерфейсі і реалізуєте його в класі, ви не можете перекрити метод інтерфейсу, не залишаючи похідні класи не в змозі отримати доступ до методу інтерфейсу за замовчуванням. Розглянемо наступний код:

[source,vala]
----
public interface Callable : GLib.Object {
   public abstract bool answering { get; protected set; }
   public abstract void answer ();
   public abstract bool hang ();
   public static bool default_hang (Callable call)
   {
      stdout.printf ("At Callable.hang()\n");
      call.answering = false;
      return true;
   }
}

public abstract class Caller : GLib.Object, Callable
{
   public bool answering { get; protected set; }
   public void answer ()
   {
     stdout.printf ("At Caller.answer()\n");
     answering = true;
     hang ();
   }
   public virtual bool hang () { return Callable.default_hang (this); }
}

public class TechPhone : Caller {
        public string number { get; set; }
}

public class Phone : Caller {
   public override bool hang () {
        stdout.printf ("At Phone.hang()\n");
        return false;
   }
   
   public static void main ()
   {
      var f = (Callable) new Phone ();
      f.answer ();
      if (f.hang ())
         stdout.printf("Hand done.\n");
      else
         stdout.printf("Hand Error!\n");
      
      var t = (Callable) new TechPhone ();
      t.answer ();
      if (t.hang ())
         stdout.printf("Tech Hand done.\n");
      else
         stdout.printf("Tech Hand Error!\n");
      stdout.printf("END\n");
   }
}
----

У цьому випадку ми визначили інтерфейс `Callable` з реалізацією за замовчуванням для `abstract bool hang()` під назвою `default_hang`, це може бути статичний або віртуальний метод. Тоді `Caller` є базовим класом, що реалізує `Callable` для класів `TechPhone` і `Phone`, при чому метод `Caller.hang()` просто викликає реалізацію `Callable` за замовчуванням. `TechPhone` нічого не робить і просто приймає `Caller` як базовий клас, використовуючи реалізацію методу за замовчуванням; але `Phone` переосмислює `Caller.hang()`, і це змушує використовувати його власну реалізацію, що дозволяє завжди викликати її, навіть якщо об'єкт приведений до `Callable`.

==== Явна реалізація методу

Явна реалізація методу інтерфейсу дозволяє реалізувати два інтерфейси, які мають методи (а не властивості) з однаковим іменем. Приклад:

[source,vala]
----
interface Foo {
 public abstract int m();
}

interface Bar {
 public abstract string m();
}

class Cls: Foo, Bar {
 public int Foo.m() {
  return 10;
 }

 public string Bar.m() {
  return "bar";
 }
}

void main () {
 var cls = new Cls ();
 message ("%d %s", ((Foo) cls).m(), ((Bar) cls).m());
}
----

Видасть `10 bar`.

==== Поліморфізм

Поліморфізм описує спосіб використання одного і того ж об'єкта, як ніби це більше ніж один окремий тип. Деякі з описаних тут прийомів дозволяють припустити, як це можливо у Vala: екземпляр класу може використовуватися як екземпляр надкласу або будь-яких реалізованих інтерфейсів, не знаючи його фактичного типу.

Логічне розширення цієї потужності полягає в тому, щоб дозволити підтипу поводитись по-різному зі своїм батьківським типом, хоча це виглядає точно так само. Це поняття не дуже легко пояснити, тому я розпочну з прикладу того, що станеться, якщо ви безпосередньо не націлитеся на цю мету:

[source,vala]
----
class SuperClass : GLib.Object {
    public void method_1() {
        stdout.printf("SuperClass.method_1()\n");
    }
}

class SubClass : SuperClass {
    public void method_1() {
        stdout.printf("SubClass.method_1()\n");
    }
}
----

Обидва ці класи реалізують метод, який називається `method_1`, і `SubClass`, таким чином, містить два методи, звані `method_1`, оскільки він успадковує один із `SuperClass`. Кожен із них може бути викликаний, як показує наступний код:

[source,vala]
----
SubClass o1 = new SubClass();
o1.method_1();
SuperClass o2 = o1;
o2.method_1();
----

Це фактично призведе до виклику двох різних методів. Другий рядок вважає, що `o1` є `SubClass` і визиває версію методу цього класу. Четвертий рядок вважає, що `o2` є `SuperClass` і визиває версію методу цього класу.

Проблема, яку розкриває цей приклад, полягає в тому, що будь-який код, що містить посилання на `SuperClass`, буде викликати методи, фактично описані в цьому класі, навіть якщо насправді об'єкті є підкласом. Спосіб зміни такої поведінки - це використання віртуальних методів. Розглянемо наступну переписану версію останнього прикладу:

[source,vala]
----
class SuperClass : GLib.Object {
    public virtual void method_1() {
        stdout.printf("SuperClass.method_1()\n");
    }
}

class SubClass : SuperClass {
    public override void method_1() {
        stdout.printf("SubClass.method_1()\n");
    }
}
----

Коли цей код використовується так само, як і раніше, `method_1` з `SubClass` буде викликаний двічі. Це тому, що ми сказали системі, що `method_1` - це віртуальний метод, тобто, якщо його буде замінено на підкласі, ця нова версія завжди буде виконуватися на екземплярах цього підкласу, незалежно від знань викликаючого.

Ця відмінність, мабуть, знайома програмістам деяких мов, таких як C++, але насправді це протилежність мовам стилю Java, в яких потрібно вжити заходів, щоб запобігти віртуальності методу.

Напевно, зараз ви також побачили, що коли метод оголошується абстрактним, він також повинен бути віртуальним. В іншому випадку неможливо виконати цей метод з урахуванням очевидного екземпляра типу, як він був оголошений. При впровадженні абстрактного методу в підкласі, ви можете вирішити оголосити реалізацію як `override`, передаючи таким чином віртуальний характер методу, і дозволяючи підтипам робити те саме, якщо вони бажають.

Також можливо реалізувати методи інтерфейсу таким чином, щоб підкласи могли змінити реалізацію. Процес у цьому випадку полягає у початковій реалізації, щоб оголосити реалізацію методу віртуальною, і тоді підкласи можуть змінювати її за потребою.

Під час написання класу прийнято використовувати функціонал, визначений у класі, від якого ви успадкували. Це складно, коли назва методу використовується у дереві спадкування для вашого класу більше одного разу. Для цього Vala надає ключове слово `base`. Найпоширеніший випадок, коли ви перекрили віртуальний метод, щоб забезпечити додаткову функціональність, але все ж потрібен метод батьківського класу. Наступний приклад показує цей випадок:


[source,vala]
----
public override void method_name() {
    base.method_name();
    extra_task();
}
----

Vala також дозволяє властивостям бути віртуальними:

[source,vala]
----
class SuperClass : GLib.Object {
    public virtual string prop_1 {
        get {
            return "SuperClass.prop_1";
        }
    }
}

class SubClass : SuperClass {
    public override string prop_1 {
        get {
            return "SubClass.prop_1";
        }
    }
}
----

==== Приховування методів

За допомогою модифікатора `new` ви можете приховати успадкований метод новим методом з тим же ім’ям. Новий метод може мати інший підпис. Приховування методу не слід плутати з перекриттям методу, оскільки приховування методу не проявляє поліморфної поведінки.

[source,vala]
----
class Foo : Object {
    public void my_method() { }
}

class Bar : Foo {
    public new void my_method() { }
}
----

Ви все ще можете викликати оригінальний метод, перейшовши на базовий клас або інтерфейс:

[source,vala]
----
void main() {
    var bar = new Bar();
    bar.my_method();
    (bar as Foo).my_method();
}
----

=== Інформація про тип часу виконання

Оскільки класи Vala реєструються під час виконання і кожен екземпляр несе інформацію про тип, ви можете динамічно перевіряти тип об'єкта за допомогою оператора `is`:

[source,vala]
----
bool b = object is SomeTypeName;
----

Ви можете отримати інформацію про типи об'єктів, використовуючи метод `get_type()`:

[source,vala]
----
Type type = object.get_type();
stdout.printf("%s\n", type.name());
----

За допомогою оператора `typeof()` ви можете отримати інформацію про тип безпосередньо. З цієї інформації про тип можна пізніше створити нові примірники за допомогою `Object.new()`:

[source,vala]
----
Type type = typeof(Foo);
Foo foo = (Foo) Object.new(type);
----

Який конструктор буде визиватися? Це блок `construct {}`, який буде описано в розділі про побудову в стилі `gobject`.

=== Динамічне приведення типів

Для динамічного приведення змінна доповнюється виразом постфікса `as DesiredTypeName`. Vala включить перевірку типу виконання, щоб переконатися, що цей кастинг є розумним - якщо це нелегальний кастинг, буде повернуто значення `null`. Однак для цього потрібно, щоб тип джерела, так і цільовий тип, були типами посилання.

Наприклад,

[source,vala]
----
Button b = widget as Button;
----

Якщо з якихось причин клас екземпляра віджета не є класом `Button` або одним із його підкласів, або не реалізує інтерфейс `Button`, `b` буде `null`. Цей кастинг еквівалентний:

[source,vala]
----
Button b = (widget is Button) ? (Button) widget : null;
----

=== Дженеріки

Vala включає систему дженериків часу виконання, за якою конкретний екземпляр класу може бути обмежений певним типом або набором типів, обраних під час створення. Це обмеження зазвичай використовується для того, щоб вимагати, щоб дані, що зберігаються в об'єкті, мали певний тип, наприклад, для реалізації списку об'єктів певного типу. У цьому випадку Vala має переконатись, що до списку можуть бути додані лише об'єкти запитуваного типу, і що при виборці всі об'єкти будуть приведені до цього типу.

У Vala дженерики обробляються під час роботи програми. Коли ви визначаєте клас, який може бути обмежений типом, існує лише один клас, але кожен примірник налаштовується індивідуально. Це відрізняється від C ++, що створює новий клас для кожного необхідного обмеження типу - Vala схожий на систему, що використовується Java. Це має різні наслідки, найголовніше: статичні члени загальні за типом у цілому, незалежно від обмежень, що ставляться до кожного екземпляра; і що для класу і підкласу, дженерік, уточнений підкласом, може бути використаний як загальний, уточнений класом.

Наступний код демонструє, як використовувати систему дженеріків для визначення мінімального класу обгортки:

[source,vala]
----
public class Wrapper<G> : GLib.Object {
    private G data;

    public void set_data(G data) {
        this.data = data;
    }

    public G get_data() {
        return this.data;
    }
}
----

Цей клас `Wrapper` повинен бути обмежений типом, щоб його інстанціювати - у цьому випадку тип буде ідентифікований як `G`, тому екземпляри цього класу будуть зберігати один об'єкт типу `G` та мати методи для встановки або отримання цього об’єкта. (Причиною цього конкретного прикладу є надання пояснення, що в даний час ддженерік клас не може використовувати властивості свого типу обмеження, і тому цей клас має прості методи отримання та встановлення.)

Для інстанцінації цього класу необхідно вибрати тип, наприклад вбудований тип `string` (у Vala немає обмежень щодо того, який тип може бути використаний у дженеріку). Щоб створити просто скористайтеся цим класом:

[source,vala]
----
var wrapper = new Wrapper<string>();
wrapper.set_data("test");
var data = wrapper.get_data();
----

Як бачите, коли дані витягуються з обгортки, вони присвоюються ідентифікатору без явного типу. Це можливо, тому що Vala знає, які об’єкти є у кожному екземплярі обгортки, і тому може зробити цю роботу за вас.

Те, що Vala не створює декілька класів із загального визначення, означає, що ви можете кодувати наступним чином:

[source,vala]
----
class TestClass : GLib.Object {
}

void accept_object_wrapper(Wrapper<Glib.Object> w) {
}

...
var test_wrapper = new Wrapper<TestClass>();
accept_object_wrapper(test_wrapper);
...
----

Оскільки всі екземпляри `TestClass` є також `Objects`, метод `accept_object_wrapper` з радістю прийме об'єкт, який йому передається, і буде розглядати його обгорнутий об'єкт, як екземпляр `GLib.Object`.

=== Побудова в стилі GObject

As pointed out before, Vala supports an alternative construction scheme that is slightly different to the one described before, but closer to the way GObject construction works. Which one you prefer depends on whether you come from the GObject side or from the Java or C# side. The gobject-style construction scheme introduces some new syntax elements: construct properties, a special Object(...) call and a construct block. Let's take a look at how this works:
Як було зазначено раніше, Vala підтримує альтернативну схему будівництва, яка дещо відрізняється від описаної раніше, але ближче до того, як працює будівництво `GObject`. Якій з них ви віддаєте перевагу, залежить від того, чи ви просуваєтесь зі сторони `GObject`, чи з боку Java чи C#. Схема побудови в стилі `gobject` вводить деякі нові елементи синтаксису: _властивості конструкції_, спеціальний виклик `Object (...)` та блок `construct`. Давайте розглянемо, як це працює:

[source,vala]
----
public class Person : Object {

    /* Властивості конструкції */
    public string name { get; construct; }
    public int age { get; construct set; }

    public Person(string name) {
        Object(name: name);
    }

    public Person.with_age(string name, int years) {
        Object(name: name, age: years);
    }

    construct {
        // робити все інше
        stdout.printf("Welcome %s\n", this.name);
    }
}
----

За схемою побудови у стилі `gobject` кожен метод побудови містить лише виклик `Object(...)` для встановлення так званих властивостей конструкції. Виклик `Object (...)` приймає змінну кількість названих аргументів у вигляді `властивість: значення`. Ці властивості повинні бути оголошені як властивості `construct` або `set`. Вони будуть встановлені в задані значення, і після цього будуть викликані всі блоки `construct {}` в ієрархії від `GLib.Object` до нашого класу.

Гарантовано, що блок `construct` викликається, коли створюється екземпляр цього класу, навіть якщо він створений як підтип. Він не має ані параметрів, ані зворотного значення. У цьому блоці ви можете викликати інші методи та встановити змінні-члени за потребою.

Властивості конструювання визначаються так само, як властивості `get` і `set`, і тому вони можуть виконувати довільний код при призначенні. Якщо вам потрібно зробити ініціалізацію на основі однієї властивості конструкції, можна написати властивий `construct` блок для властивості, який буде виконуватися негайно при призначенні та перед будь-яким іншим кодом побудови.

Якщо властивість конструкції оголошується без `set`, то це так звана властивість лише конструкції, це означає, що вона може бути призначена лише при побудові, але вже не після цього. У наведеному вище  прикладі `name` є такою властивістю лише часу конструкції.

Ось підсумок різних типів властивостей разом із номенклатурою, що як правило, міститься в документації бібліотек на основі `gobject`:

[source,vala]
----
    public int a { get; private set; }    // Read
    public int b { private get; set; }    // Write
    public int c { get; set; }            // Read / Write
    public int d { get; set construct; }  // Read / Write / Construct
    public int e { get; construct; }      // Read / Write-Construct-Only
----

У деяких випадках ви також можете виконати якусь дію - не тоді, коли створюються екземпляри класу, - але коли сам клас створений під час виконання `GObject`. У термінології `GObject` ми говоримо про фрагмент коду, який виконується всередині функції `class_init` для відповідного класу. У Java це відоме як статичні блоки ініціалізатора. У Vala це виглядає так:

[source,vala]
----
    /* Цей фрагмент коду виконується під час реєстрації
     * класу в системі типу */
    static construct {
      ...
    }
----

== Додаткові функції

=== Твердження та контрактне програмування

З твердженнями, програміст може перевіряти припущення під час виконання. Синтаксис - `assert(умова)`. Якщо твердження не справжнюється, програма завершиться відповідним повідомленням про помилку. Є ще кілька методів твердження в стандартному просторі імен `GLib`, наприклад:

[source,vala]
----
assert_not_reached()

return_if_fail(bool expr)

return_if_reached()

warn_if_fail(bool expr)

warn_if_reached()
----

Ви можете спокуситись використовувати твердження, щоб перевірити аргументи методу на `null`. Однак це не обов'язково, оскільки Vala робить це неявно для всіх параметрів, які не позначені `?` як можливий `null`.

[source,vala]
----
void method_name(Foo foo, Bar bar) {
    / * Не потрібно, Вала це робить за вас:
    return_if_fail(foo != null);
    return_if_fail(bar != null);
    */
}
----

Vala підтримує основні функції контрактного програмування. Метод може мати передумови (`requires`) та постумови (`ensures`), які повинні бути виконані на початку або в кінці методу відповідно:

[source,vala]
----
double method_name(int x, double d)
        requires (x > 0 && x < 10)
        requires (d >= 0.0 && d <= 1.0)
        ensures (result >= 0.0 && result <= 10.0)
{
    return d * x;
}
----

`result` - це спеціальна змінна, що представляє повернене значення.

=== Обробка помилок

GLib має систему управління винятками часу виконання, що називається `GError`. Vala переводить це у форму, звичну для сучасних мов програмування, але її реалізація означає, що вона не зовсім така, як у Java або C#. Важливо врахувати, коли використовувати цей тип обробки помилок - `GError` значною мірою спеціально розроблений для боротьби з помилками, що відновлюються, тобто факторами, які не відомі до запуску програми в реальній системі, і які не є фатальними для виконання . Не слід використовувати `GError` для проблем, які можна передбачити, наприклад, повідомлення про те, що методу передане недійсне значення. Якщо метод, наприклад, вимагає в якості параметра числа, що перевищує `0`, він повинен уникати негативних значень, використовуючи методи контрактного програмування, такі як передумови або твердження, описані в попередньому розділі.

Помилки Vala - це так звані перевірені винятки, що означає, що помилки повинні бути оброблені в певний момент. Однак якщо ви не виявите помилку, компілятор Vala видасть лише попередження, не зупиняючи процес компіляції.

Використання винятків (або помилок у термінології Vala) - це питання:

1) Заявити, що метод може призвести до помилки:

[source,vala]
----
void my_method() throws IOError {
    // ...
}
----

2) Викидання помилки, коли це доречно:

[source,vala]
----
if (something_went_wrong) {
    throw new IOError.FILE_NOT_FOUND("Requested file could not be found.");
}
----

3) Перехоплення помилки з коду виклику:

[source,vala]
----
try {
    my_method();
} catch (IOError e) {
    stdout.printf("Error: %s\n", e.message);
}
----

4) Порівняння коду помилки оператором `is`

[source,vala]
----
IOChannel channel;
try {
    channel = new IOChannel.file("/tmp/my_lock", "w");
} catch (FileError e) {
    if(e is FileError.EXIST) {
        throw e;
    }
    GLib.error("", e.message);
}
----

Все це виглядає більш-менш, як і в інших мовах, але визначення типів допущених помилок є досить унікальним. Помилки мають три компоненти, відомі як "домен", "код" та повідомлення. Повідомлення, які ми вже бачили, це просто фрагмент тексту, який надається при створенні помилки. Домени помилок описують тип проблеми та прирівнюється до підкласу `Exception` в Java або подібних. У наведених вище прикладах ми уявили домен помилки під назвою `IOError`. Третя частина, код помилки - це уточнення, що описує точну різноманітність виниклої проблеми. Кожен домен помилки має один або кілька кодів помилок - у прикладі є код під назвою `FILE_NOT_FOUND`.

Спосіб визначення цієї інформації про типи помилок пов'язаний з реалізацією в `glib`. Для того, щоб приклади тут працювали, потрібно таке визначення, як:

[source,vala]
----
errordomain IOError {
    FILE_NOT_FOUND
}
----

Під час перехоплення помилки ви надаєте домен помилок, в якому хочете перехопити помилки, і якщо помилка в цьому домені виникає, код у обробнику запускається з помилкою, присвоєною наданому імені. З цього об’єкта помилки ви можете отримати код помилки та повідомлення за потребою. Якщо ви хочете вловлювати помилки з більш ніж одного домену, просто надайте додаткові блоки вилову. Існує також необов'язковий блок, який можна розмістити після `try` та будь-яких `catch` блоки, `finally`. Цей код слід виконувати завжди в кінці розділу, незалежно від того, була помилка викинута чи виконані будь-які блоки перехоплення, навіть якщо помилка насправді не оброблялася та буде закинута знову. Це дозволяє, наприклад, звільняти будь-які ресурси, зарезервовані у блоці `try`, незалежно від будь-яких помилок. Повний приклад цих функцій:

[source,vala]
----
public errordomain ErrorType1 {
    CODE_1A
}

public errordomain ErrorType2 {
    CODE_2A,
    CODE_2B
}

public class Test : GLib.Object {
    public static void thrower() throws ErrorType1, ErrorType2 {
        throw new ErrorType1.CODE_1A("Error");
    }

    public static void catcher() throws ErrorType2 {
        try {
            thrower();
        } catch (ErrorType1 e) {
            // Робота з ErrorType1
        } finally {
            // Прибирати
        }
    }

    public static int main(string[] args) {
        try {
            catcher();
        } catch (ErrorType2 e) {
            // Робота з ErrorType2
            if (e is ErrorType2.CODE_2B) {
                // Попрацюйте з цим кодом
            }
        }
        return 0;
    }
}
----

У цьому прикладі є два домена помилок, обидві з яких можна перекинути методом `thrower`. `catcher` може згенерувати лише помилку другого типу, і так повинен владнати справи з першим типом, якщо `thrower` закидає його. Нарешті, метод `main` впорається з будь-якими помилками `catcher`.

=== Напрямок параметрів

Метод у Vala передається нульовим або більше аргументами. Поведінка за замовчуванням при виклику методу є наступним:

* Будь-які параметри типу значень копіюються у локальне місце для методу під час його виконання.
* Будь-які параметри типу посилання не копіюються, натомість методу просто передається посилання на них.

Ця поведінка може бути змінена за допомогою модифікаторів `ref` та `out`.

* `out` з боку викликаючого
ви можете передати методу неініціалізовану змінну і, можливо, очікуєте, що вона буде ініціалізована після повернення методу
* `out` для викликаного
параметр вважається неініціалізованим, і вам доведеться його ініціалізувати

* `ref` з боку викликаючого
змінна, яку ви передаєте методу, повинна бути ініціалізована, і вона може бути змінена  методом або ні
* `ref` для викликаного
параметр вважається ініціалізованим, і ви можете його змінити чи ні

[source,vala]
----
void method_1(int a, out int b, ref int c) { ... }
void method_2(Object o, out Object p, ref Object q) { ... }
----

Ці методи можна визвати наступним чином:

[source,vala]
----
int a = 1;
int b;
int c = 3;
method_1(a, out b, ref c);

Object o = new Object();
Object p;
Object q = new Object();
method_2(o, out p, ref q);
----

Обробка кожної змінної буде такою:

`a` - це значення типу. Значення буде скопійовано в нове місце пам'яті, локальне для методу, і тому зміни в ньому не будуть видні викликаючому.

`b` також має тип значення, але передається як параметр `out`. У цьому випадку значення не скопіюється, замість цього методу передається вказівник на дані, і тому будь-яке зміна параметра методу буде видимим для виклику коду.

`c` трактується так само, як `"b"`, єдина зміна полягає у сигналі про наміри методу.

`o` має тип посилання. Метод передається посиланням на той самий об'єкт, що і викликаюча сторона. Таким чином, метод може змінити цей об'єкт, але якщо він переприсвоїть параметр, ця зміна не буде видимою для абонента.

`p` того самого типу, але передається як параметр `out`. Це означає, що метод отримає вказівник на посилання на об'єкт. Тому він може замінити посилання на посилання на інший об'єкт, і коли метод повернеться, викликаючий замість старого повинен мати посилання на цей інший об'єкт. Якщо ви використовуєте цей тип параметрів, якщо ви не призначите нове посилання на параметр, він буде встановлений в `null`.

`q` знову того ж типу. Цей випадок трактується як `p` з важливими відмінностями у тому, що метод може не змінити посилання і може отримати доступ до об'єкта, на який посилається. Vala переконається, що в цьому випадку `q` насправді посилається на будь-який об'єкт, і воно не буде встановлено на `null`.

Ось приклад того, як реалізувати `method_1()`:

[source,vala]
----
void method_1(int a, out int b, ref int c) {
    b = a + c;
    c = 3;
}
----

Встановлюючи значення для аргументу `out b`, Vala переконається, що `b` не є `null`. Тож ви можете сміливо передавати `null` як другий аргумент `method_1()`, якщо вас це значення не цікавить.

== Колекції

Gee - бібліотека колекцій класів, написана у Vala. Усі класи повинні бути знайомі користувачам бібліотек, таких як Java Foundation Classes. Gee складається з набору інтерфейсів і різних типів, які по-різному реалізують їх.

Якщо ви хочете використовувати Gee у власному додатку, встановіть бібліотеку окремо у вашій системі. Gee можна отримати на http://live.gnome.org/Projects/Libgee[http://live.gnome.org/Projects/Libgee]. Щоб користуватися бібліотекою, ви повинні компілювати свої програми з `--pkg gee-0.8`.

Основними видами колекції є:

* Списки: впорядковані колекції предметів, доступні за числовим індексом.
* Набори: невпорядковані колекції без повторів.
* Мапи: Непорядкована колекція предметів, доступна за індексом довільного типу.

Усі списки та набори в бібліотеці реалізують інтерфейс `Collection`, та всі мапи - інтерфейсу `Map`. Списки також реалізують `List` та набори `Set`. Ці загальні інтерфейси означають не тільки те, що всі колекції подібного типу можуть використовуватися взаємозамінно, але і те, що нові колекції можна писати за допомогою тих самих інтерфейсів, і тому використовувати з існуючим кодом.

Також спільним для кожного типу `Collection` є інтерфейс `Iterable`. Це означає, що будь-який об’єкт у цій категорії можна повторити за допомогою стандартного набору методів або безпосередньо у Vala, використовуючи синтаксис `foreach`.

Усі класи та інтерфейси використовують систему дженеріків. Це означає, що вони повинні бути реалізовані з примірниками певного типу або набору типів, які вони будуть містити. Система гарантуватиме, що до колекцій можуть бути покладені лише призначені типи, а також, що коли об'єкти будуть отримані, вони повернуться як правильний тип.

http://valadoc.org/gee-0.8/index.htm[Повна документація Gee API], https://wiki.gnome.org/Projects/Vala/GeeSamples[Приклади Gee]

Деякі важливі класи Gee:

==== ArrayList<G>

Реалізує: `Iterable<G>`, `Collection<G>`, `List<G>`

Впорядкований список елементів типу `G`, підкріплений масивом, що динамічно змінюється. Цей тип дуже швидкий для доступу до даних, але потенційно повільний при вставці елементів де-небудь, крім кінця, або при вставці елементів, коли внутрішній масив заповнений.

==== HashMap<K,V>

Реалізує: `Iterable<Entry<K,V>>`, `Map<K,V>`

Відбраження 1:1 від елементів типу `K` до елементів типу `V`. Відображення проводиться шляхом обчислення хеш-значення для кожного ключа - це можна налаштувати шляхом надання покажчиків на функції хешування та тестування рівності ключів певними способами.

Ви можете опціонально передавати конструктору власні функції хешу та рівності, наприклад:

[source,vala]
----
var map = new Gee.HashMap<Foo, Object>(foo_hash, foo_equal);
----

Для рядків і цілих чисел функції хешу і рівності виявляються автоматично, об'єкти відрізняються за посиланнями за замовчуванням. Ви повинні забезпечити користувацькі функції хешу і рівності, лише якщо ви хочете змінити поведінку за замовчуванням.

==== HashSet<G>

Реалізує: `Iterable<G>`, `Collection<G>`, `Set<G>`

Набір елементів типу `G`. Дублікати виявляються за допомогою обчислення хеш-значення для кожного ключа - це можна налаштувати, надаючи покажчики функції хешування та тестуючи рівність ключів певними способами.

==== Перегляди лише для читання

Ви можете отримати представлення колекції лише для читання за допомогою властивості `read_only_view`, наприклад, `my_map.read_only_view`. Це поверне обгортку, яка має той самий інтерфейс, що і її первинна колекція, але не дозволить будь-якої форми модифікації або будь-якого доступу до вміщеної колекції.

=== Методи з підтримкою синтаксису

Vala розпізнає деякі методи з певними іменами та підписами та надає їм підтримку синтаксису. Наприклад, якщо тип містить метод `contains()`, об'єкти цього типу можуть використовуватися з оператором `in`. У наступній таблиці перераховані ці спеціальні методи. `T` і `Tn` є лише заповнювачами типів у цій таблиці і повинні бути замінені реальними типами.

==== Індексатори

`T2 get(T1 index)` індексний доступ: `obj[index]`

`void set(T1 index, T2 item)` індексне призначення: `obj[index] = item`

==== Індексатори з декількома індексами

`T3 get(T1 index1, T2 index2)` індексний доступ: `obj[index1, index2]`

`void set(T1 index1, T2 index2, T3 item)` індексне призначення: `obj[index1, index2] = item`

(... і так далі для отримання додаткових індексів)

==== Інші

`T slice(long start, long end)` фрагментація: `obj[start:end]`

`bool contains(T needle)` оператор `in`: `bool b = needle in obj`

`string to_string()` підтримка через рядкові шаблони: `@"$obj"`

`Iterator iterator()` інерабельне через `foreach`

`T1 size { get; }`  інерабельне через `foreach`

Тип `Iterator` може мати будь-яке ім'я і повинен реалізувати один з цих двох протоколів:

`bool next()`, `T get()` стандартний протокол ітератора: ітерація, поки `.next()` не поверне значення `false`. Поточний елемент витягується через `.get()`.

`T? next_value()` альтернативний протокол ітератора: якщо об’єкт ітератора має функцію `.next_value()`, яка повертає null-здатний тип, то ми повторюємо, викликаючи цю функцію, поки вона не поверне `null`.

Цей приклад реалізує деякі з цих методів:

[source,vala]
----
public class EvenNumbers {
    public int get(int index) {
        return index * 2;
    }

    public bool contains(int i) {
        return i % 2 == 0;
    }

    public string to_string() {
        return "[This object enumerates even numbers]";
    }

    public Iterator iterator() {
        return new Iterator(this);
    }

    public class Iterator {
        private int index;
        private EvenNumbers even;

        public Iterator(EvenNumbers even) {
            this.even = even;
        }

        public bool next() {
            return true;
        }

        public int get() {
            this.index++;
            return this.even[this.index - 1];
        }
    }
}

void main() {
    var even = new EvenNumbers();
    stdout.printf("%d\n", even[5]);   // get()
    if (4 in even) {                  // contains()
        stdout.printf(@"$even\n");    // to_string()
    }
    foreach (int i in even) {         // iterator()
        stdout.printf("%d\n", i);
        if (i == 20) break;
    }
}
----

== Багатопоточність

=== Потоки у Vala

Програма, написана у Vala, може мати кілька потоків виконання, що дозволяє їй робити більше, ніж одну справу. Точно, як цим керувати, виходить за межі Vala - потоки можуть мати спільне ядро ​​процесора чи ні, залежно від середовища.

Потік у Vala не визначається під час компіляції, натомість це просто частина коду Vala, яку вимагають під час виконання виконувати як новий потік. Це робиться за допомогою статичних методів класу `Thread` в GLib, як показано в наступному (дуже спрощеному) прикладі:

[source,vala]
----
void* thread_func() {
    stdout.printf("Thread running.\n");
    return null;
}

int main(string[] args) {
    if (!Thread.supported()) {
        stderr.printf("Cannot run without threads.\n");
        return 1;
    }

    try {
        Thread.create(thread_func, false);
    } catch (ThreadError e) {
        return 1;
    }

    return 0;
}
----

Ця коротка програма запитує створення та виконання нового потоку. Код, який слід запустити, знаходиться в `thread_func`. Також зверніть увагу на тест на початку методу `main` - програма Vala не зможе використовувати потоки, якщо не буде скомпільована належним чином, тож якщо ви побудуєте цей приклад звичайним способом, він просто відобразить помилку і перестане працювати. Можливість перевірити підтримку потоку під час виконання дозволяє будувати програму для запуску з потоками або без них, як треба. Для того, щоб побудувати з підтримкою потоку, запустіть:

[source,vala]
----
$ valac --thread threading-sample.vala
----

Це буде включати необхідні бібліотеки та забезпечити ініціалізацію системи потоків, коли це можливо.

Тепер програма буде працювати без помилок сегментації, але вона все ще не буде діяти так, як очікувалося. Без будь-якого циклу подій програма Vala припиняється, коли закінчується її основний потік (той, що створений для запуску `main`). Щоб контролювати таку поведінку, ви можете дозволити потокам співпрацювати. Це можна зробити потужно за допомогою циклів подій та асинхронних черг, але в цьому вступі до потоків ми просто покажемо основні можливості потоків.

Потік може сказати системі, що в даний момент його немає необхідності виконувати, і тим самим запропонувати замість цього запустити інший потік. Це робиться за допомогою статичного методу `Thread.yield()`. Якщо це твердження було розміщено в кінці вищезгаданого методу `main`, система часу виконання призупинить основний потік і перевірить, чи є інші потоки, які можна запустити - після знаходження новоствореного потоку в стані, який можна виконати, він буде запустіть це замість нього, поки він не буде закінчений - і програма діятиме так, як здається, повинна. Однак немає гарантії, що це все ж таки відбудеться. Система здатна вирішувати, коли запускаються потоки, і, як такий, може не дозволити новому потоку закінчитися до перезапуску первинного потоку та закінчення програми.

Для того, щоб чекати, коли нитка повністю закінчиться, існує метод `join()`. Виклик цього методу на об'єкті `Thread` змушує викликаючий потік зачекати, поки закінчиться інший потік, перш ніж продовжувати. Це також дозволяє потоку отримувати повернене значення іншого, якщо це корисно. Щоб реалізувати з'єднувальні нитки:

[source,vala]
----
try {
    unowned Thread thread = Thread.create(thread_func, true);
    thread.join();
} catch (ThreadError e) {
    return 1;
}
----

Цього разу, коли ми створюємо потік, ми додаємо `true` як останній аргумент. Це позначає нитку як "приєднану". Ми також пам’ятаємо значення, повернене в результаті створення - `unowned` посилання на об’єкт `Thread` (`unowned` посилання пояснюються пізніше і не є життєво важливими для цього розділу.) За допомогою цього посилання можна приєднати новий потік до первинного потоку. З цією версією програми гарантується, що новоствореному потоку буде дозволено повністю виконатись до продовження первинного потоку та припинення програми.

Усі ці приклади мають потенційну проблему в тому, що новостворений потік не знає контексту, в якому він повинен працювати. У C ви б надали методу створення потоку деякі дані, у Vala замість статичного методу ви зазвичай передаєте метод екземпляра `Thread.create`.

=== Контроль ресурсів

Кожного разу, коли одночасно виконується більше ніж один потік виконання, є ймовірність, що дані мають одночасний доступ. Це може призвести до умов перегонів, де результат залежить від того, коли система вирішить перемикатися між потоками.

Щоб контролювати цю ситуацію, ви можете використовувати ключове слово `lock`, щоб гарантувати, що певні блоки коду не будуть перервані іншими потоками, яким потрібно отримати доступ до тих самих даних. Найкращий спосіб показати це, мабуть, на прикладі:

[source,vala]
----
public class Test : GLib.Object {

    private int a { get; set; }

    public void action_1() {
        lock (a) {
            int tmp = a;
            tmp++;
            a = tmp;
        }
    }

    public void action_2() {
        lock (a) {
            int tmp = a;
            tmp--;
            a = tmp;
        }
    }
}
----

Цей клас визначає два методи, коли обом потрібно змінити значення `a`. Якби тут не було записів про блокування, вказівки в цих методах могли б переплестись, і отримана зміна на `а` була б фактично випадковою. Оскільки тут є заяви про блокування, Vala гарантує, що якщо одна нитка заблокувала `a`, інший потік, який потребує такого ж блокування, повинен буде дочекатися своєї черги.

У Vala можна лише заблокувати члени об'єкта, який виконує код. Це може здатися головним обмеженням, але насправді стандартне використання цієї методики повинно включати класи, які індивідуально відповідають за управління ресурсом, і тому все блокування дійсно буде внутрішнім для класу. Так само, у наведеному вище прикладі всі звернення до `а` інкапсульовані у класі.

=== Основний цикл

GLib включає систему для запуску циклу подій у класах навколо `MainLoop`. Призачення цієї системи - дозволити вам написати програму, яка чекає подій та реагує на них, замість того, щоб постійно перевіряти умови. Це модель, яку використовує GTK +, щоб програма могла чекати взаємодії з користувачем, не виконуючи жодного поточного коду.

Наступна програма створює та запускає `MainLoop`, а потім додає до нього джерело подій. У цьому випадку джерелом є простий таймер, який виконає даний метод через 2000 мс. Метод насправді просто зупинить основний цикл, який у цьому випадку вийде з програми.


[source,vala]
----
void main() {

    var loop = new MainLoop();
    var time = new TimeoutSource(2000);

    time.set_callback(() => {
        stdout.printf("Time!\n");
        loop.quit();
        return false;
    });

    time.attach(loop.get_context());

    loop.run();
}
----

При використанні GTK + основний цикл буде створений автоматично, і він буде запущений при виклику методу `Gtk.main()`. Це означає, що програма готова запуститись і почати приймати події від користувача чи з іншого джерела. Код в GTK + еквівалентний короткому прикладу, наведеному вище, і тому ви можете додавати джерела подій приблизно так само, хоча, звичайно, вам потрібно використовувати методи GTK+ для управління основним циклом.

[source,vala]
----
void main(string[] args) {

    Gtk.init(ref args);
    var time = new TimeoutSource(2000);

    time.set_callback(() => {
        stdout.printf("Time!\n");
        Gtk.main_quit();
        return false;
    });

    time.attach(null);

    Gtk.main();
}
----

Поширена вимога програм GUI полягає в тому, щоб виконувати якийсь код якомога швидше, але лише тоді, коли він не заважатиме користувачеві. Для цього ви використовуєте екземпляри `IdleSource`. Вони надсилають події в основний цикл програм, але вимагають, щоб з вони розглядалися лише тоді, коли нема нічого важливішого.

Для отримання додаткової інформації про циклі подій див. Документацію GLib та GTK+.

=== Асинхронні методи

Асинхронні методи - це методи, виконання яких можна призупинити та відновити під контролем програміста. Вони часто використовуються в головному потоці програми, де методу потрібно чекати, коли зовнішнє повільне завдання завершиться, але не повинно перешкоджати іншій обробці. (Наприклад, одна повільна робота не повинна заморожувати весь графічний інтерфейс). Коли методу доводиться чекати, він повертає керування процесором назад своєму абоненту (тобто він поступається), але він впорядковує виклик для відновлення виконання, коли дані стануть готовими. Зовнішні повільні завдання, які можуть чекати методи асинхронізації, включають: очікування даних з віддаленого сервера або очікування завершення обчислень в іншому потоці або очікування завантаження даних з дискового прикладу.

Асинхронні методи, як правило, використовуються для основного циклу GLib, оскільки зворотні виклики використовуються для обробки деяких внутрішніх зворотних викликів. Однак за певних умов `async` може використовуватися без основного циклу GLib, наприклад, якщо методи асинхронізації завжди поступаються, а `Idle.add()` ніколи не використовується. (FIXME: Перевірте, які точні умови).

Асинхронні методи призначені для переплетення обробки багатьох різних довготривалих операцій у межах однієї нитки. Вони самі по собі не розподіляють навантаження на різні нитки. Однак метод асинхронізації може бути використаний для керування фоновою ниткою та дочекання її завершення або для виконання операцій черги для обробки фонового потоку.

Методи асинхронізації у Vala використовують бібліотеку GIO для обробки зворотних викликів, тому повинні бути побудовані за допомогою параметра `--pkg = gio-2.0`.

Асинхронний метод визначається за допомогою ключового слова `async`. Наприклад:

[source,vala]
----
  async void display_jpeg(string fnam) {
// Завантажте JPEG у фонову нитку та відображайте його при завантаженні
     [...]
  }
----

або:

[source,vala]
----
  async int fetch_webpage(string url, out string text) throws IOError {
// Виберіть веб-сторінку асинхронно, і коли будете готові, поверніть
// код статусу HTTP та вміст сторінки помістіть у "текст"
     [...]
     text = result;
     return status;
  }
----

Метод може приймати аргументи і повертати значення, як і будь-який інший метод. Він може в будь-який час використовувати `yield`, щоб повернути керування процесором своєму абоненту.

Метод `async` може бути викликаний будь-якою з цих двох форм:

[source,vala]
----
  display_jpeg.begin("test.jpg");
  display_jpeg.begin("test.jpg", (obj, res) => {
      display_jpeg.end(res);
  });
----

Обидві форми запускають метод асинхронізації, що працює із заданими аргументами. Крім того, друга форма реєструє `AsyncReadyCallback`, який виконується після завершення методу. Зворотний виклик бере в якості аргументів вихідний об'єкт, `obj`, та екземпляр `GAyncResult`, `res`. У зворотному виклику повинен бути викликаний метод `.end()`, щоб отримати значення повернення асинхронного методу, якщо він має його. Якщо метод асинхронізації може кинути виняток, виклик `.end()` - це місце, де виняток надходить, і його потрібно спіймати. Якщо у методу є `out` аргументи, їх слід опустити з виклику `.begin()` і замість цього додати до виклику `.end()`.

Наприклад:

[source,vala]
----
  fetch_webpage.begin("http://www.example.com/", (obj, res) => {
      try {
          string text;
          var status = fetch_webpage.end(res, out text);
// Результат виклику в тексті та в статусі ...
      } catch (IOError e) {
// Проблема ...
      }
  });
----

Коли асинхронний метод починає працювати, він бере контроль над процесором до тих пір, поки не досягне своєї першої заяви `yield` про вихід, після чого повертається до абонента. Коли метод відновлено, він продовжує виконання відразу після цього твердження про вихід. Існує кілька загальних способів використання `yield`:

Ця форма відмовляється від контролю, але впорядковує, щоб основний цикл GLib відновив метод, коли немає більше подій для обробки:

[source,vala]
----
  Idle.add(fetch_webpage.callback);
  yield;
----

Ця форма відмовляється від керування та зберігає дані про зворотний виклик для іншого коду, який слід використовувати для відновлення виконання методу:

[source,vala]
----
  SourceFunc callback = fetch_webpage.callback;
  [... store 'callback' somewhere ...]
  yield;
----

Деякий код в іншому місці тепер повинен викликати збережений `SourceFunc`, щоб метод відновився. Це можна зробити, запланувавши основний цикл GLib для його запуску:

[source,vala]
----
  Idle.add((owned) callback);
----

або альтернативно, може здійснюватися прямий виклик, якщо абонент працює в основному потоці:

[source,vala]
----
  callback();
----

Якщо використовується прямий виклик, зазначений вище, то відновлений асинхронний метод негайно приймає контроль над процесором і працює до наступного виходу `yield`, перш ніж повернутися до коду, який виконував `callback()`. Метод `Idle.add()` корисний, якщо зворотний виклик повинен здійснюватися з фонового потоку, наприклад відновити метод асинхронізації після завершення деякої фонової обробки. (Твердження `(owned)` необхідне, щоб уникнути попередження про копіювання делегатів).

Третій поширений спосіб використання `yield` - це виклик іншого асинхронного методу, наприклад:

[source,vala]
----
  yield display_jpeg(fnam);
----

або

[source,vala]
----
  var status = yield fetch_webpage(url, out text);
----

В обох випадках метод виклику відмовляється від управління процесором і не поновлюється до завершення викликаного методу. Твердження `yield` автоматично реєструє зворотний виклик методом виклику, щоб переконатися, що абонент поновлюється правильно. Автоматичний зворотний виклик також отримує повернене значення від викликаного методу.

Коли цей оператор `yield` виконується, керування процесором спочатку переходить до викликаного методу, який працює до його першого `yield`, а потім переходить до виклику методу, який сам завершує `yield`, а потім повертає управління власному виклику.

==== Приклади

Див. https://wiki.gnome.org/Projects/Vala/AsyncSamples[Зразки методів асинхронізації] для прикладів різних способів використання `async`.

=== Слабкі посилання

Управління пам'яттю Vala засноване на автоматичному підрахунку посилань. Кожного разу, коли об'єкт присвоюється змінній, його внутрішній лічильник посилань збільшується на 1, кожен раз, коли змінна, що посилається на об'єкт, виходить за межі, його внутрішній лічильник посилання зменшується на 1. Якщо число посилань досягає 0, об'єкт буде звільнений.

Однак можна створити циклічні посилання зі своїми структурами даних. Наприклад, зі структурою даних дерев, де дочірній вузол містить посилання на його батьківський і навпаки, або подвійно пов'язаний список, де кожен елемент містить посилання на свого попередника, а попередник містить посилання на свого наступника.

У цих випадках об'єкти можуть залишатися живими, просто посилаючись один на одного, хоча вони повинні бути звільнені. Для розірвання такого циклу посилань можна використовувати модифікатор `weak` для однієї з посилань:

[source,vala]
----
class Node {
    public weak Node prev;
    public Node next;
}
----

Ця тема детально пояснена на цій сторінці: https://wiki.gnome.org/Projects/Vala/ReferenceHandling[Пояснення управління пам’яттю Vala].

=== Власність

==== Нічийні посилання

Зазвичай при створенні об'єкта у Vala вам повертається посилання на нього. Зокрема, це означає, що, незважаючи на те, що він передається вказівником на об'єкт в пам'яті, він також записує в самому об'єкті, що цей покажчик існує. Аналогічно, щоразу, коли створюється інше посилання на об'єкт, це також записується. Оскільки об’єкт знає, скільки посилань на нього є, він може бути автоматично видалений при необхідності. Це основа управління пам’яттю Vala.

==== Власність методів

Нічийні посилання навпаки не реєструються в об'єкті, на який вони посилаються. Це дозволяє вилучити об'єкт, коли це буде логічно, незалежно від того, що на нього все ще можуть бути посилання. Звичайний спосіб досягти цього - це метод, визначений для повернення нічийного посилання, наприклад:

[source,vala]
----
class Test {
    private Object o;

    public unowned Object get_unowned_ref() {
        this.o = new Object();
        return this.o;
    }
}
----

Для виклику цього методу, щоб отримати посилання на повернутий об'єкт, потрібно очікувати отримання слабкої посилання:

[source,vala]
----
unowned Object o = get_unowned_ref();
----

Причина цього, здавалося б, складного прикладу через концепцію власності.

Якщо `Object o` не зберігався у класі, тоді, коли метод `get_unowned_ref` повернувся, `o` стане нічийним (тобто на нього не було б посилань). Якби це було так, об’єкт буде видалено, і метод ніколи не повертав дійсне посилання.

Якщо значення повернення не було визначено як `unowned`, право власності перейшло б до коду виклику. Однак код виклику очікує `unowned` посилання, яке не може отримати право власності.

Якщо код виклику записаний як

[source,vala]
----
Object o = get_unowned_ref();
----

Vala намагатиметься отримати посилання або копію екземпляра, на яку вказує `unowned` посилання.

==== Власності на властивості 

На відміну від звичайних методів властивості завжди мають `unowned` значення повернення. Це означає, що ви не можете повернути новий об’єкт, створений у методі `get`. Це також означає, що ви не можете використовувати `owned` повернене значення з виклику методу. Дещо дратівливий факт пояснюється тим, що значення властивості належить об'єкту, який має цю власність. Виклик для отримання цього значення властивості не повинен красти або відтворювати (шляхом дублювання або збільшення опорного числа) значення з боку об'єкта.

Наступний приклад призведе до помилки компіляції

[source,vala]
----
public Object property {
    get {
        return new Object();   
// НЕВІРНО: властивість повертає unowned посилання,
// новостворений об’єкт буде видалено, коли
// область геттера закінчує виклик
// геттера матиме отримання недійсного посилання
// до видаленого об’єкта.
    }
}
----

і також не можна робити цього

[source,vala]
----
public string property {
    get {
        return getter_method();   
// НЕВІРНО: з тієї ж причини вище.
    }
}

public string getter_method() {
    return "some text"; 
// "some text" дублюється і повертається в цей момент.
}
----

з іншого боку, це цілком добре

[source,vala]
----
public string property {
    get {
        return getter_method();   
// ГАРНО: getter_method повертає unowned значення
    }
}

public unowned string getter_method() {
    return "some text";
// Не турбуйтеся, що текст не присвоєний жодній сильній змінній.
// Літеральні рядки у Vala завжди належать самому програмному модулю,
// і існують до тих пір, поки модуль знаходиться в пам'яті
}
----

Модифікатор `unowned` можна використовувати для автоматичного зберігання сховища власності. Це означає

[source,vala]
----
public unowned Object property { get; private set; }
----

тотожне

[source,vala]
----
private unowned Object _property;

public Object property {
    get { return _property; }
}
----

Ключове слово `owned` може бути використане для конкретного запиту властивості для повернення власного посилання на значення, внаслідок чого значення властивості відтворюється на стороні об'єкта. Подумайте двічі, перш ніж додавати ключове слово `owned`. Це властивість чи просто метод `get_xxx`? Також можуть виникнути проблеми у вашому дизайні. У будь-якому разі наступний код - це коректний сегмент,

[source,vala]
----
public owned Object property { owned get { return new Object(); } }
----

`Unowned` посилання грають схожу роль на покажчики, описані раніше. Однак вони набагато простіші у використанні, ніж покажчики, оскільки їх можна легко перетворити на звичайні посилання. Однак в цілому вони не повинні широко використовуватися в програмах, якщо ви не знаєте, що робите.

==== Передача власності

Ключове слово `owned` використовується для передачі права власності.

Як префікс типу параметра він означає, що право власності на об'єкт передається в цей контекст коду.

Як оператор перетворення типів, його можна використовувати, щоб уникнути дублювання нереференційних класів підрахунку, що, як правило, у Vala неможливо. Наприклад,

[source,vala]
----
Foo foo = (owned) bar;
----

Це означає, що `bar` буде встановлено на `null`, а `foo` успадковує посилання/право власності на посилання об'єкта `bar`.

=== Списки аргументів змінної довжини

Vala підтримує списки аргументів змінної довжини у стилі C ("varargs") для методів. Вони оголошуються еліпсисом (`"..."`) у сигнатурі методу. Метод з `varargs` вимагає принаймні одного фіксованого аргументу:

[source,vala]
----
void method_with_varargs(int x, ...) {
    var l = va_list();
    string s = l.arg();
    int i = l.arg();
    stdout.printf("%s: %d\n", s, i);
}
----

У цьому прикладі `х` є фіксованим аргументом для задоволення вимог. Список `varargs` ви отримуєте з `va_list()`. Потім ви можете отримати аргументи один за одним, викликаючи дженерік метод `arg<T>()` послідовно у цьому списку, причому `T` є типом, який слід інтерпретувати як аргумент. Якщо тип очевидний з контексту (як у нашому прикладі), тип виводиться автоматично, і ви можете просто викликати `arg()` без дженерік-аргументу типу.

Цей приклад аналізує довільну кількість пар аргументів `string?`-`double`  :

[source,vala]
----
void method_with_varargs(int fixed, ...) {
    var l = va_list();
    while (true) {
        string? key = l.arg();
        if (key == null) {
            break;  // end of the list
        }
        double val = l.arg();
        stdout.printf("%s: %g\n", key, val);
    }
}

void main() {
    method_with_varargs(42, "foo", 0.75, "bar", 0.25, "baz", 0.32);
}
----

Він перевіряє на `null` як на орієнтир, щоб визнати кінець списку `varargs`. Vala завжди неявно передає `null` як останній аргумент виклику методу `varargs`.

`Varargs` мають серйозний недолік, про який слід пам’ятати: вони не є безпечними по типу. Компілятор не може сказати вам, передаєте ви методу аргументи правильного типу чи ні. Ось чому ви повинні розглянути можливість використання `varargs` лише у випадку, коли у вас є вагомі причини, наприклад: надання зручності для програмістів C за допомогою вашої бібліотеки Vala, прив’язуючи функцію C. Часто аргумент масиву є кращим вибором.

Поширений зразок з `varargs` - це очікувати чергування пар рядків-значень як аргументів, що зазвичай означає властивість `gobject` - значення. У цьому випадку ви можете замість цього записати властивість: значення, напр .:

[source,vala]
----
actor.animate (AnimationMode.EASE_OUT_BOUNCE, 3000, x: 100.0, y: 200.0, rotation_angle_z: 500.0, opacity: 0);
----

еквівалентно:

[source,vala]
----
actor.animate (AnimationMode.EASE_OUT_BOUNCE, 3000, "x", 100.0, "y", 200.0, "rotation-angle-z", 500.0, "opacity", 0);
----

=== Покажчики

Покажчики - це спосіб Vala, що дозволяє вручну керувати пам'яттю. Зазвичай, коли ви створюєте екземпляр типу, ви отримуєте посилання на нього, і Vala подбає про знищення екземпляра, коли на нього не залишиться більше посилань. Запросивши замість цього вказівник на екземпляр, ви берете на себе відповідальність за знищення екземпляра, коли він більше не потрібен, і, отже, отримуєте більший контроль над тим, скільки пам'яті використовується.

Ця функціональність не обов'язково потрібна більшу частину часу, оскільки сучасні комп'ютери, як правило, досить швидкі для обліку підрахунку посилань, і мають достатню кількість пам'яті, що трохи неефективності не завадить. Випадки, коли ви можете вдатися до ручного управління пам'яттю, такі:

* Коли ви конкретно хочете оптимізувати частину програми, і `unowned` посилань недостатньо.
* Коли ви маєте справу із зовнішньою бібліотекою, яка не реалізує підрахунок посилань для управління пам'яттю (можливо, це означає, що вона не заснована на `gobject`).

Щоб створити екземпляр типу та отримати вказівник на нього:

[source,vala]
----
Object* o = new Object();
----

Для доступу до членів цього примірника:

[source,vala]
----
o->method_1();
o->data_1;
----

Щоб звільнити пам'ять по показчику:

[source,vala]
----
delete o;
----

Vala також підтримує оператори адреси (`&`) та розіменування (`*`), відомі з C:

[source,vala]
----
int i = 42;
int* i_ptr = &i;    // отримати адресу
int j = *i_ptr;     // розіменування
----

Поведінка трохи відрізняється від типів посилань. Ви можете опустити оператор адреси та розіменування при призначенні:

[source,vala]
----
Foo f = new Foo();
Foo* f_ptr = f;    // отримати адресу
Foo g = f_ptr;     // розіменування

unowned Foo f_weak = f;  // еквівалент другого рядка
----

Використання покажчиків референсного типу еквівалентно використанню `unowned` посилань.

=== Необ'єктні класи

Класи, визначені як такі, що не походять з `GLib.Object`, трактуються як окремий випадок. Вони отримані безпосередньо з системи типів GLib, і тому набагато легші за вагою. У більш пізньому компіляторі Vala можна також реалізувати інтерфейси, сигнали та властивості з цими класами.

Один очевидний випадок використання цих `non-Object` класів залишається у прив'язках `GLib`. Оскільки `GLib` знаходиться на нижчому рівні, ніж `GObject`, більшість класів, визначених у зв'язуванні, є такого роду. Також, як згадувалося раніше, менша вага класів, що не є об'єктами, робить їх корисними у багатьох практичних ситуаціях (наприклад, сам компілятор Vala). Однак детальне використання класів, що не належать до об'єктів, виходять за межі цього підручника. Майте на увазі, що ці класи принципово відрізняються від структур.

=== Інтеграція D-Bus

D-Bus тісно інтегрований у мову і ніколи не був простішим, ніж з Vala.

To export a custom class as a D-Bus service you just need to annotate it with the DBus code attribute and register an instance of this class with your local D-Bus session.
Щоб експортувати спеціальний клас як послугу D-Bus, вам просто потрібно анотувати його атрибутом коду DBus та зареєструвати екземпляр цього класу в локальному сеансі D-Bus.

[source,vala]
----
[DBus(name = "org.example.DemoService")]
public class DemoService : Object {
/* Приватне поле, не експортується через D-Bus */
    int counter;

/* Загальнодоступне поле, не експортується через D-Bus */
    public int status;

/* Публічеа власність, експортована через D-Bus */
    public int something { get; set; }

/* Загальнодоступний сигнал, експортований через D-Bus
*  Може випромінюватися на стороні сервера і може
*  бути підключено до клієнтської сторони.
*/
    public signal void sig1();

/* Публічний метод, експортований через D-Bus */
    public void some_method() {
        counter++;
        stdout.printf("heureka! counter = %d\n", counter);
        sig1();  // подати сигнал
    }

/* Публічний метод, експортований через D-Bus та показує відправника, хто це
*  викликає метод (не експортується в інтерфейс D-Bus) 
*/
    public void some_method_sender(string message, GLib.BusName sender) {
        counter++;
        stdout.printf("heureka! counter = %d, '%s' message from sender %s\n",
                      counter, message, sender);
    }
}
----

Зареєструйте примірник служби та запустіть основний цикл:

[source,vala]
----
void on_bus_aquired (DBusConnection conn) {
    try {
// запустити сервіс та зареєструвати його як об’єкт dbus
        var service = new DemoService();
        conn.register_object ("/org/example/demo", service);
    } catch (IOError e) {
        stderr.printf ("Could not register service: %s\n", e.message);
    }
}

void main () {
// спроба зареєструвати ім’я служби в шині сеансу
    Bus.own_name (BusType.SESSION, "org.example.DemoService", /* ім'я реєстрації */
                  BusNameOwnerFlags.NONE, /* прапорці */
                  on_bus_aquired, /* колбек вдалої реєстрації */
                  () => {}, /* колбек вдалої реєстрації імені */
                  () => stderr.printf ("Could not acquire name\n"));
                                                     /* колбек втрати імені */

    // запуск головного циклу
    new MainLoop ().run ();
}
----

Ви повинні зібрати цей приклад з пакетом `gio-2.0`:

[source,bash]
----
$ valac --pkg gio-2.0 dbus-demo-service.vala
$ ./dbus-demo-service
----

Усі імена членів автоматично додаються до імені D-Bus CamelCase від імені D-Bus, що визначає назву D-Bus. Експортований інтерфейс D-Bus у цьому прикладі матиме властивість `Something`, сигнал `Sig1` та метод `SomeMethod`. Ви можете відкрити нове вікно терміналу та викликати метод із командного рядка за допомогою:

[source,bash]
----
$ dbus-send --type=method_call                   \
            --dest=org.example.DemoService       \
            /org/example/demo                    \
            org.example.DemoService.SomeMethod
----

або

[source,bash]
----
$ dbus-send --type=method_call                   \
            --dest=org.example.DemoService       \
            /org/example/demo                    \
            org.example.DemoService.SomeMethodSender \
            string:'hello world'
----

Ви також можете використовувати графічний налагоджувач D-Bus на зразок D-Feet для перегляду інтерфейсів D-Bus та методів виклику.

Деякі вичерпні приклади: зразки клієнта DBus та вибірки сервера DBus

=== Профілі

Vala підтримує декілька різних профілів:

----
gobject (default)
posix
dova
----

Профіль визначає, які мовні функції доступні та від яких бібліотек залежатиме отриманий C-код.

Щоб вибрати інший профіль, використовуйте перемикач `valac --profile`, наприклад:

[source,bash]
----
valac --profile=posix somecode.vala
----

== Експериментальні можливості 

Деякі особливості Vala експериментальні. Це означає, що вони не пройшли повну перевірку і можуть зазнати змін у майбутніх версіях.

=== Зціплені реляційні вирази

Ця функція дозволяє записувати складні реляційні вирази на зразок

[source,vala]
----
if (1 < a && a < 5) {}

if (0 < a && a < b && b < c && c < d && d < 255) {
// робити щось
}
----

більш природним чином:

[source,vala]
----
if (1 < a < 5) {}

if (0 < a < b < c < d < 255) {
// робити щось
}
----

=== Літерали регулярних виразів

Регулярні вирази - це потужна техніка зіставлення шаблонів у рядках. Vala має експериментальну підтримку літералів регулярного виразу (`/ regex /`). Приклад:

[source,vala]
----
string email = "tux@kernel.org";
if (/^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i.match(email)) {
    stdout.printf("Valid email address\n");
}
----

Заключе `i` робить вираз нечутливим до реєстру. Ви можете зберігати регулярний вираз у змінній типу `Regex`:

[source,vala]
----
Regex regex = /foo/;
----

Приклад виразу заміни:

[source,vala]
----
var r = /(foo|bar|cow)/;
var o = r.replace ("this foo is great", -1, 0, "thing");
print ("%s\n", o);
----

Наступні символи можуть бути використані:

* `i`, літери в шаблоні збігаються як з великої, так і малої літери
* `m`, конструкції "початок рядка" і "кінець рядка" збігаються безпосередньо після будь-якого нового рядка в рядку відповідно, а також на самому початку і в кінці.
* `s`, точковий метасимвол, у шаблоні збігаються всі символи, включаючи нові рядки. Без нього виключаються нові рядки.
* `x`, символи даних пробілів у шаблоні повністю ігноруються, за винятком випадків, коли вони переходять або всередині класу символів.

=== Суворий Non-Null режим

Якщо ви компілюєте свій код з `--enable-experimental-non-null`, компілятор Vala запуститься в суворому режимі перевірки ненульових типів і вважає, що кожен тип за замовчуванням не зводиться до нуля, якщо він явно не оголошений нульовим, позначаючи його знаком питання:

[source,vala]
----
Object o1 = new Object();  // не nullable
Object? o2 = new Object(); // nullable
----

The compiler will perform a static compile-time analysis to ensure that no nullable reference is assigned to a non-nullable reference, e.g. this won't be possible:
Компілятор виконає статичний аналіз часу компіляції, щоб переконатися, що жодне зведене посилання не присвоюється ненульовій посиланню, наприклад. це неможливо:

[source,vala]
----
o1 = o2;
----

`o2` може бути нульовим, а `o1` оголошено ненульовим, тому це призначення заборонено. Однак ви Лможете змінити цю поведінку з явним ненульовим складом, якщо ви впевнені, що `o2` не є нульовим:

[source,vala]
----
o1 = (!) o2;
----

Суворий ненульовий режим допомагає уникнути небажаних помилок нульового перенаправлення. Ця особливість набула б повного потенціалу, якби нульовість усіх типів повернення у прив’язках була позначена правильно, що в даний час не завжди так.

=== Бібліотеки

На системному рівні бібліотека Vala - це саме бібліотека С, тому використовуються ті самі інструменти. Для того, щоб зробити процес простішим і щоб компілятор Vala міг зрозуміти процес, тоді є додатковий рівень конкретної інформації Vala.

Отже, "бібліотека Vala" є системною частиною:

* Системна бібліотека (наприклад, libgee.so)
* Запис у форматі `pkg-config` (наприклад, gee-1.0.pc)

Обидва вони встановлені у стандартних місцях. І конкретні файли Vala:

* Файл VAPI (наприклад, gee-1.0.vapi)
* Опціональний файл залежності (наприклад, gee-1.0.deps)

Ці файли будуть пояснені пізніше в цьому розділі. Слід зазначити, що імена бібліотек у файлах конкретного Vala такі ж, як у файлах pkg-config.

=== Використання бібліотек

Використання бібліотеки у Vala значною мірою автоматизоване, якщо ви використовуєте компілятор `valac`. Файли бібліотеки Vala складають те, що називають пакетом. Ви повідомляєте компілятору, що пакет потрібен вашій програмі так:

[source,vala]
----
$ valac --pkg gee-1.0 test.vala
----

Ця команда означає, що ваша програма може використовувати будь-яке визначення у файлі `gee-1.0.vapi`, а також будь-яке в будь-якому з пакетів, від яких залежить `gee-1.0`. Ці залежності були б занесені до `gee-1.0.deps`, якби вони були. У цьому прикладі `valac` налаштований так, щоб будувати весь шлях до двійкового образу, і тому буде включати інформацію з `pkg-config` для зв'язку правильних бібліотек. Ось чому імена `pkg-config` також використовуються для імен пакетів Vala.

Пакети зазвичай використовуються з просторами імен, але вони технічно не пов'язані. Це означає, що незважаючи на те, що ваша програма побудована з посиланням на пакет, ви все одно повинні включати необхідні, використовуючи оператори у кожному файлі, як це доречно, або ж використовувати повністю кваліфіковані імена всіх символів.

Також можна розглядати локальну бібліотеку (таку, яка не встановлена) як пакет. Для порівняння, Vala сама використовує внутрішню версію Gee. Коли вбудований `valac`, він створює файл VAPI цієї внутрішньої бібліотеки і використовує його приблизно так:

[source,vala]
----
$ valac --vapidir ../gee --pkg gee ...
----

Детальніше про те, як створити цю бібліотеку, див. У наступному розділі чи прикладі.

=== Створення бібліотеки

==== Використання Autotools

Можна використовувати Autotools для створення бібліотеки, написаної у Vala. Бібліотека створюється за допомогою коду С, згенерованого компілятором Vala, пов'язаного та встановленого як будь-яка інша бібліотека. Тоді вам потрібно сказати, які файли C повинні бути використані для створення бібліотеки, і які з них повинні бути розповсюджуваними, дозволяючи іншим складати тарбол без Vala, використовуючи стандартні команди Autotools: `configure`, `make` і `make install`.

==== Приклад

Цей приклад взятий з останніх доповнень `GXml`. `GXmlDom` - це бібліотека, спрямована на заміну `libxml2` на основі `GObject`; написано у Vala і спочатку використовувалося для використання WAF для побудови.

`valac` можна використовувати для створення коду С та заголовків із джерел Vala. У цей час можливо генерувати `GObjectIntrospection` і файл VAPI також з джерел `vala`.

`gxml.vala.stamp` використовується як джерело коду для нашої бібліотеки.

Is important to add --pkg switches in order to valac to success and set all CFLAGS and LIBS required by the C library to compile and link against.
Важливо додати `--pkg` перемикачі, щоб домогтися успіху та встановити всі CFLAGS та LIBS, необхідні бібліотеці С для компіляції та зв'язування.

----

Toggle line numbers
   1 NULL =
   2 
   3 
   4 AM_CPPFLAGS = \
   5         -DPACKAGE_LOCALE_DIR=\""$(prefix)/$(DATADIRNAME)/locale"\" \
   6         -DPACKAGE_SRC_DIR=\""$(srcdir)"\" \
   7         -DPACKAGE_DATA_DIR=\""$(datadir)"\" 
   8 
   9 BUILT_SOURCES = gxml.vala.stamp
  10 CLEANFILES = gxml.vala.stamp
  11 
  12 AM_CFLAGS =\
  13          -Wall\
  14          -g \
  15         $(GLIB_CFLAGS) \
  16         $(LIBXML_CFLAGS) \
  17         $(GIO_CFLAGS) \
  18         $(GEE_CFLAGS) \
  19         $(VALA_CFLAGS) \
  20         $(NULL)
  21 
  22 lib_LTLIBRARIES = libgxml.la
  23 
  24 VALAFLAGS = \
  25     $(top_srcdir)/vapi/config.vapi \
  26     --vapidir=$(top_srcdir)/vapi \
  27     --pkg libxml-2.0 \
  28     --pkg gee-1.0 \
  29     --pkg gobject-2.0 \
  30     --pkg gio-2.0 \
  31     $(NULL)
  32 
  33 libgxml_la_VALASOURCES = \
  34         Attr.vala \
  35         BackedNode.vala \
  36         CDATASection.vala \
  37         CharacterData.vala \
  38         Comment.vala \
  39         Document.vala \
  40         DocumentFragment.vala \
  41         DocumentType.vala \
  42         DomError.vala \
  43         Element.vala \
  44         Entity.vala \
  45         EntityReference.vala \
  46         Implementation.vala \
  47         NamespaceAttr.vala \
  48         NodeList.vala \
  49         NodeType.vala \
  50         Notation.vala \
  51         ProcessingInstruction.vala \
  52         Text.vala \
  53         XNode.vala \
  54         $(NULL)
  55 
  56 libgxml_la_SOURCES = \
  57         gxml.vala.stamp \
  58         $(libgxml_la_VALASOURCES:.vala=.c) \
  59         $(NULL) 
  60 
  61 # Generate C code and headers, including GObject Introspection GIR files and VAPI file
  62 gxml-1.0.vapi gxml.vala.stamp GXml-1.0.gir: $(libgxml_la_VALASOURCES)
  63         $(VALA_COMPILER) $(VALAFLAGS) -C -H $(top_builddir)/gxml/gxml-dom.h --gir=GXmlDom-1.0.gir  --library gxmldom-1.0 $^
  64         @touch $@
  65 
  66 
  67 # Library configuration
  68 libgxml_la_LDFLAGS = 
  69 
  70 libgxml_la_LIBADD = \
  71         $(GLIB_LIBS) \
  72         $(LIBXML_LIBS) \
  73         $(GIO_LIBS) \
  74         $(GEE_LIBS) \
  75         $(VALA_LIBS) \
  76         $(NULL)
  77 
  78 include_HEADERS = \
  79         gxml.h \
  80         $(NULL)
  81 
  82 
  83 pkgconfigdir = $(libdir)/pkgconfig
  84 pkgconfig_DATA = libgxml-1.0.pc
  85 
  86 gxmlincludedir=$(includedir)/libgxml-1.0/gxml
  87 gxmlinclude_HEADERS= gxml-dom.h
  88 
  89 # GObject Introspection
  90 
  91 if ENABLE_GI_SYSTEM_INSTALL
  92 girdir = $(INTROSPECTION_GIRDIR)
  93 typelibsdir = $(INTROSPECTION_TYPELIBDIR)
  94 else
  95 girdir = $(datadir)/gir-1.0
  96 typelibsdir = $(libdir)/girepository-1.0
  97 endif
  98 
  99 # GIR files are generated automatically by Valac so is not necessary to scan source code to generate it
 100 INTROSPECTION_GIRS =
 101 INTROSPECTION_GIRS += GXmlDom-1.0.gir
 102 INTROSPECTION_COMPILER_ARGS = \
 103     --includedir=. \
 104     --includedir=$(top_builddir)/gxml 
 105 
 106 GXmlDom-1.0.typelib: $(INTROSPECTION_GIRS)
 107         $(INTROSPECTION_COMPILER) $(INTROSPECTION_COMPILER_ARGS)  $< -o $@
 108 
 109 gir_DATA = $(INTROSPECTION_GIRS)
 110 typelibs_DATA = GXmlDom-1.0.typelib
 111 
 112 vapidir = $(VALA_VAPIDIR)
 113 vapi_DATA=gxmldom-1.0.vapi
 114 
 115 CLEANFILES += $(INTROSPECTION_GIRS) $(typelibs_DATA) gxml-1.0.vapi
 116 
 117 EXTRA_DIST = \
 118         libgxml-1.0.pc.in \
 119         $(libgxml_la_VALASOURCES) \
 120         $(typelibs_DATA) \
 121         $(INTROSPECTION_GIRS) \
 122         gxml.vala.stamp
----

==== Компіляція та зв'язування за допомогою командного рядка

Vala ще не здатний безпосередньо створювати динамічні або статичні бібліотеки. Щоб створити бібліотеку, перейдіть до перемикача `-c` (лише компілювати) та зв’яжіть файли об'єктів із улюбленим лінкером, тобто `libtool` або `ar`.

[source,vala]
----
$ valac -c ...(source files)
$ ar cx ...(object files)
----

або шляхом складання проміжного коду С за допомогою gcc

[source,vala]
----
$ valac -C ...(source files)
$ gcc -o my-best-library.so --shared -fPIC ...(compiled C code files)...
----

==== Приклад

Далі наведено приклад того, як написати просту бібліотеку у Vala, а також скласти та перевірити її локально, не встановлюючи її.

Збережіть наступний код у файлі `test.vala`. Це власне код бібліотеки, що містить функції, які ми хочемо викликати з нашої основної програми.

[source,vala]
----
public class MyLib : Object {

    public void hello() {
        stdout.printf("Hello World, MyLib\n");
    }

    public int sum(int x, int y) {
        return x + y;
    }
}
----

Використовуйте наступну команду для створення файлів `test.c`, `test.h` та `test.vapi`. Це С версії бібліотеки, що підлягає компіляції, та файл VAPI, що представляє публічний інтерфейс бібліотеки.

----
$ valac -C -H test.h --library test test.vala --basedir ./
----

Тепер складіть бібліотеку:

----
$ gcc --shared -fPIC -o libtest.so $(pkg-config --cflags --libs gobject-2.0) test.c
----

Збережіть наступний код у файлі під назвою `hello.vala`. Це код, який використовуватиме створена нами бібліотека.

[source,vala]
----
void main() {
    var test = new MyLib();
    test.hello();
    int x = 4, y = 5;
    stdout.printf("The sum of %d and %d is %d\n", x, y, test.sum(x, y));
}
----

Тепер компілюємо код програми, повідомляючи компілятору, що ми хочемо зв’язатись із створеною нами бібліотекою.

----

$ valac -X -I. -X -L. -X -ltest -o hello hello.vala test.vapi --basedir ./
----

Зараз ми можемо запустити програму. Ця команда зазначає, що будь-які необхідні бібліотеки будуть знайдені в поточному каталозі.

----
$ LD_LIBRARY_PATH=$PWD ./hello
----

Вихід програми повинен бути:

----
Hello World, MyLib
The sum of 4 and 5 is 9
----

Ви також можете створити файл GIR `GObjectIntrospection` для своєї бібліотеки за допомогою параметра `--gir`:

----
valac -C test.vala --library test --gir Test-1.0.gir
----

Файли GIR - це XML-описи API.

==== Пов'язування бібліотек з файлами VAPI

Файли VAPI - це описи публічного інтерфейсу зовнішніх бібліотек Vala. Коли бібліотека записується у Vala, цей файл створюється компілятором Vala, і в основному це об'єднання всіх публічних визначень з усіх вихідних файлів Vala. Для бібліотеки, написаної на C, файл VAPI стає складнішим, особливо якщо конвенції про іменування бібліотеки не відповідають конвенції GLib. У цьому випадку файл VAPI міститиме багато приміток, що описують, як стандартизований інтерфейс Vala перетворюється на версію C.

Цей процес створення в цілому становить три етапи,

* Запуск `vala-gen-introspect` для вилучення метаданих з бібліотеки С.
* Додавання додаткових метаданих для стандартизації інтерфейсу або внесення різних інших змін.
* Генерування файлу VAPI з вищезазначених джерел за допомогою `vapigen`.

Конкретні вказівки щодо створення зв'язків містяться у навчальному посібнику з прив'язки до Vala.

=== Інструменти

Дистрибутив Vala включає кілька програм, які допоможуть вам створити та працювати з програмами Vala. Докладніше про кожен інструмент див. На сторінках man.

`valac` - компілятор Vala. Його основна функція полягає в перетворенні коду Vala в компільований код C, хоча він може також автоматизувати весь проект збірки та зв’язку в простих випадках.

Простий чохол для використання:

----
$ valac -o appname --pkg gee-1.0 file_name_1.vala file_name_2.vala
----

Перемикач `-o` вимагає створення об’єктного файлу, а не просто виведення вихідних файлів C. Опція `--pkg` говорить, що для цієї збірки потрібна інформація з пакета `gee-1.0`. Вам не потрібно вказувати деталі про те, до яких бібліотек слід зв’язатись, пакет містить цю інформацію внутрішньо. Нарешті, наведено список вихідних файлів. Якщо вам потрібен більш складний процес збирання, використовуйте перемикач `-C`, щоб генерувати файли C замість бінарних, і продовжуйте процес вручну або через скрипт.

`vapigen` - це інструмент для виготовлення прив'язок. Він створює файли VAPI з метаданих бібліотеки та будь-якої необхідної додаткової інформації. Дивіться також навчальний посібник щодо зв'язків з Vala.

`vala-gen-introspect` - це інструмент для отримання метеаформації про бібліотеки на основі `GObject`. В даний час кращим методом є використання `GObjectIntrospection` замість цього, оскільки `vapigen` може використовувати файли GIR безпосередньо. Дивіться також навчальний посібник щодо зв'язків з Vala.

=== Техніки

==== Налагодження

Для демонстраційних цілей ми створимо програму-баг, навмисно використовуючи нульове посилання, що призведе до помилки сегментації:

[source,vala]
----
class Foo : Object {
    public int field;
}

void main() {
    Foo? foo = null;
    stdout.printf("%d\n", foo.field);
}
----

[source,bash]
----
$ valac debug-demo.vala
$ ./debug-demo
----

==== Помилка сегментації

То як ми налагоджуємо цю програму? Параметр командного рядка '-g' повідомляє компілятору Vala включати інформацію про рядок вихідного коду Vala у складений бінарний файл, `--save-temps` зберігає тимчасові вихідні файли C:

[source,bash]
----
$ valac -g --save-temps debug-demo.vala
----

Vala programs can be debugged with the GNU Debugger gdb or one of its graphical front-ends, e.g. Nemiver.
Програми Vala можна налагодити за допомогою налагоджувача GNU `gdb` або одного з його графічних фронтендів, наприклад `Nemiver`.

[source,bash]
----
 nemiver debug-demo
----

Зразок сеансу `gdb`:

----
$ gdb debug-demo
(gdb) run
Starting program: /home/valacoder/debug-demo

Program received signal SIGSEGV, Segmentation fault.
0x0804881f in _main () at debug-demo.vala:7
7           stdout.printf("%d\n", foo.field);
(gdb)
----

==== Використання GLib

GLib включає великий набір утиліт, включаючи обгортки для більшості стандартних функцій `libc` та багато іншого. Ці інструменти доступні на всіх платформах Vala, навіть тих, які не відповідають стандартам POSIX. Повний опис всього, що надає GLib, див. У довідковому посібнику GLib. Це посилання пов'язане з API C для GLib, але розробити, як перекласти на Vala, в основному дуже просто.

Функції GLib доступні у Vala завдяки такій умові іменування:

==== Приклад

----

g_topic_foobar()

GLib.Topic.foobar()

GLib.Path.get_basename()
----

Типи GLib можна використовувати аналогічно:

----
GLib.Foo foo = new GLib.Foo();
foo.bar();
----

API не ідентичне між C і Vala, але ці правила іменування повинні означати, що ви можете знайти потрібні функції у файлах GLib VAPI, що постачаються з Vala, і звідти знайти параметри. Цього, сподіваємось, буде достатньо, доки не вдасться створити більше документації Vala.

=== Обробка файлів

Про гнучкі I/O файлів та обробку файлів див. Зразки GIO.

Ви також можете використовувати FileUtils.get_contents для завантаження файлу в рядок.

[source,vala]
----
string content;
FileUtils.get_contents("file.vala", out content);
----
