<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_d_bus_specification">D-Bus Specification</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>D-Bus - це система низько-навантаженого, простого у використанні міжпроцесорного зв'язку (IPC). Більш детально:</p></div>
<div class="ulist"><ul>
<li>
<p>
D-Bus є <em>низько-навантаженим</em>, оскільки він використовує двійковий протокол, і не повинен перетворювати його в текстовий формат, наприклад XML. Оскільки D-Bus призначений для потенційно IPC на одній машині з високою роздільною здатністю, не в першу чергу для Internet IPC, це цікава оптимізація. D-Bus також призначений для уникнення кругових маршрутів і спроможності асинхронної роботи, подібно до протоколу X.
</p>
</li>
<li>
<p>
D-Bus <em>простий у використанні</em>, оскільки він працює в термінах повідомлень, а не потоків байтів, і автоматично обробляє безліч важких проблем з IPC. Крім того, бібліотека D-Bus розроблена так, щоб вона була огорнута таким чином, що дозволяє розробникам використовувати існуючу систему об'єктів/типів їхніх фреймворків, а не вивчати нову спеціально для IPC.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Базовий протокол D-Bus - це протокол "один на один" (одноранговий або клієнт-сервер), визначений у розділі "Протокол повідомлення". Тобто це система для одного додатку для спілкування з одним іншим додатком. Однак основним призначенням протоколу є шина повідомлень D-Bus, зазначена в розділі "Специфікація шини повідомлень". Шина повідомлень - це спеціальна програма, яка приймає з'єднання з декількох інших додатків та пересилає повідомлення серед них.</p></div>
<div class="paragraph"><p>Використання D-Bus включає сповіщення про зміни системи (повідомлення про те, коли камера підключена до комп'ютера чи встановлена ​​нова версія якогось програмного забезпечення) або сумісність робочого столу, наприклад, служба моніторингу файлів або служба конфігурації.</p></div>
<div class="paragraph"><p>D-Bus призначений для двох конкретних випадків використання:</p></div>
<div class="paragraph"><p>"Системна шина" для сповіщень від системи до сеансів користувача та щоб дозволити системі запитувати введення даних із сеансів користувача.</p></div>
<div class="paragraph"><p>"Шина сеансу", що використовується для реалізації середовищ настільних ПК, таких як GNOME та KDE.</p></div>
<div class="paragraph"><p>D-Bus не призначений бути загальною системою IPC для будь-якого можливого застосування, і навмисно упускає багато можливостей, знайдених в інших системах IPC з цієї причини.</p></div>
<div class="paragraph"><p>У той же час демони шини пропонують ряд функцій, які не зустрічаються в інших системах IPC, такі як "власні назви шин" для одного власника (подібні до X-вибору), запуск послуг на вимогу та політика безпеки. Багато в чому ці особливості є основною мотивацією для розвитку D-Bus; інших систем було б достатньо, якби IPC була єдиною метою.</p></div>
<div class="paragraph"><p>D-Bus може виявитися корисним у непередбачуваних застосуваннях, але майбутні версії цієї специфікації та посилання на реалізацію, ймовірно, не включатимуть функції, що заважають основним випадкам використання.</p></div>
<div class="paragraph"><p>У цьому документі ключові слова "ОБОВ'ЯЗКОВО", "НЕ ПОВИННІ", "ВИМАГАЄТЬСЯ", "ПОТРІБНО", "МАЄ", "НЕ МАЄ", "РЕКОМЕНДОВАНО", "МОЖУ" та "ОПЦІЙНО" тлумачити так, як описано в RFC 2119. Однак документ може використовувати серйозний аудит, щоб переконатися, що це має сенс. Також вони не використовуються з великої літери.</p></div>
</div>
<div class="sect2">
<h3 id="____">Стабільність протоколу та специфікації</h3>
<div class="paragraph"><p>Протокол D-Bus заморожено (дозволені лише сумісні розширення) з 8 листопада 2006 року. Однак ця специфікація може все-таки використати неабияку роботу, щоб зробити можливим взаємодіючу імплементацію без посилання на реалізацію посилання D-Bus. Таким чином, ця специфікація не позначена 1,0. Щоб позначити це 1.0, ми хотіли б, щоб хтось вкладав значні зусилля в роз'яснення мови специфікацій та розширення специфікації, щоб охопити більше аспектів поведінки формальної реалізації.</p></div>
<div class="paragraph"><p>Поки ця робота не буде завершена, будь-яка спроба повторного втілення D-Bus, ймовірно, потребує перегляду посилання на реалізацію та/або задавання питань у списку розсилки D-Bus щодо наміченої поведінки. Питання в списку дуже вітаються.</p></div>
<div class="paragraph"><p>Тим не менш, цей документ повинен бути корисним початковим пунктом і, наскільки нам відомо, точним, хоча і неповним.</p></div>
</div>
<div class="sect2">
<h3 id="__">Система типів</h3>
<div class="paragraph"><p>D-Bus має систему типів, в якій значення різних типів можуть бути серіалізовані в послідовність байтів, що називаються дротяним форматом стандартним способом. Перетворення значення з якогось іншого представлення у дротяний формат називається маршалінг, а перетворення його назад із дротяного формату - демаршалінг.</p></div>
<div class="paragraph"><p>Протокол D-Bus не включає теги типів у даних маршалінгу; блок значень маршалінгу повинен мати відомий тип підпису. Підпис типу складається з нуля або більше окрених повних типів, кожен складається з одного або декількох кодів типу.</p></div>
<div class="paragraph"><p>Код типу - символ ASCII, що представляє тип значення. Оскільки використовуються символи ASCII, підпис типу завжди утворюватиме гідний рядок ASCII. Просте порівняння рядків визначає, чи два підписи рівнозначні.</p></div>
<div class="paragraph"><p>A single complete type is a sequence of type codes that fully describes one type: either a basic type, or a single fully-described container type. A single complete type is a basic type code, a variant type code, an array with its element type, or a struct with its fields (all of which are defined below). So the following signatures are not single complete types:
Окремий повний тип - це послідовність типів кодів, яка повністю описує один тип: або основний тип, або єдиний повністю описаний тип контейнера. Одиничний повний тип - це базовий код типу, код варіанту типу, масив з його типом елемента або структура з полями (усі вони визначені нижче). Отже, наступні підписи не є єдиними повними типами: <code>aa</code>, <code>(ii</code>, <code>ii)</code>. А наступні підписи містять кілька повних типів: <code>ii</code>, <code>aiai</code>, <code>(ii)(ii)</code>.</p></div>
<div class="paragraph"><p>Зауважте, однак, що один повний тип може містити декілька інших одиничних повних типів, що містять <code>struct</code> або запис <code>dict</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Основні типи</h3>
<div class="paragraph"><p>Найпростіші типи кодів - основні типи, структура яких повністю визначена їх 1-символьним кодом типу. Основні типи складаються з фіксованих типів і строкоподібних типів.</p></div>
<div class="paragraph"><p>Фіксовані типи - це базові типи, значення яких мають фіксовану довжину, а саме: <code>BYTE</code>, <code>BOOLEAN</code>, <code>DOUBLE</code>, <code>UNIX_FD</code> та знакові або беззнакові цілі числа довжиною 16, 32 або 64 біт.</p></div>
<div class="paragraph"><p>Як простий приклад, код типу для 32-бітного цілого числа (<code>INT32</code>) - символ ASCII <code>i</code>. Отже, підписом для блоку значень, що містить єдиний <code>INT32</code>, було б: <code>i</code>. Блок значень, що містить два <code>INT32</code>, повинен мати цей підпис: <code>ii</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Характеристики фіксованих типів.</caption>
<col width="20%" />
<col width="13%" />
<col width="66%" />
<thead>
<tr>
<th align="left" valign="top">Звичайна назва</th>
<th align="center" valign="top">Код ASCII</th>
<th align="left" valign="top">Кодування</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">BYTE</p></td>
<td align="center" valign="top"><p class="table">y (121)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 8-бітне ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BOOLEAN</p></td>
<td align="center" valign="top"><p class="table">b (98)</p></td>
<td align="left" valign="top"><p class="table">Булеве значення: 0 - брехня, 1 - істина, будь-яке інше значення, дозволене форматом маршалінгу, недійсне</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT16</p></td>
<td align="center" valign="top"><p class="table">n (110)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 16-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT16</p></td>
<td align="center" valign="top"><p class="table">q (113)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 16-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT32</p></td>
<td align="center" valign="top"><p class="table">i (105)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 32-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT32</p></td>
<td align="center" valign="top"><p class="table">u (117)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 32-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT64</p></td>
<td align="center" valign="top"><p class="table">x (120)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 64-бітове ціле число (нагадування: x і t є першими символами "шістдесяти", які вже не використовуються для чогось більш поширеного)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT64</p></td>
<td align="center" valign="top"><p class="table">t (116)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 64-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DOUBLE</p></td>
<td align="center" valign="top"><p class="table">d (100)</p></td>
<td align="left" valign="top"><p class="table">IEEE 754 з плаваючою точкою подвійної точності</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UNIX_FD</p></td>
<td align="center" valign="top"><p class="table">h (104)</p></td>
<td align="left" valign="top"><p class="table">32-розрядне ціле число без знака, представляє індекс у позадіапазонному масиві дескрипторів файлів, переданих через якийсь механізм, орієнтований на платформу (мнемонічний: h для ручки)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Рядко-подібні типи - це базові типи зі змінною довжиною. Значення будь-якого рядкового типу - це концептуально 0 або більше кодових точок Unicode, закодованих у UTF-8, жодна з яких не може бути U + 0000. Текст UTF-8 повинен бути чітко підтверджений: зокрема, він не повинен містити надто довгих послідовностей або кодових точок вище <code>U+10FFFF</code>.</p></div>
<div class="paragraph"><p>Оскільки специфікація D-Bus версії 0.21, відповідно до виправлення Unicode № 9, "несимволи" <code>U+FDD0..U+FDEF</code>, <code>U+nFFFE</code> та <code>U+nFFFF</code> дозволені в рядках UTF-8 (але зауважте, що старіші версії D-Bus відхиляли ці несимволи).</p></div>
<div class="paragraph"><p>Формати маршалінгу для рядко-подібних типів закінчуються одним байтом нуля (<code>NUL</code>), але цей байт не вважається частиною тексту.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Характеристики рядко-подібних типів.</caption>
<col width="20%" />
<col width="13%" />
<col width="66%" />
<thead>
<tr>
<th align="left" valign="top"> Звичайна назва </th>
<th align="center" valign="top"> ASCII код типу </th>
<th align="left" valign="top"> Обмеження дійсності</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">STRING</p></td>
<td align="center" valign="top"><p class="table">s (115)</p></td>
<td align="left" valign="top"><p class="table">Без зайвих обмежень</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OBJECT_PATH</p></td>
<td align="center" valign="top"><p class="table">o (111)</p></td>
<td align="left" valign="top"><p class="table">Повинен бути синтаксично дійсний шлях до об'єкта</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">SIGNATURE</p></td>
<td align="center" valign="top"><p class="table">g (103)</p></td>
<td align="left" valign="top"><p class="table">Нуль або більше окремих повних типів</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_____2">Дійсні шляхи об'єктів</h4>
<div class="paragraph"><p>Шлях до об'єкта - це ім'я, яке використовується для позначення екземпляра об'єкта. У концептуальному плані кожен учасник обміну повідомленнями D-Bus може мати будь-яку кількість екземплярів об'єктів (думайте я про об'єкти C ++ або Java), і кожен такий екземпляр матиме шлях. Як і файлова система, об'єкт екземпляри в додатку утворюють ієрархічне дерево.</p></div>
<div class="paragraph"><p>Шляхи до об'єктів часто представлені просторами імен, починаючи із зворотного доменного імені та містять номер версії інтерфейсу так само, як імена інтерфейсів та гарно відомі імена шини. Це дає можливість реалізувати більше одного сервісу або більше однієї версії послуги в одному процесі, навіть якщо служби поділяють з'єднання, але не можуть інакше співпрацювати (наприклад, якщо вони реалізовані різними плагінами).</p></div>
<div class="paragraph"><p>Використання об'єктного шляху <code>/</code> дозволено, але не рекомендується, оскільки це ускладнює створення версій інтерфейсів. Будь-які сигнали, що випромінюються від об'єкта D-Bus, мають унікальне ім'я шини, пов'язане з ними, а не його відоме ім'я. Це означає, що одержувачі сигналів повинні повністю покладатися на ім'я сигналу та шлях об'єкта, щоб визначити, з якого інтерфейсу походить сигнал.</p></div>
<div class="paragraph"><p>Наприклад, якщо власник <code>example.com</code> розробляє API D-Bus для музичного плеєра, він може використовувати ієрархію об'єктних шляхів, що починаються з <code>/com/example/MusicPlayer1</code> для його об'єктів.</p></div>
<div class="paragraph"><p>Наступні правила визначають дійсний шлях до об'єкта. Програми не повинні надсилати та приймати повідомлення з недійсними об'єктними шляхами.</p></div>
<div class="ulist"><ul>
<li>
<p>
Шлях може бути будь-якої довжини.
</p>
</li>
<li>
<p>
Шлях повинен починатися з символу ASCII <code>'/'</code> (ціле число 47) і повинен складатися з елементів, розділених косою рисою.
</p>
</li>
<li>
<p>
Кожен елемент повинен містити лише символи ASCII <code>"[A-Z][a-z][0-9]_"</code>
</p>
</li>
<li>
<p>
Жоден елемент не може бути порожнім рядком.
</p>
</li>
<li>
<p>
Кілька символів <code>'/'</code> не можуть стояти послідовно.
</p>
</li>
<li>
<p>
Заключний символ <code>'/'</code> не дозволений, якщо шлях не є кореневим шляхом (єдиний символ <code>'/'</code>).
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="___3">Дійсні підписи</h4>
<div class="paragraph"><p>Реалізація не повинна надсилати або приймати недійсні підписи. Дійсні підписи відповідають таким правилам:</p></div>
<div class="ulist"><ul>
<li>
<p>
Підпис - це список окремих повних типів. Масиви повинні мати типи елементів, а структури повинні мати відкриті і закриті дужки.
</p>
</li>
<li>
<p>
У підписі дозволено використовувати лише коди, відкриті та закриті дужки та відкриті та закриті фігурні дужки. Код типу <code>STRUCT</code> у підписах заборонений, оскільки замість нього використовуються круглі дужки. Аналогічно, код типу <code>DICT_ENTRY</code> у підписах заборонений, оскільки замість нього використовуються фігурні дужки.
</p>
</li>
<li>
<p>
Максимальна глибина вкладення типу контейнера - 32 коди типу масиву та 32 відкриті дужки. Це означає, що максимальна загальна глибина рекурсії становить 64, для "масиву масиву масиву &#8230; структура в структурі &#8230;", де є 32 масиви та 32 struct.
</p>
</li>
<li>
<p>
Максимальна довжина підпису - 255.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Коли підписи з'являються в повідомленнях, формат маршалінгу гарантує, що за ними буде слідувати нульовий байт (який можна інтерпретувати як припинення рядка в стилі С або код типу <code>INVALID</code>), але це концептуально не є частиною підпису.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___4">Типи контейнерів</h3>
<div class="paragraph"><p>Окрім основних типів, є чотири типи контейнерів: <code>STRUCT</code>, <code>ARRAY</code>, <code>VARIANT</code> та <code>DICT_ENTRY</code>.</p></div>
<div class="paragraph"><p><code>STRUCT</code> має код типу, ASCII символ <code>'r'</code>, але цей тип коду не відображається в підписах. Натомість символи ASCII використовуються <code>'('</code> і <code>')'</code> для позначення початку та кінця структури. Так, наприклад, структура, що містить два цілих числа, мала б цей підпис: <code>"(ii)"</code></p></div>
<div class="paragraph"><p>Структури можуть бути вкладені, наприклад, структура, що містить ціле число та іншу структуру: <code>"(i(ii))"</code></p></div>
<div class="paragraph"><p>Блок значення, що зберігає цю структуру, міститиме три цілі числа; підпис типу дозволяє відрізнити <code>"(i (ii))"</code> від <code>"((ii) i)"</code> або <code>"(iii)"</code> або <code>"iii"</code>.</p></div>
<div class="paragraph"><p>Код типу <code>STRUCT</code> <code>'r'</code> наразі не використовується в протоколі D-Bus, але корисний у коді, який реалізує протокол. Цей тип коду визначений, щоб дозволити такому коду взаємодіяти в непротокольних контекстах.</p></div>
<div class="paragraph"><p>Порожні структури не допускаються; між дужками повинен бути принаймні один код типу.</p></div>
<div class="paragraph"><p>Код типу <code>ARRAY</code> має символ ASCII <code>'a'</code>. Коду типу масиву повинен дотримуватися один повний тип. Єдиний повний тип, що слідує за масивом, - це тип кожного елемента масиву. Тож простий приклад: <code>"ai"</code>, що є масивом 32-бітових цілих чисел. Але масив може бути будь-якого типу, наприклад, цей масив структур з двох полів <code>int32</code>: <code>"a(ii)"</code>. Або цей масив масиву цілих чисел: <code>"aai"</code></p></div>
<div class="paragraph"><p>Код типу <code>VARIANT</code> має символ ASCII <code>'v'</code>. Значення з маршовим типом типу <code>VARIANT</code> матиме підпис одного повного типу як частини значення. Після цього підпису буде додано маршаловане значення цього типу.</p></div>
<div class="paragraph"><p>На відміну від підпису повідомлення, варіантний підпис може містити лише один повний тип. Отже, <code>"i"</code>, <code>"ai"</code> або <code>"(ii)"</code> в порядку, але <code>"ii"</code> - ні. Використання варіантів не може призвести до того, що загальна глибина повідомлення перевищує 64, включаючи інші типи контейнерів, такі як структури.</p></div>
<div class="paragraph"><p><code>DICT_ENTRY</code> працює точно як структура, але замість дужок він використовує фігурні дужки і має більше обмежень. Обмеження наступні: це зустрічається лише як тип елемента масиву; у нього рівно два окемих цілих типи всередині фігурних брекетів; перший тип ("ключ") повинен бути основним типом, а не типом контейнера. Реалізації не повинні приймати записи словника за межами масивів, не повинні приймати записи словника з нулем, одним або більше двох полів і не повинні приймати записи словника з ключами, що не належать до основного типу. Запис у словнику - це завжди пара ключ-значення.</p></div>
<div class="paragraph"><p>Перше поле в <code>DICT_ENTRY</code> завжди є ключовим. Повідомлення вважається пошкодженим, якщо однаковий ключ зустрічається двічі в одному масиві <code>DICT_ENTRY</code>. Однак з міркувань продуктивності реалізації не потрібно відкидати словники з повторюваними ключами.</p></div>
<div class="paragraph"><p>У більшості мов масив записів словника буде представлений у вигляді мапи, хеш-таблиці або об’єкта словника.</p></div>
</div>
<div class="sect2">
<h3 id="___">Підсумок щодо типів</h3>
<div class="paragraph"><p>У наступній таблиці підсумовані типи D-Bus.</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="7%" />
<col width="14%" />
<col width="21%" />
<col width="57%" />
<thead>
<tr>
<th align="left" valign="top"> Категорія    </th>
<th align="left" valign="top"> Умовна назва </th>
<th align="left" valign="top">Код </th>
<th align="left" valign="top"> Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">INVALID</p></td>
<td align="left" valign="top"><p class="table">0 (ASCII NUL)</p></td>
<td align="left" valign="top"><p class="table">Недійсний код типу, який використовується для завершення підпису</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">BYTE</p></td>
<td align="left" valign="top"><p class="table">121 (ASCII <em>y</em>)</p></td>
<td align="left" valign="top"><p class="table">8-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">BOOLEAN</p></td>
<td align="left" valign="top"><p class="table">98 (ASCII <em>b</em>)</p></td>
<td align="left" valign="top"><p class="table">Логічне значення, 0 FALSE, 1 TRUE. Все інше недійсне.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT16</p></td>
<td align="left" valign="top"><p class="table">110 (ASCII <em>n</em>)</p></td>
<td align="left" valign="top"><p class="table">16-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT16</p></td>
<td align="left" valign="top"><p class="table">113 (ASCII <em>q</em>)</p></td>
<td align="left" valign="top"><p class="table">16-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT32</p></td>
<td align="left" valign="top"><p class="table">105 (ASCII <em>i</em>)</p></td>
<td align="left" valign="top"><p class="table">32-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT32</p></td>
<td align="left" valign="top"><p class="table">117 (ASCII <em>u</em>)</p></td>
<td align="left" valign="top"><p class="table">32-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT64</p></td>
<td align="left" valign="top"><p class="table">120 (ASCII <em>x</em>)</p></td>
<td align="left" valign="top"><p class="table">64-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT64</p></td>
<td align="left" valign="top"><p class="table">116 (ASCII <em>t</em>)</p></td>
<td align="left" valign="top"><p class="table">64-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">DOUBLE</p></td>
<td align="left" valign="top"><p class="table">100 (ASCII <em>d</em>)</p></td>
<td align="left" valign="top"><p class="table">IEEE 754 подвійної точності</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">STRING</p></td>
<td align="left" valign="top"><p class="table">115 (ASCII <em>s</em>)</p></td>
<td align="left" valign="top"><p class="table">UTF-8 рядок (має бути дійсним UTF-8). Повинно бути нуль-термінованим та не містити інші байти nul.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">OBJECT_PATH</p></td>
<td align="left" valign="top"><p class="table">111 (ASCII <em>o</em>)</p></td>
<td align="left" valign="top"><p class="table">Ім'я примірника об'єкта</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">SIGNATURE</p></td>
<td align="left" valign="top"><p class="table">103 (ASCII <em>g</em>)</p></td>
<td align="left" valign="top"><p class="table">Сигнатура типу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">ARRAY</p></td>
<td align="left" valign="top"><p class="table">97 (ASCII <em>a</em>)</p></td>
<td align="left" valign="top"><p class="table">Масив</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">STRUCT</p></td>
<td align="left" valign="top"><p class="table">114 (ASCII <em>r</em>), 40 (ASCII <em>(</em>), 41 (ASCII <em>)</em>)</p></td>
<td align="left" valign="top"><p class="table">Структура; код типу 114 <em>r</em> зарезервований для використання у прив'язках та реалізаціях для представлення загальної концепції структури, і не повинен відображатися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">VARIANT</p></td>
<td align="left" valign="top"><p class="table">118 (ASCII <em>v</em>)</p></td>
<td align="left" valign="top"><p class="table">Тип варіанту (тип значення є частиною самого значення)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">DICT_ENTRY</p></td>
<td align="left" valign="top"><p class="table">101 (ASCII <em>e</em>), 123 (ASCII <em>{</em>), 125 (ASCII <em>}</em>)</p></td>
<td align="left" valign="top"><p class="table">Запис у dict або map (масив пар ключ-значення). Код типу 101 <em>e</em> зарезервований для використання у прив'язках та реалізації, щоб представити загальну концепцію dict або dict-entry, і не повинен відображатися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UNIX_FD</p></td>
<td align="left" valign="top"><p class="table">104 (ASCII <em>h</em>)</p></td>
<td align="left" valign="top"><p class="table">Файловий дескриптор Unix</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">109 (ASCII <em>m</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для типу "можливо", сумісного з типом у GVariant, і не повинно з'являтися у підписах, що використовуються на D-Bus, поки не вказано тут</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">42 (ASCII <em>*</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого окремого повного типу і не повинно з'являтися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">63 (ASCII <em>?</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого базового типу і не повинно з'являтися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">64 (ASCII <em>@</em>), 38 (ASCII <em>&amp;</em>), 94 (ASCII <em>^</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для внутрішнього використання шляхом прив'язки/реалізації та не повинно відображатися у підписах, що використовуються на D-Bus. GVariant використовує ці типи кодів для кодування умовних викликів.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____2">Маршалінг (дротовий формат)</h2>
<div class="sectionbody">
<div class="paragraph"><p>D-Bus визначає маршовий формат для своєї системи типів, який використовується у повідомленнях D-Bus. Це не єдиний можливий формат маршалінгу для системи типів: наприклад, <code>GVariant</code> (частина GLib) повторно використовує систему типів D-Bus, але реалізує альтернативний формат маршалінгу.</p></div>
<div class="sect2">
<h3 id="_____3">Порядок байт та вирівнювання</h3>
<div class="paragraph"><p>Беручи підпис типу, блок байтів може бути перетворений в типізовані значення. У цьому розділі описано формат блоку байтів. Проблеми з порядком і вирівнюванням байтів обробляються однаково для всіх типів D-Bus.</p></div>
<div class="paragraph"><p>Блок байтів має пов'язаний порядок байт. Порядок байтів повинен бути виявлений якимось чином; для повідомлень D-Bus порядок байтів є частиною заголовка повідомлення, як описано в розділі під назвою "Формат повідомлення". Поки припустимо, що байтовий порядок є відомий як біг- або літл-ендіан.</p></div>
<div class="paragraph"><p>Кожне значення в блоці байтів вирівнюється "природним чином", наприклад, 4-байтні значення вирівнюються до 4-байтної межі, а 8-байтові - до 8-байтової межі. Межі обчислюються в глобальному масштабі щодо першого байту повідомлення. Для правильного вирівнювання значення може знадобитися прокладка вирівнювання перед значенням. Підкладка вирівнювання завжди повинна бути мінімально необхідною прокладкою, щоб правильно вирівняти наступне значення; і вона завжди повинна складатися з нульових байтів. Прокладка вирівнювання не повинна залишатися неініціалізованою (вона не може містити сміття), і не слід використовувати більше прокладки, ніж потрібно.</p></div>
<div class="paragraph"><p>Як виняток від природного вирівнювання, значення <code>STRUCT</code> та <code>DICT_ENTRY</code> завжди вирівнюються до 8-байтової межі, незалежно від вирівнювання їх вмісту.</p></div>
</div>
<div class="sect2">
<h3 id="____3">Маршалінг основних типів</h3>
<div class="paragraph"><p>Для маршалінгу та демаршалінгу фіксованих типів ви просто зчитуєте одне значення з блоку даних, що відповідає кожному коду типу в підписі. Всі підписані цілі значення кодуються в доповнення двох, значення <code>DOUBLE</code> - IEEE 754 з плаваючою точкою подвійної точності, а значення <code>BOOLEAN</code> кодуються в 32 біти (з яких використовується лише найменш значущий біт).</p></div>
<div class="paragraph"><p>Рядкоподібні типи (<code>STRING</code>, <code>OBJECT_PATH</code> і <code>SIGNATURE</code>) усі розміщуються як беззнакове ціле фіксованої довжини <code>n</code>, що дає довжину змінної частини, а потім <code>n</code> ненульових байтів тексту UTF-8, а потім один нульовий байт (<code>nul</code>) байт, який не вважається частиною тексту. Вирівнювання рядкового типу є таким же, як і вирівнювання <code>n</code>: будь-яка прокладка, необхідна для <code>n</code>, з'являється безпосередньо перед самим <code>n</code>. Ніколи не існує жодного вирівнювання між <code>n</code> та текстом рядка, або між текстом рядка та кінцевим нулем. Вирівнювання наступного значення в повідомленні (якщо воно є) починається після кінцевого нуля.</p></div>
<div class="paragraph"><p>Для типів <code>STRING</code> і <code>OBJECT_PATH</code> <code>n</code> кодується в 4 байти (<code>UINT32</code>), що веде до 4-байтового вирівнювання. Для типу <code>SIGNATURE</code> <code>n</code> кодується як один байт (<code>UINT8</code>). В результаті вирівнювання прокладки ніколи не потрібно перед <code>SIGNATURE</code>.</p></div>
<div class="paragraph"><p>Наприклад, якщо поточне положення є кратним 8 байтів від початку повідомлення літл-ендіван повідомлення, рядки <code>"foo"</code>, <code>"+"</code> і <code>"bar"</code> будуть серіалізовані в послідовності наступним чином:</p></div>
<div class="paragraph"><p>0x03 0x00 0x00 0x00   кратне 4, вирівнювання не потрібне, довжина ‘foo’ = 3
0x66 0x6f 0x6f        ‘foo’
0x00                  заключний nul
0x01 0x00 0x00 0x00   кратне 4, вирівнювання не потрібне, довжина ‘+’ = 1
0x2b                  ‘+’
0x00                  заключний nul
0x00 0x00             2 байти вирівнювання
0x03 0x00 0x00 0x00   довжина ‘bar’ = 3
0x62 0x61 0x72        ‘bar’
0x00                  заключний nul</p></div>
</div>
<div class="sect2">
<h3 id="___5">Контейнери маршалінга</h3>
<div class="paragraph"><p>Масиви розташовуються як <code>UINT32 n</code>, що задає довжину даних масиву в байтах з подальшим вирівнюванням до межі вирівнювання типу масиву з подальшими <code>n</code> байтами елементів масиву, маршованих послідовно. <code>n</code> не включає прокладку після довжини або будь-яку прокладку після останнього елемента, тобто <code>n</code> слід ділити на кількість елементів у масиві.</p></div>
<div class="paragraph"><p>Наприклад, якщо поточне положення в повідомленні кратне 8 байтам, а порядок байтів є біг-ендіан, масив, що містить лише 64-бітове ціле число 5, буде розміщено як:</p></div>
<div class="paragraph"><p>00 00 00 08               n = 8 байт даних
00 00 00 00               вирівнювання на межу 8 байтів
00 00 00 00  00 00 00 05  перший елемент = 5</p></div>
<div class="paragraph"><p>Масиви мають максимальну довжину, визначену як 2 в 26-й ступені, 67108864 (64 МБ). Впровадження не повинно надсилати або приймати масиви, що перевищують цю довжину.</p></div>
<div class="paragraph"><p>Структури та записи мап розміщуються так само, як і їхній вміст, але їх вирівнювання завжди до 8-байтової межі, навіть якщо їх вміст, як правило, менш суворо вирівняний.</p></div>
<div class="paragraph"><p>Варіанти маршируються як <code>SIGNATURE</code> вмісту (який повинен бути єдиним завершеним типом), а потім слідує маршальоване значення з типом, заданим цим підписом. Варіант має те ж однобайтове вирівнювання, що і підпис, що означає, що вирівнювання перед варіантом ніколи не потрібне. Використання варіантів не повинно призводити до того, що загальна глибина повідомлення не перевищує 64, включаючи інші типи контейнерів, такі як структури. (Див. Дійсні підписи).</p></div>
<div class="paragraph"><p>Враховуючи все це, типи розміщуються на дроті наступним чином:</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Короткий огляд маршалінгу D-Bus</caption>
<col width="27%" />
<col width="54%" />
<col width="18%" />
<thead>
<tr>
<th align="left" valign="top"> Звичайна назва </th>
<th align="left" valign="top"> Кодування </th>
<th align="left" valign="top"> вирівнювання</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">INVALID</p></td>
<td align="left" valign="top"><p class="table">Не маршулюється</p></td>
<td align="left" valign="top"><p class="table">N/A</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BYTE</p></td>
<td align="left" valign="top"><p class="table">Поодинокий 8-бітний байт</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BOOLEAN</p></td>
<td align="left" valign="top"><p class="table">Як для UINT32, але значення лише 0 та 1</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT16</p></td>
<td align="left" valign="top"><p class="table">16-бітне знакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">2</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT16</p></td>
<td align="left" valign="top"><p class="table">16-бітне беззнакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">2</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT32</p></td>
<td align="left" valign="top"><p class="table">32-бітне знакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT32</p></td>
<td align="left" valign="top"><p class="table">32-бітне беззнакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT64</p></td>
<td align="left" valign="top"><p class="table">64-бітне знакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT64</p></td>
<td align="left" valign="top"><p class="table">64-бітне беззнакове ціле в відповідному порядку байт</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DOUBLE</p></td>
<td align="left" valign="top"><p class="table">64-бітове IEEE 754 подвійної точності</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">STRING</p></td>
<td align="left" valign="top"><p class="table">UINT32 в якості довжини рядка в байтах, виключаючи завершальний nul, за яким ідуть дані вказаної довжини і заключиний байт nul</p></td>
<td align="left" valign="top"><p class="table">4 (для довжини)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OBJECT_PATH</p></td>
<td align="left" valign="top"><p class="table">Те саме, що STRING, за виключенням того, що рядок має бути валідним шляхом(див вище)</p></td>
<td align="left" valign="top"><p class="table">4 (для довжини)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">SIGNATURE</p></td>
<td align="left" valign="top"><p class="table">Те саме, що STRING, за виключнням того, що довжина складає один байт (тобто сигнатура має максимальну довжину 255), і вміст має бути валідним підписом (див вище)</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">ARRAY</p></td>
<td align="left" valign="top"><p class="table">UINT32, що дає довжину масива даних в байтах, за яким іде вирівнювання до межі згідно елементам типу, за яким ідуть самі елементи</p></td>
<td align="left" valign="top"><p class="table">4 (для довожини)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">STRUCT</p></td>
<td align="left" valign="top"><p class="table">Структура має починатись з 8-байтової межі, безвідносно до полів. Значення структури складається з кожного з полів, маршальованих послідовно, починаючи з цієї 8-бітної межі</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">VARIANT</p></td>
<td align="left" valign="top"><p class="table">Маршальована SIGNATURE єдиного повного типу, за яким іде значення типу, вказаноого в сигнатурі</p></td>
<td align="left" valign="top"><p class="table">1 (вирівнювання сигнатури)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DICT_ENTRY</p></td>
<td align="left" valign="top"><p class="table">Ідентично до STRUCT</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UNIX_FD</p></td>
<td align="left" valign="top"><p class="table">32-бітне беззнакове ціле в відповідному порядку байт. Справжні дескриптори файлів мають передавати по іншим каналам, специфічним для платформи. На дроті значення цього типу зберігають індекс файлового дескриптора в масиві дескрипторів, що супроводжує повідомлення</p></td>
<td align="left" valign="top"><p class="table">4</p>
<p class="table">== Протокол повідомлення</p>
<p class="table">A message consists of a header and a body. If you think of a message as a package, the header is the address, and the body contains the package contents. The message delivery system uses the header information to figure out where to send the message and how to interpret it; the recipient interprets the body of the message.</p>
<p class="table">The body of the message is made up of zero or more arguments, which are typed values, such as an integer or a byte array.</p>
<p class="table">Both header and body use the D-Bus type system and format for serializing data.</p>
<p class="table">Message Format
A message consists of a header and a body. The header is a block of values with a fixed signature and meaning. The body is a separate block of values, with a signature specified in the header.</p>
<p class="table">The length of the header must be a multiple of 8, allowing the body to begin on an 8-byte boundary when storing the entire message in a single buffer. If the header does not naturally end on an 8-byte boundary up to 7 bytes of nul-initialized alignment padding must be added.</p>
<p class="table">The message body need not end on an 8-byte boundary.</p>
<p class="table">The maximum length of a message, including header, header alignment padding, and body is 2 to the 27th power or 134217728 (128 MiB). Implementations must not send or accept messages exceeding this size.</p>
<p class="table">The signature of the header is:</p>
<p class="table">          "yyyyuua(yv)"</p>
<p class="table">Written out more readably, this is:</p>
<p class="table">          BYTE, BYTE, BYTE, BYTE, UINT32, UINT32, ARRAY of STRUCT of (BYTE,VARIANT)</p>
<p class="table">These values have the following meanings:</p>
<p class="table">Value   Description
1st BYTE        Endianness flag; ASCII <em>l</em> for little-endian or ASCII <em>B</em> for big-endian. Both header and body are in this endianness.
2nd BYTE        Message type. Unknown types must be ignored. Currently-defined types are described below.
3rd BYTE        Bitwise OR of flags. Unknown flags must be ignored. Currently-defined flags are described below.
4th BYTE        Major protocol version of the sending application. If the major protocol version of the receiving application does not match, the applications will not be able to communicate and the D-Bus connection must be disconnected. The major protocol version for this version of the specification is 1.
1st UINT32      Length in bytes of the message body, starting from the end of the header. The header ends after its alignment padding to an 8-boundary.
2nd UINT32      The serial of this message, used as a cookie by the sender to identify the reply corresponding to this request. This must not be zero.
ARRAY of STRUCT of (BYTE,VARIANT)       An array of zero or more header fields where the byte is the field code, and the variant is the field value. The message type determines which fields are required.
Message types that can appear in the second byte of the header are:</p>
<p class="table">Conventional name       Decimal value   Description
INVALID 0       This is an invalid type.
METHOD_CALL     1       Method call. This message type may prompt a reply.
METHOD_RETURN   2       Method reply with returned data.
ERROR   3       Error reply. If the first argument exists and is a string, it is an error message.
SIGNAL  4       Signal emission.
Flags that can appear in the third byte of the header:</p>
<p class="table">Conventional name       Hex value       Description
NO_REPLY_EXPECTED       0x1
This message does not expect method return replies or error replies, even if it is of a type that can have a reply; the reply should be omitted.</p>
<p class="table">Note that METHOD_CALL is the only message type currently defined in this specification that can expect a reply, so the presence or absence of this flag in the other three message types that are currently documented is meaningless: replies to those message types should not be sent, whether this flag is present or not.</p>
<p class="table">NO_AUTO_START   0x2     The bus must not launch an owner for the destination name in response to this message.
ALLOW_INTERACTIVE_AUTHORIZATION 0x4
This flag may be set on a method call message to inform the receiving side that the caller is prepared to wait for interactive authorization, which might take a considerable time to complete. For instance, if this flag is set, it would be appropriate to query the user for passwords or confirmation via Polkit or a similar framework.</p>
<p class="table">This flag is only useful when unprivileged code calls a more privileged method call, and an authorization framework is deployed that allows possibly interactive authorization. If no such framework is deployed it has no effect. This flag should not be set by default by client implementations. If it is set, the caller should also set a suitably long timeout on the method call to make sure the user interaction may complete. This flag is only valid for method call messages, and shall be ignored otherwise.</p>
<p class="table">Interaction that takes place as a part of the effect of the method being called is outside the scope of this flag, even if it could also be characterized as authentication or authorization. For instance, in a method call that directs a network management service to attempt to connect to a virtual private network, this flag should control how the network management service makes the decision "is this user allowed to change system network configuration?", but it should not affect how or whether the network management service interacts with the user to obtain the credentials that are required for access to the VPN.</p>
<p class="table">If a this flag is not set on a method call, and a service determines that the requested operation is not allowed without interactive authorization, but could be allowed after successful interactive authorization, it may return the org.freedesktop.DBus.Error.InteractiveAuthorizationRequired error.</p>
<p class="table">The absence of this flag does not guarantee that interactive authorization will not be applied, since existing services that pre-date this flag might already use interactive authorization. However, existing D-Bus APIs that will use interactive authorization should document that the call may take longer than usual, and new D-Bus APIs should avoid interactive authorization in the absence of this flag.</p>
<p class="table">Header Fields
The array at the end of the header contains header fields, where each field is a 1-byte field code followed by a field value. A header must contain the required header fields for its message type, and zero or more of any optional header fields. Future versions of this protocol specification may add new fields. Implementations must not invent their own header fields; only changes to this specification may introduce new header fields.</p>
<p class="table">If an implementation sees a header field code that it does not expect, it must accept and ignore that field, as it will be part of a new (but compatible) version of this specification. This also applies to known header fields appearing in unexpected messages, for example: if a signal has a reply serial it must be ignored even though it has no meaning as of this version of the spec.</p>
<p class="table">However, implementations must not send or accept known header fields with the wrong type stored in the field value. So for example a message with an INTERFACE field of type UINT32 would be considered corrupt.</p>
<p class="table">Server implementations that might relay messages from one mutually-distrustful client to another, such as the message bus, should remove header fields that the server does not recognise. However, a client must assume that the server has not done so, unless it has evidence to the contrary, such as having checked for the HeaderFiltering message bus feature.</p>
<p class="table">New header fields controlled by the message bus (similar to SENDER) might be added to this specification in future. Such message fields should normally only be added to messages that are going to be delivered to a client that specifically requested them (for example by calling some method), and the message bus should remove those header fields from all other messages that it relays. This design principle serves two main purposes. One is to avoid unnecessary memory and throughput overhead when delivering messages to clients that are not interested in the new header fields. The other is to give clients a reason to call the method that requests those messages (otherwise, the clients would not work). This is desirable because looking at the reply to that method call is a natural way to check that the message bus guarantees to filter out faked header fields that might have been sent by malicious peers.</p>
<p class="table">Here are the currently-defined header fields:</p>
<p class="table">Conventional Name       Decimal Code    Type    Required In     Description
INVALID 0       N/A     not allowed     Not a valid field name (error if it appears in a message)
PATH    1       OBJECT_PATH     METHOD_CALL, SIGNAL     The object to send a call to, or the object a signal is emitted from. The special path /org/freedesktop/DBus/Local is reserved; implementations should not send messages with this path, and the reference implementation of the bus daemon will disconnect any application that attempts to do so. This header field is controlled by the message sender.
INTERFACE       2       STRING  SIGNAL  The interface to invoke a method call on, or that a signal is emitted from. Optional for method calls, required for signals. The special interface org.freedesktop.DBus.Local is reserved; implementations should not send messages with this interface, and the reference implementation of the bus daemon will disconnect any application that attempts to do so. This header field is controlled by the message sender.
MEMBER  3       STRING  METHOD_CALL, SIGNAL     The member, either the method name or signal name. This header field is controlled by the message sender.
ERROR_NAME      4       STRING  ERROR   The name of the error that occurred, for errors
REPLY_SERIAL    5       UINT32  ERROR, METHOD_RETURN    The serial number of the message this message is a reply to. (The serial number is the second UINT32 in the header.) This header field is controlled by the message sender.
DESTINATION     6       STRING  optional        The name of the connection this message is intended for. This field is usually only meaningful in combination with the message bus (see the section called “Message Bus Specification”), but other servers may define their own meanings for it. This header field is controlled by the message sender.
SENDER  7       STRING  optional        Unique name of the sending connection. This field is usually only meaningful in combination with the message bus, but other servers may define their own meanings for it. On a message bus, this header field is controlled by the message bus, so it is as reliable and trustworthy as the message bus itself. Otherwise, this header field is controlled by the message sender, unless there is out-of-band information that indicates otherwise.
SIGNATURE       8       SIGNATURE       optional        The signature of the message body. If omitted, it is assumed to be the empty signature "" (i.e. the body must be 0-length). This header field is controlled by the message sender.
UNIX_FDS        9       UINT32  optional        The number of Unix file descriptors that accompany the message. If omitted, it is assumed that no Unix file descriptors accompany the message. The actual file descriptors need to be transferred via platform specific mechanism out-of-band. They must be sent at the same time as part of the message itself. They may not be sent before the first byte of the message itself is transferred or after the last byte of the message itself. This header field is controlled by the message sender.
Valid Names
The various names in D-Bus messages have some restrictions.</p>
<p class="table">There is a maximum name length of 255 which applies to bus names, interfaces, and members.</p>
<p class="table">Interface names
Interfaces have names with type STRING, meaning that they must be valid UTF-8. However, there are also some additional restrictions that apply to interface names specifically:</p>
<p class="table">Interface names are composed of 2 or more elements separated by a period (<em>.</em>) character. All elements must contain at least one character.</p>
<p class="table">Each element must only contain the ASCII characters "[A-Z][a-z]<em><span class="0-9">" and must not begin with a digit.</p>
<p class="table">Interface names must not exceed the maximum name length.</p>
<p class="table">Interface names should start with the reversed DNS domain name of the author of the interface (in lower-case), like interface names in Java. It is conventional for the rest of the interface name to consist of words run together, with initial capital letters on all words ("CamelCase"). Several levels of hierarchy can be used. It is also a good idea to include the major version of the interface in the name, and increment it if incompatible changes are made; this way, a single object can implement several versions of an interface in parallel, if necessary.</p>
<p class="table">For instance, if the owner of example.com is developing a D-Bus API for a music player, they might define interfaces called com.example.MusicPlayer1, com.example.MusicPlayer1.Track and com.example.MusicPlayer1.Seekable.</p>
<p class="table">If the author&#8217;s DNS domain name contains hyphen/minus characters (<em>-</em>), which are not allowed in D-Bus interface names, they should be replaced by underscores. If the DNS domain name contains a digit immediately following a period (<em>.</em>), which is also not allowed in interface names), the interface name should add an underscore before that digit. For example, if the owner of 7-zip.org defined an interface for out-of-process plugins, it might be named org._7_zip.Plugin.</p>
<p class="table">D-Bus does not distinguish between the concepts that would be called classes and interfaces in Java: either can be identified on D-Bus by an interface name.</p>
<p class="table">Bus names
Connections have one or more bus names associated with them. A connection has exactly one bus name that is a unique connection name. The unique connection name remains with the connection for its entire lifetime. A bus name is of type STRING, meaning that it must be valid UTF-8. However, there are also some additional restrictions that apply to bus names specifically:</p>
<p class="table">Bus names that start with a colon (<em>:</em>) character are unique connection names. Other bus names are called well-known bus names.</p>
<p class="table">Bus names are composed of 1 or more elements separated by a period (<em>.</em>) character. All elements must contain at least one character.</p>
<p class="table">Each element must only contain the ASCII characters "[A-Z][a-z][0-9]</span></em>-", with "-" discouraged in new bus names. Only elements that are part of a unique connection name may begin with a digit, elements in other bus names must not begin with a digit.</p>
<p class="table">Bus names must contain at least one <em>.</em> (period) character (and thus at least two elements).</p>
<p class="table">Bus names must not begin with a <em>.</em> (period) character.</p>
<p class="table">Bus names must not exceed the maximum name length.</p>
<p class="table">Note that the hyphen (<em>-</em>) character is allowed in bus names but not in interface names. It is also problematic or not allowed in various specifications and APIs that refer to D-Bus, such as Flatpak application IDs, the DBusActivatable interface in the Desktop Entry Specification, and the convention that an application&#8217;s "main" interface and object path resemble its bus name. To avoid situations that require special-case handling, it is recommended that new D-Bus names consistently replace hyphens with underscores.</p>
<p class="table">Like interface names, well-known bus names should start with the reversed DNS domain name of the author of the interface (in lower-case), and it is conventional for the rest of the well-known bus name to consist of words run together, with initial capital letters. As with interface names, including a version number in well-known bus names is a good idea; it&#8217;s possible to have the well-known bus name for more than one version simultaneously if backwards compatibility is required.</p>
<p class="table">As with interface names, if the author&#8217;s DNS domain name contains hyphen/minus characters they should be replaced by underscores, and if it contains leading digits they should be escaped by prepending an underscore. For example, if the owner of 7-zip.org used a D-Bus name for an archiving application, it might be named org.<em>7_zip.Archiver.</p>
<p class="table">If a well-known bus name implies the presence of a "main" interface, that "main" interface is often given the same name as the well-known bus name, and situated at the corresponding object path. For instance, if the owner of example.com is developing a D-Bus API for a music player, they might define that any application that takes the well-known name com.example.MusicPlayer1 should have an object at the object path /com/example/MusicPlayer1 which implements the interface com.example.MusicPlayer1.</p>
<p class="table">Member names
Member (i.e. method or signal) names:</p>
<p class="table">Must only contain the ASCII characters "[A-Z][a-z][0-9]</em>" and may not begin with a digit.</p>
<p class="table">Must not contain the <em>.</em> (period) character.</p>
<p class="table">Must not exceed the maximum name length.</p>
<p class="table">Must be at least 1 byte in length.</p>
<p class="table">It is conventional for member names on D-Bus to consist of capitalized words with no punctuation ("camel-case"). Method names should usually be verbs, such as GetItems, and signal names should usually be a description of an event, such as ItemsChanged.</p>
<p class="table">Error names
Error names have the same restrictions as interface names.</p>
<p class="table">Error names have the same naming conventions as interface names, and often contain .Error.; for instance, the owner of example.com might define the errors com.example.MusicPlayer1.Error.FileNotFound and com.example.MusicPlayer1.Error.OutOfMemory. The errors defined by D-Bus itself, such as org.freedesktop.DBus.Error.Failed, follow a similar pattern.</p>
<p class="table">Message Types
Each of the message types (METHOD_CALL, METHOD_RETURN, ERROR, and SIGNAL) has its own expected usage conventions and header fields. This section describes these conventions.</p>
<p class="table">Method Calls
Some messages invoke an operation on a remote object. These are called method call messages and have the type tag METHOD_CALL. Such messages map naturally to methods on objects in a typical program.</p>
<p class="table">A method call message is required to have a MEMBER header field indicating the name of the method. Optionally, the message has an INTERFACE field giving the interface the method is a part of. Including the INTERFACE in all method call messages is strongly recommended.</p>
<p class="table">In the absence of an INTERFACE field, if two or more interfaces on the same object have a method with the same name, it is undefined which of those methods will be invoked. Implementations may choose to either return an error, or deliver the message as though it had an arbitrary one of those interfaces.</p>
<p class="table">In some situations (such as the well-known system bus), messages are filtered through an access-control list external to the remote object implementation. If that filter rejects certain messages by matching their interface, or accepts only messages to specific interfaces, it must also reject messages that have no INTERFACE: otherwise, malicious applications could use this to bypass the filter.</p>
<p class="table">Method call messages also include a PATH field indicating the object to invoke the method on. If the call is passing through a message bus, the message will also have a DESTINATION field giving the name of the connection to receive the message.</p>
<p class="table">When an application handles a method call message, it is required to return a reply. The reply is identified by a REPLY_SERIAL header field indicating the serial number of the METHOD_CALL being replied to. The reply can have one of two types; either METHOD_RETURN or ERROR.</p>
<p class="table">If the reply has type METHOD_RETURN, the arguments to the reply message are the return value(s) or "out parameters" of the method call. If the reply has type ERROR, then an "exception" has been thrown, and the call fails; no return value will be provided. It makes no sense to send multiple replies to the same method call.</p>
<p class="table">Even if a method call has no return values, a METHOD_RETURN reply is required, so the caller will know the method was successfully processed.</p>
<p class="table">The METHOD_RETURN or ERROR reply message must have the REPLY_SERIAL header field.</p>
<p class="table">If a METHOD_CALL message has the flag NO_REPLY_EXPECTED, then the application receiving the method should not send the reply message (regardless of whether the reply would have been METHOD_RETURN or ERROR).</p>
<p class="table">Unless a message has the flag NO_AUTO_START, if the destination name does not exist then a program to own the destination name will be started (activated) before the message is delivered. See the section called “Message Bus Starting Services (Activation)”. The message will be held until the new program is successfully started or has failed to start; in case of failure, an error will be returned. This flag is only relevant in the context of a message bus, it is ignored during one-to-one communication with no intermediate bus.</p>
<p class="table">Mapping method calls to native APIs
APIs for D-Bus may map method calls to a method call in a specific programming language, such as C<code>, or may map a method call written in an IDL to a D-Bus message.</p>
<p class="table">In APIs of this nature, arguments to a method are often termed "in" (which implies sent in the METHOD_CALL), or "out" (which implies returned in the METHOD_RETURN). Some APIs such as CORBA also have "inout" arguments, which are both sent and received, i.e. the caller passes in a value which is modified. Mapped to D-Bus, an "inout" argument is equivalent to an "in" argument, followed by an "out" argument. You can&#8217;t pass things "by reference" over the wire, so "inout" is purely an illusion of the in-process API.</p>
<p class="table">Given a method with zero or one return values, followed by zero or more arguments, where each argument may be "in", "out", or "inout", the caller constructs a message by appending each "in" or "inout" argument, in order. "out" arguments are not represented in the caller&#8217;s message.</p>
<p class="table">The recipient constructs a reply by appending first the return value if any, then each "out" or "inout" argument, in order. "in" arguments are not represented in the reply message.</p>
<p class="table">Error replies are normally mapped to exceptions in languages that have exceptions.</p>
<p class="table">In converting from native APIs to D-Bus, it is perhaps nice to map D-Bus naming conventions ("FooBar") to native conventions such as "fooBar" or "foo_bar" automatically. This is OK as long as you can say that the native API is one that was specifically written for D-Bus. It makes the most sense when writing object implementations that will be exported over the bus. Object proxies used to invoke remote D-Bus objects probably need the ability to call any D-Bus method, and thus a magic name mapping like this could be a problem.</p>
<p class="table">This specification doesn&#8217;t require anything of native API bindings; the preceding is only a suggested convention for consistency among bindings.</p>
<p class="table">Signal Emission
Unlike method calls, signal emissions have no replies. A signal emission is simply a single message of type SIGNAL. It must have three header fields: PATH giving the object the signal was emitted from, plus INTERFACE and MEMBER giving the fully-qualified name of the signal. The INTERFACE header is required for signals, though it is optional for method calls.</p>
<p class="table">Errors
Messages of type ERROR are most commonly replies to a METHOD_CALL, but may be returned in reply to any kind of message. The message bus for example will return an ERROR in reply to a signal emission if the bus does not have enough memory to send the signal.</p>
<p class="table">An ERROR may have any arguments, but if the first argument is a STRING, it must be an error message. The error message may be logged or shown to the user in some way.</p>
<p class="table">Notation in this document
This document uses a simple pseudo-IDL to describe particular method calls and signals. Here is an example of a method call:</p>
<p class="table">            org.freedesktop.DBus.StartServiceByName (in STRING name, in UINT32 flags,
                                                     out UINT32 resultcode)</p>
<p class="table">This means INTERFACE = org.freedesktop.DBus, MEMBER = StartServiceByName, METHOD_CALL arguments are STRING and UINT32, METHOD_RETURN argument is UINT32. Remember that the MEMBER field can&#8217;t contain any <em>.</em> (period) characters so it&#8217;s known that the last part of the name in the "IDL" is the member name.</p>
<p class="table">In C</code> that might end up looking like this:</p>
<p class="table">            unsigned int org::freedesktop::DBus::StartServiceByName (const char  *name,
                                                                     unsigned int flags);</p>
<p class="table">or equally valid, the return value could be done as an argument:</p>
<p class="table">            void org::freedesktop::DBus::StartServiceByName (const char   *name,
                                                             unsigned int  flags,
                                                             unsigned int *resultcode);</p>
<p class="table">It&#8217;s really up to the API designer how they want to make this look. You could design an API where the namespace wasn&#8217;t used in C++, using STL or Qt, using varargs, or whatever you wanted.</p>
<p class="table">Signals are written as follows:</p>
<p class="table">            org.freedesktop.DBus.NameLost (STRING name)</p>
<p class="table">Signals don&#8217;t specify "in" vs. "out" because only a single direction is possible.</p>
<p class="table">It isn&#8217;t especially encouraged to use this lame pseudo-IDL in actual API implementations; you might use the native notation for the language you&#8217;re using, or you might use COM or CORBA IDL, for example.</p>
<p class="table">Invalid Protocol and Spec Extensions
For security reasons, the D-Bus protocol should be strictly parsed and validated, with the exception of defined extension points. Any invalid protocol or spec violations should result in immediately dropping the connection without notice to the other end. Exceptions should be carefully considered, e.g. an exception may be warranted for a well-understood idiosyncrasy of a widely-deployed implementation. In cases where the other end of a connection is 100% trusted and known to be friendly, skipping validation for performance reasons could also make sense in certain cases.</p>
<p class="table">Generally speaking violations of the "must" requirements in this spec should be considered possible attempts to exploit security, and violations of the "should" suggestions should be considered legitimate (though perhaps they should generate an error in some cases).</p>
<p class="table">The following extension points are built in to D-Bus on purpose and must not be treated as invalid protocol. The extension points are intended for use by future versions of this spec, they are not intended for third parties. At the moment, the only way a third party could extend D-Bus without breaking interoperability would be to introduce a way to negotiate new feature support as part of the auth protocol, using EXTENSION_-prefixed commands. There is not yet a standard way to negotiate features.</p>
<p class="table">In the authentication protocol (see the section called “Authentication Protocol”) unknown commands result in an ERROR rather than a disconnect. This enables future extensions to the protocol. Commands starting with EXTENSION_ are reserved for third parties.</p>
<p class="table">The authentication protocol supports pluggable auth mechanisms.</p>
<p class="table">The address format (see the section called “Server Addresses”) supports new kinds of transport.</p>
<p class="table">Messages with an unknown type (something other than METHOD_CALL, METHOD_RETURN, ERROR, SIGNAL) are ignored. Unknown-type messages must still be well-formed in the same way as the known messages, however. They still have the normal header and body.</p>
<p class="table">Header fields with an unknown or unexpected field code must be ignored, though again they must still be well-formed.</p>
<p class="table">New standard interfaces (with new methods and signals) can of course be added.</p>
<p class="table">Authentication Protocol
Before the flow of messages begins, two applications must authenticate. A simple plain-text protocol is used for authentication; this protocol is a SASL profile, and maps fairly directly from the SASL specification. The message encoding is NOT used here, only plain text messages.</p>
<p class="table">Using SASL in D-Bus requires that we define the meaning of non-empty authorization identity strings. When D-Bus is used on Unix platforms, a non-empty SASL authorization identity represents a Unix user. An authorization identity consisting entirely of ASCII decimal digits represents a numeric user ID as defined by POSIX, for example 0 for the root user or 1000 for the first user created on many systems. Non-numeric authorization identities are not required to be accepted or supported, but if used, they must be interpreted as a login name as found in the pw_name field of POSIX struct passwd, for example root, and normalized to the corresponding numeric user ID. For best interoperability, clients and servers should use numeric user IDs.</p>
<p class="table">When D-Bus is used on Windows platforms, a non-empty SASL authorization identity represents a Windows security identifier (SID) in its string form, for example S-1-5-21-3623811015-3361044348-30300820-1013 for a domain or local computer user or S-1-5-18 for the LOCAL_SYSTEM user. The user-facing usernames such as Administrator or LOCAL_SYSTEM are not used in the D-Bus protocol.</p>
<p class="table">In examples, "C:" and "S:" indicate lines sent by the client and server respectively. The client sends the first line, and the server must respond to each line from the client with a single-line reply, with one exception: there is no reply to the BEGIN command.</p>
<p class="table">Protocol Overview
The protocol is a line-based protocol, where each line ends with \r\n. Each line begins with an all-caps ASCII command name containing only the character range [A-Z_], a space, then any arguments for the command, then the \r\n ending the line. The protocol is case-sensitive. All bytes must be in the ASCII character set. Commands from the client to the server are as follows:</p>
<p class="table">AUTH [mechanism] [initial-response]</p>
<p class="table">CANCEL</p>
<p class="table">BEGIN</p>
<p class="table">DATA &lt;data in hex encoding&gt;</p>
<p class="table">ERROR [human-readable error explanation]</p>
<p class="table">NEGOTIATE_UNIX_FD</p>
<p class="table">From server to client are as follows:</p>
<p class="table">REJECTED &lt;space-separated list of mechanism names&gt;</p>
<p class="table">OK &lt;GUID in hex&gt;</p>
<p class="table">DATA &lt;data in hex encoding&gt;</p>
<p class="table">ERROR [human-readable error explanation]</p>
<p class="table">AGREE_UNIX_FD</p>
<p class="table">Unofficial extensions to the command set must begin with the letters "EXTENSION_", to avoid conflicts with future official commands. For example, "EXTENSION_COM_MYDOMAIN_DO_STUFF".</p>
<p class="table">Special credentials-passing nul byte
Immediately after connecting to the server, the client must send a single nul byte. This byte may be accompanied by credentials information on some operating systems that use sendmsg() with SCM_CREDS or SCM_CREDENTIALS to pass credentials over UNIX domain sockets. However, the nul byte must be sent even on other kinds of socket, and even on operating systems that do not require a byte to be sent in order to transmit credentials. The text protocol described in this document begins after the single nul byte. If the first byte received from the client is not a nul byte, the server may disconnect that client.</p>
<p class="table">A nul byte in any context other than the initial byte is an error; the protocol is ASCII-only.</p>
<p class="table">The credentials sent along with the nul byte may be used with the SASL mechanism EXTERNAL.</p>
<p class="table">AUTH command
The AUTH command is sent by the client to the server. The server replies with DATA, OK or REJECTED.</p>
<p class="table">If an AUTH command has no arguments, it is a request to list available mechanisms. The server must respond with a REJECTED command listing the mechanisms it understands, or with an error.</p>
<p class="table">If an AUTH command specifies a mechanism, and the server supports said mechanism, the server should begin exchanging SASL challenge-response data with the client using DATA commands.</p>
<p class="table">If the server does not support the mechanism given in the AUTH command, it must send either a REJECTED command listing the mechanisms it does support, or an error.</p>
<p class="table">If the [initial-response] argument is provided, it is intended for use with mechanisms that have no initial challenge (or an empty initial challenge), as if it were the argument to an initial DATA command. If the selected mechanism has an initial challenge and [initial-response] was provided, the server should reject authentication by sending REJECTED.</p>
<p class="table">If authentication succeeds after exchanging DATA commands, an OK command must be sent to the client.</p>
<p class="table">CANCEL Command
The CANCEL command is sent by the client to the server. The server replies with REJECTED.</p>
<p class="table">At any time up to sending the BEGIN command, the client may send a CANCEL command. On receiving the CANCEL command, the server must send a REJECTED command and abort the current authentication exchange.</p>
<p class="table">DATA Command
The DATA command may come from either client or server, and simply contains a hex-encoded block of data to be interpreted according to the SASL mechanism in use. If sent by the client, the server replies with DATA, OK or REJECTED.</p>
<p class="table">Some SASL mechanisms support sending an "empty string"; FIXME we need some way to do this.</p>
<p class="table">BEGIN Command
The BEGIN command is sent by the client to the server. The server does not reply.</p>
<p class="table">The BEGIN command acknowledges that the client has received an OK command from the server and completed any feature negotiation that it wishes to do, and declares that the stream of messages is about to begin.</p>
<p class="table">The first octet received by the server after the \r\n of the BEGIN command from the client must be the first octet of the authenticated/encrypted stream of D-Bus messages.</p>
<p class="table">Unlike all other commands, the server does not reply to the BEGIN command with an authentication command of its own. After the \r\n of the reply to the command before BEGIN, the next octet received by the client must be the first octet of the authenticated/encrypted stream of D-Bus messages.</p>
<p class="table">REJECTED Command
The REJECTED command is sent by the server to the client.</p>
<p class="table">The REJECTED command indicates that the current authentication exchange has failed, and further exchange of DATA is inappropriate. The client would normally try another mechanism, or try providing different responses to challenges.</p>
<p class="table">Optionally, the REJECTED command has a space-separated list of available auth mechanisms as arguments. If a server ever provides a list of supported mechanisms, it must provide the same list each time it sends a REJECTED message. Clients are free to ignore all lists received after the first.</p>
<p class="table">OK Command
The OK command is sent by the server to the client.</p>
<p class="table">The OK command indicates that the client has been authenticated. The client may now proceed with negotiating Unix file descriptor passing. To do that it shall send NEGOTIATE_UNIX_FD to the server.</p>
<p class="table">Otherwise, the client must respond to the OK command by sending a BEGIN command, followed by its stream of messages, or by disconnecting. The server must not accept additional commands using this protocol after the BEGIN command has been received. Further communication will be a stream of D-Bus messages (optionally encrypted, as negotiated) rather than this protocol.</p>
<p class="table">If there is no negotiation, the first octet received by the client after the \r\n of the OK command must be the first octet of the authenticated/encrypted stream of D-Bus messages. If the client negotiates Unix file descriptor passing, the first octet received by the client after the \r\n of the AGREE_UNIX_FD or ERROR reply must be the first octet of the authenticated/encrypted stream.</p>
<p class="table">The OK command has one argument, which is the GUID of the server. See the section called “Server Addresses” for more on server GUIDs.</p>
<p class="table">ERROR Command
The ERROR command can be sent in either direction. If sent by the client, the server replies with REJECTED.</p>
<p class="table">The ERROR command indicates that either server or client did not know a command, does not accept the given command in the current context, or did not understand the arguments to the command. This allows the protocol to be extended; a client or server can send a command present or permitted only in new protocol versions, and if an ERROR is received instead of an appropriate response, fall back to using some other technique.</p>
<p class="table">If an ERROR is sent, the server or client that sent the error must continue as if the command causing the ERROR had never been received. However, the the server or client receiving the error should try something other than whatever caused the error; if only canceling/rejecting the authentication.</p>
<p class="table">If the D-Bus protocol changes incompatibly at some future time, applications implementing the new protocol would probably be able to check for support of the new protocol by sending a new command and receiving an ERROR from applications that don&#8217;t understand it. Thus the ERROR feature of the auth protocol is an escape hatch that lets us negotiate extensions or changes to the D-Bus protocol in the future.</p>
<p class="table">NEGOTIATE_UNIX_FD Command
The NEGOTIATE_UNIX_FD command is sent by the client to the server. The server replies with AGREE_UNIX_FD or ERROR.</p>
<p class="table">The NEGOTIATE_UNIX_FD command indicates that the client supports Unix file descriptor passing. This command may only be sent after the connection is authenticated, i.e. after OK was received by the client. This command may only be sent on transports that support Unix file descriptor passing.</p>
<p class="table">On receiving NEGOTIATE_UNIX_FD the server must respond with either AGREE_UNIX_FD or ERROR. It shall respond the former if the transport chosen supports Unix file descriptor passing and the server supports this feature. It shall respond the latter if the transport does not support Unix file descriptor passing, the server does not support this feature, or the server decides not to enable file descriptor passing due to security or other reasons.</p>
<p class="table">AGREE_UNIX_FD Command
The AGREE_UNIX_FD command is sent by the server to the client.</p>
<p class="table">The AGREE_UNIX_FD command indicates that the server supports Unix file descriptor passing. This command may only be sent after the connection is authenticated, and the client sent NEGOTIATE_UNIX_FD to enable Unix file descriptor passing. This command may only be sent on transports that support Unix file descriptor passing.</p>
<p class="table">On receiving AGREE_UNIX_FD the client must respond with BEGIN, followed by its stream of messages, or by disconnecting. The server must not accept additional commands using this protocol after the BEGIN command has been received. Further communication will be a stream of D-Bus messages (optionally encrypted, as negotiated) rather than this protocol.</p>
<p class="table">Future Extensions
Future extensions to the authentication and negotiation protocol are possible. For that new commands may be introduced. If a client or server receives an unknown command it shall respond with ERROR and not consider this fatal. New commands may be introduced both before, and after authentication, i.e. both before and after the OK command.</p>
<p class="table">Authentication examples
Figure 1. Example of successful EXTERNAL authentication</p>
<p class="table">            31303030 is ASCII decimal "1000" represented in hex, so
            the client is authenticating as Unix uid 1000 in this example.</p>
<p class="table">            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 2. Example of finding out mechanisms then picking one</p>
<p class="table">            C: AUTH
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 3. Example of client sends unknown command then falls back to regular auth</p>
<p class="table">            532d312d352d3138 is the Windows SID "S-1-5-18" in hex,
            so the client is authenticating as Windows SID S-1-5-18
            in this example.</p>
<p class="table">            C: FOOBAR
            S: ERROR
            C: AUTH EXTERNAL 532d312d352d3138
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 4. Example of server doesn&#8217;t support initial auth mechanism</p>
<p class="table">            C: AUTH EXTERNAL
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 5. Example of wrong password or the like followed by successful retry</p>
<p class="table">            C: AUTH EXTERNAL 736d6376
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: REJECTED
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 6. Example of skey cancelled and restarted</p>
<p class="table">            C: AUTH EXTERNAL 32303438
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: CANCEL
            S: REJECTED
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN</p>
<p class="table">Figure 7. Example of successful EXTERNAL authentication with successful negotiation of Unix FD passing</p>
<p class="table">            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: NEGOTIATE_UNIX_FD
            S: AGREE_UNIX_FD
            C: BEGIN</p>
<p class="table">Figure 8. Example of successful EXTERNAL authentication with unsuccessful negotiation of Unix FD passing</p>
<p class="table">            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: NEGOTIATE_UNIX_FD
            S: ERROR Not supported on this OS
            C: BEGIN</p>
<p class="table">Authentication state diagrams
This section documents the auth protocol in terms of a state machine for the client and the server. This is probably the most robust way to implement the protocol.</p>
<p class="table">Client states
To more precisely describe the interaction between the protocol state machine and the authentication mechanisms the following notation is used: MECH(CHALL) means that the server challenge CHALL was fed to the mechanism MECH, which returns one of</p>
<p class="table">CONTINUE(RESP) means continue the auth conversation and send RESP as the response to the server;</p>
<p class="table">OK(RESP) means that after sending RESP to the server the client side of the auth conversation is finished and the server should return "OK";</p>
<p class="table">ERROR means that CHALL was invalid and could not be processed.</p>
<p class="table">Both RESP and CHALL may be empty.</p>
<p class="table">The Client starts by getting an initial response from the default mechanism and sends AUTH MECH RESP, or AUTH MECH if the mechanism did not provide an initial response. If the mechanism returns CONTINUE, the client starts in state WaitingForData, if the mechanism returns OK the client starts in state WaitingForOK.</p>
<p class="table">The client should keep track of available mechanisms and which it mechanisms it has already attempted. This list is used to decide which AUTH command to send. When the list is exhausted, the client should give up and close the connection.</p>
<p class="table">WaitingForData.</p>
<p class="table">Receive DATA CHALL</p>
<p class="table">MECH(CHALL) returns CONTINUE(RESP) → send DATA RESP, goto WaitingForData
MECH(CHALL) returns OK(RESP) → send DATA RESP, goto WaitingForOK
MECH(CHALL) returns ERROR → send ERROR [msg], goto WaitingForData
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p>
<p class="table">Receive ERROR → send CANCEL, goto WaitingForReject</p>
<p class="table">Receive OK → authenticated, choose one:</p>
<p class="table">send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive anything else → send ERROR, goto WaitingForData</p>
<p class="table">WaitingForOK.</p>
<p class="table">Receive OK → authenticated, choose one:</p>
<p class="table">send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p>
<p class="table">Receive DATA → send CANCEL, goto WaitingForReject</p>
<p class="table">Receive ERROR → send CANCEL, goto WaitingForReject</p>
<p class="table">Receive anything else → send ERROR, goto WaitingForOK</p>
<p class="table">WaitingForReject.</p>
<p class="table">Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p>
<p class="table">Receive anything else → terminate auth conversation, disconnect</p>
<p class="table">WaitingForAgreeUnixFD.  By the time this state is reached, the client has already been authenticated.</p>
<p class="table">Receive AGREE_UNIX_FD → enable Unix fd passing, send BEGIN, terminate auth conversation (successfully)</p>
<p class="table">Receive ERROR → disable Unix fd passing, send BEGIN, terminate auth conversation (successfully)</p>
<p class="table">Receive anything else → terminate auth conversation, disconnect</p>
<p class="table">Server states
For the server MECH(RESP) means that the client response RESP was fed to the the mechanism MECH, which returns one of</p>
<p class="table">CONTINUE(CHALL) means continue the auth conversation and send CHALL as the challenge to the client;</p>
<p class="table">OK means that the client has been successfully authenticated;</p>
<p class="table">REJECTED means that the client failed to authenticate or there was an error in RESP.</p>
<p class="table">The server starts out in state WaitingForAuth. If the client is rejected too many times the server must disconnect the client.</p>
<p class="table">WaitingForAuth.</p>
<p class="table">Receive AUTH → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive AUTH MECH RESP</p>
<p class="table">MECH not valid mechanism → send REJECTED [mechs], goto WaitingForAuth
MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect</p>
<p class="table">Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive anything else → send ERROR, goto WaitingForAuth</p>
<p class="table">WaitingForData.</p>
<p class="table">Receive DATA RESP</p>
<p class="table">MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect</p>
<p class="table">Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive anything else → send ERROR, goto WaitingForData</p>
<p class="table">WaitingForBegin.</p>
<p class="table">Receive BEGIN → terminate auth conversation, client authenticated</p>
<p class="table">Receive NEGOTIATE_UNIX_FD → send AGREE_UNIX_FD or ERROR, goto WaitingForBegin</p>
<p class="table">Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p>
<p class="table">Receive anything else → send ERROR, goto WaitingForBegin</p>
<p class="table">Authentication mechanisms
This section describes some authentication mechanisms that are often supported by practical D-Bus implementations. The D-Bus protocol also allows any other standard SASL mechanism, although implementations of D-Bus often do not.</p>
<p class="table">EXTERNAL
The EXTERNAL mechanism is defined in RFC 4422 "Simple Authentication and Security Layer (SASL)", appendix A "The SASL EXTERNAL Mechanism". This is the recommended authentication mechanism on platforms where credentials can be transferred out-of-band, in particular Unix platforms that can perform credentials-passing over the unix: transport.</p>
<p class="table">On Unix platforms, interoperable clients should prefer to send the ASCII decimal string form of the integer Unix user ID as the authorization identity, for example 1000. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 31303030 followed by \r\n.</p>
<p class="table">On Windows platforms, clients that use the EXTERNAL mechanism should use the Windows security identifier in its string form as the authorization identity, for example S-1-5-21-3623811015-3361044348-30300820-1013 for a domain or local computer user or S-1-5-18 for the LOCAL_SYSTEM user. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 532d312d352d3138 followed by \r\n.</p>
<p class="table">DBUS_COOKIE_SHA1
DBUS_COOKIE_SHA1 is a D-Bus-specific SASL mechanism. Its reference implementation is part of the reference implementation of D-Bus.</p>
<p class="table">This mechanism is designed to establish that a client has the ability to read a private file owned by the user being authenticated. If the client can prove that it has access to a secret cookie stored in this file, then the client is authenticated. Thus the security of DBUS_COOKIE_SHA1 depends on a secure home directory. This is the recommended authentication mechanism for platforms and configurations where EXTERNAL cannot be used.</p>
<p class="table">Throughout this description, "hex encoding" must output the digits from a to f in lower-case; the digits A to F must not be used in the DBUS_COOKIE_SHA1 mechanism.</p>
<p class="table">Authentication proceeds as follows:</p>
<p class="table">The client sends the username it would like to authenticate as, hex-encoded.</p>
<p class="table">The server sends the name of its "cookie context" (see below); a space character; the integer ID of the secret cookie the client must demonstrate knowledge of; a space character; then a randomly-generated challenge string, all of this hex-encoded into one, single string.</p>
<p class="table">The client locates the cookie and generates its own randomly-generated challenge string. The client then concatenates the server&#8217;s decoded challenge, a ":" character, its own challenge, another ":" character, and the cookie. It computes the SHA-1 hash of this composite string as a hex digest. It concatenates the client&#8217;s challenge string, a space character, and the SHA-1 hex digest, hex-encodes the result and sends it back to the server.</p>
<p class="table">The server generates the same concatenated string used by the client and computes its SHA-1 hash. It compares the hash with the hash received from the client; if the two hashes match, the client is authenticated.</p>
<p class="table">Each server has a "cookie context," which is a name that identifies a set of cookies that apply to that server. A sample context might be "org_freedesktop_session_bus". Context names must be valid ASCII, nonzero length, and may not contain the characters slash ("/"), backslash ("\"), space (" "), newline ("\n"), carriage return ("\r"), tab ("\t"), or period ("."). There is a default context, "org_freedesktop_general" that&#8217;s used by servers that do not specify otherwise.</p>
<p class="table">Cookies are stored in a user&#8217;s home directory, in the directory ~/.dbus-keyrings/. This directory must not be readable or writable by other users. If it is, clients and servers must ignore it. The directory contains cookie files named after the cookie context.</p>
<p class="table">A cookie file contains one cookie per line. Each line has three space-separated fields:</p>
<p class="table">The cookie ID number, which must be a non-negative integer and may not be used twice in the same file.</p>
<p class="table">The cookie&#8217;s creation time, in UNIX seconds-since-the-epoch format.</p>
<p class="table">The cookie itself, a hex-encoded random block of bytes. The cookie may be of any length, though obviously security increases as the length increases.</p>
<p class="table">Only server processes modify the cookie file. They must do so with this procedure:</p>
<p class="table">Create a lockfile name by appending ".lock" to the name of the cookie file. The server should attempt to create this file using O_CREAT</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-05-08 02:54:42 EEST
</div>
</div>
</body>
</html>
