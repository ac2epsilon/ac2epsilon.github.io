<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_d_bus_specification">.D-Bus Specification</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>D-Bus - це система низько-навантаженого, простого у використанні міжпроцесорного зв'язку (IPC). Більш детально:</p></div>
<div class="ulist"><ul>
<li>
<p>
D-Bus є <em>низько-навантаженим</em>, оскільки він використовує двійковий протокол, і не повинен перетворювати його в текстовий формат, наприклад XML. Оскільки D-Bus призначений для потенційно IPC на одній машині з високою роздільною здатністю, не в першу чергу для Internet IPC, це цікава оптимізація. D-Bus також призначений для уникнення кругових маршрутів і спроможності асинхронної роботи, подібно до протоколу X.
</p>
</li>
<li>
<p>
D-Bus <em>простий у використанні</em>, оскільки він працює в термінах повідомлень, а не потоків байтів, і автоматично обробляє безліч важких проблем з IPC. Крім того, бібліотека D-Bus розроблена так, щоб вона була огорнута таким чином, що дозволяє розробникам використовувати існуючу систему об'єктів/типів їхніх фреймворків, а не вивчати нову спеціально для IPC.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Базовий протокол D-Bus - це протокол "один на один" (одноранговий або клієнт-сервер), визначений у розділі "Протокол повідомлення". Тобто це система для одного додатку для спілкування з одним іншим додатком. Однак основним призначенням протоколу є шина повідомлень D-Bus, зазначена в розділі "Специфікація шини повідомлень". Шина повідомлень - це спеціальна програма, яка приймає з'єднання з декількох інших додатків та пересилає повідомлення серед них.</p></div>
<div class="paragraph"><p>Використання D-Bus включає сповіщення про зміни системи (повідомлення про те, коли камера підключена до комп'ютера чи встановлена ​​нова версія якогось програмного забезпечення) або сумісність робочого столу, наприклад, служба моніторингу файлів або служба конфігурації.</p></div>
<div class="paragraph"><p>D-Bus призначений для двох конкретних випадків використання:</p></div>
<div class="paragraph"><p>"Системна шина" для сповіщень від системи до сеансів користувача та щоб дозволити системі запитувати введення даних із сеансів користувача.</p></div>
<div class="paragraph"><p>"Шина сеансу", що використовується для реалізації середовищ настільних ПК, таких як GNOME та KDE.</p></div>
<div class="paragraph"><p>D-Bus не призначений бути загальною системою IPC для будь-якого можливого застосування, і навмисно упускає багато можливостей, знайдених в інших системах IPC з цієї причини.</p></div>
<div class="paragraph"><p>У той же час демони шини пропонують ряд функцій, які не зустрічаються в інших системах IPC, такі як "власні назви шин" для одного власника (подібні до X-вибору), запуск послуг на вимогу та політика безпеки. Багато в чому ці особливості є основною мотивацією для розвитку D-Bus; інших систем було б достатньо, якби IPC була єдиною метою.</p></div>
<div class="paragraph"><p>D-Bus може виявитися корисним у непередбачуваних застосуваннях, але майбутні версії цієї специфікації та посилання на реалізацію, ймовірно, не включатимуть функції, що заважають основним випадкам використання.</p></div>
<div class="paragraph"><p>У цьому документі ключові слова "ОБОВ'ЯЗКОВО", "НЕ ПОВИННІ", "ВИМАГАЄТЬСЯ", "ПОТРІБНО", "МАЄ", "НЕ МАЄ", "РЕКОМЕНДОВАНО", "МОЖУ" та "ОПЦІЙНО" тлумачити так, як описано в RFC 2119. Однак документ може використовувати серйозний аудит, щоб переконатися, що це має сенс. Також вони не використовуються з великої літери.</p></div>
</div>
<div class="sect2">
<h3 id="____">Стабільність протоколу та специфікації</h3>
<div class="paragraph"><p>Протокол D-Bus заморожено (дозволені лише сумісні розширення) з 8 листопада 2006 року. Однак ця специфікація може все-таки використати неабияку роботу, щоб зробити можливим взаємодіючу імплементацію без посилання на реалізацію посилання D-Bus. Таким чином, ця специфікація не позначена 1,0. Щоб позначити це 1.0, ми хотіли б, щоб хтось вкладав значні зусилля в роз'яснення мови специфікацій та розширення специфікації, щоб охопити більше аспектів поведінки формальної реалізації.</p></div>
<div class="paragraph"><p>Поки ця робота не буде завершена, будь-яка спроба повторного втілення D-Bus, ймовірно, потребує перегляду посилання на реалізацію та/або задавання питань у списку розсилки D-Bus щодо наміченої поведінки. Питання в списку дуже вітаються.</p></div>
<div class="paragraph"><p>Тим не менш, цей документ повинен бути корисним початковим пунктом і, наскільки нам відомо, точним, хоча і неповним.</p></div>
</div>
<div class="sect2">
<h3 id="__">Система типів</h3>
<div class="paragraph"><p>D-Bus має систему типів, в якій значення різних типів можуть бути серіалізовані в послідовність байтів, що називаються дротяним форматом стандартним способом. Перетворення значення з якогось іншого представлення у дротяний формат називається маршалінг, а перетворення його назад із дротяного формату - демаршалінг.</p></div>
<div class="paragraph"><p>Протокол D-Bus не включає теги типів у даних маршалінгу; блок значень маршалінгу повинен мати відомий тип підпису. Підпис типу складається з нуля або більше окрених повних типів, кожен складається з одного або декількох кодів типу.</p></div>
<div class="paragraph"><p>Код типу - символ ASCII, що представляє тип значення. Оскільки використовуються символи ASCII, підпис типу завжди утворюватиме гідний рядок ASCII. Просте порівняння рядків визначає, чи два підписи рівнозначні.</p></div>
<div class="paragraph"><p>A single complete type is a sequence of type codes that fully describes one type: either a basic type, or a single fully-described container type. A single complete type is a basic type code, a variant type code, an array with its element type, or a struct with its fields (all of which are defined below). So the following signatures are not single complete types:
Окремий повний тип - це послідовність типів кодів, яка повністю описує один тип: або основний тип, або єдиний повністю описаний тип контейнера. Одиничний повний тип - це базовий код типу, код варіанту типу, масив з його типом елемента або структура з полями (усі вони визначені нижче). Отже, наступні підписи не є єдиними повними типами: <code>aa</code>, <code>(ii</code>, <code>ii)</code>. А наступні підписи містять кілька повних типів: <code>ii</code>, <code>aiai</code>, <code>(ii)(ii)</code>.</p></div>
<div class="paragraph"><p>Зауважте, однак, що один повний тип може містити декілька інших одиничних повних типів, що містять <code>struct</code> або запис <code>dict</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Основні типи</h3>
<div class="paragraph"><p>Найпростіші типи кодів - основні типи, структура яких повністю визначена їх 1-символьним кодом типу. Основні типи складаються з фіксованих типів і строкоподібних типів.</p></div>
<div class="paragraph"><p>Фіксовані типи - це базові типи, значення яких мають фіксовану довжину, а саме: <code>BYTE</code>, <code>BOOLEAN</code>, <code>DOUBLE</code>, <code>UNIX_FD</code> та знакові або беззнакові цілі числа довжиною 16, 32 або 64 біт.</p></div>
<div class="paragraph"><p>Як простий приклад, код типу для 32-бітного цілого числа (<code>INT32</code>) - символ ASCII <code>i</code>. Отже, підписом для блоку значень, що містить єдиний <code>INT32</code>, було б: <code>i</code>. Блок значень, що містить два <code>INT32</code>, повинен мати цей підпис: <code>ii</code>.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Характеристики фіксованих типів.</caption>
<col width="20%" />
<col width="13%" />
<col width="66%" />
<thead>
<tr>
<th align="left" valign="top">Звичайна назва</th>
<th align="center" valign="top">Код ASCII</th>
<th align="left" valign="top">Кодування</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">BYTE</p></td>
<td align="center" valign="top"><p class="table">y (121)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 8-бітне ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BOOLEAN</p></td>
<td align="center" valign="top"><p class="table">b (98)</p></td>
<td align="left" valign="top"><p class="table">Булеве значення: 0 - брехня, 1 - істина, будь-яке інше значення, дозволене форматом маршалінгу, недійсне</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT16</p></td>
<td align="center" valign="top"><p class="table">n (110)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 16-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT16</p></td>
<td align="center" valign="top"><p class="table">q (113)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 16-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT32</p></td>
<td align="center" valign="top"><p class="table">i (105)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 32-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT32</p></td>
<td align="center" valign="top"><p class="table">u (117)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 32-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">INT64</p></td>
<td align="center" valign="top"><p class="table">x (120)</p></td>
<td align="left" valign="top"><p class="table">Знакове (доповнення до двох) 64-бітове ціле число (нагадування: x і t є першими символами "шістдесяти", які вже не використовуються для чогось більш поширеного)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UINT64</p></td>
<td align="center" valign="top"><p class="table">t (116)</p></td>
<td align="left" valign="top"><p class="table">Беззнакове 64-бітове ціле число</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">DOUBLE</p></td>
<td align="center" valign="top"><p class="table">d (100)</p></td>
<td align="left" valign="top"><p class="table">IEEE 754 з плаваючою точкою подвійної точності</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">UNIX_FD</p></td>
<td align="center" valign="top"><p class="table">h (104)</p></td>
<td align="left" valign="top"><p class="table">32-розрядне ціле число без знака, представляє індекс у позадіапазонному масиві дескрипторів файлів, переданих через якийсь механізм, орієнтований на платформу (мнемонічний: h для ручки)</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Рядко-подібні типи - це базові типи зі змінною довжиною. Значення будь-якого рядкового типу - це концептуально 0 або більше кодових точок Unicode, закодованих у UTF-8, жодна з яких не може бути U + 0000. Текст UTF-8 повинен бути чітко підтверджений: зокрема, він не повинен містити надто довгих послідовностей або кодових точок вище <code>U+10FFFF</code>.</p></div>
<div class="paragraph"><p>Оскільки специфікація D-Bus версії 0.21, відповідно до виправлення Unicode № 9, "несимволи" <code>U+FDD0..U+FDEF</code>, <code>U+nFFFE</code> та <code>U+nFFFF</code> дозволені в рядках UTF-8 (але зауважте, що старіші версії D-Bus відхиляли ці несимволи).</p></div>
<div class="paragraph"><p>Формати маршалінгу для рядко-подібних типів закінчуються одним байтом нуля (<code>NUL</code>), але цей байт не вважається частиною тексту.</p></div>
<div class="tableblock">
<table rules="all"
width="50%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Характеристики рядко-подібних типів.</caption>
<col width="20%" />
<col width="13%" />
<col width="66%" />
<thead>
<tr>
<th align="left" valign="top"> Звичайна назва </th>
<th align="center" valign="top"> ASCII код типу </th>
<th align="left" valign="top"> Обмеження дійсності</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">STRING</p></td>
<td align="center" valign="top"><p class="table">s (115)</p></td>
<td align="left" valign="top"><p class="table">Без зайвих обмежень</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">OBJECT_PATH</p></td>
<td align="center" valign="top"><p class="table">o (111)</p></td>
<td align="left" valign="top"><p class="table">Повинен бути синтаксично дійсний шлях до об'єкта</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">SIGNATURE</p></td>
<td align="center" valign="top"><p class="table">g (103)</p></td>
<td align="left" valign="top"><p class="table">Нуль або більше окремих повних типів</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_____2">Дійсні шляхи об'єктів</h4>
<div class="paragraph"><p>Шлях до об'єкта - це ім'я, яке використовується для позначення екземпляра об'єкта. У концептуальному плані кожен учасник обміну повідомленнями D-Bus може мати будь-яку кількість екземплярів об'єктів (думайте я про об'єкти C ++ або Java), і кожен такий екземпляр матиме шлях. Як і файлова система, об'єкт екземпляри в додатку утворюють ієрархічне дерево.</p></div>
<div class="paragraph"><p>Шляхи до об'єктів часто представлені просторами імен, починаючи із зворотного доменного імені та містять номер версії інтерфейсу так само, як імена інтерфейсів та гарно відомі імена шини. Це дає можливість реалізувати більше одного сервісу або більше однієї версії послуги в одному процесі, навіть якщо служби поділяють з'єднання, але не можуть інакше співпрацювати (наприклад, якщо вони реалізовані різними плагінами).</p></div>
<div class="paragraph"><p>Використання об'єктного шляху <code>/</code> дозволено, але не рекомендується, оскільки це ускладнює створення версій інтерфейсів. Будь-які сигнали, що випромінюються від об'єкта D-Bus, мають унікальне ім'я шини, пов'язане з ними, а не його відоме ім'я. Це означає, що одержувачі сигналів повинні повністю покладатися на ім'я сигналу та шлях об'єкта, щоб визначити, з якого інтерфейсу походить сигнал.</p></div>
<div class="paragraph"><p>Наприклад, якщо власник <code>example.com</code> розробляє API D-Bus для музичного плеєра, він може використовувати ієрархію об'єктних шляхів, що починаються з <code>/com/example/MusicPlayer1</code> для його об'єктів.</p></div>
<div class="paragraph"><p>Наступні правила визначають дійсний шлях до об'єкта. Програми не повинні надсилати та приймати повідомлення з недійсними об'єктними шляхами.</p></div>
<div class="ulist"><ul>
<li>
<p>
Шлях може бути будь-якої довжини.
</p>
</li>
<li>
<p>
Шлях повинен починатися з символу ASCII <code>'/'</code> (ціле число 47) і повинен складатися з елементів, розділених косою рисою.
</p>
</li>
<li>
<p>
Кожен елемент повинен містити лише символи ASCII <code>"[A-Z][a-z][0-9]_"</code>
</p>
</li>
<li>
<p>
Жоден елемент не може бути порожнім рядком.
</p>
</li>
<li>
<p>
Кілька символів <code>'/'</code> не можуть стояти послідовно.
</p>
</li>
<li>
<p>
Заключний символ <code>'/'</code> не дозволений, якщо шлях не є кореневим шляхом (єдиний символ <code>'/'</code>).
</p>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="___3">Дійсні підписи</h4>
<div class="paragraph"><p>Реалізація не повинна надсилати або приймати недійсні підписи. Дійсні підписи відповідають таким правилам:</p></div>
<div class="ulist"><ul>
<li>
<p>
Підпис - це список окремих повних типів. Масиви повинні мати типи елементів, а структури повинні мати відкриті і закриті дужки.
</p>
</li>
<li>
<p>
У підписі дозволено використовувати лише коди, відкриті та закриті дужки та відкриті та закриті фігурні дужки. Код типу <code>STRUCT</code> у підписах заборонений, оскільки замість нього використовуються круглі дужки. Аналогічно, код типу <code>DICT_ENTRY</code> у підписах заборонений, оскільки замість нього використовуються фігурні дужки.
</p>
</li>
<li>
<p>
Максимальна глибина вкладення типу контейнера - 32 коди типу масиву та 32 відкриті дужки. Це означає, що максимальна загальна глибина рекурсії становить 64, для "масиву масиву масиву &#8230; структура в структурі &#8230;", де є 32 масиви та 32 struct.
</p>
</li>
<li>
<p>
Максимальна довжина підпису - 255.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Коли підписи з'являються в повідомленнях, формат маршалінгу гарантує, що за ними буде слідувати нульовий байт (який можна інтерпретувати як припинення рядка в стилі С або код типу <code>INVALID</code>), але це концептуально не є частиною підпису.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___4">Типи контейнерів</h3>
<div class="paragraph"><p>Окрім основних типів, є чотири типи контейнерів: <code>STRUCT</code>, <code>ARRAY</code>, <code>VARIANT</code> та <code>DICT_ENTRY</code>.</p></div>
<div class="paragraph"><p><code>STRUCT</code> має код типу, ASCII символ <code>'r'</code>, але цей тип коду не відображається в підписах. Натомість символи ASCII використовуються <code>'('</code> і <code>')'</code> для позначення початку та кінця структури. Так, наприклад, структура, що містить два цілих числа, мала б цей підпис: <code>"(ii)"</code></p></div>
<div class="paragraph"><p>Структури можуть бути вкладені, наприклад, структура, що містить ціле число та іншу структуру: <code>"(i(ii))"</code></p></div>
<div class="paragraph"><p>Блок значення, що зберігає цю структуру, міститиме три цілі числа; підпис типу дозволяє відрізнити <code>"(i (ii))"</code> від <code>"((ii) i)"</code> або <code>"(iii)"</code> або <code>"iii"</code>.</p></div>
<div class="paragraph"><p>Код типу <code>STRUCT</code> <code>'r'</code> наразі не використовується в протоколі D-Bus, але корисний у коді, який реалізує протокол. Цей тип коду визначений, щоб дозволити такому коду взаємодіяти в непротокольних контекстах.</p></div>
<div class="paragraph"><p>Порожні структури не допускаються; між дужками повинен бути принаймні один код типу.</p></div>
<div class="paragraph"><p>Код типу <code>ARRAY</code> має символ ASCII <code>'a'</code>. Коду типу масиву повинен дотримуватися один повний тип. Єдиний повний тип, що слідує за масивом, - це тип кожного елемента масиву. Тож простий приклад: <code>"ai"</code>, що є масивом 32-бітових цілих чисел. Але масив може бути будь-якого типу, наприклад, цей масив структур з двох полів <code>int32</code>: <code>"a(ii)"</code>. Або цей масив масиву цілих чисел: <code>"aai"</code></p></div>
<div class="paragraph"><p>Код типу <code>VARIANT</code> має символ ASCII <code>'v'</code>. Значення з маршовим типом типу <code>VARIANT</code> матиме підпис одного повного типу як частини значення. Після цього підпису буде додано маршаловане значення цього типу.</p></div>
<div class="paragraph"><p>На відміну від підпису повідомлення, варіантний підпис може містити лише один повний тип. Отже, <code>"i"</code>, <code>"ai"</code> або <code>"(ii)"</code> в порядку, але <code>"ii"</code> - ні. Використання варіантів не може призвести до того, що загальна глибина повідомлення перевищує 64, включаючи інші типи контейнерів, такі як структури.</p></div>
<div class="paragraph"><p><code>DICT_ENTRY</code> працює точно як структура, але замість дужок він використовує фігурні дужки і має більше обмежень. Обмеження наступні: це зустрічається лише як тип елемента масиву; у нього рівно два окемих цілих типи всередині фігурних брекетів; перший тип ("ключ") повинен бути основним типом, а не типом контейнера. Реалізації не повинні приймати записи словника за межами масивів, не повинні приймати записи словника з нулем, одним або більше двох полів і не повинні приймати записи словника з ключами, що не належать до основного типу. Запис у словнику - це завжди пара ключ-значення.</p></div>
<div class="paragraph"><p>Перше поле в <code>DICT_ENTRY</code> завжди є ключовим. Повідомлення вважається пошкодженим, якщо однаковий ключ зустрічається двічі в одному масиві <code>DICT_ENTRY</code>. Однак з міркувань продуктивності реалізації не потрібно відкидати словники з повторюваними ключами.</p></div>
<div class="paragraph"><p>У більшості мов масив записів словника буде представлений у вигляді мапи, хеш-таблиці або об’єкта словника.</p></div>
</div>
<div class="sect2">
<h3 id="___">Підсумок щодо типів</h3>
<div class="paragraph"><p>У наступній таблиці підсумовані типи D-Bus.</p></div>
<div class="tableblock">
<table rules="all"
width="80%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="7%" />
<col width="14%" />
<col width="21%" />
<col width="57%" />
<thead>
<tr>
<th align="left" valign="top"> Категорія    </th>
<th align="left" valign="top"> Умовна назва </th>
<th align="left" valign="top">Код </th>
<th align="left" valign="top"> Опис</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">INVALID</p></td>
<td align="left" valign="top"><p class="table">0 (ASCII NUL)</p></td>
<td align="left" valign="top"><p class="table">Недійсний код типу, який використовується для завершення підпису</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">BYTE</p></td>
<td align="left" valign="top"><p class="table">121 (ASCII <em>y</em>)</p></td>
<td align="left" valign="top"><p class="table">8-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">BOOLEAN</p></td>
<td align="left" valign="top"><p class="table">98 (ASCII <em>b</em>)</p></td>
<td align="left" valign="top"><p class="table">Логічне значення, 0 FALSE, 1 TRUE. Все інше недійсне.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT16</p></td>
<td align="left" valign="top"><p class="table">110 (ASCII <em>n</em>)</p></td>
<td align="left" valign="top"><p class="table">16-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT16</p></td>
<td align="left" valign="top"><p class="table">113 (ASCII <em>q</em>)</p></td>
<td align="left" valign="top"><p class="table">16-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT32</p></td>
<td align="left" valign="top"><p class="table">105 (ASCII <em>i</em>)</p></td>
<td align="left" valign="top"><p class="table">32-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT32</p></td>
<td align="left" valign="top"><p class="table">117 (ASCII <em>u</em>)</p></td>
<td align="left" valign="top"><p class="table">32-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">INT64</p></td>
<td align="left" valign="top"><p class="table">120 (ASCII <em>x</em>)</p></td>
<td align="left" valign="top"><p class="table">64-бітне знакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UINT64</p></td>
<td align="left" valign="top"><p class="table">116 (ASCII <em>t</em>)</p></td>
<td align="left" valign="top"><p class="table">64-бітне беззнакове ціле</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">DOUBLE</p></td>
<td align="left" valign="top"><p class="table">100 (ASCII <em>d</em>)</p></td>
<td align="left" valign="top"><p class="table">IEEE 754 подвійної точності</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">STRING</p></td>
<td align="left" valign="top"><p class="table">115 (ASCII <em>s</em>)</p></td>
<td align="left" valign="top"><p class="table">UTF-8 рядок (має бути дійсним UTF-8). Повинно бути нуль-термінованим та не містити інші байти nul.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">OBJECT_PATH</p></td>
<td align="left" valign="top"><p class="table">111 (ASCII <em>o</em>)</p></td>
<td align="left" valign="top"><p class="table">Ім'я примірника об'єкта</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">s-like, basic</p></td>
<td align="left" valign="top"><p class="table">SIGNATURE</p></td>
<td align="left" valign="top"><p class="table">103 (ASCII <em>g</em>)</p></td>
<td align="left" valign="top"><p class="table">Сигнатура типу</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">ARRAY</p></td>
<td align="left" valign="top"><p class="table">97 (ASCII <em>a</em>)</p></td>
<td align="left" valign="top"><p class="table">Масив</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">STRUCT</p></td>
<td align="left" valign="top"><p class="table">114 (ASCII <em>r</em>), 40 (ASCII <em>(</em>), 41 (ASCII <em>)</em>)</p></td>
<td align="left" valign="top"><p class="table">Структура; код типу 114 <em>r</em> зарезервований для використання у прив'язках та реалізаціях для представлення загальної концепції структури, і не повинен відображатися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">VARIANT</p></td>
<td align="left" valign="top"><p class="table">118 (ASCII <em>v</em>)</p></td>
<td align="left" valign="top"><p class="table">Тип варіанту (тип значення є частиною самого значення)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">container</p></td>
<td align="left" valign="top"><p class="table">DICT_ENTRY</p></td>
<td align="left" valign="top"><p class="table">101 (ASCII <em>e</em>), 123 (ASCII <em>{</em>), 125 (ASCII <em>}</em>)</p></td>
<td align="left" valign="top"><p class="table">Запис у dict або map (масив пар ключ-значення). Код типу 101 <em>e</em> зарезервований для використання у прив'язках та реалізації, щоб представити загальну концепцію dict або dict-entry, і не повинен відображатися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">fixed, basic</p></td>
<td align="left" valign="top"><p class="table">UNIX_FD</p></td>
<td align="left" valign="top"><p class="table">104 (ASCII <em>h</em>)</p></td>
<td align="left" valign="top"><p class="table">Файловий дескриптор Unix</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">109 (ASCII <em>m</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для типу "можливо", сумісного з типом у GVariant, і не повинно з'являтися у підписах, що використовуються на D-Bus, поки не вказано тут</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">42 (ASCII <em>*</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого окремого повного типу і не повинно з'являтися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">63 (ASCII <em>?</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого базового типу і не повинно з'являтися в підписах, використовуваних на D-Bus.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">reserved</p></td>
<td align="left" valign="top"><p class="table">(reserved)</p></td>
<td align="left" valign="top"><p class="table">64 (ASCII <em>@</em>), 38 (ASCII <em>&amp;</em>), 94 (ASCII <em>^</em>)</p></td>
<td align="left" valign="top"><p class="table">Зарезервовано для внутрішнього використання шляхом прив'язки/реалізації та не повинно відображатися у підписах, що використовуються на D-Bus. GVariant використовує ці типи кодів для кодування умовних викликів.</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="____2">Маршалінг (дротовий формат)</h3>
<div class="paragraph"><p>D-Bus defines a marshalling format for its type system, which is used in D-Bus messages. This is not the only possible marshalling format for the type system: for instance, GVariant (part of GLib) re-uses the D-Bus type system but implements an alternative marshalling format.</p></div>
<div class="paragraph"><p>Byte order and alignment
Given a type signature, a block of bytes can be converted into typed values. This section describes the format of the block of bytes. Byte order and alignment issues are handled uniformly for all D-Bus types.</p></div>
<div class="paragraph"><p>A block of bytes has an associated byte order. The byte order has to be discovered in some way; for D-Bus messages, the byte order is part of the message header as described in the section called “Message Format”. For now, assume that the byte order is known to be either little endian or big endian.</p></div>
<div class="paragraph"><p>Each value in a block of bytes is aligned "naturally," for example 4-byte values are aligned to a 4-byte boundary, and 8-byte values to an 8-byte boundary. Boundaries are calculated globally, with respect to the first byte in the message. To properly align a value, alignment padding may be necessary before the value. The alignment padding must always be the minimum required padding to properly align the following value; and it must always be made up of nul bytes. The alignment padding must not be left uninitialized (it can&#8217;t contain garbage), and more padding than required must not be used.</p></div>
<div class="paragraph"><p>As an exception to natural alignment, STRUCT and DICT_ENTRY values are always aligned to an 8-byte boundary, regardless of the alignments of their contents.</p></div>
<div class="paragraph"><p>Marshalling basic types
To marshal and unmarshal fixed types, you simply read one value from the data block corresponding to each type code in the signature. All signed integer values are encoded in two&#8217;s complement, DOUBLE values are IEEE 754 double-precision floating-point, and BOOLEAN values are encoded in 32 bits (of which only the least significant bit is used).</p></div>
<div class="paragraph"><p>The string-like types (STRING, OBJECT_PATH and SIGNATURE) are all marshalled as a fixed-length unsigned integer n giving the length of the variable part, followed by n nonzero bytes of UTF-8 text, followed by a single zero (nul) byte which is not considered to be part of the text. The alignment of the string-like type is the same as the alignment of n: any padding required for n appears immediately before n itself. There is never any alignment padding between n and the string text, or between the string text and the trailing nul. The alignment padding for the next value in the message (if there is one) starts after the trailing nul.</p></div>
<div class="paragraph"><p>For the STRING and OBJECT_PATH types, n is encoded in 4 bytes (a UINT32), leading to 4-byte alignment. For the SIGNATURE type, n is encoded as a single byte (a UINT8). As a result, alignment padding is never required before a SIGNATURE.</p></div>
<div class="paragraph"><p>For example, if the current position is a multiple of 8 bytes from the beginning of a little-endian message, strings ‘foo’, ‘+’ and ‘bar’ would be serialized in sequence as follows:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>                                          no padding required, we are already at a multiple of 4
0x03 0x00 0x00 0x00                       length of ‘foo’ = 3
                    0x66 0x6f 0x6f        ‘foo’
                                   0x00   trailing nul</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>                                          no padding required, we are already at a multiple of 4
0x01 0x00 0x00 0x00                       length of ‘+’ = 1
                    0x2b                  ‘+’
                         0x00             trailing nul</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>                               0x00 0x00  2 bytes of padding to reach next multiple of 4
0x03 0x00 0x00 0x00                       length of ‘bar’ = 3
                    0x62 0x61 0x72        ‘bar’
                                    0x00  trailing nul</code></pre>
</div></div>
<div class="paragraph"><p>Marshalling containers
Arrays are marshalled as a UINT32 n giving the length of the array data in bytes, followed by alignment padding to the alignment boundary of the array element type, followed by the n bytes of the array elements marshalled in sequence. n does not include the padding after the length, or any padding after the last element. i.e. n should be divisible by the number of elements in the array.</p></div>
<div class="paragraph"><p>For instance, if the current position in the message is a multiple of 8 bytes and the byte-order is big-endian, an array containing only the 64-bit integer 5 would be marshalled as:</p></div>
<div class="paragraph"><p>00 00 00 08               n = 8 bytes of data
00 00 00 00               padding to 8-byte boundary
00 00 00 00  00 00 00 05  first element = 5</p></div>
<div class="paragraph"><p>Arrays have a maximum length defined to be 2 to the 26th power or 67108864 (64 MiB). Implementations must not send or accept arrays exceeding this length.</p></div>
<div class="paragraph"><p>Structs and dict entries are marshalled in the same way as their contents, but their alignment is always to an 8-byte boundary, even if their contents would normally be less strictly aligned.</p></div>
<div class="paragraph"><p>Variants are marshalled as the SIGNATURE of the contents (which must be a single complete type), followed by a marshalled value with the type given by that signature. The variant has the same 1-byte alignment as the signature, which means that alignment padding before a variant is never needed. Use of variants must not cause a total message depth to be larger than 64, including other container types such as structures. (See Valid Signatures.)</p></div>
<div class="paragraph"><p>Summary of D-Bus marshalling
Given all this, the types are marshaled on the wire as follows:</p></div>
<div class="paragraph"><p>Conventional Name       Encoding        Alignment
INVALID Not applicable; cannot be marshaled.    N/A
BYTE    A single 8-bit byte.    1
BOOLEAN As for UINT32, but only 0 and 1 are valid values.       4
INT16   16-bit signed integer in the message&#8217;s byte order.      2
UINT16  16-bit unsigned integer in the message&#8217;s byte order.    2
INT32   32-bit signed integer in the message&#8217;s byte order.      4
UINT32  32-bit unsigned integer in the message&#8217;s byte order.    4
INT64   64-bit signed integer in the message&#8217;s byte order.      8
UINT64  64-bit unsigned integer in the message&#8217;s byte order.    8
DOUBLE  64-bit IEEE 754 double in the message&#8217;s byte order.     8
STRING  A UINT32 indicating the string&#8217;s length in bytes excluding its terminating nul, followed by non-nul string data of the given length, followed by a terminating nul byte.        4 (for the length)
OBJECT_PATH     Exactly the same as STRING except the content must be a valid object path (see above).  4 (for the length)
SIGNATURE       The same as STRING except the length is a single byte (thus signatures have a maximum length of 255) and the content must be a valid signature (see above).     1
ARRAY   A UINT32 giving the length of the array data in bytes, followed by alignment padding to the alignment boundary of the array element type, followed by each array element.       4 (for the length)
STRUCT  A struct must start on an 8-byte boundary regardless of the type of the struct fields. The struct value consists of each field marshaled in sequence starting from that 8-byte alignment boundary.      8
VARIANT The marshaled SIGNATURE of a single complete type, followed by a marshaled value with the type given in the signature.  1 (alignment of the signature)
DICT_ENTRY      Identical to STRUCT.    8
UNIX_FD 32-bit unsigned integer in the message&#8217;s byte order. The actual file descriptors need to be transferred out-of-band via some platform specific mechanism. On the wire, values of this type store the index to the file descriptor in the array of file descriptors that accompany the message.  4
Message Protocol
A message consists of a header and a body. If you think of a message as a package, the header is the address, and the body contains the package contents. The message delivery system uses the header information to figure out where to send the message and how to interpret it; the recipient interprets the body of the message.</p></div>
<div class="paragraph"><p>The body of the message is made up of zero or more arguments, which are typed values, such as an integer or a byte array.</p></div>
<div class="paragraph"><p>Both header and body use the D-Bus type system and format for serializing data.</p></div>
<div class="paragraph"><p>Message Format
A message consists of a header and a body. The header is a block of values with a fixed signature and meaning. The body is a separate block of values, with a signature specified in the header.</p></div>
<div class="paragraph"><p>The length of the header must be a multiple of 8, allowing the body to begin on an 8-byte boundary when storing the entire message in a single buffer. If the header does not naturally end on an 8-byte boundary up to 7 bytes of nul-initialized alignment padding must be added.</p></div>
<div class="paragraph"><p>The message body need not end on an 8-byte boundary.</p></div>
<div class="paragraph"><p>The maximum length of a message, including header, header alignment padding, and body is 2 to the 27th power or 134217728 (128 MiB). Implementations must not send or accept messages exceeding this size.</p></div>
<div class="paragraph"><p>The signature of the header is:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>"yyyyuua(yv)"</code></pre>
</div></div>
<div class="paragraph"><p>Written out more readably, this is:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>BYTE, BYTE, BYTE, BYTE, UINT32, UINT32, ARRAY of STRUCT of (BYTE,VARIANT)</code></pre>
</div></div>
<div class="paragraph"><p>These values have the following meanings:</p></div>
<div class="paragraph"><p>Value   Description
1st BYTE        Endianness flag; ASCII <em>l</em> for little-endian or ASCII <em>B</em> for big-endian. Both header and body are in this endianness.
2nd BYTE        Message type. Unknown types must be ignored. Currently-defined types are described below.
3rd BYTE        Bitwise OR of flags. Unknown flags must be ignored. Currently-defined flags are described below.
4th BYTE        Major protocol version of the sending application. If the major protocol version of the receiving application does not match, the applications will not be able to communicate and the D-Bus connection must be disconnected. The major protocol version for this version of the specification is 1.
1st UINT32      Length in bytes of the message body, starting from the end of the header. The header ends after its alignment padding to an 8-boundary.
2nd UINT32      The serial of this message, used as a cookie by the sender to identify the reply corresponding to this request. This must not be zero.
ARRAY of STRUCT of (BYTE,VARIANT)       An array of zero or more header fields where the byte is the field code, and the variant is the field value. The message type determines which fields are required.
Message types that can appear in the second byte of the header are:</p></div>
<div class="paragraph"><p>Conventional name       Decimal value   Description
INVALID 0       This is an invalid type.
METHOD_CALL     1       Method call. This message type may prompt a reply.
METHOD_RETURN   2       Method reply with returned data.
ERROR   3       Error reply. If the first argument exists and is a string, it is an error message.
SIGNAL  4       Signal emission.
Flags that can appear in the third byte of the header:</p></div>
<div class="paragraph"><p>Conventional name       Hex value       Description
NO_REPLY_EXPECTED       0x1
This message does not expect method return replies or error replies, even if it is of a type that can have a reply; the reply should be omitted.</p></div>
<div class="paragraph"><p>Note that METHOD_CALL is the only message type currently defined in this specification that can expect a reply, so the presence or absence of this flag in the other three message types that are currently documented is meaningless: replies to those message types should not be sent, whether this flag is present or not.</p></div>
<div class="paragraph"><p>NO_AUTO_START   0x2     The bus must not launch an owner for the destination name in response to this message.
ALLOW_INTERACTIVE_AUTHORIZATION 0x4
This flag may be set on a method call message to inform the receiving side that the caller is prepared to wait for interactive authorization, which might take a considerable time to complete. For instance, if this flag is set, it would be appropriate to query the user for passwords or confirmation via Polkit or a similar framework.</p></div>
<div class="paragraph"><p>This flag is only useful when unprivileged code calls a more privileged method call, and an authorization framework is deployed that allows possibly interactive authorization. If no such framework is deployed it has no effect. This flag should not be set by default by client implementations. If it is set, the caller should also set a suitably long timeout on the method call to make sure the user interaction may complete. This flag is only valid for method call messages, and shall be ignored otherwise.</p></div>
<div class="paragraph"><p>Interaction that takes place as a part of the effect of the method being called is outside the scope of this flag, even if it could also be characterized as authentication or authorization. For instance, in a method call that directs a network management service to attempt to connect to a virtual private network, this flag should control how the network management service makes the decision "is this user allowed to change system network configuration?", but it should not affect how or whether the network management service interacts with the user to obtain the credentials that are required for access to the VPN.</p></div>
<div class="paragraph"><p>If a this flag is not set on a method call, and a service determines that the requested operation is not allowed without interactive authorization, but could be allowed after successful interactive authorization, it may return the org.freedesktop.DBus.Error.InteractiveAuthorizationRequired error.</p></div>
<div class="paragraph"><p>The absence of this flag does not guarantee that interactive authorization will not be applied, since existing services that pre-date this flag might already use interactive authorization. However, existing D-Bus APIs that will use interactive authorization should document that the call may take longer than usual, and new D-Bus APIs should avoid interactive authorization in the absence of this flag.</p></div>
<div class="paragraph"><p>Header Fields
The array at the end of the header contains header fields, where each field is a 1-byte field code followed by a field value. A header must contain the required header fields for its message type, and zero or more of any optional header fields. Future versions of this protocol specification may add new fields. Implementations must not invent their own header fields; only changes to this specification may introduce new header fields.</p></div>
<div class="paragraph"><p>If an implementation sees a header field code that it does not expect, it must accept and ignore that field, as it will be part of a new (but compatible) version of this specification. This also applies to known header fields appearing in unexpected messages, for example: if a signal has a reply serial it must be ignored even though it has no meaning as of this version of the spec.</p></div>
<div class="paragraph"><p>However, implementations must not send or accept known header fields with the wrong type stored in the field value. So for example a message with an INTERFACE field of type UINT32 would be considered corrupt.</p></div>
<div class="paragraph"><p>Server implementations that might relay messages from one mutually-distrustful client to another, such as the message bus, should remove header fields that the server does not recognise. However, a client must assume that the server has not done so, unless it has evidence to the contrary, such as having checked for the HeaderFiltering message bus feature.</p></div>
<div class="paragraph"><p>New header fields controlled by the message bus (similar to SENDER) might be added to this specification in future. Such message fields should normally only be added to messages that are going to be delivered to a client that specifically requested them (for example by calling some method), and the message bus should remove those header fields from all other messages that it relays. This design principle serves two main purposes. One is to avoid unnecessary memory and throughput overhead when delivering messages to clients that are not interested in the new header fields. The other is to give clients a reason to call the method that requests those messages (otherwise, the clients would not work). This is desirable because looking at the reply to that method call is a natural way to check that the message bus guarantees to filter out faked header fields that might have been sent by malicious peers.</p></div>
<div class="paragraph"><p>Here are the currently-defined header fields:</p></div>
<div class="paragraph"><p>Conventional Name       Decimal Code    Type    Required In     Description
INVALID 0       N/A     not allowed     Not a valid field name (error if it appears in a message)
PATH    1       OBJECT_PATH     METHOD_CALL, SIGNAL     The object to send a call to, or the object a signal is emitted from. The special path /org/freedesktop/DBus/Local is reserved; implementations should not send messages with this path, and the reference implementation of the bus daemon will disconnect any application that attempts to do so. This header field is controlled by the message sender.
INTERFACE       2       STRING  SIGNAL  The interface to invoke a method call on, or that a signal is emitted from. Optional for method calls, required for signals. The special interface org.freedesktop.DBus.Local is reserved; implementations should not send messages with this interface, and the reference implementation of the bus daemon will disconnect any application that attempts to do so. This header field is controlled by the message sender.
MEMBER  3       STRING  METHOD_CALL, SIGNAL     The member, either the method name or signal name. This header field is controlled by the message sender.
ERROR_NAME      4       STRING  ERROR   The name of the error that occurred, for errors
REPLY_SERIAL    5       UINT32  ERROR, METHOD_RETURN    The serial number of the message this message is a reply to. (The serial number is the second UINT32 in the header.) This header field is controlled by the message sender.
DESTINATION     6       STRING  optional        The name of the connection this message is intended for. This field is usually only meaningful in combination with the message bus (see the section called “Message Bus Specification”), but other servers may define their own meanings for it. This header field is controlled by the message sender.
SENDER  7       STRING  optional        Unique name of the sending connection. This field is usually only meaningful in combination with the message bus, but other servers may define their own meanings for it. On a message bus, this header field is controlled by the message bus, so it is as reliable and trustworthy as the message bus itself. Otherwise, this header field is controlled by the message sender, unless there is out-of-band information that indicates otherwise.
SIGNATURE       8       SIGNATURE       optional        The signature of the message body. If omitted, it is assumed to be the empty signature "" (i.e. the body must be 0-length). This header field is controlled by the message sender.
UNIX_FDS        9       UINT32  optional        The number of Unix file descriptors that accompany the message. If omitted, it is assumed that no Unix file descriptors accompany the message. The actual file descriptors need to be transferred via platform specific mechanism out-of-band. They must be sent at the same time as part of the message itself. They may not be sent before the first byte of the message itself is transferred or after the last byte of the message itself. This header field is controlled by the message sender.
Valid Names
The various names in D-Bus messages have some restrictions.</p></div>
<div class="paragraph"><p>There is a maximum name length of 255 which applies to bus names, interfaces, and members.</p></div>
<div class="paragraph"><p>Interface names
Interfaces have names with type STRING, meaning that they must be valid UTF-8. However, there are also some additional restrictions that apply to interface names specifically:</p></div>
<div class="paragraph"><p>Interface names are composed of 2 or more elements separated by a period (<em>.</em>) character. All elements must contain at least one character.</p></div>
<div class="paragraph"><p>Each element must only contain the ASCII characters "[A-Z][a-z][0-9]_" and must not begin with a digit.</p></div>
<div class="paragraph"><p>Interface names must not exceed the maximum name length.</p></div>
<div class="paragraph"><p>Interface names should start with the reversed DNS domain name of the author of the interface (in lower-case), like interface names in Java. It is conventional for the rest of the interface name to consist of words run together, with initial capital letters on all words ("CamelCase"). Several levels of hierarchy can be used. It is also a good idea to include the major version of the interface in the name, and increment it if incompatible changes are made; this way, a single object can implement several versions of an interface in parallel, if necessary.</p></div>
<div class="paragraph"><p>For instance, if the owner of example.com is developing a D-Bus API for a music player, they might define interfaces called com.example.MusicPlayer1, com.example.MusicPlayer1.Track and com.example.MusicPlayer1.Seekable.</p></div>
<div class="paragraph"><p>If the author&#8217;s DNS domain name contains hyphen/minus characters (<em>-</em>), which are not allowed in D-Bus interface names, they should be replaced by underscores. If the DNS domain name contains a digit immediately following a period (<em>.</em>), which is also not allowed in interface names), the interface name should add an underscore before that digit. For example, if the owner of 7-zip.org defined an interface for out-of-process plugins, it might be named org._7_zip.Plugin.</p></div>
<div class="paragraph"><p>D-Bus does not distinguish between the concepts that would be called classes and interfaces in Java: either can be identified on D-Bus by an interface name.</p></div>
<div class="paragraph"><p>Bus names
Connections have one or more bus names associated with them. A connection has exactly one bus name that is a unique connection name. The unique connection name remains with the connection for its entire lifetime. A bus name is of type STRING, meaning that it must be valid UTF-8. However, there are also some additional restrictions that apply to bus names specifically:</p></div>
<div class="paragraph"><p>Bus names that start with a colon (<em>:</em>) character are unique connection names. Other bus names are called well-known bus names.</p></div>
<div class="paragraph"><p>Bus names are composed of 1 or more elements separated by a period (<em>.</em>) character. All elements must contain at least one character.</p></div>
<div class="paragraph"><p>Each element must only contain the ASCII characters "[A-Z][a-z][0-9]_-", with "-" discouraged in new bus names. Only elements that are part of a unique connection name may begin with a digit, elements in other bus names must not begin with a digit.</p></div>
<div class="paragraph"><p>Bus names must contain at least one <em>.</em> (period) character (and thus at least two elements).</p></div>
<div class="paragraph"><p>Bus names must not begin with a <em>.</em> (period) character.</p></div>
<div class="paragraph"><p>Bus names must not exceed the maximum name length.</p></div>
<div class="paragraph"><p>Note that the hyphen (<em>-</em>) character is allowed in bus names but not in interface names. It is also problematic or not allowed in various specifications and APIs that refer to D-Bus, such as Flatpak application IDs, the DBusActivatable interface in the Desktop Entry Specification, and the convention that an application&#8217;s "main" interface and object path resemble its bus name. To avoid situations that require special-case handling, it is recommended that new D-Bus names consistently replace hyphens with underscores.</p></div>
<div class="paragraph"><p>Like interface names, well-known bus names should start with the reversed DNS domain name of the author of the interface (in lower-case), and it is conventional for the rest of the well-known bus name to consist of words run together, with initial capital letters. As with interface names, including a version number in well-known bus names is a good idea; it&#8217;s possible to have the well-known bus name for more than one version simultaneously if backwards compatibility is required.</p></div>
<div class="paragraph"><p>As with interface names, if the author&#8217;s DNS domain name contains hyphen/minus characters they should be replaced by underscores, and if it contains leading digits they should be escaped by prepending an underscore. For example, if the owner of 7-zip.org used a D-Bus name for an archiving application, it might be named org._7_zip.Archiver.</p></div>
<div class="paragraph"><p>If a well-known bus name implies the presence of a "main" interface, that "main" interface is often given the same name as the well-known bus name, and situated at the corresponding object path. For instance, if the owner of example.com is developing a D-Bus API for a music player, they might define that any application that takes the well-known name com.example.MusicPlayer1 should have an object at the object path /com/example/MusicPlayer1 which implements the interface com.example.MusicPlayer1.</p></div>
<div class="paragraph"><p>Member names
Member (i.e. method or signal) names:</p></div>
<div class="paragraph"><p>Must only contain the ASCII characters "[A-Z][a-z][0-9]_" and may not begin with a digit.</p></div>
<div class="paragraph"><p>Must not contain the <em>.</em> (period) character.</p></div>
<div class="paragraph"><p>Must not exceed the maximum name length.</p></div>
<div class="paragraph"><p>Must be at least 1 byte in length.</p></div>
<div class="paragraph"><p>It is conventional for member names on D-Bus to consist of capitalized words with no punctuation ("camel-case"). Method names should usually be verbs, such as GetItems, and signal names should usually be a description of an event, such as ItemsChanged.</p></div>
<div class="paragraph"><p>Error names
Error names have the same restrictions as interface names.</p></div>
<div class="paragraph"><p>Error names have the same naming conventions as interface names, and often contain .Error.; for instance, the owner of example.com might define the errors com.example.MusicPlayer1.Error.FileNotFound and com.example.MusicPlayer1.Error.OutOfMemory. The errors defined by D-Bus itself, such as org.freedesktop.DBus.Error.Failed, follow a similar pattern.</p></div>
<div class="paragraph"><p>Message Types
Each of the message types (METHOD_CALL, METHOD_RETURN, ERROR, and SIGNAL) has its own expected usage conventions and header fields. This section describes these conventions.</p></div>
<div class="paragraph"><p>Method Calls
Some messages invoke an operation on a remote object. These are called method call messages and have the type tag METHOD_CALL. Such messages map naturally to methods on objects in a typical program.</p></div>
<div class="paragraph"><p>A method call message is required to have a MEMBER header field indicating the name of the method. Optionally, the message has an INTERFACE field giving the interface the method is a part of. Including the INTERFACE in all method call messages is strongly recommended.</p></div>
<div class="paragraph"><p>In the absence of an INTERFACE field, if two or more interfaces on the same object have a method with the same name, it is undefined which of those methods will be invoked. Implementations may choose to either return an error, or deliver the message as though it had an arbitrary one of those interfaces.</p></div>
<div class="paragraph"><p>In some situations (such as the well-known system bus), messages are filtered through an access-control list external to the remote object implementation. If that filter rejects certain messages by matching their interface, or accepts only messages to specific interfaces, it must also reject messages that have no INTERFACE: otherwise, malicious applications could use this to bypass the filter.</p></div>
<div class="paragraph"><p>Method call messages also include a PATH field indicating the object to invoke the method on. If the call is passing through a message bus, the message will also have a DESTINATION field giving the name of the connection to receive the message.</p></div>
<div class="paragraph"><p>When an application handles a method call message, it is required to return a reply. The reply is identified by a REPLY_SERIAL header field indicating the serial number of the METHOD_CALL being replied to. The reply can have one of two types; either METHOD_RETURN or ERROR.</p></div>
<div class="paragraph"><p>If the reply has type METHOD_RETURN, the arguments to the reply message are the return value(s) or "out parameters" of the method call. If the reply has type ERROR, then an "exception" has been thrown, and the call fails; no return value will be provided. It makes no sense to send multiple replies to the same method call.</p></div>
<div class="paragraph"><p>Even if a method call has no return values, a METHOD_RETURN reply is required, so the caller will know the method was successfully processed.</p></div>
<div class="paragraph"><p>The METHOD_RETURN or ERROR reply message must have the REPLY_SERIAL header field.</p></div>
<div class="paragraph"><p>If a METHOD_CALL message has the flag NO_REPLY_EXPECTED, then the application receiving the method should not send the reply message (regardless of whether the reply would have been METHOD_RETURN or ERROR).</p></div>
<div class="paragraph"><p>Unless a message has the flag NO_AUTO_START, if the destination name does not exist then a program to own the destination name will be started (activated) before the message is delivered. See the section called “Message Bus Starting Services (Activation)”. The message will be held until the new program is successfully started or has failed to start; in case of failure, an error will be returned. This flag is only relevant in the context of a message bus, it is ignored during one-to-one communication with no intermediate bus.</p></div>
<div class="paragraph"><p>Mapping method calls to native APIs
APIs for D-Bus may map method calls to a method call in a specific programming language, such as C++, or may map a method call written in an IDL to a D-Bus message.</p></div>
<div class="paragraph"><p>In APIs of this nature, arguments to a method are often termed "in" (which implies sent in the METHOD_CALL), or "out" (which implies returned in the METHOD_RETURN). Some APIs such as CORBA also have "inout" arguments, which are both sent and received, i.e. the caller passes in a value which is modified. Mapped to D-Bus, an "inout" argument is equivalent to an "in" argument, followed by an "out" argument. You can&#8217;t pass things "by reference" over the wire, so "inout" is purely an illusion of the in-process API.</p></div>
<div class="paragraph"><p>Given a method with zero or one return values, followed by zero or more arguments, where each argument may be "in", "out", or "inout", the caller constructs a message by appending each "in" or "inout" argument, in order. "out" arguments are not represented in the caller&#8217;s message.</p></div>
<div class="paragraph"><p>The recipient constructs a reply by appending first the return value if any, then each "out" or "inout" argument, in order. "in" arguments are not represented in the reply message.</p></div>
<div class="paragraph"><p>Error replies are normally mapped to exceptions in languages that have exceptions.</p></div>
<div class="paragraph"><p>In converting from native APIs to D-Bus, it is perhaps nice to map D-Bus naming conventions ("FooBar") to native conventions such as "fooBar" or "foo_bar" automatically. This is OK as long as you can say that the native API is one that was specifically written for D-Bus. It makes the most sense when writing object implementations that will be exported over the bus. Object proxies used to invoke remote D-Bus objects probably need the ability to call any D-Bus method, and thus a magic name mapping like this could be a problem.</p></div>
<div class="paragraph"><p>This specification doesn&#8217;t require anything of native API bindings; the preceding is only a suggested convention for consistency among bindings.</p></div>
<div class="paragraph"><p>Signal Emission
Unlike method calls, signal emissions have no replies. A signal emission is simply a single message of type SIGNAL. It must have three header fields: PATH giving the object the signal was emitted from, plus INTERFACE and MEMBER giving the fully-qualified name of the signal. The INTERFACE header is required for signals, though it is optional for method calls.</p></div>
<div class="paragraph"><p>Errors
Messages of type ERROR are most commonly replies to a METHOD_CALL, but may be returned in reply to any kind of message. The message bus for example will return an ERROR in reply to a signal emission if the bus does not have enough memory to send the signal.</p></div>
<div class="paragraph"><p>An ERROR may have any arguments, but if the first argument is a STRING, it must be an error message. The error message may be logged or shown to the user in some way.</p></div>
<div class="paragraph"><p>Notation in this document
This document uses a simple pseudo-IDL to describe particular method calls and signals. Here is an example of a method call:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.StartServiceByName (in STRING name, in UINT32 flags,
                                         out UINT32 resultcode)</code></pre>
</div></div>
<div class="paragraph"><p>This means INTERFACE = org.freedesktop.DBus, MEMBER = StartServiceByName, METHOD_CALL arguments are STRING and UINT32, METHOD_RETURN argument is UINT32. Remember that the MEMBER field can&#8217;t contain any <em>.</em> (period) characters so it&#8217;s known that the last part of the name in the "IDL" is the member name.</p></div>
<div class="paragraph"><p>In C++ that might end up looking like this:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>unsigned int org::freedesktop::DBus::StartServiceByName (const char  *name,
                                                         unsigned int flags);</code></pre>
</div></div>
<div class="paragraph"><p>or equally valid, the return value could be done as an argument:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>void org::freedesktop::DBus::StartServiceByName (const char   *name,
                                                 unsigned int  flags,
                                                 unsigned int *resultcode);</code></pre>
</div></div>
<div class="paragraph"><p>It&#8217;s really up to the API designer how they want to make this look. You could design an API where the namespace wasn&#8217;t used in C++, using STL or Qt, using varargs, or whatever you wanted.</p></div>
<div class="paragraph"><p>Signals are written as follows:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.NameLost (STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Signals don&#8217;t specify "in" vs. "out" because only a single direction is possible.</p></div>
<div class="paragraph"><p>It isn&#8217;t especially encouraged to use this lame pseudo-IDL in actual API implementations; you might use the native notation for the language you&#8217;re using, or you might use COM or CORBA IDL, for example.</p></div>
<div class="paragraph"><p>Invalid Protocol and Spec Extensions
For security reasons, the D-Bus protocol should be strictly parsed and validated, with the exception of defined extension points. Any invalid protocol or spec violations should result in immediately dropping the connection without notice to the other end. Exceptions should be carefully considered, e.g. an exception may be warranted for a well-understood idiosyncrasy of a widely-deployed implementation. In cases where the other end of a connection is 100% trusted and known to be friendly, skipping validation for performance reasons could also make sense in certain cases.</p></div>
<div class="paragraph"><p>Generally speaking violations of the "must" requirements in this spec should be considered possible attempts to exploit security, and violations of the "should" suggestions should be considered legitimate (though perhaps they should generate an error in some cases).</p></div>
<div class="paragraph"><p>The following extension points are built in to D-Bus on purpose and must not be treated as invalid protocol. The extension points are intended for use by future versions of this spec, they are not intended for third parties. At the moment, the only way a third party could extend D-Bus without breaking interoperability would be to introduce a way to negotiate new feature support as part of the auth protocol, using EXTENSION_-prefixed commands. There is not yet a standard way to negotiate features.</p></div>
<div class="paragraph"><p>In the authentication protocol (see the section called “Authentication Protocol”) unknown commands result in an ERROR rather than a disconnect. This enables future extensions to the protocol. Commands starting with EXTENSION_ are reserved for third parties.</p></div>
<div class="paragraph"><p>The authentication protocol supports pluggable auth mechanisms.</p></div>
<div class="paragraph"><p>The address format (see the section called “Server Addresses”) supports new kinds of transport.</p></div>
<div class="paragraph"><p>Messages with an unknown type (something other than METHOD_CALL, METHOD_RETURN, ERROR, SIGNAL) are ignored. Unknown-type messages must still be well-formed in the same way as the known messages, however. They still have the normal header and body.</p></div>
<div class="paragraph"><p>Header fields with an unknown or unexpected field code must be ignored, though again they must still be well-formed.</p></div>
<div class="paragraph"><p>New standard interfaces (with new methods and signals) can of course be added.</p></div>
<div class="paragraph"><p>Authentication Protocol
Before the flow of messages begins, two applications must authenticate. A simple plain-text protocol is used for authentication; this protocol is a SASL profile, and maps fairly directly from the SASL specification. The message encoding is NOT used here, only plain text messages.</p></div>
<div class="paragraph"><p>Using SASL in D-Bus requires that we define the meaning of non-empty authorization identity strings. When D-Bus is used on Unix platforms, a non-empty SASL authorization identity represents a Unix user. An authorization identity consisting entirely of ASCII decimal digits represents a numeric user ID as defined by POSIX, for example 0 for the root user or 1000 for the first user created on many systems. Non-numeric authorization identities are not required to be accepted or supported, but if used, they must be interpreted as a login name as found in the pw_name field of POSIX struct passwd, for example root, and normalized to the corresponding numeric user ID. For best interoperability, clients and servers should use numeric user IDs.</p></div>
<div class="paragraph"><p>When D-Bus is used on Windows platforms, a non-empty SASL authorization identity represents a Windows security identifier (SID) in its string form, for example S-1-5-21-3623811015-3361044348-30300820-1013 for a domain or local computer user or S-1-5-18 for the LOCAL_SYSTEM user. The user-facing usernames such as Administrator or LOCAL_SYSTEM are not used in the D-Bus protocol.</p></div>
<div class="paragraph"><p>In examples, "C:" and "S:" indicate lines sent by the client and server respectively. The client sends the first line, and the server must respond to each line from the client with a single-line reply, with one exception: there is no reply to the BEGIN command.</p></div>
<div class="paragraph"><p>Protocol Overview
The protocol is a line-based protocol, where each line ends with \r\n. Each line begins with an all-caps ASCII command name containing only the character range [A-Z_], a space, then any arguments for the command, then the \r\n ending the line. The protocol is case-sensitive. All bytes must be in the ASCII character set. Commands from the client to the server are as follows:</p></div>
<div class="paragraph"><p>AUTH [mechanism] [initial-response]</p></div>
<div class="paragraph"><p>CANCEL</p></div>
<div class="paragraph"><p>BEGIN</p></div>
<div class="paragraph"><p>DATA &lt;data in hex encoding&gt;</p></div>
<div class="paragraph"><p>ERROR [human-readable error explanation]</p></div>
<div class="paragraph"><p>NEGOTIATE_UNIX_FD</p></div>
<div class="paragraph"><p>From server to client are as follows:</p></div>
<div class="paragraph"><p>REJECTED &lt;space-separated list of mechanism names&gt;</p></div>
<div class="paragraph"><p>OK &lt;GUID in hex&gt;</p></div>
<div class="paragraph"><p>DATA &lt;data in hex encoding&gt;</p></div>
<div class="paragraph"><p>ERROR [human-readable error explanation]</p></div>
<div class="paragraph"><p>AGREE_UNIX_FD</p></div>
<div class="paragraph"><p>Unofficial extensions to the command set must begin with the letters "EXTENSION_", to avoid conflicts with future official commands. For example, "EXTENSION_COM_MYDOMAIN_DO_STUFF".</p></div>
<div class="paragraph"><p>Special credentials-passing nul byte
Immediately after connecting to the server, the client must send a single nul byte. This byte may be accompanied by credentials information on some operating systems that use sendmsg() with SCM_CREDS or SCM_CREDENTIALS to pass credentials over UNIX domain sockets. However, the nul byte must be sent even on other kinds of socket, and even on operating systems that do not require a byte to be sent in order to transmit credentials. The text protocol described in this document begins after the single nul byte. If the first byte received from the client is not a nul byte, the server may disconnect that client.</p></div>
<div class="paragraph"><p>A nul byte in any context other than the initial byte is an error; the protocol is ASCII-only.</p></div>
<div class="paragraph"><p>The credentials sent along with the nul byte may be used with the SASL mechanism EXTERNAL.</p></div>
<div class="paragraph"><p>AUTH command
The AUTH command is sent by the client to the server. The server replies with DATA, OK or REJECTED.</p></div>
<div class="paragraph"><p>If an AUTH command has no arguments, it is a request to list available mechanisms. The server must respond with a REJECTED command listing the mechanisms it understands, or with an error.</p></div>
<div class="paragraph"><p>If an AUTH command specifies a mechanism, and the server supports said mechanism, the server should begin exchanging SASL challenge-response data with the client using DATA commands.</p></div>
<div class="paragraph"><p>If the server does not support the mechanism given in the AUTH command, it must send either a REJECTED command listing the mechanisms it does support, or an error.</p></div>
<div class="paragraph"><p>If the [initial-response] argument is provided, it is intended for use with mechanisms that have no initial challenge (or an empty initial challenge), as if it were the argument to an initial DATA command. If the selected mechanism has an initial challenge and [initial-response] was provided, the server should reject authentication by sending REJECTED.</p></div>
<div class="paragraph"><p>If authentication succeeds after exchanging DATA commands, an OK command must be sent to the client.</p></div>
<div class="paragraph"><p>CANCEL Command
The CANCEL command is sent by the client to the server. The server replies with REJECTED.</p></div>
<div class="paragraph"><p>At any time up to sending the BEGIN command, the client may send a CANCEL command. On receiving the CANCEL command, the server must send a REJECTED command and abort the current authentication exchange.</p></div>
<div class="paragraph"><p>DATA Command
The DATA command may come from either client or server, and simply contains a hex-encoded block of data to be interpreted according to the SASL mechanism in use. If sent by the client, the server replies with DATA, OK or REJECTED.</p></div>
<div class="paragraph"><p>Some SASL mechanisms support sending an "empty string"; FIXME we need some way to do this.</p></div>
<div class="paragraph"><p>BEGIN Command
The BEGIN command is sent by the client to the server. The server does not reply.</p></div>
<div class="paragraph"><p>The BEGIN command acknowledges that the client has received an OK command from the server and completed any feature negotiation that it wishes to do, and declares that the stream of messages is about to begin.</p></div>
<div class="paragraph"><p>The first octet received by the server after the \r\n of the BEGIN command from the client must be the first octet of the authenticated/encrypted stream of D-Bus messages.</p></div>
<div class="paragraph"><p>Unlike all other commands, the server does not reply to the BEGIN command with an authentication command of its own. After the \r\n of the reply to the command before BEGIN, the next octet received by the client must be the first octet of the authenticated/encrypted stream of D-Bus messages.</p></div>
<div class="paragraph"><p>REJECTED Command
The REJECTED command is sent by the server to the client.</p></div>
<div class="paragraph"><p>The REJECTED command indicates that the current authentication exchange has failed, and further exchange of DATA is inappropriate. The client would normally try another mechanism, or try providing different responses to challenges.</p></div>
<div class="paragraph"><p>Optionally, the REJECTED command has a space-separated list of available auth mechanisms as arguments. If a server ever provides a list of supported mechanisms, it must provide the same list each time it sends a REJECTED message. Clients are free to ignore all lists received after the first.</p></div>
<div class="paragraph"><p>OK Command
The OK command is sent by the server to the client.</p></div>
<div class="paragraph"><p>The OK command indicates that the client has been authenticated. The client may now proceed with negotiating Unix file descriptor passing. To do that it shall send NEGOTIATE_UNIX_FD to the server.</p></div>
<div class="paragraph"><p>Otherwise, the client must respond to the OK command by sending a BEGIN command, followed by its stream of messages, or by disconnecting. The server must not accept additional commands using this protocol after the BEGIN command has been received. Further communication will be a stream of D-Bus messages (optionally encrypted, as negotiated) rather than this protocol.</p></div>
<div class="paragraph"><p>If there is no negotiation, the first octet received by the client after the \r\n of the OK command must be the first octet of the authenticated/encrypted stream of D-Bus messages. If the client negotiates Unix file descriptor passing, the first octet received by the client after the \r\n of the AGREE_UNIX_FD or ERROR reply must be the first octet of the authenticated/encrypted stream.</p></div>
<div class="paragraph"><p>The OK command has one argument, which is the GUID of the server. See the section called “Server Addresses” for more on server GUIDs.</p></div>
<div class="paragraph"><p>ERROR Command
The ERROR command can be sent in either direction. If sent by the client, the server replies with REJECTED.</p></div>
<div class="paragraph"><p>The ERROR command indicates that either server or client did not know a command, does not accept the given command in the current context, or did not understand the arguments to the command. This allows the protocol to be extended; a client or server can send a command present or permitted only in new protocol versions, and if an ERROR is received instead of an appropriate response, fall back to using some other technique.</p></div>
<div class="paragraph"><p>If an ERROR is sent, the server or client that sent the error must continue as if the command causing the ERROR had never been received. However, the the server or client receiving the error should try something other than whatever caused the error; if only canceling/rejecting the authentication.</p></div>
<div class="paragraph"><p>If the D-Bus protocol changes incompatibly at some future time, applications implementing the new protocol would probably be able to check for support of the new protocol by sending a new command and receiving an ERROR from applications that don&#8217;t understand it. Thus the ERROR feature of the auth protocol is an escape hatch that lets us negotiate extensions or changes to the D-Bus protocol in the future.</p></div>
<div class="paragraph"><p>NEGOTIATE_UNIX_FD Command
The NEGOTIATE_UNIX_FD command is sent by the client to the server. The server replies with AGREE_UNIX_FD or ERROR.</p></div>
<div class="paragraph"><p>The NEGOTIATE_UNIX_FD command indicates that the client supports Unix file descriptor passing. This command may only be sent after the connection is authenticated, i.e. after OK was received by the client. This command may only be sent on transports that support Unix file descriptor passing.</p></div>
<div class="paragraph"><p>On receiving NEGOTIATE_UNIX_FD the server must respond with either AGREE_UNIX_FD or ERROR. It shall respond the former if the transport chosen supports Unix file descriptor passing and the server supports this feature. It shall respond the latter if the transport does not support Unix file descriptor passing, the server does not support this feature, or the server decides not to enable file descriptor passing due to security or other reasons.</p></div>
<div class="paragraph"><p>AGREE_UNIX_FD Command
The AGREE_UNIX_FD command is sent by the server to the client.</p></div>
<div class="paragraph"><p>The AGREE_UNIX_FD command indicates that the server supports Unix file descriptor passing. This command may only be sent after the connection is authenticated, and the client sent NEGOTIATE_UNIX_FD to enable Unix file descriptor passing. This command may only be sent on transports that support Unix file descriptor passing.</p></div>
<div class="paragraph"><p>On receiving AGREE_UNIX_FD the client must respond with BEGIN, followed by its stream of messages, or by disconnecting. The server must not accept additional commands using this protocol after the BEGIN command has been received. Further communication will be a stream of D-Bus messages (optionally encrypted, as negotiated) rather than this protocol.</p></div>
<div class="paragraph"><p>Future Extensions
Future extensions to the authentication and negotiation protocol are possible. For that new commands may be introduced. If a client or server receives an unknown command it shall respond with ERROR and not consider this fatal. New commands may be introduced both before, and after authentication, i.e. both before and after the OK command.</p></div>
<div class="paragraph"><p>Authentication examples
Figure 1. Example of successful EXTERNAL authentication</p></div>
<div class="literalblock">
<div class="content">
<pre><code>31303030 is ASCII decimal "1000" represented in hex, so
the client is authenticating as Unix uid 1000 in this example.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL 31303030
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 2. Example of finding out mechanisms then picking one</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH
S: REJECTED KERBEROS_V4 SKEY
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 3. Example of client sends unknown command then falls back to regular auth</p></div>
<div class="literalblock">
<div class="content">
<pre><code>532d312d352d3138 is the Windows SID "S-1-5-18" in hex,
so the client is authenticating as Windows SID S-1-5-18
in this example.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>C: FOOBAR
S: ERROR
C: AUTH EXTERNAL 532d312d352d3138
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 4. Example of server doesn&#8217;t support initial auth mechanism</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL
S: REJECTED KERBEROS_V4 SKEY
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 5. Example of wrong password or the like followed by successful retry</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL 736d6376
S: REJECTED KERBEROS_V4 SKEY
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
S: REJECTED
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 6. Example of skey cancelled and restarted</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL 32303438
S: REJECTED KERBEROS_V4 SKEY
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: CANCEL
S: REJECTED
C: AUTH SKEY 7ab83f32ee
S: DATA 8799cabb2ea93e
C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
S: OK 1234deadbeef
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 7. Example of successful EXTERNAL authentication with successful negotiation of Unix FD passing</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL 31303030
S: OK 1234deadbeef
C: NEGOTIATE_UNIX_FD
S: AGREE_UNIX_FD
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Figure 8. Example of successful EXTERNAL authentication with unsuccessful negotiation of Unix FD passing</p></div>
<div class="literalblock">
<div class="content">
<pre><code>C: AUTH EXTERNAL 31303030
S: OK 1234deadbeef
C: NEGOTIATE_UNIX_FD
S: ERROR Not supported on this OS
C: BEGIN</code></pre>
</div></div>
<div class="paragraph"><p>Authentication state diagrams
This section documents the auth protocol in terms of a state machine for the client and the server. This is probably the most robust way to implement the protocol.</p></div>
<div class="paragraph"><p>Client states
To more precisely describe the interaction between the protocol state machine and the authentication mechanisms the following notation is used: MECH(CHALL) means that the server challenge CHALL was fed to the mechanism MECH, which returns one of</p></div>
<div class="paragraph"><p>CONTINUE(RESP) means continue the auth conversation and send RESP as the response to the server;</p></div>
<div class="paragraph"><p>OK(RESP) means that after sending RESP to the server the client side of the auth conversation is finished and the server should return "OK";</p></div>
<div class="paragraph"><p>ERROR means that CHALL was invalid and could not be processed.</p></div>
<div class="paragraph"><p>Both RESP and CHALL may be empty.</p></div>
<div class="paragraph"><p>The Client starts by getting an initial response from the default mechanism and sends AUTH MECH RESP, or AUTH MECH if the mechanism did not provide an initial response. If the mechanism returns CONTINUE, the client starts in state WaitingForData, if the mechanism returns OK the client starts in state WaitingForOK.</p></div>
<div class="paragraph"><p>The client should keep track of available mechanisms and which it mechanisms it has already attempted. This list is used to decide which AUTH command to send. When the list is exhausted, the client should give up and close the connection.</p></div>
<div class="paragraph"><p>WaitingForData.</p></div>
<div class="paragraph"><p>Receive DATA CHALL</p></div>
<div class="paragraph"><p>MECH(CHALL) returns CONTINUE(RESP) → send DATA RESP, goto WaitingForData
MECH(CHALL) returns OK(RESP) → send DATA RESP, goto WaitingForOK
MECH(CHALL) returns ERROR → send ERROR [msg], goto WaitingForData
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p></div>
<div class="paragraph"><p>Receive ERROR → send CANCEL, goto WaitingForReject</p></div>
<div class="paragraph"><p>Receive OK → authenticated, choose one:</p></div>
<div class="paragraph"><p>send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive anything else → send ERROR, goto WaitingForData</p></div>
<div class="paragraph"><p>WaitingForOK.</p></div>
<div class="paragraph"><p>Receive OK → authenticated, choose one:</p></div>
<div class="paragraph"><p>send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p></div>
<div class="paragraph"><p>Receive DATA → send CANCEL, goto WaitingForReject</p></div>
<div class="paragraph"><p>Receive ERROR → send CANCEL, goto WaitingForReject</p></div>
<div class="paragraph"><p>Receive anything else → send ERROR, goto WaitingForOK</p></div>
<div class="paragraph"><p>WaitingForReject.</p></div>
<div class="paragraph"><p>Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK</p></div>
<div class="paragraph"><p>Receive anything else → terminate auth conversation, disconnect</p></div>
<div class="paragraph"><p>WaitingForAgreeUnixFD.  By the time this state is reached, the client has already been authenticated.</p></div>
<div class="paragraph"><p>Receive AGREE_UNIX_FD → enable Unix fd passing, send BEGIN, terminate auth conversation (successfully)</p></div>
<div class="paragraph"><p>Receive ERROR → disable Unix fd passing, send BEGIN, terminate auth conversation (successfully)</p></div>
<div class="paragraph"><p>Receive anything else → terminate auth conversation, disconnect</p></div>
<div class="paragraph"><p>Server states
For the server MECH(RESP) means that the client response RESP was fed to the the mechanism MECH, which returns one of</p></div>
<div class="paragraph"><p>CONTINUE(CHALL) means continue the auth conversation and send CHALL as the challenge to the client;</p></div>
<div class="paragraph"><p>OK means that the client has been successfully authenticated;</p></div>
<div class="paragraph"><p>REJECTED means that the client failed to authenticate or there was an error in RESP.</p></div>
<div class="paragraph"><p>The server starts out in state WaitingForAuth. If the client is rejected too many times the server must disconnect the client.</p></div>
<div class="paragraph"><p>WaitingForAuth.</p></div>
<div class="paragraph"><p>Receive AUTH → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive AUTH MECH RESP</p></div>
<div class="paragraph"><p>MECH not valid mechanism → send REJECTED [mechs], goto WaitingForAuth
MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect</p></div>
<div class="paragraph"><p>Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive anything else → send ERROR, goto WaitingForAuth</p></div>
<div class="paragraph"><p>WaitingForData.</p></div>
<div class="paragraph"><p>Receive DATA RESP</p></div>
<div class="paragraph"><p>MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect</p></div>
<div class="paragraph"><p>Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive anything else → send ERROR, goto WaitingForData</p></div>
<div class="paragraph"><p>WaitingForBegin.</p></div>
<div class="paragraph"><p>Receive BEGIN → terminate auth conversation, client authenticated</p></div>
<div class="paragraph"><p>Receive NEGOTIATE_UNIX_FD → send AGREE_UNIX_FD or ERROR, goto WaitingForBegin</p></div>
<div class="paragraph"><p>Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive ERROR → send REJECTED [mechs], goto WaitingForAuth</p></div>
<div class="paragraph"><p>Receive anything else → send ERROR, goto WaitingForBegin</p></div>
<div class="paragraph"><p>Authentication mechanisms
This section describes some authentication mechanisms that are often supported by practical D-Bus implementations. The D-Bus protocol also allows any other standard SASL mechanism, although implementations of D-Bus often do not.</p></div>
<div class="paragraph"><p>EXTERNAL
The EXTERNAL mechanism is defined in RFC 4422 "Simple Authentication and Security Layer (SASL)", appendix A "The SASL EXTERNAL Mechanism". This is the recommended authentication mechanism on platforms where credentials can be transferred out-of-band, in particular Unix platforms that can perform credentials-passing over the unix: transport.</p></div>
<div class="paragraph"><p>On Unix platforms, interoperable clients should prefer to send the ASCII decimal string form of the integer Unix user ID as the authorization identity, for example 1000. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 31303030 followed by \r\n.</p></div>
<div class="paragraph"><p>On Windows platforms, clients that use the EXTERNAL mechanism should use the Windows security identifier in its string form as the authorization identity, for example S-1-5-21-3623811015-3361044348-30300820-1013 for a domain or local computer user or S-1-5-18 for the LOCAL_SYSTEM user. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 532d312d352d3138 followed by \r\n.</p></div>
<div class="paragraph"><p>DBUS_COOKIE_SHA1
DBUS_COOKIE_SHA1 is a D-Bus-specific SASL mechanism. Its reference implementation is part of the reference implementation of D-Bus.</p></div>
<div class="paragraph"><p>This mechanism is designed to establish that a client has the ability to read a private file owned by the user being authenticated. If the client can prove that it has access to a secret cookie stored in this file, then the client is authenticated. Thus the security of DBUS_COOKIE_SHA1 depends on a secure home directory. This is the recommended authentication mechanism for platforms and configurations where EXTERNAL cannot be used.</p></div>
<div class="paragraph"><p>Throughout this description, "hex encoding" must output the digits from a to f in lower-case; the digits A to F must not be used in the DBUS_COOKIE_SHA1 mechanism.</p></div>
<div class="paragraph"><p>Authentication proceeds as follows:</p></div>
<div class="paragraph"><p>The client sends the username it would like to authenticate as, hex-encoded.</p></div>
<div class="paragraph"><p>The server sends the name of its "cookie context" (see below); a space character; the integer ID of the secret cookie the client must demonstrate knowledge of; a space character; then a randomly-generated challenge string, all of this hex-encoded into one, single string.</p></div>
<div class="paragraph"><p>The client locates the cookie and generates its own randomly-generated challenge string. The client then concatenates the server&#8217;s decoded challenge, a ":" character, its own challenge, another ":" character, and the cookie. It computes the SHA-1 hash of this composite string as a hex digest. It concatenates the client&#8217;s challenge string, a space character, and the SHA-1 hex digest, hex-encodes the result and sends it back to the server.</p></div>
<div class="paragraph"><p>The server generates the same concatenated string used by the client and computes its SHA-1 hash. It compares the hash with the hash received from the client; if the two hashes match, the client is authenticated.</p></div>
<div class="paragraph"><p>Each server has a "cookie context," which is a name that identifies a set of cookies that apply to that server. A sample context might be "org_freedesktop_session_bus". Context names must be valid ASCII, nonzero length, and may not contain the characters slash ("/"), backslash ("\"), space (" "), newline ("\n"), carriage return ("\r"), tab ("\t"), or period ("."). There is a default context, "org_freedesktop_general" that&#8217;s used by servers that do not specify otherwise.</p></div>
<div class="paragraph"><p>Cookies are stored in a user&#8217;s home directory, in the directory ~/.dbus-keyrings/. This directory must not be readable or writable by other users. If it is, clients and servers must ignore it. The directory contains cookie files named after the cookie context.</p></div>
<div class="paragraph"><p>A cookie file contains one cookie per line. Each line has three space-separated fields:</p></div>
<div class="paragraph"><p>The cookie ID number, which must be a non-negative integer and may not be used twice in the same file.</p></div>
<div class="paragraph"><p>The cookie&#8217;s creation time, in UNIX seconds-since-the-epoch format.</p></div>
<div class="paragraph"><p>The cookie itself, a hex-encoded random block of bytes. The cookie may be of any length, though obviously security increases as the length increases.</p></div>
<div class="paragraph"><p>Only server processes modify the cookie file. They must do so with this procedure:</p></div>
<div class="paragraph"><p>Create a lockfile name by appending ".lock" to the name of the cookie file. The server should attempt to create this file using O_CREAT | O_EXCL. If file creation fails, the lock fails. Servers should retry for a reasonable period of time, then they may choose to delete an existing lock to keep users from having to manually delete a stale lock. [1]</p></div>
<div class="paragraph"><p>Once the lockfile has been created, the server loads the cookie file. It should then delete any cookies that are old (the timeout can be fairly short), or more than a reasonable time in the future (so that cookies never accidentally become permanent, if the clock was set far into the future at some point). If no recent keys remain, the server may generate a new key.</p></div>
<div class="paragraph"><p>The pruned and possibly added-to cookie file must be resaved atomically (using a temporary file which is rename()'d).</p></div>
<div class="paragraph"><p>The lock must be dropped by deleting the lockfile.</p></div>
<div class="paragraph"><p>Clients need not lock the file in order to load it, because servers are required to save the file atomically.</p></div>
<div class="paragraph"><p>ANONYMOUS
The ANONYMOUS mechanism is defined in RFC 4505 "Anonymous Simple Authentication and Security Layer (SASL) Mechanism". It does not perform any authentication at all, and should not be accepted by message buses. However, it might sometimes be useful for non-message-bus uses of D-Bus.</p></div>
<div class="paragraph"><p>Server Addresses
Server addresses consist of a transport name followed by a colon, and then an optional, comma-separated list of keys and values in the form key=value. Each value is escaped.</p></div>
<div class="paragraph"><p>For example:</p></div>
<div class="paragraph"><p>unix:path=/tmp/dbus-test
Which is the address to a unix socket with the path /tmp/dbus-test.</p></div>
<div class="paragraph"><p>Value escaping is similar to URI escaping but simpler.</p></div>
<div class="paragraph"><p>The set of optionally-escaped bytes is: [-0-9A-Za-z_/.\]. To escape, each byte (note, not character) which is not in the set of optionally-escaped bytes must be replaced with an ASCII percent (%) and the value of the byte in hex. The hex value must always be two digits, even if the first digit is zero. The optionally-escaped bytes may be escaped if desired.</p></div>
<div class="paragraph"><p>To unescape, append each byte in the value; if a byte is an ASCII percent (%) character then append the following hex value instead. It is an error if a % byte does not have two hex digits following. It is an error if a non-optionally-escaped byte is seen unescaped.</p></div>
<div class="paragraph"><p>The set of optionally-escaped bytes is intended to preserve address readability and convenience.</p></div>
<div class="paragraph"><p>A server may specify a key-value pair with the key guid and the value a hex-encoded 16-byte sequence. the section called “UUIDs” describes the format of the guid field. If present, this UUID may be used to distinguish one server address from another. A server should use a different UUID for each address it listens on. For example, if a message bus daemon offers both UNIX domain socket and TCP connections, but treats clients the same regardless of how they connect, those two connections are equivalent post-connection but should have distinct UUIDs to distinguish the kinds of connection.</p></div>
<div class="paragraph"><p>The intent of the address UUID feature is to allow a client to avoid opening multiple identical connections to the same server, by allowing the client to check whether an address corresponds to an already-existing connection. Comparing two addresses is insufficient, because addresses can be recycled by distinct servers, and equivalent addresses may look different if simply compared as strings (for example, the host in a TCP address can be given as an IP address or as a hostname).</p></div>
<div class="paragraph"><p>Note that the address key is guid even though the rest of the API and documentation says "UUID," for historical reasons.</p></div>
<div class="paragraph"><p>[FIXME clarify if attempting to connect to each is a requirement or just a suggestion] When connecting to a server, multiple server addresses can be separated by a semi-colon. The library will then try to connect to the first address and if that fails, it&#8217;ll try to connect to the next one specified, and so forth. For example</p></div>
<div class="paragraph"><p>unix:path=/tmp/dbus-test;unix:path=/tmp/dbus-test2
Some addresses are connectable. A connectable address is one containing enough information for a client to connect to it. For instance, tcp:host=127.0.0.1,port=4242 is a connectable address. It is not necessarily possible to listen on every connectable address: for instance, it is not possible to listen on a unixexec: address.</p></div>
<div class="paragraph"><p>Some addresses are listenable. A listenable address is one containing enough information for a server to listen on it, producing a connectable address (which may differ from the original address). Many listenable addresses are not connectable: for instance, tcp:host=127.0.0.1 is listenable, but not connectable (because it does not specify a port number).</p></div>
<div class="paragraph"><p>Listening on an address that is not connectable will result in a connectable address that is not the same as the listenable address. For instance, listening on tcp:host=127.0.0.1 might result in the connectable address tcp:host=127.0.0.1,port=30958, listening on unix:tmpdir=/tmp might result in the connectable address unix:abstract=/tmp/dbus-U8OSdmf7, or listening on unix:runtime=yes might result in the connectable address unix:path=/run/user/1234/bus.</p></div>
<div class="paragraph"><p>Transports
[FIXME we need to specify in detail each transport and its possible arguments] Current transports include: unix domain sockets (including abstract namespace on linux), launchd, systemd, TCP/IP, an executed subprocess and a debug/testing transport using in-process pipes. Future possible transports include one that tunnels over X11 protocol.</p></div>
<div class="paragraph"><p>Unix Domain Sockets
Unix domain sockets can be either paths in the file system or on Linux kernels, they can be abstract which are similar to paths but do not show up in the file system.</p></div>
<div class="paragraph"><p>When a socket is opened by the D-Bus library it truncates the path name right before the first trailing Nul byte. This is true for both normal paths and abstract paths. Note that this is a departure from previous versions of D-Bus that would create sockets with a fixed length path name. Names which were shorter than the fixed length would be padded by Nul bytes.</p></div>
<div class="paragraph"><p>Unix domain sockets are not available on Windows. On all other platforms, they are the recommended transport for D-Bus, either used alone or in conjunction with systemd or launchd addresses.</p></div>
<div class="paragraph"><p>Unix addresses that specify path or abstract are both listenable and connectable. Unix addresses that specify tmpdir or dir are only listenable: the corresponding connectable address will specify either path or abstract. Similarly, Unix addresses that specify runtime are only listenable, and the corresponding connectable address will specify path.</p></div>
<div class="paragraph"><p>Server Address Format
Unix domain socket addresses are identified by the "unix:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
path    (path)  Path of the unix domain socket.
dir     (path)  Directory in which a socket file with a random file name starting with <em>dbus-</em> will be created by the server. This key can only be used in server addresses, not in client addresses; the resulting client address will have the "path" key instead. be set.
tmpdir  (path)  The same as "dir", except that on platforms with abstract sockets, the server may attempt to create an abstract socket whose name starts with this directory instead of a path-based socket. This key can only be used in server addresses, not in client addresses; the resulting client address will have the "abstract" or "path" key instead.
abstract        (string)        Unique string in the abstract namespace, often syntactically resembling a path but unconnected to the filesystem namespace. This key is only supported on platforms with abstract Unix sockets, of which Linux is the only known example.
runtime yes     If given, This key can only be used in server addresses, not in client addresses. If set, its value must be yes. This is typically used in an address string like unix:runtime=yes;unix:tmpdir=/tmp so that there can be a fallback if XDG_RUNTIME_DIR is not set.
Exactly one of the keys path, abstract, runtime, dir or tmpdir must be provided.</p></div>
<div class="paragraph"><p>launchd
launchd is an open-source server management system that replaces init, inetd and cron on Apple Mac OS X versions 10.4 and above. It provides a common session bus address for each user and deprecates the X11-enabled D-Bus launcher on OSX.</p></div>
<div class="paragraph"><p>launchd allocates a socket and provides it with the unix path through the DBUS_LAUNCHD_SESSION_BUS_SOCKET variable in launchd&#8217;s environment. Every process spawned by launchd (or dbus-daemon, if it was started by launchd) can access it through its environment. Other processes can query for the launchd socket by executing: $ launchctl getenv DBUS_LAUNCHD_SESSION_BUS_SOCKET This is normally done by the D-Bus client library so doesn&#8217;t have to be done manually.</p></div>
<div class="paragraph"><p>launchd is not available on Microsoft Windows.</p></div>
<div class="paragraph"><p>launchd addresses are listenable and connectable.</p></div>
<div class="paragraph"><p>Server Address Format
launchd addresses are identified by the "launchd:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
env     (environment variable)  path of the unix domain socket for the launchd created dbus-daemon.
The env key is required.</p></div>
<div class="paragraph"><p>systemd
systemd is an open-source server management system that replaces init and inetd on newer Linux systems. It supports socket activation. The D-Bus systemd transport is used to acquire socket activation file descriptors from systemd and use them as D-Bus transport when the current process is spawned by socket activation from it.</p></div>
<div class="paragraph"><p>The systemd transport accepts only one or more Unix domain or TCP streams sockets passed in via socket activation. Using Unix domain sockets is strongly recommended.</p></div>
<div class="paragraph"><p>The systemd transport is not available on non-Linux operating systems.</p></div>
<div class="paragraph"><p>The systemd transport defines no parameter keys.</p></div>
<div class="paragraph"><p>systemd addresses are listenable, but not connectable. The corresponding connectable address is the unix or tcp address of the socket.</p></div>
<div class="paragraph"><p>TCP Sockets
The tcp transport provides TCP/IP based connections between clients located on the same or different hosts.</p></div>
<div class="paragraph"><p>Similar to remote X11, the TCP transport has no integrity or confidentiality protection, so it should normally only be used across the local loopback interface, for example using an address like tcp:host=127.0.0.1 or tcp:host=localhost. In particular, configuring the well-known system bus or the well-known session bus to listen on a non-loopback TCP address is insecure.</p></div>
<div class="paragraph"><p>On Windows and most Unix platforms, the TCP stack is unable to transfer credentials over a TCP connection, so the EXTERNAL authentication mechanism does not normally work for this transport (although the reference implementation of D-Bus is able to identify loopback TCPv4 connections on Windows by their port number, partially enabling the EXTERNAL mechanism). The DBUS_COOKIE_SHA1 mechanism is normally used instead.</p></div>
<div class="paragraph"><p>Developers are sometimes tempted to use remote TCP as a debugging tool. However, if this functionality is left enabled in finished products, the result will be dangerously insecure. Instead of using remote TCP, developers should relay connections via Secure Shell or a similar protocol.</p></div>
<div class="paragraph"><p>Remote TCP connections were historically sometimes used to share a single session bus between login sessions of the same user on different machines within a trusted local area network, in conjunction with unencrypted remote X11, a NFS-shared home directory and NIS (YP) authentication. This is insecure against an attacker on the same LAN and should be considered strongly deprecated; more specifically, it is insecure in the same ways and for the same reasons as unencrypted remote X11 and NFSv2/NFSv3. The D-Bus maintainers recommend using a separate session bus per (user, machine) pair, only accessible from within that machine.</p></div>
<div class="paragraph"><p>All tcp addresses are listenable. tcp addresses in which both host and port are specified, and port is non-zero, are also connectable.</p></div>
<div class="paragraph"><p>Server Address Format
TCP/IP socket addresses are identified by the "tcp:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
host    (string)        DNS name or IP address
bind    (string)        Used in a listenable address to configure the interface on which the server will listen: either the IP address of one of the local machine&#8217;s interfaces (most commonly 127.0.0.1 ), or a DNS name that resolves to one of those IP addresses, or <em>*</em> to listen on all interfaces simultaneously. If not specified, the default is the same value as "host".
port    (number)        The tcp port the server will open. A zero value let the server choose a free port provided from the underlaying operating system. libdbus is able to retrieve the real used port from the server.
family  (string)        If set, provide the type of socket family either "ipv4" or "ipv6". If unset, the family is unspecified.
Nonce-authenticated TCP Sockets
The nonce-tcp transport provides a modified TCP transport using a simple authentication mechanism, to ensure that only clients with read access to a certain location in the filesystem can connect to the server. The server writes a secret, the nonce, to a file and an incoming client connection is only accepted if the client sends the nonce right after the connect. The nonce mechanism requires no setup and is orthogonal to the higher-level authentication mechanisms described in the Authentication section.</p></div>
<div class="paragraph"><p>The nonce-tcp transport is conceptually similar to a combination of the DBUS_COOKIE_SHA1 authentication mechanism and the tcp transport, and appears to have originally been implemented as a result of a misunderstanding of the SASL authentication mechanisms.</p></div>
<div class="paragraph"><p>Like the ordinary tcp transport, the nonce-tcp transport has no integrity or confidentiality protection, so it should normally only be used across the local loopback interface, for example using an address like tcp:host=127.0.0.1 or tcp:host=localhost. Other uses are insecure. See the section called “TCP Sockets” for more information on situations where these transports have been used, and alternatives to these transports.</p></div>
<div class="paragraph"><p>Implementations of D-Bus on Windows operating systems normally use a nonce-tcp transport via the local loopback interface. This is because the unix transport, which would otherwise be recommended, is not available on these operating systems.</p></div>
<div class="paragraph"><p>On start, the server generates a random 16 byte nonce and writes it to a file in the user&#8217;s temporary directory. The nonce file location is published as part of the server&#8217;s D-Bus address using the "noncefile" key-value pair. After an accept, the server reads 16 bytes from the socket. If the read bytes do not match the nonce stored in the nonce file, the server MUST immediately drop the connection. If the nonce match the received byte sequence, the client is accepted and the transport behaves like an ordinary tcp transport.</p></div>
<div class="paragraph"><p>After a successful connect to the server socket, the client MUST read the nonce from the file published by the server via the noncefile= key-value pair and send it over the socket. After that, the transport behaves like an ordinary tcp transport.</p></div>
<div class="paragraph"><p>All nonce-tcp addresses are listenable. nonce-tcp addresses in which host, port and noncefile are all specified, and port is nonzero, are also connectable.</p></div>
<div class="paragraph"><p>Server Address Format
Nonce TCP/IP socket addresses uses the "nonce-tcp:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
host    (string)        DNS name or IP address
bind    (string)        The same as for tcp: addresses
port    (number)        The tcp port the server will open. A zero value let the server choose a free port provided from the underlaying operating system. libdbus is able to retrieve the real used port from the server.
family  (string)        If set, provide the type of socket family either "ipv4" or "ipv6". If unset, the family is unspecified.
noncefile       (path)  File location containing the secret. This is only meaningful in connectable addresses: a listening D-Bus server that offers this transport will always create a new nonce file.
Executed Subprocesses on Unix
This transport forks off a process and connects its standard input and standard output with an anonymous Unix domain socket. This socket is then used for communication by the transport. This transport may be used to use out-of-process forwarder programs as basis for the D-Bus protocol.</p></div>
<div class="paragraph"><p>The forked process will inherit the standard error output and process group from the parent process.</p></div>
<div class="paragraph"><p>Executed subprocesses are not available on Windows.</p></div>
<div class="paragraph"><p>unixexec addresses are connectable, but are not listenable.</p></div>
<div class="paragraph"><p>Server Address Format
Executed subprocess addresses are identified by the "unixexec:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
path    (path)  Path of the binary to execute, either an absolute path or a binary name that is searched for in the default search path of the OS. This corresponds to the first argument of execlp(). This key is mandatory.
argv0   (string)        The program name to use when executing the binary. If omitted the same value as specified for path= will be used. This corresponds to the second argument of execlp().
argv1, argv2, &#8230;       (string)        Arguments to pass to the binary. This corresponds to the third and later arguments of execlp(). If a specific argvX is not specified no further argvY for Y &gt; X are taken into account.
Meta Transports
Meta transports are a kind of transport with special enhancements or behavior. Currently available meta transports include: autolaunch</p></div>
<div class="paragraph"><p>Autolaunch
The autolaunch transport provides a way for dbus clients to autodetect a running dbus session bus and to autolaunch a session bus if not present.</p></div>
<div class="paragraph"><p>On Unix, autolaunch addresses are connectable, but not listenable.</p></div>
<div class="paragraph"><p>On Windows, autolaunch addresses are both connectable and listenable.</p></div>
<div class="paragraph"><p>Server Address Format
Autolaunch addresses uses the "autolaunch:" prefix and support the following key/value pairs:</p></div>
<div class="paragraph"><p>Name    Values  Description
scope   (string)        scope of autolaunch (Windows only)
"*install-path" - limit session bus to dbus installation path. The dbus installation path is determined from the location of the shared dbus library. If the library is located in a <em>bin</em> subdirectory the installation root is the directory above, otherwise the directory where the library lives is taken as installation root.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>&lt;install-root&gt;/bin/[lib]dbus-1.dll
&lt;install-root&gt;/[lib]dbus-1.dll</code></pre>
</div></div>
<div class="paragraph"><p>"*user" - limit session bus to the recent user.</p></div>
<div class="paragraph"><p>other values - specify dedicated session bus like "release", "debug" or other</p></div>
<div class="paragraph"><p>Windows implementation
On start, the server opens a platform specific transport, creates a mutex and a shared memory section containing the related session bus address. This mutex will be inspected by the dbus client library to detect a running dbus session bus. The access to the mutex and the shared memory section are protected by global locks.</p></div>
<div class="paragraph"><p>In the recent implementation the autolaunch transport uses a tcp transport on localhost with a port choosen from the operating system. This detail may change in the future.</p></div>
<div class="paragraph"><p>Disclaimer: The recent implementation is in an early state and may not work in all cirumstances and/or may have security issues. Because of this the implementation is not documentated yet.</p></div>
<div class="paragraph"><p>UUIDs
A working D-Bus implementation uses universally-unique IDs in two places. First, each server address has a UUID identifying the address, as described in the section called “Server Addresses”. Second, each operating system kernel instance running a D-Bus client or server has a UUID identifying that kernel, retrieved by invoking the method org.freedesktop.DBus.Peer.GetMachineId() (see the section called “org.freedesktop.DBus.Peer”).</p></div>
<div class="paragraph"><p>The term "UUID" in this document is intended literally, i.e. an identifier that is universally unique. It is not intended to refer to RFC4122, and in fact the D-Bus UUID is not compatible with that RFC.</p></div>
<div class="paragraph"><p>The UUID must contain 128 bits of data and be hex-encoded. The hex-encoded string may not contain hyphens or other non-hex-digit characters, and it must be exactly 32 characters long. To generate a UUID, the current reference implementation concatenates 96 bits of random data followed by the 32-bit time in seconds since the UNIX epoch (in big endian byte order).</p></div>
<div class="paragraph"><p>It would also be acceptable and probably better to simply generate 128 bits of random data, as long as the random number generator is of high quality. The timestamp could conceivably help if the random bits are not very random. With a quality random number generator, collisions are extremely unlikely even with only 96 bits, so it&#8217;s somewhat academic.</p></div>
<div class="paragraph"><p>Implementations should, however, stick to random data for the first 96 bits of the UUID.</p></div>
<div class="paragraph"><p>Standard Interfaces
See the section called “Notation in this document” for details on the notation used in this section. There are some standard interfaces that may be useful across various D-Bus applications.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Peer
The org.freedesktop.DBus.Peer interface has two methods:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.Peer.Ping ()
org.freedesktop.DBus.Peer.GetMachineId (out STRING machine_uuid)</code></pre>
</div></div>
<div class="paragraph"><p>On receipt of the METHOD_CALL message org.freedesktop.DBus.Peer.Ping, an application should do nothing other than reply with a METHOD_RETURN as usual. It does not matter which object path a ping is sent to. The reference implementation handles this method automatically.</p></div>
<div class="paragraph"><p>On receipt of the METHOD_CALL message org.freedesktop.DBus.Peer.GetMachineId, an application should reply with a METHOD_RETURN containing a hex-encoded UUID representing the identity of the machine the process is running on. This UUID must be the same for all processes on a single system at least until that system next reboots. It should be the same across reboots if possible, but this is not always possible to implement and is not guaranteed. It does not matter which object path a GetMachineId is sent to. The reference implementation handles this method automatically.</p></div>
<div class="paragraph"><p>The UUID is intended to be per-instance-of-the-operating-system, so may represent a virtual machine running on a hypervisor, rather than a physical machine. Basically if two processes see the same UUID, they should also see the same shared memory, UNIX domain sockets, process IDs, and other features that require a running OS kernel in common between the processes.</p></div>
<div class="paragraph"><p>The UUID is often used where other programs might use a hostname. Hostnames can change without rebooting, however, or just be "localhost" - so the UUID is more robust.</p></div>
<div class="paragraph"><p>the section called “UUIDs” explains the format of the UUID.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Introspectable
This interface has one method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.Introspectable.Introspect (out STRING xml_data)</code></pre>
</div></div>
<div class="paragraph"><p>Objects instances may implement Introspect which returns an XML description of the object, including its interfaces (with signals and methods), objects below it in the object path tree, and its properties.</p></div>
<div class="paragraph"><p>the section called “Introspection Data Format” describes the format of this XML string.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Properties
Many native APIs will have a concept of object properties or attributes. These can be exposed via the org.freedesktop.DBus.Properties interface.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.Properties.Get (in STRING interface_name,
                                     in STRING property_name,
                                     out VARIANT value);
org.freedesktop.DBus.Properties.Set (in STRING interface_name,
                                     in STRING property_name,
                                     in VARIANT value);
org.freedesktop.DBus.Properties.GetAll (in STRING interface_name,
                                        out DICT&lt;STRING,VARIANT&gt; props);</code></pre>
</div></div>
<div class="paragraph"><p>It is conventional to give D-Bus properties names consisting of capitalized words without punctuation ("CamelCase"), like member names. For instance, the GObject property connection-status or the Qt property connectionStatus could be represented on D-Bus as ConnectionStatus.</p></div>
<div class="paragraph"><p>Strictly speaking, D-Bus property names are not required to follow the same naming restrictions as member names, but D-Bus property names that would not be valid member names (in particular, GObject-style dash-separated property names) can cause interoperability problems and should be avoided.</p></div>
<div class="paragraph"><p>The available properties and whether they are writable can be determined by calling org.freedesktop.DBus.Introspectable.Introspect, see the section called “org.freedesktop.DBus.Introspectable”.</p></div>
<div class="paragraph"><p>An empty string may be provided for the interface name; in this case, if there are multiple properties on an object with the same name, the results are undefined (picking one by according to an arbitrary deterministic rule, or returning an error, are the reasonable possibilities).</p></div>
<div class="paragraph"><p>If org.freedesktop.DBus.Properties.GetAll is called with a valid interface name which contains no properties, an empty array should be returned. If it is called with a valid interface name for which some properties are not accessible to the caller (for example, due to per-property access control implemented in the service), those properties should be silently omitted from the result array. If org.freedesktop.DBus.Properties.Get is called for any such properties, an appropriate access control error should be returned.</p></div>
<div class="paragraph"><p>If one or more properties change on an object, the org.freedesktop.DBus.Properties.PropertiesChanged signal may be emitted (this signal was added in 0.14):</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,
                                                   DICT&lt;STRING,VARIANT&gt; changed_properties,
                                                   ARRAY&lt;STRING&gt; invalidated_properties);</code></pre>
</div></div>
<div class="paragraph"><p>where changed_properties is a dictionary containing the changed properties with the new values and invalidated_properties is an array of properties that changed but the value is not conveyed.</p></div>
<div class="paragraph"><p>Whether the PropertiesChanged signal is supported can be determined by calling org.freedesktop.DBus.Introspectable.Introspect. Note that the signal may be supported for an object but it may differ how whether and how it is used on a per-property basis (for e.g. performance or security reasons). Each property (or the parent interface) must be annotated with the org.freedesktop.DBus.Property.EmitsChangedSignal annotation to convey this (usually the default value true is sufficient meaning that the annotation does not need to be used). See the section called “Introspection Data Format” for details on this annotation.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.ObjectManager
An API can optionally make use of this interface for one or more sub-trees of objects. The root of each sub-tree implements this interface so other applications can get all objects, interfaces and properties in a single method call. It is appropriate to use this interface if users of the tree of objects are expected to be interested in all interfaces of all objects in the tree; a more granular API should be used if users of the objects are expected to be interested in a small subset of the objects, a small subset of their interfaces, or both.</p></div>
<div class="paragraph"><p>The method that applications can use to get all objects and properties is GetManagedObjects:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.ObjectManager.GetManagedObjects (out DICT&lt;OBJPATH,DICT&lt;STRING,DICT&lt;STRING,VARIANT&gt;&gt;&gt; objpath_interfaces_and_properties);</code></pre>
</div></div>
<div class="paragraph"><p>The return value of this method is a dict whose keys are object paths. All returned object paths are children of the object path implementing this interface, i.e. their object paths start with the ObjectManager&#8217;s object path plus <em>/</em>.</p></div>
<div class="paragraph"><p>Each value is a dict whose keys are interfaces names. Each value in this inner dict is the same dict that would be returned by the org.freedesktop.DBus.Properties.GetAll() method for that combination of object path and interface. If an interface has no properties, the empty dict is returned.</p></div>
<div class="paragraph"><p>Changes are emitted using the following two signals:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.ObjectManager.InterfacesAdded (OBJPATH object_path,
                                                    DICT&lt;STRING,DICT&lt;STRING,VARIANT&gt;&gt; interfaces_and_properties);
org.freedesktop.DBus.ObjectManager.InterfacesRemoved (OBJPATH object_path,
                                                      ARRAY&lt;STRING&gt; interfaces);</code></pre>
</div></div>
<div class="paragraph"><p>The InterfacesAdded signal is emitted when either a new object is added or when an existing object gains one or more interfaces. The InterfacesRemoved signal is emitted whenever an object is removed or it loses one or more interfaces. The second parameter of the InterfacesAdded signal contains a dict with the interfaces and properties (if any) that have been added to the given object path. Similarly, the second parameter of the InterfacesRemoved signal contains an array of the interfaces that were removed. Note that changes on properties on existing interfaces are not reported using this interface - an application should also monitor the existing PropertiesChanged signal on each object.</p></div>
<div class="paragraph"><p>Applications SHOULD NOT export objects that are children of an object (directly or otherwise) implementing this interface but which are not returned in the reply from the GetManagedObjects() method of this interface on the given object.</p></div>
<div class="paragraph"><p>The intent of the ObjectManager interface is to make it easy to write a robust client implementation. The trivial client implementation only needs to make two method calls:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>org.freedesktop.DBus.AddMatch (bus_proxy,
                               "type='signal',sender='org.example.App2',path_namespace='/org/example/App2'");
objects = org.freedesktop.DBus.ObjectManager.GetManagedObjects (app_proxy);</code></pre>
</div></div>
<div class="paragraph"><p>on the message bus and the remote application&#8217;s ObjectManager, respectively. Whenever a new remote object is created (or an existing object gains a new interface), the InterfacesAdded signal is emitted, and since this signal contains all properties for the interfaces, no calls to the org.freedesktop.Properties interface on the remote object are needed. Additionally, since the initial AddMatch() rule already includes signal messages from the newly created child object, no new AddMatch() call is needed.</p></div>
<div class="paragraph"><p>The org.freedesktop.DBus.ObjectManager interface was added in version 0.17 of the D-Bus specification.</p></div>
<div class="paragraph"><p>Introspection Data Format
As described in the section called “org.freedesktop.DBus.Introspectable”, objects may be introspected at runtime, returning an XML string that describes the object. The same XML format may be used in other contexts as well, for example as an "IDL" for generating static language bindings.</p></div>
<div class="paragraph"><p>Here is an example of introspection data:</p></div>
<div class="literalblock">
<div class="content">
<pre><code> &lt;!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
  "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd"&gt;
 &lt;node name="/com/example/sample_object0"&gt;
   &lt;interface name="com.example.SampleInterface0"&gt;
     &lt;method name="Frobate"&gt;
       &lt;arg name="foo" type="i" direction="in"/&gt;
       &lt;arg name="bar" type="s" direction="out"/&gt;
       &lt;arg name="baz" type="a{us}" direction="out"/&gt;
       &lt;annotation name="org.freedesktop.DBus.Deprecated" value="true"/&gt;
     &lt;/method&gt;
     &lt;method name="Bazify"&gt;
       &lt;arg name="bar" type="(iiu)" direction="in"/&gt;
       &lt;arg name="bar" type="v" direction="out"/&gt;
     &lt;/method&gt;
     &lt;method name="Mogrify"&gt;
       &lt;arg name="bar" type="(iiav)" direction="in"/&gt;
     &lt;/method&gt;
     &lt;signal name="Changed"&gt;
       &lt;arg name="new_value" type="b"/&gt;
     &lt;/signal&gt;
     &lt;property name="Bar" type="y" access="readwrite"/&gt;
   &lt;/interface&gt;
   &lt;node name="child_of_sample_object"/&gt;
   &lt;node name="another_child_of_sample_object"/&gt;
&lt;/node&gt;</code></pre>
</div></div>
<div class="paragraph"><p>A more formal DTD and spec needs writing, but here are some quick notes.</p></div>
<div class="paragraph"><p>Only the root &lt;node&gt; element can omit the node name, as it&#8217;s known to be the object that was introspected. If the root &lt;node&gt; does have a name attribute, it must be an absolute object path. If child &lt;node&gt; have object paths, they must be relative.</p></div>
<div class="paragraph"><p>If a child &lt;node&gt; has any sub-elements, then they must represent a complete introspection of the child. If a child &lt;node&gt; is empty, then it may or may not have sub-elements; the child must be introspected in order to find out. The intent is that if an object knows that its children are "fast" to introspect it can go ahead and return their information, but otherwise it can omit it.</p></div>
<div class="paragraph"><p>The direction element on &lt;arg&gt; may be omitted, in which case it defaults to "in" for method calls and "out" for signals. Signals only allow "out" so while direction may be specified, it&#8217;s pointless.</p></div>
<div class="paragraph"><p>The possible directions are "in" and "out", unlike CORBA there is no "inout"</p></div>
<div class="paragraph"><p>The possible property access flags are "readwrite", "read", and "write"</p></div>
<div class="paragraph"><p>Multiple interfaces can of course be listed for one &lt;node&gt;.</p></div>
<div class="paragraph"><p>The "name" attribute on arguments is optional.</p></div>
<div class="paragraph"><p>Method, interface, property, signal, and argument elements may have "annotations", which are generic key/value pairs of metadata. They are similar conceptually to Java&#8217;s annotations and C# attributes. Well-known annotations:</p></div>
<div class="paragraph"><p>Name    Values (separated by ,) Description
org.freedesktop.DBus.Deprecated true,false      Whether or not the entity is deprecated; defaults to false
org.freedesktop.DBus.GLib.CSymbol       (string)        The C symbol; may be used for methods and interfaces
org.freedesktop.DBus.Method.NoReply     true,false      If set, don&#8217;t expect a reply to the method call; defaults to false.
org.freedesktop.DBus.Property.EmitsChangedSignal        true,invalidates,const,false
If set to false, the org.freedesktop.DBus.Properties.PropertiesChanged signal, see the section called “org.freedesktop.DBus.Properties” is not guaranteed to be emitted if the property changes.</p></div>
<div class="paragraph"><p>If set to const the property never changes value during the lifetime of the object it belongs to, and hence the signal is never emitted for it.</p></div>
<div class="paragraph"><p>If set to invalidates the signal is emitted but the value is not included in the signal.</p></div>
<div class="paragraph"><p>If set to true the signal is emitted with the value included.</p></div>
<div class="paragraph"><p>The value for the annotation defaults to true if the enclosing interface element does not specify the annotation. Otherwise it defaults to the value specified in the enclosing interface element.</p></div>
<div class="paragraph"><p>This annotation is intended to be used by code generators to implement client-side caching of property values. For all properties for which the annotation is set to const, invalidates or true the client may unconditionally cache the values as the properties don&#8217;t change or notifications are generated for them if they do.</p></div>
<div class="paragraph"><p>Message Bus Specification
Message Bus Overview
The message bus accepts connections from one or more applications. Once connected, applications can exchange messages with other applications that are also connected to the bus.</p></div>
<div class="paragraph"><p>In order to route messages among connections, the message bus keeps a mapping from names to connections. Each connection has one unique-for-the-lifetime-of-the-bus name automatically assigned. Applications may request additional names for a connection. Additional names are usually "well-known names" such as "com.example.TextEditor1". When a name is bound to a connection, that connection is said to own the name.</p></div>
<div class="paragraph"><p>The bus itself owns a special name, org.freedesktop.DBus, with an object located at /org/freedesktop/DBus that implements the org.freedesktop.DBus interface. This service allows applications to make administrative requests of the bus itself. For example, applications can ask the bus to assign a name to a connection.</p></div>
<div class="paragraph"><p>Each name may have queued owners. When an application requests a name for a connection and the name is already in use, the bus will optionally add the connection to a queue waiting for the name. If the current owner of the name disconnects or releases the name, the next connection in the queue will become the new owner.</p></div>
<div class="paragraph"><p>This feature causes the right thing to happen if you start two text editors for example; the first one may request "com.example.TextEditor1", and the second will be queued as a possible owner of that name. When the first exits, the second will take over.</p></div>
<div class="paragraph"><p>Applications may send unicast messages to a specific recipient or to the message bus itself, or broadcast messages to all interested recipients. See the section called “Message Bus Message Routing” for details.</p></div>
<div class="paragraph"><p>Message Bus Names
Each connection has at least one name, assigned at connection time and returned in response to the org.freedesktop.DBus.Hello method call. This automatically-assigned name is called the connection&#8217;s unique name. Unique names are never reused for two different connections to the same bus.</p></div>
<div class="paragraph"><p>Ownership of a unique name is a prerequisite for interaction with the message bus. It logically follows that the unique name is always the first name that an application comes to own, and the last one that it loses ownership of.</p></div>
<div class="paragraph"><p>Unique connection names must begin with the character <em>:</em> (ASCII colon character); bus names that are not unique names must not begin with this character. (The bus must reject any attempt by an application to manually request a name beginning with <em>:</em>.) This restriction categorically prevents "spoofing"; messages sent to a unique name will always go to the expected connection.</p></div>
<div class="paragraph"><p>When a connection is closed, all the names that it owns are deleted (or transferred to the next connection in the queue if any).</p></div>
<div class="paragraph"><p>A connection can request additional names to be associated with it using the org.freedesktop.DBus.RequestName message. the section called “Bus names” describes the format of a valid name. These names can be released again using the org.freedesktop.DBus.ReleaseName message.</p></div>
<div class="paragraph"><p>Message Bus Message Routing
Messages may have a DESTINATION field (see the section called “Header Fields”), resulting in a unicast message. If the DESTINATION field is present, it specifies a message recipient by name. Method calls and replies normally specify this field. The message bus must send messages (of any type) with the DESTINATION field set to the specified recipient, regardless of whether the recipient has set up a match rule matching the message.</p></div>
<div class="paragraph"><p>When the message bus receives a signal, if the DESTINATION field is absent, it is considered to be a broadcast signal, and is sent to all applications with message matching rules that match the message. Most signal messages are broadcasts, and no other message types currently defined in this specification may be broadcast.</p></div>
<div class="paragraph"><p>Unicast signal messages (those with a DESTINATION field) are not commonly used, but they are treated like any unicast message: they are delivered to the specified receipient, regardless of its match rules. One use for unicast signals is to avoid a race condition in which a signal is emitted before the intended recipient can call the section called “org.freedesktop.DBus.AddMatch” to receive that signal: if the signal is sent directly to that recipient using a unicast message, it does not need to add a match rule at all, and there is no race condition. Another use for unicast signals, on message buses whose security policy prevents eavesdropping, is to send sensitive information which should only be visible to one recipient.</p></div>
<div class="paragraph"><p>When the message bus receives a method call, if the DESTINATION field is absent, the call is taken to be a standard one-to-one message and interpreted by the message bus itself. For example, sending an org.freedesktop.DBus.Peer.Ping message with no DESTINATION will cause the message bus itself to reply to the ping immediately; the message bus will not make this message visible to other applications.</p></div>
<div class="paragraph"><p>Continuing the org.freedesktop.DBus.Peer.Ping example, if the ping message were sent with a DESTINATION name of com.yoyodyne.Screensaver, then the ping would be forwarded, and the Yoyodyne Corporation screensaver application would be expected to reply to the ping.</p></div>
<div class="paragraph"><p>Message bus implementations may impose a security policy which prevents certain messages from being sent or received. When a method call message cannot be sent or received due to a security policy, the message bus should send an error reply, unless the original message had the NO_REPLY flag.</p></div>
<div class="paragraph"><p>Eavesdropping
Receiving a unicast message whose DESTINATION indicates a different recipient is called eavesdropping. On a message bus which acts as a security boundary (like the standard system bus), the security policy should usually prevent eavesdropping, since unicast messages are normally kept private and may contain security-sensitive information.</p></div>
<div class="paragraph"><p>Eavesdropping interacts poorly with buses with non-trivial access control restrictions, and is deprecated. The BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”) provides a preferable way to monitor buses.</p></div>
<div class="paragraph"><p>Eavesdropping is mainly useful for debugging tools, such as the dbus-monitor tool in the reference implementation of D-Bus. Tools which eavesdrop on the message bus should be careful to avoid sending a reply or error in response to messages intended for a different client.</p></div>
<div class="paragraph"><p>Clients may attempt to eavesdrop by adding match rules (see the section called “Match Rules”) containing the eavesdrop=<em>true</em> match. For compatibility with older message bus implementations, if adding such a match rule results in an error reply, the client may fall back to adding the same rule with the eavesdrop match omitted.</p></div>
<div class="paragraph"><p>Match Rules
An important part of the message bus routing protocol is match rules. Match rules describe the messages that should be sent to a client, based on the contents of the message. Broadcast signals are only sent to clients which have a suitable match rule: this avoids waking up client processes to deal with signals that are not relevant to that client.</p></div>
<div class="paragraph"><p>Messages that list a client as their DESTINATION do not need to match the client&#8217;s match rules, and are sent to that client regardless. As a result, match rules are mainly used to receive a subset of broadcast signals.</p></div>
<div class="paragraph"><p>Match rules can also be used for eavesdropping (see the section called “Eavesdropping”), if the security policy of the message bus allows it, but this usage is deprecated in favour of the BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”).</p></div>
<div class="paragraph"><p>Match rules are added using the AddMatch bus method (see the section called “org.freedesktop.DBus.AddMatch”). Rules are specified as a string of comma separated key/value pairs. Excluding a key from the rule indicates a wildcard match. For instance excluding the the member from a match rule but adding a sender would let all messages from that sender through. An example of a complete rule would be "type=<em>signal</em>,sender=<em>org.freedesktop.DBus</em>,interface=<em>org.freedesktop.DBus</em>,member=<em>Foo</em>,path=<em>/bar/foo</em>,destination=<em>:452345.34</em>,arg2=<em>bar</em>"</p></div>
<div class="paragraph"><p>Within single quotes (ASCII apostrophe, U+0027), a backslash (U+005C) represents itself, and an apostrophe ends the quoted section. Outside single quotes, \' (backslash, apostrophe) represents an apostrophe, and any backslash not followed by an apostrophe represents itself. For instance, the match rules arg0=<em>'\</em>'<em>,arg1=</em>',arg2=<em>,</em>,arg3=<em>\\</em> and arg0=',arg1=\,arg2=<em>,</em>,arg3=\\ both match messages where the arguments are a 1-character string containing an apostrophe, a 1-character string containing a backslash, a 1-character string containing a comma, and a 2-character string containing two backslashes[2].</p></div>
<div class="paragraph"><p>The following table describes the keys that can be used to create a match rule.</p></div>
<div class="paragraph"><p>Key     Possible Values Description
type    <em>signal</em>, <em>method_call</em>, <em>method_return</em>, <em>error</em>       Match on the message type. An example of a type match is type=<em>signal</em>
sender  A bus or unique name (see Bus Name and Unique Connection Name respectively)     Match messages sent by a particular sender. An example of a sender match is sender=<em>org.freedesktop.Hal</em>
interface       An interface name (see the section called “Interface names”)        Match messages sent over or to a particular interface. An example of an interface match is interface=<em>org.freedesktop.Hal.Manager</em>. If a message omits the interface header, it must not match any rule that specifies this key.
member  Any valid method or signal name Matches messages which have the give method or signal name. An example of a member match is member=<em>NameOwnerChanged</em>
path    An object path (see the section called “Valid Object Paths”)        Matches messages which are sent from or to the given object. An example of a path match is path=<em>/org/freedesktop/Hal/Manager</em>
path_namespace  An object path
Matches messages which are sent from or to an object for which the object path is either the given value, or that value followed by one or more path components.</p></div>
<div class="paragraph"><p>For example, path_namespace=<em>/com/example/foo</em> would match signals sent by /com/example/foo or by /com/example/foo/bar, but not by /com/example/foobar.</p></div>
<div class="paragraph"><p>Using both path and path_namespace in the same match rule is not allowed.</p></div>
<div class="paragraph"><p>This match key was added in version 0.16 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.0 and later.</p></div>
<div class="paragraph"><p>destination     A unique name (see Unique Connection Name)      Matches messages which are being sent to the given unique name. An example of a destination match is destination=<em>:1.0</em>
arg[0, 1, 2, 3, &#8230;]    Any string      Arg matches are special and are used for further restricting the match based on the arguments in the body of a message. Only arguments of type STRING can be matched in this way. An example of an argument match would be arg3=<em>Foo</em>. Only argument indexes from 0 to 63 should be accepted.
arg[0, 1, 2, 3, &#8230;]path        Any string
Argument path matches provide a specialised form of wildcard matching for path-like namespaces. They can match arguments whose type is either STRING or OBJECT_PATH. As with normal argument matches, if the argument is exactly equal to the string given in the match rule then the rule is satisfied. Additionally, there is also a match when either the string given in the match rule or the appropriate message argument ends with <em>/</em> and is a prefix of the other. An example argument path match is arg0path=<em>/aa/bb/</em>. This would match messages with first arguments of <em>/</em>, <em>/aa/</em>, <em>/aa/bb/</em>, <em>/aa/bb/cc/</em> and <em>/aa/bb/cc</em>. It would not match messages with first arguments of <em>/aa/b</em>, <em>/aa</em> or even <em>/aa/bb</em>.</p></div>
<div class="paragraph"><p>This is intended for monitoring “directories” in file system-like hierarchies, as used in the dconf configuration system. An application interested in all nodes in a particular hierarchy would monitor arg0path=<em>/ca/example/foo/</em>. Then the service could emit a signal with zeroth argument "/ca/example/foo/bar" to represent a modification to the “bar” property, or a signal with zeroth argument "/ca/example/" to represent atomic modification of many properties within that directory, and the interested application would be notified in both cases.</p></div>
<div class="paragraph"><p>This match key was added in version 0.12 of the D-Bus specification, implemented for STRING arguments by the bus daemon in dbus 1.2.0 and later, and implemented for OBJECT_PATH arguments in dbus 1.5.0 and later.</p></div>
<div class="paragraph"><p>arg0namespace   Like a bus name, except that the string is not required to contain a <em>.</em> (period)
Match messages whose first argument is of type STRING, and is a bus name or interface name within the specified namespace. This is primarily intended for watching name owner changes for a group of related bus names, rather than for a single name or all name changes.</p></div>
<div class="paragraph"><p>Because every valid interface name is also a valid bus name, this can also be used for messages whose first argument is an interface name.</p></div>
<div class="paragraph"><p>For example, the match rule member=<em>NameOwnerChanged</em>,arg0namespace=<em>com.example.backend1</em> matches name owner changes for bus names such as com.example.backend1.foo, com.example.backend1.foo.bar, and com.example.backend1 itself.</p></div>
<div class="paragraph"><p>See also the section called “org.freedesktop.DBus.NameOwnerChanged”.</p></div>
<div class="paragraph"><p>This match key was added in version 0.16 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.0 and later.</p></div>
<div class="paragraph"><p>eavesdrop       <em>true</em>, <em>false</em>
Since D-Bus 1.5.6, match rules do not match messages which have a DESTINATION field unless the match rule specifically requests this (see the section called “Eavesdropping”) by specifying eavesdrop=<em>true</em> in the match rule. eavesdrop=<em>false</em> restores the default behaviour. Messages are delivered to their DESTINATION regardless of match rules, so this match does not affect normal delivery of unicast messages. In older versions of D-Bus, this match was not allowed in match rules, and all match rules behaved as if eavesdrop=<em>true</em> had been used.</p></div>
<div class="paragraph"><p>Use of eavesdrop=<em>true</em> is deprecated. Monitors should prefer to use the BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”), which was introduced in version 0.26 of the D-Bus specification and version 1.9.10 of the reference dbus-daemon.</p></div>
<div class="paragraph"><p>Message bus implementations may restrict match rules with eavesdrop=<em>true</em> so that they can only be added by privileged connections.</p></div>
<div class="paragraph"><p>This match key was added in version 0.18 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.6 and later.</p></div>
<div class="paragraph"><p>Message Bus Starting Services (Activation)
The message bus can start applications on behalf of other applications. This is referred to as service activation or activation. An application that can be started in this way is called a service or an activatable service.</p></div>
<div class="paragraph"><p>Starting a service should be read as synonymous with service activation.</p></div>
<div class="paragraph"><p>In D-Bus, service activation is normally done by auto-starting. In auto-starting, applications send a message to a particular well-known name, such as com.example.TextEditor1, without specifying the NO_AUTO_START flag in the message header. If no application on the bus owns the requested name, but the bus daemon does know how to start an activatable service for that name, then the bus daemon will start that service, wait for it to request that name, and deliver the message to it.</p></div>
<div class="paragraph"><p>It is also possible for applications to send an explicit request to start a service: this is another form of activation, distinct from auto-starting. See the section called “org.freedesktop.DBus.StartServiceByName” for details.</p></div>
<div class="paragraph"><p>In either case, this implies a contract documented along with the name com.example.TextEditor1 for which object the owner of that name will provide, and what interfaces those objects will have.</p></div>
<div class="paragraph"><p>To find an executable corresponding to a particular name, the bus daemon looks for service description files. Service description files define a mapping from names to executables. Different kinds of message bus will look for these files in different places, see the section called “Well-known Message Bus Instances”.</p></div>
<div class="paragraph"><p>Service description files have the ".service" file extension. The message bus will only load service description files ending with .service; all other files will be ignored. The file format is similar to that of desktop entries. All service description files must be in UTF-8 encoding. To ensure that there will be no name collisions, service files must be namespaced using the same mechanism as messages and service names.</p></div>
<div class="paragraph"><p>On the well-known system bus, the name of a service description file must be its well-known name plus .service, for instance com.example.ConfigurationDatabase1.service.</p></div>
<div class="paragraph"><p>On the well-known session bus, services should follow the same service description file naming convention as on the system bus, but for backwards compatibility they are not required to do so.</p></div>
<div class="paragraph"><p>[FIXME the file format should be much better specified than "similar to .desktop entries" esp. since desktop entries are already badly-specified. ;-)] These sections from the specification apply to service files as well:</p></div>
<div class="paragraph"><p>General syntax</p></div>
<div class="paragraph"><p>Comment format</p></div>
<div class="paragraph"><p>Service description files must contain a D-BUS Service group with at least the keys Name (the well-known name of the service) and Exec (the command to be executed).</p></div>
<div class="paragraph"><p>Figure 9. Example service description file</p></div>
<div class="literalblock">
<div class="content">
<pre><code># Sample service description file
[D-BUS Service]
Name=com.example.ConfigurationDatabase1
Exec=/usr/bin/sample-configd</code></pre>
</div></div>
<div class="paragraph"><p>Additionally, service description files for the well-known system bus on Unix must contain a User key, whose value is the name of a user account (e.g. root). The system service will be run as that user.</p></div>
<div class="paragraph"><p>When an application asks to start a service by name, the bus daemon tries to find a service that will own that name. It then tries to spawn the executable associated with it. If this fails, it will report an error.</p></div>
<div class="paragraph"><p>On the well-known system bus, it is not possible for two .service files in the same directory to offer the same service, because they are constrained to have names that match the service name.</p></div>
<div class="paragraph"><p>On the well-known session bus, if two .service files in the same directory offer the same service name, the result is undefined. Distributors should avoid this situation, for instance by naming session services' .service files according to their service name.</p></div>
<div class="paragraph"><p>If two .service files in different directories offer the same service name, the one in the higher-priority directory is used: for instance, on the system bus, .service files in /usr/local/share/dbus-1/system-services take precedence over those in /usr/share/dbus-1/system-services.</p></div>
<div class="paragraph"><p>The executable launched will have the environment variable DBUS_STARTER_ADDRESS set to the address of the message bus so it can connect and request the appropriate names.</p></div>
<div class="paragraph"><p>The executable being launched may want to know whether the message bus starting it is one of the well-known message buses (see the section called “Well-known Message Bus Instances”). To facilitate this, the bus must also set the DBUS_STARTER_BUS_TYPE environment variable if it is one of the well-known buses. The currently-defined values for this variable are system for the systemwide message bus, and session for the per-login-session message bus. The new executable must still connect to the address given in DBUS_STARTER_ADDRESS, but may assume that the resulting connection is to the well-known bus.</p></div>
<div class="paragraph"><p>Message Bus Service Scope
The "scope" of a service is its "per-", such as per-session, per-machine, per-home-directory, or per-display. The reference implementation doesn&#8217;t yet support starting services in a different scope from the message bus itself. So e.g. if you start a service on the session bus its scope is per-session.</p></div>
<div class="paragraph"><p>We could add an optional scope to a bus name. For example, for per-(display,session pair), we could have a unique ID for each display generated automatically at login and set on screen 0 by executing a special "set display ID" binary. The ID would be stored in a _DBUS_DISPLAY_ID property and would be a string of random bytes. This ID would then be used to scope names. Starting/locating a service could be done by ID-name pair rather than only by name.</p></div>
<div class="paragraph"><p>Contrast this with a per-display scope. To achieve that, we would want a single bus spanning all sessions using a given display. So we might set a _DBUS_DISPLAY_BUS_ADDRESS property on screen 0 of the display, pointing to this bus.</p></div>
<div class="paragraph"><p>systemd Activation
Service description files may contain a SystemdService key. Its value is the name of a systemd service, for example dbus-com.example.MyDaemon.service.</p></div>
<div class="paragraph"><p>If this key is present, the bus daemon may carry out activation for this D-Bus service by sending a request to systemd asking it to start the systemd service whose name is the value of SystemdService. For example, the reference dbus-daemon has a --systemd-activation option that enables this feature, and that option is given when it is started by systemd.</p></div>
<div class="paragraph"><p>On the well-known system bus, it is a common practice to set SystemdService to dbus-, followed by the well-known bus name, followed by .service, then register that name as an alias for the real systemd service. This allows D-Bus activation of a service to be enabled or disabled independently of whether the service is started by systemd during boot.</p></div>
<div class="paragraph"><p>Mediating Activation with AppArmor
Please refer to AppArmor documentation for general information on AppArmor, and how it mediates D-Bus messages when used in conjunction with a kernel and dbus-daemon that support this.</p></div>
<div class="paragraph"><p>In recent versions of the reference dbus-daemon, AppArmor policy rules of type dbus send are also used to control auto-starting: if a message is sent to the well-known name of an activatable service, the dbus-daemon will attempt to determine whether it would deliver the message to that service beforeauto-starting it, by making some assumptions about the resulting process&#8217;s credentials.</p></div>
<div class="paragraph"><p>If it does proceed with auto-starting, when the service appears, the dbus-daemon repeats the policy check (with the service&#8217;s true credentials, which might not be identical) before delivering the message. In practice, this second check will usually be more strict than the first; the first check would only be more strict if there are "blacklist"-style rules like deny dbus send peer=(label=/usr/bin/protected) that match on the peer&#8217;s specific credentials, but AppArmor is normally used in a "whitelist" style where this does not apply.</p></div>
<div class="paragraph"><p>To support this process, service description files may contain a AssumedAppArmorLabel key. Its value is the name of an AppArmor label, for example /usr/sbin/mydaemon. If present, AppArmor mediation of messages that auto-start a service will decide whether to allow auto-starting to occur based on the assumption that the activated service will be confined under the specified label; in particular, rules of the form dbus send peer=(label=/usr/sbin/mydaemon) or deny dbus send peer=(label=/usr/sbin/mydaemon) will match it, allowing or denying as appropriate (even if there is in fact no profile of that name loaded).</p></div>
<div class="paragraph"><p>Otherwise, AppArmor mediation of messages that auto-start a service will decide whether to allow auto-starting to occur without specifying any particular label. In particular, any rule of the form dbus send peer=(label=X) or deny dbus send peer=(label=X) (for any value of X, including the special label unconfined) will not influence whether the auto-start is allowed.</p></div>
<div class="paragraph"><p>Rules of type dbus receive are not checked when deciding whether to allow auto-starting; they are only checked against the service&#8217;s profile after the service has started, when deciding whether to deliver the message that caused the auto-starting operation.</p></div>
<div class="paragraph"><p>Explicit activation via the section called “org.freedesktop.DBus.StartServiceByName” is not currently affected by this mediation: if a confined process is to be prevented from starting arbitrary services, then it must not be allowed to call that method.</p></div>
<div class="paragraph"><p>Well-known Message Bus Instances
Two standard message bus instances are defined here, along with how to locate them and where their service files live.</p></div>
<div class="paragraph"><p>Login session message bus
Each time a user logs in, a login session message bus may be started. All applications in the user&#8217;s login session may interact with one another using this message bus.</p></div>
<div class="paragraph"><p>The address of the login session message bus is given in the DBUS_SESSION_BUS_ADDRESS environment variable. If that variable is not set, applications may also try to read the address from the X Window System root window property _DBUS_SESSION_BUS_ADDRESS. The root window property must have type STRING. The environment variable should have precedence over the root window property.</p></div>
<div class="paragraph"><p>The address of the login session message bus is given in the DBUS_SESSION_BUS_ADDRESS environment variable. If DBUS_SESSION_BUS_ADDRESS is not set, or if it&#8217;s set to the string "autolaunch:", the system should use platform-specific methods of locating a running D-Bus session server, or starting one if a running instance cannot be found. Note that this mechanism is not recommended for attempting to determine if a daemon is running. It is inherently racy to attempt to make this determination, since the bus daemon may be started just before or just after the determination is made. Therefore, it is recommended that applications do not try to make this determination for their functionality purposes, and instead they should attempt to start the server.</p></div>
<div class="paragraph"><p>X Windowing System
For the X Windowing System, the application must locate the window owner of the selection represented by the atom formed by concatenating:</p></div>
<div class="paragraph"><p>the literal string "<em>DBUS_SESSION_BUS_SELECTION</em>"</p></div>
<div class="paragraph"><p>the current user&#8217;s username</p></div>
<div class="paragraph"><p>the literal character <em>_</em> (underscore)</p></div>
<div class="paragraph"><p>the machine&#8217;s ID</p></div>
<div class="paragraph"><p>The following properties are defined for the window that owns this X selection:</p></div>
<div class="paragraph"><p>Atom</p></div>
<div class="paragraph"><p>meaning</p></div>
<div class="paragraph"><p>_DBUS_SESSION_BUS_ADDRESS</p></div>
<div class="paragraph"><p>the actual address of the server socket</p></div>
<div class="paragraph"><p>_DBUS_SESSION_BUS_PID</p></div>
<div class="paragraph"><p>the PID of the server process</p></div>
<div class="paragraph"><p>At least the _DBUS_SESSION_BUS_ADDRESS property MUST be present in this window.</p></div>
<div class="paragraph"><p>If the X selection cannot be located or if reading the properties from the window fails, the implementation MUST conclude that there is no D-Bus server running and proceed to start a new server. (See below on concurrency issues)</p></div>
<div class="paragraph"><p>Failure to connect to the D-Bus server address thus obtained MUST be treated as a fatal connection error and should be reported to the application.</p></div>
<div class="paragraph"><p>As an alternative, an implementation MAY find the information in the following file located in the current user&#8217;s home directory, in subdirectory .dbus/session-bus/:</p></div>
<div class="paragraph"><p>the machine&#8217;s ID</p></div>
<div class="paragraph"><p>the literal character <em>-</em> (dash)</p></div>
<div class="paragraph"><p>the X display without the screen number, with the following prefixes removed, if present: ":", "localhost:" ."localhost.localdomain:". That is, a display of "localhost:10.0" produces just the number "10"</p></div>
<div class="paragraph"><p>The contents of this file NAME=value assignment pairs and lines starting with # are comments (no comments are allowed otherwise). The following variable names are defined:</p></div>
<div class="paragraph"><p>Variable</p></div>
<div class="paragraph"><p>meaning</p></div>
<div class="paragraph"><p>DBUS_SESSION_BUS_ADDRESS</p></div>
<div class="paragraph"><p>the actual address of the server socket</p></div>
<div class="paragraph"><p>DBUS_SESSION_BUS_PID</p></div>
<div class="paragraph"><p>the PID of the server process</p></div>
<div class="paragraph"><p>DBUS_SESSION_BUS_WINDOWID</p></div>
<div class="paragraph"><p>the window ID</p></div>
<div class="paragraph"><p>At least the DBUS_SESSION_BUS_ADDRESS variable MUST be present in this file.</p></div>
<div class="paragraph"><p>Failure to open this file MUST be interpreted as absence of a running server. Therefore, the implementation MUST proceed to attempting to launch a new bus server if the file cannot be opened.</p></div>
<div class="paragraph"><p>However, success in opening this file MUST NOT lead to the conclusion that the server is running. Thus, a failure to connect to the bus address obtained by the alternative method MUST NOT be considered a fatal error. If the connection cannot be established, the implementation MUST proceed to check the X selection settings or to start the server on its own.</p></div>
<div class="paragraph"><p>If the implementation concludes that the D-Bus server is not running it MUST attempt to start a new server and it MUST also ensure that the daemon started as an effect of the "autolaunch" mechanism provides the lookup mechanisms described above, so subsequent calls can locate the newly started server. The implementation MUST also ensure that if two or more concurrent initiations happen, only one server remains running and all other initiations are able to obtain the address of this server and connect to it. In other words, the implementation MUST ensure that the X selection is not present when it attempts to set it, without allowing another process to set the selection between the verification and the setting (e.g., by using XGrabServer / XungrabServer).</p></div>
<div class="paragraph"><p>Finding session services
On Unix systems, the session bus should search for .service files in $XDG_DATA_DIRS/dbus-1/services as defined by the XDG Base Directory Specification. Implementations may also search additional locations, with a higher or lower priority than the XDG directories.</p></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>System message bus
A computer may have a system message bus, accessible to all applications on the system. This message bus may be used to broadcast system events, such as adding new hardware devices, changes in the printer queue, and so forth.</p></div>
<div class="paragraph"><p>The address of the system message bus is given in the DBUS_SYSTEM_BUS_ADDRESS environment variable. If that variable is not set, applications should try to connect to the well-known address unix:path=/var/run/dbus/system_bus_socket. [3]</p></div>
<div class="paragraph"><p>On Unix systems, the system bus should default to searching for .service files in /usr/local/share/dbus-1/system-services, /usr/share/dbus-1/system-services and /lib/dbus-1/system-services, with that order of precedence. It may also search other implementation-specific locations, but should not vary these locations based on environment variables. [4]</p></div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Message Bus Messages
The special message bus name org.freedesktop.DBus responds to a number of additional messages at the object path /org/freedesktop/DBus. That object path is also used when emitting the the section called “org.freedesktop.DBus.NameOwnerChanged” signal.</p></div>
<div class="paragraph"><p>For historical reasons, some of the methods in the org.freedesktop.DBus interface are available on multiple object paths. Message bus implementations should accept method calls that were added before specification version 0.26 on any object path. Message bus implementations should not accept newer method calls on unexpected object paths, and as a security hardening measure, older method calls that are security-sensitive may be rejected with the error org.freedesktop.DBus.Error.AccessDenied when called on an unexpected object path. Client software should send all method calls to /org/freedesktop/DBus instead of relying on this.</p></div>
<div class="paragraph"><p>In addition to the method calls listed below, the message bus should implement the standard Introspectable, Properties and Peer interfaces (see the section called “Standard Interfaces”). Support for the Properties and Peer interfaces was added in version 1.11.x of the reference implementation of the message bus.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Hello
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>STRING Hello ()</code></pre>
</div></div>
<div class="paragraph"><p>Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique name assigned to the connection
Before an application is able to send messages to other applications it must send the org.freedesktop.DBus.Hello message to the message bus to obtain a unique name. If an application without a unique name tries to send a message to another application, or a message to the message bus itself that isn&#8217;t the org.freedesktop.DBus.Hello message, it will be disconnected from the bus.</p></div>
<div class="paragraph"><p>There is no corresponding "disconnect" request; if a client wishes to disconnect from the bus, it simply closes the socket (or other communication channel).</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.RequestName
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UINT32 RequestName (in STRING name, in UINT32 flags)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name to request
1       UINT32  Flags
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       UINT32  Return value
Ask the message bus to assign the given name to the method caller. Each name maintains a queue of possible owners, where the head of the queue is the primary or current owner of the name. Each potential owner in the queue maintains the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE settings from its latest RequestName call. When RequestName is invoked the following occurs:</p></div>
<div class="paragraph"><p>If the method caller is currently the primary owner of the name, the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE values are updated with the values from the new RequestName call, and nothing further happens.</p></div>
<div class="paragraph"><p>If the current primary owner (head of the queue) has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, and the RequestName invocation has the DBUS_NAME_FLAG_REPLACE_EXISTING flag, then the caller of RequestName replaces the current primary owner at the head of the queue and the current primary owner moves to the second position in the queue. If the caller of RequestName was in the queue previously its flags are updated with the values from the new RequestName in addition to moving it to the head of the queue.</p></div>
<div class="paragraph"><p>If replacement is not possible, and the method caller is currently in the queue but not the primary owner, its flags are updated with the values from the new RequestName call.</p></div>
<div class="paragraph"><p>If replacement is not possible, and the method caller is currently not in the queue, the method caller is appended to the queue.</p></div>
<div class="paragraph"><p>If any connection in the queue has DBUS_NAME_FLAG_DO_NOT_QUEUE set and is not the primary owner, it is removed from the queue. This can apply to the previous primary owner (if it was replaced) or the method caller (if it updated the DBUS_NAME_FLAG_DO_NOT_QUEUE flag while still stuck in the queue, or if it was just added to the queue with that flag set).</p></div>
<div class="paragraph"><p>Note that DBUS_NAME_FLAG_REPLACE_EXISTING results in "jumping the queue," even if another application already in the queue had specified DBUS_NAME_FLAG_REPLACE_EXISTING. This comes up if a primary owner that does not allow replacement goes away, and the next primary owner does allow replacement. In this case, queued items that specified DBUS_NAME_FLAG_REPLACE_EXISTING do not automatically replace the new primary owner. In other words, DBUS_NAME_FLAG_REPLACE_EXISTING is not saved, it is only used at the time RequestName is called. This is deliberate to avoid an infinite loop anytime two applications are both DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_REPLACE_EXISTING.</p></div>
<div class="paragraph"><p>The flags argument contains any of the following values logically ORed together:</p></div>
<div class="paragraph"><p>Conventional Name       Value   Description
DBUS_NAME_FLAG_ALLOW_REPLACEMENT        0x1     If an application A specifies this flag and succeeds in becoming the owner of the name, and another application B later calls RequestName with the DBUS_NAME_FLAG_REPLACE_EXISTING flag, then application A will lose ownership and receive a org.freedesktop.DBus.NameLost signal, and application B will become the new owner. If DBUS_NAME_FLAG_ALLOW_REPLACEMENT is not specified by application A, or DBUS_NAME_FLAG_REPLACE_EXISTING is not specified by application B, then application B will not replace application A as the owner.
DBUS_NAME_FLAG_REPLACE_EXISTING 0x2     Try to replace the current owner if there is one. If this flag is not set the application will only become the owner of the name if there is no current owner. If this flag is set, the application will replace the current owner if the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT.
DBUS_NAME_FLAG_DO_NOT_QUEUE     0x4     Without this flag, if an application requests a name that is already owned, the application will be placed in a queue to own the name when the current owner gives it up. If this flag is given, the application will not be placed in the queue, the request for the name will simply fail. This flag also affects behavior when an application is replaced as name owner; by default the application moves back into the waiting queue, unless this flag was provided when the application became the name owner.
The return code can be one of the following values:</p></div>
<div class="paragraph"><p>Conventional Name       Value   Description
DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER   1       The caller is now the primary owner of the name, replacing any previous owner. Either the name had no owner before, or the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT.
DBUS_REQUEST_NAME_REPLY_IN_QUEUE        2       The name already had an owner, DBUS_NAME_FLAG_DO_NOT_QUEUE was not specified, and either the current owner did not specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the requesting application did not specify DBUS_NAME_FLAG_REPLACE_EXISTING.
DBUS_REQUEST_NAME_REPLY_EXISTS  3       The name already has an owner, DBUS_NAME_FLAG_DO_NOT_QUEUE was specified, and either DBUS_NAME_FLAG_ALLOW_REPLACEMENT was not specified by the current owner, or DBUS_NAME_FLAG_REPLACE_EXISTING was not specified by the requesting application.
DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER   4       The application trying to request ownership of a name is already the owner of it.
org.freedesktop.DBus.ReleaseName
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UINT32 ReleaseName (in STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name to release
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       UINT32  Return value
Ask the message bus to release the method caller&#8217;s claim to the given name. If the caller is the primary owner, a new primary owner will be selected from the queue if any other owners are waiting. If the caller is waiting in the queue for the name, the caller will removed from the queue and will not be made an owner of the name if it later becomes available. If there are no other owners in the queue for the name, it will be removed from the bus entirely. The return code can be one of the following values:</p></div>
<div class="paragraph"><p>Conventional Name       Value   Description
DBUS_RELEASE_NAME_REPLY_RELEASED        1       The caller has released his claim on the given name. Either the caller was the primary owner of the name, and the name is now unused or taken by somebody waiting in the queue for the name, or the caller was waiting in the queue for the name and has now been removed from the queue.
DBUS_RELEASE_NAME_REPLY_NON_EXISTENT    2       The given name does not exist on this bus.
DBUS_RELEASE_NAME_REPLY_NOT_OWNER       3       The caller was not the primary owner of this name, and was also not waiting in the queue to own this name.
org.freedesktop.DBus.ListQueuedOwners
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ARRAY of STRING ListQueuedOwners (in STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  The well-known bus name to query, such as com.example.cappuccino
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of STRING The unique bus names of connections currently queued for the name
List the connections currently queued for a bus name (see Queued Name Owner).</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.ListNames
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ARRAY of STRING ListNames ()</code></pre>
</div></div>
<div class="paragraph"><p>Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of STRING Array of strings where each string is a bus name
Returns a list of all currently-owned names on the bus.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.ListActivatableNames
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ARRAY of STRING ListActivatableNames ()</code></pre>
</div></div>
<div class="paragraph"><p>Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of STRING Array of strings where each string is a bus name
Returns a list of all names that can be activated on the bus.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.NameHasOwner
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>BOOLEAN NameHasOwner (in STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name to check
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       BOOLEAN Return value, true if the name exists
Checks if the specified name exists (currently has an owner).</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.NameOwnerChanged
This is a signal:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>NameOwnerChanged (STRING name, STRING old_owner, STRING new_owner)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name with a new owner
1       STRING  Old owner or empty string if none
2       STRING  New owner or empty string if none
This signal indicates that the owner of a name has changed. It&#8217;s also the signal to use to detect the appearance of new names on the bus.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.NameLost
This is a signal:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>NameLost (STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name which was lost
This signal is sent to a specific application when it loses ownership of a name.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.NameAcquired
This is a signal:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>NameAcquired (STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name which was acquired
This signal is sent to a specific application when it gains ownership of a name.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.StartServiceByName
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UINT32 StartServiceByName (in STRING name, in UINT32 flags)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name of the service to start
1       UINT32  Flags (currently not used)
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       UINT32  Return value
Tries to launch the executable associated with a name (service activation), as an explicit request. This is an alternative to relying on auto-starting. For more information on how services are activated and the difference between auto-starting and explicit activation, see the section called “Message Bus Starting Services (Activation)”.</p></div>
<div class="paragraph"><p>It is often preferable to carry out auto-starting instead of calling this method. This is because calling this method is subject to a time-of-check/time-of-use issue: if a caller asks the message bus to start a service so that the same caller can make follow-up method calls to that service, the fact that the message bus was able to start the required service is no guarantee that it will not have crashed or otherwise exited by the time the caller makes those follow-up method calls. As a result, calling this method does not remove the need for the caller to handle errors from method calls. Given that fact, it is usually simpler to rely on auto-starting, in which the required service starts as a side-effect of the first method call.</p></div>
<div class="paragraph"><p>The return value can be one of the following values:</p></div>
<div class="paragraph"><p>Identifier      Value   Description
DBUS_START_REPLY_SUCCESS        1       The service was successfully started.
DBUS_START_REPLY_ALREADY_RUNNING        2       A connection already owns the given name.
org.freedesktop.DBus.UpdateActivationEnvironment
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UpdateActivationEnvironment (in ARRAY of DICT&lt;STRING,STRING&gt; environment)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of DICT&lt;STRING,STRING&gt;    Environment to add or update
Normally, session bus activated services inherit the environment of the bus daemon. This method adds to or modifies that environment when activating services.</p></div>
<div class="paragraph"><p>Some bus instances, such as the standard system bus, may disable access to this method for some or all callers.</p></div>
<div class="paragraph"><p>Note, both the environment variable names and values must be valid UTF-8. There&#8217;s no way to update the activation environment with data that is invalid UTF-8.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetNameOwner
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>STRING GetNameOwner (in STRING name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Name to get the owner of
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Return value, a unique connection name
Returns the unique connection name of the primary owner of the name given. If the requested name doesn&#8217;t have an owner, returns a org.freedesktop.DBus.Error.NameHasNoOwner error.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetConnectionUnixUser
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UINT32 GetConnectionUnixUser (in STRING bus_name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       UINT32  Unix user ID
Returns the Unix user ID of the process connected to the server. If unable to determine it (for instance, because the process is not on the same machine as the bus daemon), an error is returned.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetConnectionUnixProcessID
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>UINT32 GetConnectionUnixProcessID (in STRING bus_name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       UINT32  Unix process id
Returns the Unix process ID of the process connected to the server. If unable to determine it (for instance, because the process is not on the same machine as the bus daemon), an error is returned.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetConnectionCredentials
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>DICT&lt;STRING,VARIANT&gt; GetConnectionCredentials (in STRING bus_name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       DICT&lt;STRING,VARIANT&gt;    Credentials
Returns as many credentials as possible for the process connected to the server. If unable to determine certain credentials (for instance, because the process is not on the same machine as the bus daemon, or because this version of the bus daemon does not support a particular security framework), or if the values of those credentials cannot be represented as documented here, then those credentials are omitted.</p></div>
<div class="paragraph"><p>Keys in the returned dictionary not containing "." are defined by this specification. Bus daemon implementors supporting credentials frameworks not mentioned in this document should either contribute patches to this specification, or use keys containing "." and starting with a reversed domain name.</p></div>
<div class="paragraph"><p>Key     Value type      Value
UnixUserID      UINT32  The numeric Unix user ID, as defined by POSIX
UnixGroupIDs    ARRAY of UINT32 The numeric Unix group IDs (including both the primary group and the supplementary groups), as defined by POSIX, in numerically sorted order. This array is either complete or absent: if the message bus is able to determine some but not all of the caller&#8217;s groups, or if one of the groups is not representable in a UINT32, it must not add this credential to the dictionary.
ProcessID       UINT32  The numeric process ID, on platforms that have this concept. On Unix, this is the process ID defined by POSIX.
WindowsSID      STRING  The Windows security identifier in its string form, e.g. "S-1-5-21-3623811015-3361044348-30300820-1013" for a domain or local computer user or "S-1-5-18" for the LOCAL_SYSTEM user
LinuxSecurityLabel      ARRAY of BYTE
On Linux systems, the security label that would result from the SO_PEERSEC getsockopt call. The array contains the non-zero bytes of the security label in an unspecified ASCII-compatible encoding[a], followed by a single zero byte.</p></div>
<div class="paragraph"><p>For example, the SELinux context system_u:system_r:init_t:s0 (a string of length 27) would be encoded as 28 bytes ending with <em>:</em>, <em>s</em>, <em>0</em>, <em>\x00</em>.[b]</p></div>
<div class="paragraph"><p>On SELinux systems this is the SELinux context, as output by ps -Z or ls -Z. Typical values might include system_u:system_r:init_t:s0, unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023, or unconfined_u:unconfined_r:chrome_sandbox_t:s0-s0:c0.c1023.</p></div>
<div class="paragraph"><p>On Smack systems, this is the Smack label. Typical values might include _, *, User, System or System::Shared.</p></div>
<div class="paragraph"><p>On AppArmor systems, this is the AppArmor context, a composite string encoding the AppArmor label (one or more profiles) and the enforcement mode. Typical values might include unconfined, /usr/bin/firefox (enforce) or user1 (complain).</p></div>
<div class="paragraph"><p>[a] It could be ASCII or UTF-8, but could also be ISO Latin-1 or any other encoding.</p></div>
<div class="paragraph"><p>[b] Note that this is not the same as the older GetConnectionSELinuxContext method, which does not append the zero byte. Always appending the zero byte allows callers to read the string from the message payload without copying.</p></div>
<div class="paragraph"><p>This method was added in D-Bus 1.7 to reduce the round-trips required to list a process&#8217;s credentials. In older versions, calling this method will fail: applications should recover by using the separate methods such as the section called “org.freedesktop.DBus.GetConnectionUnixUser” instead.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetAdtAuditSessionData
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ARRAY of BYTE GetAdtAuditSessionData (in STRING bus_name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of BYTE   auditing data as returned by adt_export_session_data()
Returns auditing data used by Solaris ADT, in an unspecified binary format. If you know what this means, please contribute documentation via the D-Bus bug tracking system. This method is on the core DBus interface for historical reasons; the same information should be made available via the section called “org.freedesktop.DBus.GetConnectionCredentials” in future.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetConnectionSELinuxSecurityContext
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>ARRAY of BYTE GetConnectionSELinuxSecurityContext (in STRING bus_name)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of BYTE   some sort of string of bytes, not necessarily UTF-8, not including <em>\0</em>
Returns the security context used by SELinux, in an unspecified format. If you know what this means, please contribute documentation via the D-Bus bug tracking system. This method is on the core DBus interface for historical reasons; the same information should be made available via the section called “org.freedesktop.DBus.GetConnectionCredentials” in future.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.AddMatch
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>AddMatch (in STRING rule)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Match rule to add to the connection
Adds a match rule to match messages going through the message bus (see the section called “Match Rules”). If the bus does not have enough resources the org.freedesktop.DBus.Error.OOM error is returned.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.RemoveMatch
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>RemoveMatch (in STRING rule)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Match rule to remove from the connection
Removes the first rule that matches (see the section called “Match Rules”). If the rule is not found the org.freedesktop.DBus.Error.MatchRuleNotFound error is returned.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.GetId
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>GetId (out STRING id)</code></pre>
</div></div>
<div class="paragraph"><p>Reply arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       STRING  Unique ID identifying the bus daemon
Gets the unique ID of the bus. The unique ID here is shared among all addresses the bus daemon is listening on (TCP, UNIX domain socket, etc.) and its format is described in the section called “UUIDs”. Each address the bus is listening on also has its own unique ID, as described in the section called “Server Addresses”. The per-bus and per-address IDs are not related. There is also a per-machine ID, described in the section called “org.freedesktop.DBus.Peer” and returned by org.freedesktop.DBus.Peer.GetMachineId(). For a desktop session bus, the bus ID can be used as a way to uniquely identify a user&#8217;s session.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Monitoring.BecomeMonitor
As a method:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>BecomeMonitor (in ARRAY of STRING rule, in UINT32 flags)</code></pre>
</div></div>
<div class="paragraph"><p>Message arguments:</p></div>
<div class="paragraph"><p>Argument        Type    Description
0       ARRAY of STRING Match rules to add to the connection
1       UINT32  Not used, must be 0
Converts the connection into a monitor connection which can be used as a debugging/monitoring tool. Only a user who is privileged on this bus (by some implementation-specific definition) may create monitor connections[5].</p></div>
<div class="paragraph"><p>Monitor connections lose all their bus names, including the unique connection name, and all their match rules. Sending messages on a monitor connection is not allowed: applications should use a private connection for monitoring.</p></div>
<div class="paragraph"><p>Monitor connections may receive all messages, even messages that should only have gone to some other connection ("eavesdropping"). The first argument is a list of match rules, which replace any match rules that were previously active for this connection. These match rules are always treated as if they contained the special eavesdrop=<em>true</em> member.</p></div>
<div class="paragraph"><p>As a special case, an empty list of match rules (which would otherwise match nothing, making the monitor useless) is treated as a shorthand for matching all messages.</p></div>
<div class="paragraph"><p>The second argument might be used for flags to influence the behaviour of the monitor connection in future D-Bus versions.</p></div>
<div class="paragraph"><p>Message bus implementations should attempt to minimize the side-effects of monitoring — in particular, unlike ordinary eavesdropping, monitoring the system bus does not require the access control rules to be relaxed, which would change the set of messages that can be delivered to their (non-monitor) destinations. However, it is unavoidable that monitoring will increase the message bus&#8217;s resource consumption. In edge cases where there was barely enough time or memory without monitoring, this might result in message deliveries failing when they would otherwise have succeeded.</p></div>
<div class="paragraph"><p>Message Bus Properties
The special message bus name org.freedesktop.DBus exports several properties (see the section called “org.freedesktop.DBus.Properties”) on the object path /org/freedesktop/DBus.</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Features
As a property:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Read-only constant ARRAY of STRING Features</code></pre>
</div></div>
<div class="paragraph"><p>This property lists abstract “features” provided by the message bus, and can be used by clients to detect the capabilities of the message bus with which they are communicating. This property was added in version 1.11.x of the reference implementation of the message bus.</p></div>
<div class="paragraph"><p>Items in the returned array not containing “.” are defined by this specification. Bus daemon implementors wishing to advertise features not mentioned in this document should either contribute patches to this specification, or use keys containing “.” and starting with their own reversed domain name, for example com.example.MyBus.SubliminalMessages.</p></div>
<div class="paragraph"><p>The features currently defined in this specification are as follows:</p></div>
<div class="paragraph"><p>AppArmor
This message bus filters messages via the AppArmor security framework. This feature should only be advertised if AppArmor mediation is enabled and active at runtime; merely compiling in support for AppArmor should not result in this feature being advertised on message bus instances where it is disabled by message bus or operating system configuration.</p></div>
<div class="paragraph"><p>HeaderFiltering
This message bus guarantees that it will remove header fields that it does not understand when it relays messages, so that a client receiving a recently-defined header field that is specified to be controlled by the message bus can safely assume that it was in fact set by the message bus. This check is needed because older message bus implementations did not guarantee to filter headers in this way, so a malicious client could send any recently-defined header field with a crafted value of its choice through an older message bus that did not understand that header field.</p></div>
<div class="paragraph"><p>SELinux
This message bus filters messages via the SELinux security framework. Similar to apparmor, this feature should only be advertised if SELinux mediation is enabled and active at runtime (if SELinux is placed in permissive mode, that is still considered to be active).</p></div>
<div class="paragraph"><p>SystemdActivation
When asked to activate a service that has the SystemdService field in its .service file, this message bus will carry out systemd activation (for details see the section called “systemd Activation”).</p></div>
<div class="paragraph"><p>org.freedesktop.DBus.Interfaces
As a property:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Read-only constant ARRAY of STRING Interfaces</code></pre>
</div></div>
<div class="paragraph"><p>This property lists interfaces provided by the /org/freedesktop/DBus object, and can be used by clients to detect the capabilities of the message bus with which they are communicating. Unlike the standard Introspectable interface, querying this property does not require parsing XML. This property was added in version 1.11.x of the reference implementation of the message bus.</p></div>
<div class="paragraph"><p>The standard org.freedesktop.DBus and org.freedesktop.DBus.Properties interfaces are not included in the value of this property, because their presence can be inferred from the fact that a method call on org.freedesktop.DBus.Properties asking for properties of org.freedesktop.DBus was successful. The standard org.freedesktop.DBus.Peer and org.freedesktop.DBus.Introspectable interfaces are not included in the value of this property either, because they do not indicate features of the message bus implementation.</p></div>
<div class="paragraph"><p>Glossary
This glossary defines some of the terms used in this specification.</p></div>
<div class="paragraph"><p>Bus Name
The message bus maintains an association between names and connections. (Normally, there&#8217;s one connection per application.) A bus name is simply an identifier used to locate connections. For example, the hypothetical com.yoyodyne.Screensaver name might be used to send a message to a screensaver from Yoyodyne Corporation. An application is said to own a name if the message bus has associated the application&#8217;s connection with the name. Names may also have queued owners (see Queued Name Owner). The bus assigns a unique name to each connection, see Unique Connection Name. Other names can be thought of as "well-known names" and are used to find applications that offer specific functionality.</p></div>
<div class="paragraph"><p>See the section called “Bus names” for details of the syntax and naming conventions for bus names.</p></div>
<div class="paragraph"><p>Message
A message is the atomic unit of communication via the D-Bus protocol. It consists of a header and a body; the body is made up of arguments.</p></div>
<div class="paragraph"><p>Message Bus
The message bus is a special application that forwards or routes messages between a group of applications connected to the message bus. It also manages names used for routing messages.</p></div>
<div class="paragraph"><p>Name
See Bus Name. "Name" may also be used to refer to some of the other names in D-Bus, such as interface names.</p></div>
<div class="paragraph"><p>Namespace
Used to prevent collisions when defining new interfaces, bus names etc. The convention used is the same one Java uses for defining classes: a reversed domain name. See the section called “Bus names”, the section called “Interface names”, the section called “Error names”, the section called “Valid Object Paths”.</p></div>
<div class="paragraph"><p>Object
Each application contains objects, which have interfaces and methods. Objects are referred to by a name, called a path.</p></div>
<div class="paragraph"><p>One-to-One
An application talking directly to another application, without going through a message bus. One-to-one connections may be "peer to peer" or "client to server." The D-Bus protocol has no concept of client vs. server after a connection has authenticated; the flow of messages is symmetrical (full duplex).</p></div>
<div class="paragraph"><p>Path
Object references (object names) in D-Bus are organized into a filesystem-style hierarchy, so each object is named by a path. As in LDAP, there&#8217;s no difference between "files" and "directories"; a path can refer to an object, while still having child objects below it.</p></div>
<div class="paragraph"><p>Queued Name Owner
Each bus name has a primary owner; messages sent to the name go to the primary owner. However, certain names also maintain a queue of secondary owners "waiting in the wings." If the primary owner releases the name, then the first secondary owner in the queue automatically becomes the new owner of the name.</p></div>
<div class="paragraph"><p>Service
A service is an executable that can be launched by the bus daemon. Services normally guarantee some particular features, for example they may guarantee that they will request a specific name such as "com.example.Screensaver1", have a singleton object "/com/example/Screensaver1", and that object will implement the interface "com.example.Screensaver1.Control".</p></div>
<div class="paragraph"><p>Service Description Files
".service files" tell the bus about service applications that can be launched (see Service). Most importantly they provide a mapping from bus names to services that will request those names when they start up.</p></div>
<div class="paragraph"><p>Unique Connection Name
The special name automatically assigned to each connection by the message bus. This name will never change owner, and will be unique (never reused during the lifetime of the message bus). It will begin with a <em>:</em> character.</p></div>
<div class="paragraph"><p>[1] Lockfiles are used instead of real file locking fcntl() because real locking implementations are still flaky on network filesystems.</p></div>
<div class="paragraph"><p>[2] This idiosyncratic quoting style is based on the rules for escaping items to appear inside single-quoted strings in POSIX /bin/sh, but please note that backslashes that are not inside single quotes have different behaviour. This syntax does not offer any way to represent an apostrophe inside single quotes (it is necessary to leave the single-quoted section, backslash-escape the apostrophe and re-enter single quotes), or to represent a comma outside single quotes (it is necessary to wrap it in a single-quoted section).</p></div>
<div class="paragraph"><p>[3] The D-Bus reference implementation actually honors the $(localstatedir) configure option for this address, on both client and server side.</p></div>
<div class="paragraph"><p>[4] The system bus is security-sensitive and is typically executed by an init system with a clean environment. Its launch helper process is particularly security-sensitive, and specifically clears its own environment.</p></div>
<div class="paragraph"><p>[5] In the reference implementation, the default configuration is that each user (identified by numeric user ID) may monitor their own session bus, and the root user (user ID zero) may monitor the system bus.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-04-25 02:52:07 EEST
</div>
</div>
</body>
</html>
