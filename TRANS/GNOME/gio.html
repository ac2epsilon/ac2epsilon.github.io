<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_gobject_reference_manual_for_gobject_2_64_1">GObject Reference Manual for GObject 2.64.1</h2>
<div class="sectionbody">
<div class="paragraph"><p>The latest version of this documentation can be found on-line at <a href="https://developer.gnome.org/gobject/unstable/">https://developer.gnome.org/gobject/unstable/</a>.</p></div>
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>Більшість сучасних мов програмування мають власні об'єктні системи та додаткові фундаментальні алгоритмічні мовні конструкції. Подібно до того, як GLib служить реалізацією таких фундаментальних типів та алгоритмів (пов'язані списки, хеш-таблиці тощо), система об’єктів GLib забезпечує необхідні реалізації гнучкого, розширюваного та навмисно простого для відображення (в інші мови) об'єкт-орієнтований фреймворку для C. Суттєві елементи, які надаються, можна підсумувати так:</p></div>
<div class="ulist"><ul>
<li>
<p>
Загальна система типів для реєстрації довільних одно-успадкованих пласких та глибоких похідних типів, а також інтерфейсів для структурованих типів. Вона піклується про створення, ініціалізацію та управління пам’яттю об'єднаних об'єктних та класових структур, підтримує взаємовідносини батьків і дітей та займається динамічними реалізаціями таких типів. Тобто, їх конкретні типові реалізації можуть бути переміщені/незавантажувані під час виконання.
</p>
</li>
<li>
<p>
Колекція реалізацій основних типів, таких як цілі числа, подвійні, перерахунки та структуровані типи, щоб назвати декілька.
</p>
</li>
<li>
<p>
Зразок реалізації фундаментального типу для базових ієрархій об'єктів - фундаментального типу GObject.
</p>
</li>
<li>
<p>
Сигнальна система, яка дозволяє дуже гнучко налаштовуватись користувачу на віртуальні/перезаписні методи об’єктів і може слугувати потужним механізмом сповіщення.
</p>
</li>
<li>
<p>
Розширювана система параметрів/значень, що підтримує всі надані основні типи, які можуть бути задіяні для загального використання властивостей об'єкта або інших параметризованих типів.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__i_">Частина I. Концепції</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__2">Підгрунтя</h3>
<div class="paragraph"><p><code>GObject</code> та його система нижчого рівня, <code>GType</code>, використовуються GTK + та в більшості бібліотек GNOME для забезпечення:</p></div>
<div class="ulist"><ul>
<li>
<p>
об'єктно-орієнтовані API на основі C та
</p>
</li>
<li>
<p>
автоматичні прозорі прив’язки API до інших компільованих або інтерпретованих мов.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Дуже багато програмістів звикли працювати із мовами, що тільки компілюються або лише динамічно інтерпретуються, і не розуміють проблем, пов’язаних із міжмовною сумісністю. Цей вступ намагається дати розуміння цих проблем і коротко описує рішення, обране GLib.</p></div>
<div class="paragraph"><p>У наступних главах детальніше описується, як працюють <code>GType</code> та <code>GObject</code>, і як ви можете використовувати їх як програміст C. Корисно пам’ятати, що надання доступу до об’єктів C з інших інтерпретованих мов було однією з головних цілей дизайну: це часто може пояснити іноді досить складні API та функції, наявні в цій бібліотеці.</p></div>
</div>
<div class="sect2">
<h3 id="____">Типи даних та програмування</h3>
<div class="paragraph"><p>Можна сказати, що мова програмування - це лише спосіб створення типів даних та маніпулювання ними. Більшість мов надають декілька мовно-природних типів та кілька примітивів для створення більш складних типів на основі цих примітивних типів.</p></div>
<div class="paragraph"><p>У мові C передбачені такі типи, як <code>char</code>, <code>long</code>, <code>pointer</code>. Під час компіляції коду С компілятор відображає ці мовні типи на машинні типи цільової архітектури. Якщо ви використовуєте інтерпретатор C (припустимо, що він існує), то інтерпретатор (програма, що інтерпретує вихідний код і виконує його) відображає типи мови на типи цільової машини під час виконання програми (або безпосередньо перед цим виконанням, якщо він використовує двигун компілятора Just In Time).</p></div>
<div class="paragraph"><p>Perl і Python - інтерпретовані мови, які насправді не забезпечують визначення типів, подібних до тих, що використовуються C. Програмісти Perl і Python маніпулюють змінними, і тип змінних визначається лише при першому призначенні або при першому використанні, яке визначає тип на змінної. Інтерпретатор також часто забезпечує безліч автоматичних перетворень від одного типу до іншого. Наприклад, в Perl змінна, яка містить ціле число, може бути автоматично перетворена в рядок, згідно з потребою контекста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">my</span> <span class="err">$</span><span class="n">tmp</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">print</span> <span class="s">&quot;this is an integer converted to a string:&quot;</span> <span class="p">.</span> <span class="err">$</span><span class="n">tmp</span> <span class="p">.</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Звичайно, часто також можна чітко вказати перетворення, коли конверсії за замовчуванням, які надаються мовою, не є інтуїтивно зрозумілими.</p></div>
</div>
<div class="sect2">
<h3 id="__api_c">Експорт API C</h3>
<div class="paragraph"><p>API визначаються набором функцій та глобальними змінними, які зазвичай експортуються з двійкового файлу. Функції C мають довільну кількість аргументів і одне повернене значення. Кожна функція, таким чином, однозначно ідентифікується назвою функції та набором типів C, які описують аргументи функції та повертають значення. Глобальні змінні, експортовані API, аналогічно ідентифікуються за назвою та типом.</p></div>
<div class="paragraph"><p>Таким чином, API C визначається лише набором імен, до яких пов'язаний набір типів. Якщо ви знаєте конвенцію виклику функції та відображення типів C на машинні типи, використовуваних платформою, на якій ви перебуваєте, ви можете вирішити ім’я кожної функції, щоб знайти, де в пам'яті знаходиться код, пов'язаний з цією функцією, а потім побудувати правильний список аргументів для функції. Нарешті, все, що вам потрібно зробити, це запустити виклик до цільової функції C зі списком аргументів.</p></div>
<div class="paragraph"><p>Для обговорення тут наведена проста функція C та пов'язаний з нею 32-бітний код ассемблеру x86, сформований GCC на комп'ютері Linux:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">function_foo</span> <span class="p">(</span><span class="kt">int</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span> <span class="p">(</span><span class="kt">int</span>   <span class="n">argc</span><span class="p">,</span>
      <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
        <span class="n">function_foo</span> <span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nf">push</span>   <span class="no">$0xa</span>
<span class="nf">call</span>   <span class="mh">0x80482f4</span> <span class="p">&lt;</span><span class="no">function_foo</span><span class="p">&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Код асемблера, показаний вище, досить простий: перша інструкція заштовхує в стек шістнадцяткове значення <code>0xa</code> (десяткове значення <code>10</code>) як 32-бітове ціле число і викликає <code>function_foo</code>. Як бачимо, виклики функцій C реалізуються GCC як виклики природних функцій (це, мабуть, найшвидша реалізація).</p></div>
<div class="paragraph"><p>Тепер, скажімо, ми хочемо викликати функцію C <code>function_foo</code> з програми Python. Для цього інтерпретатору Python необхідно:</p></div>
<div class="ulist"><ul>
<li>
<p>
Знайдіть, де функція знаходиться. Це, ймовірно, означає пошук двійкового файлу, сформованого компілятором C, який експортує цю функцію.
</p>
</li>
<li>
<p>
Завантажте код функції у виконувану пам'ять.
</p>
</li>
<li>
<p>
Перетворіть параметри Python в параметри, сумісні з C, перш ніж викликати функцію.
</p>
</li>
<li>
<p>
Викличте функцію за правильним протоколом виклику.
</p>
</li>
<li>
<p>
Перетворіть значення повернення функції C в сумісні з Python змінні, щоб повернути їх у код Python.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Описаний вище процес досить складний, і існує маса способів зробити його повністю автоматичним і прозорим для програмістів на C і Python:</p></div>
<div class="paragraph"><p>Перше рішення - вручну написати багато зкліючого коду, один раз для кожної функції, що експортується чи імпортується, що здійснює перетворення параметрів Python-в-C та перетворення зворотного значення C-в-Python. Потім цей клей-код пов'язується з інтерпретатором, який дозволяє програмам Python викликати функції Python, які делегують роботу функціям C.</p></div>
<div class="paragraph"><p>Ще одне, приємніше рішення - автоматично генерувати код клею один раз для кожної функції, що експортується чи імпортується, за допомогою спеціального компілятора, який зчитує оригінальний підпис функції.</p></div>
<div class="paragraph"><p>Рішення, використовуване GLib, полягає у використанні бібліотеки GType, яка містить під час виконання опис усіх об'єктів, якими маніпулює програміст. Ця так звана бібліотека динамічного типу [1] потім використовується спеціальним загальним кодом клею для автоматичного перетворення параметрів функцій та умов виклику функцій між різними доменами часу виконання.</p></div>
<div class="paragraph"><p>Найбільша перевага рішення, реалізованого GType, полягає в тому, що код клею, що знаходиться на межах домену виконання, пишеться один раз: на малюнку нижче це позначено читкіше.</p></div>
<div class="imageblock">
<div class="content">
<img src="glue.png" alt="glue.png" />
</div>
</div>
<div class="paragraph"><p>В даний час існує принаймні загальний код клею Python та Perl, який дозволяє використовувати об'єкти C, написані GType безпосередньо в Python або Perl, з мінімальним обсягом роботи: немає необхідності генерувати величезну кількість коду клею або автоматично, або вручну.</p></div>
<div class="paragraph"><p>Хоча ця мета, мабуть, похвальна, її прагнення мало великий вплив на всю бібліотеку GType/GObject. Програмісти C, ймовірно, будуть спантеличені складністю функцій, викладених у наступних розділах, якщо вони забудуть, що бібліотека GType/GObject була розроблена не тільки для того, щоб запропонувати програмістам на C подібні функції, а й прозорої міжмовної сумісності.</p></div>
</div>
<div class="sect2">
<h3 id="____glib">Система динамічного типу GLib</h3>
<div class="paragraph"><p>Тип, маніпульований системою типів GLib, набагато загальніший, ніж те, що зазвичай розуміється як тип <code>Object</code>. Найкраще це пояснити, переглянувши структуру та функції, які використовуються для реєстрації нових типів у системі типів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GTypeInfo</span>               <span class="n">GTypeInfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">_GTypeInfo</span>
<span class="p">{</span>
  <span class="cm">/* інтерфейсні, класові типи, втілені типи */</span>
  <span class="n">guint16</span>                <span class="n">class_size</span><span class="p">;</span>

  <span class="n">GBaseInitFunc</span>          <span class="n">base_init</span><span class="p">;</span>
  <span class="n">GBaseFinalizeFunc</span>      <span class="n">base_finalize</span><span class="p">;</span>

  <span class="cm">/* класові типи, втілені типи */</span>
  <span class="n">GClassInitFunc</span>         <span class="n">class_init</span><span class="p">;</span>
  <span class="n">GClassFinalizeFunc</span>     <span class="n">class_finalize</span><span class="p">;</span>
  <span class="n">gconstpointer</span>          <span class="n">class_data</span><span class="p">;</span>

  <span class="cm">/* втілені типи */</span>
  <span class="n">guint16</span>                <span class="n">instance_size</span><span class="p">;</span>
  <span class="n">guint16</span>                <span class="n">n_preallocs</span><span class="p">;</span>
  <span class="n">GInstanceInitFunc</span>      <span class="n">instance_init</span><span class="p">;</span>

  <span class="cm">/* обробка значення */</span>
  <span class="k">const</span> <span class="n">GTypeValueTable</span> <span class="o">*</span><span class="n">value_table</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">GType</span> <span class="nf">g_type_register_static</span> <span class="p">(</span><span class="n">GType</span>             <span class="n">parent_type</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">gchar</span>      <span class="o">*</span><span class="n">type_name</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">GTypeInfo</span>  <span class="o">*</span><span class="n">info</span><span class="p">,</span>
                              <span class="n">GTypeFlags</span>        <span class="n">flags</span><span class="p">);</span>
<span class="n">GType</span> <span class="nf">g_type_register_fundamental</span> <span class="p">(</span><span class="n">GType</span>                       <span class="n">type_id</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">gchar</span>                <span class="o">*</span><span class="n">type_name</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">GTypeInfo</span>            <span class="o">*</span><span class="n">info</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">GTypeFundamentalInfo</span> <span class="o">*</span><span class="n">finfo</span><span class="p">,</span>
                                   <span class="n">GTypeFlags</span>                  <span class="n">flags</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p><code>g_type_register_static</code>,<code>g_type_register_dynamic</code> та <code>g_type_register_fundamental</code> - це функції C, визначені в <code>gtype.h</code> та реалізовані в <code>gtype.c</code>, які слід використовувати для реєстрації нового <code>GType</code> у системі типів програми. Ймовірно, вам ніколи не знадобиться використовувати <code>g_type_register_fundamental</code>, але у випадку, якщо ви цього хочете, в останній главі пояснено, як створити нові основні типи.</p></div>
<div class="paragraph"><p>Фундаментальні типи - це типи найвищого рівня, які не походять від будь-якого іншого типу, тоді як інші не фундаментальні типи походять від інших типів. Після ініціалізації система типів не тільки ініціалізує свої внутрішні структури даних, але й реєструє ряд основних типів: деякі з них є фундаментальними типами. Інші - це типи, похідні від цих основних типів.</p></div>
<div class="paragraph"><p>Фундаментальні та не фундаментальні типи визначаються:</p></div>
<div class="ulist"><ul>
<li>
<p>
розмір класу: поле <code>class_size</code> в <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
функції ініціалізації класу (конструктор C ++): поля <code>base_init</code> та <code>class_init</code> у <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
функції знищення класу (деструктор C ++): поля <code>base_finalize</code> та <code>class_finalize</code> у <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
розмір примірника (параметр C ++ до <code>new</code>): поле <code>instance_size</code> в <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
політика примірників (тип C ++ оператора <code>new</code>): поле <code>n_preallocs</code> у <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
функції копіювання (оператори копіювання C++): поле <code>value_table</code> у <code>GTypeInfo</code>.
</p>
</li>
<li>
<p>
прапорці характеристик типу: <code>GTypeFlags</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Fundamental types are also defined by a set of GTypeFundamentalFlags which are stored in a GTypeFundamentalInfo. Non-fundamental types are furthermore defined by the type of their parent which is passed as the parent_type parameter to g_type_register_static and g_type_register_dynamic.
Фундаментальні типи також визначаються набором <code>GTypeFundamentalFlags</code>, які зберігаються в <code>GTypeFundamentalInfo</code>. Крім того, не-фундаментальні типи визначаються типом їх батьківського типу, який передається як параметр <code>parent_type</code> в <code>g_type_register_static</code> та <code>g_type_register_dynamic</code>.</p></div>
</div>
<div class="sect2">
<h3 id="__">Функції копіювання</h3>
<div class="paragraph"><p>Основним спільним моментом між усіма типами GLib (фундаментальними та не фундаментальними, класифікованим та некласифікованим, уособлюваним та ні) є те, що всіма ними можна маніпулювати за допомогою одного API для їх копіювання/призначення.</p></div>
<div class="paragraph"><p>Структура <code>GValue</code> використовується як абстрактний контейнер для всіх цих типів. Його спрощений API (визначений у <code>gobject</code>/<code>gvalue.h</code>) може використовуватися для виклику функцій <code>value_table</code>, зареєстрованих під час реєстрації типу: наприклад, <code>g_value_copy</code> копіює вміст <code>GValue</code> в інший <code>GValue</code>. Це аналогічно призначенню C<code>, яке викликає оператор копіювання C</code> для зміни звичайної семантики біт-за-біт-копіювання за замовчуванням структур і класів C++/C.</p></div>
<div class="paragraph"><p>Наступний код показує, як можна скопіювати коло 64-бітного цілого числа, а також покажчика екземпляра <code>GObject</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">test_int</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GValue</span> <span class="n">a_value</span> <span class="o">=</span> <span class="n">G_VALUE_INIT</span><span class="p">;</span>
  <span class="n">GValue</span> <span class="n">b_value</span> <span class="o">=</span> <span class="n">G_VALUE_INIT</span><span class="p">;</span>
  <span class="n">guint64</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="mh">0xdeadbeef</span><span class="p">;</span>

  <span class="n">g_value_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span> <span class="n">G_TYPE_UINT64</span><span class="p">);</span>
  <span class="n">g_value_set_uint64</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="n">g_value_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b_value</span><span class="p">,</span> <span class="n">G_TYPE_UINT64</span><span class="p">);</span>
  <span class="n">g_value_copy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">a_value</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b_value</span><span class="p">);</span>

  <span class="n">b</span> <span class="o">=</span> <span class="n">g_value_get_uint64</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">b_value</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;Yay !! 10 lines of code to copy around a uint64.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;Are you sure this is not a Z80 ?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">test_object</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
  <span class="n">GValue</span> <span class="n">obj_vala</span> <span class="o">=</span> <span class="n">G_VALUE_INIT</span><span class="p">;</span>
  <span class="n">GValue</span> <span class="n">obj_valb</span> <span class="o">=</span> <span class="n">G_VALUE_INIT</span><span class="p">;</span>
  <span class="n">obj</span> <span class="o">=</span> <span class="n">g_object_new</span> <span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">g_value_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span> <span class="n">VIEWER_TYPE_FILE</span><span class="p">);</span>
  <span class="n">g_value_set_object</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>

  <span class="n">g_value_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj_valb</span><span class="p">,</span> <span class="n">G_TYPE_OBJECT</span><span class="p">);</span>

  <span class="cm">/* Семантика g_value_copy для типів G_TYPE_OBJECT є копіювання посилання.</span>
<span class="cm">   * Таким чином ця функція викликає g_object_ref.</span>
<span class="cm">   * Цікаво зауважити, що призначення тут працює, оскільки</span>
<span class="cm">   * VIEWER_TYPE_FILE є G_TYPE_OBJECT.</span>
<span class="cm">   */</span>
  <span class="n">g_value_copy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">obj_vala</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_valb</span><span class="p">);</span>

  <span class="n">g_object_unref</span> <span class="p">(</span><span class="n">G_OBJECT</span> <span class="p">(</span><span class="n">obj</span><span class="p">));</span>
  <span class="n">g_object_unref</span> <span class="p">(</span><span class="n">G_OBJECT</span> <span class="p">(</span><span class="n">obj</span><span class="p">));</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Важливим моментом щодо вищезазначеного коду є те, що точна семантика викликів копіювання не визначена, оскільки вони залежать від реалізації функції копіювання. Деякі функції копіювання можуть вирішити виділити новий фрагмент пам'яті, а потім скопіювати дані з джерела до місця призначення. Інші, можливо, хочуть просто збільшити кількість посилань на екземпляр і скопіювати посилання на новий <code>GValue</code>.</p></div>
<div class="paragraph"><p>Таблиця значень, яка використовується для визначення цих функцій призначення, задокументована у <code>GTypeValueTable</code>.</p></div>
<div class="paragraph"><p>Цікаво, що також малоймовірно, що вам коли-небудь потрібно буде вказати таблицю <code>value_able</code> під час реєстрації типу, оскільки ці <code>value_table</code> успадковуються від батьківських типів для нефундаментальних типів.</p></div>
</div>
<div class="sect2">
<h3 id="__3">Домовленості</h3>
<div class="paragraph"><p>Очікується, що користувачі повинні дотримуватися під час створення нових типів, які потрібно експортувати у файл заголовка:</p></div>
<div class="ulist"><ul>
<li>
<p>
Імена типів (включаючи назви об’єктів) повинні бути не менше трьох символів і починатись з «a – z», «A – Z» або «_».
</p>
</li>
<li>
<p>
Використовуйте шаблон <code>object_method</code> для імен функцій: для виклику методу з ім'ям збереження у екземплярі файлу типу об’єкта, викличте <code>file_save</code>.
</p>
</li>
<li>
<p>
Використовуйте префікси, щоб уникнути конфліктів у просторі імен з іншими проектами. Якщо ваша бібліотека (або додаток) названа <code>Viewer</code>, приставте до всіх імен функцій <code>viewer_</code>. Наприклад: <code>viewer_object_method</code>.
</p>
</li>
<li>
<p>
Створіть макрос з назвою <code>PREFIX_TYPE_OBJECT</code>, який завжди повертає <code>GType</code> для пов'язаного типу об'єкта. Для об’єкта типу <code>File</code> у просторі імен <code>Viewer</code> використовуйте: <code>VIEWER_TYPE_FILE</code>. Цей макрос реалізований за допомогою функції з назвою <code>prefix_object_get_type;</code> наприклад, <code>viewer_file_get_type</code>.
</p>
</li>
<li>
<p>
Використовуйте <code>G_DECLARE_FINAL_TYPE</code> або <code>G_DECLARE_DERIVABLE_TYPE</code> для визначення різних інших звичайних макросів для вашого об'єкта:
</p>
<div class="ulist"><ul>
<li>
<p>
<code>PREFIX_OBJECT (obj)</code>, який повертає вказівник типу <code>PrefixObject</code>. Цей макрос використовується для забезпечення безпеки статичного типу, виконуючи явні касти, де це необхідно. Він також забезпечує безпеку динамічного типу, роблячи перевірку часу виконання. Можливо відключити перевірку динамічного типу у виробничих побудовах (див. побудова GLib). Наприклад, ми створимо <code>VIEWER_FILE (obj)</code>, щоб проілюструвати попередній приклад.
</p>
</li>
<li>
<p>
<code>PREFIX_OBJECT_CLASS (klass)</code>, який суворо еквівалентний попередньому макросу кастингу: він робить статичний кастинг із динамічною перевіркою типів класових структур. Очікується повернути вказівник на структуру класу типу <code>PrefixObjectClass</code>. Приклад: <code>VIEWER_FILE_CLASS</code>.
</p>
</li>
<li>
<p>
<code>PREFIX_IS_OBJECT (obj)</code>, який повертає <code>gboolean</code>, який вказує, чи вказівник екземпляра об'єкта введення не <code>NULL</code> та типу <code>OBJECT</code>. Наприклад, <code>VIEWER_IS_FILE</code>.
</p>
</li>
<li>
<p>
<code>PREFIX_IS_OBJECT_CLASS (klass)</code>, який повертає булеве значення, якщо вказівник класу введення є вказівником на клас типу <code>OBJECT</code>. Наприклад, <code>VIEWER_IS_FILE_CLASS</code>.
</p>
</li>
<li>
<p>
<code>PREFIX_OBJECT_GET_CLASS (obj)</code>, який повертає вказівник класу, пов'язаний з екземпляром даного типу. Цей макрос використовується для безпеки статичного та динамічного типу (як і попередні макроси кастингу). Наприклад, <code>VIEWER_FILE_GET_CLASS</code>.
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>Реалізація цих макросів досить проста: в <code>gtype.h</code> надано ряд простих у користуванні макросів. Для прикладу, який ми використовували вище, ми напишемо наступний тривіальний код для оголошення макросів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type ()</span>
<span class="n">G_DECLARE_FINAL_TYPE</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span> <span class="n">viewer_file</span><span class="p">,</span> <span class="n">VIEWER</span><span class="p">,</span> <span class="kt">FILE</span><span class="p">,</span> <span class="n">GObject</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ваш код не має особливих вимог, ви можете використовувати макрос <code>G_DEFINE_TYPE</code> для визначення класу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">G_DEFINE_TYPE</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span> <span class="n">viewer_file</span><span class="p">,</span> <span class="n">G_TYPE_OBJECT</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>В іншому випадку функція <code>viewer_file_get_type</code> повинна бути реалізована вручну:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">GType</span> <span class="nf">viewer_file_get_type</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">GType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">GTypeInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* Ви заповнюєте цю структуру. */</span>
    <span class="p">};</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">g_type_register_static</span> <span class="p">(</span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
                                   <span class="s">&quot;ViewerFile&quot;</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____2">Неуособлювюані некласифіковані фундаментальні типи</h3>
<div class="paragraph"><p>Багато типів не призначені для створення примірників системою типів і не мають класу. Більшість із цих типів є фундаментальними тривіальними типами, такими як <code>gchar</code>, і вже зареєстровані GLib.</p></div>
<div class="paragraph"><p>In the rare case of needing to register such a type in the type system, fill a GTypeInfo structure with zeros since these types are also most of the time fundamental:
У рідкісному випадку, коли потрібно зареєструвати такий тип у системі типів, заповніть структуру <code>GTypeInfo</code> нулями, оскільки ці типи також більшість часу є фундаментальними:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">GTypeInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mi">0</span><span class="p">,</span>                           <span class="cm">/* class_size */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* base_init */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* base_destroy */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* class_init */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* class_destroy */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* class_data */</span>
  <span class="mi">0</span><span class="p">,</span>                           <span class="cm">/* instance_size */</span>
  <span class="mi">0</span><span class="p">,</span>                           <span class="cm">/* n_preallocs */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* instance_init */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* value_table */</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">GTypeValueTable</span> <span class="n">value_table</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">value_init_long0</span><span class="p">,</span>            <span class="cm">/* value_init */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* value_free */</span>
  <span class="n">value_copy_long0</span><span class="p">,</span>            <span class="cm">/* value_copy */</span>
  <span class="nb">NULL</span><span class="p">,</span>                        <span class="cm">/* value_peek_pointer */</span>
  <span class="s">&quot;i&quot;</span><span class="p">,</span>                         <span class="cm">/* collect_format */</span>
  <span class="n">value_collect_int</span><span class="p">,</span>           <span class="cm">/* collect_value */</span>
  <span class="s">&quot;p&quot;</span><span class="p">,</span>                         <span class="cm">/* lcopy_format */</span>
  <span class="n">value_lcopy_char</span><span class="p">,</span>            <span class="cm">/* lcopy_value */</span>
<span class="p">};</span>
<span class="n">info</span><span class="p">.</span><span class="n">value_table</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">value_table</span><span class="p">;</span>
<span class="n">type</span> <span class="o">=</span> <span class="n">g_type_register_fundamental</span> <span class="p">(</span><span class="n">G_TYPE_CHAR</span><span class="p">,</span> <span class="s">&quot;gchar&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">finfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Наявність неуособлюваних типів може здатися трохи марним: що гарного в типі, якщо ви не можете створити екземпляр цього типу? Більшість із цих типів використовуються спільно з <code>GValues</code>: <code>GValue</code> ініціалізується цілим чи рядком і передається кудись, використовуючи <code>value_table</code> зареєстрованого типу. <code>GValues</code> ​​(і поширюючи ці тривіальні фундаментальні типи) є найбільш корисними, коли вони використовуються в поєднанні з властивостями об'єктів і сигналами.</p></div>
</div>
<div class="sect2">
<h3 id="_____">Уособлювані класифіковані типи: об'єкти</h3>
<div class="paragraph"><p>Цей розділ охоплює теорію позаду об'єктів. Див. розділ Як визначити та реалізувати новий GObject для рекомендованого способу визначення <code>GObject</code>.</p></div>
<div class="paragraph"><p>Типи, які зареєстровані в класі та оголошені уособлюваними, - це те, що найбільше нагадує об'єкт. Хоча <code>GObject</code> (докладно описаний в базовому класі <code>GObject</code>) є найбільш добре відомим типом інстанціюємих класифікованих типів, інші види подібних об'єктів, що використовуються в якості основи ієрархії успадкування, були зовні розроблені і всі вони побудовані на основних рисах описані нижче.</p></div>
<div class="paragraph"><p>Наприклад, наведений нижче код показує, як ви можете зареєструвати такий фундаментальний об'єктний тип в системі типів (не використовуючи жоден API зручності <code>GObject</code>):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">GObject</span> <span class="n">parent</span><span class="p">;</span>

  <span class="cm">/* члени екземпляра */</span>
  <span class="n">gchar</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
<span class="p">}</span> <span class="n">ViewerFile</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">GObjectClass</span> <span class="n">parent</span><span class="p">;</span>

  <span class="cm">/* члени класу */</span>
  <span class="cm">/* перший - публічний, чистий і віртуальний */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span>  <span class="p">(</span><span class="n">ViewerFile</span>  <span class="o">*</span><span class="n">self</span><span class="p">,</span>
                 <span class="n">GError</span>     <span class="o">**</span><span class="n">error</span><span class="p">);</span>

  <span class="cm">/* другий - загальнодоступний і віртуальний */</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">close</span><span class="p">)</span> <span class="p">(</span><span class="n">ViewerFile</span>  <span class="o">*</span><span class="n">self</span><span class="p">,</span>
                 <span class="n">GError</span>     <span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="p">}</span> <span class="n">ViewerFileClass</span><span class="p">;</span>

<span class="cp">#define VIEWER_TYPE_FILE (viewer_file_get_type ())</span>

<span class="n">GType</span>
<span class="nf">viewer_file_get_type</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">GType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">GTypeInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="k">sizeof</span> <span class="p">(</span><span class="n">ViewerFileClass</span><span class="p">),</span>
      <span class="nb">NULL</span><span class="p">,</span>           <span class="cm">/* base_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>           <span class="cm">/* base_finalize */</span>
      <span class="p">(</span><span class="n">GClassInitFunc</span><span class="p">)</span> <span class="n">viewer_file_class_init</span><span class="p">,</span>
      <span class="nb">NULL</span><span class="p">,</span>           <span class="cm">/* class_finalize */</span>
      <span class="nb">NULL</span><span class="p">,</span>           <span class="cm">/* class_data */</span>
      <span class="k">sizeof</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">),</span>
      <span class="mi">0</span><span class="p">,</span>              <span class="cm">/* n_preallocs */</span>
      <span class="p">(</span><span class="n">GInstanceInitFunc</span><span class="p">)</span> <span class="nb">NULL</span> <span class="cm">/* instance_init */</span>
    <span class="p">};</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">g_type_register_static</span> <span class="p">(</span><span class="n">G_TYPE_OBJECT</span><span class="p">,</span>
                                   <span class="s">&quot;ViewerFile&quot;</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Після першого виклику <code>viewer_file_get_type</code> тип з назвою <code>ViewerFile</code> буде зареєстрований у системі типів як спадковий від типу <code>G_TYPE_OBJECT</code>.</p></div>
<div class="paragraph"><p>Кожен об'єкт повинен визначати дві структури: його структуру класу та структуру екземпляра. Усі структури класу повинні містити як перший член структуру GTypeClass. Усі структури примірника повинні містити як перший член структуру GTypeInstance. Декларація цих типів C, що надходить із <code>gtype.h</code>, показана нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_GTypeClass</span>
<span class="p">{</span>
  <span class="n">GType</span> <span class="n">g_type</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="n">_GTypeInstance</span>
<span class="p">{</span>
  <span class="n">GTypeClass</span> <span class="o">*</span><span class="n">g_class</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці обмеження дозволяють системі типів переконатися, що кожен екземпляр об'єкта (ідентифікований вказівником на структуру екземпляра об'єкта) містить у своїх перших байтах вказівник на структуру класу об'єкта.</p></div>
<div class="paragraph"><p>Цей взаємозв'язок найкраще пояснюється прикладом: візьмемо об'єкт <code>B</code>, який успадковується від об'єкта <code>A</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cm">/* Визначення A */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">GTypeInstance</span> <span class="n">parent</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">field_a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">field_b</span><span class="p">;</span>
<span class="p">}</span> <span class="n">A</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">GTypeClass</span> <span class="n">parent_class</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">method_a</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">method_b</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span> <span class="n">AClass</span><span class="p">;</span>

<span class="cm">/* визначення B */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">A</span> <span class="n">parent</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">field_c</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">field_d</span><span class="p">;</span>
<span class="p">}</span> <span class="n">B</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
  <span class="n">AClass</span> <span class="n">parent_class</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">method_c</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">method_d</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">}</span> <span class="n">BClass</span><span class="p">;</span>
</pre></div></div></div>
<div class="paragraph"><p>Стандарт C наказує, що перше поле структури С зберігається починаючи з першого байту буфера, який використовується для зберігання полів структури в пам'яті. Це означає, що перше поле екземпляра об'єкта <code>B</code> - це перше поле <code>A</code>, що, в свою чергу, є першим полем <code>GTypeInstance</code>, що, в свою чергу, є <code>g_class</code>, вказівником на структуру класу <code>B</code>.</p></div>
<div class="paragraph"><p>Завдяки цим простим умовам можна виявити тип кожного екземпляра об'єкта, виконавши:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="n">b</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">g_class</span><span class="o">-&gt;</span><span class="n">g_type</span>
</pre></div></div></div>
<div class="paragraph"><p>або, швидше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">B</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">((</span><span class="n">GTypeInstance</span> <span class="o">*</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">g_class</span><span class="o">-&gt;</span><span class="n">g_type</span>
</pre></div></div></div>
<div class="sect3">
<h4 id="___">Ініціалізація та знищення</h4>
<div class="paragraph"><p>Створення примірників цих типів може бути виконано за допомогою <code>g_type_create_instance</code>, яка буде шукати структуру інформації про тип, пов'язану з запитуваним типом. Тоді розмір екземпляра та політика копіювання (якщо для поля <code>n_preallocs</code> встановлено ненульове значення, система типів виділяє структури екземпляра об'єкта шматками, а не робить <code>malloc</code> для кожного екземпляра), оголошені користувачем, використовуються для отримання буфера для утримування структури екземпляра об'єкта.</p></div>
<div class="paragraph"><p>Якщо це перший екземпляр об'єкта, який коли-небудь створений, система типів повинна створити структуру класу. Він виділяє буфер для зберігання структури класу об'єкта та ініціалізує його. Перша частина структури класу (тобто вбудована структура батьківського класу) ініціалізується шляхом копіювання вмісту з структури класів батьківського класу. Решта структури класу ініціалізується до нуля. Якщо немає батьків, вся структура класу ініціалізується нулями. Потім система типів викликає функції <code>base_class_initialization</code> (<code>GBaseInitFunc</code>) від найголовнішого фундаментального об'єкта до самого найбільш похідного об'єкта. Після цього викликається функція <code>class_init</code> об'єкта (<code>GClassInitFunc</code>) для завершення ініціалізації структури класу. Нарешті, інтерфейси ініціалізуються об'єкта (про ініціалізацію інтерфейсу ми поговоримо більш детально пізніше).</p></div>
<div class="paragraph"><p>Після того, як система типів має вказівник на ініціалізовану структуру класів, вона встановлює вказівник класу об'єкта на структуру класу об'єкта та викликає функції <code>instance_init</code> (<code>GInstanceInitFunc</code>) об'єкта від найфундаментальнішого типу до найбільш похідного типу.</p></div>
<div class="paragraph"><p>Знищення примірника об'єкта через <code>g_type_free_instance</code> дуже просте: структура екземпляра повертається до пулу екземплярів, якщо такий є, і якщо це був останній живий екземпляр об'єкта, клас знищується.</p></div>
<div class="paragraph"><p>Руйнування класів (поняття знищення іноді частково називають фіналізацією у <code>GType</code>) - це симетричний процес ініціалізації: спочатку знищуються інтерфейси. Тоді викликається найбільш похідна функція <code>class_finalize</code> (<code>GClassFinalizeFunc</code>). Нарешті, викликаються функції <code>base_class_finalize</code> (<code>GBaseFinalizeFunc</code>) від найнижчого похідного типу до самого фундаментального типу, і структура класу звільняється.</p></div>
<div class="paragraph"><p>Процес базових ініціалізації/завершення дуже схожий на парадигму конструктора/деструктора C<code>. Практичні деталі, проте, різні, і важливо не плутати поверхневі подібності. <code>GType</code> не мають механізму знищення примірників. Відповідальність користувача є впровадити правильну семантику знищення поверх існуючого коду <code>GType</code>. (Це те, що робить <code>GObject</code>: див. Базовий клас <code>GObject</code>). Крім того, код C</code>, еквівалентний зворотним викликам <code>base_init</code> та <code>class_init</code> <code>GType</code>, як правило, не потрібен, оскільки C ++ насправді не може створювати типи об'єктів під час виконання.</p></div>
<div class="paragraph"><p>Процес інстанції/фіналізації можна узагальнити так:</p></div>
<div class="ulist"><div class="title">Таблиця 1. Створення примірника/фіналізація GType</div><ul>
<li>
<p>
Перший виклик <code>g_type_create_instance</code> для цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
<code>base_init</code> типу на дереві спадкування класів від основного типу до цільового типу. <code>base_init</code> викликається один раз для кожної структури класу.
</p>
</li>
<li>
<p>
<code>class_init</code> цільового типу на структурі класу цільового типу
</p>
</li>
<li>
<p>
ініціалізація інтерфейсу, див. розділ "Ініціалізація інтерфейсу"
</p>
</li>
</ul></div>
</li>
<li>
<p>
Кожен виклик <code>g_type_create_insubstance</code> для цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
<code>instance_init</code> на екземплярі об'єкта
</p>
</li>
</ul></div>
</li>
<li>
<p>
Останній виклик <code>g_type_free_insubstance</code> для цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
руйнування інтерфейсу. див. У розділі "Знищення інтерфейсу"
</p>
</li>
<li>
<p>
<code>class_finalize</code> цільового типу на структурі класів цільового типу
</p>
</li>
<li>
<p>
<code>base_finalize</code> на дереві спадкування класів від основного типу до цільового типу. <code>base_finalize</code> викликається один раз для кожної структури класу.
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="_____3">Неуособлювані класифіковані типи: інтерфейси</h3>
<div class="paragraph"><p>Цей розділ охоплює теорію інтерфейсів. Див. Розділ Як визначити та реалізувати інтерфейси для рекомендованого способу визначення інтерфейсу.</p></div>
<div class="paragraph"><p>Інтерфейси GType дуже схожі на інтерфейси Java. Вони дозволяють описати загальний API, якого дотримуватимуться кілька класів. Уявіть, що кнопки відтворення, паузи та зупинки на обладнання hi-fi - вони можуть сприйматися як інтерфейс відтворення. Коли ви дізнаєтеся, як вони роблять, ви можете керувати своїм CD-програвачем, MP3-програвачем або будь-яким, що використовує ці символи. Для оголошення інтерфейсу необхідно зареєструвати класифікований тип, який не створює примірників, який походить від <code>GTypeInterface</code>. Наступний фрагмент коду проголошує такий інтерфейс.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#define VIEWER_TYPE_EDITABLE viewer_editable_get_type ()</span>
<span class="n">G_DECLARE_INTERFACE</span> <span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span> <span class="n">viewer_editable</span><span class="p">,</span> <span class="n">VIEWER</span><span class="p">,</span> <span class="n">EDITABLE</span><span class="p">,</span> <span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span> <span class="n">_ViewerEditableInterface</span> <span class="p">{</span>
  <span class="n">GTypeInterface</span> <span class="n">parent</span><span class="p">;</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">save</span><span class="p">)</span> <span class="p">(</span><span class="n">ViewerEditable</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">viewer_editable_save</span> <span class="p">(</span><span class="n">ViewerEditable</span>  <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Функція інтерфейсу <code>viewer_editable_save</code> реалізована досить просто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">viewer_editable_save</span> <span class="p">(</span><span class="n">ViewerEditable</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span> <span class="n">GError</span> <span class="o">**</span><span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ViewerEditableinterface</span> <span class="o">*</span><span class="n">iface</span><span class="p">;</span>

  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">VIEWER_IS_EDITABLE</span> <span class="p">(</span><span class="n">self</span><span class="p">));</span>
  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="o">*</span><span class="n">error</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

  <span class="n">iface</span> <span class="o">=</span> <span class="n">VIEWER_EDITABLE_GET_IFACE</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>
  <span class="n">g_return_if_fail</span> <span class="p">(</span><span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span> <span class="p">(</span><span class="n">self</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>viewer_editable_get_type</code> реєструє тип з назвою <code>ViewerEditable</code>, який успадковується від <code>G_TYPE_INTERFACE</code>. Усі інтерфейси повинні бути дітьми <code>G_TYPE_INTERFACE</code> у дереві спадкування.</p></div>
<div class="paragraph"><p>Інтерфейс визначається лише однією структурою, яка повинна містити як перший член структуру <code>GTypeInterface</code>. Очікується, що структура інтерфейсу містить функціональні покажчики методів інтерфейсу. Добрим стилем є визначення допоміжних функцій для кожного з методів інтерфейсу, який просто викликає метод інтерфейсу безпосередньо: <code>viewer_editable_save</code> - одна із них.</p></div>
<div class="paragraph"><p>Якщо у вас немає особливих вимог, ви можете використовувати макрос <code>G_IMPLEMENT_INTERFACE</code> для реалізації інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_save</span> <span class="p">(</span><span class="n">ViewerEditable</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;File implementation of editable interface save method.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span> <span class="p">(</span><span class="n">ViewerEditableInterface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span> <span class="o">=</span> <span class="n">viewer_file_save</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">G_DEFINE_TYPE_WITH_CODE</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span> <span class="n">viewer_file</span><span class="p">,</span> <span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
                         <span class="n">G_IMPLEMENT_INTERFACE</span> <span class="p">(</span><span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
                                                <span class="n">viewer_file_editable_interface_init</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ваш код має особливі вимоги, ви повинні написати спеціальну функцію <code>get_type</code>, щоб зареєструвати свій <code>GType</code>, який успадковується від деякого <code>GObject</code> і реалізує інтерфейс <code>ViewerEditable</code>. Наприклад, цей код реєструє новий клас <code>ViewerFile</code>, який реалізує <code>ViewerEditable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_save</span> <span class="p">(</span><span class="n">ViewerEditable</span> <span class="o">*</span><span class="n">editable</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;File implementation of editable interface save method.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_editable_interface_init</span> <span class="p">(</span><span class="n">gpointer</span> <span class="n">g_iface</span><span class="p">,</span>
                                     <span class="n">gpointer</span> <span class="n">iface_data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ViewerEditableInterface</span> <span class="o">*</span><span class="n">iface</span> <span class="o">=</span> <span class="n">g_iface</span><span class="p">;</span>

  <span class="n">iface</span><span class="o">-&gt;</span><span class="n">save</span> <span class="o">=</span> <span class="n">viewer_file_save</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">GType</span>
<span class="nf">viewer_file_get_type</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="n">GType</span> <span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">GTypeInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="k">sizeof</span> <span class="p">(</span><span class="n">ViewerFileClass</span><span class="p">),</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* base_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* base_finalize */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* class_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* class_finalize */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* class_data */</span>
      <span class="k">sizeof</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">),</span>
      <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* n_preallocs */</span>
      <span class="nb">NULL</span>    <span class="cm">/* instance_init */</span>
    <span class="p">};</span>
    <span class="k">const</span> <span class="n">GInterfaceInfo</span> <span class="n">editable_info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">(</span><span class="n">GInterfaceInitFunc</span><span class="p">)</span> <span class="n">viewer_file_editable_interface_init</span><span class="p">,</span>  <span class="cm">/* interface_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* interface_finalize */</span>
      <span class="nb">NULL</span>    <span class="cm">/* interface_data */</span>
    <span class="p">};</span>
    <span class="n">type</span> <span class="o">=</span> <span class="n">g_type_register_static</span> <span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span>
                                   <span class="s">&quot;ViewerFile&quot;</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">g_type_add_interface_static</span> <span class="p">(</span><span class="n">type</span><span class="p">,</span>
                                 <span class="n">VIEWER_TYPE_EDITABLE</span><span class="p">,</span>
                                 <span class="o">&amp;</span><span class="n">editable_info</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>g_type_add_interface_static records in the type system that a given type implements also FooInterface (foo_interface_get_type returns the type of FooInterface). The GInterfaceInfo structure holds information about the implementation of the interface:
<code>g_type_add_interface_static</code> записує в системі типів, що даний тип реалізує також FooInterfa`c`e (<code>foo_interface_get_type</code> повертає тип <code>FooInterface</code>). Структура <code>GInterfaceInfo</code> містить інформацію про реалізацію інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">_GInterfaceInfo</span>
<span class="p">{</span>
  <span class="n">GInterfaceInitFunc</span>     <span class="n">interface_init</span><span class="p">;</span>
  <span class="n">GInterfaceFinalizeFunc</span> <span class="n">interface_finalize</span><span class="p">;</span>
  <span class="n">gpointer</span>               <span class="n">interface_data</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></div></div>
<div class="sect3">
<h4 id="___2">Ініціалізація інтерфейсу</h4>
<div class="paragraph"><p>Коли вперше створюється класифікований тип, який реалізує інтерфейс (або безпосередньо, або успадковуючи реалізацію від надкласу), його структура класу ініціалізується за процесом, описаним у розділі, що називається "Уособлювані класифіковані типи: об'єкти". Після цього реалізації інтерфейсу, пов'язані з типом, ініціалізуються.</p></div>
<div class="paragraph"><p>Спочатку виділяється буфер пам'яті для зберігання структури інтерфейсу. Потім структура інтерфейсу батьків копіюється в нову структуру інтерфейсу (батьківський інтерфейс вже ініціалізований в цій точці). Якщо батьківського інтерфейсу немає, структура інтерфейсу ініціалізується нулями. Потім ініціалізуються поля <code>g_type</code> та <code>g_instance_type</code>: <code>g_type</code> встановлюється до типу найбільш похідного інтерфейсу, а <code>g_instan_type</code> - до типу найбільш похідного типу, який реалізує цей інтерфейс.</p></div>
<div class="paragraph"><p>Викликається функція <code>base_init</code> інтерфейсу, після чого викликається <code>default_init</code> інтерфейсу. Нарешті, якщо тип зареєстрував реалізацію інтерфейсу, викликається функція <code>interface_init</code> реалізації. Якщо є кілька реалізацій інтерфейсу, функції <code>base_init</code> та <code>interface_init</code> будуть викликатися один раз для кожної ініціалізації реалізації.</p></div>
<div class="paragraph"><p>Тому рекомендується використовувати функцію <code>default_init</code> для ініціалізації інтерфейсу. Ця функція викликається лише один раз для інтерфейсу незалежно від кількості реалізацій. Функція <code>default_init</code> оголошена <code>G_DEFINE_INTERFACE</code>, яка може бути використана для визначення інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">G_DEFINE_INTERFACE</span> <span class="p">(</span><span class="n">ViewerEditable</span><span class="p">,</span> <span class="n">viewer_editable</span><span class="p">,</span> <span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">viewer_editable_default_init</span> <span class="p">(</span><span class="n">ViewerEditableInterface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* додайте тут властивості та сигнали, буде викликано лише один раз */</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Або ви можете зробити це самостійно у функції <code>GType</code> для вашого інтерфейсу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">GType</span> <span class="nf">viewer_editable_get_type</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="k">volatile</span> <span class="n">gsize</span> <span class="n">type_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">g_once_init_enter</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">type_id</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">GTypeInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="p">{</span>
      <span class="k">sizeof</span> <span class="p">(</span><span class="n">ViewerEditableInterface</span><span class="p">),</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* base_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* base_finalize */</span>
      <span class="n">viewer_editable_default_init</span><span class="p">,</span> <span class="cm">/* class_init */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* class_finalize */</span>
      <span class="nb">NULL</span><span class="p">,</span>   <span class="cm">/* class_data */</span>
      <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* instance_size */</span>
      <span class="mi">0</span><span class="p">,</span>      <span class="cm">/* n_preallocs */</span>
      <span class="nb">NULL</span>    <span class="cm">/* instance_init */</span>
    <span class="p">};</span>
    <span class="n">GType</span> <span class="n">type</span> <span class="o">=</span> <span class="n">g_type_register_static</span> <span class="p">(</span><span class="n">G_TYPE_INTERFACE</span><span class="p">,</span>
                                         <span class="s">&quot;ViewerEditable&quot;</span><span class="p">,</span>
                                         <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">g_once_init_leave</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">type_id</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">type_id</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_editable_default_init</span> <span class="p">(</span><span class="n">ViewerEditableInterface</span> <span class="o">*</span><span class="n">iface</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* додайте сюди властивості та сигнали, буде викликатися лише один раз */</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Підсумовуючи, ініціалізація інтерфейсу використовує такі функції:</p></div>
<div class="ulist"><div class="title">Таблиця 2. Ініціалізація інтерфейсу</div><ul>
<li>
<p>
Перший виклик <code>g_type_create_instance</code> для будь-якого типу, що реалізує інтерфейс, функція <code>base_init</code>. Вкрай необхідний для використання. Викликається один раз за оригінальним класифікованим типом, що реалізує інтерфейс.
</p>
</li>
<li>
<p>
Перший виклик <code>g_type_create_instance</code> для кожного типу, що реалізує функцію інтерфейсу <code>default_init</code>. Тут ви можете зареєструвати сигнали, властивості інтерфейсу <code>vtable</code>. Буде викликано один раз.
</p>
</li>
<li>
<p>
Перший виклик <code>g_type_create_instance</code> для будь-якого типу, що реалізує функцію інтерфейсу реалізації <code>interface_init</code>. Викликається для кожного класу, який реалізує інтерфейс. Ініціалізуйте покажчики методу інтерфейсу в структурі інтерфейсу до реалізації класу реалізації.
</p>
<div class="ulist"><ul>
<li>
<p>
Знищення інтерфейсу
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>Коли останній примірник уособлюваного типу, який зареєстрував реалізацію інтерфейсу, знищений, реалізації інтерфейсу, пов'язані з типом, знищуються.</p></div>
<div class="paragraph"><p>Щоб знищити реалізацію інтерфейсу, <code>GType</code> спочатку викликає функцію <code>interface_finalize</code> реалізації, а потім найбільш похідну функцію <code>base_finalize</code> інтерфейсу.</p></div>
<div class="paragraph"><p>Знову, важливо розуміти, як у розділі "Ініціалізація інтерфейсу", що і <code>interface_finalize</code>, і <code>base_finalize</code> викликаються рівно один раз для знищення кожної реалізації інтерфейсу. Таким чином, якби ви використовували одну з цих функцій, вам потрібно було б використовувати статичну змінну цілого числа, яка містила б кількість екземплярів реалізації інтерфейсу таким чином, що клас інтерфейсу знищується лише один раз (коли ціла змінна досягає нуля) .</p></div>
<div class="paragraph"><p>Наведений вище процес можна узагальнити так:</p></div>
<div class="ulist"><div class="title">Таблиця 3. Фіналізація інтерфейсу</div><ul>
<li>
<p>
Останній виклик <code>g_type_free_instance</code> для типу, що реалізує функцію інтерфейсу
</p>
<div class="ulist"><ul>
<li>
<p>
<code>interface_finalize</code> на vtable інтерфейсу
</p>
</li>
<li>
<p>
<code>base_finalize</code> на vtable інтерфейсу
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___gobject">Базовий клас GObject</h2>
<div class="sectionbody">
<div class="paragraph"><p>У попередньому розділі обговорювались деталі системи динамічної системи типів GLib. Бібліотека GObject також містить реалізацію для базового фундаментального типу з назвою GObject.</p></div>
<div class="paragraph"><p>GObject - це фундаментальний класифікований уособлюваний тип. Він реалізує:</p></div>
<div class="ulist"><ul>
<li>
<p>
Управління пам'яттю з підрахунком посилань
</p>
</li>
<li>
<p>
Будівництво / Знищення екземплярів
</p>
</li>
<li>
<p>
Загальні властивості для кожного об'єкта з парами функцій set/get
</p>
</li>
<li>
<p>
Простота використання сигналів
</p>
</li>
</ul></div>
<div class="paragraph"><p>Усі бібліотеки GNOME, які використовують систему типу GLib (як GTK + та GStreamer), успадковують <code>GObject</code>, тому важливо зрозуміти деталі того, як вона працює.</p></div>
<div class="sect2">
<h3 id="_____4">Створення екземпляру об'єкта</h3>
<div class="paragraph"><p>The g_object_new family of functions can be used to instantiate any GType which inherits from the GObject base type. All these functions make sure the class and instance structures have been correctly initialized by GLib&#8217;s type system and then invoke at one point or another the constructor class method which is used to:
Сімейство функцій <code>g_object_new</code> може використовуватися для створення будь-якого <code>GType</code>, який успадковується від базового типу <code>GObject</code>. Усі ці функції гарантують, що структури класів та екземплярів були правильно ініціалізовані системою типів <code>GLib</code>, а потім викликають в тій чи іншій точці метод класу конструктора, який використовується для:</p></div>
<div class="ulist"><ul>
<li>
<p>
Виділення та очистку пам’яті за допомогою <code>g_type_create_instance</code>,
</p>
</li>
<li>
<p>
Ініціалізації екземпляра об'єкта за допомогою властивостей конструкції.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Хоча можна очікувати, що для всіх членів класу та екземпляра (крім полів, що вказують на батьків) буде встановлено нуль, деякі вважають, що це добре встановити їх явно.</p></div>
<div class="paragraph"><p>Після завершення всіх операцій конструювання та встановлення властивостей конструктора викликається метод <code>constructed</code> побудованого класу.</p></div>
<div class="paragraph"><p>Objects which inherit from GObject are allowed to override this constructed class method. The example below shows how ViewerFile overrides the parent&#8217;s construction process:
Об'єкти, успадковані від <code>GObject</code>, дозволяють перевизначити цей метод <code>constructed</code> класу. Наведений нижче приклад показує, як <code>ViewerFile</code> перевизначає процес побудови батьків:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cp">#define VIEWER_TYPE_FILE viewer_file_get_type ()</span>
<span class="n">G_DECLARE_FINAL_TYPE</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span> <span class="n">viewer_file</span><span class="p">,</span> <span class="n">VIEWER</span><span class="p">,</span> <span class="kt">FILE</span><span class="p">,</span> <span class="n">GObject</span><span class="p">)</span>

<span class="k">struct</span> <span class="n">_ViewerFile</span>
<span class="p">{</span>
  <span class="n">GObject</span> <span class="n">parent_instance</span><span class="p">;</span>

  <span class="cm">/* instance members */</span>
  <span class="n">gchar</span> <span class="o">*</span><span class="n">filename</span><span class="p">;</span>
  <span class="n">guint</span> <span class="n">zoom_level</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* створить viewer_file_get_type і встановить viewer_file_parent_class */</span>
<span class="n">G_DEFINE_TYPE</span> <span class="p">(</span><span class="n">ViewerFile</span><span class="p">,</span> <span class="n">viewer_file</span><span class="p">,</span> <span class="n">G_TYPE_OBJECT</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">viewer_file_constructed</span> <span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* оновити стан об&#39;єкта залежно від властивостей конструктора */</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">Завжди</span> <span class="err">ланцюжком</span> <span class="err">виконайте</span> <span class="err">батьківську</span> <span class="err">функцію</span> <span class="n">constructed</span><span class="p">,</span> <span class="err">щоб</span> <span class="err">завершити</span> <span class="err">ініціалізацію</span> <span class="err">об&#39;єкта</span><span class="p">.</span> <span class="err">*/</span>
  <span class="n">G_OBJECT_CLASS</span> <span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">constructed</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">viewer_file_finalize</span> <span class="p">(</span><span class="n">GObject</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ViewerFile</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">VIEWER_FILE</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>

  <span class="n">g_free</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>

<span class="o">/</span> <span class="o">*</span> <span class="err">Завжди</span> <span class="err">зціплюйтесь</span> <span class="err">до</span> <span class="err">функції</span> <span class="err">завершення</span> <span class="n">finalize</span><span class="p">,</span> <span class="err">щоб</span> <span class="err">завершити</span> <span class="err">знищення</span> <span class="err">об&#39;єкта</span><span class="p">.</span> <span class="o">*</span> <span class="o">/</span>
  <span class="n">G_OBJECT_CLASS</span> <span class="p">(</span><span class="n">viewer_file_parent_class</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">finalize</span> <span class="p">(</span><span class="n">obj</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">viewer_file_class_init</span> <span class="p">(</span><span class="n">ViewerFileClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GObjectClass</span> <span class="o">*</span><span class="n">object_class</span> <span class="o">=</span> <span class="n">G_OBJECT_CLASS</span> <span class="p">(</span><span class="n">klass</span><span class="p">);</span>

  <span class="n">object_class</span><span class="o">-&gt;</span><span class="n">constructed</span> <span class="o">=</span> <span class="n">viewer_file_constructed</span><span class="p">;</span>
  <span class="n">object_class</span><span class="o">-&gt;</span><span class="n">finalize</span> <span class="o">=</span> <span class="n">viewer_file_finalize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="n">viewer_file_init</span> <span class="p">(</span><span class="n">ViewerFile</span> <span class="o">*</span><span class="n">self</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/* ініціалізувати об’єкт */</span>
<span class="p">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо користувач інстанціює об'єкт ViewerFile за допомогою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ViewerFile</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">g_object_new</span> <span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо це перша інстанція такого об’єкта, функція <code>viewer_file_class_init</code> буде викликана після будь-якої функції <code>viewer_file_base_class_init</code>. Це забезпечить правильну ініціалізацію структури класів цього нового об’єкта. Тут очікується, що <code>viewer_file_class_init</code> перекриє методи класу об'єкта та встановить власні методи класу. У наведеному вище прикладі побудований метод є єдиним перекритим методом: він встановлений на <code>viewer_file_constructed</code>.</p></div>
<div class="paragraph"><p>Як тільки <code>g_object_new</code> отримав посилання на ініціалізовану структуру класу, він викликає свій метод конструктора для створення екземпляра нового об'єкта, якщо конструктор був перевизначеий у <code>viewer_file_class_init</code>. Перекриті конструктори повинні з'єднуватися з конструктором своїх батьків. Для того щоб знайти батьківський клас і ланцюг до конструктора батьківського класу, ми можемо використовувати покажчик <code>viewer_file_parent_class</code>, який був створений для нас макросом <code>G_DEFINE_TYPE</code>.</p></div>
<div class="paragraph"><p>Нарешті, в тій чи іншій точці останній конструктор ланцюга викликає <code>g_object_constructor</code>. Ця функція виділяє буфер примірника об'єкта через <code>g_type_create_instance</code>, що означає, що в цей момент функція викликається <code>instance_init</code>, якщо вона була зареєстрована. Після повернення <code>instance_init</code> об'єкт повністю ініціалізується і повинен бути готовий до того, щоб користувачі викликали його методи. Коли <code>g_type_create_instance</code> повертається, <code>g_object_constructor</code> встановлює властивості побудови (тобто властивості, які були надані <code>g_object_new</code>) і повертається до конструктора користувача.</p></div>
<div class="paragraph"><p>Описаний вище процес може здатися дещо складним, але його можна легко підсумувати таблицею, в якій наведено список функцій, на які посилається <code>g_object_new</code>, та їх порядок виклику:</p></div>
<div class="ulist"><div class="title">Таблиця 4. g_object_new</div><ul>
<li>
<p>
Перший виклик <code>g_object_new</code> для цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
<code>base_init</code> функція на дереві спадкування класів від основного типу до цільового типу. <code>base_init</code> викликається один раз для кожної структури класу. Ніколи не використовується на практиці. Навряд чи вам це знадобиться.
</p>
</li>
<li>
<p>
target type&#8217;s class_init function    On target type&#8217;s class structure        Here, you should make sure to initialize or override class methods (that is, assign to each class' method its function pointer) and create the signals and the properties associated to your object.
</p>
</li>
<li>
<p>
Функція <code>class_init</code> цільового типу на структурі класа. Вам слідує переконатися, що ви не забули ініціалізувати або переопределити методи класу (тобто призначити методу кожного класу його вказівник функції) та створити сигнали та властивості, пов’язані з вашим об’єктом.
</p>
</li>
<li>
<p>
функція <code>base_init</code> на vtable інтерфейсу
</p>
</li>
<li>
<p>
функція <code>function_init</code> на vtable інтерфейсу
</p>
</li>
</ul></div>
</li>
<li>
<p>
Кожен виклик <code>g_object_new</code> для методу конструктора класу цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
методу конструктора класів: <code>GObjectClass-&gt;constructor</code> на екземплярі об'єкта. Якщо вам потрібно обробляти властивості конструкції на власний спосіб або впроваджувати клас-синглтон, перевірте метод конструктора і переконайтеся, що ланцюг до батьківський клас об'єкта перед власною ініціалізацією. У сумніві, не перекривайте метод <code>constructor</code>.
</p>
</li>
<li>
<p>
функція <code>instance_init</code> на дереві спадкування класів від основного типу до цільового типу. екземпляр_init, наданий для кожного типу, викликається один раз для кожної структури примірника. Надайте функцію <code>instance_init</code>, щоб ініціалізувати ваш об'єкт до того, як будуть встановлені його властивості побудови. Це кращий спосіб ініціалізації екземпляра <code>GObject</code>. Ця функція еквівалентна конструкторам C++.
</p>
</li>
<li>
<p>
target type&#8217;s class constructed method: GObjectClass&#8594;constructed    On object&#8217;s instance    If you need to perform object initialization steps after all construct properties have been set. This is the final step in the object initialization process, and is only called if the constructor method returned a new object instance (rather than, for example, an existing singleton).
</p>
</li>
<li>
<p>
метод <code>constructed</code> класу цільового типу: <code>GObjectClass-&gt;constructed</code> на екземплярі об'єкта. Якщо вам потрібно виконати кроки ініціалізації об'єкта після встановлення всіх властивостей конструкції. Це завершальний крок у процесі ініціалізації об'єкта, і він визивається лише у тому випадку, якщо метод конструктора повернув новий екземпляр об'єкта (а не, наприклад, існуючий синглтон).
</p>
</li>
</ul></div>
</li>
</ul></div>
<div class="paragraph"><p>Читачі повинні відчувати занепокоєння з приводу одного невеликого повороту в порядку, в якому викликаються функції: в той час, як технічно, метод конструктора класу викликається перед <code>GType</code> функцією <code>instance_init</code> (оскільки <code>g_type_create_instance</code>, що викликає <code>instance_init</code>, визивається в <code>g_object_constructor</code>, який є метод конструктора верхнього рівня класа, і до якого, як очікується, користувачі покладуть ланцюг), код користувача, який працює в наданому користувачем конструкторі, завжди працюватиме після <code>GType</code> функції <code>instance_init</code>, оскільки наданий користувачем конструктор повинен (вас попереджали) уиворити ланцюжок, перш ніж робити що-небудь корисне.</p></div>
</div>
<div class="sect2">
<h3 id="______2">Управління пам'яттю об'єкта</h3>
<div class="paragraph"><p>API управління пам'яттю для <code>GObject</code> трохи складний, але ідея, що стоїть за ним, є досить простою: мета полягає у створенні гнучкої моделі на основі підрахунку посилань, яка може бути інтегрована в додатки, які використовують або вимагають різних моделей управління пам'яттю (наприклад, збір сміття). Нижче описані методи, які використовуються для маніпулювання цією кількістю посилань.</p></div>
<div class="sect3">
<h4 id="___3">Підрахунок посилань</h4>
<div class="paragraph"><p>Функції <code>g_object_ref</code>/<code>g_object_unref</code> відповідно збільшують і зменшують кількість посилань. Ці функції є безпечними для потоків. <code>g_clear_object</code> - це зручна обгортка навколо <code>g_object_unref</code>, яка також очищає вказівник, переданий на нього.</p></div>
<div class="paragraph"><p>Підрахунок посилань ініціалізується на <code>g_object_new</code>, що означає, що викликач наразі є єдиним власником новоствореного посилання. Коли кількість посилань досягає нуля, тобто коли останній клієнт, що містить посилання на об'єкт, викликає <code>g_object_unref</code>, викликаються методи класу <code>dispose</code> та <code>finalize</code>.</p></div>
<div class="paragraph"><p>Нарешті, після виклику фіналізації викликується <code>g_type_free_instance</code>, щоб звільнити примірник об'єкта. Залежно від політики розподілу пам'яті, прийнятої при реєстрації типу (через одну з функцій <code>g_type_register_*</code>), пам'ять примірника об'єкта буде звільнена або повернута в пул об'єктів для цього типу. Після вивільнення об'єкта, якщо це був останній екземпляр типу, клас типу буде знищений, як описано в розділі, який називається "Уособлювані класифіковані типи: об'єкти" та розділі під назвою "Неуособлювані класифіковані типи: інтерфейси".</p></div>
<div class="paragraph"><p>У таблиці нижче наведено процес знищення <code>GObject</code>:</p></div>
<div class="ulist"><div class="title">Таблиця 5. g_object_unref</div><ul>
<li>
<p>
Останній виклик <code>g_object_unref</code> для <strong>примірника</strong> цільового типу.
</p>
<div class="ulist"><ul>
<li>
<p>
<code>dispose</code>  цільового типу для екземпляра <code>GObject</code>. Коли <code>dispose</code> закінчується, об'єкт не повинен містити посилання на будь-який інший об'єкт-член. Очікується, що об'єкт також зможе відповідати на виклики методу клієнта (можливо, з кодом помилки, але без порушення пам’яті) до завершення <code>finalize</code>. <code>dispose</code> може бути виконано не один раз. <code>dispose</code> слід зціплювати до його батьківської реалізації безпосередньо перед поверненням до абонента.
</p>
</li>
<li>
<p>
<code>finalize</code> цільового типу для екземпляра <code>GObject</code>. <code>finalize</code> завершить процес знищення, ініційований <code>dispose</code>. Це повинно завершити руйнування об'єкта. <code>finalize</code> буде виконано лише один раз. <code>finalize</code> повинно іти ланцюжком до його батьківської реалізації безпосередньо перед поверненням до абонента. Причина, через яку процес руйнування розбивається на дві різні фази, пояснюється в розділі «Підрахунок посилань та цикли».
</p>
</li>
</ul></div>
</li>
<li>
<p>
Останній виклик <code>g_object_unref</code> <strong>для останнього примірника</strong> цільового типу
</p>
<div class="ulist"><ul>
<li>
<p>
<code>interface_finalize</code> на <code>vtable</code> інтерфейсу. Ніколи не використовується на практиці. Навряд чи вам це знадобиться.
</p>
</li>
<li>
<p>
<code>base_finalize</code> інтерфейсу на <code>vtable</code> інтерфейсу. Ніколи не використовується на практиці. Навряд чи вам це знадобиться.
</p>
</li>
<li>
<p>
<code>class_finalize</code> на структурі класу цільового типу. Ніколи не використовується на практиці. Навряд чи вам це знадобиться.
</p>
</li>
<li>
<p>
<code>base_finalize</code> на дереві спадкування класів від основного типу до цільового типу. <code>base_finalize</code> викликається один раз для кожної структури класу. Ніколи не використовується на практиці. Навряд чи вам це знадобиться.
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect3">
<h4 id="___4">Слабкі посилання</h4>
<div class="paragraph"><p>Слабкі посилання використовуються для контролю за фіналізацією об’єкта: <code>g_object_weak_ref</code> додає зворотний виклик моніторингу, який не містить посилання на об'єкт, але викликається, коли об’єкт запускає свій метод <code>dispose</code>. Таким чином, кожен слабкий ref може бути викликаний не раз при завершенні об'єкта (оскільки <code>dispose</code> може працювати більше одного разу під час фіналізації об'єкта).</p></div>
<div class="paragraph"><p><code>g_object_weak_unref</code> можна використовувати для видалення зворотного виклику моніторингу з об'єкта.</p></div>
<div class="paragraph"><p>Слабкі посилання також використовуються для реалізації <code>g_object_add_weak_pointer</code> та <code>g_object_remove_weak_pointer</code>. Ці функції додають слабке посилання на об'єкт, до якого вони застосовуються, що гарантує анулювання покажчика, заданого користувачем, коли об'єкт фіналізований.</p></div>
<div class="paragraph"><p>Аналогічно, <code>GWeakRef</code> можна використовувати для впровадження слабких посилань, якщо потрібна безпека потоку.</p></div>
</div>
<div class="sect3">
<h4 id="_____5">Підрахунок посилань та цикли</h4>
<div class="paragraph"><p>Модель управління пам'яттю <code>GObject</code> була розроблена для того, щоб легко інтегруватись у існуючий код за допомогою збору сміття. Ось чому процес руйнування розбивається на дві фази: перша фаза, виконана в оброблювачем <code>dispose</code>, повинна звільнити всі посилання на інші об'єкти-члени. Друга фаза, виконана обробником <code>finalize</code>, повинна завершити процес руйнування об'єкта. Об'єктні методи повинні бути в змозі запускатися без програмної помилки між двома фазами.</p></div>
<div class="paragraph"><p>Цей двоетапний процес руйнування дуже корисний для порушення циклів підрахунку посилань. Хоча виявлення циклів залежить від зовнішнього коду, після виявлення циклів зовнішній код може викликати <code>g_object_run_dispose</code>, який дійсно порушить будь-які існуючі цикли, оскільки він запустить оброблювач <code>dispose</code>, пов'язаний з об'єктом, і таким чином звільнить усі посилання на інші об’єкти.</p></div>
<div class="paragraph"><p>Це пояснює одне з правил, викладених раніше щодо <code>dispose</code>, що викладений раніше: обробник <code>dispose</code> можна викликати кілька разів. Скажімо, у нас є цикл відліку посилань: об’єкт <code>A</code> посилається на <code>B</code>, який сам посилається на об’єкт <code>А</code>. Скажімо, ми виявили цикл і хочемо знищити два об'єкти. Один із способів зробити це - викликати <code>g_object_run_dispose</code> на одному з об’єктів.</p></div>
<div class="paragraph"><p>Якщо об’єкт <code>A</code> вивільняє всі свої посилання на всі об'єкти, це означає, що він вивільняє своє посилання на об'єкт <code>B</code>. Якщо об'єктом <code>B</code> не володів хтось інший, це його останнє  посилання, що означає, що цей останній <code>unref</code> запускає обробник <code>dispose</code> <code>B</code>, який, у свою чергу, звільняє посилання <code>B</code> на об’єкт <code>A</code>. Якщо це останнє посилання на <code>A</code>, це останнє <code>unref</code> запускає обробник <code>dispose</code> <code>A</code>, який працює вдруге перед тим, як викликати обробник <code>finalize</code> A!</p></div>
<div class="paragraph"><p>Наведений вище приклад, який може здатися трохи надуманим, справді може статися, якщо <code>GObjects</code> обробляються мовними прив'язками - отже, слід уважно дотримуватися правил знищення об'єктів.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____2">Властивості об'єкта</h3>
<div class="paragraph"><p>Однією з приємних особливостей <code>GObject</code> є його загальний механізм <code>get</code>/<code>set</code> для властивостей об'єкта. Коли об'єкт інстанціюється, обробник <code>class_init</code> об'єкта повинен використовуватися для реєстрації властивостей об'єкта за допомогою <code>g_object_class_install_properties</code>.</p></div>
<div class="paragraph"><p>Найкращий спосіб зрозуміти, як функціонують властивості об'єкта, - перегляньте реальний приклад того, як він використовується:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cm">/************************************************/</span>
<span class="cm">/* Реалізація                                   */</span>
<span class="cm">/************************************************/</span>

<span class="k">typedef</span> <span class="k">enum</span>
<span class="p">{</span>
  <span class="n">PROP_FILENAME</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">PROP_ZOOM_LEVEL</span><span class="p">,</span>
  <span class="n">N_PROPERTIES</span>
<span class="p">}</span> <span class="n">ViewerFileProperty</span><span class="p">;</span>

<span class="k">static</span> <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">obj_properties</span><span class="p">[</span><span class="n">N_PROPERTIES</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_set_property</span> <span class="p">(</span><span class="n">GObject</span>      <span class="o">*</span><span class="n">object</span><span class="p">,</span>
                          <span class="n">guint</span>         <span class="n">property_id</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">GValue</span> <span class="o">*</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">GParamSpec</span>   <span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ViewerFile</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">VIEWER_FILE</span> <span class="p">(</span><span class="n">object</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">((</span><span class="n">ViewerFileProperty</span><span class="p">)</span> <span class="n">property_id</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">PROP_FILENAME</span><span class="p">:</span>
      <span class="n">g_free</span> <span class="p">(</span><span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
      <span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span> <span class="o">=</span> <span class="n">g_value_dup_string</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;filename: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">PROP_ZOOM_LEVEL</span><span class="p">:</span>
      <span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span> <span class="o">=</span> <span class="n">g_value_get_uint</span> <span class="p">(</span><span class="n">value</span><span class="p">);</span>
      <span class="n">g_print</span> <span class="p">(</span><span class="s">&quot;zoom level: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="cm">/* We don&#39;t have any other property... */</span>
      <span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span> <span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">property_id</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_get_property</span> <span class="p">(</span><span class="n">GObject</span>    <span class="o">*</span><span class="n">object</span><span class="p">,</span>
                          <span class="n">guint</span>       <span class="n">property_id</span><span class="p">,</span>
                          <span class="n">GValue</span>     <span class="o">*</span><span class="n">value</span><span class="p">,</span>
                          <span class="n">GParamSpec</span> <span class="o">*</span><span class="n">pspec</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">ViewerFile</span> <span class="o">*</span><span class="n">self</span> <span class="o">=</span> <span class="n">VIEWER_FILE</span> <span class="p">(</span><span class="n">object</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">((</span><span class="n">ViewerFileProperty</span><span class="p">)</span> <span class="n">property_id</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="nl">PROP_FILENAME</span><span class="p">:</span>
      <span class="n">g_value_set_string</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">filename</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">PROP_ZOOM_LEVEL</span><span class="p">:</span>
      <span class="n">g_value_set_uint</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">self</span><span class="o">-&gt;</span><span class="n">zoom_level</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">default</span><span class="o">:</span>
      <span class="cm">/* We don&#39;t have any other property... */</span>
      <span class="n">G_OBJECT_WARN_INVALID_PROPERTY_ID</span> <span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">property_id</span><span class="p">,</span> <span class="n">pspec</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">viewer_file_class_init</span> <span class="p">(</span><span class="n">ViewerFileClass</span> <span class="o">*</span><span class="n">klass</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">GObjectClass</span> <span class="o">*</span><span class="n">object_class</span> <span class="o">=</span> <span class="n">G_OBJECT_CLASS</span> <span class="p">(</span><span class="n">klass</span><span class="p">);</span>

  <span class="n">object_class</span><span class="o">-&gt;</span><span class="n">set_property</span> <span class="o">=</span> <span class="n">viewer_file_set_property</span><span class="p">;</span>
  <span class="n">object_class</span><span class="o">-&gt;</span><span class="n">get_property</span> <span class="o">=</span> <span class="n">viewer_file_get_property</span><span class="p">;</span>

  <span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_FILENAME</span><span class="p">]</span> <span class="o">=</span>
    <span class="n">g_param_spec_string</span> <span class="p">(</span><span class="s">&quot;filename&quot;</span><span class="p">,</span>
                         <span class="s">&quot;Filename&quot;</span><span class="p">,</span>
                         <span class="s">&quot;Name of the file to load and display from.&quot;</span><span class="p">,</span>
                         <span class="nb">NULL</span>  <span class="cm">/* default value */</span><span class="p">,</span>
                         <span class="n">G_PARAM_CONSTRUCT_ONLY</span> <span class="o">|</span> <span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

  <span class="n">obj_properties</span><span class="p">[</span><span class="n">PROP_ZOOM_LEVEL</span><span class="p">]</span> <span class="o">=</span>
    <span class="n">g_param_spec_uint</span> <span class="p">(</span><span class="s">&quot;zoom-level&quot;</span><span class="p">,</span>
                       <span class="s">&quot;Zoom level&quot;</span><span class="p">,</span>
                       <span class="s">&quot;Zoom level to view the file at.&quot;</span><span class="p">,</span>
                       <span class="mi">0</span>  <span class="cm">/* minimum value */</span><span class="p">,</span>
                       <span class="mi">10</span> <span class="cm">/* maximum value */</span><span class="p">,</span>
                       <span class="mi">2</span>  <span class="cm">/* default value */</span><span class="p">,</span>
                       <span class="n">G_PARAM_READWRITE</span><span class="p">);</span>

  <span class="n">g_object_class_install_properties</span> <span class="p">(</span><span class="n">object_class</span><span class="p">,</span>
                                     <span class="n">N_PROPERTIES</span><span class="p">,</span>
                                     <span class="n">obj_properties</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/************************************************/</span>
<span class="cm">/* Використання                                 */</span>
<span class="cm">/************************************************/</span>

<span class="n">ViewerFile</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="n">GValue</span> <span class="n">val</span> <span class="o">=</span> <span class="n">G_VALUE_INIT</span><span class="p">;</span>

<span class="n">file</span> <span class="o">=</span> <span class="n">g_object_new</span> <span class="p">(</span><span class="n">VIEWER_TYPE_FILE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="n">g_value_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="n">G_TYPE_UINT</span><span class="p">);</span>
<span class="n">g_value_set_char</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

<span class="n">g_object_set_property</span> <span class="p">(</span><span class="n">G_OBJECT</span> <span class="p">(</span><span class="n">file</span><span class="p">),</span> <span class="s">&quot;zoom-level&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>

<span class="n">g_value_unset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Код клієнта вище виглядає просто, але багато чого відбувається за лаштунками:</p></div>
<div class="paragraph"><p><code>g_object_set_property</code> спочатку гарантує, що властивість з цим ім'ям була зареєстрована у файлі обробника <code>class_init</code> файлу. Якщо так, то вона переходить до ієрархії класів, від найнижчого типу, найпохіднішого, до найфундаментальнішого типу, щоб знайти клас, який зареєстрував це властивість. Потім він намагається перетворити надану користувачем <code>GValue</code> в <code>GValue</code>, тип якого - тип пов'язаної властивості.</p></div>
<div class="paragraph"><p>Якщо користувач надає <code>signed char</code> <code>GValue</code>, як показано тут, і якщо властивість об'єкта було зареєстровано як <code>unsigned int</code>, <code>g_value_transform</code> спробує перетворити <code>signed char</code> на вході в <code>unsigned int</code>. Звичайно, успіх перетворення залежить від наявності необхідної функції перетворення. На практиці майже завжди буде трансформація, що співпадає, і перетворення буде здійснено за потреби.</p></div>
<div class="paragraph"><p>Після трансформації <code>GValue</code> перевіряється <code>g_param_value_validate</code>, що гарантує, що дані користувача, що зберігаються у <code>GValue</code>, відповідають характеристикам, визначеним <code>GParamSpec</code> властивості. Тут <code>GParamSpec</code>, який ми надали у <code>class_init</code>, має функцію перевірки, яка гарантує, що <code>GValue</code> містить значення, яке поважає мінімальну та максимальну межі <code>GParamSpec</code>. У наведеному вище прикладі клієнтське <code>GValue</code> не дотримується цих обмежень (воно встановлене ​​в <code>11</code>, тоді як максимальне - <code>10</code>). Таким чином, функція <code>g_object_set_property</code> повернеться з помилкою.</p></div>
<div class="paragraph"><p>Якщо для користувача <code>GValue</code> було встановлено гідне значення, <code>g_object_set_property</code> продовжував би виклик методу <code>set_property</code> класу. Оскільки наша реалізація <code>ViewerFile</code> змінила цей метод, виконання буде переходити до <code>viewer_file_set_property</code> після отримання з <code>GParamSpec param_id</code>, який зберігався <code>g_object_class_install_property</code>.</p></div>
<div class="paragraph"><p>Після встановлення властивості методом класу <code>set_property</code> об’єкта, виконання повертається до <code>g_object_set_property</code>, що гарантує, що сигнал <code>notify</code> випромінюється в екземплярі об'єкта зі зміненою властивістю як параметром, якщо сповіщення не було заморожено <code>g_object_freeze_notify</code>.</p></div>
<div class="paragraph"><p><code>g_object_thaw_notify</code> можна використовувати для повторного включення сповіщень про зміни властивостей за допомогою сигналу <code>notify</code>. Важливо пам’ятати, що навіть якщо властивості змінюються, коли сповіщення про зміну властивості заморожено, сигнал <code>notify</code> надсилатиметься один раз для кожної з цих змінених властивостей, як тільки повідомлення про зміну властивості буде розморожено: жодна зміна властивості не втрачається для сигналу <code>notify</code>, хоча кілька повідомлень для однієї властивості згортаються. Сигнали лише можуть бути відкладені механізмом заморожування повідомлень.</p></div>
<div class="paragraph"><p>Це звучить як копітка задача налаштувати <code>GValues</code> ​​кожного разу, коли хочеться змінити властивість. На практиці це рідко хто буде робити. Функції <code>g_object_set_property</code> та <code>g_object_get_property</code> призначені для використання в мовних прив'язках. Для застосування існує більш простий спосіб, який описаний далі.</p></div>
<div class="sect3">
<h4 id="______3">Доступ до кількох ресурсів одночасно</h4>
<div class="paragraph"><p>Цікаво зауважити, що функції <code>g_object_set</code> та <code>g_object_set_valist</code> (варіатична версія) можна використовувати для встановлення декількох властивостей одночасно. Код клієнта, показаний вище, може бути переписаний у такий спосіб:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ViewerFile</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
<span class="n">file</span> <span class="o">=</span> <span class="cm">/* */</span><span class="p">;</span>
<span class="n">g_object_set</span> <span class="p">(</span><span class="n">G_OBJECT</span> <span class="p">(</span><span class="n">file</span><span class="p">),</span>
              <span class="s">&quot;zoom-level&quot;</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span>
              <span class="s">&quot;filename&quot;</span><span class="p">,</span> <span class="s">&quot;~/some-file.txt&quot;</span><span class="p">,</span>
              <span class="nb">NULL</span><span class="p">);</span>
</pre></div></div></div>
<div class="paragraph"><p>Це позбавляє нас від управління <code>GValues</code>, які нам потрібно було обробляти при використанні <code>g_object_set_property</code>. Код, наведений вище, викликає випромінювання одного сигналу <code>notify</code> для кожної модифікованої властивості.</p></div>
<div class="paragraph"><p>Також доступні еквівалентні версії <code>_get</code>: <code>g_object_get</code> та <code>g_object_get_valist</code> (варіатична версія) можуть бути використані для отримання декількох властивостей одразу.</p></div>
<div class="paragraph"><p>У цих функцій високого рівня є один недолік - вони не забезпечують повернення значення. Слід звернути увагу на типи аргументів та діапазони при їх використанні. Відоме джерело помилок - це передавання іншого типу від того, що очікує властивість; наприклад, передаючи ціле число, коли властивість очікує значення з плаваючою точкою і таким чином змінює всі наступні параметри на деяку кількість байтів. Також забуття заключного <code>NULL</code> призведе до невизначеної поведінки.</p></div>
<div class="paragraph"><p>Це пояснює, як працюють <code>g_object_new</code>, <code>g_object_newv</code> та <code>g_object_new_valist</code>: вони аналізують задану користувачем змінну кількість параметрів і викликають <code>g_object_set</code> на параметрах лише після успішного побудови об'єкта. Сигнал <code>notify</code> буде випромінюватися для кожного набору властивостей.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____gobject">Система обміну повідомленнями GObject</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__4">Замикання</h3>
<div class="paragraph"><p>Closures are central to the concept of asynchronous signal delivery which is widely used throughout GTK+ and GNOME applications. A closure is an abstraction, a generic representation of a callback. It is a small structure which contains three objects:</p></div>
<div class="paragraph"><p>a function pointer (the callback itself) whose prototype looks like:</p></div>
<div class="paragraph"><p>return_type function_callback (… , gpointer user_data);
the user_data pointer which is passed to the callback upon invocation of the closure</p></div>
<div class="paragraph"><p>a function pointer which represents the destructor of the closure: whenever the closure&#8217;s refcount reaches zero, this function will be called before the closure structure is freed.</p></div>
<div class="paragraph"><p>The GClosure structure represents the common functionality of all closure implementations: there exists a different closure implementation for each separate runtime which wants to use the GObject type system. [4] The GObject library provides a simple GCClosure type which is a specific implementation of closures to be used with C/C++ callbacks.</p></div>
<div class="paragraph"><p>A GClosure provides simple services:</p></div>
<div class="paragraph"><p>Invocation (g_closure_invoke): this is what closures were created for: they hide the details of callback invocation from the callback invoker.</p></div>
<div class="paragraph"><p>Notification: the closure notifies listeners of certain events such as closure invocation, closure invalidation and closure finalization. Listeners can be registered with g_closure_add_finalize_notifier (finalization notification), g_closure_add_invalidate_notifier (invalidation notification) and g_closure_add_marshal_guards (invocation notification). There exist symmetric deregistration functions for finalization and invalidation events (g_closure_remove_finalize_notifier and g_closure_remove_invalidate_notifier) but not for the invocation process. [5]</p></div>
<div class="paragraph"><p>C Closures
If you are using C or C++ to connect a callback to a given event, you will either use simple GCClosures which have a pretty minimal API or the even simpler g_signal_connect functions (which will be presented a bit later).</p></div>
<div class="paragraph"><p>g_cclosure_new will create a new closure which can invoke the user-provided callback_func with the user-provided user_data as its last parameter. When the closure is finalized (second stage of the destruction process), it will invoke the destroy_data function if the user has supplied one.</p></div>
<div class="paragraph"><p>g_cclosure_new_swap will create a new closure which can invoke the user-provided callback_func with the user-provided user_data as its first parameter (instead of being the last parameter as with g_cclosure_new). When the closure is finalized (second stage of the destruction process), it will invoke the destroy_data function if the user has supplied one.</p></div>
<div class="paragraph"><p>Non-C closures (for the fearless)
As was explained above, closures hide the details of callback invocation. In C, callback invocation is just like function invocation: it is a matter of creating the correct stack frame for the called function and executing a call assembly instruction.</p></div>
<div class="paragraph"><p>C closure marshallers transform the array of GValues which represent the parameters to the target function into a C-style function parameter list, invoke the user-supplied C function with this new parameter list, get the return value of the function, transform it into a GValue and return this GValue to the marshaller caller.</p></div>
<div class="paragraph"><p>A generic C closure marshaller is available as g_cclosure_marshal_generic which implements marshalling for all function types using libffi. Custom marshallers for different types are not needed apart from performance critical code where the libffi-based marshaller may be too slow.</p></div>
<div class="paragraph"><p>An example of a custom marshaller is given below, illustrating how GValues can be converted to a C function call. The marshaller is for a C function which takes an integer as its first parameter and returns void.</p></div>
<div class="paragraph"><p>g_cclosure_marshal_VOID<em>INT (GClosure     <strong>closure,
                              GValue       *return_value,
                              guint         n_param_values,
                              const GValue *param_values,
                              gpointer      invocation_hint,
                              gpointer      marshal_data)
{
  typedef void (*GMarshalFunc_VOID</em>INT) (gpointer     data1,
                                          gint         arg_1,
                                          gpointer     data2);
  register GMarshalFunc_VOID__INT callback;
  register GCClosure *cc = (GCClosure</strong>) closure;
  register gpointer data1, data2;</p></div>
<div class="literalblock">
<div class="content">
<pre><code>g_return_if_fail (n_param_values == 2);</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>data1 = g_value_peek_pointer (param_values + 0);
data2 = closure-&gt;data;</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  callback (data1,
            g_marshal_value_peek_int (param_values + 1),
            data2);
}
There exist other kinds of marshallers, for example there is a generic Python marshaller which is used by all Python closures (a Python closure is used to invoke a callback written in Python). This Python marshaller transforms the input GValue list representing the function parameters into a Python tuple which is the equivalent structure in Python.</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-05-08 11:37:26 EEST
</div>
</div>
</body>
</html>
