:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== D-Bus Specification

=== Вступ

D-Bus - це система низько-навантаженого, простого у використанні міжпроцесорного зв'язку (IPC). Більш детально:

* D-Bus є _низько-навантаженим_, оскільки він використовує двійковий протокол, і не повинен перетворювати його в текстовий формат, наприклад XML. Оскільки D-Bus призначений для потенційно IPC на одній машині з високою роздільною здатністю, не в першу чергу для Internet IPC, це цікава оптимізація. D-Bus також призначений для уникнення кругових маршрутів і спроможності асинхронної роботи, подібно до протоколу X.

* D-Bus _простий у використанні_, оскільки він працює в термінах повідомлень, а не потоків байтів, і автоматично обробляє безліч важких проблем з IPC. Крім того, бібліотека D-Bus розроблена так, щоб вона була огорнута таким чином, що дозволяє розробникам використовувати існуючу систему об'єктів/типів їхніх фреймворків, а не вивчати нову спеціально для IPC.

Базовий протокол D-Bus - це протокол "один на один" (одноранговий або клієнт-сервер), визначений у розділі "Протокол повідомлення". Тобто це система для одного додатку для спілкування з одним іншим додатком. Однак основним призначенням протоколу є шина повідомлень D-Bus, зазначена в розділі "Специфікація шини повідомлень". Шина повідомлень - це спеціальна програма, яка приймає з'єднання з декількох інших додатків та пересилає повідомлення серед них.

Використання D-Bus включає сповіщення про зміни системи (повідомлення про те, коли камера підключена до комп'ютера чи встановлена ​​нова версія якогось програмного забезпечення) або сумісність робочого столу, наприклад, служба моніторингу файлів або служба конфігурації.

D-Bus призначений для двох конкретних випадків використання:

"Системна шина" для сповіщень від системи до сеансів користувача та щоб дозволити системі запитувати введення даних із сеансів користувача.

"Шина сеансу", що використовується для реалізації середовищ настільних ПК, таких як GNOME та KDE.

D-Bus не призначений бути загальною системою IPC для будь-якого можливого застосування, і навмисно упускає багато можливостей, знайдених в інших системах IPC з цієї причини.

У той же час демони шини пропонують ряд функцій, які не зустрічаються в інших системах IPC, такі як "власні назви шин" для одного власника (подібні до X-вибору), запуск послуг на вимогу та політика безпеки. Багато в чому ці особливості є основною мотивацією для розвитку D-Bus; інших систем було б достатньо, якби IPC була єдиною метою.

D-Bus може виявитися корисним у непередбачуваних застосуваннях, але майбутні версії цієї специфікації та посилання на реалізацію, ймовірно, не включатимуть функції, що заважають основним випадкам використання.

У цьому документі ключові слова "ОБОВ'ЯЗКОВО", "НЕ ПОВИННІ", "ВИМАГАЄТЬСЯ", "ПОТРІБНО", "МАЄ", "НЕ МАЄ", "РЕКОМЕНДОВАНО", "МОЖУ" та "ОПЦІЙНО" тлумачити так, як описано в RFC 2119. Однак документ може використовувати серйозний аудит, щоб переконатися, що це має сенс. Також вони не використовуються з великої літери.

=== Стабільність протоколу та специфікації

Протокол D-Bus заморожено (дозволені лише сумісні розширення) з 8 листопада 2006 року. Однак ця специфікація може все-таки використати неабияку роботу, щоб зробити можливим взаємодіючу імплементацію без посилання на реалізацію посилання D-Bus. Таким чином, ця специфікація не позначена 1,0. Щоб позначити це 1.0, ми хотіли б, щоб хтось вкладав значні зусилля в роз'яснення мови специфікацій та розширення специфікації, щоб охопити більше аспектів поведінки формальної реалізації.

Поки ця робота не буде завершена, будь-яка спроба повторного втілення D-Bus, ймовірно, потребує перегляду посилання на реалізацію та/або задавання питань у списку розсилки D-Bus щодо наміченої поведінки. Питання в списку дуже вітаються.

Тим не менш, цей документ повинен бути корисним початковим пунктом і, наскільки нам відомо, точним, хоча і неповним.

=== Система типів

D-Bus має систему типів, в якій значення різних типів можуть бути серіалізовані в послідовність байтів, що називаються дротяним форматом стандартним способом. Перетворення значення з якогось іншого представлення у дротяний формат називається маршалінг, а перетворення його назад із дротяного формату - демаршалінг.

Протокол D-Bus не включає теги типів у даних маршалінгу; блок значень маршалінгу повинен мати відомий тип підпису. Підпис типу складається з нуля або більше окрених повних типів, кожен складається з одного або декількох кодів типу.

Код типу - символ ASCII, що представляє тип значення. Оскільки використовуються символи ASCII, підпис типу завжди утворюватиме гідний рядок ASCII. Просте порівняння рядків визначає, чи два підписи рівнозначні.

A single complete type is a sequence of type codes that fully describes one type: either a basic type, or a single fully-described container type. A single complete type is a basic type code, a variant type code, an array with its element type, or a struct with its fields (all of which are defined below). So the following signatures are not single complete types:
Окремий повний тип - це послідовність типів кодів, яка повністю описує один тип: або основний тип, або єдиний повністю описаний тип контейнера. Одиничний повний тип - це базовий код типу, код варіанту типу, масив з його типом елемента або структура з полями (усі вони визначені нижче). Отже, наступні підписи не є єдиними повними типами: `aa`, `(ii`, `ii)`. А наступні підписи містять кілька повних типів: `ii`, `aiai`, `(ii)(ii)`.
      
Зауважте, однак, що один повний тип може містити декілька інших одиничних повних типів, що містять `struct` або запис `dict`.

=== Основні типи

Найпростіші типи кодів - основні типи, структура яких повністю визначена їх 1-символьним кодом типу. Основні типи складаються з фіксованих типів і строкоподібних типів.

Фіксовані типи - це базові типи, значення яких мають фіксовану довжину, а саме: `BYTE`, `BOOLEAN`, `DOUBLE`, `UNIX_FD` та знакові або беззнакові цілі числа довжиною 16, 32 або 64 біт.

Як простий приклад, код типу для 32-бітного цілого числа (`INT32`) - символ ASCII `i`. Отже, підписом для блоку значень, що містить єдиний `INT32`, було б: `i`. Блок значень, що містить два `INT32`, повинен мати цей підпис: `ii`.
        
.Характеристики фіксованих типів.
[width="50%",cols="3,^2,10",options="header"]
|=====
|Звичайна назва|Код ASCII|Кодування
| BYTE    | y (121) | Беззнакове 8-бітне ціле
| BOOLEAN | b (98)  | Булеве значення: 0 - брехня, 1 - істина, будь-яке інше значення, дозволене форматом маршалінгу, недійсне
| INT16	  | n (110) | Знакове (доповнення до двох) 16-бітове ціле число
| UINT16  |	q (113)	| Беззнакове 16-бітове ціле число
| INT32	  | i (105) | Знакове (доповнення до двох) 32-бітове ціле число
| UINT32	| u (117)	| Беззнакове 32-бітове ціле число
| INT64	  | x (120)	| Знакове (доповнення до двох) 64-бітове ціле число (нагадування: x і t є першими символами "шістдесяти", які вже не використовуються для чогось більш поширеного)
| UINT64	| t (116)	| Беззнакове 64-бітове ціле число
| DOUBLE	| d (100)	| IEEE 754 з плаваючою точкою подвійної точності
| UNIX_FD	| h (104)	| 32-розрядне ціле число без знака, представляє індекс у позадіапазонному масиві дескрипторів файлів, переданих через якийсь механізм, орієнтований на платформу (мнемонічний: h для ручки)
|=====

Рядко-подібні типи - це базові типи зі змінною довжиною. Значення будь-якого рядкового типу - це концептуально 0 або більше кодових точок Unicode, закодованих у UTF-8, жодна з яких не може бути U + 0000. Текст UTF-8 повинен бути чітко підтверджений: зокрема, він не повинен містити надто довгих послідовностей або кодових точок вище `U+10FFFF`.

Оскільки специфікація D-Bus версії 0.21, відповідно до виправлення Unicode № 9, "несимволи" `U+FDD0..U+FDEF`, `U+nFFFE` та `U+nFFFF` дозволені в рядках UTF-8 (але зауважте, що старіші версії D-Bus відхиляли ці несимволи).

Формати маршалінгу для рядко-подібних типів закінчуються одним байтом нуля (`NUL`), але цей байт не вважається частиною тексту.

.Характеристики рядко-подібних типів.
[width="50%",cols="3,^2,10",options="header"]
|=====
| Звичайна назва | ASCII код типу | Обмеження дійсності
| STRING      |	s (115) | Без зайвих обмежень
| OBJECT_PATH | o (111)	| Повинен бути синтаксично дійсний шлях до об'єкта
| SIGNATURE   | g (103)	| Нуль або більше окремих повних типів
|=====

==== Дійсні шляхи об'єктів

Шлях до об'єкта - це ім'я, яке використовується для позначення екземпляра об'єкта. У концептуальному плані кожен учасник обміну повідомленнями D-Bus може мати будь-яку кількість екземплярів об'єктів (думайте я про об'єкти C ++ або Java), і кожен такий екземпляр матиме шлях. Як і файлова система, об'єкт екземпляри в додатку утворюють ієрархічне дерево.

Шляхи до об'єктів часто представлені просторами імен, починаючи із зворотного доменного імені та містять номер версії інтерфейсу так само, як імена інтерфейсів та гарно відомі імена шини. Це дає можливість реалізувати більше одного сервісу або більше однієї версії послуги в одному процесі, навіть якщо служби поділяють з'єднання, але не можуть інакше співпрацювати (наприклад, якщо вони реалізовані різними плагінами).

Використання об'єктного шляху `/` дозволено, але не рекомендується, оскільки це ускладнює створення версій інтерфейсів. Будь-які сигнали, що випромінюються від об'єкта D-Bus, мають унікальне ім'я шини, пов'язане з ними, а не його відоме ім'я. Це означає, що одержувачі сигналів повинні повністю покладатися на ім'я сигналу та шлях об'єкта, щоб визначити, з якого інтерфейсу походить сигнал.

Наприклад, якщо власник `example.com` розробляє API D-Bus для музичного плеєра, він може використовувати ієрархію об'єктних шляхів, що починаються з `/com/example/MusicPlayer1` для його об'єктів.

Наступні правила визначають дійсний шлях до об'єкта. Програми не повинні надсилати та приймати повідомлення з недійсними об'єктними шляхами.

* Шлях може бути будь-якої довжини.
* Шлях повинен починатися з символу ASCII `'/'` (ціле число 47) і повинен складатися з елементів, розділених косою рисою.
* Кожен елемент повинен містити лише символи ASCII `"[A-Z][a-z][0-9]_"`
* Жоден елемент не може бути порожнім рядком.
* Кілька символів `'/'` не можуть стояти послідовно.
* Заключний символ `'/'` не дозволений, якщо шлях не є кореневим шляхом (єдиний символ `'/'`).

==== Дійсні підписи

Реалізація не повинна надсилати або приймати недійсні підписи. Дійсні підписи відповідають таким правилам:

* Підпис - це список окремих повних типів. Масиви повинні мати типи елементів, а структури повинні мати відкриті і закриті дужки.
* У підписі дозволено використовувати лише коди, відкриті та закриті дужки та відкриті та закриті фігурні дужки. Код типу `STRUCT` у підписах заборонений, оскільки замість нього використовуються круглі дужки. Аналогічно, код типу `DICT_ENTRY` у підписах заборонений, оскільки замість нього використовуються фігурні дужки.
* Максимальна глибина вкладення типу контейнера - 32 коди типу масиву та 32 відкриті дужки. Це означає, що максимальна загальна глибина рекурсії становить 64, для "масиву масиву масиву ... структура в структурі ...", де є 32 масиви та 32 struct.
* Максимальна довжина підпису - 255.

Коли підписи з'являються в повідомленнях, формат маршалінгу гарантує, що за ними буде слідувати нульовий байт (який можна інтерпретувати як припинення рядка в стилі С або код типу `INVALID`), але це концептуально не є частиною підпису.

=== Типи контейнерів

Окрім основних типів, є чотири типи контейнерів: `STRUCT`, `ARRAY`, `VARIANT` та `DICT_ENTRY`.

`STRUCT` має код типу, ASCII символ `'r'`, але цей тип коду не відображається в підписах. Натомість символи ASCII використовуються `'('` і `')'` для позначення початку та кінця структури. Так, наприклад, структура, що містить два цілих числа, мала б цей підпис: `"(ii)"`

Структури можуть бути вкладені, наприклад, структура, що містить ціле число та іншу структуру: `"(i(ii))"`
        
Блок значення, що зберігає цю структуру, міститиме три цілі числа; підпис типу дозволяє відрізнити `"(i (ii))"` від `"((ii) i)"` або `"(iii)"` або `"iii"`.

Код типу `STRUCT` `'r'` наразі не використовується в протоколі D-Bus, але корисний у коді, який реалізує протокол. Цей тип коду визначений, щоб дозволити такому коду взаємодіяти в непротокольних контекстах.

Порожні структури не допускаються; між дужками повинен бути принаймні один код типу.

Код типу `ARRAY` має символ ASCII `'a'`. Коду типу масиву повинен дотримуватися один повний тип. Єдиний повний тип, що слідує за масивом, - це тип кожного елемента масиву. Тож простий приклад: `"ai"`, що є масивом 32-бітових цілих чисел. Але масив може бути будь-якого типу, наприклад, цей масив структур з двох полів `int32`: `"a(ii)"`. Або цей масив масиву цілих чисел: `"aai"`
        
Код типу `VARIANT` має символ ASCII `'v'`. Значення з маршовим типом типу `VARIANT` матиме підпис одного повного типу як частини значення. Після цього підпису буде додано маршаловане значення цього типу.

На відміну від підпису повідомлення, варіантний підпис може містити лише один повний тип. Отже, `"i"`, `"ai"` або `"(ii)"` в порядку, але `"ii"` - ні. Використання варіантів не може призвести до того, що загальна глибина повідомлення перевищує 64, включаючи інші типи контейнерів, такі як структури.

`DICT_ENTRY` працює точно як структура, але замість дужок він використовує фігурні дужки і має більше обмежень. Обмеження наступні: це зустрічається лише як тип елемента масиву; у нього рівно два окемих цілих типи всередині фігурних брекетів; перший тип ("ключ") повинен бути основним типом, а не типом контейнера. Реалізації не повинні приймати записи словника за межами масивів, не повинні приймати записи словника з нулем, одним або більше двох полів і не повинні приймати записи словника з ключами, що не належать до основного типу. Запис у словнику - це завжди пара ключ-значення.

Перше поле в `DICT_ENTRY` завжди є ключовим. Повідомлення вважається пошкодженим, якщо однаковий ключ зустрічається двічі в одному масиві `DICT_ENTRY`. Однак з міркувань продуктивності реалізації не потрібно відкидати словники з повторюваними ключами.

У більшості мов масив записів словника буде представлений у вигляді мапи, хеш-таблиці або об’єкта словника.

=== Підсумок щодо типів

У наступній таблиці підсумовані типи D-Bus.

[width="80%",cols="1,2,3,8",options="header"]
|=====
| Категорія    | Умовна назва |Код | Опис
| reserved	   | INVALID | 0 (ASCII NUL)   | Недійсний код типу, який використовується для завершення підпису
| fixed, basic | BYTE    | 121 (ASCII 'y') | 8-бітне беззнакове ціле
| fixed, basic | BOOLEAN |	98 (ASCII 'b') | Логічне значення, 0 FALSE, 1 TRUE. Все інше недійсне.
| fixed, basic | INT16   | 110 (ASCII 'n') | 16-бітне знакове ціле
| fixed, basic | UINT16	 | 113 (ASCII 'q') | 16-бітне беззнакове ціле
| fixed, basic | INT32	 | 105 (ASCII 'i') | 32-бітне знакове ціле
| fixed, basic | UINT32	 | 117 (ASCII 'u') | 32-бітне беззнакове ціле
| fixed, basic | INT64	 | 120 (ASCII 'x') | 64-бітне знакове ціле
| fixed, basic | UINT64	 | 116 (ASCII 't') | 64-бітне беззнакове ціле
| fixed, basic | DOUBLE	 | 100 (ASCII 'd') | IEEE 754 подвійної точності
| s-like, basic| STRING	 | 115 (ASCII 's') | UTF-8 рядок (має бути дійсним UTF-8). Повинно бути нуль-термінованим та не містити інші байти nul.
| s-like, basic | OBJECT_PATH | 111 (ASCII 'o') | Ім'я примірника об'єкта
| s-like, basic | SIGNATURE   |	103 (ASCII 'g')	| Сигнатура типу
| container	   | ARRAY   |  97 (ASCII 'a') | Масив
| container    | STRUCT  | 114 (ASCII 'r'), 40 (ASCII '('), 41 (ASCII ')') |	Структура; код типу 114 'r' зарезервований для використання у прив'язках та реалізаціях для представлення загальної концепції структури, і не повинен відображатися в підписах, використовуваних на D-Bus.
| container    | VARIANT | 118 (ASCII 'v') | Тип варіанту (тип значення є частиною самого значення)
| container    |	DICT_ENTRY | 101 (ASCII 'e'), 123 (ASCII '{'), 125 (ASCII '}') | Запис у dict або map (масив пар ключ-значення). Код типу 101 'e' зарезервований для використання у прив'язках та реалізації, щоб представити загальну концепцію dict або dict-entry, і не повинен відображатися в підписах, використовуваних на D-Bus.
| fixed, basic | UNIX_FD | 104 (ASCII 'h') | Файловий дескриптор Unix
| reserved     | (reserved) |	109 (ASCII 'm') |	Зарезервовано для типу "можливо", сумісного з типом у GVariant, і не повинно з'являтися у підписах, що використовуються на D-Bus, поки не вказано тут
| reserved	   | (reserved) |  42 (ASCII '*') |	Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого окремого повного типу і не повинно з'являтися в підписах, використовуваних на D-Bus.
| reserved     | (reserved) |	 63 (ASCII '?') |	Зарезервовано для використання в прив'язках/реалізаціях для представлення будь-якого базового типу і не повинно з'являтися в підписах, використовуваних на D-Bus.
| reserved    |	(reserved)  |  64 (ASCII '@'), 38 (ASCII '&'), 94 (ASCII '^') |Зарезервовано для внутрішнього використання шляхом прив'язки/реалізації та не повинно відображатися у підписах, що використовуються на D-Bus. GVariant використовує ці типи кодів для кодування умовних викликів.
|=====

== Маршалінг (дротовий формат)

D-Bus визначає маршовий формат для своєї системи типів, який використовується у повідомленнях D-Bus. Це не єдиний можливий формат маршалінгу для системи типів: наприклад, `GVariant` (частина GLib) повторно використовує систему типів D-Bus, але реалізує альтернативний формат маршалінгу.

=== Порядок байт та вирівнювання

Беручи підпис типу, блок байтів може бути перетворений в типізовані значення. У цьому розділі описано формат блоку байтів. Проблеми з порядком і вирівнюванням байтів обробляються однаково для всіх типів D-Bus.

Блок байтів має пов'язаний порядок байт. Порядок байтів повинен бути виявлений якимось чином; для повідомлень D-Bus порядок байтів є частиною заголовка повідомлення, як описано в розділі під назвою "Формат повідомлення". Поки припустимо, що байтовий порядок є відомий як біг- або літл-ендіан.

Кожне значення в блоці байтів вирівнюється "природним чином", наприклад, 4-байтні значення вирівнюються до 4-байтної межі, а 8-байтові - до 8-байтової межі. Межі обчислюються в глобальному масштабі щодо першого байту повідомлення. Для правильного вирівнювання значення може знадобитися прокладка вирівнювання перед значенням. Підкладка вирівнювання завжди повинна бути мінімально необхідною прокладкою, щоб правильно вирівняти наступне значення; і вона завжди повинна складатися з нульових байтів. Прокладка вирівнювання не повинна залишатися неініціалізованою (вона не може містити сміття), і не слід використовувати більше прокладки, ніж потрібно.

Як виняток від природного вирівнювання, значення `STRUCT` та `DICT_ENTRY` завжди вирівнюються до 8-байтової межі, незалежно від вирівнювання їх вмісту.

=== Маршалінг основних типів

Для маршалінгу та демаршалінгу фіксованих типів ви просто зчитуєте одне значення з блоку даних, що відповідає кожному коду типу в підписі. Всі підписані цілі значення кодуються в доповнення двох, значення `DOUBLE` - IEEE 754 з плаваючою точкою подвійної точності, а значення `BOOLEAN` кодуються в 32 біти (з яких використовується лише найменш значущий біт).

Рядкоподібні типи (`STRING`, `OBJECT_PATH` і `SIGNATURE`) усі розміщуються як беззнакове ціле фіксованої довжини `n`, що дає довжину змінної частини, а потім `n` ненульових байтів тексту UTF-8, а потім один нульовий байт (`nul`) байт, який не вважається частиною тексту. Вирівнювання рядкового типу є таким же, як і вирівнювання `n`: будь-яка прокладка, необхідна для `n`, з'являється безпосередньо перед самим `n`. Ніколи не існує жодного вирівнювання між `n` та текстом рядка, або між текстом рядка та кінцевим нулем. Вирівнювання наступного значення в повідомленні (якщо воно є) починається після кінцевого нуля.

Для типів `STRING` і `OBJECT_PATH` `n` кодується в 4 байти (`UINT32`), що веде до 4-байтового вирівнювання. Для типу `SIGNATURE` `n` кодується як один байт (`UINT8`). В результаті вирівнювання прокладки ніколи не потрібно перед `SIGNATURE`.

Наприклад, якщо поточне положення є кратним 8 байтів від початку повідомлення літл-ендіван повідомлення, рядки `"foo"`, `"+"` і `"bar"` будуть серіалізовані в послідовності наступним чином:

0x03 0x00 0x00 0x00   кратне 4, вирівнювання не потрібне, довжина ‘foo’ = 3
0x66 0x6f 0x6f        ‘foo’
0x00                  заключний nul
0x01 0x00 0x00 0x00   кратне 4, вирівнювання не потрібне, довжина ‘+’ = 1
0x2b                  ‘+’
0x00                  заключний nul
0x00 0x00             2 байти вирівнювання
0x03 0x00 0x00 0x00   довжина ‘bar’ = 3
0x62 0x61 0x72        ‘bar’
0x00                  заключний nul
        
=== Контейнери маршалінга

Масиви розташовуються як `UINT32 n`, що задає довжину даних масиву в байтах з подальшим вирівнюванням до межі вирівнювання типу масиву з подальшими `n` байтами елементів масиву, маршованих послідовно. `n` не включає прокладку після довжини або будь-яку прокладку після останнього елемента, тобто `n` слід ділити на кількість елементів у масиві.

Наприклад, якщо поточне положення в повідомленні кратне 8 байтам, а порядок байтів є біг-ендіан, масив, що містить лише 64-бітове ціле число 5, буде розміщено як:

00 00 00 08               n = 8 байт даних
00 00 00 00               вирівнювання на межу 8 байтів
00 00 00 00  00 00 00 05  перший елемент = 5
        
Масиви мають максимальну довжину, визначену як 2 в 26-й ступені, 67108864 (64 МБ). Впровадження не повинно надсилати або приймати масиви, що перевищують цю довжину.

Структури та записи мап розміщуються так само, як і їхній вміст, але їх вирівнювання завжди до 8-байтової межі, навіть якщо їх вміст, як правило, менш суворо вирівняний.

Варіанти маршируються як `SIGNATURE` вмісту (який повинен бути єдиним завершеним типом), а потім слідує маршальоване значення з типом, заданим цим підписом. Варіант має те ж однобайтове вирівнювання, що і підпис, що означає, що вирівнювання перед варіантом ніколи не потрібне. Використання варіантів не повинно призводити до того, що загальна глибина повідомлення не перевищує 64, включаючи інші типи контейнерів, такі як структури. (Див. Дійсні підписи).

Враховуючи все це, типи розміщуються на дроті наступним чином:

.Короткий огляд маршалінгу D-Bus
[width="80%",cols="3,6,2",options="header"]
|=====
| Звичайна назва | Кодування | вирівнювання
| INVALID | Не маршулюється          | N/A
| BYTE	  | Поодинокий 8-бітний байт | 1
| BOOLEAN	| Як для UINT32, але значення лише 0 та 1 |	4
| INT16   |	16-бітне знакове ціле в відповідному порядку байт | 2
| UINT16	| 16-бітне беззнакове ціле в відповідному порядку байт | 2
| INT32	  | 32-бітне знакове ціле в відповідному порядку байт | 4
| UINT32	| 32-бітне беззнакове ціле в відповідному порядку байт | 4
| INT64	  | 64-бітне знакове ціле в відповідному порядку байт | 8
| UINT64	| 64-бітне беззнакове ціле в відповідному порядку байт | 8
| DOUBLE	| 64-бітове IEEE 754 подвійної точності | 8
| STRING	| UINT32 в якості довжини рядка в байтах, виключаючи завершальний nul, за яким ідуть дані вказаної довжини і заключиний байт nul |4 (для довжини)
| OBJECT_PATH |	Те саме, що STRING, за виключенням того, що рядок має бути валідним шляхом(див вище) | 4 (для довжини)
| SIGNATURE   |	Те саме, що STRING, за виключнням того, що довжина складає один байт (тобто сигнатура має максимальну довжину 255), і вміст має бути валідним підписом (див вище) |	1
| ARRAY	      | UINT32, що дає довжину масива даних в байтах, за яким іде вирівнювання до межі згідно елементам типу, за яким ідуть самі елементи |	4 (для довожини)
| STRUCT	    | Структура має починатись з 8-байтової межі, безвідносно до полів. Значення структури складається з кожного з полів, маршальованих послідовно, починаючи з цієї 8-бітної межі | 8
| VARIANT	    | Маршальована SIGNATURE єдиного повного типу, за яким іде значення типу, вказаноого в сигнатурі |	1 (вирівнювання сигнатури)
| DICT_ENTRY	| Ідентично до STRUCT |	8
| UNIX_FD	    | 32-бітне беззнакове ціле в відповідному порядку байт. Справжні дескриптори файлів мають передавати по іншим каналам, специфічним для платформи. На дроті значення цього типу зберігають індекс файлового дескриптора в масиві дескрипторів, що супроводжує повідомлення | 4
|=====

== Протокол повідомлення

Повідомлення складається із заголовка та тіла. Якщо ви вважаєте повідомлення як пакет, заголовок - це адреса, а тіло - вміст пакета. Система доставки повідомлень використовує інформацію заголовка, щоб визначити, куди надсилати повідомлення та як його інтерпретувати; одержувач інтерпретує тіло повідомлення.

Тіло повідомлення складається з нуля або більше аргументів, які є типізовані значення, такі як ціле число або байтовий масив.

І заголовок, і тіло використовують систему та формат типу D-Bus для серіалізації даних.

=== Формат повідомлення

Повідомлення складається із заголовка та тіла. Заголовок - це блок значень із фіксованою підписом та значенням. Тіло - це окремий блок значень з підписом, зазначеним у заголовку.

Довжина заголовка повинна бути кратною 8, що дозволяє тілу починатись на 8-байтовій межі при зберіганні всього повідомлення в одному буфері. Якщо заголовок природним чином не закінчується на 8-байтовій межі, слід додати до 7 байтів ініціалізованої нулями прокладки вирівнювання.

Тіло повідомлення не обов'язково повинно закінчуватися на 8-байтовій межі.

Максимальна довжина повідомлення, включаючи заголовок, прокладку вирівнювання заголовка та тіло, становить від 2 в 27 ступені, або 134217728 (128 МБ). Програми не повинні надсилати та приймати повідомлення, що перевищують цей розмір.

Підпис заголовка такий:

    `yyyyuua(yv)`
        
Більш зрозуміло це:

`BYTE`, `BYTE`, `BYTE`, `BYTE`, `UINT32`, `UINT32`, `ARRAY` з `STRUCT` з (`BYTE`,`VARIANT`)
        
Ці байти мають такі значення:

[width="80%",cols="2,10",options="header"]
|=====
| Значення | Опис
| BYTE-1 | Прапор порядку байт; ASCII 'l' для little-endian або ASCII 'B' для big-endian. І заголовок, і тіло дотримуються цього впорядкування.
| BYTE-2 | Тип повідомлення. Невідомі типи потрібно ігнорувати. Нині визначені типи описані нижче.
| BYTE-3 | Побітові АБО прапори. Невідомі прапори потрібно ігнорувати. Нині визначені прапори описані нижче.
| BYTE-4 | Основна версія протоколу програми надсилання. Якщо основна версія протоколу приймаючої програми не збігається, програми не зможуть спілкуватися, і з'єднання D-Bus потрібно відключити. Основна версія протоколу для цієї версії специфікації - 1.
| UINT32-1 | Довжина в байтах тіла повідомлення, починаючи з кінця заголовка. Заголовок закінчується після вирівнювання до 8 байт.
| UINT32-2 | Послідовність цього повідомлення, що використовується відправником як cookie для ідентифікації відповіді, що відповідає цьому запиту. Значення не повинно бути нульовим.
| ARRAY of STRUCT of (BYTE,VARIANT) | Масив із нуля чи більше полів заголовка, де байт - код поля, а варіант - значення поля. Тип повідомлення визначає, які поля обов’язкові для заповнення.
|===== 

Типи повідомлень, які можуть відображатися у другому байті заголовка, є:

[width="80%",cols="2,1,10",options="header"]
|=====
| Умовна назва  | Десяткове значення | Опис
| INVALID       |	0	| Невалідний тип.
| METHOD_CALL	  | 1	| Метод виклику. Цей тип повідомлення може запропонувати відповідь.
| METHOD_RETURN |	2	| Відповідь методу із поверненими даними.
| ERROR	        | 3 |	Помилка відповіді. Якщо перший аргумент існує і є рядком, це повідомлення про помилку.
| SIGNAL	      | 4 | Випромінювання сигналу.
|===== 

Прапори, які можуть з’явитися в третьому байті заголовка:

[width="80%",cols="2,1,10",options="header"]
|=====
| Умовне найменування | Шестнадцяте значення | Опис
|=====
| NO_REPLY_EXPECTED |	0x1	| Це повідомлення не очікує відповіді чи помилки, навіть якщо воно має тип, який може мати відповідь; відповідь слід опустити. Зауважте, що METHOD_CALL - єдиний тип повідомлення, визначений у цій специфікації, який може очікувати відповіді, тому наявність або відсутність цього прапора в інших трьох типах повідомлень, які на даний момент задокументовані, є безглуздим: відповіді на ці типи повідомлень не надсилаються, присутній цей прапор чи ні.
| NO_AUTO_START |	0x2 |	У відповідь на це повідомлення шина не повинна запускати власника імені призначення.
| ALLOW_INTERACTIVE_AUTHORIZATION |	0x4	|
Цей прапор може бути встановлений на повідомленні про виклик методу, щоб повідомити приймаючу сторону, що абонент готовий чекати інтерактивної авторизації, що може зайняти значний час для його завершення. Наприклад, якщо цей прапор встановлений, було б доцільно запитувати користувача про наявність паролів або підтвердження через Polkit або подібний фреймворк.
|=====

Останній прапор корисний лише тоді, коли непривілейований код викликає виклик більш привілейованого методу та розгорнутий фреймворк авторизації, який дозволяє можливо інтерактивну авторизацію. Якщо такий фреймворк не розгорнутий, це не має ефекту. Цей прапор не повинен встановлюватися за замовчуванням реалізацією клієнта. Якщо він встановлений, абонент повинен також встановити відповідний тривалий час очікування на виклик методу, щоб переконатися, що взаємодія з користувачем може завершитися. Цей прапор дійсний лише для повідомлень про виклики методу, інакше він ігнорується.

Взаємодія, яка відбувається як частина ефекту викликаного методу, виходить за межі цього прапора, навіть якщо його також можна охарактеризувати як автентифікацію або авторизацію. Наприклад, у виклику методу, який спрямовує службу управління мережею на спробу підключення до віртуальної приватної мережі, цей прапор повинен контролювати те, як служба управління мережею приймає рішення "чи дозволяється користувачеві змінювати конфігурацію системної мережі?", Але це не повинно впливати на те, як чи взаємодіє служба управління мережею з користувачем для отримання облікових даних, необхідних для доступу до VPN.

Якщо цей прапор не встановлений під час виклику методу, і служба визначає, що запитувана операція не дозволена без інтерактивного авторизації, але вона може бути дозволена після успішного інтерактивного авторизації, вона може повернути помилку `org.freedesktop.DBus.Error.InteractiveAuthorizationRequired`.

Відсутність цього прапора не гарантує, що інтерактивна авторизація не застосовуватиметься, оскільки існуючі сервіси, які попередньо встановили цей прапор, вже можуть використовувати інтерактивну авторизацію. Однак існуючі API D-Bus, які використовуватимуть інтерактивну авторизацію, повинні документувати, що виклик може зайняти більше часу, ніж зазвичай, а нові D-Bus API повинні уникати інтерактивної авторизації за відсутності цього прапора.

==== Поля заголовків

Масив в кінці заголовка містить поля заголовка, де кожне поле є 1-байтовим кодом поля, за яким слідує значення поля. Заголовок повинен містити необхідні поля заголовка для свого типу повідомлення та нуль або більше будь-яких необов’язкових полів заголовка. Майбутні версії цієї специфікації протоколу можуть додавати нові поля. Впровадження не повинні вигадувати власні поля заголовків; тільки зміни цієї специфікації можуть вводити нові поля заголовка.

Якщо реалізація бачить код поля заголовка, якого не очікує, вона повинна прийняти та проігнорувати це поле, оскільки це буде частиною нової (але сумісної) версії цієї специфікації. Це стосується також відомих полів заголовка, що з’являються у несподіваних повідомленнях, наприклад: якщо сигнал має серійну відповідь, його слід ігнорувати, навіть коли це не має значення для цієї версії специфікації.

Однак реалізації не повинні надсилати або приймати відомі поля заголовка з неправильним типом, збереженим у значенні поля. Так, наприклад, повідомлення з полем `INTERFACE` типу `UINT32` вважатиметься пошкодженим.

Реалізації сервера, які можуть передавати повідомлення від одного взаємно недовірливого клієнта до іншого, наприклад шина повідомлень, повинні видаляти поля заголовка, які сервер не розпізнає. Однак клієнт повинен припустити, що сервер цього не зробив, якщо у нього немає доказів протилежного, наприклад, перевіривши функцію шини повідомлень `HeaderFiltering`.

У цю специфікацію в майбутньому можуть бути додані нові поля заголовків, керовані шиною повідомлень (подібними до `SENDER`). Такі поля повідомлень зазвичай додаються лише до повідомлень, які будуть доставлені клієнтові, який спеціально їх запитував (наприклад, за допомогою виклику якогось методу), а шина повідомлень повинна видаляти ці заголовкові поля з усіх інших повідомлень, які вони ретранслюють. Цей принцип проектування виконує дві основні цілі. Перше - уникати зайвої пам'яті та пропускної здатності при доставці повідомлень клієнтам, які не зацікавлені у нових полях заголовка. Інша - дати клієнтам привід викликати метод, який запитує ці повідомлення (інакше клієнти не працюють). Це бажано, тому що перегляд відповіді на виклик цього методу є природним способом перевірити, чи шина повідомлень гарантує відфільтрувати підроблені поля заголовка, які могли бути надіслані шкідливими кореспондентами.

Ось визначені в даний час поля заголовка:

[width="80%",cols="2,1,2,4,10",options="header"]
|=====
| Умовне найменування | Десятковий код | Тип | Блок | Опис
| INVALID   |	0 |	N/A	| не дозволено | Недійсне ім'я поля (помилка, якщо вона з’являється в повідомленні)
| PATH      |	1	| OBJECT_PATH |	METHOD_CALL, SIGNAL |	Об'єкт, на який потрібно надіслати виклик, або від якого випромінюється сигнал. Спеціальний шлях `/org/freedesktop/DBus/Local` зарезервований; реалізації не повинні надсилати повідомлення з цим шляхом, і контрольна реалізація демона шини відключить будь-яку програму, яка намагається це зробити. Цим полем заголовка керує відправник повідомлення.
| INTERFACE |	2 |	STRING | SIGNAL |	Інтерфейс для виклику методу, або від якого випромінюється сигнал. Необов’язково для викликів методів, необхідне для сигналів. Спеціальний інтерфейс `org.freedesktop.DBus.Local` зарезервований; реалізації не повинні надсилати повідомлення з цим інтерфейсом, і контрольна реалізація демона шини відключить будь-яку програму, яка намагається це зробити. Цим полем заголовка керує відправник повідомлення.
| MEMBER    |	3	| STRING | METHOD_CALL, SIGNAL | Член, або ім'я методу, або ім'я сигналу. Цим полем заголовка керує відправник повідомлення.
| ERROR_NAME | 4 |	STRING | ERROR | Назва помилки, що сталася, для помилок
| REPLY_SERIAL | 5 | UINT32 | ERROR, METHOD_RETURN | Серійний номер повідомлення, на яке це повідомлення є відповіддю. (Серійний номер є другим UINT32 у заголовку.) Це поле заголовка контролюється відправником повідомлення.
| DESTINATION | 6 |	STRING | опціональне | Назва з'єднання, яке призначене для цього повідомлення. Зазвичай це поле має значення лише в поєднанні з шиною повідомлень (див. Розділ «Специфікація шини повідомлення»), але інші сервери можуть визначати для них свої значення. Цим полем заголовка керує відправник повідомлення.
| SENDER    | 7 |	STRING | опціональне |
Унікальна назва з'єднання для надсилання. Зазвичай це поле має значення лише в поєднанні з шиною повідомлень, але інші сервери можуть визначати для них свої значення. На шині повідомлень це поле заголовка керурється шиною повідомлень, тому воно настільки ж надійне, як і сама шина повідомлень. В іншому випадку цим заголовком керує відправник повідомлення, якщо тільки немає позадіапазонної інформації, яка вказує на інше.
| SIGNATURE |	8 |	SIGNATURE |	опціональне | Підпис органу повідомлення. Якщо пропущено, передбачається порожній підпис "" (тобто тіло має бути 0-довжину). Цим полем заголовка керує відправник повідомлення.
| UNIX_FDS	| 9	| UINT32 | опціональне | Кількість дескрипторів файлів Unix, які супроводжують повідомлення. Якщо пропущено, передбачається, що жодні дескриптори файлів Unix не супроводжують повідомлення. Фактичні дескриптори файлів повинні бути передані через механізм, визначений для платформи поза межами діапазону. Вони повинні бути надіслані одночасно з частиною самого повідомлення. Вони можуть не надсилатися до того, як буде передано перший байт самого повідомлення або після останнього байта самого повідомлення. Цим полем заголовка керує відправник повідомлення.
|=====

== Дійсні імена

Різні імена в повідомленнях D-Bus мають деякі обмеження.

Максимальна довжина імені - 255, що стосується імен шини, інтерфейсів та членів.

=== Імена інтерфейсу

Інтерфейси мають назви типу `STRING`, тобто вони повинні бути дійсними UTF-8. Однак існують також деякі додаткові обмеження, які стосуються саме імен інтерфейсу:

* Імена інтерфейсу складаються з 2 або більше елементів, розділених символом крапки ('.'). Усі елементи повинні містити принаймні один символ.
* Кожен елемент повинен містити лише символи ASCII "[A-Z] [a-z] [0-9] _" і не повинен починатися з цифри.
* Імена інтерфейсу не повинні перевищувати максимальну довжину імені.
* Імена інтерфейсу повинні починатися зі зворотного доменного імені DNS автора інтерфейсу (малі регістри), як імена інтерфейсів на Java. За іншою частиною назви інтерфейсу прийнято складатися зі слів, що працюють разом, з початкових великих літер на всіх словах ("CamelCase"). Можна використовувати кілька рівнів ієрархії. Також корисно включити в назву основну версію інтерфейсу та збільшити її, якщо будуть внесені несумісні зміни; таким чином, один об’єкт може реалізувати паралельно кілька версій інтерфейсу, якщо це необхідно. 

Наприклад, якщо власник `example.com` розробляє API D-Bus для музичного плеєра, він може визначити інтерфейси під назвою `com.example.MusicPlayer1`, `com.example.MusicPlayer1.Track` та `com.example.MusicPlayer1.Seekable`.

Якщо доменне ім’я DNS автора містить символи дефісу / мінусу ('-'), які не дозволені в іменах інтерфейсу D-Bus, їх слід замінити на підкреслення. Якщо доменне ім'я DNS містить цифру, що безпосередньо після крапки ('.'), (що також не дозволено в назвах інтерфейсів), ім'я інтерфейсу повинно додати підкреслення перед цією цифрою. Наприклад, якщо власник `7-zip.org` визначив інтерфейс для поза-процессових плагінів, він може бути названий `org._7_zip.Plugin`.

D-Bus не розрізняє поняття, які б в Java називались класами та інтерфейсами: обоє можна ідентифікувати на D-Bus за назвою інтерфейсу.

=== Назви шин

З'єднання мають одне або кілька імен шин, пов'язаних з ними. З'єднання має саме одне ім'я шини, яке є унікальним іменем з'єднання. Унікальна назва з'єднання залишається зі з’єднанням протягом усього життя. Назва шини має тип `STRING`, це означає, що вона повинна бути дійсною UTF-8. Однак існують також деякі додаткові обмеження, які стосуються саме імен шин:

* Імена шин, що починаються з символу двокрапки (':'), є унікальними іменами з'єднання. Інші імена шин називаються гарно відомими іменами шин.
* Імена шин складаються з 1 або більше елементів, розділених символом періоду ('.'). Усі елементи повинні містити принаймні один символ.
* Кожен елемент повинен містити лише символи ASCII "[A-Z] [a-z] [0-9] _-", при цьому "-" не рекомендується використовувати в нових іменах шин. Тільки елементи, що є частиною унікальної назви з'єднання, можуть починатися з цифри, елементи в інших назвах шин не повинні починатися з цифри.
* Імена шин повинні містити принаймні один символ "." (крапку) (і, таким чином, щонайменше два елементи).
* Назви шин не повинні починатися з символа "." (крапки).
* Імена шин не повинні перевищувати максимальну довжину імені.

Зверніть увагу, що символ дефісу ('-') дозволений у назвах шин, але не в назвах інтерфейсу. Це також проблематично або заборонено в різних специфікаціях та API, що посилаються на D-Bus, такі як ідентифікатори додатків Flatpak, інтерфейс `DBusActivatable` у специфікації вводу на робочий стіл та домовленість, що `main` інтерфейс програми та шлях об'єкта нагадують його назву шини. Щоб уникнути ситуацій, що вимагають обробки в окремих випадках, рекомендується, щоб нові імена D-Bus послідовно замінювали дефіси на підкреслення.

Як імена інтерфейсу, відомі імена шин повинні починатися із зворотного доменного імені DNS автора інтерфейсу (в нижньому реєстрі), а для решти відомого імені шини звичайно складатися зі слів, що працюють разом , з початковими великими літерами. Як і для назв інтерфейсів, включаючи номер версії у відомих іменах шини - це гарна ідея; можливо мати відоме ім'я шини для декількох версій одночасно, якщо потрібна зворотна сумісність.

Як і у випадку з іменами інтерфейсів, якщо доменне ім’я DNS автора містить символи дефісу/мінусу, їх слід замінити на підкреслення, а якщо вони містять провідні цифри, їх слід уникнути, попередньо підставивши підкреслення. Наприклад, якщо власник `7-zip.org` використовував ім'я D-Bus для програми архівації, воно може бути названо `org._7_zip.Archiver`.

Якщо відоме ім'я шини передбачає наявність "main" інтерфейсу, цьому "main" інтерфейсу часто присвоюється те саме ім'я, що й відоме ім'я шини, і розташоване у відповідному об'єктному шляху. Наприклад, якщо власник `example.com` розробляє API D-Bus для музичного плеєра, він може визначити, що будь-яка програма, яка має відоме ім'я `com.example.MusicPlayer1`, повинна мати об'єкт на шляху об'єкта `/com/example/MusicPlayer1`, який реалізує інтерфейс `com.example.MusicPlayer1`.

=== Імена членів

Імена члена (тобто методу чи сигналу):

* Повинені містити лише символи ASCII "[A-Z] [a-z] [0-9] _" і не може починатися з цифри.
* Не повинні містити символ "." (крапку).
* Не повинні перевищувати максимальну довжину імені.
* Повинні бути не менше 1 байта.

Імена членів на D-Bus звичайно складаються з заглавних слів без розділових знаків ("верблюд-реєстр"). Імена методів зазвичай мають бути дієсловами, такими як `GetItems`, а імена сигналів зазвичай мають бути описом події, наприклад, `ItemChanged`.

=== Імена помилок

Імена помилок мають ті самі обмеження, що імена інтерфейсу.

Імена помилок мають ті самі умови імен, що імена інтерфейсів, і часто містять `.Error.`; наприклад, власник `example.com` може визначити помилки `com.example.MusicPlayer1.Error.FileNotFound` та `com.example.MusicPlayer1.Error.OutOfMemory`. Помилки, визначені самою D-Bus, такі як `org.freedesktop.DBus.Error.Failed`, дотримуються подібної схеми.

== Типи повідомлень

Кожен із типів повідомлень (`METHOD_CALL`, `METHOD_RETURN`, `ERROR` та `SIGNAL`) має власні очікувані умови використання та поля заголовка. У цьому розділі описані ці умовності.

=== Виклики методів 

Деякі повідомлення викликають операцію над віддаленим об'єктом. Вони називаються повідомленнями виклику методу і мають тег типу `METHOD_CALL`. Такі повідомлення природно відображають методи на об'єктах типової програми.

Повідомлення виклику методу повинно мати поле заголовка `MEMBER`, що вказує назву методу. Необов'язково, повідомлення містить поле `INTERFACE`, що дає інтерфейс, до якого входить метод. Наполегливо рекомендується включати `INTERFACE` у всі повідомлення виклику методів.

За відсутності поля `INTERFACE`, якщо два або більше інтерфейсів на одному об’єкті мають метод з тим же ім'ям, не визначено, який із цих методів буде викликаний. Реалізація може вибрати або повернути помилку, або доставити повідомлення так, ніби воно має довільно один із цих інтерфейсів.

У деяких ситуаціях (наприклад, добре відома системна шина) повідомлення фільтруються через список контролю доступу, зовнішній для віддаленої реалізації об'єкта. Якщо цей фільтр відхиляє певні повідомлення, зважаючи їх інтерфейс, або приймає лише повідомлення до певних інтерфейсів, він також повинен відхиляти повідомлення, які не мають `INTERFACE`: інакше шкідливі програми можуть використовувати це для обходу фільтра.

Повідомлення виклику методу також включають поле `PATH`, яке вказує на об'єкт, на якому слід викликати метод. Якщо виклик проходить через шину повідомлень, у повідомленні також буде поле `DESTINATION` із зазначенням імені з'єднання для отримання повідомлення.

Коли програма обробляє повідомлення виклику, потрібно повернути відповідь. Відповідь ідентифікується полем заголовка `REPLY_SERIAL` із зазначенням серійного номера `METHOD_CALL`, на який іде відповідь. Відповідь може мати один з двох типів; або `METHOD_RETURN` або `ERROR`.

Якщо відповідь має тип `METHOD_RETURN`, аргументами відповіді є повернене значення (або декілька) або "вихідні параметри" виклику методу. Якщо у відповіді введено тип `ERROR`, тоді було кинуто "виняток", і виклик невдалий; значення повернення не буде надано. Немає сенсу надсилати кілька відповідей на виклик одного і того ж методу.

Навіть якщо виклик методу не має зворотних значень, потрібна відповідь `METHOD_RETURN`, тож абонент дізнається, що метод успішно оброблений.

Повідомлення відповіді `METHOD_RETURN` або `ERROR` повинно мати поле заголовка `REPLY_SERIAL`.

Якщо у повідомленні `METHOD_CALL` є прапор `NO_REPLY_EXPECTED`, програма, що отримує метод, не повинна надсилати відповідь (незалежно від того, чи була б відповідь `METHOD_RETURN` чи `ERROR`).

Якщо повідомлення не містить прапор NO_AUTO_START, якщо ім'я призначення не існує, тоді програма до власного імені призначення буде запущена (активована) до доставки повідомлення. Дивіться розділ «Служба запуску шини повідомлень (активація)». Повідомлення буде зберігатися до успішного запуску нової програми або не вдалося її запустити; у разі відмови буде повернута помилка. Цей прапор є релевантним лише в контексті шини повідомлень, він ігнорується під час спілкування один на один без проміжної шини.

=== Відображення методів на природні API

API для D-Bus можуть відображати виклики методу на виклик методу в певній мові програмування, наприклад, C++, або можуть зіставити виклик методу, записаний в IDL, на повідомлення D-Bus.

В таких інтерфейсах API аргументи методу часто називають `in` (що має на увазі відправлене в `METHOD_CALL`) або `out` (що означає, що повертається у `METHOD_RETURN`). Деякі API, такі як CORBA, також мають аргументи `inout`, які надсилаються та отримуються, тобто виклик передає значення, яке змінюється. Вказаний на D-Bus аргумент `inout` еквівалентний аргументу `in`, а потім аргументу `out`. Ви не можете передавати речі "за посиланням" по дроту, тому `inout` - це суто ілюзія API, що працює в одному процесі.

Враховуючи метод з нуль або одним зворотним значенням, а потім нульом або більше аргументами, де кожен аргумент може бути `in`, `out` або `inout`, абонент будує повідомлення, додаючи кожне `in` або `inout` аргумент, по порядку. Аргументи `out` не представлені у повідомленні абонента.

Одержувач будує відповідь, додаючи спочатку повернене значення, якщо воно є, а потім кожен аргумент `out` або `inout` в порядку. Аргументи `in` не представлені у відповіді.

Відповіді на помилки зазвичай відображаються на винятки на мовах, які мають винятки.

При переході від природних API до D-Bus, можливо, приємно автоматично відображати конвенції іменування D-Bus (`FooBar`) на власні конвенції, такі як `fooBar` або `foo_bar`. Це нормально, доки ви можете сказати, що нативним API є той, який був спеціально написаний для D-Bus. Це має найбільш сенс при написанні реалізації об'єктів, які будуть експортовані по шині. Проксі-сервери об'єктів, які використовуються для виклику віддалених об'єктів D-Bus, ймовірно, потребують можливості викликати будь-який метод D-Bus, і, таким чином, магічне відображення імен, як це, може стати проблемою.

Ця специфікація не вимагає нічого від нативних прив’язок API; попереднє є лише запропонованою умовою щодо узгодженості зв'язків.

== Випромінювання сигналу

На відміну від викликів методів, на запити сигналу не відповідають. Випромінювання сигналу - це просто одне повідомлення типу `SIGNAL`. У ньому повинно бути три поля заголовка: `PATH`, що передає об'єкту сигнал, який випромінюється, плюс `INTERFACE` та `MEMBER`, що дають повноцінне ім'я сигналу. Заголовок `INTERFACE` необхідний для сигналів, хоча він не є обов'язковим для викликів методів.

== Помилки

Повідомленнями типу `ERROR` найчастіше відповідають на `METHOD_CALL`, але можуть бути повернені у відповідь на будь-яке повідомлення. Наприклад, шина повідомлень поверне помилку у відповідь на випромінювання сигналу, якщо шині не вистачає пам'яті для відправлення сигналу.

Помилка може мати будь-які аргументи, але якщо перший аргумент є `STRING`, це повинно бути повідомлення про помилку. Повідомлення про помилку може якимось чином реєструватися або показуватися користувачеві.

== Позначення в цьому документі

Цей документ використовує простий псевдо-IDL для опису конкретних викликів методу та сигналів. Ось приклад виклику методу:

----
org.freedesktop.DBus.StartServiceByName (in STRING name, in UINT32 flags, out UINT32 resultcode)
----

Це означає `INTERFACE` = `org.freedesktop.DBus`, `MEMBER` = `StartServiceByName`, аргументи `METHOD_CALL` - `STRING` і `UINT32`, аргумент `METHOD_RETURN` - `UINT32`. Пам'ятайте, що поле `MEMBER` не може містити жодного символа крапки ".", тому відомо, що остання частина імені в "IDL" - це ім'я члена.

У C ++ це може виглядати так:

[source,cpp]
----
unsigned int org::freedesktop::DBus::StartServiceByName (
  const char *name, unsigned int flags);
----

або однаково вірне, повернене значення може бути зроблено як аргумент:

[source,cpp]
----
void org::freedesktop::DBus::StartServiceByName (
  const char *name, unsigned int  flags, unsigned int *resultcode);
----

Це насправді залежить від того, як розробники API хочуть зробити це. Ви можете розробити API, де простір імен не використовувався в C ++, використовуючи STL або Qt, використовуючи `varargs` або що завгодно.

Сигнали записуються так:

----
org.freedesktop.DBus.NameLost (STRING name)
----

Сигнали не вказують `in` проти `out`, оскільки можливий лише один напрямок.

Не рекомендується особливо використовувати цей кульгавий псевдо-IDL у фактичних реалізаціях API; ви можете використовувати природну нотацію для мови, яку ви використовуєте, або, наприклад, ви можете використовувати COM або CORBA IDL.

== Недійсний протокол та розширення специфікації

З міркувань безпеки протокол D-Bus повинен бути чітко проаналізований та перевірений, за винятком визначених точок розширення. Будь-які недійсні порушення протоколу або специфікації повинні спричинити негайне припинення з'єднання без попереднього повідомлення. Винятки слід ретельно враховувати, наприклад виняток може бути гарантованим для добре зрозумілої ідіосинкразії широко розгорнутої реалізації. У випадках, коли інший кінець з'єднання на 100% довіряє і, як відомо, є дружнім, пропуск перевірки з міркувань продуктивності також може мати сенс у певних випадках.

Взагалі порушення вимог "обов'язково" у цій специфікації слід вважати можливими спробами використання безпеки, а порушення пропозицій "слід" вважати законними (хоча, можливо, вони можуть спричинити помилку в деяких випадках).

Наступні точки розширення вбудовані в D-Bus спеціально і не повинні розглядатися як недійсний протокол. Точки розширення призначені для використання майбутніми версіями цієї специфікації, вони не призначені для третіх сторін. На даний момент єдиним способом, яким третя сторона могла б розширити D-Bus, не порушуючи сумісності, було б ввести спосіб узгодити підтримку нових функцій як частину протоколу автентичності, використовуючи попередньо встановлені команди `EXTENSION_`. Ще не існує стандартного способу узгодження можливостей.

У протоколі аутентифікації (див. Розділ «Протокол автентифікації») невідомі команди призводять до помилки, а не до відключення. Це дозволяє в майбутньому розширити протокол. Команди, що починаються з `EXTENSION_`, зарезервовані для третіх сторін.

Протокол аутентифікації підтримує підключені механізми аутентифікації.

The address format (see the section called “Server Addresses”) supports new kinds of transport.

Повідомлення з невідомим типом (щось інше, ніж `METHOD_CALL`, `METHOD_RETURN`, `ERROR`, `SIGNAL`) ігноруються. Однак повідомлення невідомого типу все одно повинні бути добре сформовані так само, як відомі повідомлення. Вони все ще мають нормальний заголовок і тіло.

Поля заголовка з невідомим або несподіваним кодом поля повинні ігноруватися, хоча знову ж таки вони повинні бути добре сформовані.

Звичайно, можна додати нові стандартні інтерфейси (з новими методами та сигналами).

== Протокол аутентифікації

Перед тим, як розпочнеться потік повідомлень, дві програми повинні автентифікуватись. Для аутентифікації використовується простий текстовий протокол; цей протокол є профілем SASL і відображається досить безпосередньо із специфікації SASL. Кодування повідомлень НЕ використовується тут, а лише звичайні текстові повідомлення.

Using SASL in D-Bus requires that we define the meaning of non-empty authorization identity strings. When D-Bus is used on Unix platforms, a non-empty SASL authorization identity represents a Unix user. An authorization identity consisting entirely of ASCII decimal digits represents a numeric user ID as defined by POSIX, for example 0 for the root user or 1000 for the first user created on many systems. Non-numeric authorization identities are not required to be accepted or supported, but if used, they must be interpreted as a login name as found in the pw_name field of POSIX struct passwd, for example root, and normalized to the corresponding numeric user ID. For best interoperability, clients and servers should use numeric user IDs.
Використання SASL в D-Bus вимагає, щоб ми визначили значення непустих рядків ідентифікації авторизації. Якщо D-Bus використовується на платформах Unix, не порожній ідентифікатор авторизації SASL представляє користувача Unix. Ідентифікація авторизації, що складається повністю з десяткових цифр ASCII, являє числовий ідентифікатор користувача, визначений POSIX, наприклад 0 для кореневого користувача або 1000 для першого користувача, створеного у багатьох системах. Нечислові ідентифікатори авторизації не потрібно приймати або підтримувати, але якщо вони використовуються, вони повинні інтерпретуватися як ім’я для входу, як знайдене в полі pw_name POS-структури POSIX-структури passwd, наприклад, root, і нормалізується на відповідний числовий ідентифікатор користувача. Для кращої сумісності клієнти та сервери повинні використовувати числові ідентифікатори користувачів.

Якщо D-Bus використовується на платформах Windows, не порожній ідентифікатор авторизації SASL являє собою ідентифікатор безпеки Windows (SID) у його рядковій формі, наприклад `S-1-5-21-3623811015-3361044348-30300820-1013` для домену або локальний користувач комп'ютера або `S-1-5-18` для користувача `LOCAL_SYSTEM`. Користувальницькі імена користувачів, такі як адміністратор або `LOCAL_SYSTEM`, не використовуються в протоколі D-Bus.

У прикладах `C:` і `S:` вказують рядки, надіслані клієнтом і сервером відповідно. Клієнт надсилає перший рядок, і сервер повинен відповідати на кожен рядок із клієнта однорядковою відповіддю, за одним винятком: відповіді на команду `BEGIN` немає.

=== Огляд протоколу

The protocol is a `line`-based protocol, where each line ends with \r\n. Each line begins with an all-caps ASCII command name containing only the character range [A-Z_], a space, then any arguments for the command, then the \r\n ending the line. The protocol is case-sensitive. All bytes must be in the ASCII character set. Commands from the client to the server are as follows:
Протокол побудований на основі рядка, де кожен рядок закінчується на `\r\n`. Кожен рядок починається з назви команд ASCII з усіма символами, що містить лише діапазон символів `[A-Z_]`, пробіл, потім будь-які аргументи для команди, а потім `\r\n` закінчення рядка. Протокол враховує регістри. Усі байти повинні бути в наборі символів ASCII. Команди від клієнта до сервера наступні:

`AUTH [механізм] [початкова відповідь]`
`CANCEL`
`BEGIN`
`DATA <дані в hex кодуванні>` 
`ERROR [пояснення помилок, зрозумілих для людини]`
`NEGOTIATE_UNIX_FD`

Від сервера до клієнта є:

`REJECTED <розділений пробілом список назв механізмів>`
`ОК <GUID в hex версії>`
`DATA <дані в hex кодуванні>`
`ERROR [пояснення помилок, зрозумілих для людини]`
`AGREE_UNIX_FD`

Неофіційні розширення набору команд повинні починатися з літер `EXTENSION_`, щоб уникнути конфліктів з майбутніми офіційними командами. Наприклад, `EXTENSION_COM_MYDOMAIN_DO_STUFF`.

=== Спеціальні облікові дані, що передають нульовий байт

Відразу після підключення до сервера клієнт повинен надіслати єдиний нульовий байт. Цей байт може супроводжуватися інформацією про облікові дані в деяких операційних системах, які використовують `sendmsg()` з `SCM_CREDS` або `SCM_CREDENTIALS` для передачі облікових даних через  доменний сокет UNIX. Однак нульовий байт повинен бути надісланий навіть в інших типах сокета і навіть в операційних системах, які не потребують відправлення байта для передачі облікових даних. Текстовий протокол, описаний у цьому документі, починається після єдиного нульового байта. Якщо перший байт, отриманий від клієнта, не є нульовим байтом, сервер може відключити цього клієнта.

Нуль-байт у будь-якому контексті, крім початкового байта, є помилкою; протокол призначений лише для ASCII.

Вхідні дані, надіслані разом з нульовим байтом, можуть використовуватися із механізмом SASL `EXTERNAL`.

=== Команда AUTH

Команда AUTH відправляється клієнтом на сервер. Сервер відповідає з `DATA`, `OK` або `REJECTED`.

Якщо команда `AUTH` не має аргументів, це запит на перелік доступних механізмів. Сервер повинен відповісти командою `REJECTED`, у якій перераховані механізми, які він розуміє, або помилкою.

Якщо команда `AUTH` вказує механізм, а сервер підтримує згаданий механізм, сервер повинен почати обмін даними SASL відповідь-виклик з клієнтом за допомогою команд `DATA`.

Якщо сервер не підтримує механізм, заданий командою `AUTH`, він повинен надіслати або команду `REJECTED` з переліком механізмів, які він підтримує, або помилку.

Якщо аргумент [початкова відповідь] надано, він призначений для використання з механізмами, які не мають початкового виклику (або порожній початковий виклик), як би це було аргументом для початкової команди `DATA`. Якщо вибраний механізм має початковий виклик і [початкова відповідь] була надана, сервер повинен відхилити автентифікацію, відправивши `REJECTED`.

Якщо аутентифікація проходить успішно після обміну командами `DATA`, клієнту слід надіслати команду `ОК`.

=== Команда CANCEL

Команда `CANCEL` відправляється клієнтом на сервер. Сервер відповідає `REJECTED`.

У будь-який час до відправлення команди `BEGIN` клієнт може надіслати команду `CANCEL`. Після отримання команди `CANCEL` сервер повинен надіслати команду `REJECTED` і відмінити поточний обмін аутентифікацією.

=== Команда DATA

Команда `DATA` може надходити або від клієнта, або з сервера і просто містить шістнадцятковий блок даних для інтерпретації відповідно до використовуваного механізму SASL. Якщо її надіслав клієнт, сервер відповідає `DATA`, `OK` або `REJECTED`.

Деякі механізми SASL підтримують надсилання "порожнього рядка"; FIXME нам потрібен певний спосіб зробити це.

=== Команда BEGIN

Команда `BEGIN` відправляється клієнтом на сервер. Сервер не відповідає.

Команда `BEGIN` визнає, що клієнт отримав команду `ОК` від сервера і завершила будь-які переговори щодо функції, які він хоче зробити, і заявляє, що потік повідомлень вже починається.

Перший октет, отриманий сервером після `\r\n` команди `BEGIN` від клієнта, повинен бути першим октетом аутентифікованого/зашифрованого потоку повідомлень D-Bus.

На відміну від усіх інших команд, сервер не відповідає на команду `BEGIN` власною командою аутентифікації. Після `\r\n` відповіді на команду перед `BEGIN`, наступним октетом, отриманим клієнтом, повинен бути перший октет автентифікованого/зашифрованого потоку повідомлень D-Bus.

=== Команда REJECTED

Команда `REJECTED` надсилається сервером клієнту.

Команда `REJECTED` вказує на те, що поточний обмін аутентифікацією не вдався, і подальший обмін `DATA` є недоцільним. Зазвичай клієнт спробує інший механізм або намагається надати різні відповіді на виклики.

Необов'язково, команда `REJECTED` має аргументи розділеного проміжком списку доступних механізмів `auth`. Якщо сервер коли-небудь надає список підтримуваних механізмів, він повинен надавати той самий список кожного разу, коли він надсилає повідомлення відхилення. Клієнти можуть ігнорувати всі списки, отримані після першого.

=== Команда OK

Команда ОК надсилається сервером клієнту.

Команда ОК вказує на те, що клієнт був аутентифікований. Тепер клієнт може продовжити узгодження передачі дескриптора файлу Unix. Для цього він надсилає `NEGOTIATE_UNIX_FD` на сервер.

В іншому випадку клієнт повинен відповісти на команду `ОК`, надіславши команду `BEGIN` з подальшим потоком повідомлень або відключившись. Сервер не повинен приймати додаткові команди, використовуючи цей протокол після отримання команди `BEGIN`. Подальша комунікація буде потоком повідомлень D-Bus (необов'язково зашифрованих за домовленістю), а не цього протоколу.

Якщо немає переговорів, перший октет, отриманий клієнтом після `\r\n` команди `OK`, повинен бути першим октетом аутентифікованого/зашифрованого потоку повідомлень D-Bus. Якщо клієнт узгоджує передачу дескриптора файлу Unix, перший октет, отриманий клієнтом після `\r\n` відповіді `AGREE_UNIX_FD` або `ERROR`, повинен бути першим октетом аутентифікованого/зашифрованого потоку.

Команда `ОК` має один аргумент, який є GUID сервера. Див. Розділ "Адреси сервера" для отримання додаткових відомостей про GUID серверів.

=== Команда ERROR

Команда `ERROR` може бути надіслана в будь-якому напрямку. Якщо надісланий клієнтом, сервер відповідає `REJECTED`.

Команда `ERROR` вказує на те, що або сервер, або клієнт не розпізнали команди, не приймають цю команду в поточному контексті або не зрозуміли аргументи команди. Це дозволяє розширити протокол; клієнт або сервер можуть надсилати команди, присутні або дозволені лише в нових версіях протоколу, і якщо замість відповідної відповіді отримана помилка, поверніться до використання іншої техніки.

Якщо надсилається `ERROR`, сервер або клієнт, який надіслав помилку, повинні продовжуватись так, як ніби команда, що викликає помилку, ніколи не була отримана. Однак сервер або клієнт, які отримують помилку, повинні спробувати щось інше, ніж те, що спричинило помилку; якщо лише скасувати/відхилити аутентифікацію.

Якщо протокол D-Bus зміниться несумісно в якийсь майбутній час, програми, що реалізують новий протокол, ймовірно, зможуть перевірити підтримку нового протоколу, надіславши нову команду та отримавши `ERROR` від програми, які її не розуміють. Таким чином, функція `ERROR` протоколу `auth` - це випускний люк, який дозволяє нам узгоджувати розширення або зміни протоколу D-Bus у майбутньому.

=== Команда NEGOTIATE_UNIX_FD

Команда `NEGOTIATE_UNIX_FD` відправляється клієнтом на сервер. Сервер відповідає на відповідь `AGREE_UNIX_FD` або `ERROR`.

Команда `NEGOTIATE_UNIX_FD` вказує, що клієнт підтримує передачу дескриптора файлу Unix. Ця команда може бути надіслана лише після автентифікації з'єднання, тобто після отримання клієнтом `ОК`. Ця команда може бути надіслана лише на транспорті, які підтримують передачу дескриптора файлу Unix.

Після отримання `NEGOTIATE_UNIX_FD` сервер повинен відповісти або `AGREE_UNIX_FD`, або `ERROR`. Він відповідає на перший, якщо вибраний транспорт підтримує дескриптор файлу Unix, який проходить, і сервер підтримує цю функцію. Він повинен відповідати останньому, якщо транспорт не підтримує дескриптор файлу Unix, сервер не підтримує цю функцію або сервер вирішує не вмикати дескриптор файлів для передачі через безпеку чи інші причини.

=== Команда AGREE_UNIX_FD

Команда `AGREE_UNIX_FD` сервер надсилає клієнту.

Команда `AGREE_UNIX_FD` вказує, що сервер підтримує передачу дескриптора файлу Unix. Ця команда може бути надіслана лише після автентифікації з'єднання, і клієнт надіслав `NEGOTIATE_UNIX_FD` для включення передачі дескриптора файлу Unix. Ця команда може бути надіслана лише на транспорті, які підтримують передачу дескриптора файлу Unix.

Після отримання `AGREE_UNIX_FD` клієнт повинен відповісти `BEGIN` з подальшим потоком повідомлень або відключенням. Сервер не повинен приймати додаткові команди, використовуючи цей протокол після отримання команди `BEGIN`. Подальша комунікація буде потоком повідомлень D-Bus (необов'язково зашифрованих за домовленістю), а не цього протоколу.

=== Майбутні розширення

Можливі подальші розширення протоколу аутентифікації та переговорів. Для цього можуть бути введені нові команди. Якщо клієнт або сервер отримує невідому команду, він повинен відповідати помилкою і не вважати це фатальним. Нові команди можуть бути введені як до, так і після автентифікації, тобто як до, так і після команди ОК.

=== Приклади автентифікації

Малюнок 1. Приклад успішної EXTERNAL аутентифікації

----
            31303030 is ASCII decimal "1000" represented in hex, so
            the client is authenticating as Unix uid 1000 in this example.

            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: BEGIN
----


Малюнок 2. Приклад пошуку механізмів та вибору одного з них

----
            
            C: AUTH
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN
----


Малюнок 3. Приклад того, як клієнт відправляє невідому команду, потім повертається до звичайної auth

----
            532d312d352d3138 is the Windows SID "S-1-5-18" in hex,
            so the client is authenticating as Windows SID S-1-5-18
            in this example.

            C: FOOBAR
            S: ERROR
            C: AUTH EXTERNAL 532d312d352d3138
            S: OK 1234deadbeef
            C: BEGIN
----


Малюнок 4. Приклад сервера не підтримує початковий механізм аутентифікації

----
            C: AUTH EXTERNAL
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN
----

Малюнок 5. Приклад неправильного пароля чи подібного з подальшим успішним спробою

----
            C: AUTH EXTERNAL 736d6376
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: REJECTED
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN
----          

Малюнок 6. Приклад скасування skey та перезапуску

----
            C: AUTH EXTERNAL 32303438
            S: REJECTED KERBEROS_V4 SKEY
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: CANCEL
            S: REJECTED
            C: AUTH SKEY 7ab83f32ee
            S: DATA 8799cabb2ea93e
            C: DATA 8ac876e8f68ee9809bfa876e6f9876g8fa8e76e98f
            S: OK 1234deadbeef
            C: BEGIN
----          

Малюнок 7. Приклад успішної зовнішньої аутентифікації з успішним узгодженням передачі Unix FD

----
            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: NEGOTIATE_UNIX_FD
            S: AGREE_UNIX_FD
            C: BEGIN
----          

Малюнок 8. Приклад успішної зовнішньої аутентифікації з невдалим узгодженням передачі Unix FD

----
            C: AUTH EXTERNAL 31303030
            S: OK 1234deadbeef
            C: NEGOTIATE_UNIX_FD
            S: ERROR Not supported on this OS
            C: BEGIN
----          

== Діаграми стану аутентифікації

This section documents the auth protocol in terms of a state machine for the client and the server. This is probably the most robust way to implement the protocol.

Client states
To more precisely describe the interaction between the protocol state machine and the authentication mechanisms the following notation is used: MECH(CHALL) means that the server challenge CHALL was fed to the mechanism MECH, which returns one of

CONTINUE(RESP) means continue the auth conversation and send RESP as the response to the server;

OK(RESP) means that after sending RESP to the server the client side of the auth conversation is finished and the server should return "OK";

ERROR means that CHALL was invalid and could not be processed.

Both RESP and CHALL may be empty.

The Client starts by getting an initial response from the default mechanism and sends AUTH MECH RESP, or AUTH MECH if the mechanism did not provide an initial response. If the mechanism returns CONTINUE, the client starts in state WaitingForData, if the mechanism returns OK the client starts in state WaitingForOK.

The client should keep track of available mechanisms and which it mechanisms it has already attempted. This list is used to decide which AUTH command to send. When the list is exhausted, the client should give up and close the connection.

WaitingForData. 

Receive DATA CHALL

MECH(CHALL) returns CONTINUE(RESP) → send DATA RESP, goto WaitingForData
MECH(CHALL) returns OK(RESP) → send DATA RESP, goto WaitingForOK
MECH(CHALL) returns ERROR → send ERROR [msg], goto WaitingForData
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK

Receive ERROR → send CANCEL, goto WaitingForReject

Receive OK → authenticated, choose one:

send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive anything else → send ERROR, goto WaitingForData

WaitingForOK. 

Receive OK → authenticated, choose one:

send NEGOTIATE_UNIX_FD, goto WaitingForAgreeUnixFD
send BEGIN, terminate auth conversation (successfully)
Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK

Receive DATA → send CANCEL, goto WaitingForReject

Receive ERROR → send CANCEL, goto WaitingForReject

Receive anything else → send ERROR, goto WaitingForOK

WaitingForReject. 

Receive REJECTED [mechs] → send AUTH [next mech], goto WaitingForData or WaitingForOK

Receive anything else → terminate auth conversation, disconnect

WaitingForAgreeUnixFD.  By the time this state is reached, the client has already been authenticated.

Receive AGREE_UNIX_FD → enable Unix fd passing, send BEGIN, terminate auth conversation (successfully)

Receive ERROR → disable Unix fd passing, send BEGIN, terminate auth conversation (successfully)

Receive anything else → terminate auth conversation, disconnect

Server states
For the server MECH(RESP) means that the client response RESP was fed to the the mechanism MECH, which returns one of

CONTINUE(CHALL) means continue the auth conversation and send CHALL as the challenge to the client;

OK means that the client has been successfully authenticated;

REJECTED means that the client failed to authenticate or there was an error in RESP.

The server starts out in state WaitingForAuth. If the client is rejected too many times the server must disconnect the client.

WaitingForAuth. 

Receive AUTH → send REJECTED [mechs], goto WaitingForAuth

Receive AUTH MECH RESP

MECH not valid mechanism → send REJECTED [mechs], goto WaitingForAuth
MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect

Receive ERROR → send REJECTED [mechs], goto WaitingForAuth

Receive anything else → send ERROR, goto WaitingForAuth

WaitingForData. 

Receive DATA RESP

MECH(RESP) returns CONTINUE(CHALL) → send DATA CHALL, goto WaitingForData
MECH(RESP) returns OK → send OK, goto WaitingForBegin
MECH(RESP) returns REJECTED → send REJECTED [mechs], goto WaitingForAuth
Receive BEGIN → terminate auth conversation, disconnect

Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth

Receive ERROR → send REJECTED [mechs], goto WaitingForAuth

Receive anything else → send ERROR, goto WaitingForData

WaitingForBegin. 

Receive BEGIN → terminate auth conversation, client authenticated

Receive NEGOTIATE_UNIX_FD → send AGREE_UNIX_FD or ERROR, goto WaitingForBegin

Receive CANCEL → send REJECTED [mechs], goto WaitingForAuth

Receive ERROR → send REJECTED [mechs], goto WaitingForAuth

Receive anything else → send ERROR, goto WaitingForBegin

Authentication mechanisms
This section describes some authentication mechanisms that are often supported by practical D-Bus implementations. The D-Bus protocol also allows any other standard SASL mechanism, although implementations of D-Bus often do not.

EXTERNAL
The EXTERNAL mechanism is defined in RFC 4422 "Simple Authentication and Security Layer (SASL)", appendix A "The SASL EXTERNAL Mechanism". This is the recommended authentication mechanism on platforms where credentials can be transferred out-of-band, in particular Unix platforms that can perform credentials-passing over the unix: transport.

On Unix platforms, interoperable clients should prefer to send the ASCII decimal string form of the integer Unix user ID as the authorization identity, for example 1000. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 31303030 followed by \r\n.

On Windows platforms, clients that use the EXTERNAL mechanism should use the Windows security identifier in its string form as the authorization identity, for example S-1-5-21-3623811015-3361044348-30300820-1013 for a domain or local computer user or S-1-5-18 for the LOCAL_SYSTEM user. When encoded in hex by the authentication protocol, this will typically result in a line like AUTH EXTERNAL 532d312d352d3138 followed by \r\n.

DBUS_COOKIE_SHA1
DBUS_COOKIE_SHA1 is a D-Bus-specific SASL mechanism. Its reference implementation is part of the reference implementation of D-Bus.

This mechanism is designed to establish that a client has the ability to read a private file owned by the user being authenticated. If the client can prove that it has access to a secret cookie stored in this file, then the client is authenticated. Thus the security of DBUS_COOKIE_SHA1 depends on a secure home directory. This is the recommended authentication mechanism for platforms and configurations where EXTERNAL cannot be used.

Throughout this description, "hex encoding" must output the digits from a to f in lower-case; the digits A to F must not be used in the DBUS_COOKIE_SHA1 mechanism.

Authentication proceeds as follows:

The client sends the username it would like to authenticate as, hex-encoded.

The server sends the name of its "cookie context" (see below); a space character; the integer ID of the secret cookie the client must demonstrate knowledge of; a space character; then a randomly-generated challenge string, all of this hex-encoded into one, single string.

The client locates the cookie and generates its own randomly-generated challenge string. The client then concatenates the server's decoded challenge, a ":" character, its own challenge, another ":" character, and the cookie. It computes the SHA-1 hash of this composite string as a hex digest. It concatenates the client's challenge string, a space character, and the SHA-1 hex digest, hex-encodes the result and sends it back to the server.

The server generates the same concatenated string used by the client and computes its SHA-1 hash. It compares the hash with the hash received from the client; if the two hashes match, the client is authenticated.

Each server has a "cookie context," which is a name that identifies a set of cookies that apply to that server. A sample context might be "org_freedesktop_session_bus". Context names must be valid ASCII, nonzero length, and may not contain the characters slash ("/"), backslash ("\"), space (" "), newline ("\n"), carriage return ("\r"), tab ("\t"), or period ("."). There is a default context, "org_freedesktop_general" that's used by servers that do not specify otherwise.

Cookies are stored in a user's home directory, in the directory ~/.dbus-keyrings/. This directory must not be readable or writable by other users. If it is, clients and servers must ignore it. The directory contains cookie files named after the cookie context.

A cookie file contains one cookie per line. Each line has three space-separated fields:

The cookie ID number, which must be a non-negative integer and may not be used twice in the same file.

The cookie's creation time, in UNIX seconds-since-the-epoch format.

The cookie itself, a hex-encoded random block of bytes. The cookie may be of any length, though obviously security increases as the length increases.

Only server processes modify the cookie file. They must do so with this procedure:

Create a lockfile name by appending ".lock" to the name of the cookie file. The server should attempt to create this file using O_CREAT | O_EXCL. If file creation fails, the lock fails. Servers should retry for a reasonable period of time, then they may choose to delete an existing lock to keep users from having to manually delete a stale lock. [1]

Once the lockfile has been created, the server loads the cookie file. It should then delete any cookies that are old (the timeout can be fairly short), or more than a reasonable time in the future (so that cookies never accidentally become permanent, if the clock was set far into the future at some point). If no recent keys remain, the server may generate a new key.

The pruned and possibly added-to cookie file must be resaved atomically (using a temporary file which is rename()'d).

The lock must be dropped by deleting the lockfile.

Clients need not lock the file in order to load it, because servers are required to save the file atomically.

ANONYMOUS
The ANONYMOUS mechanism is defined in RFC 4505 "Anonymous Simple Authentication and Security Layer (SASL) Mechanism". It does not perform any authentication at all, and should not be accepted by message buses. However, it might sometimes be useful for non-message-bus uses of D-Bus.

Server Addresses
Server addresses consist of a transport name followed by a colon, and then an optional, comma-separated list of keys and values in the form key=value. Each value is escaped.

For example:

unix:path=/tmp/dbus-test
Which is the address to a unix socket with the path /tmp/dbus-test.

Value escaping is similar to URI escaping but simpler.

The set of optionally-escaped bytes is: [-0-9A-Za-z_/.\]. To escape, each byte (note, not character) which is not in the set of optionally-escaped bytes must be replaced with an ASCII percent (%) and the value of the byte in hex. The hex value must always be two digits, even if the first digit is zero. The optionally-escaped bytes may be escaped if desired.

To unescape, append each byte in the value; if a byte is an ASCII percent (%) character then append the following hex value instead. It is an error if a % byte does not have two hex digits following. It is an error if a non-optionally-escaped byte is seen unescaped.

The set of optionally-escaped bytes is intended to preserve address readability and convenience.

A server may specify a key-value pair with the key guid and the value a hex-encoded 16-byte sequence. the section called “UUIDs” describes the format of the guid field. If present, this UUID may be used to distinguish one server address from another. A server should use a different UUID for each address it listens on. For example, if a message bus daemon offers both UNIX domain socket and TCP connections, but treats clients the same regardless of how they connect, those two connections are equivalent post-connection but should have distinct UUIDs to distinguish the kinds of connection.

The intent of the address UUID feature is to allow a client to avoid opening multiple identical connections to the same server, by allowing the client to check whether an address corresponds to an already-existing connection. Comparing two addresses is insufficient, because addresses can be recycled by distinct servers, and equivalent addresses may look different if simply compared as strings (for example, the host in a TCP address can be given as an IP address or as a hostname).

Note that the address key is guid even though the rest of the API and documentation says "UUID," for historical reasons.

[FIXME clarify if attempting to connect to each is a requirement or just a suggestion] When connecting to a server, multiple server addresses can be separated by a semi-colon. The library will then try to connect to the first address and if that fails, it'll try to connect to the next one specified, and so forth. For example

unix:path=/tmp/dbus-test;unix:path=/tmp/dbus-test2
Some addresses are connectable. A connectable address is one containing enough information for a client to connect to it. For instance, tcp:host=127.0.0.1,port=4242 is a connectable address. It is not necessarily possible to listen on every connectable address: for instance, it is not possible to listen on a unixexec: address.

Some addresses are listenable. A listenable address is one containing enough information for a server to listen on it, producing a connectable address (which may differ from the original address). Many listenable addresses are not connectable: for instance, tcp:host=127.0.0.1 is listenable, but not connectable (because it does not specify a port number).

Listening on an address that is not connectable will result in a connectable address that is not the same as the listenable address. For instance, listening on tcp:host=127.0.0.1 might result in the connectable address tcp:host=127.0.0.1,port=30958, listening on unix:tmpdir=/tmp might result in the connectable address unix:abstract=/tmp/dbus-U8OSdmf7, or listening on unix:runtime=yes might result in the connectable address unix:path=/run/user/1234/bus.

Transports
[FIXME we need to specify in detail each transport and its possible arguments] Current transports include: unix domain sockets (including abstract namespace on linux), launchd, systemd, TCP/IP, an executed subprocess and a debug/testing transport using in-process pipes. Future possible transports include one that tunnels over X11 protocol.

Unix Domain Sockets
Unix domain sockets can be either paths in the file system or on Linux kernels, they can be abstract which are similar to paths but do not show up in the file system.

When a socket is opened by the D-Bus library it truncates the path name right before the first trailing Nul byte. This is true for both normal paths and abstract paths. Note that this is a departure from previous versions of D-Bus that would create sockets with a fixed length path name. Names which were shorter than the fixed length would be padded by Nul bytes.

Unix domain sockets are not available on Windows. On all other platforms, they are the recommended transport for D-Bus, either used alone or in conjunction with systemd or launchd addresses.

Unix addresses that specify path or abstract are both listenable and connectable. Unix addresses that specify tmpdir or dir are only listenable: the corresponding connectable address will specify either path or abstract. Similarly, Unix addresses that specify runtime are only listenable, and the corresponding connectable address will specify path.

Server Address Format
Unix domain socket addresses are identified by the "unix:" prefix and support the following key/value pairs:

Name	Values	Description
path	(path)	Path of the unix domain socket.
dir	(path)	Directory in which a socket file with a random file name starting with 'dbus-' will be created by the server. This key can only be used in server addresses, not in client addresses; the resulting client address will have the "path" key instead. be set.
tmpdir	(path)	The same as "dir", except that on platforms with abstract sockets, the server may attempt to create an abstract socket whose name starts with this directory instead of a path-based socket. This key can only be used in server addresses, not in client addresses; the resulting client address will have the "abstract" or "path" key instead.
abstract	(string)	Unique string in the abstract namespace, often syntactically resembling a path but unconnected to the filesystem namespace. This key is only supported on platforms with abstract Unix sockets, of which Linux is the only known example.
runtime	yes	If given, This key can only be used in server addresses, not in client addresses. If set, its value must be yes. This is typically used in an address string like unix:runtime=yes;unix:tmpdir=/tmp so that there can be a fallback if XDG_RUNTIME_DIR is not set.
Exactly one of the keys path, abstract, runtime, dir or tmpdir must be provided.

launchd
launchd is an open-source server management system that replaces init, inetd and cron on Apple Mac OS X versions 10.4 and above. It provides a common session bus address for each user and deprecates the X11-enabled D-Bus launcher on OSX.

launchd allocates a socket and provides it with the unix path through the DBUS_LAUNCHD_SESSION_BUS_SOCKET variable in launchd's environment. Every process spawned by launchd (or dbus-daemon, if it was started by launchd) can access it through its environment. Other processes can query for the launchd socket by executing: $ launchctl getenv DBUS_LAUNCHD_SESSION_BUS_SOCKET This is normally done by the D-Bus client library so doesn't have to be done manually.

launchd is not available on Microsoft Windows.

launchd addresses are listenable and connectable.

Server Address Format
launchd addresses are identified by the "launchd:" prefix and support the following key/value pairs:

Name	Values	Description
env	(environment variable)	path of the unix domain socket for the launchd created dbus-daemon.
The env key is required.

systemd
systemd is an open-source server management system that replaces init and inetd on newer Linux systems. It supports socket activation. The D-Bus systemd transport is used to acquire socket activation file descriptors from systemd and use them as D-Bus transport when the current process is spawned by socket activation from it.

The systemd transport accepts only one or more Unix domain or TCP streams sockets passed in via socket activation. Using Unix domain sockets is strongly recommended.

The systemd transport is not available on non-Linux operating systems.

The systemd transport defines no parameter keys.

systemd addresses are listenable, but not connectable. The corresponding connectable address is the unix or tcp address of the socket.

TCP Sockets
The tcp transport provides TCP/IP based connections between clients located on the same or different hosts.

Similar to remote X11, the TCP transport has no integrity or confidentiality protection, so it should normally only be used across the local loopback interface, for example using an address like tcp:host=127.0.0.1 or tcp:host=localhost. In particular, configuring the well-known system bus or the well-known session bus to listen on a non-loopback TCP address is insecure.

On Windows and most Unix platforms, the TCP stack is unable to transfer credentials over a TCP connection, so the EXTERNAL authentication mechanism does not normally work for this transport (although the reference implementation of D-Bus is able to identify loopback TCPv4 connections on Windows by their port number, partially enabling the EXTERNAL mechanism). The DBUS_COOKIE_SHA1 mechanism is normally used instead.

Developers are sometimes tempted to use remote TCP as a debugging tool. However, if this functionality is left enabled in finished products, the result will be dangerously insecure. Instead of using remote TCP, developers should relay connections via Secure Shell or a similar protocol.

Remote TCP connections were historically sometimes used to share a single session bus between login sessions of the same user on different machines within a trusted local area network, in conjunction with unencrypted remote X11, a NFS-shared home directory and NIS (YP) authentication. This is insecure against an attacker on the same LAN and should be considered strongly deprecated; more specifically, it is insecure in the same ways and for the same reasons as unencrypted remote X11 and NFSv2/NFSv3. The D-Bus maintainers recommend using a separate session bus per (user, machine) pair, only accessible from within that machine.

All tcp addresses are listenable. tcp addresses in which both host and port are specified, and port is non-zero, are also connectable.

Server Address Format
TCP/IP socket addresses are identified by the "tcp:" prefix and support the following key/value pairs:

Name	Values	Description
host	(string)	DNS name or IP address
bind	(string)	Used in a listenable address to configure the interface on which the server will listen: either the IP address of one of the local machine's interfaces (most commonly 127.0.0.1 ), or a DNS name that resolves to one of those IP addresses, or '*' to listen on all interfaces simultaneously. If not specified, the default is the same value as "host".
port	(number)	The tcp port the server will open. A zero value let the server choose a free port provided from the underlaying operating system. libdbus is able to retrieve the real used port from the server.
family	(string)	If set, provide the type of socket family either "ipv4" or "ipv6". If unset, the family is unspecified.
Nonce-authenticated TCP Sockets
The nonce-tcp transport provides a modified TCP transport using a simple authentication mechanism, to ensure that only clients with read access to a certain location in the filesystem can connect to the server. The server writes a secret, the nonce, to a file and an incoming client connection is only accepted if the client sends the nonce right after the connect. The nonce mechanism requires no setup and is orthogonal to the higher-level authentication mechanisms described in the Authentication section.

The nonce-tcp transport is conceptually similar to a combination of the DBUS_COOKIE_SHA1 authentication mechanism and the tcp transport, and appears to have originally been implemented as a result of a misunderstanding of the SASL authentication mechanisms.

Like the ordinary tcp transport, the nonce-tcp transport has no integrity or confidentiality protection, so it should normally only be used across the local loopback interface, for example using an address like tcp:host=127.0.0.1 or tcp:host=localhost. Other uses are insecure. See the section called “TCP Sockets” for more information on situations where these transports have been used, and alternatives to these transports.

Implementations of D-Bus on Windows operating systems normally use a nonce-tcp transport via the local loopback interface. This is because the unix transport, which would otherwise be recommended, is not available on these operating systems.

On start, the server generates a random 16 byte nonce and writes it to a file in the user's temporary directory. The nonce file location is published as part of the server's D-Bus address using the "noncefile" key-value pair. After an accept, the server reads 16 bytes from the socket. If the read bytes do not match the nonce stored in the nonce file, the server MUST immediately drop the connection. If the nonce match the received byte sequence, the client is accepted and the transport behaves like an ordinary tcp transport.

After a successful connect to the server socket, the client MUST read the nonce from the file published by the server via the noncefile= key-value pair and send it over the socket. After that, the transport behaves like an ordinary tcp transport.

All nonce-tcp addresses are listenable. nonce-tcp addresses in which host, port and noncefile are all specified, and port is nonzero, are also connectable.

Server Address Format
Nonce TCP/IP socket addresses uses the "nonce-tcp:" prefix and support the following key/value pairs:

Name	Values	Description
host	(string)	DNS name or IP address
bind	(string)	The same as for tcp: addresses
port	(number)	The tcp port the server will open. A zero value let the server choose a free port provided from the underlaying operating system. libdbus is able to retrieve the real used port from the server.
family	(string)	If set, provide the type of socket family either "ipv4" or "ipv6". If unset, the family is unspecified.
noncefile	(path)	File location containing the secret. This is only meaningful in connectable addresses: a listening D-Bus server that offers this transport will always create a new nonce file.
Executed Subprocesses on Unix
This transport forks off a process and connects its standard input and standard output with an anonymous Unix domain socket. This socket is then used for communication by the transport. This transport may be used to use out-of-process forwarder programs as basis for the D-Bus protocol.

The forked process will inherit the standard error output and process group from the parent process.

Executed subprocesses are not available on Windows.

unixexec addresses are connectable, but are not listenable.

Server Address Format
Executed subprocess addresses are identified by the "unixexec:" prefix and support the following key/value pairs:

Name	Values	Description
path	(path)	Path of the binary to execute, either an absolute path or a binary name that is searched for in the default search path of the OS. This corresponds to the first argument of execlp(). This key is mandatory.
argv0	(string)	The program name to use when executing the binary. If omitted the same value as specified for path= will be used. This corresponds to the second argument of execlp().
argv1, argv2, ...	(string)	Arguments to pass to the binary. This corresponds to the third and later arguments of execlp(). If a specific argvX is not specified no further argvY for Y > X are taken into account.
Meta Transports
Meta transports are a kind of transport with special enhancements or behavior. Currently available meta transports include: autolaunch

Autolaunch
The autolaunch transport provides a way for dbus clients to autodetect a running dbus session bus and to autolaunch a session bus if not present.

On Unix, autolaunch addresses are connectable, but not listenable.

On Windows, autolaunch addresses are both connectable and listenable.

Server Address Format
Autolaunch addresses uses the "autolaunch:" prefix and support the following key/value pairs:

Name	Values	Description
scope	(string)	scope of autolaunch (Windows only)
"*install-path" - limit session bus to dbus installation path. The dbus installation path is determined from the location of the shared dbus library. If the library is located in a 'bin' subdirectory the installation root is the directory above, otherwise the directory where the library lives is taken as installation root.

                   <install-root>/bin/[lib]dbus-1.dll
                   <install-root>/[lib]dbus-1.dll
               
"*user" - limit session bus to the recent user.

other values - specify dedicated session bus like "release", "debug" or other

Windows implementation
On start, the server opens a platform specific transport, creates a mutex and a shared memory section containing the related session bus address. This mutex will be inspected by the dbus client library to detect a running dbus session bus. The access to the mutex and the shared memory section are protected by global locks.

In the recent implementation the autolaunch transport uses a tcp transport on localhost with a port choosen from the operating system. This detail may change in the future.

Disclaimer: The recent implementation is in an early state and may not work in all cirumstances and/or may have security issues. Because of this the implementation is not documentated yet.

UUIDs
A working D-Bus implementation uses universally-unique IDs in two places. First, each server address has a UUID identifying the address, as described in the section called “Server Addresses”. Second, each operating system kernel instance running a D-Bus client or server has a UUID identifying that kernel, retrieved by invoking the method org.freedesktop.DBus.Peer.GetMachineId() (see the section called “org.freedesktop.DBus.Peer”).

The term "UUID" in this document is intended literally, i.e. an identifier that is universally unique. It is not intended to refer to RFC4122, and in fact the D-Bus UUID is not compatible with that RFC.

The UUID must contain 128 bits of data and be hex-encoded. The hex-encoded string may not contain hyphens or other non-hex-digit characters, and it must be exactly 32 characters long. To generate a UUID, the current reference implementation concatenates 96 bits of random data followed by the 32-bit time in seconds since the UNIX epoch (in big endian byte order).

It would also be acceptable and probably better to simply generate 128 bits of random data, as long as the random number generator is of high quality. The timestamp could conceivably help if the random bits are not very random. With a quality random number generator, collisions are extremely unlikely even with only 96 bits, so it's somewhat academic.

Implementations should, however, stick to random data for the first 96 bits of the UUID.

Standard Interfaces
See the section called “Notation in this document” for details on the notation used in this section. There are some standard interfaces that may be useful across various D-Bus applications.

org.freedesktop.DBus.Peer
The org.freedesktop.DBus.Peer interface has two methods:

          org.freedesktop.DBus.Peer.Ping ()
          org.freedesktop.DBus.Peer.GetMachineId (out STRING machine_uuid)
        
On receipt of the METHOD_CALL message org.freedesktop.DBus.Peer.Ping, an application should do nothing other than reply with a METHOD_RETURN as usual. It does not matter which object path a ping is sent to. The reference implementation handles this method automatically.

On receipt of the METHOD_CALL message org.freedesktop.DBus.Peer.GetMachineId, an application should reply with a METHOD_RETURN containing a hex-encoded UUID representing the identity of the machine the process is running on. This UUID must be the same for all processes on a single system at least until that system next reboots. It should be the same across reboots if possible, but this is not always possible to implement and is not guaranteed. It does not matter which object path a GetMachineId is sent to. The reference implementation handles this method automatically.

The UUID is intended to be per-instance-of-the-operating-system, so may represent a virtual machine running on a hypervisor, rather than a physical machine. Basically if two processes see the same UUID, they should also see the same shared memory, UNIX domain sockets, process IDs, and other features that require a running OS kernel in common between the processes.

The UUID is often used where other programs might use a hostname. Hostnames can change without rebooting, however, or just be "localhost" - so the UUID is more robust.

the section called “UUIDs” explains the format of the UUID.

org.freedesktop.DBus.Introspectable
This interface has one method:

          org.freedesktop.DBus.Introspectable.Introspect (out STRING xml_data)
        
Objects instances may implement Introspect which returns an XML description of the object, including its interfaces (with signals and methods), objects below it in the object path tree, and its properties.

the section called “Introspection Data Format” describes the format of this XML string.

org.freedesktop.DBus.Properties
Many native APIs will have a concept of object properties or attributes. These can be exposed via the org.freedesktop.DBus.Properties interface.

              org.freedesktop.DBus.Properties.Get (in STRING interface_name,
                                                   in STRING property_name,
                                                   out VARIANT value);
              org.freedesktop.DBus.Properties.Set (in STRING interface_name,
                                                   in STRING property_name,
                                                   in VARIANT value);
              org.freedesktop.DBus.Properties.GetAll (in STRING interface_name,
                                                      out DICT<STRING,VARIANT> props);
        
It is conventional to give D-Bus properties names consisting of capitalized words without punctuation ("CamelCase"), like member names. For instance, the GObject property connection-status or the Qt property connectionStatus could be represented on D-Bus as ConnectionStatus.

Strictly speaking, D-Bus property names are not required to follow the same naming restrictions as member names, but D-Bus property names that would not be valid member names (in particular, GObject-style dash-separated property names) can cause interoperability problems and should be avoided.

The available properties and whether they are writable can be determined by calling org.freedesktop.DBus.Introspectable.Introspect, see the section called “org.freedesktop.DBus.Introspectable”.

An empty string may be provided for the interface name; in this case, if there are multiple properties on an object with the same name, the results are undefined (picking one by according to an arbitrary deterministic rule, or returning an error, are the reasonable possibilities).

If org.freedesktop.DBus.Properties.GetAll is called with a valid interface name which contains no properties, an empty array should be returned. If it is called with a valid interface name for which some properties are not accessible to the caller (for example, due to per-property access control implemented in the service), those properties should be silently omitted from the result array. If org.freedesktop.DBus.Properties.Get is called for any such properties, an appropriate access control error should be returned.

If one or more properties change on an object, the org.freedesktop.DBus.Properties.PropertiesChanged signal may be emitted (this signal was added in 0.14):

              org.freedesktop.DBus.Properties.PropertiesChanged (STRING interface_name,
                                                                 DICT<STRING,VARIANT> changed_properties,
                                                                 ARRAY<STRING> invalidated_properties);
        
where changed_properties is a dictionary containing the changed properties with the new values and invalidated_properties is an array of properties that changed but the value is not conveyed.

Whether the PropertiesChanged signal is supported can be determined by calling org.freedesktop.DBus.Introspectable.Introspect. Note that the signal may be supported for an object but it may differ how whether and how it is used on a per-property basis (for e.g. performance or security reasons). Each property (or the parent interface) must be annotated with the org.freedesktop.DBus.Property.EmitsChangedSignal annotation to convey this (usually the default value true is sufficient meaning that the annotation does not need to be used). See the section called “Introspection Data Format” for details on this annotation.

org.freedesktop.DBus.ObjectManager
An API can optionally make use of this interface for one or more sub-trees of objects. The root of each sub-tree implements this interface so other applications can get all objects, interfaces and properties in a single method call. It is appropriate to use this interface if users of the tree of objects are expected to be interested in all interfaces of all objects in the tree; a more granular API should be used if users of the objects are expected to be interested in a small subset of the objects, a small subset of their interfaces, or both.

The method that applications can use to get all objects and properties is GetManagedObjects:

          org.freedesktop.DBus.ObjectManager.GetManagedObjects (out DICT<OBJPATH,DICT<STRING,DICT<STRING,VARIANT>>> objpath_interfaces_and_properties);
        
The return value of this method is a dict whose keys are object paths. All returned object paths are children of the object path implementing this interface, i.e. their object paths start with the ObjectManager's object path plus '/'.

Each value is a dict whose keys are interfaces names. Each value in this inner dict is the same dict that would be returned by the org.freedesktop.DBus.Properties.GetAll() method for that combination of object path and interface. If an interface has no properties, the empty dict is returned.

Changes are emitted using the following two signals:

          org.freedesktop.DBus.ObjectManager.InterfacesAdded (OBJPATH object_path,
                                                              DICT<STRING,DICT<STRING,VARIANT>> interfaces_and_properties);
          org.freedesktop.DBus.ObjectManager.InterfacesRemoved (OBJPATH object_path,
                                                                ARRAY<STRING> interfaces);
        
The InterfacesAdded signal is emitted when either a new object is added or when an existing object gains one or more interfaces. The InterfacesRemoved signal is emitted whenever an object is removed or it loses one or more interfaces. The second parameter of the InterfacesAdded signal contains a dict with the interfaces and properties (if any) that have been added to the given object path. Similarly, the second parameter of the InterfacesRemoved signal contains an array of the interfaces that were removed. Note that changes on properties on existing interfaces are not reported using this interface - an application should also monitor the existing PropertiesChanged signal on each object.

Applications SHOULD NOT export objects that are children of an object (directly or otherwise) implementing this interface but which are not returned in the reply from the GetManagedObjects() method of this interface on the given object.

The intent of the ObjectManager interface is to make it easy to write a robust client implementation. The trivial client implementation only needs to make two method calls:

          org.freedesktop.DBus.AddMatch (bus_proxy,
                                         "type='signal',sender='org.example.App2',path_namespace='/org/example/App2'");
          objects = org.freedesktop.DBus.ObjectManager.GetManagedObjects (app_proxy);
        
on the message bus and the remote application's ObjectManager, respectively. Whenever a new remote object is created (or an existing object gains a new interface), the InterfacesAdded signal is emitted, and since this signal contains all properties for the interfaces, no calls to the org.freedesktop.Properties interface on the remote object are needed. Additionally, since the initial AddMatch() rule already includes signal messages from the newly created child object, no new AddMatch() call is needed.

The org.freedesktop.DBus.ObjectManager interface was added in version 0.17 of the D-Bus specification.

Introspection Data Format
As described in the section called “org.freedesktop.DBus.Introspectable”, objects may be introspected at runtime, returning an XML string that describes the object. The same XML format may be used in other contexts as well, for example as an "IDL" for generating static language bindings.

Here is an example of introspection data:

        <!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
         "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">
        <node name="/com/example/sample_object0">
          <interface name="com.example.SampleInterface0">
            <method name="Frobate">
              <arg name="foo" type="i" direction="in"/>
              <arg name="bar" type="s" direction="out"/>
              <arg name="baz" type="a{us}" direction="out"/>
              <annotation name="org.freedesktop.DBus.Deprecated" value="true"/>
            </method>
            <method name="Bazify">
              <arg name="bar" type="(iiu)" direction="in"/>
              <arg name="bar" type="v" direction="out"/>
            </method>
            <method name="Mogrify">
              <arg name="bar" type="(iiav)" direction="in"/>
            </method>
            <signal name="Changed">
              <arg name="new_value" type="b"/>
            </signal>
            <property name="Bar" type="y" access="readwrite"/>
          </interface>
          <node name="child_of_sample_object"/>
          <node name="another_child_of_sample_object"/>
       </node>
      
A more formal DTD and spec needs writing, but here are some quick notes.

Only the root <node> element can omit the node name, as it's known to be the object that was introspected. If the root <node> does have a name attribute, it must be an absolute object path. If child <node> have object paths, they must be relative.

If a child <node> has any sub-elements, then they must represent a complete introspection of the child. If a child <node> is empty, then it may or may not have sub-elements; the child must be introspected in order to find out. The intent is that if an object knows that its children are "fast" to introspect it can go ahead and return their information, but otherwise it can omit it.

The direction element on <arg> may be omitted, in which case it defaults to "in" for method calls and "out" for signals. Signals only allow "out" so while direction may be specified, it's pointless.

The possible directions are "in" and "out", unlike CORBA there is no "inout"

The possible property access flags are "readwrite", "read", and "write"

Multiple interfaces can of course be listed for one <node>.

The "name" attribute on arguments is optional.

Method, interface, property, signal, and argument elements may have "annotations", which are generic key/value pairs of metadata. They are similar conceptually to Java's annotations and C# attributes. Well-known annotations:

Name	Values (separated by ,)	Description
org.freedesktop.DBus.Deprecated	true,false	Whether or not the entity is deprecated; defaults to false
org.freedesktop.DBus.GLib.CSymbol	(string)	The C symbol; may be used for methods and interfaces
org.freedesktop.DBus.Method.NoReply	true,false	If set, don't expect a reply to the method call; defaults to false.
org.freedesktop.DBus.Property.EmitsChangedSignal	true,invalidates,const,false	
If set to false, the org.freedesktop.DBus.Properties.PropertiesChanged signal, see the section called “org.freedesktop.DBus.Properties” is not guaranteed to be emitted if the property changes.

If set to const the property never changes value during the lifetime of the object it belongs to, and hence the signal is never emitted for it.

If set to invalidates the signal is emitted but the value is not included in the signal.

If set to true the signal is emitted with the value included.

The value for the annotation defaults to true if the enclosing interface element does not specify the annotation. Otherwise it defaults to the value specified in the enclosing interface element.

This annotation is intended to be used by code generators to implement client-side caching of property values. For all properties for which the annotation is set to const, invalidates or true the client may unconditionally cache the values as the properties don't change or notifications are generated for them if they do.

Message Bus Specification
Message Bus Overview
The message bus accepts connections from one or more applications. Once connected, applications can exchange messages with other applications that are also connected to the bus.

In order to route messages among connections, the message bus keeps a mapping from names to connections. Each connection has one unique-for-the-lifetime-of-the-bus name automatically assigned. Applications may request additional names for a connection. Additional names are usually "well-known names" such as "com.example.TextEditor1". When a name is bound to a connection, that connection is said to own the name.

The bus itself owns a special name, org.freedesktop.DBus, with an object located at /org/freedesktop/DBus that implements the org.freedesktop.DBus interface. This service allows applications to make administrative requests of the bus itself. For example, applications can ask the bus to assign a name to a connection.

Each name may have queued owners. When an application requests a name for a connection and the name is already in use, the bus will optionally add the connection to a queue waiting for the name. If the current owner of the name disconnects or releases the name, the next connection in the queue will become the new owner.

This feature causes the right thing to happen if you start two text editors for example; the first one may request "com.example.TextEditor1", and the second will be queued as a possible owner of that name. When the first exits, the second will take over.

Applications may send unicast messages to a specific recipient or to the message bus itself, or broadcast messages to all interested recipients. See the section called “Message Bus Message Routing” for details.

Message Bus Names
Each connection has at least one name, assigned at connection time and returned in response to the org.freedesktop.DBus.Hello method call. This automatically-assigned name is called the connection's unique name. Unique names are never reused for two different connections to the same bus.

Ownership of a unique name is a prerequisite for interaction with the message bus. It logically follows that the unique name is always the first name that an application comes to own, and the last one that it loses ownership of.

Unique connection names must begin with the character ':' (ASCII colon character); bus names that are not unique names must not begin with this character. (The bus must reject any attempt by an application to manually request a name beginning with ':'.) This restriction categorically prevents "spoofing"; messages sent to a unique name will always go to the expected connection.

When a connection is closed, all the names that it owns are deleted (or transferred to the next connection in the queue if any).

A connection can request additional names to be associated with it using the org.freedesktop.DBus.RequestName message. the section called “Bus names” describes the format of a valid name. These names can be released again using the org.freedesktop.DBus.ReleaseName message.

Message Bus Message Routing
Messages may have a DESTINATION field (see the section called “Header Fields”), resulting in a unicast message. If the DESTINATION field is present, it specifies a message recipient by name. Method calls and replies normally specify this field. The message bus must send messages (of any type) with the DESTINATION field set to the specified recipient, regardless of whether the recipient has set up a match rule matching the message.

When the message bus receives a signal, if the DESTINATION field is absent, it is considered to be a broadcast signal, and is sent to all applications with message matching rules that match the message. Most signal messages are broadcasts, and no other message types currently defined in this specification may be broadcast.

Unicast signal messages (those with a DESTINATION field) are not commonly used, but they are treated like any unicast message: they are delivered to the specified receipient, regardless of its match rules. One use for unicast signals is to avoid a race condition in which a signal is emitted before the intended recipient can call the section called “org.freedesktop.DBus.AddMatch” to receive that signal: if the signal is sent directly to that recipient using a unicast message, it does not need to add a match rule at all, and there is no race condition. Another use for unicast signals, on message buses whose security policy prevents eavesdropping, is to send sensitive information which should only be visible to one recipient.

When the message bus receives a method call, if the DESTINATION field is absent, the call is taken to be a standard one-to-one message and interpreted by the message bus itself. For example, sending an org.freedesktop.DBus.Peer.Ping message with no DESTINATION will cause the message bus itself to reply to the ping immediately; the message bus will not make this message visible to other applications.

Continuing the org.freedesktop.DBus.Peer.Ping example, if the ping message were sent with a DESTINATION name of com.yoyodyne.Screensaver, then the ping would be forwarded, and the Yoyodyne Corporation screensaver application would be expected to reply to the ping.

Message bus implementations may impose a security policy which prevents certain messages from being sent or received. When a method call message cannot be sent or received due to a security policy, the message bus should send an error reply, unless the original message had the NO_REPLY flag.

Eavesdropping
Receiving a unicast message whose DESTINATION indicates a different recipient is called eavesdropping. On a message bus which acts as a security boundary (like the standard system bus), the security policy should usually prevent eavesdropping, since unicast messages are normally kept private and may contain security-sensitive information.

Eavesdropping interacts poorly with buses with non-trivial access control restrictions, and is deprecated. The BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”) provides a preferable way to monitor buses.

Eavesdropping is mainly useful for debugging tools, such as the dbus-monitor tool in the reference implementation of D-Bus. Tools which eavesdrop on the message bus should be careful to avoid sending a reply or error in response to messages intended for a different client.

Clients may attempt to eavesdrop by adding match rules (see the section called “Match Rules”) containing the eavesdrop='true' match. For compatibility with older message bus implementations, if adding such a match rule results in an error reply, the client may fall back to adding the same rule with the eavesdrop match omitted.

Match Rules
An important part of the message bus routing protocol is match rules. Match rules describe the messages that should be sent to a client, based on the contents of the message. Broadcast signals are only sent to clients which have a suitable match rule: this avoids waking up client processes to deal with signals that are not relevant to that client.

Messages that list a client as their DESTINATION do not need to match the client's match rules, and are sent to that client regardless. As a result, match rules are mainly used to receive a subset of broadcast signals.

Match rules can also be used for eavesdropping (see the section called “Eavesdropping”), if the security policy of the message bus allows it, but this usage is deprecated in favour of the BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”).

Match rules are added using the AddMatch bus method (see the section called “org.freedesktop.DBus.AddMatch”). Rules are specified as a string of comma separated key/value pairs. Excluding a key from the rule indicates a wildcard match. For instance excluding the the member from a match rule but adding a sender would let all messages from that sender through. An example of a complete rule would be "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='Foo',path='/bar/foo',destination=':452345.34',arg2='bar'"

Within single quotes (ASCII apostrophe, U+0027), a backslash (U+005C) represents itself, and an apostrophe ends the quoted section. Outside single quotes, \' (backslash, apostrophe) represents an apostrophe, and any backslash not followed by an apostrophe represents itself. For instance, the match rules arg0=''\''',arg1='\',arg2=',',arg3='\\' and arg0=\',arg1=\,arg2=',',arg3=\\ both match messages where the arguments are a 1-character string containing an apostrophe, a 1-character string containing a backslash, a 1-character string containing a comma, and a 2-character string containing two backslashes[2].

The following table describes the keys that can be used to create a match rule.

Key	Possible Values	Description
type	'signal', 'method_call', 'method_return', 'error'	Match on the message type. An example of a type match is type='signal'
sender	A bus or unique name (see Bus Name and Unique Connection Name respectively)	Match messages sent by a particular sender. An example of a sender match is sender='org.freedesktop.Hal'
interface	An interface name (see the section called “Interface names”)	Match messages sent over or to a particular interface. An example of an interface match is interface='org.freedesktop.Hal.Manager'. If a message omits the interface header, it must not match any rule that specifies this key.
member	Any valid method or signal name	Matches messages which have the give method or signal name. An example of a member match is member='NameOwnerChanged'
path	An object path (see the section called “Valid Object Paths”)	Matches messages which are sent from or to the given object. An example of a path match is path='/org/freedesktop/Hal/Manager'
path_namespace	An object path	
Matches messages which are sent from or to an object for which the object path is either the given value, or that value followed by one or more path components.

For example, path_namespace='/com/example/foo' would match signals sent by /com/example/foo or by /com/example/foo/bar, but not by /com/example/foobar.

Using both path and path_namespace in the same match rule is not allowed.

This match key was added in version 0.16 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.0 and later.

destination	A unique name (see Unique Connection Name)	Matches messages which are being sent to the given unique name. An example of a destination match is destination=':1.0'
arg[0, 1, 2, 3, ...]	Any string	Arg matches are special and are used for further restricting the match based on the arguments in the body of a message. Only arguments of type STRING can be matched in this way. An example of an argument match would be arg3='Foo'. Only argument indexes from 0 to 63 should be accepted.
arg[0, 1, 2, 3, ...]path	Any string	
Argument path matches provide a specialised form of wildcard matching for path-like namespaces. They can match arguments whose type is either STRING or OBJECT_PATH. As with normal argument matches, if the argument is exactly equal to the string given in the match rule then the rule is satisfied. Additionally, there is also a match when either the string given in the match rule or the appropriate message argument ends with '/' and is a prefix of the other. An example argument path match is arg0path='/aa/bb/'. This would match messages with first arguments of '/', '/aa/', '/aa/bb/', '/aa/bb/cc/' and '/aa/bb/cc'. It would not match messages with first arguments of '/aa/b', '/aa' or even '/aa/bb'.

This is intended for monitoring “directories” in file system-like hierarchies, as used in the dconf configuration system. An application interested in all nodes in a particular hierarchy would monitor arg0path='/ca/example/foo/'. Then the service could emit a signal with zeroth argument "/ca/example/foo/bar" to represent a modification to the “bar” property, or a signal with zeroth argument "/ca/example/" to represent atomic modification of many properties within that directory, and the interested application would be notified in both cases.

This match key was added in version 0.12 of the D-Bus specification, implemented for STRING arguments by the bus daemon in dbus 1.2.0 and later, and implemented for OBJECT_PATH arguments in dbus 1.5.0 and later.

arg0namespace	Like a bus name, except that the string is not required to contain a '.' (period)	
Match messages whose first argument is of type STRING, and is a bus name or interface name within the specified namespace. This is primarily intended for watching name owner changes for a group of related bus names, rather than for a single name or all name changes.

Because every valid interface name is also a valid bus name, this can also be used for messages whose first argument is an interface name.

For example, the match rule member='NameOwnerChanged',arg0namespace='com.example.backend1' matches name owner changes for bus names such as com.example.backend1.foo, com.example.backend1.foo.bar, and com.example.backend1 itself.

See also the section called “org.freedesktop.DBus.NameOwnerChanged”.

This match key was added in version 0.16 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.0 and later.

eavesdrop	'true', 'false'	
Since D-Bus 1.5.6, match rules do not match messages which have a DESTINATION field unless the match rule specifically requests this (see the section called “Eavesdropping”) by specifying eavesdrop='true' in the match rule. eavesdrop='false' restores the default behaviour. Messages are delivered to their DESTINATION regardless of match rules, so this match does not affect normal delivery of unicast messages. In older versions of D-Bus, this match was not allowed in match rules, and all match rules behaved as if eavesdrop='true' had been used.

Use of eavesdrop='true' is deprecated. Monitors should prefer to use the BecomeMonitor method (see the section called “org.freedesktop.DBus.Monitoring.BecomeMonitor”), which was introduced in version 0.26 of the D-Bus specification and version 1.9.10 of the reference dbus-daemon.

Message bus implementations may restrict match rules with eavesdrop='true' so that they can only be added by privileged connections.

This match key was added in version 0.18 of the D-Bus specification and implemented by the bus daemon in dbus 1.5.6 and later.

Message Bus Starting Services (Activation)
The message bus can start applications on behalf of other applications. This is referred to as service activation or activation. An application that can be started in this way is called a service or an activatable service.

Starting a service should be read as synonymous with service activation.

In D-Bus, service activation is normally done by auto-starting. In auto-starting, applications send a message to a particular well-known name, such as com.example.TextEditor1, without specifying the NO_AUTO_START flag in the message header. If no application on the bus owns the requested name, but the bus daemon does know how to start an activatable service for that name, then the bus daemon will start that service, wait for it to request that name, and deliver the message to it.

It is also possible for applications to send an explicit request to start a service: this is another form of activation, distinct from auto-starting. See the section called “org.freedesktop.DBus.StartServiceByName” for details.

In either case, this implies a contract documented along with the name com.example.TextEditor1 for which object the owner of that name will provide, and what interfaces those objects will have.

To find an executable corresponding to a particular name, the bus daemon looks for service description files. Service description files define a mapping from names to executables. Different kinds of message bus will look for these files in different places, see the section called “Well-known Message Bus Instances”.

Service description files have the ".service" file extension. The message bus will only load service description files ending with .service; all other files will be ignored. The file format is similar to that of desktop entries. All service description files must be in UTF-8 encoding. To ensure that there will be no name collisions, service files must be namespaced using the same mechanism as messages and service names.

On the well-known system bus, the name of a service description file must be its well-known name plus .service, for instance com.example.ConfigurationDatabase1.service.

On the well-known session bus, services should follow the same service description file naming convention as on the system bus, but for backwards compatibility they are not required to do so.

[FIXME the file format should be much better specified than "similar to .desktop entries" esp. since desktop entries are already badly-specified. ;-)] These sections from the specification apply to service files as well:

General syntax

Comment format

Service description files must contain a D-BUS Service group with at least the keys Name (the well-known name of the service) and Exec (the command to be executed).

Figure 9. Example service description file

            # Sample service description file
            [D-BUS Service]
            Name=com.example.ConfigurationDatabase1
            Exec=/usr/bin/sample-configd
          

Additionally, service description files for the well-known system bus on Unix must contain a User key, whose value is the name of a user account (e.g. root). The system service will be run as that user.

When an application asks to start a service by name, the bus daemon tries to find a service that will own that name. It then tries to spawn the executable associated with it. If this fails, it will report an error.

On the well-known system bus, it is not possible for two .service files in the same directory to offer the same service, because they are constrained to have names that match the service name.

On the well-known session bus, if two .service files in the same directory offer the same service name, the result is undefined. Distributors should avoid this situation, for instance by naming session services' .service files according to their service name.

If two .service files in different directories offer the same service name, the one in the higher-priority directory is used: for instance, on the system bus, .service files in /usr/local/share/dbus-1/system-services take precedence over those in /usr/share/dbus-1/system-services.

The executable launched will have the environment variable DBUS_STARTER_ADDRESS set to the address of the message bus so it can connect and request the appropriate names.

The executable being launched may want to know whether the message bus starting it is one of the well-known message buses (see the section called “Well-known Message Bus Instances”). To facilitate this, the bus must also set the DBUS_STARTER_BUS_TYPE environment variable if it is one of the well-known buses. The currently-defined values for this variable are system for the systemwide message bus, and session for the per-login-session message bus. The new executable must still connect to the address given in DBUS_STARTER_ADDRESS, but may assume that the resulting connection is to the well-known bus.

[FIXME there should be a timeout somewhere, either specified in the .service file, by the client, or just a global value and if the client being activated fails to connect within that timeout, an error should be sent back.]

Message Bus Service Scope
The "scope" of a service is its "per-", such as per-session, per-machine, per-home-directory, or per-display. The reference implementation doesn't yet support starting services in a different scope from the message bus itself. So e.g. if you start a service on the session bus its scope is per-session.

We could add an optional scope to a bus name. For example, for per-(display,session pair), we could have a unique ID for each display generated automatically at login and set on screen 0 by executing a special "set display ID" binary. The ID would be stored in a _DBUS_DISPLAY_ID property and would be a string of random bytes. This ID would then be used to scope names. Starting/locating a service could be done by ID-name pair rather than only by name.

Contrast this with a per-display scope. To achieve that, we would want a single bus spanning all sessions using a given display. So we might set a _DBUS_DISPLAY_BUS_ADDRESS property on screen 0 of the display, pointing to this bus.

systemd Activation
Service description files may contain a SystemdService key. Its value is the name of a systemd service, for example dbus-com.example.MyDaemon.service.

If this key is present, the bus daemon may carry out activation for this D-Bus service by sending a request to systemd asking it to start the systemd service whose name is the value of SystemdService. For example, the reference dbus-daemon has a --systemd-activation option that enables this feature, and that option is given when it is started by systemd.

On the well-known system bus, it is a common practice to set SystemdService to dbus-, followed by the well-known bus name, followed by .service, then register that name as an alias for the real systemd service. This allows D-Bus activation of a service to be enabled or disabled independently of whether the service is started by systemd during boot.

Mediating Activation with AppArmor
Please refer to AppArmor documentation for general information on AppArmor, and how it mediates D-Bus messages when used in conjunction with a kernel and dbus-daemon that support this.

In recent versions of the reference dbus-daemon, AppArmor policy rules of type dbus send are also used to control auto-starting: if a message is sent to the well-known name of an activatable service, the dbus-daemon will attempt to determine whether it would deliver the message to that service beforeauto-starting it, by making some assumptions about the resulting process's credentials.

If it does proceed with auto-starting, when the service appears, the dbus-daemon repeats the policy check (with the service's true credentials, which might not be identical) before delivering the message. In practice, this second check will usually be more strict than the first; the first check would only be more strict if there are "blacklist"-style rules like deny dbus send peer=(label=/usr/bin/protected) that match on the peer's specific credentials, but AppArmor is normally used in a "whitelist" style where this does not apply.

To support this process, service description files may contain a AssumedAppArmorLabel key. Its value is the name of an AppArmor label, for example /usr/sbin/mydaemon. If present, AppArmor mediation of messages that auto-start a service will decide whether to allow auto-starting to occur based on the assumption that the activated service will be confined under the specified label; in particular, rules of the form dbus send peer=(label=/usr/sbin/mydaemon) or deny dbus send peer=(label=/usr/sbin/mydaemon) will match it, allowing or denying as appropriate (even if there is in fact no profile of that name loaded).

Otherwise, AppArmor mediation of messages that auto-start a service will decide whether to allow auto-starting to occur without specifying any particular label. In particular, any rule of the form dbus send peer=(label=X) or deny dbus send peer=(label=X) (for any value of X, including the special label unconfined) will not influence whether the auto-start is allowed.

Rules of type dbus receive are not checked when deciding whether to allow auto-starting; they are only checked against the service's profile after the service has started, when deciding whether to deliver the message that caused the auto-starting operation.

Explicit activation via the section called “org.freedesktop.DBus.StartServiceByName” is not currently affected by this mediation: if a confined process is to be prevented from starting arbitrary services, then it must not be allowed to call that method.

Well-known Message Bus Instances
Two standard message bus instances are defined here, along with how to locate them and where their service files live.

Login session message bus
Each time a user logs in, a login session message bus may be started. All applications in the user's login session may interact with one another using this message bus.

The address of the login session message bus is given in the DBUS_SESSION_BUS_ADDRESS environment variable. If that variable is not set, applications may also try to read the address from the X Window System root window property _DBUS_SESSION_BUS_ADDRESS. The root window property must have type STRING. The environment variable should have precedence over the root window property.

The address of the login session message bus is given in the DBUS_SESSION_BUS_ADDRESS environment variable. If DBUS_SESSION_BUS_ADDRESS is not set, or if it's set to the string "autolaunch:", the system should use platform-specific methods of locating a running D-Bus session server, or starting one if a running instance cannot be found. Note that this mechanism is not recommended for attempting to determine if a daemon is running. It is inherently racy to attempt to make this determination, since the bus daemon may be started just before or just after the determination is made. Therefore, it is recommended that applications do not try to make this determination for their functionality purposes, and instead they should attempt to start the server.

X Windowing System
For the X Windowing System, the application must locate the window owner of the selection represented by the atom formed by concatenating:

the literal string "_DBUS_SESSION_BUS_SELECTION_"

the current user's username

the literal character '_' (underscore)

the machine's ID

The following properties are defined for the window that owns this X selection:

Atom

meaning

_DBUS_SESSION_BUS_ADDRESS

the actual address of the server socket

_DBUS_SESSION_BUS_PID

the PID of the server process

At least the _DBUS_SESSION_BUS_ADDRESS property MUST be present in this window.

If the X selection cannot be located or if reading the properties from the window fails, the implementation MUST conclude that there is no D-Bus server running and proceed to start a new server. (See below on concurrency issues)

Failure to connect to the D-Bus server address thus obtained MUST be treated as a fatal connection error and should be reported to the application.

As an alternative, an implementation MAY find the information in the following file located in the current user's home directory, in subdirectory .dbus/session-bus/:

the machine's ID

the literal character '-' (dash)

the X display without the screen number, with the following prefixes removed, if present: ":", "localhost:" ."localhost.localdomain:". That is, a display of "localhost:10.0" produces just the number "10"

The contents of this file NAME=value assignment pairs and lines starting with # are comments (no comments are allowed otherwise). The following variable names are defined:

Variable

meaning

DBUS_SESSION_BUS_ADDRESS

the actual address of the server socket

DBUS_SESSION_BUS_PID

the PID of the server process

DBUS_SESSION_BUS_WINDOWID

the window ID

At least the DBUS_SESSION_BUS_ADDRESS variable MUST be present in this file.

Failure to open this file MUST be interpreted as absence of a running server. Therefore, the implementation MUST proceed to attempting to launch a new bus server if the file cannot be opened.

However, success in opening this file MUST NOT lead to the conclusion that the server is running. Thus, a failure to connect to the bus address obtained by the alternative method MUST NOT be considered a fatal error. If the connection cannot be established, the implementation MUST proceed to check the X selection settings or to start the server on its own.

If the implementation concludes that the D-Bus server is not running it MUST attempt to start a new server and it MUST also ensure that the daemon started as an effect of the "autolaunch" mechanism provides the lookup mechanisms described above, so subsequent calls can locate the newly started server. The implementation MUST also ensure that if two or more concurrent initiations happen, only one server remains running and all other initiations are able to obtain the address of this server and connect to it. In other words, the implementation MUST ensure that the X selection is not present when it attempts to set it, without allowing another process to set the selection between the verification and the setting (e.g., by using XGrabServer / XungrabServer).

Finding session services
On Unix systems, the session bus should search for .service files in $XDG_DATA_DIRS/dbus-1/services as defined by the XDG Base Directory Specification. Implementations may also search additional locations, with a higher or lower priority than the XDG directories.

As described in the XDG Base Directory Specification, software packages should install their session .service files to their configured ${datadir}/dbus-1/services, where ${datadir} is as defined by the GNU coding standards. System administrators or users can arrange for these service files to be read by setting XDG_DATA_DIRS or by symlinking them into the default locations.

System message bus
A computer may have a system message bus, accessible to all applications on the system. This message bus may be used to broadcast system events, such as adding new hardware devices, changes in the printer queue, and so forth.

The address of the system message bus is given in the DBUS_SYSTEM_BUS_ADDRESS environment variable. If that variable is not set, applications should try to connect to the well-known address unix:path=/var/run/dbus/system_bus_socket. [3]

On Unix systems, the system bus should default to searching for .service files in /usr/local/share/dbus-1/system-services, /usr/share/dbus-1/system-services and /lib/dbus-1/system-services, with that order of precedence. It may also search other implementation-specific locations, but should not vary these locations based on environment variables. [4]

Software packages should install their system .service files to their configured ${datadir}/dbus-1/system-services, where ${datadir} is as defined by the GNU coding standards. System administrators can arrange for these service files to be read by editing the system bus' configuration file or by symlinking them into the default locations.

Message Bus Messages
The special message bus name org.freedesktop.DBus responds to a number of additional messages at the object path /org/freedesktop/DBus. That object path is also used when emitting the the section called “org.freedesktop.DBus.NameOwnerChanged” signal.

For historical reasons, some of the methods in the org.freedesktop.DBus interface are available on multiple object paths. Message bus implementations should accept method calls that were added before specification version 0.26 on any object path. Message bus implementations should not accept newer method calls on unexpected object paths, and as a security hardening measure, older method calls that are security-sensitive may be rejected with the error org.freedesktop.DBus.Error.AccessDenied when called on an unexpected object path. Client software should send all method calls to /org/freedesktop/DBus instead of relying on this.

In addition to the method calls listed below, the message bus should implement the standard Introspectable, Properties and Peer interfaces (see the section called “Standard Interfaces”). Support for the Properties and Peer interfaces was added in version 1.11.x of the reference implementation of the message bus.

org.freedesktop.DBus.Hello
As a method:

            STRING Hello ()
          
Reply arguments:

Argument	Type	Description
0	STRING	Unique name assigned to the connection
Before an application is able to send messages to other applications it must send the org.freedesktop.DBus.Hello message to the message bus to obtain a unique name. If an application without a unique name tries to send a message to another application, or a message to the message bus itself that isn't the org.freedesktop.DBus.Hello message, it will be disconnected from the bus.

There is no corresponding "disconnect" request; if a client wishes to disconnect from the bus, it simply closes the socket (or other communication channel).

org.freedesktop.DBus.RequestName
As a method:

            UINT32 RequestName (in STRING name, in UINT32 flags)
          
Message arguments:

Argument	Type	Description
0	STRING	Name to request
1	UINT32	Flags
Reply arguments:

Argument	Type	Description
0	UINT32	Return value
Ask the message bus to assign the given name to the method caller. Each name maintains a queue of possible owners, where the head of the queue is the primary or current owner of the name. Each potential owner in the queue maintains the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE settings from its latest RequestName call. When RequestName is invoked the following occurs:

If the method caller is currently the primary owner of the name, the DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_DO_NOT_QUEUE values are updated with the values from the new RequestName call, and nothing further happens.

If the current primary owner (head of the queue) has DBUS_NAME_FLAG_ALLOW_REPLACEMENT set, and the RequestName invocation has the DBUS_NAME_FLAG_REPLACE_EXISTING flag, then the caller of RequestName replaces the current primary owner at the head of the queue and the current primary owner moves to the second position in the queue. If the caller of RequestName was in the queue previously its flags are updated with the values from the new RequestName in addition to moving it to the head of the queue.

If replacement is not possible, and the method caller is currently in the queue but not the primary owner, its flags are updated with the values from the new RequestName call.

If replacement is not possible, and the method caller is currently not in the queue, the method caller is appended to the queue.

If any connection in the queue has DBUS_NAME_FLAG_DO_NOT_QUEUE set and is not the primary owner, it is removed from the queue. This can apply to the previous primary owner (if it was replaced) or the method caller (if it updated the DBUS_NAME_FLAG_DO_NOT_QUEUE flag while still stuck in the queue, or if it was just added to the queue with that flag set).

Note that DBUS_NAME_FLAG_REPLACE_EXISTING results in "jumping the queue," even if another application already in the queue had specified DBUS_NAME_FLAG_REPLACE_EXISTING. This comes up if a primary owner that does not allow replacement goes away, and the next primary owner does allow replacement. In this case, queued items that specified DBUS_NAME_FLAG_REPLACE_EXISTING do not automatically replace the new primary owner. In other words, DBUS_NAME_FLAG_REPLACE_EXISTING is not saved, it is only used at the time RequestName is called. This is deliberate to avoid an infinite loop anytime two applications are both DBUS_NAME_FLAG_ALLOW_REPLACEMENT and DBUS_NAME_FLAG_REPLACE_EXISTING.

The flags argument contains any of the following values logically ORed together:

Conventional Name	Value	Description
DBUS_NAME_FLAG_ALLOW_REPLACEMENT	0x1	If an application A specifies this flag and succeeds in becoming the owner of the name, and another application B later calls RequestName with the DBUS_NAME_FLAG_REPLACE_EXISTING flag, then application A will lose ownership and receive a org.freedesktop.DBus.NameLost signal, and application B will become the new owner. If DBUS_NAME_FLAG_ALLOW_REPLACEMENT is not specified by application A, or DBUS_NAME_FLAG_REPLACE_EXISTING is not specified by application B, then application B will not replace application A as the owner.
DBUS_NAME_FLAG_REPLACE_EXISTING	0x2	Try to replace the current owner if there is one. If this flag is not set the application will only become the owner of the name if there is no current owner. If this flag is set, the application will replace the current owner if the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT.
DBUS_NAME_FLAG_DO_NOT_QUEUE	0x4	Without this flag, if an application requests a name that is already owned, the application will be placed in a queue to own the name when the current owner gives it up. If this flag is given, the application will not be placed in the queue, the request for the name will simply fail. This flag also affects behavior when an application is replaced as name owner; by default the application moves back into the waiting queue, unless this flag was provided when the application became the name owner.
The return code can be one of the following values:

Conventional Name	Value	Description
DBUS_REQUEST_NAME_REPLY_PRIMARY_OWNER	1	The caller is now the primary owner of the name, replacing any previous owner. Either the name had no owner before, or the caller specified DBUS_NAME_FLAG_REPLACE_EXISTING and the current owner specified DBUS_NAME_FLAG_ALLOW_REPLACEMENT.
DBUS_REQUEST_NAME_REPLY_IN_QUEUE	2	The name already had an owner, DBUS_NAME_FLAG_DO_NOT_QUEUE was not specified, and either the current owner did not specify DBUS_NAME_FLAG_ALLOW_REPLACEMENT or the requesting application did not specify DBUS_NAME_FLAG_REPLACE_EXISTING.
DBUS_REQUEST_NAME_REPLY_EXISTS	3	The name already has an owner, DBUS_NAME_FLAG_DO_NOT_QUEUE was specified, and either DBUS_NAME_FLAG_ALLOW_REPLACEMENT was not specified by the current owner, or DBUS_NAME_FLAG_REPLACE_EXISTING was not specified by the requesting application.
DBUS_REQUEST_NAME_REPLY_ALREADY_OWNER	4	The application trying to request ownership of a name is already the owner of it.
org.freedesktop.DBus.ReleaseName
As a method:

            UINT32 ReleaseName (in STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	Name to release
Reply arguments:

Argument	Type	Description
0	UINT32	Return value
Ask the message bus to release the method caller's claim to the given name. If the caller is the primary owner, a new primary owner will be selected from the queue if any other owners are waiting. If the caller is waiting in the queue for the name, the caller will removed from the queue and will not be made an owner of the name if it later becomes available. If there are no other owners in the queue for the name, it will be removed from the bus entirely. The return code can be one of the following values:

Conventional Name	Value	Description
DBUS_RELEASE_NAME_REPLY_RELEASED	1	The caller has released his claim on the given name. Either the caller was the primary owner of the name, and the name is now unused or taken by somebody waiting in the queue for the name, or the caller was waiting in the queue for the name and has now been removed from the queue.
DBUS_RELEASE_NAME_REPLY_NON_EXISTENT	2	The given name does not exist on this bus.
DBUS_RELEASE_NAME_REPLY_NOT_OWNER	3	The caller was not the primary owner of this name, and was also not waiting in the queue to own this name.
org.freedesktop.DBus.ListQueuedOwners
As a method:

            ARRAY of STRING ListQueuedOwners (in STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	The well-known bus name to query, such as com.example.cappuccino
Reply arguments:

Argument	Type	Description
0	ARRAY of STRING	The unique bus names of connections currently queued for the name
List the connections currently queued for a bus name (see Queued Name Owner).

org.freedesktop.DBus.ListNames
As a method:

            ARRAY of STRING ListNames ()
          
Reply arguments:

Argument	Type	Description
0	ARRAY of STRING	Array of strings where each string is a bus name
Returns a list of all currently-owned names on the bus.

org.freedesktop.DBus.ListActivatableNames
As a method:

            ARRAY of STRING ListActivatableNames ()
          
Reply arguments:

Argument	Type	Description
0	ARRAY of STRING	Array of strings where each string is a bus name
Returns a list of all names that can be activated on the bus.

org.freedesktop.DBus.NameHasOwner
As a method:

            BOOLEAN NameHasOwner (in STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	Name to check
Reply arguments:

Argument	Type	Description
0	BOOLEAN	Return value, true if the name exists
Checks if the specified name exists (currently has an owner).

org.freedesktop.DBus.NameOwnerChanged
This is a signal:

            NameOwnerChanged (STRING name, STRING old_owner, STRING new_owner)
          
Message arguments:

Argument	Type	Description
0	STRING	Name with a new owner
1	STRING	Old owner or empty string if none
2	STRING	New owner or empty string if none
This signal indicates that the owner of a name has changed. It's also the signal to use to detect the appearance of new names on the bus.

org.freedesktop.DBus.NameLost
This is a signal:

            NameLost (STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	Name which was lost
This signal is sent to a specific application when it loses ownership of a name.

org.freedesktop.DBus.NameAcquired
This is a signal:

            NameAcquired (STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	Name which was acquired
This signal is sent to a specific application when it gains ownership of a name.

org.freedesktop.DBus.StartServiceByName
As a method:

            UINT32 StartServiceByName (in STRING name, in UINT32 flags)
          
Message arguments:

Argument	Type	Description
0	STRING	Name of the service to start
1	UINT32	Flags (currently not used)
Reply arguments:

Argument	Type	Description
0	UINT32	Return value
Tries to launch the executable associated with a name (service activation), as an explicit request. This is an alternative to relying on auto-starting. For more information on how services are activated and the difference between auto-starting and explicit activation, see the section called “Message Bus Starting Services (Activation)”.

It is often preferable to carry out auto-starting instead of calling this method. This is because calling this method is subject to a time-of-check/time-of-use issue: if a caller asks the message bus to start a service so that the same caller can make follow-up method calls to that service, the fact that the message bus was able to start the required service is no guarantee that it will not have crashed or otherwise exited by the time the caller makes those follow-up method calls. As a result, calling this method does not remove the need for the caller to handle errors from method calls. Given that fact, it is usually simpler to rely on auto-starting, in which the required service starts as a side-effect of the first method call.

The return value can be one of the following values:

Identifier	Value	Description
DBUS_START_REPLY_SUCCESS	1	The service was successfully started.
DBUS_START_REPLY_ALREADY_RUNNING	2	A connection already owns the given name.
org.freedesktop.DBus.UpdateActivationEnvironment
As a method:

            UpdateActivationEnvironment (in ARRAY of DICT<STRING,STRING> environment)
          
Message arguments:

Argument	Type	Description
0	ARRAY of DICT<STRING,STRING>	Environment to add or update
Normally, session bus activated services inherit the environment of the bus daemon. This method adds to or modifies that environment when activating services.

Some bus instances, such as the standard system bus, may disable access to this method for some or all callers.

Note, both the environment variable names and values must be valid UTF-8. There's no way to update the activation environment with data that is invalid UTF-8.

org.freedesktop.DBus.GetNameOwner
As a method:

            STRING GetNameOwner (in STRING name)
          
Message arguments:

Argument	Type	Description
0	STRING	Name to get the owner of
Reply arguments:

Argument	Type	Description
0	STRING	Return value, a unique connection name
Returns the unique connection name of the primary owner of the name given. If the requested name doesn't have an owner, returns a org.freedesktop.DBus.Error.NameHasNoOwner error.

org.freedesktop.DBus.GetConnectionUnixUser
As a method:

            UINT32 GetConnectionUnixUser (in STRING bus_name)
          
Message arguments:

Argument	Type	Description
0	STRING	Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:

Argument	Type	Description
0	UINT32	Unix user ID
Returns the Unix user ID of the process connected to the server. If unable to determine it (for instance, because the process is not on the same machine as the bus daemon), an error is returned.

org.freedesktop.DBus.GetConnectionUnixProcessID
As a method:

            UINT32 GetConnectionUnixProcessID (in STRING bus_name)
          
Message arguments:

Argument	Type	Description
0	STRING	Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:

Argument	Type	Description
0	UINT32	Unix process id
Returns the Unix process ID of the process connected to the server. If unable to determine it (for instance, because the process is not on the same machine as the bus daemon), an error is returned.

org.freedesktop.DBus.GetConnectionCredentials
As a method:

            DICT<STRING,VARIANT> GetConnectionCredentials (in STRING bus_name)
          
Message arguments:

Argument	Type	Description
0	STRING	Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:

Argument	Type	Description
0	DICT<STRING,VARIANT>	Credentials
Returns as many credentials as possible for the process connected to the server. If unable to determine certain credentials (for instance, because the process is not on the same machine as the bus daemon, or because this version of the bus daemon does not support a particular security framework), or if the values of those credentials cannot be represented as documented here, then those credentials are omitted.

Keys in the returned dictionary not containing "." are defined by this specification. Bus daemon implementors supporting credentials frameworks not mentioned in this document should either contribute patches to this specification, or use keys containing "." and starting with a reversed domain name.

Key	Value type	Value
UnixUserID	UINT32	The numeric Unix user ID, as defined by POSIX
UnixGroupIDs	ARRAY of UINT32	The numeric Unix group IDs (including both the primary group and the supplementary groups), as defined by POSIX, in numerically sorted order. This array is either complete or absent: if the message bus is able to determine some but not all of the caller's groups, or if one of the groups is not representable in a UINT32, it must not add this credential to the dictionary.
ProcessID	UINT32	The numeric process ID, on platforms that have this concept. On Unix, this is the process ID defined by POSIX.
WindowsSID	STRING	The Windows security identifier in its string form, e.g. "S-1-5-21-3623811015-3361044348-30300820-1013" for a domain or local computer user or "S-1-5-18" for the LOCAL_SYSTEM user
LinuxSecurityLabel	ARRAY of BYTE	
On Linux systems, the security label that would result from the SO_PEERSEC getsockopt call. The array contains the non-zero bytes of the security label in an unspecified ASCII-compatible encoding[a], followed by a single zero byte.

For example, the SELinux context system_u:system_r:init_t:s0 (a string of length 27) would be encoded as 28 bytes ending with ':', 's', '0', '\x00'.[b]

On SELinux systems this is the SELinux context, as output by ps -Z or ls -Z. Typical values might include system_u:system_r:init_t:s0, unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023, or unconfined_u:unconfined_r:chrome_sandbox_t:s0-s0:c0.c1023.

On Smack systems, this is the Smack label. Typical values might include _, *, User, System or System::Shared.

On AppArmor systems, this is the AppArmor context, a composite string encoding the AppArmor label (one or more profiles) and the enforcement mode. Typical values might include unconfined, /usr/bin/firefox (enforce) or user1 (complain).

[a] It could be ASCII or UTF-8, but could also be ISO Latin-1 or any other encoding.

[b] Note that this is not the same as the older GetConnectionSELinuxContext method, which does not append the zero byte. Always appending the zero byte allows callers to read the string from the message payload without copying.

This method was added in D-Bus 1.7 to reduce the round-trips required to list a process's credentials. In older versions, calling this method will fail: applications should recover by using the separate methods such as the section called “org.freedesktop.DBus.GetConnectionUnixUser” instead.

org.freedesktop.DBus.GetAdtAuditSessionData
As a method:

            ARRAY of BYTE GetAdtAuditSessionData (in STRING bus_name)
          
Message arguments:

Argument	Type	Description
0	STRING	Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:

Argument	Type	Description
0	ARRAY of BYTE	auditing data as returned by adt_export_session_data()
Returns auditing data used by Solaris ADT, in an unspecified binary format. If you know what this means, please contribute documentation via the D-Bus bug tracking system. This method is on the core DBus interface for historical reasons; the same information should be made available via the section called “org.freedesktop.DBus.GetConnectionCredentials” in future.

org.freedesktop.DBus.GetConnectionSELinuxSecurityContext
As a method:

            ARRAY of BYTE GetConnectionSELinuxSecurityContext (in STRING bus_name)
          
Message arguments:

Argument	Type	Description
0	STRING	Unique or well-known bus name of the connection to query, such as :12.34 or com.example.tea
Reply arguments:

Argument	Type	Description
0	ARRAY of BYTE	some sort of string of bytes, not necessarily UTF-8, not including '\0'
Returns the security context used by SELinux, in an unspecified format. If you know what this means, please contribute documentation via the D-Bus bug tracking system. This method is on the core DBus interface for historical reasons; the same information should be made available via the section called “org.freedesktop.DBus.GetConnectionCredentials” in future.

org.freedesktop.DBus.AddMatch
As a method:

            AddMatch (in STRING rule)
          
Message arguments:

Argument	Type	Description
0	STRING	Match rule to add to the connection
Adds a match rule to match messages going through the message bus (see the section called “Match Rules”). If the bus does not have enough resources the org.freedesktop.DBus.Error.OOM error is returned.

org.freedesktop.DBus.RemoveMatch
As a method:

            RemoveMatch (in STRING rule)
          
Message arguments:

Argument	Type	Description
0	STRING	Match rule to remove from the connection
Removes the first rule that matches (see the section called “Match Rules”). If the rule is not found the org.freedesktop.DBus.Error.MatchRuleNotFound error is returned.

org.freedesktop.DBus.GetId
As a method:

            GetId (out STRING id)
          
Reply arguments:

Argument	Type	Description
0	STRING	Unique ID identifying the bus daemon
Gets the unique ID of the bus. The unique ID here is shared among all addresses the bus daemon is listening on (TCP, UNIX domain socket, etc.) and its format is described in the section called “UUIDs”. Each address the bus is listening on also has its own unique ID, as described in the section called “Server Addresses”. The per-bus and per-address IDs are not related. There is also a per-machine ID, described in the section called “org.freedesktop.DBus.Peer” and returned by org.freedesktop.DBus.Peer.GetMachineId(). For a desktop session bus, the bus ID can be used as a way to uniquely identify a user's session.

org.freedesktop.DBus.Monitoring.BecomeMonitor
As a method:

            BecomeMonitor (in ARRAY of STRING rule, in UINT32 flags)
          
Message arguments:

Argument	Type	Description
0	ARRAY of STRING	Match rules to add to the connection
1	UINT32	Not used, must be 0
Converts the connection into a monitor connection which can be used as a debugging/monitoring tool. Only a user who is privileged on this bus (by some implementation-specific definition) may create monitor connections[5].

Monitor connections lose all their bus names, including the unique connection name, and all their match rules. Sending messages on a monitor connection is not allowed: applications should use a private connection for monitoring.

Monitor connections may receive all messages, even messages that should only have gone to some other connection ("eavesdropping"). The first argument is a list of match rules, which replace any match rules that were previously active for this connection. These match rules are always treated as if they contained the special eavesdrop='true' member.

As a special case, an empty list of match rules (which would otherwise match nothing, making the monitor useless) is treated as a shorthand for matching all messages.

The second argument might be used for flags to influence the behaviour of the monitor connection in future D-Bus versions.

Message bus implementations should attempt to minimize the side-effects of monitoring — in particular, unlike ordinary eavesdropping, monitoring the system bus does not require the access control rules to be relaxed, which would change the set of messages that can be delivered to their (non-monitor) destinations. However, it is unavoidable that monitoring will increase the message bus's resource consumption. In edge cases where there was barely enough time or memory without monitoring, this might result in message deliveries failing when they would otherwise have succeeded.

Message Bus Properties
The special message bus name org.freedesktop.DBus exports several properties (see the section called “org.freedesktop.DBus.Properties”) on the object path /org/freedesktop/DBus.

org.freedesktop.DBus.Features
As a property:

            Read-only constant ARRAY of STRING Features
          
This property lists abstract “features” provided by the message bus, and can be used by clients to detect the capabilities of the message bus with which they are communicating. This property was added in version 1.11.x of the reference implementation of the message bus.

Items in the returned array not containing “.” are defined by this specification. Bus daemon implementors wishing to advertise features not mentioned in this document should either contribute patches to this specification, or use keys containing “.” and starting with their own reversed domain name, for example com.example.MyBus.SubliminalMessages.

The features currently defined in this specification are as follows:

AppArmor
This message bus filters messages via the AppArmor security framework. This feature should only be advertised if AppArmor mediation is enabled and active at runtime; merely compiling in support for AppArmor should not result in this feature being advertised on message bus instances where it is disabled by message bus or operating system configuration.

HeaderFiltering
This message bus guarantees that it will remove header fields that it does not understand when it relays messages, so that a client receiving a recently-defined header field that is specified to be controlled by the message bus can safely assume that it was in fact set by the message bus. This check is needed because older message bus implementations did not guarantee to filter headers in this way, so a malicious client could send any recently-defined header field with a crafted value of its choice through an older message bus that did not understand that header field.

SELinux
This message bus filters messages via the SELinux security framework. Similar to apparmor, this feature should only be advertised if SELinux mediation is enabled and active at runtime (if SELinux is placed in permissive mode, that is still considered to be active).

SystemdActivation
When asked to activate a service that has the SystemdService field in its .service file, this message bus will carry out systemd activation (for details see the section called “systemd Activation”).

org.freedesktop.DBus.Interfaces
As a property:

            Read-only constant ARRAY of STRING Interfaces
          
This property lists interfaces provided by the /org/freedesktop/DBus object, and can be used by clients to detect the capabilities of the message bus with which they are communicating. Unlike the standard Introspectable interface, querying this property does not require parsing XML. This property was added in version 1.11.x of the reference implementation of the message bus.

The standard org.freedesktop.DBus and org.freedesktop.DBus.Properties interfaces are not included in the value of this property, because their presence can be inferred from the fact that a method call on org.freedesktop.DBus.Properties asking for properties of org.freedesktop.DBus was successful. The standard org.freedesktop.DBus.Peer and org.freedesktop.DBus.Introspectable interfaces are not included in the value of this property either, because they do not indicate features of the message bus implementation.

Glossary
This glossary defines some of the terms used in this specification.

Bus Name
The message bus maintains an association between names and connections. (Normally, there's one connection per application.) A bus name is simply an identifier used to locate connections. For example, the hypothetical com.yoyodyne.Screensaver name might be used to send a message to a screensaver from Yoyodyne Corporation. An application is said to own a name if the message bus has associated the application's connection with the name. Names may also have queued owners (see Queued Name Owner). The bus assigns a unique name to each connection, see Unique Connection Name. Other names can be thought of as "well-known names" and are used to find applications that offer specific functionality.

See the section called “Bus names” for details of the syntax and naming conventions for bus names.

Message
A message is the atomic unit of communication via the D-Bus protocol. It consists of a header and a body; the body is made up of arguments.

Message Bus
The message bus is a special application that forwards or routes messages between a group of applications connected to the message bus. It also manages names used for routing messages.

Name
See Bus Name. "Name" may also be used to refer to some of the other names in D-Bus, such as interface names.

Namespace
Used to prevent collisions when defining new interfaces, bus names etc. The convention used is the same one Java uses for defining classes: a reversed domain name. See the section called “Bus names”, the section called “Interface names”, the section called “Error names”, the section called “Valid Object Paths”.

Object
Each application contains objects, which have interfaces and methods. Objects are referred to by a name, called a path.

One-to-One
An application talking directly to another application, without going through a message bus. One-to-one connections may be "peer to peer" or "client to server." The D-Bus protocol has no concept of client vs. server after a connection has authenticated; the flow of messages is symmetrical (full duplex).

Path
Object references (object names) in D-Bus are organized into a filesystem-style hierarchy, so each object is named by a path. As in LDAP, there's no difference between "files" and "directories"; a path can refer to an object, while still having child objects below it.

Queued Name Owner
Each bus name has a primary owner; messages sent to the name go to the primary owner. However, certain names also maintain a queue of secondary owners "waiting in the wings." If the primary owner releases the name, then the first secondary owner in the queue automatically becomes the new owner of the name.

Service
A service is an executable that can be launched by the bus daemon. Services normally guarantee some particular features, for example they may guarantee that they will request a specific name such as "com.example.Screensaver1", have a singleton object "/com/example/Screensaver1", and that object will implement the interface "com.example.Screensaver1.Control".

Service Description Files
".service files" tell the bus about service applications that can be launched (see Service). Most importantly they provide a mapping from bus names to services that will request those names when they start up.

Unique Connection Name
The special name automatically assigned to each connection by the message bus. This name will never change owner, and will be unique (never reused during the lifetime of the message bus). It will begin with a ':' character.


[1] Lockfiles are used instead of real file locking fcntl() because real locking implementations are still flaky on network filesystems.

[2] This idiosyncratic quoting style is based on the rules for escaping items to appear inside single-quoted strings in POSIX /bin/sh, but please note that backslashes that are not inside single quotes have different behaviour. This syntax does not offer any way to represent an apostrophe inside single quotes (it is necessary to leave the single-quoted section, backslash-escape the apostrophe and re-enter single quotes), or to represent a comma outside single quotes (it is necessary to wrap it in a single-quoted section).

[3] The D-Bus reference implementation actually honors the $(localstatedir) configure option for this address, on both client and server side.

[4] The system bus is security-sensitive and is typically executed by an init system with a clean environment. Its launch helper process is particularly security-sensitive, and specifically clears its own environment.

[5] In the reference implementation, the default configuration is that each user (identified by numeric user ID) may monitor their own session bus, and the root user (user ID zero) may monitor the system bus.