:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

== GIO Tutorial

GIO прагне забезпечити сучасний, простий у користуванні API VFS, який сидить на потрібному рівні в стеку бібліотеки, а також інші загально корисні API для настільних додатків (таких як мережа та підтримка D-Bus). Мета полягає в тому, щоб подолати недоліки GnomeVFS і надати API, який настільки хороший, що розробники віддають перевагу йому над необробленими POSIX-викликами. Крім усього іншого, це означає використання GObject. Це також означає не клонування POSIX API, а надання документо-орієнтованих інтерфейсів вищого рівня.

Абстрактна модель файлової системи GIO складається з ряду інтерфейсів та базових класів для вводу/виводу та файлів:

* GFile посилання на файл
* GFileInfo інформація про файл або файлову систему
* GFileEnumerator перелік файлів або директорій
* GDrive представляє пристрій
* GVolume представляє файлову систему в абстрактний спосіб
* GMount представляє змонтовану файлову систему

Також існує ряд класів потоків, схожих на ієрархії потоків введення та виведення, які можна знайти у фреймфорках типу Java:

* GInputStream читання даних
* GOutputStream запис даних
* GIOStream читання та запис даних
* GSeekable інтерфейс, опціонально реалізований потоками для підтримки пошуку

Є інтерфейси, пов’язані з програмами та типами файлів, якими вони обробляються:

* GAppInfo інформація про встановлений додаток
* GIcon абстрактний тип для піктограм файлів та додатків

Існує фреймворк для зберігання та отримання налаштувань програми:

* GSettings зберігає та витягує налаштування програми

Існує підтримка мережевого програмування, включаючи моніторинг підключення, роздільну здатність імен, API сокетів низького рівня та допоміжні класи клієнтів та серверів:

* GSocket Об'єкт незалежної сокетної платформи на низькому рівні
* GResolver асинхронний та скасовуваний DNS-роздільник
* GSocketClient помічник мережевого клієнта високого рівня
* GSocketService помічник мережевого сервера високого рівня
* GSocketConnection мережевий потік підключення
* GNetworkMonitor моніторинг підключення до мережі

Існує підтримка підключення до D-Bus, надсилання та отримання повідомлень, володіння та перегляд імен шин та надання об'єктів доступними на шині:

* GDBusConnection з'єднання D-Bus
* GDBusMethodInvocation для обробки віддалених дзвінків
* GDBusServer помічник для прийому з'єднань
* GDBusProxy проксі для доступу до інтерфейсів D-Bus на віддаленому об'єкті

Крім цього, GIO надає засоби для моніторингу файлів, асинхронного вводу/виводу та завершення імені файлу. Окрім інтерфейсів, GIO забезпечує реалізацію для локального випадку. Реалізації для різних мережевих файлових систем забезпечуються пакетом GVFS як модулі, що завантажуються.

Інший вибір дизайну, який свідомо пориває з дизайном GnomeVFS, полягає в тому, щоб вивести бекенди за процесс, що мінімізує залежність і робить всю систему більш надійною. Бекенди не включені в GIO, а в окремий пакет GVFS. Пакет GVFS також містить демон GVFS, який породжує подальший монтаж демонів для кожного окремого з'єднання.

.GIO в стеку бібліотеки GTK+
image::https://developer.gnome.org/gio/unstable/gvfs-overview.png[]

Модель GIO вводу/виводу є зі станом: якщо програма встановлює, наприклад, з'єднання SFTP з сервером, воно стає доступним для всіх програм у сеансі; користувачеві не потрібно вводити свій пароль знову і знову.

Однією з великих переваг розміщення VFS в шарі GLib є те, що GTK+ може безпосередньо використовувати його, наприклад, у програмі вибору файлів.

== Написання GIO-додатків

Інформація в документації GLib про написання програм GLib, як правило, застосовується при написанні GIO-додатків.

=== Потоки

GDBus має власну приватну робочу нитку, тому програми, що використовують GDBus, мають принаймні 3 потоки. GIO широко використовує концепцію основного контексту потоку за замовчуванням для виконання зворотних викликів асинхронних методів у тому ж контексті, в якому була запущена операція.

=== Асинхронне програмування

Багато функцій GIO поставляються у двох версіях: синхронні та асинхронні, позначені суфіксом `_async`. Важливо використовувати їх належним чином: синхронні виклики не повинні використовуватися з основного циклу, який спільно використовується з іншим кодом, наприклад, одним у головному потоці програми. Синхронні виклики блокуються, поки вони не завершаться, і операції вводу/виводу можуть зайняти помітні проміжки часу (навіть на «швидких» SSD). Блокування ітерації основного циклу під час очікування вводу/виводу означає, що інші джерела в основному циклі не будуть розсилатися, наприклад, обробники вводу та перемальовування для користувальницького інтерфейсу програми. Це може призвести до «заморожування» програми, поки не завершиться введення/виведення.

Кілька автономних груп функцій, таких як код, згенерований `gdbus-codegen`, використовують іншу домовленість: функції є асинхронними за замовчуванням, і саме синхронна версія має суфікс `_sync`. Окрім відмінностей іменування, до них слід ставитись так само, як і до функцій, що дотримуються звичайної конвенції, наведеної вище.

Асинхронні (`_async`) версії функцій повертають управління абоненту негайно, після планування вводу/виводу в ядрі та додавання зворотного виклику для нього в основний цикл. Цей зворотний виклик буде викликаний після завершення операції. Зі зворотного виклику слід викликати парну функцію `_finish`, щоб отримати повернене значення операції вводу/виводу та будь-які помилки, що сталися. Для отримання додаткової інформації про використання та реалізацію асинхронних функцій див. `GAsyncResult` та `GTask`.

Запускаючи кілька послідовних асинхронних операцій, вони будуть виконуватися паралельно (до довільної межі, встановленої внутрішнім пулом робочих ниток GIO).

Синхронні версії функцій можна використовувати на початку запуску програми, коли немає головного циклу для блокування, наприклад для завантаження початкових файлів конфігурації. Вони також можуть використовуватися для вводу-виводу на файлах, які гарантовано є невеликими, і на локальному диску. Зауважте, що домашній каталог користувача не гарантується на локальному диску.

=== Безпека

Коли вашій програмі необхідно виконати певну привілейовану операцію (скажімо, створити новий обліковий запис користувача), існують різні способи вирішити це:

* Реалізуйте демон, який пропонує привілейовану операцію. Зручний спосіб зробити це - послуга системної шини D-Bus. Демону, ймовірно, знадобляться способи перевірити особу та авторизацію абонента перед виконанням операції. `polkit` - це фреймворк, яка дозволяє це зробити.
* Скористайтеся невеликим помічником, який виконується з підвищеними привілеями через `pkexec`. `pkexec` - це невеликий код запуску програми, який є частиною `polkit`.
* Скористайтеся невеликим помічником, який виконується з підвищеними привілеями, використовуючи `suid root`.

Жоден із цих підходів не є явним переможцем, всі вони мають свої переваги та недоліки.

При написанні коду, який працює з підвищеними привілеями, важливо дотримуватися деяких основних правил безпечного програмування. Девід Уілер має чудову книгу на цю тему, Безпечне програмування для Linux та Unix HOWTO.

Використовуючи GIO в коді, який працює з підвищеними привілеями, ви повинні бути обережними. GIO має точки розширення, реалізація яких завантажується з модулів (виконуваного коду в спільних об'єктах), що може дозволити зловмиснику занести свій власний код у вашу програму, позначаючи його на завантаження коду як модуля. Однак GIO ніколи не завантажує модулі з вашого домашнього каталогу, за винятком випадків, коли його явно попросять це зробити через змінну середовища.

У більшості випадків ваша помічна програма повинна бути настільки малою, що вам не потрібен GIO, API якого в значній мірі розроблені для підтримки повномасштабних настільних додатків. Якщо ви не можете протистояти зручності цих API, ось кілька кроків, які ви повинні зробити:

* Очищення навколишнього середовища, наприклад за допомогою функції `clearenv()`. Девід Уілер має гарне пояснення, чому важливо санітувати довкілля. Див. Запуск програм GIO для переліку всіх змінних середовища, що впливають на GIO. Зокрема, важливими є `PATH` (використовується для пошуку бінарних файлів), `GIO_EXTRA_MODULES` (використовується для пошуку завантажуваних модулів) та `DBUS_{SYSTEM, SESSION}_BUS_ADDRESS` (використовується для пошуку системи D-Bus та шини сеансу).

Не використовуйте GVfs, встановивши `GIO_USE_VFS=local` у середовищі. Причина уникати GVfs у чутливих до безпеки програмах полягає в тому, що він використовує багато бібліотек, які не обов'язково перевірялися на предмет проблем безпеки. Gvfs також широко розповсюджений і покладається на наявність сеансової шини.

=== Складання GIO-додатків

GIO іде разом з файлом `gio-2.0.pc`, який ви маєте використовувати разом з `pkg-config` для отримання потрібної інформації щодо файлів заголовка та бібліотек. Дивіться `man` сторінку  `pkg-config` або документацію GLib для додаткової інформації щодо використання `pkg-config` для компіляції вашого застосування.

Якщо ви використовуєте GIO в UNIX-подібних системах, ви можете використовувати специфічні для UNIX інтерфейси GIO, такі як `GUnixInputStream`, `GUnixOutputStream`, `GUnixMount` або `GDesktopAppInfo`. Для цього використовуйте файл `gio-unix-2.0.pc` замість `gio-2.0.pc`

=== Запуск GIO-додатків

GIO перевіряє кілька змінних оточуючого середовища на додаток до тих, які використовує GLib.

`XDG_DATA_HOME`,`XDG_DATA_DIRS`.  GIO використовує ці змінні середовища для пошуку інформації MIME. Для отримання додаткової інформації див. Спільну базу даних MIME-інформації та Специфікацію базового каталогу.

`GVFS_DISABLE_FUSE`. Цю змінну можна встановити для того, щоб Gvfs не запускав fuse бекенд, що може бути небажаним або непотрібним у певних ситуаціях.

`GIO_USE_VFS`. Цю змінну середовища можна встановити щоб вказати реалізацію GVfs для цілей налагодження, щоб замінити типову. Реалізація GVfs для локальних файлів, що входить до GIO, має ім'я `"local"`, реалізація в модулі gvfs має назву `gvfs`. Найчастіше системне програмне забезпечення встановлює це значення `local`, щоб уникнути того, щоб API `GFile` виконували зайві виклики DBus. Довідка зі кожним значенням може використовуватися для друку списку доступних реалізацій на стандартний вихід.

Наступні змінні середовища корисні лише для налагодження самого GIO або модулів, які він завантажує. Їх не слід встановлювати у виробничих умовах.

`GIO_USE_FILE_MONITOR`. Цю змінну можна встановити ім'я реалізації `GFileMonitor`, щоб замінити типовий для цілей налагодження. Реалізація `GFileMonitor` для локальних файлів, що входить до GIO на Linux, має назву `inotify`, інші, що вбідовані, будуються як модулі (залежно від платформи) називаються `fam` і `fen`. Довідка зі спеціальним значенням може використовуватися для друку списку доступних реалізацій на стандартний вихід.

`GIO_USE_VOLUME_MONITOR`. Цю змінну можна встановити для завдання реалізації `GVolumeMonitor`, щоб замінити типовий для цілей налагодження. Реалізація `GVolumeMonitor` для локальних файлів, що входить до GIO, має ім'я `unix`, реалізація на основі `udisks2` у модулі gvfs має назву `udisks2`. Довідка зі спеціальним значенням може використовуватися для друку списку доступних реалізацій на стандартний вихід.

`GIO_USE_TLS`. Цю змінну можна встановити для встановлення реалізації `GTlsBackend`, щоб замінити типовий для цілей налагодження. GIO не включає реалізацію `GTlsBackend`, реалізація на основі `gnutls` в модулі `glib-networking` має назву `gnutls`. Довідка зі спеціальним значенням може використовуватися для друку списку доступних реалізацій на стандартний вихід.

`GIO_MODULE_DIR`. Коли ця змінна середовище встановлена ​​на шлях, GIO завантажить модулі з цього альтернативного каталогу замість каталогу, вбудованого в GIO. Це корисно, наприклад, під час запуску тестів.

`GIO_EXTRA_MODULES`. Коли ця змінна середовище встановлена ​​на шлях або набір шляхів, розділених двокрапкою, GIO спробує завантажити додаткові модулі по цьому шляху.

`GSETTINGS_BACKEND`. Цю змінну можна встановити на ім'я реалізації GSettingsBackend, щоб замінити типовий для цілей налагодження. Реалізація на основі пам'яті, яка включена в GIO, має ім'я `memory`, а в `dconf` назва `dconf`. Довідка зі спеціальним значенням може використовуватися для друку списку доступних реалізацій на стандартний вихід.

`GSETTINGS_SCHEMA_DIR`. Цю змінну можна встановити назви каталогів, які слід враховувати під час пошуку скомпільованих схем для `GSettings`, на додаток до підкаталогів `glib-2.0/schemas` системи XDG. Щоб вказати кілька каталогів, використовуйте `G_SEARCHPATH_SEPARATOR_S` як роздільник.

`DBUS_SYSTEM_BUS_ADDRESS`. Ця змінна використовується для пошуку адреси системної шини D-Bus. Формат адрес D-Bus див. У специфікації D-Bus. Встановлення цієї змінної переосмислює конкретні для платформи способи визначення адреси системної шини.

`DBUS_SESSION_BUS_ADDRESS`. Ця змінна використовується для пошуку адреси шини сеансу D-Bus. Встановлення цієї змінної переосмислює конкретні для платформи способи визначення адреси шини сеансу.

`DBUS_STARTER_BUS_TYPE`. З цією змінною можна ознайомитись, щоб знайти шину «стартера» для програми, запущеного за допомогою активації D-Bus. Можливі значення - `system` або `session`.

`G_DBUS_DEBUG`. Через цю змінну можна встановити список параметрів налагодження, які змушують GLib друкувати різні типи інформації про налагодження при використанні підпрограм D-Bus.

`transport` Показати активність вводу-виводу (наприклад, читання та запис)
`message` Показати всі надіслані та отримані повідомлення D-Bus
`payload` Показати корисне навантаження для всіх відправлених та отриманих повідомлень D-Bus (означає повідомлення)
`call` Простежує використання API `g_dbus_connection_call()` та використання `g_dbus_connection_call_sync()`
`signal` Показати, коли буде отриманий сигнал D-Bus
`incoming` Показати, коли надходить вхідний дзвінок методу D-Bus
`return` Показати, коли відповідь буде повернуто через API `GDBusMethodInvocation`
`emission` Простежує використання API `g_dbus_connection_emit_signal()`
`authentication` Показати інформацію про автентифікацію з'єднання
`address` Показати інформацію про пошук адрес D-Bus та автозапуск

Спеціальне значення `all` може використовуватися для включення всіх параметрів налагодження. Довідка зі спеціальним значенням може використовуватися для друку списку підтримуваних параметрів для стандартного виводу.

`G_DBUS_COOKIE_SHA1_KEYRING_DIR`. Може використовуватися для заміщення каталогу, який використовується для зберігання ключових рядків, використовуваних у механізмі аутентифікації `DBUS_COOKIE_SHA1`. Зазвичай використовуваний каталог - це `.dbus-keyrings` у домашньому каталозі користувача.

`G_DBUS_COOKIE_SHA1_KEYRING_DIR_IGNORE_PERMISSION`. Якщо встановлено, дозволи каталогу, який використовується для зберігання ключів, використовуваних у механізмі аутентифікації `DBUS_COOKIE_SHA1`, не перевіряться. Зазвичай каталог повинен читати тільки користувач.

=== Розширення GIO

Багато функціональних можливостей, доступних через GIO, реалізовані в завантажуваних модулях, а модулі забезпечують зручний спосіб розширення GIO. На додаток до API `GIOModule`, який підтримує запис таких модулів, GIO має механізм визначення точок розширення та реєстрації їх реалізацій, див. `GIOExtensionPoint`.

Наступні точки розширення в даний час визначаються GIO:

`G_VFS_EXTENSION_POINT_NAME`. Дозволяє змінити функціональність класу GVfs. Реалізація цієї точки розширення повинна виходити з GVfs. GIO використовує реалізацію з найвищим пріоритетом, який є активним, див. `G_vfs_is_active()`. GIO реалізує цю точку розширення для локальних файлів, `gvfs` містить реалізацію, яка підтримує всі резервні файли в `gvfs`.

`G_VOLUME_MONITOR_EXTENSION_POINT_NAME`. Дозволяє додавати більше моніторів гучності. Реалізація цієї точки розширення повинна виходити з `GVolumeMonitor`. GIO використовує всі зареєстровані розширення. `gvfs` містить реалізацію, яка працює разом із реалізацією GVfs у gvfs.

`G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME`. Дозволяє змінити "рідний" монітор гучності. Реалізація цієї точки розширення повинна виходити з `GNativeVolumeMonitor`. GIO використовує реалізацію з найвищим пріоритетом, який підтримується, як це визначено `is_supported()` `vfunc` в `GVolumeMonitorClass`. GIO реалізує цю точку розширення для локальних версій, `gvfs` містить реалізацію на основі `udisks2`.

`G_LOCAL_FILE_MONITOR_EXTENSION_POINT_NAME`. Дозволяє змінити реалізацію монітора файлів для локальних файлів. Реалізація цієї точки розширення повинна виходити з `GLocalFileMonitor`. GIO використовує реалізацію з найвищим пріоритетом, який підтримується, як це визначено `is_supported()` `vfunc` в `GLocalFileMonitorClass`. GIO використовує цю точку розширення внутрішньо, щоб перемикатися між своїми моніторинговими реалізаціями файлів на основі `fam` і `inotify`.

`G_LOCAL_DIRECTORY_MONITOR_EXTENSION_POINT_NAME`. Дозволяє замінити реалізацію монітора каталогу для локальних файлів. Реалізація цієї точки розширення повинна бути отримана від `GLocalDirectoryMonitor`. GIO використовує реалізацію з найвищим пріоритетом, який підтримується, як це визначено `is_supported()` `vfunc` в `GLocalDirectoryMonitorClass`. GIO використовує цю точку розширення внутрішньо для переключення між своїми моніторинговими реалізаціями каталогів на основі `fam` і `inotify`.

`G_DESKTOP_APP_INFO_LOOKUP_EXTENSION_POINT_NAME`. Тільки для Unix. Дозволяє надати спосіб асоціювати обробники за замовчуванням із схемами URI. Реалізація цієї точки розширення повинна реалізувати інтерфейс `GDesktopAppInfoLookup`. GIO використовує реалізацію з найвищим пріоритетом. Цю точку розширення було припинено у GLib 2.28. Вона все ще доступна для збереження стабільності API та ABI, але GIO вже не використовує її для обробників за замовчуванням. Натомість використовується механізм обробці міми разом із псевдо-міме-типами `x-scheme-handler`.

`G_SETTINGS_BACKEND_EXTENSION_POINT_NAME`. Дозволяє надати альтернативне сховище для `GSettings`. Реалізація цієї точки розширення має виходити з типу `GSettingsBackend`. GIO містить реалізацію цієї точки розширення на основі ключових даних, ще одну надає `dconf`.

`G_PROXY_EXTENSION_POINT_NAME`. Дозволяє надати реалізації для проксі-доступу до мережі. Реалізація цієї точки розширення повинна забезпечувати інтерфейс `GProxy` і повинен бути названий за мережевим протоколом, до якого вони проксують. `glib-networking` містить реалізацію цієї точки розширення на основі `libproxy`.

`G_TLS_BACKEND_EXTENSION_POINT_NAME`. Дозволяє надати реалізації для підтримки TLS. Реалізація цієї точки розширення повинна реалізовувати інтерфейс `GTlsBackend`. `glib-networking` містить реалізацію цієї точки розширення.

`G_NETWORK_MONITOR_EXTENSION_POINT_NAME`. Дозволяє надати реалізації для моніторингу підключення до мережі. Реалізація цієї точки розширення повинна реалізувати інтерфейс `GNetworkMonitorInterface`. GIO містить реалізацію цієї точки розширення, яка використовує інтерфейс `netlink` ядра Linux.

