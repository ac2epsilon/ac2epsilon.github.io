include::headers.adoc[]

== Розуміння гачків життєвого циклу Vue.js

Гачки життєвого циклу є важливою складовою будь-якого серйозного компонента. Вам часто потрібно знати, коли ваш компонент створений, доданий до DOM, оновлений або знищений. Гачки життєвого циклу - це вікно в світ бібліотеки, яку ви використовуєте, як вона працює за кадром, і, як правило, це викликає почуття трепету чи неяковості у новачків.

На щастя, це досить легко зрозуміти, як це видно на цій схемі. (Дозволено https://vuejs.org/.)

Діаграма життєвого циклу компонента Vue.js

=== Створення (ініціалізація)

Гачки створення - це найперші гачки, які працюють у вашому компоненті. Вони дозволяють виконувати дії до того, як ваш компонент навіть був доданий до DOM. На відміну від будь-яких інших, гачки створення також виконуються під час відтворення на стороні сервера.

Use creation hooks if you need to set things up in your component both during client rendering and server rendering. You will not have access to the DOM or the target mounting element (this.$el) inside of creation hooks.
Використовуйте гачки створення, якщо вам потрібно налаштувати речі у своєму компоненті як під час відтворення на клієнті, так і на сервері. Ви не матимете доступу до DOM або цільового монтуємого елемента (`this.$el`) всередині гачків створення.

`beforeCreate`

Гак `beforeCreate` працює при самій ініціалізації вашого компонента. `data` не підключене до реактивності, а `events` ще не встановлені.

Приклад:

[source,html]
----
<script>
export default {
  beforeCreate() {
    console.log('Ніщо не буде створене до мене!')
  }
}
</script>
----

`created`

У гачку `created` ви зможете отримати доступ до реактивних даних і активні події. Шаблони та віртуальний DOM ще не змонтовані або надані.

Приклад:

[source,html]
----
<script>
export default {
  data() {
    return {
      property: 'Blank'
    }
  },

  computed: {
    propertyComputed() {
      console.log('Я змінююсь коли змінюється this.property.')
      return this.property
    }
  },

  created() {
    this.property = 'Приклад оновлення властивості.'
    console.log('propertyComputed буде оновлюваться, бо this.property тепер реактивне.')
  }
}
</script>
----

=== Монтування (вставка DOM)

Монтажні гачки найчастіше є найчастіше використовуваними гачками, добре це чи ні. Вони дозволяють отримати доступ до свого компонента безпосередньо перед і після першої візуалізації. Однак вони не запускаються під час візуалізації на стороні сервера.

_Використовуйте, якщо:_ Вам потрібно отримати доступ або змінити DOM вашого компонента безпосередньо перед або після початкового візуалізації.

_Не використовуйте, якщо:_ Вам потрібно отримати деякі дані для вашого компонента при ініціалізації. Використовуйте для цього `created` (або `created` + `activated` для збережених компонентів), особливо якщо вам потрібні дані під час відображення з боку сервера.

`beforeMount`

Гак `beforeMount` запускається безпосередньо перед початковою візуалізацією та після того, як будуть скомпільовані функції шаблону чи візуалізації. Швидше за все, вам ніколи не потрібно буде використовувати цей гачок. Пам’ятайте, що він не викликається під час серверної візуалізації.

Приклад:

[source,html]
----
<script>
export default {
  beforeMount() {
    console.log(`this.$el doesn't exist yet, but it will soon!`)
  }
}
</script>
----

`mounted`

In the mounted hook, you will have full access to the reactive component, templates, and rendered DOM (via. this.$el). Mounted is the most-often used lifecycle hook. The most frequently used patterns are fetching data for your component (use created for this instead,) and modifying the DOM, often to integrate non-Vue libraries.
У гачку `mounted` ви матимете повний доступ до реактивного компонента, шаблонів та відмальований DOM (через `this.$el`). `mounted` - це найчастіше використовуваний гак життєвого циклу. Найчастіше використовувані шаблони - це отримання даних для вашого компонента (використовуйте `created` замість цього) та модифікація DOM, часто для інтеграції бібліотек, які не є частиною Vue.

Приклад:

[source,html]
----
<template>
  <p> Я текст всередині компонента. </p>
</template>

<script>
export default {
  mounted() {
    console.log(this.$el.textContent) // Я текст всередині компонента.
  }
}
</script>
----

=== Оновлення (Diff & Re-render)

Гачки оновлення викликаються щоразу, коли реактивна властивість, використовувана вашим компонентом, змінюється, або щось інше викликає його повторне відображення. Вони дозволяють підключитися до циклу споглядай-обчисляй-візуалізуй для вашого компонента.

_Використовуйте, якщо:_ Вам потрібно знати, коли ваш компонент повторно відображається, можливо, для налагодження чи профілювання.

_Не використовуйте, якщо:_ Вам потрібно знати, коли змінюється реактивна властивість вашого компонента. Використовуйте для цього обчислювані властивості або спостерігачі.

`beforeUpdate`

Гак `beforeUpdate` запускається після зміни даних про ваш компонент і починається цикл оновлення, безпосередньо перед тим, як DOM буде виправлено і повторно виведено. Це дозволяє отримати новий стан будь-яких реакційно-здатних даних про ваш компонент, перш ніж вони фактично будуть відображені.

Приклад:

[source,html]
----
<script>
export default {
  data() {
    return {
      counter: 0
    }
  },

  beforeUpdate() {
    console.log(this.counter) 
    // Щосекунди занотовує лічильник, перш ніж оновити DOM.
  },

  created() {
    setInterval(() => {
      this.counter++
    }, 1000)
  }
}
</script>
----

`updated`

Гак `updated` запускається після зміни даних про ваш компонент і повторний показ DOM. Якщо вам потрібно отримати доступ до DOM після зміни властивості, тут, мабуть, найбезпечніше місце для цього.

Приклад:

[source,html]
----
<template>
  <p ref="dom-element">{{counter}}</p>
</template>
<script>
export default {
  data() {
    return {
      counter: 0
    }
  },

  updated() {
    // Вибухає щосекунди, завжди має бути true
    console.log(+this.$refs['dom-element'].textContent === this.counter)
  },

  created() {
    setInterval(() => {
      this.counter++
    }, 1000)
  }
}
</script>
----

=== Знищення (згортання)

Гачки знищення дозволяють виконувати дії, коли ваш компонент знищений, наприклад, як результат очищення чи надсилання аналітики. Вони спрацьовують, коли ваш компонент виривається та видаляється з DOM.

`beforeDestroy`

`beforeDestroy` спрацьовує безпосередньо перед забуттям. Ваш компонент все ще буде повністю присутнім та функціональним. Якщо вам потрібно очистити події чи реактивні підписки, `beforeDestroy`, ймовірно, саме час зробити це.

Приклад:

[source,html]
----
<script>
export default {
  data() {
    return {
      someLeakyProperty: "Я втрачаю пам'ять, якщо код не кодочищується!"
    }
  },

  beforeDestroy() {
// Виконайте процедуру відстеження для someLeakyProperty.
// (У цьому випадку фактично нічого)
    this.someLeakyProperty = null
    delete this.someLeakyProperty
  }
}
</script>
----

`destroyed`

Коли ви дістанетесь гака `destroyed`, на вашому компоненті майже нічого не залишилося. Все, що було прикріплено до нього, було знищено. Ви можете використовувати гачок `destroyed`, щоб зробити будь-яку чистку в останню хвилину або повідомити віддаленому серверу, що компонент був знищений, як _sneaky snitch_. <_<

Приклад:

[source,html]
----
<script>
import MyCreepyAnalyticsService from './somewhere-bad'

export default {
  destroyed() {
    console.log(this) // Тут практично нічого немає!
    MyCreepyAnalyticsService.informService('Компонент знищений. Усі активи переміщені.")
  }
}
</script>
----

=== Інші гачки

Є ще два гачки, `activated` та `deactivated`. Вони призначені для збереження живих компонентів - теми, яка не входить у рамки цієї статті. Досить сказати, що вони дозволяють виявити, коли компонент, який загорнуто в тег `<keep-alive> </keep-alive>`, увімкнено чи вимкнено. Ви можете використовувати їх для отримання даних для вашого компонента або обробки змін у стані, ефективно вести себе як `created` та `beforeDestroy` без необхідності робити повну перебудову компонентів.