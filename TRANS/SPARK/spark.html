<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="imageblock">
<div class="content">
<img src="spark-logo-trademark.png" alt="spark-logo-trademark.png" />
</div>
</div>
<h1 id="_apache_spark________">Apache Spark ™ - це уніфікований механізм аналітики для масштабної обробки даних.</h1>
<div class="sect1">
<h2 id="_">Швидкість</h2>
<div class="sectionbody">
<div class="sect4">
<h5 id="____100__">Виконуйте навантаження в 100 разів швидше.</h5>
<div class="paragraph"><p>Apache Spark досягає високої продуктивності як для пакетних, так і потокових даних, використовуючи сучасний DAG-планувальник, оптимізатор запитів і механізм фізичного виконання.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Простота використання</h2>
<div class="sectionbody">
<div class="sect4">
<h5 id="_____java_scala_python_r__sql">Швидко пишіть програми на Java, Scala, Python, R та SQL.</h5>
<div class="paragraph"><p>Spark пропонує понад 80 операторів високого рівня, які спрощують створення паралельних додатків. І ви можете використовувати його інтерактивно з оболонок Scala, Python, R та SQL.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__2">Загальність</h2>
<div class="sectionbody">
<div class="sect4">
<h5 id="__sql____">Поєднайте SQL, поточну та комплексну аналітику.</h5>
<div class="paragraph"><p>Spark посилює стек бібліотек, включаючи SQL і DataFrames, MLlib для машинного навчання, GraphX ​​та Spark Streaming. Ви можете безперешкодно поєднувати ці бібліотеки в одній програмі.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___">Виконується будь-де</h2>
<div class="sectionbody">
<div class="sect4">
<h5 id="_spark___hadoop_apache_mesos_kubernetes____________">Spark працює на Hadoop, Apache Mesos, Kubernetes, окремо або в хмарі. Він може отримати доступ до різноманітних джерел даних.</h5>
<div class="paragraph"><p>Ви можете запустити Spark, використовуючи його окремий кластерний режим, на EC2, Hadoop YARN, Mesos або Kubernetes. Доступ до даних у форматі HDFS, Alluxio, Apache Cassandra, Apache HBase, Apache Hive та сотнях інших джерел даних.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Швидкий старт</h2>
<div class="sectionbody">
<div class="paragraph"><p>Цей підручник пропонує швидке ознайомлення з використанням Spark. Спочатку ми введемо API через інтерактивну оболонку Spark (у Python чи Scala), а потім покажемо, як писати програми на Java, Scala та Python.</p></div>
<div class="paragraph"><p>Щоб дотримуватися цього посібника, спочатку завантажте упакований випуск Spark з веб-сайту Spark. Оскільки ми не будемо використовувати HDFS, ви можете завантажити пакет для будь-якої версії Hadoop.</p></div>
<div class="paragraph"><p>Зауважте, що до Spark 2.0 основним інтерфейсом програмування Spark був еластичний розподілений набір даних (Resilient Distributed Dataset, RDD). Після Spark 2.0 RDD замінюються Dataset, який суворо типізований як RDD, але з більш багатими оптимізаціями за лаштунками. Інтерфейс RDD все ще підтримується, і ви можете отримати більш детальну інформацію в посібнику з програмування RDD. Однак ми настійно рекомендуємо перейти на використання Dataset, який має кращі показники, ніж RDD. Для отримання додаткової інформації про Dataset див. Посібник із програмування SQL.</p></div>
<div class="sect2">
<h3 id="__3">Безпека</h3>
<div class="paragraph"><p>Безпека Spark за замовчуванням вимкнена. Це може означати, що ви вразливі до атаки за замовчуванням. Будь ласка, перегляньте безпеку Spark перед запуском Spark.</p></div>
</div>
<div class="sect2">
<h3 id="_____spark">Інтерактивний аналіз із оболонкою Spark</h3>
<div class="sect3">
<h4 id="__4">Основи</h4>
<div class="paragraph"><p>Оболонка Spark забезпечує простий спосіб вивчення API, а також потужний інструмент для інтерактивного аналізу даних. Він доступний або в Scala (який працює на Java VM, тому є хорошим способом використання існуючих бібліотек Java), або в Python. Почніть роботу, запустивши в каталозі Spark наступне:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>./bin/spark-shell
</pre></div></div></div>
<div class="paragraph"><p>Основна абстракція Spark - це розподілена колекція елементів, що називається Набір даних <code>Dataset</code>. Набори даних можна створити з Hadoop InputFormat (таких як файли HDFS) або шляхом перетворення інших наборів даних. Давайте зробимо новий набір даних із тексту файлу <code>README</code> у каталозі джерел Spark:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">textFile</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;README.md&quot;</span><span class="o">)</span>
<span class="n">textFile</span><span class="k">:</span> <span class="kt">org.apache.spark.sql.Dataset</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">value:</span> <span class="kt">string</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете отримати значення з Набору даних безпосередньо, викликавши виконня  деяких дій, або трансформуючи Набір даних, щоб отримати новий. Для отримання більш детальної інформації, будь ласка, ознайомтеся з документацією API.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">textFile</span><span class="o">.</span><span class="n">count</span><span class="o">()</span> <span class="c1">// Кількість елементів у цьому наборі даних</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">126</span> <span class="c1">// Може відрізнятись від вашої, оскільки README.md змінюватиметься з часом, як і інші результати</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">textFile</span><span class="o">.</span><span class="n">first</span><span class="o">()</span> <span class="c1">// Перший елемент у цьому наборі даних</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">#</span> <span class="nc">Apache</span> <span class="nc">Spark</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер перетворимо цей набір даних у новий. Ми викликаємо фільтр, щоб повернути новий набір даних із підмножиною елементів у файлі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">linesWithSpark</span> <span class="k">=</span> <span class="n">textFile</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Spark&quot;</span><span class="o">))</span>
<span class="n">linesWithSpark</span><span class="k">:</span> <span class="kt">org.apache.spark.sql.Dataset</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">value:</span> <span class="kt">string</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо поєднати трансформації та дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">textFile</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;Spark&quot;</span><span class="o">)).</span><span class="n">count</span><span class="o">()</span> <span class="c1">// Скільки рядків містить &quot;Spark&quot;?</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="______">Детальніше про операції з набором даних</h4>
<div class="paragraph"><p>Дії та перетворення набору даних можна використовувати для більш складних обчислень. Скажімо, ми хочемо знайти рядок з найбільшою кількістю слів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">textFile</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">).</span><span class="n">size</span><span class="o">).</span><span class="n">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Першим виконується відображення рядка на ціле значення, створюючи новий набір даних. <code>reduce</code> визивається для цього набору даних, щоб знайти найбільшу кількість слів. Аргументи для <code>map</code> та <code>reduce</code> - це функціональні літерали Scala (замикання) і можуть використовувати будь-яку мовну функцію або бібліотеку Scala/Java. Наприклад, ми можемо легко викликати функції, оголошені в іншому місці. Ми будемо використовувати функцію <code>Math.max()</code>, щоб полегшити розуміння цього коду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.lang.Math</span>
<span class="k">import</span> <span class="nn">java.lang.Math</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">textFile</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">).</span><span class="n">size</span><span class="o">).</span><span class="n">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Math</span><span class="o">.</span><span class="n">max</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Однією поширеною схемою потоку даних є MapReduce, яку популяризує Hadoop. Spark може легко реалізувати потоки MapReduce:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">wordCounts</span> <span class="k">=</span> <span class="n">textFile</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)).</span><span class="n">groupByKey</span><span class="o">(</span><span class="n">identity</span><span class="o">).</span><span class="n">count</span><span class="o">()</span>
<span class="n">wordCounts</span><span class="k">:</span> <span class="kt">org.apache.spark.sql.Dataset</span><span class="o">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Long</span><span class="o">)]</span> <span class="k">=</span> <span class="o">[</span><span class="kt">value:</span> <span class="kt">string</span><span class="p">,</span> <span class="kt">count</span><span class="o">(</span><span class="err">1</span><span class="o">)</span><span class="kt">:</span> <span class="kt">bigint</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут ми закликаємо <code>flatMap</code> для перетворення набору даних рядків у набір слів, а потім поєднуємо в <code>groupByKey</code> і підраховуємо, щоб обчислити кількість слів у файлі у вигляді набору даних з пар <code>(String, Long)</code>. Щоб зібрати кількість слів у нашій оболонці, ми можемо викликати <code>collect</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">wordCounts</span><span class="o">.</span><span class="n">collect</span><span class="o">()</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">Int</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">((</span><span class="n">means</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">under</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="k">this</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="o">(</span><span class="nc">Because</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="nc">Python</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="o">(</span><span class="n">agree</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">cluster</span><span class="o">.,</span><span class="mi">1</span><span class="o">),</span> <span class="o">...)</span>
</pre></div></div></div>
</div>
<div class="sect3">
<h4 id="__5">Кешування</h4>
<div class="paragraph"><p>Spark також підтримує перетягування наборів даних у кеш-пам'ять, що є загальною для кластера. Це дуже корисно, коли до них звертаються неодноразово, наприклад, при запитах до невеликого "гарячого" набору даних або при запуску ітеративного алгоритму, наприклад <code>PageRank</code>. Як простий приклад, позначимо кешування нашого набору <code>linesWithSpark</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">linesWithSpark</span><span class="o">.</span><span class="n">cache</span><span class="o">()</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">linesWithSpark.</span><span class="k">type</span> <span class="o">=</span> <span class="o">[</span><span class="kt">value:</span> <span class="kt">string</span><span class="o">]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">linesWithSpark</span><span class="o">.</span><span class="n">count</span><span class="o">()</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">15</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">linesWithSpark</span><span class="o">.</span><span class="n">count</span><span class="o">()</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">15</span>
</pre></div></div></div>
<div class="paragraph"><p>Може здатися нерозумним використання Spark для вивчення та кешування текстового файлу в 100 рядків. Цікава частина полягає в тому, що ці самі функції можна використовувати на дуже великих наборах даних, навіть коли вони поділені на десятки чи сотні вузлів. Ви також можете це зробити інтерактивно, підключивши <code>bin/spark-shell</code> до кластеру, як описано в посібнику з програмування RDD.</p></div>
</div>
<div class="sect3">
<h4 id="___3">Самозабезпечені програми</h4>
<div class="paragraph"><p>Припустимо, ми хочемо написати автономну програму за допомогою API Spark. Ми розглянемо простий додаток у Scala (з sbt), Java (з Maven) та Python (pip).</p></div>
<div class="paragraph"><p>Ми створимо в Scala дуже простий додаток Spark - насправді настільки простий, що називається <code>SimpleApp.scala</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="cm">/* SimpleApp.scala */</span>
<span class="k">import</span> <span class="nn">org.apache.spark.sql.SparkSession</span>

<span class="k">object</span> <span class="nc">SimpleApp</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">logFile</span> <span class="k">=</span> <span class="s">&quot;YOUR_SPARK_HOME/README.md&quot;</span> <span class="c1">// Має бути якийсь файл у вашій системі</span>
    <span class="k">val</span> <span class="n">spark</span> <span class="k">=</span> <span class="nc">SparkSession</span><span class="o">.</span><span class="n">builder</span><span class="o">.</span><span class="n">appName</span><span class="o">(</span><span class="s">&quot;Simple Application&quot;</span><span class="o">).</span><span class="n">getOrCreate</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">logData</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="n">logFile</span><span class="o">).</span><span class="n">cache</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">numAs</span> <span class="k">=</span> <span class="n">logData</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)).</span><span class="n">count</span><span class="o">()</span>
    <span class="k">val</span> <span class="n">numBs</span> <span class="k">=</span> <span class="n">logData</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)).</span><span class="n">count</span><span class="o">()</span>
    <span class="n">println</span><span class="o">(</span><span class="s">s&quot;Lines with a: </span><span class="si">$numAs</span><span class="s">, Lines with b: </span><span class="si">$numBs</span><span class="s">&quot;</span><span class="o">)</span>
    <span class="n">spark</span><span class="o">.</span><span class="n">stop</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що програми повинні визначати метод <code>main()</code> замість розширення <code>scala.App</code>. Підкласи <code>scala.App</code> можуть працювати неправильно.</p></div>
<div class="paragraph"><p>Ця програма просто підраховує кількість рядків, що містять <code>"a"</code>, і число, що містить <code>"b"</code> в <code>Spark</code> <code>README</code>. Зауважте, що вам потрібно буде замінити <code>YOUR_SPARK_HOME</code> на місце, де встановлено Spark. На відміну від попередніх прикладів із оболонкою Spark, яка ініціалізує власну <code>SparkSession</code>, ми ініціалізуємо <code>SparkSession</code> як частину програми.</p></div>
<div class="paragraph"><p>Ми викликаємо <code>SparkSession.builder</code> щоб побудувати <code>[[SparkSession]]</code>, потім встановити ім'я програми та нарешті викликати <code>getOrCreate</code>, щоб отримати екземпляр <code>[[SparkSession]]</code>.</p></div>
<div class="paragraph"><p>Our application depends on the Spark API, so we’ll also include an sbt configuration file, build.sbt, which explains that Spark is a dependency. This file also adds a repository that Spark depends on:
Наш додаток залежить від Spark API, тому ми також включимо файл конфігурації sbt, <code>build.sbt</code>, який пояснює, що Spark - це залежність. Цей файл також додає сховище, від якого залежить Spark:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>name := "Simple Project"

version := "1.0"

scalaVersion := "2.12.10"

libraryDependencies += "org.apache.spark" %% "spark-sql" % "2.4.6"</code></pre>
</div></div>
<div class="paragraph"><p>Щоб sbt працював правильно, нам потрібно буде компонувати <code>SimpleApp.scala</code> і <code>build.sbt</code> відповідно до типової структури каталогів. Після того, як все буде на місці, ми можемо створити пакет JAR, що містить код програми, а потім використовувати сценарій <code>spark-submit</code> для запуску нашої програми.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1"># Скелет вашого каталогу повинен виглядати приблизно так</span>
$ find .
.
./build.sbt
./src
./src/main
./src/main/scala
./src/main/scala/SimpleApp.scala

<span class="c1"># Пакує jar, що містить ваше застосування</span>
$ sbt package
...
<span class="o">[</span>info<span class="o">]</span> Packaging <span class="o">{</span>..<span class="o">}</span>/<span class="o">{</span>..<span class="o">}</span>/target/scala-2.12/simple-project_2.12-1.0.jar

<span class="c1"># Використовуйте spark-submit, щоб запустити ваше застосування</span>
$ YOUR_SPARK_HOME/bin/spark-submit <span class="se">\</span>
  --class <span class="s2">&quot;SimpleApp&quot;</span> <span class="se">\</span>
  --master local<span class="o">[</span><span class="m">4</span><span class="o">]</span> <span class="se">\</span>
  target/scala-2.12/simple-project_2.12-1.0.jar
...
Lines with a: <span class="m">46</span>, Lines with b: <span class="m">23</span>
</pre></div></div></div>
</div>
</div>
<div class="sect2">
<h3 id="____2">Куди піти звідси</h3>
<div class="paragraph"><p>Вітаємо з запуском першої програми Spark!</p></div>
<div class="paragraph"><p>Щоб отримати поглиблений огляд API, почніть з посібника з програмування RDD та керівництва з програмування SQL або перегляньте меню «Посібники з програмування» для інших компонентів.</p></div>
<div class="paragraph"><p>Для запуску програм на кластері перейдіть до огляду розгортання.</p></div>
<div class="paragraph"><p>Нарешті, Spark включає декілька зразків у каталозі прикладів (Scala, Java, Python, R). Ви можете запустити їх наступним чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">#</span> <span class="nc">Для</span> <span class="nc">Scala</span> <span class="n">та</span> <span class="nc">Java</span> <span class="n">використовуйте</span> <span class="n">run</span><span class="o">-</span><span class="n">example</span><span class="k">:</span>
<span class="kt">./bin/run-example</span> <span class="kt">SparkPi</span>

<span class="k">#</span> <span class="nc">Для</span> <span class="n">прикладів</span> <span class="nc">Python</span> <span class="n">напряму</span> <span class="n">використовуйте</span> <span class="n">spark</span><span class="o">-</span><span class="n">submit</span><span class="k">:</span>
<span class="kt">./bin/spark-submit</span> <span class="kt">examples/src/main/python/pi.py</span>

<span class="k">#</span> <span class="nc">Для</span> <span class="n">прикладів</span> <span class="n">R</span> <span class="n">напряму</span> <span class="n">використовуйте</span> <span class="n">spark</span><span class="o">-</span><span class="n">submit</span><span class="k">:</span>
<span class="kt">./bin/spark-submit</span> <span class="kt">examples/src/main/r/dataframe.R</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____rdd">Посібник з програмування RDD</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="__6">Огляд</h3>
<div class="paragraph"><p>На високому рівні кожна програма Spark складається з драйверної програми, яка виконує основну функцію користувача та виконує різні паралельні операції на кластері. Основна абстракція, яку надає Spark, - це еластичний розподілений набір даних (RDD), який представляє собою сукупність елементів, розподілених по вузлах кластеру, якими можна керувати паралельно. RDD створюються, починаючи з файлу у файловій системі Hadoop (або будь-якої іншої файлової системи, підтримуваної Hadoop), або існуючої колекції Scala в драйверній програмі, та трансформуючи її. Користувачі можуть також попросити Spark зберегти RDD в пам'яті, що дозволяє ефективно використовувати його протягом паралельних операцій. Нарешті, RDD автоматично відновлюються після відмови вузла.</p></div>
<div class="paragraph"><p>Друга абстракція в Spark - це загальні змінні, які можна використовувати в паралельних операціях. За замовчуванням, коли Spark виконує функцію паралельно у вигляді набору завдань на різних вузлах, він надсилає копію кожної змінної, яка використовується у функції, до кожного завдання. Іноді змінну потрібно розділити між завданнями або між завданнями та програмою драйвера. Spark підтримує два типи загальних змінних: широкомовні змінні, які можна використовувати для кешування значень у пам'яті на всіх вузлах, і акумулятори, що є змінними, до яких може бути лише додано, як лічильники та суми.</p></div>
<div class="paragraph"><p>У цьому посібнику показано кожну з цих можливостей на кожній з підтримуваних мов Spark. Найпростіше слідкувати за подіями, якщо ви запускаєте інтерактивну оболонку Spark - або <code>bin/spark-shell</code> для оболонки Scala, або <code>bin/pyspark</code> для Python.</p></div>
</div>
<div class="sect2">
<h3 id="___spark">Лінкування зі Spark</h3>
<div class="paragraph"><p>Spark 2.4.6 побудована та розповсюджена для роботи зі Scala 2.12 за замовчуванням. (Spark може бути побудована для роботи з іншими версіями Scala.) Для написання програм у Scala вам потрібно буде використовувати сумісну версію Scala (наприклад, 2.12.X).</p></div>
<div class="paragraph"><p>Щоб написати програму Spark, потрібно додати залежність Maven від Spark. Spark доступна через Maven Central за адресою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>groupId = org.apache.spark
artifactId = spark-core_2.12
version = 2.4.6</code></pre>
</div></div>
<div class="paragraph"><p>Крім того, якщо ви хочете отримати доступ до кластера HDFS, вам потрібно додати залежність від <code>hadoop-client</code> для вашої версії HDFS.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>groupId = org.apache.hadoop
artifactId = hadoop-client
version = &lt;your-hdfs-version&gt;</code></pre>
</div></div>
<div class="paragraph"><p>Нарешті, вам потрібно імпортувати кілька класів Spark у свою програму. Додайте наступні рядки:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.apache.spark.SparkContext</span>
<span class="k">import</span> <span class="nn">org.apache.spark.SparkConf</span>
</pre></div></div></div>
<div class="paragraph"><p>(До Spark 1.3.0 вам потрібно явно імпортувати <code>org.apache.spark.SparkContext._</code>, щоб увімкнути основні <code>implicit</code> перетворення.)</p></div>
</div>
<div class="sect2">
<h3 id="__spark">Ініціалізація Spark</h3>
<div class="paragraph"><p>Перше, що повинна зробити програма Spark - це створити об'єкт <code>SparkContext</code>, який повідомляє Spark, як отримати доступ до кластеру. Для створення <code>SparkContext</code> спочатку потрібно створити об'єкт <code>SparkConf</code>, який містить інформацію про вашу програму.</p></div>
<div class="paragraph"><p>На JVM може бути активним лише один <code>SparkContext</code>. Ви повинні <code>stop()</code> активний <code>SparkContext</code> перед тим, як створити новий.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">conf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SparkConf</span><span class="o">().</span><span class="n">setAppName</span><span class="o">(</span><span class="n">appName</span><span class="o">).</span><span class="n">setMaster</span><span class="o">(</span><span class="n">master</span><span class="o">)</span>
<span class="k">new</span> <span class="nc">SparkContext</span><span class="o">(</span><span class="n">conf</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Параметр <code>appName</code> - це назва вашої програми для показу в інтерфейсі кластера. <code>master</code> - це група кластерів Spark, Mesos або YARN, або спеціальний рядок` “local”` для запуску в локальному режимі. На практиці, працюючи на кластері, ви не хочете жорстко кодувати <code>master</code> у програму, а швидше запускаєте додаток через <code>spark-submit</code>, та отримуєте його там. Однак для локального тестування та тестування модулів ви можете передати <code>“local”</code> для запуску програми Spark.</p></div>
<div class="sect3">
<h4 id="___4">Використання оболонки</h4>
<div class="paragraph"><p>У оболонці Spark для вас уже створено спеціальний інтерпретатор-обізнаний  <code>SparkContext</code>, у змінній з назвою <code>sc</code>. Створення власного <code>SparkContext</code> не буде робити. Ви можете встановити, до якого контексту підключається <code>master</code>, за допомогою аргументу <code>--master</code>, і ви можете додати JARs до <code>classpath</code>, передавши розділений комою список до аргументу <code>--jars</code>. Ви також можете додати залежності (наприклад, пакети Spark) до сеансу оболонки, надавши розділений комами список координат Maven до аргументу <code>--packages</code>. Будь-які додаткові сховища, де можуть існувати залежності (наприклад, Sonatype), можуть бути передані до аргументу <code>--repositories</code>. Наприклад, для запуску <code>bin/spark-shell</code> рівно на чотирьох ядрах використовуйте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./bin/spark-shell --master local<span class="o">[</span><span class="m">4</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Або, щоб також додати code.jar до свого <code>classpath</code>, використовуйте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./bin/spark-shell --master local<span class="o">[</span><span class="m">4</span><span class="o">]</span> --jars code.jar
</pre></div></div></div>
<div class="paragraph"><p>Щоб включити залежність, використовуючи координати Maven:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>$ ./bin/spark-shell --master local<span class="o">[</span><span class="m">4</span><span class="o">]</span> --packages <span class="s2">&quot;org.example:example:0.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Для повного переліку параметрів запустіть <code>spark-shell --help</code>. За лаштунками, <code>spark-shell</code> викликає більш загальний сценарій <code>spark-submit</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_____rdd">Еластичні розподілені набори даних (RDD)</h3>
<div class="paragraph"><p>Spark обертається навколо концепції еластичного розподіленого набору даних (RDD), що є стійким до відмов набором елементів, яким можна оперувати паралельно. Є два способи створення RDD: паралелізація існуючої колекції у вашій драйверній програмі або посилання на набір даних у зовнішню систему зберігання даних, наприклад, спільну файлову систему, HDFS, HBase або будь-яке джерело даних, що пропонує Hadoop InputFormat.</p></div>
<div class="sect3">
<h4 id="___5">Паралелізовані колекції</h4>
<div class="paragraph"><p>Паралелізовані колекції створюються за допомогою виклику методу <code>parallelize</code> на <code>SparkContext</code> для існуючої колекції у вашій драйверній програмі (Scala <code>Seq</code>). Елементи колекції копіюються для формування розподіленого набору даних, яким можна оперувати паралельно. Наприклад, ось як створити паралельну колекцію, що містить числа 1 до 5:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="n">distData</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">parallelize</span><span class="o">(</span><span class="n">data</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Після створення розподіленим набором даних (<code>distData</code>) можна керувати паралельно. Наприклад, ми можемо викликати <code>distData.reduce ((a, b) =&gt; a + b)</code>, щоб додати елементи масиву. Ми опишемо операції над розподіленими наборами даних згодом.</p></div>
<div class="paragraph"><p>Одним з важливих параметрів для паралельних колекцій є кількість розділів для нарізання набору даних. Spark буде виконувати одне завдання для кожного розділу кластера. Зазвичай потрібно 2-4 розділи для кожного процесора кластеру. Зазвичай Spark намагається автоматично встановити кількість розділів на основі кластеру. Однак ви також можете встановити його вручну, передавши його як другий параметр для <code>parallelize</code> (наприклад,  <code>sc.parallelize(data, 10)</code>). Примітка: деякі місця в коді використовують термін фрагменти (синонім розділів) для підтримки зворотної сумісності.</p></div>
</div>
<div class="sect3">
<h4 id="____3">Зовнішні набори даних</h4>
<div class="paragraph"><p>Spark може створювати розподілені набори даних з будь-якого джерела зберігання, підтримуваного Hadoop, включаючи локальну файлову систему, HDFS, Cassandra, HBase, Amazon S3 тощо. Spark підтримує текстові файли, SequenceFiles та будь-який інший Hadoop InputFormat.</p></div>
<div class="paragraph"><p>Текстові файли RDD можна створити за допомогою методу <code>textFile</code> на <code>SparkContext</code>. Цей метод бере URI для файлу (або локальний шлях на машині, або UDD <code>hdfs://</code>, <code>s3a://</code> тощо) і читає його як набір рядків. Ось приклад виклику:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">distFile</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data.txt&quot;</span><span class="o">)</span>
<span class="n">distFile</span><span class="k">:</span> <span class="kt">org.apache.spark.rdd.RDD</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">data</span><span class="o">.</span><span class="n">txt</span> <span class="nc">MapPartitionsRDD</span><span class="o">[</span><span class="err">10</span><span class="o">]</span> <span class="n">at</span> <span class="n">textFile</span> <span class="n">at</span> <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">26</span>
</pre></div></div></div>
<div class="paragraph"><p>Після створення <code>distFile</code> можна діяти за допомогою операцій набору даних. Наприклад, ми можемо додати розміри всіх рядків за допомогою операцій <code>map</code> і <code>reduce</code> наступним чином: <code>distFile.map (s =&gt; s.length) .reduce ((a, b) =&gt; a + b)</code>.</p></div>
<div class="paragraph"><p>Деякі зауваження щодо читання файлів зі Spark:</p></div>
<div class="ulist"><ul>
<li>
<p>
Якщо використовується шлях до локальної файлової системи, файл також повинен бути доступним тим самим шляхом на робочих вузлах. Або скопіюйте файл усім працівникам або використовуйте спільну мережеву файлову систему.
</p>
</li>
<li>
<p>
Усі методи введення файлів Spark, включаючи <code>textFile</code>, підтримують роботу на каталогах, стислих файлах та підстановках. Наприклад, ви можете використовувати <code>textFile("/my/directory")</code>, <code>textFile("/my/directory/*.txt")</code> і <code>textFile("/my/directory/*.gz")</code>.
</p>
</li>
<li>
<p>
Метод <code>textFile</code> також приймає необов'язковий другий аргумент для контролю кількості розділів файлу. За замовчуванням Spark створює один розділ для кожного блоку файлу (блоки HDFS за замовчуванням становлять 128 Мб), але ви також можете запитати більшу кількість розділів, передавши більше значення. Зауважте, що у вас не може бути менше розділів, ніж блоків.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Крім текстових файлів, API Scala Spark також підтримує декілька інших форматів даних:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>SparkContext.wholeTextFiles</code> дозволяє читати каталог, що містить декілька невеликих текстових файлів, і повертає кожен з них у вигляді пар <code>(filename, content)</code>. Це відрізняється від <code>textFile</code>, який би повертав один запис на рядок у кожному файлі. Розмежування визначається локальністю даних, яка в деяких випадках може призвести до надто малої кількості розділів. У цих випадках <code>wholeTextFiles</code> надає необов'язковий другий аргумент для контролю мінімальної кількості розділів.
</p>
</li>
<li>
<p>
Для <code>SequenceFiles</code> використовуйте метод SparkContext послідовного файлу <code>sequenceFile[K, V]</code>, де <code>K</code> і <code>V</code> - типи ключів і значень у файлі. Це повинні бути підкласи інтерфейсу для запису Hadoop, наприклад, <code>IntWritable</code> і <code>Text</code>. Крім того, Spark дозволяє вказувати нативні типи для кількох загальних <code>Writable</code>; наприклад, <code>rowFile[Int, String]</code> автоматично прочитає <code>IntWritable</code> і <code>Text</code>.
</p>
</li>
<li>
<p>
Для інших Hadoop InputFormats ви можете використовувати метод <code>SparkContext.hadoopRDD</code>, який приймає довільний <code>JobConf</code> і клас формату введення, ключовий клас та клас значень. Встановіть їх так само, як і для роботи Hadoop зі своїм джерелом введення. Ви також можете використовувати <em>SparkContext.newAPIHadoopRDD</em> для InputFormats на основі "нового" API MapReduce (<code>org.apache.hadoop.mapreduce</code>).
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>RDD.saveAsObjectFile</code> та <code>SparkContext.objectFile</code> підтримують збереження RDD у простому форматі, що складається з серіалізованих об’єктів Java. Хоча це не так ефективно, як спеціалізовані формати на зразок Avro, він пропонує простий спосіб зберегти будь-яку RDD.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="__rdd">Операції RDD</h3>
<div class="paragraph"><p>RDD підтримують два типи операцій: перетворення, які створюють новий набір даних із наявного, та дії, які повертають значення драйверній програмі після запуску обчислення на наборі даних. Наприклад, <code>map</code> - це перетворення, яке передає кожен елемент набору даних через функцію та повертає новий RDD, що представляє результати. З іншого боку, <code>reduce</code> - це дія, яка агрегує всі елементи RDD за допомогою певної функції та повертає кінцевий результат програмі драйверів (хоча існує також паралельне <code>reduceByKey</code>, яке повертає розподілений набір даних).</p></div>
<div class="paragraph"><p>Всі перетворення в Spark ліниві, оскільки вони не підраховують свої результати одразу. Натомість вони просто запам'ятовують перетворення, застосовані до деякого базового набору даних (наприклад, до файлу). Перетворення обчислюються лише тоді, коли дія вимагає повернення результату в програму драйверів. Така конструкція дозволяє Spark працювати більш ефективно. Наприклад, ми можемо збагнути, що набір даних, створений за допомогою <code>map</code>, буде використовуватися для <code>reduce</code> і повертати драйверу лише результат <code>reduce</code>, а не збільшений відображений набір даних.</p></div>
<div class="paragraph"><p>За замовчуванням кожен перетворений RDD може бути перерахований щоразу, коли  на ньому виконується дія. Однак ви також можете зберегти RDD в пам'яті, використовуючи метод <code>persist</code> (або <code>cache</code>), і в цьому випадку Spark буде зберігати елементи коло кластера для набагато швидшого доступу наступного разу, коли ви питаєте його. Існує також підтримка збережених RDD на диску або тиражуються через декілька вузлів.</p></div>
<div class="sect3">
<h4 id="__7">Основи</h4>
<div class="paragraph"><p>Щоб проілюструвати основи RDD, розгляньте просту програму нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">lines</span> <span class="k">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;data.txt&quot;</span><span class="o">)</span>
<span class="k">val</span> <span class="n">lineLengths</span> <span class="k">=</span> <span class="n">lines</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="k">val</span> <span class="n">totalLength</span> <span class="k">=</span> <span class="n">lineLengths</span><span class="o">.</span><span class="n">reduce</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший рядок визначає базовий RDD із зовнішнього файлу. Цей набір даних не завантажується в пам'ять або іншим чином діє на: рядки - це лише вказівник на файл. Другий рядок визначає <code>lineLengths</code> як результат перетворення <code>map</code>. Знову ж таки, <code>LineLengths</code> не обчислюється одразу через лінь. Нарешті, ми запускаємо <code>reduce</code>, яке є дією. У цей момент Spark розбиває обчислення на завдання для запуску на окремих машинах, і кожна машина виконує як свою частину <code>map</code>, так і локальне <code>reduce</code>, повертаючи лише свою відповідь на програму драйвера.</p></div>
<div class="paragraph"><p>Якщо ми також хотіли пізніше знову використовувати <code>lineLengths</code>, ми можемо додати:</p></div>
<div class="paragraph"><p>lineLengths.persist()
before the reduce, which would cause lineLengths to be saved in memory after the first time it is computed.</p></div>
<div class="paragraph"><p>Passing Functions to Spark</p></div>
<div class="paragraph"><p>Spark’s API relies heavily on passing functions in the driver program to run on the cluster. There are two recommended ways to do this:</p></div>
<div class="paragraph"><p>Anonymous function syntax, which can be used for short pieces of code.
Static methods in a global singleton object. For example, you can define object MyFunctions and then pass MyFunctions.func1, as follows:
object MyFunctions {
  def func1(s: String): String = { &#8230; }
}</p></div>
<div class="paragraph"><p>myRdd.map(MyFunctions.func1)
Note that while it is also possible to pass a reference to a method in a class instance (as opposed to a singleton object), this requires sending the object that contains that class along with the method. For example, consider:</p></div>
<div class="paragraph"><p>class MyClass {
  def func1(s: String): String = { &#8230; }
  def doStuff(rdd: RDD[String]): RDD[String] = { rdd.map(func1) }
}
Here, if we create a new MyClass instance and call doStuff on it, the map inside there references the func1 method of that MyClass instance, so the whole object needs to be sent to the cluster. It is similar to writing rdd.map(x &#8658; this.func1(x)).</p></div>
<div class="paragraph"><p>In a similar way, accessing fields of the outer object will reference the whole object:</p></div>
<div class="paragraph"><p>class MyClass {
  val field = "Hello"
  def doStuff(rdd: RDD[String]): RDD[String] = { rdd.map(x &#8658; field + x) }
}
is equivalent to writing rdd.map(x &#8658; this.field + x), which references all of this. To avoid this issue, the simplest way is to copy field into a local variable instead of accessing it externally:</p></div>
<div class="paragraph"><p>def doStuff(rdd: RDD[String]): RDD[String] = {
  val field_ = this.field
  rdd.map(x &#8658; field_ + x)
}
Understanding closures
One of the harder things about Spark is understanding the scope and life cycle of variables and methods when executing code across a cluster. RDD operations that modify variables outside of their scope can be a frequent source of confusion. In the example below we’ll look at code that uses foreach() to increment a counter, but similar issues can occur for other operations as well.</p></div>
<div class="paragraph"><p>Example
Consider the naive RDD element sum below, which may behave differently depending on whether execution is happening within the same JVM. A common example of this is when running Spark in local mode (--master = local[n]) versus deploying a Spark application to a cluster (e.g. via spark-submit to YARN):</p></div>
<div class="paragraph"><p>var counter = 0
var rdd = sc.parallelize(data)</p></div>
<div class="paragraph"><p>rdd.foreach(x &#8658; counter += x)</p></div>
<div class="paragraph"><p>println("Counter value: " + counter)
Local vs. cluster modes
The behavior of the above code is undefined, and may not work as intended. To execute jobs, Spark breaks up the processing of RDD operations into tasks, each of which is executed by an executor. Prior to execution, Spark computes the task’s closure. The closure is those variables and methods which must be visible for the executor to perform its computations on the RDD (in this case foreach()). This closure is serialized and sent to each executor.</p></div>
<div class="paragraph"><p>The variables within the closure sent to each executor are now copies and thus, when counter is referenced within the foreach function, it’s no longer the counter on the driver node. There is still a counter in the memory of the driver node but this is no longer visible to the executors! The executors only see the copy from the serialized closure. Thus, the final value of counter will still be zero since all operations on counter were referencing the value within the serialized closure.</p></div>
<div class="paragraph"><p>In local mode, in some circumstances, the foreach function will actually execute within the same JVM as the driver and will reference the same original counter, and may actually update it.</p></div>
<div class="paragraph"><p>To ensure well-defined behavior in these sorts of scenarios one should use an Accumulator. Accumulators in Spark are used specifically to provide a mechanism for safely updating a variable when execution is split up across worker nodes in a cluster. The Accumulators section of this guide discusses these in more detail.</p></div>
<div class="paragraph"><p>In general, closures - constructs like loops or locally defined methods, should not be used to mutate some global state. Spark does not define or guarantee the behavior of mutations to objects referenced from outside of closures. Some code that does this may work in local mode, but that’s just by accident and such code will not behave as expected in distributed mode. Use an Accumulator instead if some global aggregation is needed.</p></div>
<div class="paragraph"><p>Printing elements of an RDD
Another common idiom is attempting to print out the elements of an RDD using rdd.foreach(println) or rdd.map(println). On a single machine, this will generate the expected output and print all the RDD’s elements. However, in cluster mode, the output to stdout being called by the executors is now writing to the executor’s stdout instead, not the one on the driver, so stdout on the driver won’t show these! To print all elements on the driver, one can use the collect() method to first bring the RDD to the driver node thus: rdd.collect().foreach(println). This can cause the driver to run out of memory, though, because collect() fetches the entire RDD to a single machine; if you only need to print a few elements of the RDD, a safer approach is to use the take(): rdd.take(100).foreach(println).</p></div>
<div class="paragraph"><p>Working with Key-Value Pairs</p></div>
<div class="paragraph"><p>While most Spark operations work on RDDs containing any type of objects, a few special operations are only available on RDDs of key-value pairs. The most common ones are distributed “shuffle” operations, such as grouping or aggregating the elements by a key.</p></div>
<div class="paragraph"><p>In Scala, these operations are automatically available on RDDs containing Tuple2 objects (the built-in tuples in the language, created by simply writing (a, b)). The key-value pair operations are available in the PairRDDFunctions class, which automatically wraps around an RDD of tuples.</p></div>
<div class="paragraph"><p>For example, the following code uses the reduceByKey operation on key-value pairs to count how many times each line of text occurs in a file:</p></div>
<div class="paragraph"><p>val lines = sc.textFile("data.txt")
val pairs = lines.map(s &#8658; (s, 1))
val counts = pairs.reduceByKey((a, b) &#8658; a + b)
We could also use counts.sortByKey(), for example, to sort the pairs alphabetically, and finally counts.collect() to bring them back to the driver program as an array of objects.</p></div>
<div class="paragraph"><p>Note: when using custom objects as the key in key-value pair operations, you must be sure that a custom equals() method is accompanied with a matching hashCode() method. For full details, see the contract outlined in the Object.hashCode() documentation.</p></div>
<div class="paragraph"><p>Transformations
The following table lists some of the common transformations supported by Spark. Refer to the RDD API doc (Scala, Java, Python, R) and pair RDD functions doc (Scala, Java) for details.</p></div>
<div class="paragraph"><p>Transformation  Meaning
map(func)       Return a new distributed dataset formed by passing each element of the source through a function func.
filter(func)    Return a new dataset formed by selecting those elements of the source on which func returns true.
flatMap(func)   Similar to map, but each input item can be mapped to 0 or more output items (so func should return a Seq rather than a single item).
mapPartitions(func)     Similar to map, but runs separately on each partition (block) of the RDD, so func must be of type Iterator&lt;T&gt; &#8658; Iterator&lt;U&gt; when running on an RDD of type T.
mapPartitionsWithIndex(func)    Similar to mapPartitions, but also provides func with an integer value representing the index of the partition, so func must be of type (Int, Iterator&lt;T&gt;) &#8658; Iterator&lt;U&gt; when running on an RDD of type T.
sample(withReplacement, fraction, seed) Sample a fraction fraction of the data, with or without replacement, using a given random number generator seed.
union(otherDataset)     Return a new dataset that contains the union of the elements in the source dataset and the argument.
intersection(otherDataset)      Return a new RDD that contains the intersection of elements in the source dataset and the argument.
distinct([numPartitions]))      Return a new dataset that contains the distinct elements of the source dataset.
groupByKey([numPartitions])     When called on a dataset of (K, V) pairs, returns a dataset of (K, Iterable&lt;V&gt;) pairs.
Note: If you are grouping in order to perform an aggregation (such as a sum or average) over each key, using reduceByKey or aggregateByKey will yield much better performance.
Note: By default, the level of parallelism in the output depends on the number of partitions of the parent RDD. You can pass an optional numPartitions argument to set a different number of tasks.
reduceByKey(func, [numPartitions])      When called on a dataset of (K, V) pairs, returns a dataset of (K, V) pairs where the values for each key are aggregated using the given reduce function func, which must be of type (V,V) &#8658; V. Like in groupByKey, the number of reduce tasks is configurable through an optional second argument.
aggregateByKey(zeroValue)(seqOp, combOp, [numPartitions])       When called on a dataset of (K, V) pairs, returns a dataset of (K, U) pairs where the values for each key are aggregated using the given combine functions and a neutral "zero" value. Allows an aggregated value type that is different than the input value type, while avoiding unnecessary allocations. Like in groupByKey, the number of reduce tasks is configurable through an optional second argument.
sortByKey([ascending], [numPartitions]) When called on a dataset of (K, V) pairs where K implements Ordered, returns a dataset of (K, V) pairs sorted by keys in ascending or descending order, as specified in the boolean ascending argument.
join(otherDataset, [numPartitions])     When called on datasets of type (K, V) and (K, W), returns a dataset of (K, (V, W)) pairs with all pairs of elements for each key. Outer joins are supported through leftOuterJoin, rightOuterJoin, and fullOuterJoin.
cogroup(otherDataset, [numPartitions])  When called on datasets of type (K, V) and (K, W), returns a dataset of (K, (Iterable&lt;V&gt;, Iterable&lt;W&gt;)) tuples. This operation is also called groupWith.
cartesian(otherDataset) When called on datasets of types T and U, returns a dataset of (T, U) pairs (all pairs of elements).
pipe(command, [envVars])        Pipe each partition of the RDD through a shell command, e.g. a Perl or bash script. RDD elements are written to the process&#8217;s stdin and lines output to its stdout are returned as an RDD of strings.
coalesce(numPartitions) Decrease the number of partitions in the RDD to numPartitions. Useful for running operations more efficiently after filtering down a large dataset.
repartition(numPartitions)      Reshuffle the data in the RDD randomly to create either more or fewer partitions and balance it across them. This always shuffles all data over the network.
repartitionAndSortWithinPartitions(partitioner) Repartition the RDD according to the given partitioner and, within each resulting partition, sort records by their keys. This is more efficient than calling repartition and then sorting within each partition because it can push the sorting down into the shuffle machinery.
Actions
The following table lists some of the common actions supported by Spark. Refer to the RDD API doc (Scala, Java, Python, R)</p></div>
<div class="paragraph"><p>and pair RDD functions doc (Scala, Java) for details.</p></div>
<div class="paragraph"><p>Action  Meaning
reduce(func)    Aggregate the elements of the dataset using a function func (which takes two arguments and returns one). The function should be commutative and associative so that it can be computed correctly in parallel.
collect()       Return all the elements of the dataset as an array at the driver program. This is usually useful after a filter or other operation that returns a sufficiently small subset of the data.
count() Return the number of elements in the dataset.
first() Return the first element of the dataset (similar to take(1)).
take(n) Return an array with the first n elements of the dataset.
takeSample(withReplacement, num, [seed])        Return an array with a random sample of num elements of the dataset, with or without replacement, optionally pre-specifying a random number generator seed.
takeOrdered(n, [ordering])      Return the first n elements of the RDD using either their natural order or a custom comparator.
saveAsTextFile(path)    Write the elements of the dataset as a text file (or set of text files) in a given directory in the local filesystem, HDFS or any other Hadoop-supported file system. Spark will call toString on each element to convert it to a line of text in the file.
saveAsSequenceFile(path)
(Java and Scala)        Write the elements of the dataset as a Hadoop SequenceFile in a given path in the local filesystem, HDFS or any other Hadoop-supported file system. This is available on RDDs of key-value pairs that implement Hadoop&#8217;s Writable interface. In Scala, it is also available on types that are implicitly convertible to Writable (Spark includes conversions for basic types like Int, Double, String, etc).
saveAsObjectFile(path)
(Java and Scala)        Write the elements of the dataset in a simple format using Java serialization, which can then be loaded using SparkContext.objectFile().
countByKey()    Only available on RDDs of type (K, V). Returns a hashmap of (K, Int) pairs with the count of each key.
foreach(func)   Run a function func on each element of the dataset. This is usually done for side effects such as updating an Accumulator or interacting with external storage systems.
Note: modifying variables other than Accumulators outside of the foreach() may result in undefined behavior. See Understanding closures for more details.
The Spark RDD API also exposes asynchronous versions of some actions, like foreachAsync for foreach, which immediately return a FutureAction to the caller instead of blocking on completion of the action. This can be used to manage or wait for the asynchronous execution of the action.</p></div>
<div class="paragraph"><p>Shuffle operations
Certain operations within Spark trigger an event known as the shuffle. The shuffle is Spark’s mechanism for re-distributing data so that it’s grouped differently across partitions. This typically involves copying data across executors and machines, making the shuffle a complex and costly operation.</p></div>
<div class="paragraph"><p>Background
To understand what happens during the shuffle we can consider the example of the reduceByKey operation. The reduceByKey operation generates a new RDD where all values for a single key are combined into a tuple - the key and the result of executing a reduce function against all values associated with that key. The challenge is that not all values for a single key necessarily reside on the same partition, or even the same machine, but they must be co-located to compute the result.</p></div>
<div class="paragraph"><p>In Spark, data is generally not distributed across partitions to be in the necessary place for a specific operation. During computations, a single task will operate on a single partition - thus, to organize all the data for a single reduceByKey reduce task to execute, Spark needs to perform an all-to-all operation. It must read from all partitions to find all the values for all keys, and then bring together values across partitions to compute the final result for each key - this is called the shuffle.</p></div>
<div class="paragraph"><p>Although the set of elements in each partition of newly shuffled data will be deterministic, and so is the ordering of partitions themselves, the ordering of these elements is not. If one desires predictably ordered data following shuffle then it’s possible to use:</p></div>
<div class="paragraph"><p>mapPartitions to sort each partition using, for example, .sorted
repartitionAndSortWithinPartitions to efficiently sort partitions while simultaneously repartitioning
sortBy to make a globally ordered RDD
Operations which can cause a shuffle include repartition operations like repartition and coalesce, ‘ByKey operations (except for counting) like groupByKey and reduceByKey, and join operations like cogroup and join.</p></div>
<div class="paragraph"><p>Performance Impact
The Shuffle is an expensive operation since it involves disk I/O, data serialization, and network I/O. To organize data for the shuffle, Spark generates sets of tasks - map tasks to organize the data, and a set of reduce tasks to aggregate it. This nomenclature comes from MapReduce and does not directly relate to Spark’s map and reduce operations.</p></div>
<div class="paragraph"><p>Internally, results from individual map tasks are kept in memory until they can’t fit. Then, these are sorted based on the target partition and written to a single file. On the reduce side, tasks read the relevant sorted blocks.</p></div>
<div class="paragraph"><p>Certain shuffle operations can consume significant amounts of heap memory since they employ in-memory data structures to organize records before or after transferring them. Specifically, reduceByKey and aggregateByKey create these structures on the map side, and 'ByKey operations generate these on the reduce side. When data does not fit in memory Spark will spill these tables to disk, incurring the additional overhead of disk I/O and increased garbage collection.</p></div>
<div class="paragraph"><p>Shuffle also generates a large number of intermediate files on disk. As of Spark 1.3, these files are preserved until the corresponding RDDs are no longer used and are garbage collected. This is done so the shuffle files don’t need to be re-created if the lineage is re-computed. Garbage collection may happen only after a long period of time, if the application retains references to these RDDs or if GC does not kick in frequently. This means that long-running Spark jobs may consume a large amount of disk space. The temporary storage directory is specified by the spark.local.dir configuration parameter when configuring the Spark context.</p></div>
<div class="paragraph"><p>Shuffle behavior can be tuned by adjusting a variety of configuration parameters. See the ‘Shuffle Behavior’ section within the Spark Configuration Guide.</p></div>
<div class="paragraph"><p>RDD Persistence
One of the most important capabilities in Spark is persisting (or caching) a dataset in memory across operations. When you persist an RDD, each node stores any partitions of it that it computes in memory and reuses them in other actions on that dataset (or datasets derived from it). This allows future actions to be much faster (often by more than 10x). Caching is a key tool for iterative algorithms and fast interactive use.</p></div>
<div class="paragraph"><p>You can mark an RDD to be persisted using the persist() or cache() methods on it. The first time it is computed in an action, it will be kept in memory on the nodes. Spark’s cache is fault-tolerant – if any partition of an RDD is lost, it will automatically be recomputed using the transformations that originally created it.</p></div>
<div class="paragraph"><p>In addition, each persisted RDD can be stored using a different storage level, allowing you, for example, to persist the dataset on disk, persist it in memory but as serialized Java objects (to save space), replicate it across nodes. These levels are set by passing a StorageLevel object (Scala, Java, Python) to persist(). The cache() method is a shorthand for using the default storage level, which is StorageLevel.MEMORY_ONLY (store deserialized objects in memory). The full set of storage levels is:</p></div>
<div class="paragraph"><p>Storage Level   Meaning
MEMORY_ONLY     Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, some partitions will not be cached and will be recomputed on the fly each time they&#8217;re needed. This is the default level.
MEMORY_AND_DISK Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, store the partitions that don&#8217;t fit on disk, and read them from there when they&#8217;re needed.
MEMORY_ONLY_SER
(Java and Scala)        Store RDD as serialized Java objects (one byte array per partition). This is generally more space-efficient than deserialized objects, especially when using a fast serializer, but more CPU-intensive to read.
MEMORY_AND_DISK_SER
(Java and Scala)        Similar to MEMORY_ONLY_SER, but spill partitions that don&#8217;t fit in memory to disk instead of recomputing them on the fly each time they&#8217;re needed.
DISK_ONLY       Store the RDD partitions only on disk.
MEMORY_ONLY_2, MEMORY_AND_DISK_2, etc.  Same as the levels above, but replicate each partition on two cluster nodes.
OFF_HEAP (experimental) Similar to MEMORY_ONLY_SER, but store the data in off-heap memory. This requires off-heap memory to be enabled.
Note: In Python, stored objects will always be serialized with the Pickle library, so it does not matter whether you choose a serialized level. The available storage levels in Python include MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2, DISK_ONLY, and DISK_ONLY_2.</p></div>
<div class="paragraph"><p>Spark also automatically persists some intermediate data in shuffle operations (e.g. reduceByKey), even without users calling persist. This is done to avoid recomputing the entire input if a node fails during the shuffle. We still recommend users call persist on the resulting RDD if they plan to reuse it.</p></div>
<div class="paragraph"><p>Which Storage Level to Choose?
Spark’s storage levels are meant to provide different trade-offs between memory usage and CPU efficiency. We recommend going through the following process to select one:</p></div>
<div class="paragraph"><p>If your RDDs fit comfortably with the default storage level (MEMORY_ONLY), leave them that way. This is the most CPU-efficient option, allowing operations on the RDDs to run as fast as possible.</p></div>
<div class="paragraph"><p>If not, try using MEMORY_ONLY_SER and selecting a fast serialization library to make the objects much more space-efficient, but still reasonably fast to access. (Java and Scala)</p></div>
<div class="paragraph"><p>Don’t spill to disk unless the functions that computed your datasets are expensive, or they filter a large amount of the data. Otherwise, recomputing a partition may be as fast as reading it from disk.</p></div>
<div class="paragraph"><p>Use the replicated storage levels if you want fast fault recovery (e.g. if using Spark to serve requests from a web application). All the storage levels provide full fault tolerance by recomputing lost data, but the replicated ones let you continue running tasks on the RDD without waiting to recompute a lost partition.</p></div>
<div class="paragraph"><p>Removing Data
Spark automatically monitors cache usage on each node and drops out old data partitions in a least-recently-used (LRU) fashion. If you would like to manually remove an RDD instead of waiting for it to fall out of the cache, use the RDD.unpersist() method.</p></div>
<div class="paragraph"><p>Shared Variables
Normally, when a function passed to a Spark operation (such as map or reduce) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. Supporting general, read-write shared variables across tasks would be inefficient. However, Spark does provide two limited types of shared variables for two common usage patterns: broadcast variables and accumulators.</p></div>
<div class="paragraph"><p>Broadcast Variables
Broadcast variables allow the programmer to keep a read-only variable cached on each machine rather than shipping a copy of it with tasks. They can be used, for example, to give every node a copy of a large input dataset in an efficient manner. Spark also attempts to distribute broadcast variables using efficient broadcast algorithms to reduce communication cost.</p></div>
<div class="paragraph"><p>Spark actions are executed through a set of stages, separated by distributed “shuffle” operations. Spark automatically broadcasts the common data needed by tasks within each stage. The data broadcasted this way is cached in serialized form and deserialized before running each task. This means that explicitly creating broadcast variables is only useful when tasks across multiple stages need the same data or when caching the data in deserialized form is important.</p></div>
<div class="paragraph"><p>Broadcast variables are created from a variable v by calling SparkContext.broadcast(v). The broadcast variable is a wrapper around v, and its value can be accessed by calling the value method. The code below shows this:</p></div>
<div class="paragraph"><p>scala&gt; val broadcastVar = sc.broadcast(Array(1, 2, 3))
broadcastVar: org.apache.spark.broadcast.Broadcast[Array[Int]] = Broadcast(0)</p></div>
<div class="paragraph"><p>scala&gt; broadcastVar.value
res0: Array[Int] = Array(1, 2, 3)
After the broadcast variable is created, it should be used instead of the value v in any functions run on the cluster so that v is not shipped to the nodes more than once. In addition, the object v should not be modified after it is broadcast in order to ensure that all nodes get the same value of the broadcast variable (e.g. if the variable is shipped to a new node later).</p></div>
<div class="paragraph"><p>Accumulators
Accumulators are variables that are only “added” to through an associative and commutative operation and can therefore be efficiently supported in parallel. They can be used to implement counters (as in MapReduce) or sums. Spark natively supports accumulators of numeric types, and programmers can add support for new types.</p></div>
<div class="paragraph"><p>As a user, you can create named or unnamed accumulators. As seen in the image below, a named accumulator (in this instance counter) will display in the web UI for the stage that modifies that accumulator. Spark displays the value for each accumulator modified by a task in the “Tasks” table.</p></div>
<div class="paragraph"><p>Accumulators in the Spark UI</p></div>
<div class="paragraph"><p>Tracking accumulators in the UI can be useful for understanding the progress of running stages (NOTE: this is not yet supported in Python).</p></div>
<div class="paragraph"><p>Scala
Java
Python
A numeric accumulator can be created by calling SparkContext.longAccumulator() or SparkContext.doubleAccumulator() to accumulate values of type Long or Double, respectively. Tasks running on a cluster can then add to it using the add method. However, they cannot read its value. Only the driver program can read the accumulator’s value, using its value method.</p></div>
<div class="paragraph"><p>The code below shows an accumulator being used to add up the elements of an array:</p></div>
<div class="paragraph"><p>scala&gt; val accum = sc.longAccumulator("My Accumulator")
accum: org.apache.spark.util.LongAccumulator = LongAccumulator(id: 0, name: Some(My Accumulator), value: 0)</p></div>
<div class="paragraph"><p>scala&gt; sc.parallelize(Array(1, 2, 3, 4)).foreach(x &#8658; accum.add(x))
&#8230;
10/09/29 18:41:08 INFO SparkContext: Tasks finished in 0.317106 s</p></div>
<div class="paragraph"><p>scala&gt; accum.value
res2: Long = 10
While this code used the built-in support for accumulators of type Long, programmers can also create their own types by subclassing AccumulatorV2. The AccumulatorV2 abstract class has several methods which one has to override: reset for resetting the accumulator to zero, add for adding another value into the accumulator, merge for merging another same-type accumulator into this one. Other methods that must be overridden are contained in the API documentation. For example, supposing we had a MyVector class representing mathematical vectors, we could write:</p></div>
<div class="paragraph"><p>class VectorAccumulatorV2 extends AccumulatorV2[MyVector, MyVector] {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>private val myVector: MyVector = MyVector.createZeroVector</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def reset(): Unit = {
  myVector.reset()
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def add(v: MyVector): Unit = {
    myVector.add(v)
  }
  ...
}</code></pre>
</div></div>
<div class="paragraph"><p>val myVectorAcc = new VectorAccumulatorV2

sc.register(myVectorAcc, "MyVectorAcc1")
Note that, when programmers define their own type of AccumulatorV2, the resulting type can be different than that of the elements added.</p></div>
<div class="paragraph"><p>For accumulator updates performed inside actions only, Spark guarantees that each task’s update to the accumulator will only be applied once, i.e. restarted tasks will not update the value. In transformations, users should be aware of that each task’s update may be applied more than once if tasks or job stages are re-executed.</p></div>
<div class="paragraph"><p>Accumulators do not change the lazy evaluation model of Spark. If they are being updated within an operation on an RDD, their value is only updated once that RDD is computed as part of an action. Consequently, accumulator updates are not guaranteed to be executed when made within a lazy transformation like map(). The below code fragment demonstrates this property:</p></div>
<div class="paragraph"><p>Scala
Java
Python
val accum = sc.longAccumulator
data.map { x &#8658; accum.add(x); x }

Deploying to a Cluster
The application submission guide describes how to submit applications to a cluster. In short, once you package your application into a JAR (for Java/Scala) or a set of .py or .zip files (for Python), the bin/spark-submit script lets you submit it to any supported cluster manager.</p></div>
<div class="paragraph"><p>Launching Spark jobs from Java / Scala
The org.apache.spark.launcher package provides classes for launching Spark jobs as child processes using a simple Java API.</p></div>
<div class="paragraph"><p>Unit Testing
Spark is friendly to unit testing with any popular unit test framework. Simply create a SparkContext in your test with the master URL set to local, run your operations, and then call SparkContext.stop() to tear it down. Make sure you stop the context within a finally block or the test framework’s tearDown method, as Spark does not support two contexts running concurrently in the same program.</p></div>
<div class="paragraph"><p>Where to Go from Here
You can see some example Spark programs on the Spark website. In addition, Spark includes several samples in the examples directory (Scala, Java, Python, R). You can run Java and Scala examples by passing the class name to Spark’s bin/run-example script; for instance:</p></div>
<div class="paragraph"><div class="title">/bin/run-example SparkPi</div><p>For Python examples, use spark-submit instead:</p></div>
<div class="paragraph"><div class="title">/bin/spark-submit examples/src/main/python/pi.py</div><p>For R examples, use spark-submit instead:</p></div>
<div class="paragraph"><div class="title">/bin/spark-submit examples/src/main/r/dataframe.R</div><p>For help on optimizing your programs, the configuration and tuning guides provide information on best practices. They are especially important for making sure that your data is stored in memory in an efficient format. For help on deploying, the cluster mode overview describes the components involved in distributed operation and supported cluster managers.</p></div>
<div class="paragraph"><p>Finally, full API documentation is available in Scala, Java, Python and R.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-06-13 20:16:15 EEST
</div>
</div>
</body>
</html>
