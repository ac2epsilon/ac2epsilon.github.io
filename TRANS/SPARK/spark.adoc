include::header.adoc[]

image::spark-logo-trademark.png[]

= Apache Spark ™ - це уніфікований механізм аналітики для масштабної обробки даних.

== Швидкість

===== Виконуйте навантаження в 100 разів швидше.

Apache Spark досягає високої продуктивності як для пакетних, так і потокових даних, використовуючи сучасний DAG-планувальник, оптимізатор запитів і механізм фізичного виконання.

== Простота використання

===== Швидко пишіть програми на Java, Scala, Python, R та SQL.

Spark пропонує понад 80 операторів високого рівня, які спрощують створення паралельних додатків. І ви можете використовувати його інтерактивно з оболонок Scala, Python, R та SQL.

== Загальність

===== Поєднайте SQL, поточну та комплексну аналітику.

Spark посилює стек бібліотек, включаючи SQL і DataFrames, MLlib для машинного навчання, GraphX ​​та Spark Streaming. Ви можете безперешкодно поєднувати ці бібліотеки в одній програмі.

== Виконується будь-де

===== Spark працює на Hadoop, Apache Mesos, Kubernetes, окремо або в хмарі. Він може отримати доступ до різноманітних джерел даних.

Ви можете запустити Spark, використовуючи його окремий кластерний режим, на EC2, Hadoop YARN, Mesos або Kubernetes. Доступ до даних у форматі HDFS, Alluxio, Apache Cassandra, Apache HBase, Apache Hive та сотнях інших джерел даних.

== Швидкий старт

Цей підручник пропонує швидке ознайомлення з використанням Spark. Спочатку ми введемо API через інтерактивну оболонку Spark (у Python чи Scala), а потім покажемо, як писати програми на Java, Scala та Python.

Щоб дотримуватися цього посібника, спочатку завантажте упакований випуск Spark з веб-сайту Spark. Оскільки ми не будемо використовувати HDFS, ви можете завантажити пакет для будь-якої версії Hadoop.

Зауважте, що до Spark 2.0 основним інтерфейсом програмування Spark був еластичний розподілений набір даних (Resilient Distributed Dataset, RDD). Після Spark 2.0 RDD замінюються Dataset, який суворо типізований як RDD, але з більш багатими оптимізаціями за лаштунками. Інтерфейс RDD все ще підтримується, і ви можете отримати більш детальну інформацію в посібнику з програмування RDD. Однак ми настійно рекомендуємо перейти на використання Dataset, який має кращі показники, ніж RDD. Для отримання додаткової інформації про Dataset див. Посібник із програмування SQL.

=== Безпека

Безпека Spark за замовчуванням вимкнена. Це може означати, що ви вразливі до атаки за замовчуванням. Будь ласка, перегляньте безпеку Spark перед запуском Spark.

=== Інтерактивний аналіз із оболонкою Spark

==== Основи

Оболонка Spark забезпечує простий спосіб вивчення API, а також потужний інструмент для інтерактивного аналізу даних. Він доступний або в Scala (який працює на Java VM, тому є хорошим способом використання існуючих бібліотек Java), або в Python. Почніть роботу, запустивши в каталозі Spark наступне:

[source,bash]
----
./bin/spark-shell
----

Основна абстракція Spark - це розподілена колекція елементів, що називається Набір даних `Dataset`. Набори даних можна створити з Hadoop InputFormat (таких як файли HDFS) або шляхом перетворення інших наборів даних. Давайте зробимо новий набір даних із тексту файлу `README` у каталозі джерел Spark:

[source,scala]
----
scala> val textFile = spark.read.textFile("README.md")
textFile: org.apache.spark.sql.Dataset[String] = [value: string]
----

Ви можете отримати значення з Набору даних безпосередньо, викликавши виконня  деяких дій, або трансформуючи Набір даних, щоб отримати новий. Для отримання більш детальної інформації, будь ласка, ознайомтеся з документацією API.

[source,scala]
----
scala> textFile.count() // Кількість елементів у цьому наборі даних
res0: Long = 126 // Може відрізнятись від вашої, оскільки README.md змінюватиметься з часом, як і інші результати

scala> textFile.first() // Перший елемент у цьому наборі даних
res1: String = # Apache Spark
----

Тепер перетворимо цей набір даних у новий. Ми викликаємо фільтр, щоб повернути новий набір даних із підмножиною елементів у файлі.

[source,scala]
----
scala> val linesWithSpark = textFile.filter(line => line.contains("Spark"))
linesWithSpark: org.apache.spark.sql.Dataset[String] = [value: string]
----

Ми можемо поєднати трансформації та дії:

[source,scala]
----
scala> textFile.filter(line => line.contains("Spark")).count() // Скільки рядків містить "Spark"?
res3: Long = 15
----

==== Детальніше про операції з набором даних

Дії та перетворення набору даних можна використовувати для більш складних обчислень. Скажімо, ми хочемо знайти рядок з найбільшою кількістю слів:

[source,scala]
----
scala> textFile.map(line => line.split(" ").size).reduce((a, b) => if (a > b) a else b)
res4: Long = 15
----

Першим виконується відображення рядка на ціле значення, створюючи новий набір даних. `reduce` визивається для цього набору даних, щоб знайти найбільшу кількість слів. Аргументи для `map` та `reduce` - це функціональні літерали Scala (замикання) і можуть використовувати будь-яку мовну функцію або бібліотеку Scala/Java. Наприклад, ми можемо легко викликати функції, оголошені в іншому місці. Ми будемо використовувати функцію `Math.max()`, щоб полегшити розуміння цього коду:

[source,scala]
----
scala> import java.lang.Math
import java.lang.Math

scala> textFile.map(line => line.split(" ").size).reduce((a, b) => Math.max(a, b))
res5: Int = 15
----

Однією поширеною схемою потоку даних є MapReduce, яку популяризує Hadoop. Spark може легко реалізувати потоки MapReduce:

[source,scala]
----
scala> val wordCounts = textFile.flatMap(line => line.split(" ")).groupByKey(identity).count()
wordCounts: org.apache.spark.sql.Dataset[(String, Long)] = [value: string, count(1): bigint]
----

Тут ми закликаємо `flatMap` для перетворення набору даних рядків у набір слів, а потім поєднуємо в `groupByKey` і підраховуємо, щоб обчислити кількість слів у файлі у вигляді набору даних з пар `(String, Long)`. Щоб зібрати кількість слів у нашій оболонці, ми можемо викликати `collect`:

[source,scala]
----
scala> wordCounts.collect()
res6: Array[(String, Int)] = Array((means,1), (under,2), (this,3), (Because,1), (Python,2), (agree,1), (cluster.,1), ...)
----

==== Кешування

Spark також підтримує перетягування наборів даних у кеш-пам'ять, що є загальною для кластера. Це дуже корисно, коли до них звертаються неодноразово, наприклад, при запитах до невеликого "гарячого" набору даних або при запуску ітеративного алгоритму, наприклад `PageRank`. Як простий приклад, позначимо кешування нашого набору `linesWithSpark`:

[source,scala]
----
scala> linesWithSpark.cache()
res7: linesWithSpark.type = [value: string]

scala> linesWithSpark.count()
res8: Long = 15

scala> linesWithSpark.count()
res9: Long = 15
----

Може здатися нерозумним використання Spark для вивчення та кешування текстового файлу в 100 рядків. Цікава частина полягає в тому, що ці самі функції можна використовувати на дуже великих наборах даних, навіть коли вони поділені на десятки чи сотні вузлів. Ви також можете це зробити інтерактивно, підключивши `bin/spark-shell` до кластеру, як описано в посібнику з програмування RDD.

==== Самозабезпечені програми

Припустимо, ми хочемо написати автономну програму за допомогою API Spark. Ми розглянемо простий додаток у Scala (з sbt), Java (з Maven) та Python (pip).

Ми створимо в Scala дуже простий додаток Spark - насправді настільки простий, що називається `SimpleApp.scala`:

[source,scala]
----
/* SimpleApp.scala */
import org.apache.spark.sql.SparkSession

object SimpleApp {
  def main(args: Array[String]) {
    val logFile = "YOUR_SPARK_HOME/README.md" // Має бути якийсь файл у вашій системі
    val spark = SparkSession.builder.appName("Simple Application").getOrCreate()
    val logData = spark.read.textFile(logFile).cache()
    val numAs = logData.filter(line => line.contains("a")).count()
    val numBs = logData.filter(line => line.contains("b")).count()
    println(s"Lines with a: $numAs, Lines with b: $numBs")
    spark.stop()
  }
}
----

Зауважте, що програми повинні визначати метод `main()` замість розширення `scala.App`. Підкласи `scala.App` можуть працювати неправильно.

Ця програма просто підраховує кількість рядків, що містять `"a"`, і число, що містить `"b"` в `Spark` `README`. Зауважте, що вам потрібно буде замінити `YOUR_SPARK_HOME` на місце, де встановлено Spark. На відміну від попередніх прикладів із оболонкою Spark, яка ініціалізує власну `SparkSession`, ми ініціалізуємо `SparkSession` як частину програми.

Ми викликаємо `SparkSession.builder` щоб побудувати `[[SparkSession]]`, потім встановити ім'я програми та нарешті викликати `getOrCreate`, щоб отримати екземпляр `[[SparkSession]]`.

Our application depends on the Spark API, so we’ll also include an sbt configuration file, build.sbt, which explains that Spark is a dependency. This file also adds a repository that Spark depends on:
Наш додаток залежить від Spark API, тому ми також включимо файл конфігурації sbt, `build.sbt`, який пояснює, що Spark - це залежність. Цей файл також додає сховище, від якого залежить Spark:

[source.scala]
----
name := "Simple Project"

version := "1.0"

scalaVersion := "2.12.10"

libraryDependencies += "org.apache.spark" %% "spark-sql" % "2.4.6"
----

Щоб sbt працював правильно, нам потрібно буде компонувати `SimpleApp.scala` і `build.sbt` відповідно до типової структури каталогів. Після того, як все буде на місці, ми можемо створити пакет JAR, що містить код програми, а потім використовувати сценарій `spark-submit` для запуску нашої програми.

[source,bash]
----
# Скелет вашого каталогу повинен виглядати приблизно так
$ find .
.
./build.sbt
./src
./src/main
./src/main/scala
./src/main/scala/SimpleApp.scala

# Пакує jar, що містить ваше застосування
$ sbt package
...
[info] Packaging {..}/{..}/target/scala-2.12/simple-project_2.12-1.0.jar

# Використовуйте spark-submit, щоб запустити ваше застосування
$ YOUR_SPARK_HOME/bin/spark-submit \
  --class "SimpleApp" \
  --master local[4] \
  target/scala-2.12/simple-project_2.12-1.0.jar
...
Lines with a: 46, Lines with b: 23
----

=== Куди піти звідси

Вітаємо з запуском першої програми Spark!

Щоб отримати поглиблений огляд API, почніть з посібника з програмування RDD та керівництва з програмування SQL або перегляньте меню «Посібники з програмування» для інших компонентів.

Для запуску програм на кластері перейдіть до огляду розгортання.

Нарешті, Spark включає декілька зразків у каталозі прикладів (Scala, Java, Python, R). Ви можете запустити їх наступним чином:

[source,scala]
----
# Для Scala та Java використовуйте run-example:
./bin/run-example SparkPi

# Для прикладів Python напряму використовуйте spark-submit:
./bin/spark-submit examples/src/main/python/pi.py

# Для прикладів R напряму використовуйте spark-submit:
./bin/spark-submit examples/src/main/r/dataframe.R
----

== Посібник з програмування RDD

=== Огляд

На високому рівні кожна програма Spark складається з драйверної програми, яка виконує основну функцію користувача та виконує різні паралельні операції на кластері. Основна абстракція, яку надає Spark, - це еластичний розподілений набір даних (RDD), який представляє собою сукупність елементів, розподілених по вузлах кластеру, якими можна керувати паралельно. RDD створюються, починаючи з файлу у файловій системі Hadoop (або будь-якої іншої файлової системи, підтримуваної Hadoop), або існуючої колекції Scala в драйверній програмі, та трансформуючи її. Користувачі можуть також попросити Spark зберегти RDD в пам'яті, що дозволяє ефективно використовувати його протягом паралельних операцій. Нарешті, RDD автоматично відновлюються після відмови вузла.

Друга абстракція в Spark - це загальні змінні, які можна використовувати в паралельних операціях. За замовчуванням, коли Spark виконує функцію паралельно у вигляді набору завдань на різних вузлах, він надсилає копію кожної змінної, яка використовується у функції, до кожного завдання. Іноді змінну потрібно розділити між завданнями або між завданнями та програмою драйвера. Spark підтримує два типи загальних змінних: широкомовні змінні, які можна використовувати для кешування значень у пам'яті на всіх вузлах, і акумулятори, що є змінними, до яких може бути лише додано, як лічильники та суми.

У цьому посібнику показано кожну з цих можливостей на кожній з підтримуваних мов Spark. Найпростіше слідкувати за подіями, якщо ви запускаєте інтерактивну оболонку Spark - або `bin/spark-shell` для оболонки Scala, або `bin/pyspark` для Python.

=== Лінкування зі Spark

Spark 2.4.6 побудована та розповсюджена для роботи зі Scala 2.12 за замовчуванням. (Spark може бути побудована для роботи з іншими версіями Scala.) Для написання програм у Scala вам потрібно буде використовувати сумісну версію Scala (наприклад, 2.12.X).

Щоб написати програму Spark, потрібно додати залежність Maven від Spark. Spark доступна через Maven Central за адресою:

[source.scala]
----
groupId = org.apache.spark
artifactId = spark-core_2.12
version = 2.4.6
----

Крім того, якщо ви хочете отримати доступ до кластера HDFS, вам потрібно додати залежність від `hadoop-client` для вашої версії HDFS.

[source.scala]
----
groupId = org.apache.hadoop
artifactId = hadoop-client
version = <your-hdfs-version>
----

Нарешті, вам потрібно імпортувати кілька класів Spark у свою програму. Додайте наступні рядки:

[source,scala]
----
import org.apache.spark.SparkContext
import org.apache.spark.SparkConf
----

(До Spark 1.3.0 вам потрібно явно імпортувати `org.apache.spark.SparkContext._`, щоб увімкнути основні `implicit` перетворення.)

=== Ініціалізація Spark

Перше, що повинна зробити програма Spark - це створити об'єкт `SparkContext`, який повідомляє Spark, як отримати доступ до кластеру. Для створення `SparkContext` спочатку потрібно створити об'єкт `SparkConf`, який містить інформацію про вашу програму.

На JVM може бути активним лише один `SparkContext`. Ви повинні `stop()` активний `SparkContext` перед тим, як створити новий.

[source,scala]
----
val conf = new SparkConf().setAppName(appName).setMaster(master)
new SparkContext(conf)
----

Параметр `appName` - це назва вашої програми для показу в інтерфейсі кластера. `master` - це група кластерів Spark, Mesos або YARN, або спеціальний рядок` “local”` для запуску в локальному режимі. На практиці, працюючи на кластері, ви не хочете жорстко кодувати `master` у програму, а швидше запускаєте додаток через `spark-submit`, та отримуєте його там. Однак для локального тестування та тестування модулів ви можете передати `“local”` для запуску програми Spark.

==== Використання оболонки

У оболонці Spark для вас уже створено спеціальний інтерпретатор-обізнаний  `SparkContext`, у змінній з назвою `sc`. Створення власного `SparkContext` не буде робити. Ви можете встановити, до якого контексту підключається `master`, за допомогою аргументу `--master`, і ви можете додати JARs до `classpath`, передавши розділений комою список до аргументу `--jars`. Ви також можете додати залежності (наприклад, пакети Spark) до сеансу оболонки, надавши розділений комами список координат Maven до аргументу `--packages`. Будь-які додаткові сховища, де можуть існувати залежності (наприклад, Sonatype), можуть бути передані до аргументу `--repositories`. Наприклад, для запуску `bin/spark-shell` рівно на чотирьох ядрах використовуйте:

[source,bash]
----
$ ./bin/spark-shell --master local[4]
----

Або, щоб також додати code.jar до свого `classpath`, використовуйте:

[source,bash]
----
$ ./bin/spark-shell --master local[4] --jars code.jar
----

Щоб включити залежність, використовуючи координати Maven:

[source,bash]
----
$ ./bin/spark-shell --master local[4] --packages "org.example:example:0.1"
----

Для повного переліку параметрів запустіть `spark-shell --help`. За лаштунками, `spark-shell` викликає більш загальний сценарій `spark-submit`.

=== Еластичні розподілені набори даних (RDD)

Spark обертається навколо концепції еластичного розподіленого набору даних (RDD), що є стійким до відмов набором елементів, яким можна оперувати паралельно. Є два способи створення RDD: паралелізація існуючої колекції у вашій драйверній програмі або посилання на набір даних у зовнішню систему зберігання даних, наприклад, спільну файлову систему, HDFS, HBase або будь-яке джерело даних, що пропонує Hadoop InputFormat.

==== Паралелізовані колекції

Паралелізовані колекції створюються за допомогою виклику методу `parallelize` на `SparkContext` для існуючої колекції у вашій драйверній програмі (Scala `Seq`). Елементи колекції копіюються для формування розподіленого набору даних, яким можна оперувати паралельно. Наприклад, ось як створити паралельну колекцію, що містить числа 1 до 5:

[source,scala]
----
val data = Array(1, 2, 3, 4, 5)
val distData = sc.parallelize(data)
----

Після створення розподіленим набором даних (`distData`) можна керувати паралельно. Наприклад, ми можемо викликати `distData.reduce ((a, b) => a + b)`, щоб додати елементи масиву. Ми опишемо операції над розподіленими наборами даних згодом.

Одним з важливих параметрів для паралельних колекцій є кількість розділів для нарізання набору даних. Spark буде виконувати одне завдання для кожного розділу кластера. Зазвичай потрібно 2-4 розділи для кожного процесора кластеру. Зазвичай Spark намагається автоматично встановити кількість розділів на основі кластеру. Однак ви також можете встановити його вручну, передавши його як другий параметр для `parallelize` (наприклад,  `sc.parallelize(data, 10)`). Примітка: деякі місця в коді використовують термін фрагменти (синонім розділів) для підтримки зворотної сумісності.

==== Зовнішні набори даних

Spark може створювати розподілені набори даних з будь-якого джерела зберігання, підтримуваного Hadoop, включаючи локальну файлову систему, HDFS, Cassandra, HBase, Amazon S3 тощо. Spark підтримує текстові файли, SequenceFiles та будь-який інший Hadoop InputFormat.

Текстові файли RDD можна створити за допомогою методу `textFile` на `SparkContext`. Цей метод бере URI для файлу (або локальний шлях на машині, або UDD `hdfs://`, `s3a://` тощо) і читає його як набір рядків. Ось приклад виклику:

[source,scala]
----
scala> val distFile = sc.textFile("data.txt")
distFile: org.apache.spark.rdd.RDD[String] = data.txt MapPartitionsRDD[10] at textFile at <console>:26
----

Після створення `distFile` можна діяти за допомогою операцій набору даних. Наприклад, ми можемо додати розміри всіх рядків за допомогою операцій `map` і `reduce` наступним чином: `distFile.map (s => s.length) .reduce ((a, b) => a + b)`.

Деякі зауваження щодо читання файлів зі Spark:

* Якщо використовується шлях до локальної файлової системи, файл також повинен бути доступним тим самим шляхом на робочих вузлах. Або скопіюйте файл усім працівникам або використовуйте спільну мережеву файлову систему.

* Усі методи введення файлів Spark, включаючи `textFile`, підтримують роботу на каталогах, стислих файлах та підстановках. Наприклад, ви можете використовувати `textFile("/my/directory")`, `textFile("/my/directory/*.txt")` і `textFile("/my/directory/*.gz")`.

* Метод `textFile` також приймає необов'язковий другий аргумент для контролю кількості розділів файлу. За замовчуванням Spark створює один розділ для кожного блоку файлу (блоки HDFS за замовчуванням становлять 128 Мб), але ви також можете запитати більшу кількість розділів, передавши більше значення. Зауважте, що у вас не може бути менше розділів, ніж блоків.

Крім текстових файлів, API Scala Spark також підтримує декілька інших форматів даних:

* `SparkContext.wholeTextFiles` дозволяє читати каталог, що містить декілька невеликих текстових файлів, і повертає кожен з них у вигляді пар `(filename, content)`. Це відрізняється від `textFile`, який би повертав один запис на рядок у кожному файлі. Розмежування визначається локальністю даних, яка в деяких випадках може призвести до надто малої кількості розділів. У цих випадках `wholeTextFiles` надає необов'язковий другий аргумент для контролю мінімальної кількості розділів.

* Для `SequenceFiles` використовуйте метод SparkContext послідовного файлу `sequenceFile[K, V]`, де `K` і `V` - типи ключів і значень у файлі. Це повинні бути підкласи інтерфейсу для запису Hadoop, наприклад, `IntWritable` і `Text`. Крім того, Spark дозволяє вказувати нативні типи для кількох загальних `Writable`; наприклад, `rowFile[Int, String]` автоматично прочитає `IntWritable` і `Text`.

* Для інших Hadoop InputFormats ви можете використовувати метод `SparkContext.hadoopRDD`, який приймає довільний `JobConf` і клас формату введення, ключовий клас та клас значень. Встановіть їх так само, як і для роботи Hadoop зі своїм джерелом введення. Ви також можете використовувати 'SparkContext.newAPIHadoopRDD' для InputFormats на основі "нового" API MapReduce (`org.apache.hadoop.mapreduce`).

`RDD.saveAsObjectFile` та `SparkContext.objectFile` підтримують збереження RDD у простому форматі, що складається з серіалізованих об’єктів Java. Хоча це не так ефективно, як спеціалізовані формати на зразок Avro, він пропонує простий спосіб зберегти будь-яку RDD.

=== Операції RDD

RDD підтримують два типи операцій: перетворення, які створюють новий набір даних із наявного, та дії, які повертають значення драйверній програмі після запуску обчислення на наборі даних. Наприклад, `map` - це перетворення, яке передає кожен елемент набору даних через функцію та повертає новий RDD, що представляє результати. З іншого боку, `reduce` - це дія, яка агрегує всі елементи RDD за допомогою певної функції та повертає кінцевий результат програмі драйверів (хоча існує також паралельне `reduceByKey`, яке повертає розподілений набір даних).

Всі перетворення в Spark ліниві, оскільки вони не підраховують свої результати одразу. Натомість вони просто запам'ятовують перетворення, застосовані до деякого базового набору даних (наприклад, до файлу). Перетворення обчислюються лише тоді, коли дія вимагає повернення результату в програму драйверів. Така конструкція дозволяє Spark працювати більш ефективно. Наприклад, ми можемо збагнути, що набір даних, створений за допомогою `map`, буде використовуватися для `reduce` і повертати драйверу лише результат `reduce`, а не збільшений відображений набір даних.

За замовчуванням кожен перетворений RDD може бути перерахований щоразу, коли  на ньому виконується дія. Однак ви також можете зберегти RDD в пам'яті, використовуючи метод `persist` (або `cache`), і в цьому випадку Spark буде зберігати елементи коло кластера для набагато швидшого доступу наступного разу, коли ви питаєте його. Існує також підтримка збережених RDD на диску або тиражуються через декілька вузлів.

==== Основи

Щоб проілюструвати основи RDD, розгляньте просту програму нижче:

[source,scala]
----
val lines = sc.textFile("data.txt")
val lineLengths = lines.map(s => s.length)
val totalLength = lineLengths.reduce((a, b) => a + b)
----

Перший рядок визначає базовий RDD із зовнішнього файлу. Цей набір даних не завантажується в пам'ять або іншим чином діє на: рядки - це лише вказівник на файл. Другий рядок визначає `lineLengths` як результат перетворення `map`. Знову ж таки, `LineLengths` не обчислюється одразу через лінь. Нарешті, ми запускаємо `reduce`, яке є дією. У цей момент Spark розбиває обчислення на завдання для запуску на окремих машинах, і кожна машина виконує як свою частину `map`, так і локальне `reduce`, повертаючи лише свою відповідь на програму драйвера.

Якщо ми також хотіли пізніше знову використовувати `lineLengths`, ми можемо додати:

lineLengths.persist()
before the reduce, which would cause lineLengths to be saved in memory after the first time it is computed.

Passing Functions to Spark

Spark’s API relies heavily on passing functions in the driver program to run on the cluster. There are two recommended ways to do this:

Anonymous function syntax, which can be used for short pieces of code.
Static methods in a global singleton object. For example, you can define object MyFunctions and then pass MyFunctions.func1, as follows:
object MyFunctions {
  def func1(s: String): String = { ... }
}

myRdd.map(MyFunctions.func1)
Note that while it is also possible to pass a reference to a method in a class instance (as opposed to a singleton object), this requires sending the object that contains that class along with the method. For example, consider:

class MyClass {
  def func1(s: String): String = { ... }
  def doStuff(rdd: RDD[String]): RDD[String] = { rdd.map(func1) }
}
Here, if we create a new MyClass instance and call doStuff on it, the map inside there references the func1 method of that MyClass instance, so the whole object needs to be sent to the cluster. It is similar to writing rdd.map(x => this.func1(x)).

In a similar way, accessing fields of the outer object will reference the whole object:

class MyClass {
  val field = "Hello"
  def doStuff(rdd: RDD[String]): RDD[String] = { rdd.map(x => field + x) }
}
is equivalent to writing rdd.map(x => this.field + x), which references all of this. To avoid this issue, the simplest way is to copy field into a local variable instead of accessing it externally:

def doStuff(rdd: RDD[String]): RDD[String] = {
  val field_ = this.field
  rdd.map(x => field_ + x)
}
Understanding closures 
One of the harder things about Spark is understanding the scope and life cycle of variables and methods when executing code across a cluster. RDD operations that modify variables outside of their scope can be a frequent source of confusion. In the example below we’ll look at code that uses foreach() to increment a counter, but similar issues can occur for other operations as well.

Example
Consider the naive RDD element sum below, which may behave differently depending on whether execution is happening within the same JVM. A common example of this is when running Spark in local mode (--master = local[n]) versus deploying a Spark application to a cluster (e.g. via spark-submit to YARN):

var counter = 0
var rdd = sc.parallelize(data)

// Wrong: Don't do this!!
rdd.foreach(x => counter += x)

println("Counter value: " + counter)
Local vs. cluster modes
The behavior of the above code is undefined, and may not work as intended. To execute jobs, Spark breaks up the processing of RDD operations into tasks, each of which is executed by an executor. Prior to execution, Spark computes the task’s closure. The closure is those variables and methods which must be visible for the executor to perform its computations on the RDD (in this case foreach()). This closure is serialized and sent to each executor.

The variables within the closure sent to each executor are now copies and thus, when counter is referenced within the foreach function, it’s no longer the counter on the driver node. There is still a counter in the memory of the driver node but this is no longer visible to the executors! The executors only see the copy from the serialized closure. Thus, the final value of counter will still be zero since all operations on counter were referencing the value within the serialized closure.

In local mode, in some circumstances, the foreach function will actually execute within the same JVM as the driver and will reference the same original counter, and may actually update it.

To ensure well-defined behavior in these sorts of scenarios one should use an Accumulator. Accumulators in Spark are used specifically to provide a mechanism for safely updating a variable when execution is split up across worker nodes in a cluster. The Accumulators section of this guide discusses these in more detail.

In general, closures - constructs like loops or locally defined methods, should not be used to mutate some global state. Spark does not define or guarantee the behavior of mutations to objects referenced from outside of closures. Some code that does this may work in local mode, but that’s just by accident and such code will not behave as expected in distributed mode. Use an Accumulator instead if some global aggregation is needed.

Printing elements of an RDD
Another common idiom is attempting to print out the elements of an RDD using rdd.foreach(println) or rdd.map(println). On a single machine, this will generate the expected output and print all the RDD’s elements. However, in cluster mode, the output to stdout being called by the executors is now writing to the executor’s stdout instead, not the one on the driver, so stdout on the driver won’t show these! To print all elements on the driver, one can use the collect() method to first bring the RDD to the driver node thus: rdd.collect().foreach(println). This can cause the driver to run out of memory, though, because collect() fetches the entire RDD to a single machine; if you only need to print a few elements of the RDD, a safer approach is to use the take(): rdd.take(100).foreach(println).

Working with Key-Value Pairs

While most Spark operations work on RDDs containing any type of objects, a few special operations are only available on RDDs of key-value pairs. The most common ones are distributed “shuffle” operations, such as grouping or aggregating the elements by a key.

In Scala, these operations are automatically available on RDDs containing Tuple2 objects (the built-in tuples in the language, created by simply writing (a, b)). The key-value pair operations are available in the PairRDDFunctions class, which automatically wraps around an RDD of tuples.

For example, the following code uses the reduceByKey operation on key-value pairs to count how many times each line of text occurs in a file:

val lines = sc.textFile("data.txt")
val pairs = lines.map(s => (s, 1))
val counts = pairs.reduceByKey((a, b) => a + b)
We could also use counts.sortByKey(), for example, to sort the pairs alphabetically, and finally counts.collect() to bring them back to the driver program as an array of objects.

Note: when using custom objects as the key in key-value pair operations, you must be sure that a custom equals() method is accompanied with a matching hashCode() method. For full details, see the contract outlined in the Object.hashCode() documentation.

Transformations
The following table lists some of the common transformations supported by Spark. Refer to the RDD API doc (Scala, Java, Python, R) and pair RDD functions doc (Scala, Java) for details.

Transformation	Meaning
map(func)	Return a new distributed dataset formed by passing each element of the source through a function func.
filter(func)	Return a new dataset formed by selecting those elements of the source on which func returns true.
flatMap(func)	Similar to map, but each input item can be mapped to 0 or more output items (so func should return a Seq rather than a single item).
mapPartitions(func)	Similar to map, but runs separately on each partition (block) of the RDD, so func must be of type Iterator<T> => Iterator<U> when running on an RDD of type T.
mapPartitionsWithIndex(func)	Similar to mapPartitions, but also provides func with an integer value representing the index of the partition, so func must be of type (Int, Iterator<T>) => Iterator<U> when running on an RDD of type T.
sample(withReplacement, fraction, seed)	Sample a fraction fraction of the data, with or without replacement, using a given random number generator seed.
union(otherDataset)	Return a new dataset that contains the union of the elements in the source dataset and the argument.
intersection(otherDataset)	Return a new RDD that contains the intersection of elements in the source dataset and the argument.
distinct([numPartitions]))	Return a new dataset that contains the distinct elements of the source dataset.
groupByKey([numPartitions])	When called on a dataset of (K, V) pairs, returns a dataset of (K, Iterable<V>) pairs.
Note: If you are grouping in order to perform an aggregation (such as a sum or average) over each key, using reduceByKey or aggregateByKey will yield much better performance.
Note: By default, the level of parallelism in the output depends on the number of partitions of the parent RDD. You can pass an optional numPartitions argument to set a different number of tasks.
reduceByKey(func, [numPartitions])	When called on a dataset of (K, V) pairs, returns a dataset of (K, V) pairs where the values for each key are aggregated using the given reduce function func, which must be of type (V,V) => V. Like in groupByKey, the number of reduce tasks is configurable through an optional second argument.
aggregateByKey(zeroValue)(seqOp, combOp, [numPartitions])	When called on a dataset of (K, V) pairs, returns a dataset of (K, U) pairs where the values for each key are aggregated using the given combine functions and a neutral "zero" value. Allows an aggregated value type that is different than the input value type, while avoiding unnecessary allocations. Like in groupByKey, the number of reduce tasks is configurable through an optional second argument.
sortByKey([ascending], [numPartitions])	When called on a dataset of (K, V) pairs where K implements Ordered, returns a dataset of (K, V) pairs sorted by keys in ascending or descending order, as specified in the boolean ascending argument.
join(otherDataset, [numPartitions])	When called on datasets of type (K, V) and (K, W), returns a dataset of (K, (V, W)) pairs with all pairs of elements for each key. Outer joins are supported through leftOuterJoin, rightOuterJoin, and fullOuterJoin.
cogroup(otherDataset, [numPartitions])	When called on datasets of type (K, V) and (K, W), returns a dataset of (K, (Iterable<V>, Iterable<W>)) tuples. This operation is also called groupWith.
cartesian(otherDataset)	When called on datasets of types T and U, returns a dataset of (T, U) pairs (all pairs of elements).
pipe(command, [envVars])	Pipe each partition of the RDD through a shell command, e.g. a Perl or bash script. RDD elements are written to the process's stdin and lines output to its stdout are returned as an RDD of strings.
coalesce(numPartitions)	Decrease the number of partitions in the RDD to numPartitions. Useful for running operations more efficiently after filtering down a large dataset.
repartition(numPartitions)	Reshuffle the data in the RDD randomly to create either more or fewer partitions and balance it across them. This always shuffles all data over the network.
repartitionAndSortWithinPartitions(partitioner)	Repartition the RDD according to the given partitioner and, within each resulting partition, sort records by their keys. This is more efficient than calling repartition and then sorting within each partition because it can push the sorting down into the shuffle machinery.
Actions
The following table lists some of the common actions supported by Spark. Refer to the RDD API doc (Scala, Java, Python, R)

and pair RDD functions doc (Scala, Java) for details.

Action	Meaning
reduce(func)	Aggregate the elements of the dataset using a function func (which takes two arguments and returns one). The function should be commutative and associative so that it can be computed correctly in parallel.
collect()	Return all the elements of the dataset as an array at the driver program. This is usually useful after a filter or other operation that returns a sufficiently small subset of the data.
count()	Return the number of elements in the dataset.
first()	Return the first element of the dataset (similar to take(1)).
take(n)	Return an array with the first n elements of the dataset.
takeSample(withReplacement, num, [seed])	Return an array with a random sample of num elements of the dataset, with or without replacement, optionally pre-specifying a random number generator seed.
takeOrdered(n, [ordering])	Return the first n elements of the RDD using either their natural order or a custom comparator.
saveAsTextFile(path)	Write the elements of the dataset as a text file (or set of text files) in a given directory in the local filesystem, HDFS or any other Hadoop-supported file system. Spark will call toString on each element to convert it to a line of text in the file.
saveAsSequenceFile(path)
(Java and Scala)	Write the elements of the dataset as a Hadoop SequenceFile in a given path in the local filesystem, HDFS or any other Hadoop-supported file system. This is available on RDDs of key-value pairs that implement Hadoop's Writable interface. In Scala, it is also available on types that are implicitly convertible to Writable (Spark includes conversions for basic types like Int, Double, String, etc).
saveAsObjectFile(path)
(Java and Scala)	Write the elements of the dataset in a simple format using Java serialization, which can then be loaded using SparkContext.objectFile().
countByKey()	Only available on RDDs of type (K, V). Returns a hashmap of (K, Int) pairs with the count of each key.
foreach(func)	Run a function func on each element of the dataset. This is usually done for side effects such as updating an Accumulator or interacting with external storage systems.
Note: modifying variables other than Accumulators outside of the foreach() may result in undefined behavior. See Understanding closures for more details.
The Spark RDD API also exposes asynchronous versions of some actions, like foreachAsync for foreach, which immediately return a FutureAction to the caller instead of blocking on completion of the action. This can be used to manage or wait for the asynchronous execution of the action.

Shuffle operations
Certain operations within Spark trigger an event known as the shuffle. The shuffle is Spark’s mechanism for re-distributing data so that it’s grouped differently across partitions. This typically involves copying data across executors and machines, making the shuffle a complex and costly operation.

Background
To understand what happens during the shuffle we can consider the example of the reduceByKey operation. The reduceByKey operation generates a new RDD where all values for a single key are combined into a tuple - the key and the result of executing a reduce function against all values associated with that key. The challenge is that not all values for a single key necessarily reside on the same partition, or even the same machine, but they must be co-located to compute the result.

In Spark, data is generally not distributed across partitions to be in the necessary place for a specific operation. During computations, a single task will operate on a single partition - thus, to organize all the data for a single reduceByKey reduce task to execute, Spark needs to perform an all-to-all operation. It must read from all partitions to find all the values for all keys, and then bring together values across partitions to compute the final result for each key - this is called the shuffle.

Although the set of elements in each partition of newly shuffled data will be deterministic, and so is the ordering of partitions themselves, the ordering of these elements is not. If one desires predictably ordered data following shuffle then it’s possible to use:

mapPartitions to sort each partition using, for example, .sorted
repartitionAndSortWithinPartitions to efficiently sort partitions while simultaneously repartitioning
sortBy to make a globally ordered RDD
Operations which can cause a shuffle include repartition operations like repartition and coalesce, ‘ByKey operations (except for counting) like groupByKey and reduceByKey, and join operations like cogroup and join.

Performance Impact
The Shuffle is an expensive operation since it involves disk I/O, data serialization, and network I/O. To organize data for the shuffle, Spark generates sets of tasks - map tasks to organize the data, and a set of reduce tasks to aggregate it. This nomenclature comes from MapReduce and does not directly relate to Spark’s map and reduce operations.

Internally, results from individual map tasks are kept in memory until they can’t fit. Then, these are sorted based on the target partition and written to a single file. On the reduce side, tasks read the relevant sorted blocks.

Certain shuffle operations can consume significant amounts of heap memory since they employ in-memory data structures to organize records before or after transferring them. Specifically, reduceByKey and aggregateByKey create these structures on the map side, and 'ByKey operations generate these on the reduce side. When data does not fit in memory Spark will spill these tables to disk, incurring the additional overhead of disk I/O and increased garbage collection.

Shuffle also generates a large number of intermediate files on disk. As of Spark 1.3, these files are preserved until the corresponding RDDs are no longer used and are garbage collected. This is done so the shuffle files don’t need to be re-created if the lineage is re-computed. Garbage collection may happen only after a long period of time, if the application retains references to these RDDs or if GC does not kick in frequently. This means that long-running Spark jobs may consume a large amount of disk space. The temporary storage directory is specified by the spark.local.dir configuration parameter when configuring the Spark context.

Shuffle behavior can be tuned by adjusting a variety of configuration parameters. See the ‘Shuffle Behavior’ section within the Spark Configuration Guide.

RDD Persistence
One of the most important capabilities in Spark is persisting (or caching) a dataset in memory across operations. When you persist an RDD, each node stores any partitions of it that it computes in memory and reuses them in other actions on that dataset (or datasets derived from it). This allows future actions to be much faster (often by more than 10x). Caching is a key tool for iterative algorithms and fast interactive use.

You can mark an RDD to be persisted using the persist() or cache() methods on it. The first time it is computed in an action, it will be kept in memory on the nodes. Spark’s cache is fault-tolerant – if any partition of an RDD is lost, it will automatically be recomputed using the transformations that originally created it.

In addition, each persisted RDD can be stored using a different storage level, allowing you, for example, to persist the dataset on disk, persist it in memory but as serialized Java objects (to save space), replicate it across nodes. These levels are set by passing a StorageLevel object (Scala, Java, Python) to persist(). The cache() method is a shorthand for using the default storage level, which is StorageLevel.MEMORY_ONLY (store deserialized objects in memory). The full set of storage levels is:

Storage Level	Meaning
MEMORY_ONLY	Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, some partitions will not be cached and will be recomputed on the fly each time they're needed. This is the default level.
MEMORY_AND_DISK	Store RDD as deserialized Java objects in the JVM. If the RDD does not fit in memory, store the partitions that don't fit on disk, and read them from there when they're needed.
MEMORY_ONLY_SER
(Java and Scala)	Store RDD as serialized Java objects (one byte array per partition). This is generally more space-efficient than deserialized objects, especially when using a fast serializer, but more CPU-intensive to read.
MEMORY_AND_DISK_SER
(Java and Scala)	Similar to MEMORY_ONLY_SER, but spill partitions that don't fit in memory to disk instead of recomputing them on the fly each time they're needed.
DISK_ONLY	Store the RDD partitions only on disk.
MEMORY_ONLY_2, MEMORY_AND_DISK_2, etc.	Same as the levels above, but replicate each partition on two cluster nodes.
OFF_HEAP (experimental)	Similar to MEMORY_ONLY_SER, but store the data in off-heap memory. This requires off-heap memory to be enabled.
Note: In Python, stored objects will always be serialized with the Pickle library, so it does not matter whether you choose a serialized level. The available storage levels in Python include MEMORY_ONLY, MEMORY_ONLY_2, MEMORY_AND_DISK, MEMORY_AND_DISK_2, DISK_ONLY, and DISK_ONLY_2.

Spark also automatically persists some intermediate data in shuffle operations (e.g. reduceByKey), even without users calling persist. This is done to avoid recomputing the entire input if a node fails during the shuffle. We still recommend users call persist on the resulting RDD if they plan to reuse it.

Which Storage Level to Choose?
Spark’s storage levels are meant to provide different trade-offs between memory usage and CPU efficiency. We recommend going through the following process to select one:

If your RDDs fit comfortably with the default storage level (MEMORY_ONLY), leave them that way. This is the most CPU-efficient option, allowing operations on the RDDs to run as fast as possible.

If not, try using MEMORY_ONLY_SER and selecting a fast serialization library to make the objects much more space-efficient, but still reasonably fast to access. (Java and Scala)

Don’t spill to disk unless the functions that computed your datasets are expensive, or they filter a large amount of the data. Otherwise, recomputing a partition may be as fast as reading it from disk.

Use the replicated storage levels if you want fast fault recovery (e.g. if using Spark to serve requests from a web application). All the storage levels provide full fault tolerance by recomputing lost data, but the replicated ones let you continue running tasks on the RDD without waiting to recompute a lost partition.

Removing Data
Spark automatically monitors cache usage on each node and drops out old data partitions in a least-recently-used (LRU) fashion. If you would like to manually remove an RDD instead of waiting for it to fall out of the cache, use the RDD.unpersist() method.

Shared Variables
Normally, when a function passed to a Spark operation (such as map or reduce) is executed on a remote cluster node, it works on separate copies of all the variables used in the function. These variables are copied to each machine, and no updates to the variables on the remote machine are propagated back to the driver program. Supporting general, read-write shared variables across tasks would be inefficient. However, Spark does provide two limited types of shared variables for two common usage patterns: broadcast variables and accumulators.

Broadcast Variables
Broadcast variables allow the programmer to keep a read-only variable cached on each machine rather than shipping a copy of it with tasks. They can be used, for example, to give every node a copy of a large input dataset in an efficient manner. Spark also attempts to distribute broadcast variables using efficient broadcast algorithms to reduce communication cost.

Spark actions are executed through a set of stages, separated by distributed “shuffle” operations. Spark automatically broadcasts the common data needed by tasks within each stage. The data broadcasted this way is cached in serialized form and deserialized before running each task. This means that explicitly creating broadcast variables is only useful when tasks across multiple stages need the same data or when caching the data in deserialized form is important.

Broadcast variables are created from a variable v by calling SparkContext.broadcast(v). The broadcast variable is a wrapper around v, and its value can be accessed by calling the value method. The code below shows this:

scala> val broadcastVar = sc.broadcast(Array(1, 2, 3))
broadcastVar: org.apache.spark.broadcast.Broadcast[Array[Int]] = Broadcast(0)

scala> broadcastVar.value
res0: Array[Int] = Array(1, 2, 3)
After the broadcast variable is created, it should be used instead of the value v in any functions run on the cluster so that v is not shipped to the nodes more than once. In addition, the object v should not be modified after it is broadcast in order to ensure that all nodes get the same value of the broadcast variable (e.g. if the variable is shipped to a new node later).

Accumulators
Accumulators are variables that are only “added” to through an associative and commutative operation and can therefore be efficiently supported in parallel. They can be used to implement counters (as in MapReduce) or sums. Spark natively supports accumulators of numeric types, and programmers can add support for new types.

As a user, you can create named or unnamed accumulators. As seen in the image below, a named accumulator (in this instance counter) will display in the web UI for the stage that modifies that accumulator. Spark displays the value for each accumulator modified by a task in the “Tasks” table.

Accumulators in the Spark UI

Tracking accumulators in the UI can be useful for understanding the progress of running stages (NOTE: this is not yet supported in Python).

Scala
Java
Python
A numeric accumulator can be created by calling SparkContext.longAccumulator() or SparkContext.doubleAccumulator() to accumulate values of type Long or Double, respectively. Tasks running on a cluster can then add to it using the add method. However, they cannot read its value. Only the driver program can read the accumulator’s value, using its value method.

The code below shows an accumulator being used to add up the elements of an array:

scala> val accum = sc.longAccumulator("My Accumulator")
accum: org.apache.spark.util.LongAccumulator = LongAccumulator(id: 0, name: Some(My Accumulator), value: 0)

scala> sc.parallelize(Array(1, 2, 3, 4)).foreach(x => accum.add(x))
...
10/09/29 18:41:08 INFO SparkContext: Tasks finished in 0.317106 s

scala> accum.value
res2: Long = 10
While this code used the built-in support for accumulators of type Long, programmers can also create their own types by subclassing AccumulatorV2. The AccumulatorV2 abstract class has several methods which one has to override: reset for resetting the accumulator to zero, add for adding another value into the accumulator, merge for merging another same-type accumulator into this one. Other methods that must be overridden are contained in the API documentation. For example, supposing we had a MyVector class representing mathematical vectors, we could write:

class VectorAccumulatorV2 extends AccumulatorV2[MyVector, MyVector] {

  private val myVector: MyVector = MyVector.createZeroVector

  def reset(): Unit = {
    myVector.reset()
  }

  def add(v: MyVector): Unit = {
    myVector.add(v)
  }
  ...
}

// Then, create an Accumulator of this type:
val myVectorAcc = new VectorAccumulatorV2
// Then, register it into spark context:
sc.register(myVectorAcc, "MyVectorAcc1")
Note that, when programmers define their own type of AccumulatorV2, the resulting type can be different than that of the elements added.

For accumulator updates performed inside actions only, Spark guarantees that each task’s update to the accumulator will only be applied once, i.e. restarted tasks will not update the value. In transformations, users should be aware of that each task’s update may be applied more than once if tasks or job stages are re-executed.

Accumulators do not change the lazy evaluation model of Spark. If they are being updated within an operation on an RDD, their value is only updated once that RDD is computed as part of an action. Consequently, accumulator updates are not guaranteed to be executed when made within a lazy transformation like map(). The below code fragment demonstrates this property:

Scala
Java
Python
val accum = sc.longAccumulator
data.map { x => accum.add(x); x }
// Here, accum is still 0 because no actions have caused the map operation to be computed.
Deploying to a Cluster
The application submission guide describes how to submit applications to a cluster. In short, once you package your application into a JAR (for Java/Scala) or a set of .py or .zip files (for Python), the bin/spark-submit script lets you submit it to any supported cluster manager.

Launching Spark jobs from Java / Scala
The org.apache.spark.launcher package provides classes for launching Spark jobs as child processes using a simple Java API.

Unit Testing
Spark is friendly to unit testing with any popular unit test framework. Simply create a SparkContext in your test with the master URL set to local, run your operations, and then call SparkContext.stop() to tear it down. Make sure you stop the context within a finally block or the test framework’s tearDown method, as Spark does not support two contexts running concurrently in the same program.

Where to Go from Here
You can see some example Spark programs on the Spark website. In addition, Spark includes several samples in the examples directory (Scala, Java, Python, R). You can run Java and Scala examples by passing the class name to Spark’s bin/run-example script; for instance:

./bin/run-example SparkPi
For Python examples, use spark-submit instead:

./bin/spark-submit examples/src/main/python/pi.py
For R examples, use spark-submit instead:

./bin/spark-submit examples/src/main/r/dataframe.R
For help on optimizing your programs, the configuration and tuning guides provide information on best practices. They are especially important for making sure that your data is stored in memory in an efficient format. For help on deploying, the cluster mode overview describes the components involved in distributed operation and supported cluster managers.

Finally, full API documentation is available in Scala, Java, Python and R.