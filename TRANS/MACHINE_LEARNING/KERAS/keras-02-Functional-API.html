<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>Початок роботи з функціональним API Keras</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>Початок роботи з функціональним API Keras</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Функціональний API Keras - це спосіб визначення складних моделей, таких як моделі з декількома виходами, спрямовані ациклічні графіки або моделі з спільними шарами.</p></div>
<div class="paragraph"><p>Це керівництво передбачає, що ви вже знайомі з послідовною моделлю.</p></div>
<div class="paragraph"><p>Почнемо з чогось простого.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="______">Перший приклад: щільно пов'язана мережа</h2>
<div class="sectionbody">
<div class="paragraph"><p>Послідовна Sequential модель - це, мабуть, кращий вибір для реалізації такої мережі, але вона допомагає почати з чогось справді простого.</p></div>
<div class="ulist"><ul>
<li>
<p>
Примірник шару може визиватися (на тензорі), і він повертає тензор
</p>
</li>
<li>
<p>
Потім тензор(и) на вході та тензор(и) на виході можуть використовуватися для визначення моделі
</p>
</li>
<li>
<p>
Таку модель можна навчити так само, як і Sequential моделі Keras.
</p>
</li>
</ul></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="c1"># Це повертає тензор</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">784</span><span class="p">,))</span>

<span class="c1"># екземпляр шару може викликатись на тензорі і повертати тензор</span>
<span class="n">output_1</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
<span class="n">output_2</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">output_1</span><span class="p">)</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">output_2</span><span class="p">)</span>

<span class="c1"># Це створює модель, яка включає вхідний шар і три щільні шари</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">predictions</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;categorical_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>  <span class="c1"># починає тренування</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="________">Усі моделі викликаються так само, як і шари</h3>
<div class="paragraph"><p>За допомогою функціонального API легко повторно  використовувати натреновані моделі: ви можете ставитися до будь-якої моделі так, ніби до шару, визиваючи її на тензорі. Зауважте, що, викликаючи модель, ви не просто використовуєте архітектуру моделі, ви також повторно використовуєте її ваги.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">784</span><span class="p">,))</span>
<span class="c1"># This works, and returns the 10-way softmax we defined above.</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це може дозволити, наприклад, швидко створити моделі, які можуть обробляти послідовності входів. Ви можете перетворити модель класифікації зображень у модель відео класифікації лише в одному рядку.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">TimeDistributed</span>

<span class="c1"># Вхідний тензор для послідовностей 20 часових кроків,</span>
<span class="c1"># кожен містить 784-мірний вектор</span>
<span class="n">input_sequences</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="mi">784</span><span class="p">))</span>

<span class="c1"># Це стосується нашої попередньої моделі до кожного кроку часу у вхідній послідовності.</span>
<span class="c1"># вихід попередньої моделі був 10-ти канальний softmax,</span>
<span class="c1"># тому вихід шару нижче буде послідовністю 20 векторів розміром 10.</span>
<span class="n">processed_sequences</span> <span class="o">=</span> <span class="n">TimeDistributed</span><span class="p">(</span><span class="n">model</span><span class="p">)(</span><span class="n">input_sequences</span><span class="p">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_________2">Моделі з кількома входами та з декількома виходами</h3>
<div class="paragraph"><p>Ось гарний випадок використання функціонального API: моделі з декількома входами та виходами. Функціональний API дозволяє легко маніпулювати великою кількістю переплетених потоків даних.</p></div>
<div class="paragraph"><p>Розглянемо наступну модель. Ми прагнемо передбачити, скільки ретвітів і лайків отримає заголовок новин у Twitter. Основним входом до моделі буде сам заголовок, як послідовність слів. Але для того, щоб додати інтриги, наша модель також матиме допоміжний ввід, отримуючи додаткові дані, такі як час доби, коли розміщувався заголовок тощо. Модель також буде контролюватися за допомогою двох функцій втрат. Використання основної функції втрат раніше в моделі є хорошим механізмом регуляризації глибоких моделей.</p></div>
<div class="paragraph"><p>Ось як виглядає наша модель:</p></div>
<div class="paragraph"><p><span class="image">
<img src="multi-input-multi-output-graph.png" alt="multi-input-multi-output-graph.png" />
</span></p></div>
<div class="paragraph"><p>Давайте реалізуємо її за допомогою функціонального API.</p></div>
<div class="paragraph"><p>Основний вхід отримає заголовок у вигляді послідовності цілих чисел (кожне ціле число кодує слово). Цілі числа будуть від 1 до 10000 (словник 10 000 слів), а послідовності - 100 слів в довжину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Embedding</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Dense</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="c1"># Встановити випадкове зерно для відтворення</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Введення заголовка: призначене для отримання послідовностей з 100 цілих чисел, між 1 і 10000.</span>
<span class="c1"># Зауважте, що ми можемо назвати будь-який шар, передавши його через аргумент &quot;name&quot;.</span>
<span class="n">main_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;main_input&#39;</span><span class="p">)</span>

<span class="c1"># Цей шар вбудовування буде кодувати вхідну послідовність</span>
<span class="c1"># у послідовність щільних 512-мірних векторів.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">output_dim</span><span class="o">=</span><span class="mi">512</span><span class="p">,</span> <span class="n">input_dim</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">input_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)(</span><span class="n">main_input</span><span class="p">)</span>

<span class="c1"># LSTM перетворить послідовність векторів в один вектор,</span>
<span class="c1"># що містить інформацію про всю послідовність</span>
<span class="n">lstm_out</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Сюди ми вставляємо допоміжні втрати, що дозволяє спокійно тренуватися шару LSTM та Embedding, хоча основна втрата буде значно вищою в моделі.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">auxiliary_output</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aux_output&#39;</span><span class="p">)(</span><span class="n">lstm_out</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>У цей момент ми вводимо в модель наші допоміжні вхідні дані, з'єднуючи їх з LSTM-виходом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">auxiliary_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,),</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;aux_input&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lstm_out</span><span class="p">,</span> <span class="n">auxiliary_input</span><span class="p">])</span>

<span class="c1"># Зверху ми накладаємо глибоку щільно пов&#39;язану мережу</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># І, нарешті, ми додаємо основний логістичний рівень регресії</span>
<span class="n">main_output</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;main_output&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це визначає модель з двома входами та двома виходами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">main_input</span><span class="p">,</span> <span class="n">auxiliary_input</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="n">main_output</span><span class="p">,</span> <span class="n">auxiliary_output</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми компілюємо модель і присвоюємо вагу 0,2 до допоміжних втрат. Щоб вказати різні <code>loss_weights</code> або <code>loss</code> для кожного з різних виводів, ви можете використовувати список або словник. Тут ми передаємо єдину втрату як аргумент <code>loss</code>, тому однакові втрати будуть використані на всіх результатах.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">loss_weights</span><span class="o">=</span><span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо тренувати модель, передаючи їй списки вхідних масивів та цільових масивів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">headline_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
<span class="n">additional_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">headline_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">additional_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">headline_data</span><span class="p">,</span> <span class="n">additional_data</span><span class="p">],</span> <span class="p">[</span><span class="n">headline_labels</span><span class="p">,</span> <span class="n">additional_labels</span><span class="p">],</span>
          <span class="n">epochs</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Since our inputs and outputs are named (we passed them a "name" argument), we could also have compiled the model via:
Оскільки наші входи та виходи іменовані (ми передали їм аргумент <code>"name"</code>), ми також могли скласти модель за допомогою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;main_output&#39;</span><span class="p">:</span> <span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span> <span class="s1">&#39;aux_output&#39;</span><span class="p">:</span> <span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">},</span>
              <span class="n">loss_weights</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;main_output&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">,</span> <span class="s1">&#39;aux_output&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">})</span>

<span class="c1"># І навчили це через:</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">({</span><span class="s1">&#39;main_input&#39;</span><span class="p">:</span> <span class="n">headline_data</span><span class="p">,</span> <span class="s1">&#39;aux_input&#39;</span><span class="p">:</span> <span class="n">additional_data</span><span class="p">},</span>
          <span class="p">{</span><span class="s1">&#39;main_output&#39;</span><span class="p">:</span> <span class="n">headline_labels</span><span class="p">,</span> <span class="s1">&#39;aux_output&#39;</span><span class="p">:</span> <span class="n">additional_labels</span><span class="p">},</span>
          <span class="n">epochs</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб використовувати модель для інтерференції, використовуйте</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">({</span><span class="s1">&#39;main_input&#39;</span><span class="p">:</span> <span class="n">headline_data</span><span class="p">,</span> <span class="s1">&#39;aux_input&#39;</span><span class="p">:</span> <span class="n">additional_data</span><span class="p">})</span>
</pre></div></div></div>
<div class="paragraph"><p>або альтернативно,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">pred</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">([</span><span class="n">headline_data</span><span class="p">,</span> <span class="n">additional_data</span><span class="p">])</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__">Спільні шари</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ще одне корисне використання функціонального API - це моделі, які використовують спільні шари. Давайте розглянемо спільні шари.</p></div>
<div class="paragraph"><p>Розглянемо набір даних твітів. Ми хочемо створити модель, яка може визначити, чи два твіти від однієї особи чи ні (це, наприклад, може дозволити нам порівнювати користувачів за подібністю їх твітів).</p></div>
<div class="paragraph"><p>Один із способів досягти цього - побудувати модель, яка кодує два твіти на два вектори, об'єднує вектори і потім додає логістичну регресію; це виводить ймовірність того, що два твіти поділяють одного автора. Потім модель буде тренуватися на парах позитивних твіттів і негативних твіттів.</p></div>
<div class="paragraph"><p>Оскільки проблема симетрична, механізм, що кодує перший твіт, слід повторно використовувати (ваги та все), щоб кодувати другий твіт. Тут ми використовуємо загальний шар LSTM для кодування твітів.</p></div>
<div class="paragraph"><p>Давайте побудуємо це за допомогою функціонального API. Ми будемо брати за твіт двійникову матрицю форми (280, 256), тобто послідовність 280 векторів розміром 256, де кожен вимір у 256-мірному векторі кодує наявність/відсутність символу (з алфавіту в 256 частих символів).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">keras</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Dense</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="n">tweet_a</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">280</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="n">tweet_b</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">280</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб поділити шар на різні входи, просто інстанціюйте шар один раз, а потім викличте його на стільки входів, скільки вам потрібно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1"># Цей шар може взяти за вхід матрицю</span>
<span class="c1"># і поверне вектор розміром 64</span>
<span class="n">shared_lstm</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>

<span class="c1"># Коли ми повторно використовуємо той самий екземпляр шару</span>
<span class="c1"># багаторазово, ваги шару також використовуються повторно</span>
<span class="c1"># (це ефективно *той самий* шар)</span>
<span class="n">encoded_a</span> <span class="o">=</span> <span class="n">shared_lstm</span><span class="p">(</span><span class="n">tweet_a</span><span class="p">)</span>
<span class="n">encoded_b</span> <span class="o">=</span> <span class="n">shared_lstm</span><span class="p">(</span><span class="n">tweet_b</span><span class="p">)</span>

<span class="c1"># Ми тепер можемо об&#39;єднати два вектори:</span>
<span class="n">merged_vector</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">encoded_a</span><span class="p">,</span> <span class="n">encoded_b</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># І зверху додати логістичну регресію</span>
<span class="n">predictions</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">)(</span><span class="n">merged_vector</span><span class="p">)</span>

<span class="c1"># Ми визначаємо навчальну модель, пов&#39;язуючи</span>
<span class="c1"># вхідні твіти з прогнозами</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">tweet_a</span><span class="p">,</span> <span class="n">tweet_b</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="n">predictions</span><span class="p">)</span>

<span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;rmsprop&#39;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;binary_crossentropy&#39;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;accuracy&#39;</span><span class="p">])</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">([</span><span class="n">data_a</span><span class="p">,</span> <span class="n">data_b</span><span class="p">],</span> <span class="n">labels</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Let&#8217;s pause to take a look at how to read the shared layer&#8217;s output or output shape.
Давайте зупинимось, щоб розглянути, як читати вивід спільного шару або форму виводу.</p></div>
<div class="sect2">
<h3 id="___">Поняття "вузла" шару</h3>
<div class="paragraph"><p>Щоразу, коли ви викликаєте шар на якомусь вході, ви створюєте новий тензор (вихід шару), і ви додаєте "вузол" до шару, пов'язуючи вхідний тензор з вихідним тензором. Коли ви викликаєте один і той же шар кілька разів, цей шар володіє декількома вузлами з індексами 0, 1, 2 &#8230;</p></div>
<div class="paragraph"><p>У попередніх версіях Keras можна було отримати вихідний тензор екземпляра шару через <code>layer.get_output()</code> або його вихідну форму через <code>layer.output_shape</code>. Ви все ще можете це зробити (хоча <code>get_output()</code> було замінено результатом властивості). Але що робити, якщо шар підключений до декількох входів?</p></div>
<div class="paragraph"><p>Поки шар з'єднаний лише з одним входом, не буде плутанини, і <code>.output</code> поверне один вихід шару:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">280</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>

<span class="n">lstm</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="n">encoded_a</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">lstm</span><span class="o">.</span><span class="n">output</span> <span class="o">==</span> <span class="n">encoded_a</span>
</pre></div></div></div>
<div class="paragraph"><p>Не так, якщо в шарі є кілька входів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">280</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">280</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>

<span class="n">lstm</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>
<span class="n">encoded_a</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">encoded_b</span> <span class="o">=</span> <span class="n">lstm</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

<span class="n">lstm</span><span class="o">.</span><span class="n">output</span>
<span class="o">&gt;&gt;</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="n">Layer</span> <span class="n">lstm_1</span> <span class="n">has</span> <span class="n">multiple</span> <span class="n">inbound</span> <span class="n">nodes</span><span class="p">,</span>
<span class="n">hence</span> <span class="n">the</span> <span class="n">notion</span> <span class="n">of</span> <span class="s2">&quot;layer output&quot;</span> <span class="ow">is</span> <span class="n">ill</span><span class="o">-</span><span class="n">defined</span><span class="o">.</span>
<span class="n">Use</span> <span class="sb">`get_output_at(node_index)`</span> <span class="n">instead</span><span class="o">.</span>
</pre></div></div></div>
<div class="paragraph"><p>Нехай так. Наступне робить:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="n">lstm</span><span class="o">.</span><span class="n">get_output_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">encoded_a</span>
<span class="k">assert</span> <span class="n">lstm</span><span class="o">.</span><span class="n">get_output_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">encoded_b</span>
</pre></div></div></div>
<div class="paragraph"><p>Досить просто, чи не так?</p></div>
<div class="paragraph"><p>The same is true for the properties input_shape and output_shape: as long as the layer has only one node, or as long as all nodes have the same input/output shape, then the notion of "layer output/input shape" is well defined, and that one shape will be returned by layer.output_shape/layer.input_shape. But if, for instance, you apply the same Conv2D layer to an input of shape (32, 32, 3), and then to an input of shape (64, 64, 3), the layer will have multiple input/output shapes, and you will have to fetch them by specifying the index of the node they belong to:
Те саме стосується властивостей <code>input_shape</code> та <code>output_shape</code>: якщо у шару є лише один вузол, або поки всі вузли мають однакову форму вводу/виводу, тоді поняття "форма виводу/введення шару" добре визначена, і одна форма повернеться <code>layer.output_shape</code>/<code>layer.input_shape</code>. Але якщо, наприклад, ви застосуєте один і той же шар <code>Conv2D</code> до вводу форми <code>(32, 32, 3)</code>, а потім до вводу форми <code>(64, 64, 3)</code>, шар буде мати кілька форм вводу/виводу, і вам доведеться отримати їх, вказавши індекс вузла, до якого вони належать:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="n">conv</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
<span class="n">conved_a</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># Поки що тільки один вхід, буде працювати наступне:</span>
<span class="k">assert</span> <span class="n">conv</span><span class="o">.</span><span class="n">input_shape</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">conved_b</span> <span class="o">=</span> <span class="n">conv</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c1"># тепер властивість `.input_shape` не працює, але це так:</span>
<span class="k">assert</span> <span class="n">conv</span><span class="o">.</span><span class="n">get_input_shape_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">conv</span><span class="o">.</span><span class="n">get_input_shape_at</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___2">Більше прикладів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Приклади коду все ще є найкращим способом для початку, тому ось ще декілька.</p></div>
<div class="sect2">
<h3 id="__inception">Модуль Inception</h3>
<div class="paragraph"><p>Щоб отримати додаткові відомості про архітектуру Inception, див. <a href="http://arxiv.org/abs/1409.4842">Заглиблення в Convolutions</a>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Input</span>

<span class="n">input_img</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="n">tower_1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">input_img</span><span class="p">)</span>
<span class="n">tower_1</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">tower_1</span><span class="p">)</span>

<span class="n">tower_2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">input_img</span><span class="p">)</span>
<span class="n">tower_2</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">tower_2</span><span class="p">)</span>

<span class="n">tower_3</span> <span class="o">=</span> <span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">strides</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)(</span><span class="n">input_img</span><span class="p">)</span>
<span class="n">tower_3</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">tower_3</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">tower_1</span><span class="p">,</span> <span class="n">tower_2</span><span class="p">,</span> <span class="n">tower_3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Залишкове з'єднання на шарі згортки</p></div>
<div class="paragraph"><p>Додаткову інформацію про залишкові мережі див. у розділі <a href="http://arxiv.org/abs/1512.03385">Глибоке залишкове навчання для розпізнавання зображень</a>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">Input</span>

<span class="c1"># input tensor for a 3-channel 256x256 image</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># 3x3 conv with 3 output channels (same as input channels)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span>
<span class="c1"># this returns x + y.</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">add</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____2">Модель спільного бачення</h3>
<div class="paragraph"><p>Ця модель повторно використовує один і той же модуль обробки зображень на двох входах, щоб класифікувати, чи дві цифри MNIST однакові або різні.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span>

<span class="c1"># Спочатку визначте модулі зору</span>
<span class="n">digit_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))(</span><span class="n">digit_input</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">x</span><span class="p">)</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">x</span><span class="p">)</span>

<span class="n">vision_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">digit_input</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>

<span class="c1"># Потім визначте модель різпізнавання цифр</span>
<span class="n">digit_a</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">digit_b</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">27</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="c1"># Модель бачення буде спільною, з вагами та всім</span>
<span class="n">out_a</span> <span class="o">=</span> <span class="n">vision_model</span><span class="p">(</span><span class="n">digit_a</span><span class="p">)</span>
<span class="n">out_b</span> <span class="o">=</span> <span class="n">vision_model</span><span class="p">(</span><span class="n">digit_b</span><span class="p">)</span>

<span class="n">concatenated</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out_a</span><span class="p">,</span> <span class="n">out_b</span><span class="p">])</span>
<span class="n">out</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">)(</span><span class="n">concatenated</span><span class="p">)</span>

<span class="n">classification_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">([</span><span class="n">digit_a</span><span class="p">,</span> <span class="n">digit_b</span><span class="p">],</span> <span class="n">out</span><span class="p">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____">Візуальна модель відповіді на питання</h3>
<div class="paragraph"><p>Ця модель може вибрати правильну односкладну відповідь, коли задається питанням природної мови щодо малюнка.</p></div>
<div class="paragraph"><p>Вона працює, кодуючи питання у вектор, кодуючи зображення у вектор, поєднуючи ці два та тренуючись на базі  логістичної регресії над деяким словником потенційних відповідей.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Embedding</span><span class="p">,</span> <span class="n">Dense</span>
<span class="kn">from</span> <span class="nn">keras.models</span> <span class="kn">import</span> <span class="n">Model</span><span class="p">,</span> <span class="n">Sequential</span>

<span class="c1"># Спочатку давайте визначимо модель бачення за допомогою послідовної моделі.</span>
<span class="c1"># Ця модель буде кодувати зображення у вектор.</span>
<span class="n">vision_model</span> <span class="o">=</span> <span class="n">Sequential</span><span class="p">()</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">,</span> <span class="n">input_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">128</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Conv2D</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">MaxPooling2D</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="n">vision_model</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Flatten</span><span class="p">())</span>

<span class="c1"># Тепер давайте отримаємо тензор із результатом нашої моделі бачення:</span>
<span class="n">image_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">encoded_image</span> <span class="o">=</span> <span class="n">vision_model</span><span class="p">(</span><span class="n">image_input</span><span class="p">)</span>

<span class="c1"># Далі визначимо мовну модель для кодування питання у вектор.</span>
<span class="c1"># Кожне питання матиме не більше 100 слів в довжину,</span>
<span class="c1"># і будемо індексувати слова як цілі числа від 1 до 9999.</span>
<span class="n">question_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">embedded_question</span> <span class="o">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">input_dim</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">output_dim</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">input_length</span><span class="o">=</span><span class="mi">100</span><span class="p">)(</span><span class="n">question_input</span><span class="p">)</span>
<span class="n">encoded_question</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">256</span><span class="p">)(</span><span class="n">embedded_question</span><span class="p">)</span>

<span class="c1"># Об&#39;єднуємо вектор питання та вектор зображення:</span>
<span class="n">merged</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">encoded_question</span><span class="p">,</span> <span class="n">encoded_image</span><span class="p">])</span>

<span class="c1"># Тренуємо логістичну регресію на 1000чі слів:</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">merged</span><span class="p">)</span>

<span class="c1"># Це наша остаточна модель:</span>
<span class="n">vqa_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">image_input</span><span class="p">,</span> <span class="n">question_input</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output</span><span class="p">)</span>

<span class="c1"># The next stage would be training this model on actual data.</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____3">Модель відео відповідача</h3>
<div class="paragraph"><p>Тепер, коли ми навчили нашу модель QA зображення, ми можемо швидко перетворити її на відео QA-модель. З відповідним навчанням ви зможете показати їй коротке відео (наприклад, людські дії на 100 кадрів) і задати природне мовне запитання щодо відео (наприклад, "у який вид спорту грає хлопець?" &#8594; "у футбол").</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">keras.layers</span> <span class="kn">import</span> <span class="n">TimeDistributed</span>

<span class="n">video_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="c1"># Це наше відео, закодоване через попередньо навчену модель vid_model (ваги використовуються повторно)</span>
<span class="n">encoded_frame_sequence</span> <span class="o">=</span> <span class="n">TimeDistributed</span><span class="p">(</span><span class="n">vision_model</span><span class="p">)(</span><span class="n">video_input</span><span class="p">)</span>  <span class="c1"># the output will be a sequence of vectors</span>
<span class="n">encoded_video</span> <span class="o">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="mi">256</span><span class="p">)(</span><span class="n">encoded_frame_sequence</span><span class="p">)</span>  <span class="c1"># the output will be a vector</span>

<span class="c1"># Це представлення на рівні моделі кодера запитання, використовуючи ті ж ваги, що і раніше:</span>
<span class="n">question_encoder</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">question_input</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">encoded_question</span><span class="p">)</span>

<span class="c1"># Давайте використаємо його для кодування питання:</span>
<span class="n">video_question_input</span> <span class="o">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">)</span>
<span class="n">encoded_video_question</span> <span class="o">=</span> <span class="n">question_encoder</span><span class="p">(</span><span class="n">video_question_input</span><span class="p">)</span>

<span class="c1"># І це наша модель відповіді на відео запитання:</span>
<span class="n">merged</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">encoded_video</span><span class="p">,</span> <span class="n">encoded_video_question</span><span class="p">])</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">Dense</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;softmax&#39;</span><span class="p">)(</span><span class="n">merged</span><span class="p">)</span>
<span class="n">video_qa_model</span> <span class="o">=</span> <span class="n">Model</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="p">[</span><span class="n">video_input</span><span class="p">,</span> <span class="n">video_question_input</span><span class="p">],</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output0</span>
</pre></div></div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-14 23:15:06 EET
</div>
</div>
</body>
</html>
