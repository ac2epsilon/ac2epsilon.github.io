<!DOCTYPE html>
<!-- saved from url=(0073)https://www.raywenderlich.com/170075/android-recyclerview-tutorial-kotlin -->
<html class="chrome gr__raywenderlich_com" lang="en-US">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Туторіал Android RecyclerView з Kotlin</title>
  </head>
  <body style="   " data-gr-c-s-loaded="true" class="post-template-default single single-post postid-170075 single-format-standard">
    <sub><a id="firstLine" name="firstLine"></a>Переклад українською - <a href="mailto:ac2epsilon@gmail.com">Арсеній
        Чеботарьов</a> - Ніжин 2015-2018<br>
    </sub>
    <div id="main" class="wrapper clearfix">
      <div id="container">
        <div id="primary" class="no-margin-left">
          <div id="primary-container">
            <div id="content">
              <article id="post-170075" class="clearfix post-170075 post type-post status-publish format-standard has-post-thumbnail hentry category-user-interface-android tag-tutorial tag-kotlin tag-recyclerview tag-android">
                <header class="entry-header">
                  <h2 class="entry-title"> <a href="https://www.raywenderlich.com/170075/android-recyclerview-tutorial-kotlin"
                      title="Android RecyclerView Tutorial with Kotlin" sl-processed="1">Туторіал
                      Android RecyclerView з Kotlin</a> </h2>
                  <div class="tutorial-meta" id="larger-screens">
                    <div class="author-meta"> <a href="https://www.raywenderlich.com/u/rbiresch"
                        sl-processed="1"><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/ecf3313d6dc0db1568a252b8b20e1bd0.jpg"
                          alt="" class="user-avatar" width="100" height="100"></a><a
                        href="https://www.raywenderlich.com/u/rbiresch" class="author-name"
                        sl-processed="1">Rod Biresch</a> <span class="author-post-date">on
                        October 4, 2017</span></div>
                  </div>
                </header>
                <div class="content-wrapper">
                  <div class="note">
                    <p><em>Зауваження щото оновлення</em>: Цей туторіал був
                      оновлений&nbsp;Rod Biresch для Kotlin, Android 26 (Oreo)
                      та Android Studio 3.0. Оригінальний туторіал був написаний
                      Darryl Bayliss. </p>
                  </div>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/RecyclerView-feature-320x320.png"
                      alt="RecyclerView-feature" class="alignright size-medium wp-image-136529"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-320x320.png 320w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-250x250.png 250w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature.png 500w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-32x32.png 32w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-50x50.png 50w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-64x64.png 64w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-96x96.png 96w, https://koenig-media.raywenderlich.com/uploads/2016/06/RecyclerView-feature-128x128.png 128w"
                      sizes="(max-width: 250px) 100vw, 250px" width="250" height="250">Ресайклінг
                    (ака повторне використання) є одною з тих речей, що корисна
                    для планети, та є логічним способом переконатись, що ми не
                    потонемо у власному смітті, або залишимось без ресурсів в
                    майбутньому. </p>
                  <p>Декілька Android інженерів подумали про вигоди ресайклингу
                    та уявили, що OS може виконуватись більш ефективно, якщо
                    буде повтороно використовувати ресурси. Результатом цього
                    натхнення були мільйони еко-воїнів та ентузіастів
                    ресайклінгу, коли віджет <code>RecyclerView</code> був
                    включений до Android Lollipop — або десь так. :]</p>
                  <p>Ще більше свято було, коли Google анонсував бібліотеку
                    підтримки, що робить це чистою, зеленою машиною ресайклингу,
                    зворотньо сумісною з усіма версіями аж до Android Eclair
                    (2.2), що був виданий аж у 2010му році!</p>
                  <p>В цьому туторіалі ви отримаєте досвід щодо використання
                    RecyclerView в дії, а саме навчитесь щодо наступного:</p>
                  <ul>
                    <li>Призначення RecyclerView</li>
                    <li>Компоненти, з яких складається RecyclerView</li>
                    <li>Як змінити розміщення RecyclerView</li>
                    <li>Як додати деякі милі анімації до вашого RecyclerView</li>
                  </ul>
                  <p>Також ми завітаємо у відкритий космос, разом з прикладом
                    застосування <em>Galacticon</em>. Ви будете будувати свій
                    потік зі щоденних астрономічних світлин з публічного NASA
                    API.</p>
                  <div class="note">
                    <p><em>Попередні вимоги</em>: Вам треба мати робочі навички
                      з робробки для Android з Kotlin, перед проходженням цього
                      туторіала. Якщо вам треба оновити знаяння, подивіться на
                      наші <a title="Android Tutorials" href="http://www.raywenderlich.com/category/android"
                        target="_blank" sl-processed="1">вступні туторіали</a>!
                      Також вам знадобиться Android Studio 3.0 або новіша.</p>
                  </div>
                  <h2>Прямуємо на мис Канаверал: починаємо</h2>
                  <p>Завантажте <a href="https://koenig-media.raywenderlich.com/uploads/2017/09/galacticon-starter-5.zip"
                      sl-processed="1">початковий проект</a> та відкрийте його в
                    Android Studio. Це ще не багато що робить, та всемогутній
                    RecyclerView нема де бачити. </p>
                  <p>Клацніть на кнопці <em>Run app</em> зверху, та початите
                    дещо, що представляє відкритий космос в дещо невірний
                    спосіб:<br>
                    <img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/1-empty-app-1-281x500.png"
                      alt="" class="aligncenter size-large wp-image-170498" srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/1-empty-app-1-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/1-empty-app-1-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/1-empty-app-1.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <p>Він пустий, але це не добре. Ви не дуже чомусь навчитесь,
                    якщо за вас буде зроблена вся робота! Перед тим, як ви
                    зможете додати чудову астрофоторафію від NASA, вам
                    знадобиться виконати деякі налаштування.</p>
                  <h2>Отримання API ключив до Shuttle</h2>
                  <p>Ви будете використовувати <a href="http://apod.nasa.gov/"
                      target="_blank" title="Astronomy Picture of the Day API" sl-processed="1">Astronomy
                      Picture of the Day API</a>, один з найбільш популярних веб
                    сервісів, запроваджених NASA. Щоб переконатись, що вони не
                    стануть жертвами небажаного трафіку, сервіс вимагає від вас
                    мати ключ API, що буде застосовуватись з вашим
                    застосуванням.</p>
                  <p>На щастя, отримання ключа таке просте, к надання вашого
                    ім'я та адреси електронної пошти до <a href="https://api.nasa.gov/index.html#apply-for-an-api-key"
                      target="_blank" title="webpage" sl-processed="1">api.nasa.gov</a>,
                    та копіювання ключа API, що з'явиться на екрані або (не або,
                    а також - <em>прим.перекл</em>) на вашу електронну пошту.</p>
                  <p>Як тільки ви отримаєте ваш ключ API, скопіюйте його,
                    відкрийте файл <em>strings.xml</em> в вашому проекті, та
                    вставьте ваш ключ API як текстовий ресурс <code>api_key</code>,
                    заміщуючи <code>INSERT API KEY HERE</code>:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/4.-API_KEY-paste-700x296.png"
                      alt="4. API_KEY paste" class="aligncenter size-large wp-image-126540"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2016/02/4.-API_KEY-paste-700x296.png 700w, https://koenig-media.raywenderlich.com/uploads/2016/02/4.-API_KEY-paste-480x203.png 480w, https://koenig-media.raywenderlich.com/uploads/2016/02/4.-API_KEY-paste-768x325.png 768w"
                      sizes="(max-width: 700px) 100vw, 700px" width="700" height="296"></p>
                  <h2>Космічна чудасія: вивчаємо RecyclerView</h2>
                  <p>Ви готові для запуску у відкритий космос, щоб дослідити
                    величність RecyclerViews, але некомпетентний командер
                    прямуватиме до невідомого без підготування. Ви маєте
                    запитання, та вам потрібні відповіді, перед тим, як іти
                    далі. Дивіться на цей розділ, як на брифінг перед міссією.</p>
                  <p>На RecyclerView можна дивитись як на комбінацію <em>ListView</em>
                    та <em>GridView</em>. Однак, існують додаткові можливості,
                    що поділяє ваш код на керовані компоненти, так само, як
                    вонивикористовують ефективні до пам'яті шаблони дизайну. </p>
                  <p>Але як це було б краще за спробувані та протестовані&nbsp;
                    ListView та GridView, які ми вже використовували? Чи це
                    якась технологія прибульців? Відповіді, як завжди, криються
                    в деталях.</p>
                  <h3>Чому вам потрібен RecyclerView</h3>
                  <p>Уявіть, що ви створили ListView, де показати власні
                    документи є досить складним. Займе деякий час мило створити
                    рядкове розташування для ціх елементів, та потім використати
                    це розташування в вашому адаптері. </p>
                  <p>В вашому методі <code>getView()</code> ви розкладуєте ваше
                    нове розташування елементу. Поітм ви посилаєтесь на кожний
                    елемент всередині, через використання унікальних
                    ідентифікаторів, що ви провадите в вашому XML, щоб
                    налаштувати та додати деяку логіку відображення. Коли все
                    буде скінчено, ви передаєте цей елемент до ListView, що
                    готовий відображувати це на екрані. Все гарно…чи не так?</p>
                  <p>Правда полягає в тому, що ListViews та GridViews роблять
                    тільки половину роботи по досягненню дійсної ефективності по
                    пам'яті. Вони повторно використовують <em>макет</em>
                    елементу, але не мають посилання на дітей розташування,
                    примушуючи до виклику <code>findViewById()</code> для
                    кожного елементу розташування, кожного разу при виклику <code>getView()</code>.</p>
                  <p>Всі ці виклики можуть стати <em>дуже</em>
                    процесор-інтенсивними, особливо для складних розташувань.
                    Більше цього, ситуація може призвести до того, що прокрутка
                    вашого ListView стане сіпаною, або нереагуючою, бо він
                    нестямно намагається займати ресурси для запитаних вами
                    елементів.</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/ListView--700x491.png"
                      alt="ListView-" class="aligncenter size-large wp-image-126766"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2016/02/ListView-.png 700w, https://koenig-media.raywenderlich.com/uploads/2016/02/ListView--456x320.png 456w"
                      sizes="(max-width: 600px) 100vw, 600px" width="600" height="421"></p>
                  <p>Інженери Android з самого початку провадили рішення до цієї
                    проблеми на сайті Android Developers за допомогою <a href="http://developer.android.com/training/improving-layouts/smooth-scrolling.html#ViewHolder"
                      title="smooth scrolling" target="_blank" sl-processed="1">гладкого
                      прокручування</a>, через потужний шаблон <code>View
                      Holder</code>. </p>
                  <p>Коли ви використовуєте цей шаблон, ви створите клас, що
                    стає посиланням в пам'яті на всі елементи, потрібні для
                    вашого розташування. Вигода в тому, що якщо ви встановите
                    посилання один раз, та потім будете використовувати їх,
                    ефективно є обхідним шляхом щодо пікового навантаження, що
                    випливає від постійних викликів <code>findViewById()</code>.</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/viewholder_new_larger.png"
                      alt="viewholder_new_larger" class="aligncenter size-full wp-image-134106"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2016/05/viewholder_new_larger.png 594w, https://koenig-media.raywenderlich.com/uploads/2016/05/viewholder_new_larger-418x320.png 418w"
                      sizes="(max-width: 594px) 100vw, 594px" width="594" height="455"></p>
                  <p>Проблема в тому, що це опціональний шаблон для ListView або
                    GridView. Якщо ви не підозрювали про ці деталі, тоді ви
                    можете здивуватись, чому ваші ListViews та GridViews такі
                    повільні.</p>
                  <h2>Перший контакт: RecyclerView та розташування</h2>
                  <p>Поява RecyclerView змінила все. Він використовує <em>Adapter</em>,
                    щоб діяти як джерело даних; однак, ви маєте створити <em>ViewHolders</em>
                    для утримання посилань в пам'яті. </p>
                  <p>Коли вам треба новий елемент, він або створює новий об'єкт
                    ViewHolder для розгортання розташування, та зберігати ці
                    посилання, або буде повторно використаний такий з існуючого
                    стеку.&nbsp; </p>
                  <p>Тепер ви знаєте, чому він названий RecyclerView!</p>
                  <p>Інший прибуток з використання RecyclerViews є в тому, що
                    він іде з анімаціями по замовчанню, що ви не створювали та
                    додавали самотуж&nbsp; — вони просто роблять. </p>
                  <p>Дякуючи потребі в ViewHolder, RecyclerView точно знає, яку
                    анімацію застосовувати до кожного елементу. Та що краще за
                    все, він просто робить, як треба. Ви навіть можете створити
                    ваші власні анімації, та застосувати їх, якщо виникне
                    потреба.</p>
                  <p>Останній, та найбільш цікавий компонент RecyclerView, це
                    його <em>LayoutManager</em>. Цей об'єкт роміщує елементи
                    RecyclerView, та каже йому, коли повторно використовувати
                    елементи, що перемістились за межі екрарну.</p>
                  <p>Менеджери розташування надходять в трьох варіантах по
                    замовчанню:</p>
                  <ul>
                    <li><em>LinearLayoutManager</em> позиціонює ваші елементи як
                      стандартний ListView</li>
                    <li><em>GridLayoutManager</em> розміщує ваші елементи в
                      решитці, подібно до GridView</li>
                    <li><em>StaggeredGridLayoutManager</em> позиціонує елементи
                      в форматі зсунутої сітки.</li>
                  </ul>
                  <p>Також ви можете створити ваш власний <code>LayoutManagers</code>
                    для використання в <code>RecyclerView</code>, якщо ви
                    бажаєте додатковий рівень налаштування.</p>
                  <p>Маємо надію, що це відповідає на всі ваші питання,
                    командер. Тепер час розпочати місію!</p>
                  <h2>Підготовка до запуску: створення RecyclerView</h2>
                  <p>Щоб створити RecyclerView ми розіб'ємо роботу на чотири
                    частини:</p>
                  <ol>
                    <li>Декларувати RecyclerView в розміщенні макету, та зробити
                      посилання на нього в нашому файлі Kotlin.</li>
                    <li>Створити власний елемент XML розташування для вашого
                      RecyclerView, що буде використовуватись для елементів.</li>
                    <li>Створити зберігач елементів для ваших елементів
                      перегляду, перехопити джерело даних RecyclerView, та
                      ообробити логіку перегляду, через створення адаптеру
                      RecyclerView Adapter.</li>
                    <li>Під'єднати адаптер до RecyclerView.</li>
                  </ol>
                  <p>Перший крок має бути знайомим. Відкрийте файл розташування
                    <em>activity_main.xml</em>, та додайте наступне як дитину до
                    LinearLayout:</p>
                  <pre class="language-xml hljs" lang="xml"><span class="hljs-tag">&lt;<span
class="hljs-name">android.support.v7.widget.RecyclerView</span>
  <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/recyclerView"</span>
  <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span>
  <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>
  <span class="hljs-attr">android:scrollbars</span>=<span class="hljs-string">"vertical"</span>/&gt;</span>
</pre>
                  <p>Тут ми встановлюємо розташування, та кажемо&nbsp;
                    RecyclerView зайняти весь батьківський контейнер.</p>
                  <div class="note">
                    <p><em>Зауваження</em>: Ви використовуєте бібліотеку
                      підтримки v7 для зворотньої сумісності зі старішими
                      пристроями. Стартовий проект вже додає RecyclerView
                      Support Library як залежність до вашого застосування в
                      файлі <em>build.gradle</em>. Якщо ви бажаєте більше
                      інформації як це зробити самотуж, клацніть на сайті <a href="http://developer.android.com/tools/support-library/setup.html"
                        target="_blank" sl-processed="1">Android developer</a>.</p>
                  </div>
                  <p>Відкрийте <em>MainActivity.kt</em>, та декларуйте наступну
                    властивість сверху класу:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> linearLayoutManager: LinearLayoutManager
</pre>
                  <p>В <code>onCreate()</code> додайте наступні рядки після <code>setContentView</code>:</p>
                  <pre class="language-kotlin hljs" lang="kotlin">linearLayoutManager = LinearLayoutManager(<span
class="hljs-keyword">this</span>)
recyclerView.layoutManager = linearLayoutManager
</pre>
                  <p>Android Studio має надати підказку для імпорту <code>kotlinx.android.synthetic.main.activity_main.*</code>
                    для <code>recyclerView</code>. Ви можете здивуватись, як ми
                    збираємось посилатись на <code>recyclerView</code>, зпершу
                    не пошукавши елемент за допомогою <code>findViewById()</code>?
                    Проект був сконфігурований за допомогою плагіна <a href="https://kotlinlang.org/docs/tutorials/android-plugin.html"
                      target="_blank" sl-processed="1">Kotlin Android Extensions</a>.
                    Цей плагін дозволяє можливість імпортувати елементи в
                    розташуванні як “синтетичні” властивості. </p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.activity_main.*
</pre>
                  <p>Тепер <code>recyclerView</code> є розширеною властивостю
                    для <code>Activity</code>, та вона має той самий тип, як
                    декларовано в <code>activity_main.xml</code>. Плагін
                    видаляє багато зайвого коду, та зменьшує ризик потенційних
                    помилок.</p>
                  <p>Фаза запалювання завершена! Ви декларували та розмістили
                    пам'ять для двох частин пазла, що потрібні&nbsp;
                    RecyclerViews для роботи: самий RecyclerView та його Layout
                    Manager.</p>
                  <h2>Фаза запалювання 2: розташування для елементів
                    RecyclerView</h2>
                  <p>Друга фаза запалювання включає створення власного
                    розташування для елементів, що ви бажаєте використовувати в
                    вашому RecyclerView. Це робить так само, як це було, коли ви
                    створювали розташування для ListView або Gridview.</p>
                  <p>Прямуйте до вашої директорії розташувань, та створіть нове
                    розташування на ім'я <code>recyclerview_item_row</code>, та
                    встановіть кореневий елемент до <code>LinearLayout</code>.
                    В вашому наступному розташуванні додайте наступні XML
                    елементи як дітей до вашого LinearLayout:</p>
                  <pre class="language-xml hljs" lang="xml"><span class="hljs-tag">&lt;<span
class="hljs-name">ImageView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/itemImage"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"center"</span>
    <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">"8dp"</span>
    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"3"</span>
    <span class="hljs-attr">android:adjustViewBounds</span>=<span class="hljs-string">"true"</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/itemDate"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"top|start"</span>
    <span class="hljs-attr">android:layout_marginTop</span>=<span class="hljs-string">"8dp"</span>
    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span>
    <span class="hljs-attr">tools:text</span>=<span class="hljs-string">"Some date"</span> /&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">TextView</span>
    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/itemDescription"</span>
    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span>
    <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">"center|start"</span>
    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span>
    <span class="hljs-attr">android:ellipsize</span>=<span class="hljs-string">"end"</span>
    <span class="hljs-attr">android:maxLines</span>=<span class="hljs-string">"5"</span> /&gt;</span>
</pre>
                  <p>Це не космічна наука: ви створили декілька елементів як
                    дитяці до вашого розташування, які ви тепер можете
                    використати в вашому адаптері. </p>
                  <h2>Адаптери: ракетне паливо для вашого RecyclerView</h2>
                  <p>Клацніть правою кнопкою миші на вашому каталозі <em>com.raywenderlich.galacticon</em>,
                    оберіть <em>New \ Kotlin File/Class</em>, та назвіть його <em>RecyclerAdapter</em>
                    та обоеріть <em>Class</em> для Kind. Зверху файлу, під
                    декларацією <code>package</code>, імпортуйте бібліотеку
                    підтримки RecyclerView:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">import</span> android.support.v7.widget.RecyclerView
</pre>
                  <p>Зробіть клас розширенням <em>RecyclerView.Adapter</em>,
                    так, щоб він виглядав наступним чином:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-class"><span
class="hljs-keyword">class</span> <span class="hljs-title">RecyclerAdapter</span> : <span
class="hljs-type">RecyclerView.Adapter</span>&lt;<span class="hljs-type">RecyclerAdapter.PhotoHolder</span>&gt;</span>()  {
}
</pre>
                  <p>Android Studio здогадається, що ви розширюєте клас, що
                    потребує методів, та буде підкреслювати декларацію вашого
                    класу червоним. </p>
                  <p>Щоб вирішити це, клацніть на рядку коду щоб вставити ваш
                    курсор, потім натисніть <em>Option + Return</em> (або <em>Alt
                      + Enter</em> на PC), щоб отримати контекстне меню. Оберіть
                    <em>Implement Methods</em>:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/5-Implements-RecyclerView-Adapter-Methods-650x382.png"
                      alt="5" class="aligncenter size-large wp-image-170792" srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/5-Implements-RecyclerView-Adapter-Methods-650x382.png 650w, https://koenig-media.raywenderlich.com/uploads/2017/09/5-Implements-RecyclerView-Adapter-Methods-480x282.png 480w"
                      sizes="(max-width: 650px) 100vw, 650px" width="650" height="382"></p>
                  <p>Підтвердіть, що ви бажаєте реалізувати підказані методи, та
                    клацніть на <em>OK</em>:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/6-Confirm-RecyclerView-Implemention-Methods-650x381.png"
                      alt="" class="aligncenter size-large wp-image-170793" srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/6-Confirm-RecyclerView-Implemention-Methods-650x381.png 650w, https://koenig-media.raywenderlich.com/uploads/2017/09/6-Confirm-RecyclerView-Implemention-Methods-480x282.png 480w"
                      sizes="(max-width: 650px) 100vw, 650px" width="650" height="381"></p>
                  <p>Ці методи є рушійною силою позаду вашого адаптора
                    RecyclerView. Зауважте, що ви все ще маєте помилку
                    компілятора на цей момент – це тому, що ваш адаптер та
                    потрібні миетоди насправді визначені з ваикористанням класу
                    ViewHolder, <code>PhotoHolder</code>, що досі не існує. Ви
                    отримаєте ваш ViewHolder, та скорочено побачите, що робить
                    кожний з методів, так що тримайтесь, Командере!</p>
                  <p>Як з кожиним адаптером, вам треба запровадити відповідному
                    елементу спосіб заповнення свої поля, та вирішити, скількі
                    елементів загалом має бути.</p>
                  <p>Клацання по елементу раніше обороблялись ListView або
                    GridView в <code>onItemClickListener</code>. RecyclerView
                    не провадить методів як ці, оскільки він має єдине
                    призначення: переконатись, що елементи всередині правильно
                    позиційоновані, та керуються ефективно. </p>
                  <p>Робота по слуханню за діями тепер передана до елелмента
                    RecyclerView, та його дітей. Це може виглядати більше як
                    навантаження, але з іншого боку, ви отримуєте гарно
                    налаштований контроль над тим, як ваші дитячі елементи мають
                    діяти.</p>
                  <p>Зверху вашого класу RecyclerAdapter додайте змінну <code>photos</code>,
                    що міститиме ваші сввітлини в первинному конструкторі:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-class"><span
class="hljs-keyword">class</span> <span class="hljs-title">RecyclerAdapter</span></span>(<span
class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> photos: ArrayList&lt;Photo&gt;) RecyclerView.Adapter&lt;RecyclerAdapter.PhotoHolder&gt;() {
</pre>
                  <p>Гарна робота, Командер! Ваш адаптер тепер знає, де шукати
                    дані. Скоро ви отримаєте ArrayList зі світлин, з кращими
                    астрофотографіями! </p>
                  <p>Далі ви заповнюєте згенеровані методи, що були додані
                    Android Studio.</p>
                  <p>Перший метод, <code>getItemCount()</code>, є досить
                    простим, та має бути знайомий по вашій роботі з ListViews
                    або&nbsp; GridViews. </p>
                  <p>Адаптер буде визначати, скільки елементів відображувати. В
                    цьому випадку ми бажаємо, щоб адаптер показував кожне фото,
                    що ми завантажили з NASA API. Щоб зробити це, додайте
                    оновлення <code>getItemCount()</code> наступним чином:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">override</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getItemCount</span><span
class="hljs-params">()</span></span> = photos.size
</pre>
                  <p>Далі ми збираємось досліджувати шаблон <code>ViewHolder</code>,
                    щоб зробити об'єкт, що зберігає всі посилання на елементи
                    керування.</p>
                  <h2>Липучка для всіх: зберігання наших елементів керування</h2>
                  <p>Щоб створити <strong>PhotoHolder</strong> для посилання на
                    ваші елементи, ви створите вкладений клас в вашому адаптері.
                    Ви додасте його тут, замість ніж в окремому класі, оскільки
                    його поведінка близько пов'яззана з адаптером. Перше,
                    імпортуємо синтетичні властивості для ресайклера, так що ви
                    можете посилатись на властивості елементів:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">import</span> kotlinx.android.synthetic.main.recyclerview_item_row.view.*
</pre>
                  <p>Додайте наступний код в кінець класу RecyclerAdapter:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-comment">//1</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PhotoHolder</span></span>(v: View) : RecyclerView.ViewHolder(v), View.OnClickListener {
  <span class="hljs-comment">//2</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> view: View = v
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> photo: Photo? = <span
class="hljs-literal">null</span>

  <span class="hljs-comment">//3</span>
  init {
    v.setOnClickListener(<span class="hljs-keyword">this</span>)
  }

  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span
class="hljs-title">onClick</span><span class="hljs-params">(v: <span class="hljs-type">View</span>)</span></span> {
    Log.d(<span class="hljs-string">"RecyclerView"</span>, <span class="hljs-string">"CLICK!"</span>)
  }

  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-comment">//5</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> PHOTO_KEY = <span
class="hljs-string">"PHOTO"</span>
  }
}
</pre>
                  <p>Так що ми тут робимо? </p>
                  <ol>
                    <li>Робимо клас, що розширює RecyclerView.ViewHolder,
                      дозволяючи використовувати його як ViewHolder для
                      адаптера.</li>
                    <li>Додаємо посилання на життєвий цикл об'єкта, що дозволяє
                      ViewHolder підвішуватись до вашого View, так що він має
                      доступ до ImageView та TextView, як до розширених
                      властивостей. Плагін Kotlin Android Extensions додає
                      приховані функції та поля кешування, так що елементи не
                      запитуютсья кожного разу.</li>
                    <li>Ініціалізуємо <code>View.OnClickListener</code>.</li>
                    <li>Реалізуємо потрібіний метод для <code>View.OnClickListener</code>,
                      оскільки ViewHolder відповідальні за обробку власних
                      подій.</li>
                    <li>Додаємо ключ для простішого посилання на окремий
                      елемент, що був використаний для запуску RecyclerView.</li>
                  </ol>
                  <p>Ви все ще матимете помилки компілятора з методвами <code>onBindViewHolder</code>
                    та <code>onCreateViewHolder</code>. Змініть аргумент <code>holder:
                      ?</code> до <code>onBindViewHolder</code>, щоб він мав
                    тип <code>RecyclerAdapter.PhotoHolder</code>.</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">override</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onBindViewHolder</span><span
class="hljs-params">(holder: <span class="hljs-type">RecyclerAdapter</span>.<span
class="hljs-type">PhotoHolder</span>, position: <span class="hljs-type">Int</span>)</span></span> {
    TODO(<span class="hljs-string">"not implemented"</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span>
}
</pre>
                  <p>Тепер додайте тип значення <code>RecyclerAdapter.PhotoHolder</code>
                    до метода <code>onCreateViewHolder</code>, та видаліть
                    оператор безпечного виклику (тобто <code>?</code>) з типу
                    аргумента <code>parent</code>.</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">override</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onCreateViewHolder</span><span
class="hljs-params">(parent: <span class="hljs-type">ViewGroup</span>, viewType: <span
class="hljs-type">Int</span>)</span></span>: RecyclerAdapter.PhotoHolder {
    TODO(<span class="hljs-string">"not implemented"</span>) <span class="hljs-comment">//To change body of created functions use File | Settings | File Templates.</span>
 }
</pre>
                  <p>Тепер ви можете бути в змозі побудувати та виконати
                    застосування, але воно буде виглядати так само, оскільки ми
                    досі не сказали RecyclerView, як асоціювати PhotoHolder з
                    переглядом.</p>
                  <h2>Збираємо частини</h2>
                  <p>Іноді немає доступних ViewHolders. В такому сценарії
                    RecylerView буде викликати <code>onCreateViewHolder()</code>
                    з RecyclerAdapter, щоб створити такий. Ви будете
                    використовувати розташування елементу — PhotoHolder — щоб
                    створити перегляд для ViewHolder.</p>
                  <p>Код розташування може бути просто бути доданий до <code>onCreateViewHolder()</code>.
                    Однак, це гарна можливість показати дійсно круту можливість
                    Kotlin, що називається <a href="https://kotlinlang.org/docs/reference/extensions.html"
                      target="_blank" sl-processed="1">Розширення</a>. </p>
                  <p>Зпочатку, додайте новий файл Kotlin на ім'я <em>Extensions.kt</em>
                    до проекту, та потім додайте наступну нову функцію
                    розширення до цього файлу:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-function"><span
class="hljs-keyword">fun</span> ViewGroup.<span class="hljs-title">inflate</span><span
class="hljs-params">(<span class="hljs-meta">@LayoutRes</span> layoutRes: <span
class="hljs-type">Int</span>, attachToRoot: <span class="hljs-type">Boolean</span> = <span
class="hljs-literal">false</span>)</span></span>: View {
    <span class="hljs-keyword">return</span> LayoutInflater.from(context).inflate(layoutRes, <span
class="hljs-keyword">this</span>, attachToRoot)
}
</pre>
                  <p>Замістіть рядок <code>TODO("not implemented")</code> між
                    фігурними дужками в <code>onCreateViewHolder()</code> на
                    наступне:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">val</span> inflatedView = parent.inflate(R.layout.recyclerview_item_row, <span
class="hljs-literal">false</span>)
<span class="hljs-keyword">return</span> PhotoHolder(inflatedView)
</pre>
                  <p>Тут мі формуємо перегляд з розташування, та передаємо його
                    до PhotoHolder. Метод <code>parent.inflate(R.layout.recyclerview_item_row,
                      false)</code> буде виконувати нову функцію-розширення <code>ViewGroup.inflate(...)</code>,
                    щоб розмістити це розташування.</p>
                  <p>Та маючи це, ви вже зробили те, що об'єкти, які зберігають
                    ці посилання, будуть використані повторно, але є ще декілька
                    частин, які треба зтулити докупи, перед тим, як ви зможете
                    запустити вашу ракету.</p>
                  <p>Почнемо нову активність, через заміну журналу в ViewHolder
                    <code>onClick </code>цім кодом :</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">val</span> context = itemView.context
<span class="hljs-keyword">val</span> showPhotoIntent = Intent(context, PhotoActivity::<span
class="hljs-class"><span class="hljs-keyword">class</span>.<span class="hljs-title">java</span>)</span>
showPhotoIntent.putExtra(PHOTO_KEY, photo)
context.startActivity(showPhotoIntent)
</pre>
                  <p>Це захоплює поточний контекст вашого елементу перегляду, та
                    створює намір, щоб показати нову активність на екрані,
                    передаючи фото об'єкт, який ви бажаєте відобразити. Передача
                    об'єкту контекста в намір дозволяє застосуванню знати, яку
                    активність ми полишаємо. </p>
                  <p>Наступна річ, це додати наступний метод в <code>PhotoHolder</code>:
                  </p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-function"><span
class="hljs-keyword">fun</span> <span class="hljs-title">bindPhoto</span><span class="hljs-params">(photo: <span
class="hljs-type">Photo</span>)</span></span> {
  <span class="hljs-keyword">this</span>.photo = photo
  Picasso.with(view.context).load(photo.url).into(view.itemImage)
  view.itemDate.text = photo.humanDate
  view.itemDescription.text = photo.explanation
}
</pre>
                  <p>Це прикріплює фото до PhotoHolder, даючи вашому елементу
                    дані, що треба для з'ясування, що треба відображувати.</p>
                  <p>Це також додає рекомендований імпорт <a href="http://square.github.io/picasso/"
                      target="_blank" title="Picasso" sl-processed="1">Picasso</a>,
                    що є бібліотекою, яка значно спрощує отримання зображень по
                    певному URL.</p>
                  <p>Остання частина збірки PhotoHolder скаже йому, як
                    показувати правильне фото в правильний момент. Це
                    RecyclerAdapter <code>onBindViewHolder</code>, та він
                    дозволяє вам знати, коли новий елемент буде доступний на
                    екрані, та холдер потребує деяких даних.</p>
                  <p>Додамо наступний код в метод <code>onBindViewHolder()</code>:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">val</span> itemPhoto = photos[position]
holder.bindPhoto(itemPhoto)
</pre>
                  <p>Тут ви передаєте копію вашого ViewHolder та позицію, де
                    елемент буде показаний в вашому RecyclerView, та виклик <code>bindPhoto(...)</code>.</p>
                  <p>І це все, що вам треба зробити в цій збірці — просто
                    використовуйте позицію, де ваш ViewHolder буде з'являтись,
                    щоб захопити фото з вашого списку, та потім передати її до
                    ViewHolder. </p>
                  <p>Третій крок нашого протоколу перевірки до запуску
                    завершений!</p>
                  <h2>Відлік та відрив: пов'язуємо Adapter та RecyclerView</h2>
                  <p>Це тей момент, на який ми чекали, фінальна частина перед
                    запуском! Все що нам треба, це пов'язати ваш адаптер до
                    вашого RecyclerView, та переконатись, що він отримує фото,
                    коли він створений, так що ви можете досліджувати всесвіт —
                    по малюнках.</p>
                  <p>Відкрийте <em>MainActivity.kt</em>, та додайте цю
                    властивість в самому :</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> adapter: RecyclerAdapter
</pre>
                  <p>Далі, під присвоєнням до <code>recyclerView.layoutManager</code>
                    додайте наступне:</p>
                  <pre class="language-kotlin hljs" lang="kotlin">adapter = RecyclerAdapter(photosList)
recyclerView.adapter = adapter
</pre>
                  <p>Тут ми створюємо адаптер, передаючи його до конструкторів,
                    яких треба, та встановлюючи його як адаптер для вашого
                    RecyclerView. </p>
                  <p>Хоча адаптер і під'єднаний, існує ще одна річ, щоб
                    переконатись, що ми не матимемо пустий екран.</p>
                  <p>В <code>onStart()</code>, під викликом <code>super</code>
                    додаємо цей код, :</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">if</span> (photosList.size == <span
class="hljs-number">0</span>) {
  requestPhoto()
}
</pre>
                  <p>Це додає перевірку, чи не є ваш список порожнім, та якщо
                    так, він запитує фото.</p>
                  <p>Далі, в <code>receivedNewPhoto()</code>, оновіть метод,
                    так, щоб він виглядав наступним чином:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">override</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">receivedNewPhoto</span><span
class="hljs-params">(newPhoto: <span class="hljs-type">Photo</span>)</span></span> {
  runOnUiThread {
    photosList.add(newPhoto)
    adapter.notifyItemInserted(photosList.size)
  }
}
</pre>
                  <p>Тут ми інформуємо адаптер ресайклера, що елемент доданий
                    після того, як список фото був оновлений. </p>
                  <p>Тепер ви готові розпочати стартовий відлік.. тобто
                    запустити застосування. </p>
                  <p><em>Зпустіть застосування</em>, запустіть емулятор, та з
                    часом Galacticon повинен виглядати дещо подібне до цього:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/7-RecyclerView-Working-281x500.png"
                      alt="7. RecyclerView Working" class="aligncenter size-large wp-image-171028"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/7-RecyclerView-Working-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/7-RecyclerView-Working-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/7-RecyclerView-Working.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <p>Це не все. Тицьніть в фото, та ви повинні опинитись на
                    новій активності, що приймає цей елемент в фокусі:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/8-Focus-Activity-281x500.png"
                      alt="8. Focus Activity" class="aligncenter size-large wp-image-171029"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/8-Focus-Activity-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/8-Focus-Activity-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/8-Focus-Activity.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <p>Але це все ще не все! Спробуйте <em>повернути ваши
                      пристрій 'або емулятор</em> (function + control +
                    F11/F12), та ви побачите зображення на повному екрані!</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/9-Landscape-Focus-650x366.png"
                      alt="9. Landscape focus" class="aligncenter size-large wp-image-171030"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/9-Landscape-Focus-650x366.png 650w, https://koenig-media.raywenderlich.com/uploads/2017/09/9-Landscape-Focus-480x270.png 480w, https://koenig-media.raywenderlich.com/uploads/2017/09/9-Landscape-Focus-266x151.png 266w"
                      sizes="(max-width: 650px) 100vw, 650px" width="650" height="366"></p>
                  <p>В залежності від розміру зображення та екрана вашого
                    пристрою, це може виглядати дещо деформованим, але не
                    турбуйтесь про це.</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/stars_so_beautiful-320x320.png"
                      alt="" class="aligncenter size-medium wp-image-173047" srcset="https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-320x320.png 320w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-250x250.png 250w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful.png 500w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-32x32.png 32w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-50x50.png 50w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-64x64.png 64w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-96x96.png 96w, https://koenig-media.raywenderlich.com/uploads/2017/10/stars_so_beautiful-128x128.png 128w"
                      sizes="(max-width: 320px) 100vw, 320px" width="320" height="320"></p>
                  <p>Наші вітання! Ви маєте роблячий RecyclerView, та можете
                    робити ваші подорожі до зірок.</p>
                  <h2>Космічні кроки: додавання підтримки прокручування</h2>
                  <p>Якщо ви повернетесь до <em>MainActivity</em> на вашому
                    пристрої, та зпробуєте прокрутити донизу, ви побачите, що
                    вам дечого не вистачає — ваш&nbsp; RecyclerView не отримує
                    жодних нових фото.</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/10-Scrolling-Not-Working-281x500.png"
                      alt="10. Scrolling Not Working" class="aligncenter size-large wp-image-171032"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/10-Scrolling-Not-Working-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/10-Scrolling-Not-Working-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/10-Scrolling-Not-Working.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <p>Ваш RecyclerView робить точно як ви йому наказали,
                    показуючи вміст <code>photosList</code>. Проблема в тому,
                    що застосування буде отримуват лише одне фото, коли ви
                    заввантажуєте застосування. Воно не має і гадки, як отримати
                    більше фото.</p>
                  <p>Так що далі ми будемо отримувати декілька фото, та індекс
                    останнього фото при прогортуванні. Тепер ви перевірите, чи
                    останнє фото видиме, чи немає більше фото в запиті. Якщо
                    обоє дають true, тоді ваше застосування іде на сайт, та
                    завантажує більше гарних фото!</p>
                  <p>&nbsp;Ця латка буде потребувати космічної ходи, так що
                    розбивайте ваш скафандр, та налаштуйтесь отримати доствід
                    невагомості.</p>
                  <p>В <em>MainActivity.kt</em> додайте властівість з власним
                    асессором знизу MainActivity:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-keyword">val</span> lastVisibleItemPosition: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">get</span>() = linearLayoutManager.findLastVisibleItemPosition()
</pre>
                  <p>Це використовує ваш&nbsp;LinearLayoutManager з RecyclerView
                    для отримання індексу останнього видимого елементу на
                    екрані.</p>
                  <p>Далі ви додаєте метод, що вставляє <code>onScrollListener</code>в
                    ваш&nbsp; RecyclerView, так що ви отримуєте зворотній
                    виклик, коли користувач використовує прокрутку: </p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setRecyclerViewScrollListener</span><span
class="hljs-params">()</span></span> {
  recyclerView.addOnScrollListener(<span class="hljs-keyword">object</span> : RecyclerView.OnScrollListener() {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span
class="hljs-keyword">fun</span> <span class="hljs-title">onScrollStateChanged</span><span
class="hljs-params">(recyclerView: <span class="hljs-type">RecyclerView</span>?, newState: <span
class="hljs-type">Int</span>)</span></span> {
      <span class="hljs-keyword">super</span>.onScrollStateChanged(recyclerView, newState)
      <span class="hljs-keyword">val</span> totalItemCount = recyclerView!!.layoutManager.itemCount
      <span class="hljs-keyword">if</span> (!imageRequester.isLoadingData &amp;&amp; totalItemCount == lastVisibleItemPosition + <span
class="hljs-number">1</span>) {
        requestPhoto()
      }
    }
  })
}
</pre>
                  <p>Ця функція встановлює слухача прокрутки в RecyclerView, що
                    спрацьовує за дій користувача. Під час прокручування, слухач
                    отримує число елементів в LayoutManager, та обчислює індекс
                    останнього видимого фото. Коли це зроблене, він опрівнює ці
                    числа(збільшуючи індекс на 1, оскільки індекс починається з
                    0, тоді як лічильник починається з 1). Якщо вони
                    співпадають, та немає фото, що вже в запиті, тоді
                    викликається запит нового фото.</p>
                  <p>Нарешті, з'єднаємо все до RecyclerView, викликавши метод в
                    <code>onCreate</code>, прямо під тим, як ми встановили ваш
                    адаптер RecyclerView:</p>
                  <pre class="language-kotlin hljs" lang="kotlin">setRecyclerViewScrollListener()
</pre>
                  <p>Застрибуйте назад до космічного корабля (побудуйте та
                    запустіть застосування знову). Прокрутіть донизу, та ви
                    маєте побачити покращення!</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/11-Scrolling-Update-281x500.png"
                      alt="11. Scrolling Update" class="aligncenter size-large wp-image-171033"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/11-Scrolling-Update-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/11-Scrolling-Update-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/11-Scrolling-Update.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <p>Чудова робота, тепер ваш RecyclerView оновлюється, щоб
                    відобразити останні фото, запитані вашим застосуванням.
                    Велика річ в тому, що <code>receivedNewPhoto()</code>
                    обробляє більшість з роботи, оскільки ви сказали йому
                    повідомляти ваш адаптер щодо нових елементів. </p>
                  <p>Це додає інтергалактичних схвалень для ресайклінгу кода!</p>
                  <h2>Зміна розташування</h2>
                  <p>Тепер, коли ваш RecyclerView налаштований та робить, час
                    побавитись з вашим космічним кораблем. </p>
                  <p>Чи не було б це круто, якщо б RecyclerView міг змінювати
                    власне розташування? Гарна новина: позиціювання елементів
                    RecyclerView виділене в менеджер розташування.</p>
                  <p>Додайте властивість <em>GridLayoutManager</em> нагорі <em>MainActivity.kt</em>:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-keyword">lateinit</span> <span class="hljs-keyword">var</span> gridLayoutManager: GridLayoutManager
</pre>
                  <p>Зауважте, що GridLayoutManager є вбудованим менеджером
                    розташування, але це так саме гарно може бути ваш власний. </p>
                  <p>В <code>onCreate()</code> ініціалізуйте LayoutManager під
                    існуючим&nbsp; Linear Layout Manager:</p>
                  <pre class="language-kotlin hljs" lang="kotlin">gridLayoutManager = GridLayoutManager(<span
class="hljs-keyword">this</span>, <span class="hljs-number">2</span>)
</pre>
                  <p>Так само, як раніше ви робили з LayoutManager, ви передаєте
                    контекст, в якому менеджер має робити, але на відміну від
                    цього, він також приймає цілий параметр. В цьому випадку ви
                    встановлюєте число стовпчиків, що матиме решітка.</p>
                  <p>Додайте цей метод до MainActivity:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">changeLayoutManager</span><span
class="hljs-params">()</span></span> {
  <span class="hljs-keyword">if</span> (recyclerView.layoutManager == linearLayoutManager) {
    <span class="hljs-comment">//1</span>
    recyclerView.layoutManager = gridLayoutManager
    <span class="hljs-comment">//2</span>
    <span class="hljs-keyword">if</span> (photosList.size == <span class="hljs-number">1</span>) {
      requestPhoto()
    }
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">//3</span>
    recyclerView.layoutManager = linearLayoutManager
  }
}
</pre>
                  <p>Цей код перевіряє, який LayoutManager використовує ваш
                    RecyclerView, та потім: </p>
                  <ol>
                    <li>Якщо він використовує LinearLayoutManager, він
                      змінюється на GridLayoutManager</li>
                    <li>Він запитує нове фото, якщо ваша решітка відображує лише
                      одне фото</li>
                    <li>Якщо використовується GridLayoutManager, він
                      перемикається на LinearLayoutManager</li>
                  </ol>
                  <p>Далі вам треба зробити деякі зміни до <code>lastVisibleItemPosition</code>,
                    щоб допомогти обробці новому LayoutManager. Зробіть щоб він
                    виглядав приблизно так:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-keyword">val</span> lastVisibleItemPosition: <span class="hljs-built_in">Int</span>
  <span class="hljs-keyword">get</span>() = <span class="hljs-keyword">if</span> (recyclerView.layoutManager == linearLayoutManager) {
      linearLayoutManager.findLastVisibleItemPosition()
    } <span class="hljs-keyword">else</span> {
      gridLayoutManager.findLastVisibleItemPosition()
    }
</pre>
                  <p>Тут ми запитуємо RecyclerView повідомити вам, який його
                    LayoutManager, та потім запитуємо, що цей LayoutManager каже
                    щодо позиції останнього видимого елементу.</p>
                  <p>Щоб вімкнути розташування-решітку, використайте меню
                    Options, що вже доступне в вашому застосуванні. Додайте
                    наступний код після <code>onStart()</code>:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">override</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onOptionsItemSelected</span><span
class="hljs-params">(item: <span class="hljs-type">MenuItem</span>)</span></span>: <span
class="hljs-built_in">Boolean</span> {
  <span class="hljs-keyword">if</span> (item.itemId == R.id.action_change_recycler_manager) {
    changeLayoutManager()
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.onOptionsItemSelected(item)
}
</pre>
                  <p>Це перевіряє ID обраного елементу, та потім робить, що
                    треба зробити. В цьому випадку буде тільки один ID, який ми
                    перевіримо, що ефективно каже застосуванню піти та змінити
                    LayoutManager.</p>
                  <p>Та коли це вже є, ви готові до запуску! Завантажте
                    застосування, та клацніть на кнопці зверху зправа на екрані,
                    і маєте побачити, як зорі починають рухатись:</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/12-Grid-Layout-281x500.png"
                      alt="12. Grid Layout" class="aligncenter size-large wp-image-171037"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/12-Grid-Layout-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/12-Grid-Layout-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/12-Grid-Layout.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <h2>Вбивця зірок</h2>
                  <p>Sometimes you’ll see things you just don’t like the look
                    of, perhaps a galaxy far, far away that has fallen to the
                    dark side or a planet that is prime for destruction. How
                    could you go about killing it with a swipe?</p>
                  <p>Luckily, Android engineers have provided a useful class
                    named <code>ItemTouchHelper</code> that gives you easy
                    swipe behavior. Creating and attaching this to a
                    RecyclerView requires just a few lines of code.</p>
                  <p>In <em>MainActivity.kt</em>, underneath <code>setRecyclerViewScrollListener()</code>
                    add the following method:</p>
                  <pre class="language-kotlin hljs" lang="kotlin"><span class="hljs-keyword">private</span> <span
class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">setRecyclerViewItemTouchListener</span><span
class="hljs-params">()</span></span> {

  <span class="hljs-comment">//1</span>
  <span class="hljs-keyword">val</span> itemTouchCallback = <span class="hljs-keyword">object</span> : ItemTouchHelper.SimpleCallback(<span
class="hljs-number">0</span>, ItemTouchHelper.LEFT or ItemTouchHelper.RIGHT) {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span
class="hljs-keyword">fun</span> <span class="hljs-title">onMove</span><span class="hljs-params">(recyclerView: <span
class="hljs-type">RecyclerView</span>, viewHolder: <span class="hljs-type">RecyclerView</span>.<span
class="hljs-type">ViewHolder</span>, viewHolder1: <span class="hljs-type">RecyclerView</span>.<span
class="hljs-type">ViewHolder</span>)</span></span>: <span class="hljs-built_in">Boolean</span> {
      <span class="hljs-comment">//2</span>
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">override</span> <span class="hljs-function"><span
class="hljs-keyword">fun</span> <span class="hljs-title">onSwiped</span><span class="hljs-params">(viewHolder: <span
class="hljs-type">RecyclerView</span>.<span class="hljs-type">ViewHolder</span>, swipeDir: <span
class="hljs-type">Int</span>)</span></span> {
      <span class="hljs-comment">//3</span>
      <span class="hljs-keyword">val</span> position = viewHolder.adapterPosition
      photosList.removeAt(position)
      recyclerView.adapter.notifyItemRemoved(position)
    }
  }

  <span class="hljs-comment">//4</span>
  <span class="hljs-keyword">val</span> itemTouchHelper = ItemTouchHelper(itemTouchCallback)
  itemTouchHelper.attachToRecyclerView(recyclerView)
}
</pre>
                  <p>Let’s go through this step by step:</p>
                  <ol>
                    <li>You create the callback and tell it what events to
                      listen for. It takes two parameters, one for drag
                      directions and one for swipe directions, but you’re only
                      interested in swipe, so you pass 0 to inform the callback
                      not to respond to drag events.</li>
                    <li>You return false in <code>onMove</code> because you
                      don’t want to perform any special behavior here.</li>
                    <li><code>onSwiped</code> is called when you swipe an item
                      in the direction specified in the <code>ItemTouchHelper</code>.
                      Here, you request the <code>viewHolder</code> parameter
                      passed for the position of the item view, then you remove
                      that item from your list of photos. Finally, you inform
                      the RecyclerView adapter that an item has been removed at
                      a specific position.</li>
                    <li>You initialize the <code>ItemTouchHelper</code> with
                      the callback behavior you defined, and then attach it to
                      the RecyclerView.</li>
                  </ol>
                  <p>Add the method to the activity’s <code>onCreate()</code>,
                    underneath <code>setRecyclerViewScrollListener()</code>:</p>
                  <pre class="language-kotlin hljs" lang="kotlin">setRecyclerViewItemTouchListener()
</pre>
                  <p>This will attach the <code>ItemTouchListener</code> to the
                    RecyclerView using the code you just wrote.</p>
                  <p><em>Run the app</em> once more and <em>swipe across</em>
                    one of your items, you should see it begin to move. If you
                    swipe the item far enough, you should see it animate and
                    vanish. If other items are visible, then they will
                    reorganize themselves to cover the hole. How cool is that?</p>
                  <p><img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/13-Swipe-Away-Item-281x500.png"
                      alt="13 Swipe Away Item" class="aligncenter size-large wp-image-171038"
                      srcset="https://koenig-media.raywenderlich.com/uploads/2017/09/13-Swipe-Away-Item-281x500.png 281w, https://koenig-media.raywenderlich.com/uploads/2017/09/13-Swipe-Away-Item-180x320.png 180w, https://koenig-media.raywenderlich.com/uploads/2017/09/13-Swipe-Away-Item.png 1080w"
                      sizes="(max-width: 281px) 100vw, 281px" width="281" height="500"></p>
                  <h2>Where To Go From Here?</h2>
                  <div class="inline-video-ad" id="sub-banner-inline">
                    <div class="inline-video-ad-wrapper"> <a href="https://videos.raywenderlich.com/courses"
                        sl-processed="1">
                        <div class="col-wrapper">
                          <div class="col"> <img src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/video-yeti@2x.png"
                              alt="yeti holding videos"> </div>
                          <div class="col large-col"> <span>Want to learn even
                              faster? Save time with our <span>video courses</span></span>
                          </div>
                        </div>
                      </a> </div>
                  </div>
                  <p>Nice job! You’ve been on quite an adventure, but now it’s
                    time to head back to Earth and think about what you’ve
                    learned. </p>
                  <ul>
                    <li> You’ve created a RecyclerView and all the components it
                      needs, such as a LayoutManager, an Adapter and a
                      ViewHolder. </li>
                    <li> You’ve updated and removed items from an Adapter. </li>
                    <li> You’ve added some cool features like changing layouts
                      and adding swipe functionality. </li>
                  </ul>
                  <p>Above all, you’ve experienced how separation of components
                    — a key attribute of RecyclerViews — provides so much
                    functionality with such ease. If you want your collections
                    to be flexible and provide some excitement, then look no
                    further than the all-powerful RecyclerView.</p>
                  <p>The final project for this tutorial is available <a href="https://koenig-media.raywenderlich.com/uploads/2017/09/galacticon-final.zip"
                      sl-processed="1">here</a>.</p>
                  <p>If you want to learn more about RecyclerViews then check
                    out the <a href="http://developer.android.com/reference/android/support/v7/widget/RecyclerView.html"
                      target="_blank" title="Android documentation" sl-processed="1">Android
                      documentation</a> to see what it can do. Take a look at
                    the <a href="http://developer.android.com/tools/support-library/features.html#v7-recyclerview"
                      target="_blank" title="support library" sl-processed="1">support
                      library</a> for RecyclerViews to learn how to use it on
                    older devices. If you want to make them fit with the
                    material design spec then check out the <a href="https://www.google.com/design/spec/components/lists.html"
                      target="_blank" title="list component" sl-processed="1">list
                      component</a> design specification.</p>
                  <p>Join us in the forums to discuss this tutorial and your
                    findings as you work with RecylerViews!</p>
                  <p>Until next time, space traveler!</p>
                </div>
              </article>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="onesignal-bell-container" class="onesignal-bell-container onesignal-reset onesignal-bell-container-bottom-right">
    </div>
    <iframe id="rufous-sandbox" scrolling="no" allowtransparency="true" allowfullscreen="true"
      style="position: absolute; visibility: hidden; display: none; width: 0px; height: 0px; padding: 0px; border: none;"
      title="Twitter analytics iframe" src="./Android%20RecyclerView%20Tutorial%20with%20Kotlin_files/saved_resource%281%29.html"
      frameborder="0"></iframe>
  </body>
</html>
