<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__">Термінологія, поняття</h2>
<div class="sectionbody">
<div class="paragraph"><p>У цій главі ми намагаємося створити загальну термінологію, щоб визначити міцний грунт для спілкування про одночасні, розподілені системи, на які орієнтується Акка. Зверніть увагу, що для багатьох цих термінів не існує єдиного узгодженого визначення. Ми прагнемо дати робочі визначення, які будуть використані в рамках документації Akka.</p></div>
<div class="sect2">
<h3 id="___">Конкурентність проти паралелізму</h3>
<div class="paragraph"><p>Конкурентність і паралелізм є суміжними поняттями, але існують невеликі відмінності. Конкурентність означає, що два чи більше завдань досягають прогресу, хоча вони можуть не виконуватись одночасно. Наприклад, це може бути реалізовано за допомогою розподілу часу, коли частини завдань виконуються послідовно і змішуються з частинами інших завдань. З іншого боку, паралелізм виникає тоді, коли виконання може бути справді одночасним.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Асинхронний проти Синхронний</h3>
<div class="paragraph"><p>Виклик методу вважається синхронним, якщо абонент не може досягти прогресу, поки метод не поверне значення або не закине виняток. З іншого боку, асинхронний виклик дозволяє абоненту прогресувати після обмеженої кількості кроків, і про завершення методу може бути сигналізовано через якийсь додатковий механізм (це може бути зареєстрований зворотний виклик, <code>Future</code> або повідомлення).</p></div>
<div class="paragraph"><p>Синхронний API може використовувати блокування для реалізації синхронії, але це не є необхідністю. Дуже інтенсивне завантаження процесора може спричинити подібну поведінку, як блокування. Взагалі переважніше використовувати асинхронні API, оскільки вони гарантують, що система здатна прогресувати. Актори асинхронні за своєю суттю: актор може прогресувати після надсилання повідомлення, не чекаючи, коли відбудеться фактична доставка.</p></div>
</div>
<div class="sect2">
<h3 id="____3">Неблокування проти блокування</h3>
<div class="paragraph"><p>Ми говоримо про блокування, якщо затримка однієї нитки може невизначено затримувати деякі інші потоки. Хороший приклад - ресурс, який може використовуватися виключно одним потоком, використовуючи взаємне виключення. Якщо потік нескінченно тримається на ресурсі (наприклад, випадково запущений нескінченний цикл), інші потоки, що чекають на ресурсі, не можуть прогресувати. Навпаки, незаблокування означає, що жодна нитка не здатна безстроково затримувати інших.</p></div>
<div class="paragraph"><p>Неблокуючі операції мають перевагу над блокуючими, оскільки загальний прогрес системи не є тривіально гарантованим, коли він містить операції блокування.</p></div>
</div>
<div class="sect2">
<h3 id="______">Тупик проти голодування та живого блокування</h3>
<div class="paragraph"><p>Тупик виникає, коли кілька учасників чекають один одного, щоб досягти певного стану, щоб мати можливість прогресувати. Оскільки жоден з них не може прогресувати без іншого учасника, щоб досягти певного стану (проблема "Catch-22") всі дотичні підсистеми зупиняються. Тупик тісно пов'язаний з блокуванням, оскільки необхідно, щоб потік-учасник мав можливість затримувати просування інших потоків на невизначений термін.</p></div>
<div class="paragraph"><p>У випадку тупика жоден учасник не може досягти прогресу, тоді як, на відміну, під час голодування трапляється, коли є учасники, які можуть досягти прогресу, але може бути один або кілька, які не можуть. Типовим сценарієм є алгоритм наївного планування, який завжди вибирає завдання з високим пріоритетом над невисокими пріоритетними. Якщо кількість вхідних завдань з високим пріоритетом постійно буде достатньо великою, жодне з низько-пріоритетними завданнями не буде завершено.</p></div>
<div class="paragraph"><p>Livelock (живе блокування) схожий з тупиком, оскільки жоден з учасників не досягає успіху. Різниця, однак, полягає в тому, що замість того, щоб заморожуватися в стані очікування прогресування інших, учасники постійно змінюють свій стан. Приклад сценарію, коли двоє учасників мають два однакові ресурси. Кожен з них намагається отримати ресурс, але також перевіряє, чи потрібен інший ресурс. Якщо ресурс запитує інший учасник, він намагається отримати інший екземпляр ресурсу. У нещасному випадку може статися, що два учасники «стрибають» між двома ресурсами, ніколи не отримуючи його, завжди поступаючись іншому.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Стан гонки</h3>
<div class="paragraph"><p>Ми називаємо це умовою гонки, коли припущення про впорядкування набору подій можуть бути порушені зовнішніми недетермінованими ефектами. Умови перегонів часто виникають, коли кілька потоків мають загальний стан, що змінюється, і операції потоку над станом можуть бути переплетеними, викликаючи несподівану поведінку. Хоча це звичайний випадок, спільному стану не обов'язково мати перегони. Одним із прикладів може бути клієнт, який надсилає на сервер невпорядковані пакети (наприклад, дейтаграми UDP) P1, P2. Оскільки пакети можуть потенційно подорожувати різними мережевими маршрутами, можливо, сервер отримує спочатку P2 і P1 потім. Якщо повідомлення не містять інформації про їх порядок на відправку, серверу неможливо визначити, що вони були надіслані в іншому порядку. Залежно від значення пакетів це може спричинити перегони.</p></div>
<div class="paragraph"><p>Примітка: Єдина гарантія, яку Акка надає щодо повідомлень, що надсилаються між певною парою акторів, - це те, що їх порядок завжди зберігається. див. Надійність доставки повідомлень</p></div>
</div>
<div class="sect2">
<h3 id="____">Неблокуючі гарантії (умови прогресу)</h3>
<div class="paragraph"><p>Як було сказано в попередніх розділах, блокування небажано з кількох причин, включаючи небезпеку тупикових ситуацій та зменшення пропускної здатності в системі. У наступних розділах ми обговорюємо різні неблокуючі властивості з різною міцністю.</p></div>
<div class="sect3">
<h4 id="____4">Свобода від очікування</h4>
<div class="paragraph"><p>Метод не вимагає очікування, якщо гарантовано, що кожен виклик завершиться в кінцевій кількості кроків. Якщо метод обмежений без очікування, то кількість кроків має верхню межу.</p></div>
<div class="paragraph"><p>З цього визначення випливає, що методи без очікування ніколи не блокуються, тому тупик не може статися. Крім того, оскільки кожен учасник може прогресувати після обмеженої кількості кроків (коли закінчується виклик), методи, які не чекають, не мають голодувати.</p></div>
</div>
<div class="sect3">
<h4 id="____5">Свобода від блокування</h4>
<div class="paragraph"><p>Свобода від блокування - слабша властивість, ніж свобода від очікування. У випадку неблокуючих викликів, нескінченно часто якийсь метод закінчується у визначеній кількості кроків. Це визначення означає, що жодний глухий кут не можливий для викликів без блокування. З іншого боку, гарантії того, що деякі виклики закінчуються в кінцевій кількості кроків, недостатньо для того, щоб гарантувати, що всі вони врешті-решт закінчать. Іншими словами, свободи від блокування недостатньо, щоб гарантувати відсутність голодування.</p></div>
</div>
<div class="sect3">
<h4 id="____6">Свобода від перешкод</h4>
<div class="paragraph"><p>Свобода від перешкод - найслабша гарантія, що не блокує, яка обговорюється тут. Метод називається безперешкодним, якщо є момент часу, після якого він виконується ізольовано (інші потоки не роблять кроків, наприклад: стають призупиненими), і він закінчується обмеженою кількістю кроків. Усі об'єкти без блокувань не мають перешкод, але навпаки, як правило, не вірно.</p></div>
<div class="paragraph"><p>Методи оптимістичного контролю за одночасністю (OCC) зазвичай не мають перешкод. Підхід OCC полягає в тому, що кожен учасник намагається виконати свою операцію над спільним об'єктом, але якщо учасник виявляє конфлікти з боку інших, він скасовує модифікації та повторює спробу за певним графіком. Якщо є момент часу, коли один із учасників залишається наодинці в спробах, операція буде успішною.</p></div>
<div class="sect4">
<h5 id="___3">Рекомендована література</h5>
<div class="paragraph"><p>The Art of Multiprocessor Programming, M. Herlihy and N Shavit, 2008. ISBN 978-0123705914
Java Concurrency in Practice, B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes and D. Lea, 2006. ISBN 978-0321349606</p></div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___4">Системи акторів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Актори - це об'єкти, які інкапсулюють стан та поведінку, вони спілкуються виключно, обмінюючись повідомленнями, які розміщуються у поштовій скриньці одержувача. У певному сенсі актори є найсуворішою формою об’єктно-орієнтованого програмування, але це краще для їх розгляду як людей: моделюючи рішення з акторами, передбачте групу людей і призначте їм підзадачі, упорядкуйте їх функції в організаційну структуру і подумайте про те, як повідомляти про невдачу (все з вигодою насправді не мати стосунків з людьми, це означає, що нам не потрібно стосуватися їх емоційного стану чи моральних питань). Потім результат може слугувати розумовим підгрунтям для побудови програмного забезпечення.</p></div>
<div class="paragraph"><p>Примітка: <code>ActorSystem</code> - це важка структура, яка виділить 1… N потоків, тому створіть по одній в кожній логічній програмі.</p></div>
<div class="sect2">
<h3 id="___5">Ієрархічна структура</h3>
<div class="paragraph"><p>Як і в економічній організації, актори природно формують ієрархії. Один актор, який повинен контролювати певну функцію в програмі, може захотіти розділити своє завдання на більш дрібні, більш керовані частини. З цією метою він запускає дитячих акторів.</p></div>
<div class="paragraph"><p>Найважливішою особливістю систем акторів є те, що завдання розбиваються та делегуються до тих пір, поки вони не стануть досить маленькими, щоб їх можна було вирішувати одним складом. При цьому не тільки сама структура чітко структурована, але й отримані суб'єкти можна проміркувати, з точки зору того, які повідомлення вони оброблятимуть, як вони повинні нормально реагувати та як повинна оброблятись невдача.</p></div>
<div class="paragraph"><p>Порівняйте це з багатошаровим програмним забезпеченням, яке легко перетворюється на оборонне програмування з метою уникнути витіків жодних збоїв: якщо проблема буде донесена потрібній людині, можна знайти краще рішення, ніж якщо намагатися тримати все «під килимом».</p></div>
<div class="paragraph"><p>Тепер складність проектування такої системи полягає в тому, щоб вирішити, як структурувати роботу. Не існує єдиного найкращого рішення, але є кілька рекомендацій, які можуть бути корисними:</p></div>
<div class="ulist"><ul>
<li>
<p>
Якщо один актор несе в собі дуже важливі дані (тобто його стан не втрачається, якщо цього можна уникнути), цей актор повинен надсилати дітям будь-які можливі небезпечні підзадачі та обробляти недоліки цих дітей, якщо це необхідно. Залежно від характеру запитів, можливо, найкраще створити нову дитину для кожного запиту, що спрощує управління станом для збору відповідей. Це відоме як "шаблон Ядро помилки" від Erlang.
</p>
</li>
<li>
<p>
Якщо один актор залежить від іншого актора для виконання своїх обов'язків, він повинен стежити за життям іншого актора і діяти після отримання повідомлення про його припинення.
</p>
</li>
<li>
<p>
Якщо один актор має декілька обов'язків, кожну відповідальність часто можна перекласти на окрему дитину, щоб зробити логіку та стан більш простим.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="___6">Конфігурація контейнера</h3>
<div class="paragraph"><p>Система акторів, як колектив співпрацюючих акторів, є природним підрозділом для управління спільними об'єктами, такими як служби планування, конфігурація, ведення журналів тощо. Кілька акторських систем з різною конфігурацією можуть співіснувати в одному JVM без проблем, немає розподіленого загального стану У самій Akka. Однак, найпоширеніший сценарій передбачає лише єдину акторську систему на JVM.</p></div>
<div class="paragraph"><p>У поєднанні з прозорим зв’язком між акторськими системами - в межах одного вузла або через мережеве з'єднання - і акторські системи ідеально підходять для формування розподіленої програми.</p></div>
</div>
<div class="sect2">
<h3 id="_____2">Найкращі практики для актора</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Актори повинні бути схожими на приємних колег: виконувати свою роботу ефективно, не турбуючи всіх інших без потреби і уникаючи захоплення ресурсів. У перекладі мовою програмування це означає обробляти події та генерувати відповіді (або більше запитів) в залежності від подій. Актори не повинні блокувати (тобто пасивно чекати, займаючи <code>Thread</code>) на якусь зовнішню сутність - яка може бути блокуванням, мережевим сокетом тощо - якщо це не неминуче; в останньому випадку див. нижче.
</p>
</li>
<li>
<p>
Не передавайте змінні об'єкти між акторами. Щоб переконатися в цьому, віддайте перевагу незмінним повідомленням. Якщо інкапсуляція акторів порушена шляхом викриття їх зовнішнього стану зовні, ви повернетесь у звичайну землю Java конкуренції з усіма недоліками.
</p>
</li>
<li>
<p>
Актори стають контейнерами для поведінки та стану, застосування цього означає не передачу поведінки по колу в повідомленнях (що може бути спокусливим із застосуванням замикань Scala). Одним із ризиків є випадковий поділ змінного стану між акторами, і це порушення акторської моделі, на жаль, порушує всі властивості, які роблять програмування в стилі акторів таким приємним досвідом.
</p>
</li>
<li>
<p>
Актор системи вищого рівня - це найглибша частина вашого Ядра помилок, він повинен відповідати лише за запуск різних підсистем вашої програми, а не містити в собі багато логіки. Віддайте перевагу справді ієрархічним системам. Це має переваги щодо поводження з помилками (як з огляду на деталізацію конфігурації, так і на продуктивність), а також зменшує навантаження на актора опікуна, що є єдиною точкою відмови при надмірному використанні.
</p>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_____">Чим не варто себе турбувати</h3>
<div class="paragraph"><p>Система акторів керує ресурсами, які вона налаштована використовувати, для запуску акторів, які вона містить. У межах однієї такої системи може бути мільйони акторів, адже мантра розглядає їх як рясні, і вони важать лише біля 300 байт на екземпляр. Природно, точний порядок обробки повідомлень у великих системах не контролюється автором програми, але це також не передбачено. Зробіть крок назад і розслабтеся, поки Акка робить складну роботу за лаштунками.</p></div>
</div>
<div class="sect2">
<h3 id="__actorsystem">Зупинка ActorSystem</h3>
<div class="paragraph"><p>Коли ви знаєте, що ваша програма завершила роботу, ви можете зупинити актора опікуна користувача або викликати метод припинення <code>terminate</code> на <code>ActorSystem</code>. Це запустить <code>CoordinatedShutdown</code>, зупинивши всіх діючих акторів.</p></div>
<div class="paragraph"><p>Якщо ви хочете виконати деякі операції під час припинення <code>ActorSystem</code>, подивіться на <code>CoordinatedShutdown</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___actor">Що таке Actor?</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній розділ про Actor Systems пояснив, як актори формують ієрархії та є найменшою одиницею під час створення програми. Цей розділ розглядає одного такого актора ізольовано, пояснюючи концепції, з якими ви стикаєтесь під час його реалізації. Для більш детального ознайомлення з усіма подробицями зверніться до Вступу до акторів.</p></div>
<div class="paragraph"><p>Модель актора, визначена Хьюїттом, Бішопом та Штейгером у 1973 році, - це обчислювальна модель, яка виражає саме те, що означає розподіл обчислень. Одиниці обчислень - Актори - можуть спілкуватися лише за допомогою обміну повідомленнями та після отримання повідомлення Актор може виконати такі три основні дії:</p></div>
<div class="ulist"><ul>
<li>
<p>
надсилати обмежену кількість повідомлень акторам, яких він знає
</p>
</li>
<li>
<p>
створити скінчену кількість нових акторів
</p>
</li>
<li>
<p>
визначити поведінку, яку слід застосувати до наступного повідомлення
</p>
</li>
</ul></div>
<div class="paragraph"><p>Актор є контейнером для стану, поведінки, поштової скриньки, дитячих акторів та стратегії супервайзера. Все це інкапсульовано за посиланням на актора. Одним із важливих аспектів є те, що актори мають чіткий життєвий цикл, вони не руйнуються автоматично, коли на них більше не посилаються; після того, як ви створили актора, ви несете відповідальність за те, щоб він врешті-решт був припинений - що також дає вам контроль над тим, як вивільняються ресурси, коли актор припиняється.</p></div>
<div class="sect2">
<h3 id="____7">Посилання на актора</h3>
<div class="paragraph"><p>Як детально описано нижче, об’єкт актора потрібно захистити зовні, щоб мати користь від акторської моделі. Тому актори представлені назовні з використанням акторських посилань, які є предметами, які можна передавати  навколо вільно і без обмежень. Цей поділ на внутрішній та зовнішній об'єкт забезпечує прозорість для всіх бажаних операцій: перезапуск актора без необхідності оновлювати посилання в іншому місці, розміщення фактичного об’єкта актора на віддалених хостах, надсилання повідомлень акторам незалежно від місця їх запуску. Але найважливіший аспект полягає в тому, що неможливо зазирнути всередину актора і оволодіти його станом зовні, якщо тільки актор нерозумно не опублікує цю інформацію сам.</p></div>
<div class="paragraph"><p>Посилання акторів параметризовані і на них можуть надсилатися лише повідомлення, що мають вказаний тип.</p></div>
</div>
<div class="sect2">
<h3 id="_">Стан</h3>
<div class="paragraph"><p>Об'єкти актора, як правило, містять деякі змінні, які відображають можливі стани, в яких може бути актор. Це може бути явна машина стану, або це лічильник, набір слухачів, очікувані запити тощо. Ці дані роблять актора цінним, і вони повинні бути захищені від ушкодження іншими суб'єктами. Гарна новина полягає в тому, що в акторів Akka концептуально кожен має власну легку нитку, яка повністю захищена від решти системи. Це означає, що замість того, щоб синхронізувати доступ за допомогою блокувань, ви можете написати свій акторський код, не турбуючись про конкурентність.</p></div>
<div class="paragraph"><p>За лаштунками Акка запустить набори акторів на наборах реальних ниток, де зазвичай багато акторів поділяють одну нитку, і наступні виклики одного актора можуть в кінцевому підсумку оброблятися в різних потоках. Akka гарантує, що ця деталізація не впливає на одно-поточність керування станом актора.</p></div>
<div class="paragraph"><p>Оскільки внутрішній стан є життєво важливим для діяльності актора, наявність непослідовного стану є фатальним. Таким чином, коли актор зазнає невдачі і перезапущений його супервізором, стан буде створений з нуля, як при першому створенні актора. Це для того, щоб забезпечити можливість самолікування системи.</p></div>
<div class="paragraph"><p>За бажанням стан актора можна автоматично відновити до стану перед перезапуском, зберігаючи отримані повідомлення та відтворюючи їх після перезавантаження (див. Відновлення подій).</p></div>
</div>
<div class="sect2">
<h3 id="__2">Поведінка</h3>
<div class="paragraph"><p>Щоразу, коли повідомлення обробляється, воно співвідноситься з поточною поведінкою актора. Поведінка означає функцію, яка визначає дії, які слід здійснити у відповідь на повідомлення в певний момент часу. Скажімо, переадресувати запит, якщо клієнт авторизований, і відмовити якщо ні. Така поведінка може змінюватися з часом, напр. тому що різні клієнти отримують дозвіл з часом або тому, що актор може перейти в режим «не обслуговується» і пізніше повернутися. Ці зміни досягаються шляхом кодування їх у змінних стану, які зчитуються з логіки поведінки. Або сама функція може бути замінена під час виконання, повертаючи іншу поведінку, яка буде використана для наступного повідомлення. Однак початкова поведінка, визначена під час побудови об’єкта актора, є особливою в тому сенсі, що перезапуск актора скине його поведінку до цієї початкової.</p></div>
<div class="paragraph"><p>Повідомлення можуть бути надіслані на посилання актора, і за цим фасадом є поведінка, яка отримує повідомлення та діє на його основі. Зв'язок між посиланням на Актора і поведінкою може змінюватися з часом, але це не помітно зовні.</p></div>
<div class="paragraph"><p>Посилання акторів параметризовані і на них можуть надсилатися лише повідомлення, що мають вказаний тип. Асоціація між посиланням на актора та його типом параметра повинна бути зроблена, коли створюється посилання на актора (та самого Актора). Для цього кожна поведінка також параметризується типом повідомлень, які вона здатна обробляти. Оскільки поведінка може змінюватися за фасадом посилання актора, позначення наступної поведінки є обмеженою операцією: наступник повинен обробляти той же тип повідомлень, що і його попередник. Це необхідно для того, щоб не визнати недійсними посилання, які посилаються на цього Актора.</p></div>
<div class="paragraph"><p>Це дозволяє зробити те, що щоразу, коли повідомлення надсилається Акторові, ми можемо статистично переконатися, що тип повідомлення є таким, яким Актор заявляє, що обробляє - ми можемо уникнути помилки надсилання абсолютно безглуздих повідомлень. Однак ми не можемо статично забезпечити, що поведінка, що стоїть за посиланням на актора, буде в заданому стані, коли буде отримано наше повідомлення. Принципова причина полягає в тому, що зв'язок між посиланням актора та поведінкою є властивістю динамічного виконання, компілятор не може цього знати, перекладаючи вихідний код.</p></div>
<div class="paragraph"><p>Це те саме, що і для звичайних об'єктів Java з внутрішніми змінними: при компілюванні програми ми не можемо знати, яке буде їх значення, і якщо результат виклику методу залежить від цих змінних, то результат певною мірою непевний - ми можемо лише бути впевненим, що повернене значення має заданий тип.</p></div>
<div class="paragraph"><p>Тип повідомлення відповіді команди Actor описується типом посилання актора для відповіді, що міститься в повідомленні. Це дозволяє описувати розмову за її типами: відповідь буде типу A, але вона також може містити адресу типу B, яка потім дозволяє іншому Актору продовжувати розмову, надсилаючи повідомлення типу B на це нове посилання. Хоча ми не можемо статично виразити "поточний" стан Актора, ми можемо виразити поточний стан протоколу між двома Акторами, оскільки це просто задається останнім типом повідомлення, яке було отримано або надіслано.</p></div>
</div>
<div class="sect2">
<h3 id="___7">Поштова скринька</h3>
<div class="paragraph"><p>Метою актора є обробка повідомлень, і ці повідомлення надсилаються актору від інших акторів (або ззовні акторської системи). Частина, яка з'єднує відправника та одержувача, - це поштова скринька актора: у кожного актора є рівно одна поштова скринька, до якої всі відправники передають свої повідомлення. Виємка відбувається в порядку виконання операцій надсилання, що означає, що повідомлення, надіслані різними суб'єктами, можуть не мати визначеного порядку під час виконання через очевидну випадковість розподілу акторів по потоках. Відправлення декількох повідомлень до однієї і тієї ж цілі від одного актора, з іншого боку, призведе до впорядкованої доставки.</p></div>
<div class="paragraph"><p>Можна вибрати різні варіанти поштової скриньки, за замовчуванням - FIFO: порядок повідомлень, оброблених актором, відповідає порядку, в якому вони були введені. Зазвичай це хороший стандарт за замовчуванням, але програмам, можливо, доведеться розставити пріоритет одних повідомлень над іншими. У такому випадку поштова скринька з пріоритетом буде ставити в чергу не завжди в кінці, але в позиції, визначеній пріоритетом повідомлення, яка може бути навіть спереду. Під час використання такої черги порядок оброблюваних повідомлень, природно, визначатиметься алгоритмом черги і це, загалом, не FIFO.</p></div>
<div class="paragraph"><p>Важливою особливістю, за якою Akka відрізняється від деяких інших реалізацій моделей актора, є те, що поточна поведінка завжди повинна обробляти наступне відмінене повідомлення, не існує сканування поштової скриньки для пошуку наступного. Відмова обробляти повідомлення, як правило, трактується як збій, якщо тільки ця поведінка не буде відмінена.</p></div>
</div>
<div class="sect2">
<h3 id="___8">Дитячі актори</h3>
<div class="paragraph"><p>Кожен актор потенційно є батьком: якщо він створює дітей для делегування підзадач, він автоматично контролює їх. Список дітей підтримується в контексті актора, і актор має доступ до нього. Зміни списку здійснюються відгалуженням або зупиненням дітей, і ці дії відображаються негайно. Фактичні дії по створенню та припиненню відбуваються за кадром асинхронно, тому вони не «блокують» свого батька.</p></div>
</div>
<div class="sect2">
<h3 id="___9">Стратегія супервізора</h3>
<div class="paragraph"><p>Остання частина актора - це його стратегія поводження з несподіваними винятками - невдачами. Обробка невдачі прозоро виконується Акка, застосовуючи одну з стратегій, описаних у "Толерантності відмов" для кожної відмови.</p></div>
</div>
<div class="sect2">
<h3 id="____8">Коли Актор припиняється</h3>
<div class="paragraph"><p>Після того, як актор припиняється, тобто відмовляє таким чином, що не обробляє перезапуск, зупиняється сам або зупиняється його супервізором, він звільнить свої ресурси, витягнувши всі повідомлення, що залишилися зі своєї поштової скриньки, у «поштову скриньку мертвих листів» системи, яка пересилатиме їх у <code>EventStream</code> як <code>DeadLetters</code>. Потім поштову скриньку замінюють у посиланні актора на системну поштову скриньку, перенаправляючи всі нові повідомлення на <code>EventStream</code> як <code>DeadLetters</code>. Однак це робиться з найкращих зусиль, тому не покладайтеся на це, щоб побудувати «гарантовану доставку».</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____9">Нагляд та моніторинг</h2>
<div class="sectionbody">
<div class="paragraph"><p>У цій главі викладено поняття, що стоїть за наглядом, запропоновані примітиви та їх семантика. Для отримання детальної інформації про те, як це перетворюється в реальний код, зверніться до нагляду.</p></div>
<div class="paragraph"><p>Нагляд змінився від класичного, детальніше про класичний нагляд див. у Класичному нагляді</p></div>
<div class="sect2">
<h3 id="____10">Що означає нагляд</h3>
<div class="paragraph"><p>Є дві категорії винятку, які можуть статися у актора:</p></div>
<div class="ulist"><ul>
<li>
<p>
Помилки перевірки введення, очікувані винятки, які можна обробляти звичайним <code>try</code>-<code>catch</code> або іншими інструментами мови та стандартної бібліотеки.
</p>
</li>
<li>
<p>
Несподівані збої, наприклад, недоступний мережевий ресурс, помилка запису диска або, можливо, помилка в логіці програми.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Нагляд має справу з відмовами, і його слід відокремлювати від бізнес логіки, тоді як перевірка даних та обробка очікуваних винятків є важливою частиною бізнес-логіки. Тому нагляд додається до актора як декорація, а не щось, що переплітається з логікою обробки актора.</p></div>
<div class="paragraph"><p>Залежно від характеру роботи, що підлягає нагляду, та характеру відмови, нагляд передбачає наступні три стратегії:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Відновіть актора, зберігаючи його накопичений внутрішній стан
</p>
</li>
<li>
<p>
Перезапуск актора, очистивши його накопичений внутрішній стан, з можливою затримкою, починаючи заново
</p>
</li>
<li>
<p>
Зупинка актора назавжди
</p>
</li>
</ol></div>
<div class="paragraph"><p>Оскільки актори є частиною ієрархії, часто може мати сенс поширювати постійні невдачі вгору. Якщо всі діти актора несподівано зупинилися, може мати сенс перезапустити або зупинити самого актора, щоб повернутись до функціонального стану. Цього можна досягти за допомогою поєднання спостереження та нагляду за дітьми, щоб отримувати сповіщення про їх припинення. Приклад цього можна знайти в Просування збоїв вгору по ієрархії.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____11">Актори вищого рівня</h2>
<div class="sectionbody">
<div class="paragraph"><p>Акторська система під час її створення запустить щонайменше двох акторів.</p></div>
<div class="paragraph"><p><code>/user</code>: користувацькій актор-охоронець
Це актор, який надає користувач верхнього рівня, призначений для завантаження програми за допомогою відгалуження підсистем у якості дітей. Коли охоронець користувача зупиняється, вся система акторів вимикається.</p></div>
<div class="paragraph"><p><code>/system</code>: системний актор-охоронець
Цей спеціальний охоронець був введений для того, щоб досягти впорядкованої послідовності вимкнення, коли ведення журналу залишається активним, поки всі нормальні актори припиняються. Навіть незважаючи на те, що реєстрація журналу здійснюється за допомогою акторів. Це реалізується наявністю системного охоронця, що спостерігає за користувацьким охоронцем, і ініціює своє власне відключення після того, коли побачив, що охоронець користувача зупинився.</p></div>
<div class="sect2">
<h3 id="____12">Що означає перезапуск</h3>
<div class="paragraph"><p>Якщо представлені актором, який зазнав невдачі під час обробки певного повідомлення, причини відмови поділяються на три категорії:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Систематичні (тобто програмні) помилки для конкретного отриманого повідомлення
</p>
</li>
<li>
<p>
(Тимчасовий) збій якогось зовнішнього ресурсу, який використовується під час обробки повідомлення
</p>
</li>
<li>
<p>
Зруйнований внутрішній стан актора
</p>
</li>
</ol></div>
<div class="paragraph"><p>Якщо відмова конкретно не визначається, третю причину не можна виключати, що призводить до висновку, що внутрішній стан потрібно зачистити. Якщо супервізор вирішить, що його інші діти або він сам не стали жертвою руйнування, тобто через свідоме застосування схеми ядра помилок - тоді краще перезапустити актора. Це здійснюється шляхом створення нового екземпляра базового класу поведінки та заміни невдалого екземпляра свіжим у дитячому <code>ActorRef</code>; можливість зробити це є однією з причин інкапсуляції акторів у спеціальні посилання. Потім новий актор поновлює обробку своєї поштової скриньки, що означає, що перезапуск не помітно поза межами самого актора, за винятком того, що повідомлення, під час якого сталася помилка, не буде оброблятися повторно.</p></div>
</div>
<div class="sect2">
<h3 id="______2">Що означає моніторинг життєвого циклу</h3>
<div class="paragraph"><p>Примітка: Моніторинг життєвого циклу в Akka зазвичай називають DeathWatch</p></div>
<div class="paragraph"><p>На відміну від описаних вище особливих відносин між батьком і дитиною, кожен актор може контролювати будь-якого іншого актора. Оскільки актори виходять із створення повністю живими, а перезавантаження не видно за межами дотичних супервізорів, єдиною зміною стану, доступною для моніторингу, є перехід від живих до мертвих. Таким чином, моніторинг використовується для прив’язки одного актора до іншого, щоб він міг реагувати на припинення іншого актора, на відміну від нагляду, який реагує на збій.</p></div>
<div class="paragraph"><p>Моніторинг життєвого циклу реалізується за допомогою повідомлення про припинення, яке має отримати актор моніторингу. Поведінка за замовченням полягає у викиданні спеціального <code>DeathPactException</code>, якщо не оброблено іншим шляхом. Для того, щоб почати прослуховувати повідомлення <code>Terminated</code>, викликте <code>ActorContext.watch(targetActorRef)</code>. Щоб перестати слухати, запустіть <code>ActorContext.unwatch(targetActorRef)</code>. Важливою властивістю є те, що повідомлення буде доставлено незалежно від порядку, в якому відбувається запит моніторингу та припинення роботи цільового актора. Тобто ви все одно отримаєте повідомлення, навіть якщо на момент реєстрації ціль уже загинула.</p></div>
</div>
<div class="sect2">
<h3 id="____13">Актори та винятки</h3>
<div class="paragraph"><p>Може трапитися так, що під час обробки актором повідомлення закидається  якийсь виняток, наприклад виняток із бази даних.</p></div>
<div class="sect3">
<h4 id="_____3">Що відбувається з повідомленням</h4>
<div class="paragraph"><p>Якщо виняток буде викинуто під час обробки повідомлення (тобто вийнято з поштової скриньки та передано поточній поведінці), це повідомлення буде втрачено. Важливо розуміти, що воно не повертається назад на поштову скриньку. Тож, якщо ви хочете спробувати обробити повідомлення, вам потрібно розібратися з ним самостійно, перехопивши виняток і повторивші дії знову. Переконайтеся, що ви обмежили кількість повторних спроб, оскільки не хочете, щоб система перейшла в живе блокування (витрачаючи багато процесорних циклів без прогресу).</p></div>
</div>
<div class="sect3">
<h4 id="______3">Що відбувається з поштовою скринькою</h4>
<div class="paragraph"><p>Якщо під час обробки повідомлення закидається виняток, з поштовою скринькою нічого не відбувається. Якщо актор перезапущений, там буде та сама поштова скринька. Тож усі повідомлення в цій поштовій скриньці також будуть збережені.</p></div>
</div>
<div class="sect3">
<h4 id="_____4">Що відбувається з актором</h4>
<div class="paragraph"><p>Якщо код в рамках актора кидає виняток, цей актор призупиняється, і починається процес нагляду. Залежно від рішення супервізора, актор відновлюється (ніби нічого не сталося), перезапускається (затираючи свій внутрішній стан і починаючи з нуля) або припиняється.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="______4">Посилання акторів, шляхи та адреси</h2>
<div class="sectionbody">
<div class="paragraph"><p>У цій главі описано, як ідентифікуються та розміщуються актори в можливо розподіленій програмі Akka.</p></div>
<div class="imageblock">
<div class="content">
<img src="actor-paths-overview.png" alt="actor-paths-overview.png" />
</div>
</div>
<div class="paragraph"><p>Наведене вище зображення відображає взаємозв'язок між найважливішими сутностями в акторській системі. Будь ласка, прочитайте деталі.</p></div>
<div class="sect2">
<h3 id="______5">Що таке посилання на актора</h3>
<div class="paragraph"><p>Посилання на актора - це підтип <code>ActorRef</code>, головна мета якого - підтримка надсилання повідомлень актору, якого він представляє. Кожен актор має доступ до свогої канонічного (локального) посилання через поле <code>ActorContext.self</code>; це посилання може бути включене у повідомлення іншим учасникам, щоб отримати відповіді.</p></div>
<div class="paragraph"><p>Існує кілька різних типів посилань на акторів, які підтримуються залежно від конфігурації акторської системи:</p></div>
<div class="ulist"><ul>
<li>
<p>
Суто локальні посилання акторів використовуються акторськими системами, які не налаштовані на підтримку мережевих  функцій. Ці посилання актора не працюватимуть, якщо вони надсилаються через мережеве з'єднання до віддаленої JVM.
</p>
</li>
<li>
<p>
Локальні посилання на акторів при включеному віддаленні використовуються акторськими системами, які підтримують функції мережі для тих посилань, які представляють суб'єктів у межах одного JVM. Щоб вони також були доступні при надсиланні до інших вузлів мережі, ці посилання включають інформацію про протокол та віддалену адресацію.
</p>
</li>
<li>
<p>
Віддалені посилання акторів представляють суб'єктів, доступних за допомогою віддаленого зв'язку, тобто надсилання до них повідомлень прозоро серіалізує повідомлення та надсилатиме їх у віддалену JVM.
</p>
</li>
<li>
<p>
Існує кілька спеціальних типів посилань на акторів, які поводяться як місцеві акторські посилання для всіх практичних цілей:
</p>
<div class="ulist"><ul>
<li>
<p>
<code>PromiseActorRef</code> - це спеціальне представлення Обіцянки з метою завершення відповіді актора. <code>akka.pattern.ask</code> створює це посилання на актора.
</p>
</li>
<li>
<p>
<code>DeadLetterActorRef</code> - це реалізація за замовчуванням служби листів з мертвими листами, на яку Акка пересилає всі повідомлення, пункти призначення яких вимкнено або відсутні.
</p>
</li>
<li>
<p>
<code>EmptyLocalActorRef</code> - це те, що Акка повертає, шукаючи неіснуючий локальний шлях актора: він еквівалентний DeadLetterActorRef, але він зберігає свій шлях, щоб Акка міг пересилати його по мережі та порівнювати його з іншими існуючими посиланнями актора для цього шляху , деякі з яких могли бути отримані до смерті актора.
</p>
</li>
</ul></div>
</li>
<li>
<p>
Нарешті потім є кілька разових внутрішніх реалізацій, які ви ніколи не повинні бачити:
</p>
<div class="ulist"><ul>
<li>
<p>
Є посилання на актора, яке не представляє актора, а виступає лише псевдонаглядачем за кореневим охоронцем, ми називаємо його "тим, хто ходить бульбашками простору-часу".
</p>
</li>
<li>
<p>
Перша послуга ведення журналу, запущена до фактичного запуску засобів створення акторів, є несправжнім посиланням на актора, яка приймає події журналу та друкує їх безпосередньо на стандартний вихід; це <code>Logging.StandardOutLogger</code>.
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_____5">Що таке Акторський шлях?</h3>
<div class="paragraph"><p>Оскільки актори створені суворо ієрархічно, існує унікальна послідовність імен акторів, що задаються рекурсивно, дотримуючись зв'язків нагляду між дитиною та батьком вниз до кореня акторської системи. Ця послідовність може розглядатися як вкладання папок у файловій системі, отже, ми прийняли назву “шлях” для посилання на неї, хоча ієрархія акторів має деяку принципову відмінність від ієрархії файлової системи.</p></div>
<div class="paragraph"><p>Шлях актора складається з якоря, який ідентифікує акторську систему з наступним конкатенацією елементів шляху, від кореня-охоронця до призначеного актора; елементи шляху - це імена пройдених акторів, розділені косою рисою.</p></div>
<div class="sect3">
<h4 id="_______">Яка різниця між посиланням актора та шляхом?</h4>
<div class="paragraph"><p>Посилання актора позначає одного актора, а життєвий цикл посилання відповідає життєвому циклу актора; шлях актора являє собою ім'я, яке може бути або не бути існуючим актором, а сам шлях не має життєвого циклу, він ніколи не стає недійсним. Ви можете створити акторський шлях без створення актора, але ви не можете створити посилання на актора, не створивши відповідного актора.</p></div>
<div class="paragraph"><p>Ви можете створити актора, припинити його, а потім створити нового актора з тим самим акторським шляхом. Новостворений актор - це нове втілення актора. Це не той самий актор. Посилання актора на старе втілення не є дійсним для нового втілення. Повідомлення, надіслані до старої посилання актора, не будуть доставлені до нового втілення, навіть якщо вони мають однаковий шлях.</p></div>
</div>
<div class="sect3">
<h4 id="____14">Якорі акторського шляху</h4>
<div class="paragraph"><p>Кожен шлях актора має адресний компонент, що описує протокол і місце, за якими досяжний відповідний актор, а потім імена акторів в ієрархії від кореня вгору. Приклади:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>"akka://my-sys/user/service-a/worker1"               // чисто локальний
"akka://my-sys@host.example.com:5678/user/service-b" // віддалений</code></pre>
</div></div>
<div class="paragraph"><p>Інтерпретація частини хоста та порту (тобто <code>host.example.comwhat678</code> у прикладі) залежить від використовуваного транспортного механізму, але він повинен дотримуватися структурних правил URI.</p></div>
</div>
<div class="sect3">
<h4 id="____15">Логічні акторські шляхи</h4>
<div class="paragraph"><p>Унікальний шлях, отриманий при дотриманні посилань батьківського нагляду до кореневого опікуна, називається логічним акторським шляхом. Цей шлях точно відповідає походженню створення актора, тому він повністю детермінований, як тільки встановлюється конфігурація віддаленої акторської системи (а разом з нею і адресна складова шляху).</p></div>
</div>
<div class="sect3">
<h4 id="_______2">Псевдонім акторського шляху або символічне посилання?</h4>
<div class="paragraph"><p>Як і в деяких реальних файлових системах, ви можете думати про "псевдонім шляху" або "символічне посилання" для актора, тобто один актор може бути доступний, використовуючи більше одного шляху. Однак слід зазначити, що ієрархія акторів відрізняється від ієрархії файлової системи. Ви не можете вільно створювати акторські шляхи, як символічні зв'язки для посилання на довільних акторів.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="______6">Як отримуються посилання на актора?</h3>
<div class="paragraph"><p>Існує дві загальні категорії, як можна отримати посилання на акторів: створивши акторів або переглянувши їх через <code>Receptionist</code>.</p></div>
</div>
<div class="sect2">
<h3 id="______7">Посилання актора та рівність шляху</h3>
<div class="paragraph"><p>Рівність <code>ActorRef</code> відповідає наміру того, що <code>ActorRef</code> відповідає втіленню цільового актора. Два посилання актора вважаються рівними, коли вони мають однаковий шлях і вказують на одне втілення актора. Посилання, що вказує на припиненого актора, не порівнюється як рівне з посиланням, що вказує на іншого (відтвореного) актора з тим самим шляхом. Зауважте, що перезапуск актора, спричинений невдачею, все ще означає, що це те саме втілення актора, тобто перезапуск не помітний для споживача <code>ActorRef</code>.</p></div>
<div class="paragraph"><p>Якщо вам потрібно відслідковувати посилання на акторів у колекції та не піклуватися про точне втілення актора, ви можете використовувати <code>ActorPath</code> як ключ, оскільки ідентифікатор цільового актора не враховується при порівнянні шляхів актора.</p></div>
</div>
<div class="sect2">
<h3 id="_____6">Повторне використання акторських шляхів</h3>
<div class="paragraph"><p>Коли актора припиняють, його посилання вказуватиме на поштову скриньку мертвих листів, <code>DeathWatch</code> опублікує свій остаточний перехід, і взагалі не очікується, що він знову оживе (оскільки життєвий цикл актора не дозволяє цього).</p></div>
</div>
<div class="sect2">
<h3 id="______8">Для чого використовується адресна частина?</h3>
<div class="paragraph"><p>При надсиланні посилання на актора через мережу це відображається шляхом. Отже, шлях повинен повністю кодувати всю інформацію, необхідну для надсилання повідомлень до відповідного актора. Це досягається за допомогою протоколу кодування, хоста та порту в адресній частині рядка шляху. Коли система актора отримує шлях актора від віддаленого вузла, вона перевіряє, чи відповідає адреса цього шляху адресі поточної акторської системи, і в такому випадку вона буде вирішена місцевим посиланням актора. В іншому випадку вона буде представлена ​​віддаленим посиланням на актора.</p></div>
</div>
<div class="sect2">
<h3 id="_______3">Області вищого рівня для акторських шляхів</h3>
<div class="ulist"><ul>
<li>
<p>
В корені шляху ієрархії знаходиться кореневий опікун, над яким знаходяться всі інші суб'єкти; її назва <code>"/"</code>. Наступний рівень складається з наступного:
</p>
</li>
<li>
<p>
<code>"/user"</code> є актором-опікуном для всіх створених користувачем акторів вищого рівня; актори, створені за допомогою ActorSystem.actorOf, знаходяться нижче цього.
<code>"/system "</code> є актором-опікуном для всіх створених системою акторів вищого рівня, напр. реєстрація слухачів або акторів автоматично розгортається за конфігурацією на початку роботи системи акторів.
</p>
</li>
<li>
<p>
<code>"/deadLetters"</code>- це актор мертвих листів, куди переадресовуються всі повідомлення, надіслані зупиненим або неіснуючим акторам,  (за найкращих зусиль: повідомлення можуть втрачатися навіть у локальній JVM).
</p>
</li>
<li>
<p>
<code>"/temp"</code> є опікуном для всіх короткочасних створених системою акторів, напр. ті, які використовуються при впровадженні <code>ActorRef.ask</code>.
</p>
</li>
<li>
<p>
<code>"/remote"</code> - це штучний шлях, під яким проживають усі актори, супервізорами яких є віддалені посилання на акторів
</p>
</li>
</ul></div>
<div class="paragraph"><p>Необхідність структурувати простір імен для акторів на кшталт цього виникає з центральної та дуже простої розробницької мети: все в ієрархії - це актор, і всі актори функціонують однаково.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="___10">Прозорість місцеположення</h2>
<div class="sectionbody">
<div class="paragraph"><p>У попередньому розділі описано, як використовуються шляхи акторів для забезпечення прозорості місцеположення. Ця особливість заслуговує на додаткове пояснення, оскільки відповідний термін «прозоре віддалення» використовувався зовсім по-різному в контексті мов програмування, платформ та технологій.</p></div>
<div class="sect2">
<h3 id="____16">Розподілення за замовчуванням</h3>
<div class="paragraph"><p>Все в Akka покликане працювати в розподіленій обстановці: усі взаємодії акторів використовують суто передачу повідомлень, і все є асинхронним. Ці зусилля були зроблені для того, щоб усі функції були доступні однаково під час роботи в одній JVM або на кластері з сотні машин. Ключовим моментом для цього є перехід від віддаленого до локального шляхом оптимізації, а не намагання перейти від локального до віддаленого шляхом узагальнення. Дивіться <a href="https://doc.akka.io/docs/misc/smli_tr-94-29.pdf">https://doc.akka.io/docs/misc/smli_tr-94-29.pdf</a> [цей класичний документ] для детальної дискусії про те, чому другий підхід приречений на невдачу.</p></div>
</div>
<div class="sect2">
<h3 id="______9">Шляхи, в яких прозорість порушена</h3>
<div class="paragraph"><p>Що стосується Akka, не обов'язково повинно бути правдою для програми, яка його використовує, оскільки проектування для розподіленого виконання створює деякі обмеження щодо можливого. Найбільш очевидним є те, що всі повідомлення, що надсилаються по дроту, повинні бути серійними.</p></div>
<div class="paragraph"><p>Інший наслідок полягає в тому, і всі повинні бути попереджені, що всі взаємодії є повністю асинхронними, що в комп'ютерній мережі може означати, що щоб дістатися до свого одержувача повідомленню може знадобитись декілька хвилин (залежно від конфігурації). Це також означає, що ймовірність втратити повідомлення набагато вище, ніж у межах однієї JVM, де воно близьке до нуля (ще раз: жодної жорсткої гарантії!).</p></div>
</div>
<div class="sect2">
<h3 id="_peer_to_peer_vs_client_server">Peer-to-Peer vs. Client-Server</h3>
<div class="paragraph"><p>Akka Remoting - це комунікаційний модуль для підключення акторських систем вузол-вузол, і це основа для кластеризації Akka. Дизайн віддалення керується двома (пов'язаними) розробницькими рішеннями:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Зв'язок між залученими системами є симетричним: якщо система A може підключитися до системи B, тоді система B також повинна мати можливість підключитися до системи A незалежно.
</p>
</li>
<li>
<p>
Роль систем зв'язку є симетричною щодо моделей з'єднання: немає системи, яка приймає тільки з'єднання, і немає системи, яка тільки ініціює з'єднання.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Наслідком цих рішень є те, що неможливо безпечно створити чисті схеми клієнт-сервер із заздалегідь визначеними ролями (порушує припущення 2). Для налаштувань клієнт-сервер краще використовувати HTTP або Akka I/O.</p></div>
<div class="paragraph"><p>Важливо: Використання налаштувань, що включають трансляцію мережевих адрес, завантажувальних балансирів або контейнерів Docker, порушує припущення 1, якщо не буде зроблено додаткових кроків у конфігурації мережі, щоб дозволити симетричний зв’язок між залученими системами. У таких ситуаціях Akka може бути налаштований на прив’язку до іншої мережевої адреси, ніж та, яка використовується для встановлення з'єднань між вузлами Akka. Дивіться <a href="https://doc.akka.io/docs/akka/current/remoting-artery.html#remote-configuration-nat-artery">Akka за NAT або в контейнері Docker</a>.</p></div>
</div>
<div class="sect2">
<h3 id="________">Позначення точок для збільшення масштабів за допомогою маршрутизаторів</h3>
<div class="paragraph"><p>Окрім того, що можна запускати різні частини акторської системи на різних вузлах кластеру, також можна масштабувати на більше ядер, примноживши суб-дерева актора, які підтримують паралелізацію (подумайте, наприклад, про пошукову систему, що обробляє різні запити в паралельно). Потім клони можуть бути спрямовані за деяким принципом, наприклад, по колу. Детальнішу інформацію див. У розділі <a href="https://doc.akka.io/docs/akka/current/typed/routers.html">Маршрутизація</a>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_akka_____java">Akka та модель пам'яті Java</h2>
<div class="sectionbody">
<div class="paragraph"><p>Основна перевага використання платформи Lightbend, включаючи Scala та Akka, полягає в тому, що вона спрощує процес написання конкурентного програмного забезпечення. У цій статті йдеться про те, як платформа Lightbend і зокрема Akka підходять до спільної пам’яті в паралельних програмах.</p></div>
<div class="sect2">
<h3 id="____java">Модель пам'яті Java</h3>
<div class="paragraph"><p>До Java 5 модель пам'яті Java (JMM) була погано визначена. Можна було отримати всілякі дивні результати, коли до спільної пам'яті було доступно декілька потоків, таких як:</p></div>
<div class="ulist"><ul>
<li>
<p>
потік не бачить значень, записаних іншими потоками: проблема видимості
</p>
</li>
<li>
<p>
нитка спостерігає за "неможливою" поведінкою інших потоків, викликана тим, що вказівки не виконуються в очікуваному порядку: проблема перестановки інструкцій.
</p>
</li>
</ul></div>
<div class="paragraph"><p>З впровадженням JSR 133 на Java 5 багато з цих питань було вирішено. JMM - це сукупність правил, заснованих на відношенні "трапляється раніше", які обмежують, коли один доступ до пам'яті повинен відбуватися перед іншим, і навпаки, коли їм дозволяється відбуватися поза порядком. Два приклади цих правил:</p></div>
<div class="ulist"><ul>
<li>
<p>
Правило блокування монітора: звільнення блокування відбувається перед кожним наступним захопленням одного і того ж блокування.
</p>
</li>
<li>
<p>
Правило мінливої змінної: запис мінливої змінної відбувається перед кожним наступним читанням тієї самої змінної.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Хоча JMM може здатися складним, специфікація намагається знайти баланс між простотою використання та можливістю записувати продуктивні та масштабовані паралельні структури даних.</p></div>
</div>
<div class="sect2">
<h3 id="______java">Актори та модель пам'яті Java</h3>
<div class="paragraph"><p>З реалізацією Actor в Akka, існує два способи, коли декілька потоків можуть виконувати дії над спільною пам'яттю:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Якщо повідомлення надіслано актору (наприклад, іншому актору). У більшості випадків повідомлення є незмінними, але якщо це повідомлення не є належним чином сконструйованим незмінним об'єктом, без правила «відбувається раніше», одержувач міг би бачити частково ініціалізовані структури даних та, можливо, навіть значення з повітря.
</p>
</li>
<li>
<p>
Якщо актор вносить зміни до свого внутрішнього стану під час обробки повідомлення та отримує доступ до цього стану, обробляючи інше повідомлення через кілька хвилин. Важливо усвідомити, що за допомогою акторської моделі ви не отримуєте жодної гарантії того, що однакова нитка буде виконувати одного і того ж актора для різних повідомлень.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Щоб запобігти проблем видимості та перепорядкувати проблеми для акторів, Акка гарантує наступні два правила «відбувається раніше»:</p></div>
<div class="ulist"><ul>
<li>
<p>
Правило надсила1ння актора: надсилання повідомлення актору відбувається до отримання цього повідомлення тим самим актором.
</p>
</li>
<li>
<p>
Правило подальшої обробки актора: обробка одного повідомлення відбувається перед обробкою наступного повідомлення тим самим актором.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Примітка: В термінах перехожого це означає, що зміни внутрішніх полів актора видно, коли наступне повідомлення обробляється цим актором. Тож поля у вашого актора не повинні бути мінливими або еквівалентними.</p></div>
<div class="paragraph"><p>Обидва правила застосовуються лише для одного екземпляра актора та не дійсні, якщо використовуються різні суб'єкти.</p></div>
</div>
<div class="sect2">
<h3 id="_______java">Ф'ючерси та модель пам'яті Java</h3>
<div class="paragraph"><p>Завершення <code>Future</code> «відбувається раніше» виклику усіх зареєстрованих до нього зворотних викликів.</p></div>
<div class="paragraph"><p>Ми рекомендуємо не робити замикань над нефінальними полями (<code>final</code> в Java та <code>val</code> у Scala), і якщо ви вирішите замикатись над нефінальними полями, вони повинні бути позначені <code>volatile</code>, щоб поточне значення поля було видиме до зворотного виклику.</p></div>
<div class="paragraph"><p>Якщо ви замикаєте посилання, ви також повинні переконатися, що екземпляр, на який посилається, є безпечним для потоків. Ми настійно рекомендуємо триматися подалі від об'єктів, які використовують блокування, оскільки це може спричинити проблеми з роботою та, в гіршому випадку, тупики. Такі небезпеки <code>synchronized</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_______4">Актори та спільний стан, що змінюється</h3>
<div class="paragraph"><p>Оскільки Akka працює на JVM, є ще деякі правила, яких слід дотримуватися.</p></div>
<div class="paragraph"><p>Найголовніше, що ви не повинні замикатись на внутрішній стан актора і не розголошувати його іншим потокам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyActor</span><span class="o">(</span><span class="n">context</span><span class="k">:</span> <span class="kt">ActorContext</span><span class="o">[</span><span class="kt">MyActor.Command</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">AbstractBehavior</span><span class="o">[</span><span class="kt">MyActor.Command</span><span class="o">](</span><span class="n">context</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">MyActor._</span>

  <span class="k">var</span> <span class="n">state</span> <span class="k">=</span> <span class="s">&quot;&quot;</span>
  <span class="k">val</span> <span class="n">mySet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">String</span><span class="o">]()</span>

  <span class="k">def</span> <span class="n">onMessage</span><span class="o">(</span><span class="n">cmd</span><span class="k">:</span> <span class="kt">MyActor.Command</span><span class="o">)</span> <span class="k">=</span> <span class="n">cmd</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Message</span><span class="o">(</span><span class="n">text</span><span class="o">,</span> <span class="n">otherActor</span><span class="o">)</span> <span class="k">=&gt;</span>
<span class="cm">/*</span>
<span class="cm">  Дуже погано: загальний змінний об&#39;єкт дозволяє іншим акторам змінювати ваш стан, або ще гірше, ви можете отримати збочені умови гонки</span>
<span class="cm"> */</span>
      <span class="n">otherActor</span> <span class="o">!</span> <span class="n">mySet</span>

      <span class="k">implicit</span> <span class="k">val</span> <span class="n">ec</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">executionContext</span>
<span class="cm">/*</span>
<span class="cm">  Приклад некоректного підходу. Дуже погано: загальний змінний стан спричинить криві помилки застосування</span>
<span class="cm"> */</span>
      <span class="nc">Future</span> <span class="o">{</span> <span class="n">state</span> <span class="k">=</span> <span class="s">&quot;This will race&quot;</span> <span class="o">}</span>
<span class="cm">/*</span>
<span class="cm">  Приклад некоректного підходу. Дуже погано: загальний змінний стан спричинить криві помилки застосування</span>
<span class="cm"> */</span>
      <span class="n">expensiveCalculation</span><span class="o">().</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
        <span class="n">state</span> <span class="k">=</span> <span class="s">s&quot;new state: </span><span class="si">$result</span><span class="s">&quot;</span>
      <span class="o">}</span>
<span class="cm">/*</span>
<span class="cm">  Приклад коректного підходу. Перетворіть результат фьючерса в повідомлення, що надсилається самому собі, коли фьючерс завершується</span>
<span class="cm"> */</span>
      <span class="k">val</span> <span class="n">futureResult</span> <span class="k">=</span> <span class="n">expensiveCalculation</span><span class="o">()</span>
      <span class="n">context</span><span class="o">.</span><span class="n">pipeToSelf</span><span class="o">(</span><span class="n">futureResult</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UpdateState</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="k">throw</span> <span class="n">ex</span>
      <span class="o">}</span>
<span class="cm">/*</span>
<span class="cm">  Інший приклад некоректного підходу, зміна стану актора зі зворотнього виклику фьючерса ask</span>
<span class="cm"> */</span>
      <span class="k">import</span> <span class="nn">akka.actor.typed.scaladsl.AskPattern._</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mf">5.</span><span class="n">seconds</span><span class="o">)</span> <span class="c1">// треба для `ask` нижче</span>
      <span class="k">implicit</span> <span class="k">val</span> <span class="n">scheduler</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">scheduler</span>
      <span class="k">val</span> <span class="n">future</span><span class="k">:</span> <span class="kt">Future</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">otherActor</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="nc">Query</span><span class="o">)</span>
      <span class="n">future</span><span class="o">.</span><span class="n">foreach</span> <span class="o">{</span> <span class="n">result</span> <span class="k">=&gt;</span>
        <span class="n">state</span> <span class="k">=</span> <span class="n">result</span>
      <span class="o">}</span>
<span class="cm">/*</span>
<span class="cm">  Замість цього використовуйте context.ask, що обертає завершення в повідомлення собі</span>
<span class="cm"> */</span>
      <span class="n">context</span><span class="o">.</span><span class="n">ask</span><span class="o">(</span><span class="n">otherActor</span><span class="o">,</span> <span class="nc">Query</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UpdateState</span><span class="o">(</span><span class="n">result</span><span class="o">)</span>
        <span class="k">case</span> <span class="nc">Failure</span><span class="o">(</span><span class="n">ex</span><span class="o">)</span>     <span class="k">=&gt;</span> <span class="k">throw</span> <span class="n">ex</span>
      <span class="o">}</span>
      <span class="k">this</span>

    <span class="k">case</span> <span class="nc">UpdateState</span><span class="o">(</span><span class="n">newState</span><span class="o">)</span> <span class="k">=&gt;</span>
<span class="cm">/*</span>
<span class="cm"> Безпечно, доки `newState` незмінне, якщо воно змінне потребує безпечної копії</span>
<span class="cm"> */</span>
      <span class="n">state</span> <span class="k">=</span> <span class="n">newState</span>
      <span class="k">this</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Повідомлення повинні бути незмінними, щоб уникнути пастки спільного стану, що змінюється.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="____17">Надійність доставки повідомлень</h2>
<div class="sectionbody">
<div class="paragraph"><p>Akka допомагає вам створювати надійні програми, які використовують декілька ядер процесора в одній машині ("масштабування вгору") або розподіляються по комп'ютерній мережі ("масштабування назовні"). Основна абстракція цієї роботи полягає в тому, що всі взаємодії між вашими кодовими одиницями - акторами - відбуваються при передачі повідомлення, тому точна семантика передачі повідомлень між учасниками заслуговує на власну главу.</p></div>
<div class="paragraph"><p>Для того, щоб дати деякий контекст обговоренню нижче, розгляньте додаток, який охоплює декілька хостів мережі. Основний механізм комунікації - той самий, чи надсилання актору на локальну JVM або віддаленому виконавцю, але спостерігатимуться відмінності у затримці доставки (можливо, також залежно від пропускної здатності мережевого зв’язку та розміру повідомлення) і надійність. У разі віддаленого надсилання повідомлення є більше кроків, що означає, що більше може піти не так. Інший аспект полягає в тому, що локальне надсилання передасть посилання на повідомлення всередині того ж JVM без будь-яких обмежень на базовий об'єкт, який надсилається, тоді як віддалений транспорт буде обмежувати розмір повідомлення.</p></div>
<div class="paragraph"><p>Написати своїх акторів таким чином, щоб кожна взаємодія могла бути віддаленою - це безпечна, песимістична ставка. Це означає покладатися лише на ті властивості, які завжди гарантовані та про які детально йде мова нижче. Це має певний наклад у виконанні актора. Якщо ви готові пожертвувати повною прозорістю розташування (наприклад, у випадку групи тісно співпрацюючих акторів), ви можете розміщувати їх завжди в одній JVM і отримувати більш жорсткіші гарантії щодо доставки повідомлень. Деталі цього компромісу обговорюються далі.</p></div>
<div class="paragraph"><p>В якості додаткової частини ми наводимо кілька вказівок на те, як створити більшу надійність зверху вбудованої. Розділ закривається, обговорюючи роль "Офісу мертвих листів".</p></div>
<div class="sect2">
<h3 id="___11">Загальні правила</h3>
<div class="paragraph"><p>Це правила для надсилання повідомлень (тобто метод <code>tell</code> або <code>!</code>, який також лежить в основі шаблону запиту <code>ask</code>):</p></div>
<div class="paragraph"><p><strong>щонайбільше одноразова доставка</strong>, тобто не гарантована доставка</p></div>
<div class="paragraph"><p><strong>впорядкування повідомлень на пару відправника та одержувача</strong></p></div>
<div class="paragraph"><p>Перше правило, як правило, зустрічається і в інших реалізаціях акторів, тоді як друге характерне для Akka.</p></div>
<div class="sect3">
<h4 id="______10">Обговорення: Що означає "максимум одноразово"?</h4>
<div class="paragraph"><p>Що стосується опису семантики механізму доставки, то існує три основні категорії:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>щонайбільше одноразова доставка</strong> означає, що для кожного повідомлення, переданого механізму, це повідомлення доставляється один раз або взагалі не доставляється; у більш простих виразах це означає, що повідомлення можуть бути втрачені.
</p>
</li>
<li>
<p>
<strong>щонайменше одноразова доставка</strong> означає, що для кожного повідомлення, переданого механізму, можливе кілька спроб його доставки, таким чином, щоб принаймні одна була успішною; знову ж таки, у більш простих виразах це означає, що повідомлення можуть дублюватися, але не втрачатися.
</p>
</li>
<li>
<p>
<strong>рівно одноразова доставка</strong> означає, що для кожного повідомлення, переданого механізму, рівно одна доставка здійснюється одержувачу; повідомлення не можна ні втрачати, ні дублювати.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Перша - найдешевша - найвища продуктивність, найменше накладні витрати - тому що це можна зробити в режимі підпалити-та-забуття, не підтримуючи стан на кінці відправлення або в транспортному механізмі. Друге вимагає повторних спроб для протидії транспортним втратам, що означає збереження стану на кінці відправлення та наявність механізму підтвердження на кінці прийому. Третій є найдорожчим - і, отже, найгіршим показником - тому що, крім другого, він вимагає утримувати стан на кінці прийому, щоб відфільтрувати повторювані доставки.</p></div>
</div>
<div class="sect3">
<h4 id="______11">Обговорення: Чому немає гарантованої доставки?</h4>
<div class="paragraph"><p>В основі проблеми лежить питання, що саме означає ця гарантія:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Повідомлення надсилається в мережу?
</p>
</li>
<li>
<p>
Інший хост отримує повідомлення?
</p>
</li>
<li>
<p>
Повідомлення поміщається в поштову скриньку цільового актора?
</p>
</li>
<li>
<p>
Повідомлення починає оброблятися цільовим актором?
</p>
</li>
<li>
<p>
Повідомлення успішно оброблено цільовим актором?
</p>
</li>
</ol></div>
<div class="paragraph"><p>Кожен з них має різні проблеми та витрати, і очевидно, що існують умови, за яких будь-яка бібліотека, що передає повідомлення, не змогла б виконати; подумайте, наприклад, про настроювані типи поштових скриньок та про те, як обмежена поштова скринька взаємоділа б із третьім пунктом, або навіть, що означатиме вирішення питання про частину «успішно» п’ятої позиції.</p></div>
<div class="paragraph"><p>За цим же принципом йде міркування у "Ніхто не потребує надійного обміну повідомленнями". Єдиний змістовний спосіб відправника дізнатись, чи взаємодія була успішною - це отримання повідомлення про підтвердження бізекс рівня, яке Акка не може скласти самостійно (а також ми не пишемо фреймворк "зроби, що я маю на увазі", і ви не бажаєте щоб ми цім займались).</p></div>
<div class="paragraph"><p>Акка охоплює розподілені обчислення та робить помилковість спілкування явною при передачі повідомлення, тому не намагається брехати та імітувати протікаючу абстракцію. Це модель, яка з великим успіхом застосовується в Erlang і вимагає від користувачів проектувати свої програми навколо неї. Детальніше про цей підхід ви можете прочитати в документації Erlang (розділи 10.9 та 10.10), Акка уважно дотримується цього.</p></div>
<div class="paragraph"><p>Іншим моментом у цьому питанні є те, що, надаючи лише основні гарантії, ті випадки використання, які не потребують більш високої надійності, не платять витрати на їх реалізацію. Завжди можна додати більш високу надійність поверх базової, але неможливо ретро-активно видалити надійність для отримання більшої продуктивності.</p></div>
</div>
<div class="sect3">
<h4 id="____18">Обговорення: Впорядкування повідомлень</h4>
<div class="paragraph"><p>Правило конкретніше полягає в тому, що для певної пари дійових осіб повідомлення, що надсилаються безпосередньо від першого до другого, не будуть надходити поза порядком. Слово безпосередньо підкреслює, що ця гарантія застосовується лише при надсиланні оператором <code>tell</code> до кінцевого пункту призначення, а не при використанні посередників або інших функцій поширення повідомлень (якщо не вказано інше).</p></div>
<div class="paragraph"><p>Гарантія проілюстрована наступним чином:</p></div>
<div class="ulist"><ul>
<li>
<p>
Актор А1 надсилає повідомлення M1, M2, M3 до A2
</p>
</li>
<li>
<p>
Актор A3 надсилає повідомлення M4, M5, M6 до A2
</p>
</li>
</ul></div>
<div class="paragraph"><p>Це означає що:</p></div>
<div class="ulist"><ul>
<li>
<p>
Якщо M1 доставлений, він повинен бути доставлений до M2 та M3
</p>
</li>
<li>
<p>
Якщо M2 доставлений, він повинен бути доставлений до M3
</p>
</li>
<li>
<p>
Якщо M4 доставлений, він повинен бути доставлений до M5 та M6
</p>
</li>
<li>
<p>
Якщо M5 доставлений, він повинен бути доставлений до M6
</p>
</li>
<li>
<p>
A2 може бачити повідомлення від A1, переплетені з повідомленнями від A3
</p>
</li>
<li>
<p>
Оскільки немає гарантованої доставки, будь-яке повідомлення може бути відхилене, тобто не надходити на A2
</p>
</li>
</ul></div>
<div class="paragraph"><p>Примітка: Важливо зазначити, що гарантія Akka поширюється на порядок введення повідомлень у поштову скриньку одержувача. Якщо реалізація поштової скриньки не дотримується домовленості FIFO (наприклад, <code>PriorityMailbox</code>), то порядок обробки актором може відхилятися від порядку замовлення.</p></div>
<div class="paragraph"><p>Зауважте, що це правило не є транзитивним:</p></div>
<div class="ulist"><ul>
<li>
<p>
Актор A надсилає повідомлення актору С1 M1
</p>
</li>
<li>
<p>
Актор А потім надсилає повідомлення актору В2 M2
</p>
</li>
<li>
<p>
Актор В передає актору С повідомлення М2
</p>
</li>
<li>
<p>
Актор C може приймати М1 і М2 в будь-якому порядку
</p>
</li>
</ul></div>
<div class="paragraph"><p>Транзитивне впорядкування означало б, що M2 ніколи не отримується до M1 в акторі C (хоча будь-яке з них може бути загублене). Це впорядкування може бути порушено через різні затримки доставки повідомлень, коли A, B і C знаходяться на різних мережевих хостах, див. докладніше нижче.</p></div>
<div class="paragraph"><p>Примітка: Створення актора трактується як повідомлення, яке надсилається від батька дитині, з тією ж семантикою, що обговорена вище. Надіслати повідомлення актору таким чином, який можна було б упорядкувати за допомогою цього початкового повідомлення про створення, означає, що повідомлення може не надходити, оскільки актор ще не існує. Прикладом, коли повідомлення може надходити занадто рано, було б створити віддалений розгорнутий актор R1, надіслати його посиланням на інший віддалений актор R2 і змусити R2 відправити повідомлення на R1. Прикладом чітко визначеного впорядкування є батько, який створює актора і негайно надсилає йому повідомлення.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____19">Повідомлення про відмову</h3>
<div class="paragraph"><p>Зауважте, що обговорені вище гарантії впорядкування стосуються лише користувацьких повідомлень між акторами. Невдача дитини-актора повідомляється спеціальними системними повідомленнями, які не упорядковані відносно звичайних повідомлень користувачів. Зокрема:</p></div>
<div class="ulist"><ul>
<li>
<p>
Дитячий актор C надсилає повідомлення M своєму батькові P
</p>
</li>
<li>
<p>
Дитячий актор виходить з ладу з помилкою F
</p>
</li>
<li>
<p>
Актор-батько P може отримати дві події або в порядку M, F або F, M
</p>
</li>
</ul></div>
<div class="paragraph"><p>Причиною цього є те, що внутрішні системні повідомлення мають власні поштові скриньки. Тому впорядкування запитів користувальницьких запитів і системних повідомлень не може гарантувати впорядкування їх отримання.</p></div>
</div>
<div class="sect2">
<h3 id="___in_jvm__">Правила надсилання In-JVM (локального) повідомлення</h3>
<div class="sect3">
<h4 id="_________2">Будьте уважні, що ви робите з цим розділом!</h4>
<div class="paragraph"><p>Не рекомендується покладатися на більш високу надійність, описану у цьому розділі, оскільки це пов'язує вашу програму лише з локальним розгортанням: програма може бути розроблена по-іншому (на відміну від використання деяких моделей обміну повідомленнями, локальних для деяких акторів), щоб бути придатний для виконання на кластері машин. Нашим кредо є "спроектуй один раз, розгорніть у будь-який бажаний спосіб", і для цього вам слід покластися лише на загальні правила.</p></div>
</div>
<div class="sect3">
<h4 id="_____7">Надійність надсилання локальних повідомлень</h4>
<div class="paragraph"><p>Набір тестів Akka покладається на те, щоб не втрачати повідомлення в локальному контексті (а також для не-збійних тестів також і для віддаленого розгортання). Це означає, що ми насправді докладаємо максимум зусиль, щоб наші тести були стабільними. Однак операція локального повідомлення <code>tell</code> може не працювати з тих же причин, що і звичайний виклик методу в JVM:</p></div>
<div class="ulist"><ul>
<li>
<p>
StackOverflowError
</p>
</li>
<li>
<p>
OutOfMemoryError
</p>
</li>
<li>
<p>
інша VirtualMachineError
</p>
</li>
</ul></div>
<div class="paragraph"><p>Окрім того, локальне надсилання може не вдаватися специфічними для Akka способами:</p></div>
<div class="ulist"><ul>
<li>
<p>
якщо поштова скринька не приймає повідомлення (наприклад, повна <code>BoundedMailbox</code>)
</p>
</li>
<li>
<p>
якщо актор отримує помилку під час обробки повідомлення або вже припинений
</p>
</li>
</ul></div>
<div class="paragraph"><p>Хоча перше - це питання конфігурації, друге заслуговує на деяку думку: відправник повідомлення не отримує зворотного зв’язку, якщо під час обробки був виняток, і це повідомлення переходить до керівника. Це взагалі не відрізняється від втраченого повідомлення для зовнішнього спостерігача.</p></div>
</div>
<div class="sect3">
<h4 id="_____8">Порядок надсилання локальних повідомлень</h4>
<div class="paragraph"><p>Якщо розглянути суто поштові скриньки FIFO, вищезазначені застереження про неперехідність гарантії замовлення повідомлень усувається за певних умов. Як ви зауважите, вони є настільки тонкими, наскільки це є, і цілком можливо, що майбутні оптимізації ефективності онулюють весь цей абзац. Перелік протипоказань, можливо, не вичерпний:</p></div>
<div class="ulist"><ul>
<li>
<p>
Перш ніж отримати першу відповідь від актора вищого рівня, існує блокування, яке захищає внутрішню тимчасову чергу, і це блокування не є чесним; сенс полягає в тому, що запити на постановку в чергу від різних відправників, які надходять під час побудови актора (фігурально кажучи, деталі більш заплутані), можуть бути переупорядковані залежно від планування ниток низького рівня. Оскільки повністю чесних блоквань у JVM не існує, це неможливо виправити.
</p>
</li>
<li>
<p>
Цей же механізм використовується під час побудови <code>Router</code>, точніше маршрутизованого <code>ActorRef</code>, отже, така ж проблема існує і для акторів, розгорнутих з маршрутизаторами <code>Router</code>.
</p>
</li>
<li>
<p>
Як було сказано вище, проблема виникає в будь-якому місці блокування, яке виконується під час побудови черги, що також може стосуватися спеціальних поштових скриньок.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Цей список складено ретельно, але, можливо, інші проблемні сценарії уникнули нашого аналізу.</p></div>
</div>
<div class="sect3">
<h4 id="_______5">Як локальне впорядкування стосується мережевого впорядкування</h4>
<div class="paragraph"><p>Є правило, згідно з яким для певної пари акторів повідомлення, що надсилаються безпосередньо від першого до другого, не змінюватимуть порядок отримання. Це робить для повідомлень, що надсилаються по мережі за допомогою протоколу віддаленого транспорту Akka на основі TCP.</p></div>
<div class="paragraph"><p>Як пояснено в попередньому розділі, за певних умов надсилання локального повідомлення підкоряється транзитивному впорядкуванню. Це впорядкування може бути порушено через різні затримки доставки повідомлень. Наприклад:</p></div>
<div class="ulist"><ul>
<li>
<p>
Актор A у вузлі-1 надсилає повідомлення M1 актору C на вузол-3
</p>
</li>
<li>
<p>
Актор A у вузлі-1 потім надсилає повідомлення M2 актору B на вузол-2
</p>
</li>
<li>
<p>
Актор B у вузлі-2 пересилає повідомлення M2 актору C на вузол-3
</p>
</li>
<li>
<p>
Актор C може отримувати M1 і M2 в будь-якому порядку
</p>
</li>
</ul></div>
<div class="paragraph"><p>Можливо, у M1 може знадобитися більше часу для "подорожі" до вузла-3, ніж для M2 для "подорожі" до вузла-3 через вузол-2.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="____20">Абстракції вищого рівня</h3>
<div class="paragraph"><p>На основі невеликого та послідовного інструменту, встановленого в ядрі Akka, Akka також забезпечує потужні абстракції вищого рівня.</p></div>
<div class="sect3">
<h4 id="____21">Шаблони обміну повідомленнями</h4>
<div class="paragraph"><p>Як обговорювалося вище, пряма відповідь на вимогу надійної доставки є явним протоколом ACK–RETRY. У своїй найпростішій формі для цього потрібно</p></div>
<div class="ulist"><ul>
<li>
<p>
спосіб ідентифікації окремих повідомлень для співвіднесення повідомлення з підтвердженням
</p>
</li>
<li>
<p>
механізм повторного надсилання повідомлень, якщо його не визнано вчасно
</p>
</li>
<li>
<p>
спосіб для приймача виявити та відкинути дублікати
</p>
</li>
</ul></div>
<div class="paragraph"><p>Третє стає необхідним завдяки визнанням, яким також не гарантовано надходження.</p></div>
<div class="paragraph"><p>Протокол ACK-RETRY з підтвердженнями бізнес-рівня та дедублікацією за допомогою ідентифікаторів підтримується функцією Reliable Delivery.</p></div>
<div class="paragraph"><p>Іншим способом реалізації третьої частини було б зробити обробку повідомлень ідемпотентною (байдужою до повторних застосувань) на рівні ділової логіки.</p></div>
</div>
<div class="sect3">
<h4 id="___12">Походження подій</h4>
<div class="paragraph"><p>Походження подій (та шардинг подій) - це те, що робить великі веб-сайти масштабованими до мільярдів користувачів. Ідея досить проста: коли компонент (вважайте - актор) обробляє команду, він генерує перелік подій, що представляють ефект команди. Ці події, крім того, що вони застосовуються до стану компонента, також зберігаються. Приємним в цій схемі є те, що події лише коли-небудь додаються до сховища, нічого ніколи не змінюється. Це дає змогу досконалої реплікації та масштабування споживачів цього потоку подій (тобто інші компоненти можуть споживати потік подій як засіб для копіювання стану компонента на іншому континенті або реагування на зміни). Якщо стан компонента втрачено - через несправність машини або виштовхом з кешу - його можна реконструювати, відтворивши потік подій (зазвичай використовуючи знімки для прискорення процесу). Походження подій підтримується Akka Persistence.</p></div>
</div>
<div class="sect3">
<h4 id="______12">Поштова скринька з явним підтвердженням</h4>
<div class="paragraph"><p>Реалізуючи власний тип поштової скриньки, можна повторити обробку повідомлень на кінці приймаючого актора, щоб вирішити тимчасові збої. Ця модель є найбільш корисною в контексті локального спілкування, коли інакше гарантії доставки є достатніми для виконання вимог програми.</p></div>
<div class="paragraph"><p>Будь ласка, зауважте, що застосовуються всі застереження щодо Правил надсилань повідомлень In-JVM (Local).</p></div>
</div>
</div>
<div class="sect2">
<h3 id="___13">Мертві листи</h3>
<div class="paragraph"><p>Повідомлення, які неможливо доставити (і для яких це можна встановити), будуть доставлені синтетичному акторові під назвою <code>/deadLetters</code>. Ця доставка відбувається за найкращих зусиль; вона може бути невдалою навіть у локальній JVM (наприклад, під час припинення дії актора). Повідомлення, надіслані через ненадійні мережеві транспорти, втрачаються, не перетворюючись на мертві листи.</p></div>
<div class="sect3">
<h4 id="________2">Для чого я повинен використовувати мертві листи?</h4>
<div class="paragraph"><p>Основне використання цього засобу - для налагодження, особливо якщо надсилання актора не надходить послідовно (де зазвичай огляд мертвих листів скаже вам, що відправник або одержувач встановлені неправильно десь на шляху). Для того, щоб бути корисним для цієї мети, краще уникати надсилання на <code>DeadLetters</code>, де це можливо, тобто запустіть додаток час від часу з відповідним реєстратором мертвих листів (див. Докладніше) та очистіть записи в журналі. Ця вправа - як і все інше - вимагає розумного застосування здорового глузду: цілком можливо, що уникнення надсилання завершеному акторові ускладнює код відправника більше, ніж отримано в ясності виводу налагодження.</p></div>
<div class="paragraph"><p>Служба мертвих листів дотримується тих самих правил стосовно гарантій доставки, що і всі інші повідомлення, що надсилаються, отже, її не можна використовувати для здійснення гарантованої доставки.</p></div>
</div>
<div class="sect3">
<h4 id="______13">Як я отримую мертві листи?</h4>
<div class="paragraph"><p>Актор може підписатися на клас <code>akka.actor.DeadLetter</code> у потоці подій (про те, як це зробити, див. Event Stream) Після цього підписаний актор отримуватиме всі мертві листи, опубліковані в (локальній) системі. Мертві листи не поширюються по мережі. Якщо ви хочете зібрати їх в одному місці, вам доведеться підписати одного актора на кожний мережевий вузол і переслати їх вручну. Також врахуйте, що мертві листи створюються на вузлах, які можуть визначити, що операція надсилання не виконан. Це для віддаленого відправлення може бути локальною системою (якщо мережеве з'єднання неможливо встановити) або віддаленою (якщо актор, до якого ви надсилаєте, не існує в цей момент часу).</p></div>
</div>
<div class="sect3">
<h4 id="_________3">Мертві листи, які, як правило, не викликають занепокоєння</h4>
<div class="paragraph"><p>Кожен раз, коли актор не припиняється за власним рішенням, є ймовірність, що деякі повідомлення, які він надсилає собі, втрачаються. Є така ситуація, яка трапляється досить легко в складних сценаріях відключення, і, як правило, є здоровою: побачити випадки добровільної команди зупинки для скинутого актора означає, що було подано два запити на зупинку, але тільки один може досягти успіху. У цьому ж ключі ви можете побачити повідомлення <code>akka.actor.Terminated</code> від дітей, припиняючи ієрархію акторів, що з’являються серед мертвих листів, якщо батько все ще спостерігає за дитиною, коли сам батько вже припиняє існування.</p></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-05-24 01:22:40 EEST
</div>
</div>
</body>
</html>
