<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="___akka">Вступ до Akka</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ласкаво просимо до Akka, набір бібліотек з відкритим кодом для розробки маштабованих, пружних систем, що поєднують ядра процесора та мережі. Akka дає вам можливість сфокусуватись на відповідності потребам бізнесу замість написання инзькорівневого коду для забезпечення надійної поведінки, відмовостійкості та високої продуктивності.</p></div>
<div class="paragraph"><p>Багато поширених практик та прийнятих моделей програмування не вирішують важливих проблем, притаманних проектуванню систем для сучасних комп'ютерних архитектур. Щоб досягти успіху, розподілені системи повинні справлятись в умовах, коли компоненти виходять з ладу і не відповідають, повідомлення губляться без слідів в дротах, а мережеві затримки коливаються. Ці проблеми регулярно виникають у ретельно керованих середовищах внутрішньої обробки даних, і тим більше у віртуалізованих архитектурах.</p></div>
<div class="paragraph"><p>Щоб допомогти вам розбітратись з ціма реаліями Akka пропонує:</p></div>
<div class="ulist"><ul>
<li>
<p>
Багатопоточну поведінку без використання низькорівневих конструктивів конкуренції, як атоміки або блокування — позбавляючи вас навіть від думок про видимість пам'яті.
</p>
</li>
<li>
<p>
Прозору віддалену комунікацію між системами та їх компонентами — позбавляючи вас від написання та підтримки різного мережевого коду.
</p>
</li>
<li>
<p>
Кластерізовану, високо доступну архитектуру, яка є еластичною, на вимогу маштабується вгору та вниз - це дозволяє вам пропонувати дійсно реактивну систему.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Використана в Akka модель акторів провадить рівень абстракції, що спрощує написання коректних конкурентних, паралельних та розподілених систем. Модель акторів поєдную повний набір бібліотек Akka
, пропонуючи вам узгоджений спосіб їх розуміння та використання. Таким чином, Akka пропонує вам глибину інтеграції, яку ви не можете досягти, відбираючи бібліотеки для вирішення окремих проблем, та намагаючись скласти їх разом.</p></div>
<div class="paragraph"><p>Вивчаючи Akka, та як використовувати модель акторів, ви отримаєте доступ до величезного та глибокого набору інструментів, що вирішують проблеми складних розподілених/паралельних систем в одноманітній програмній моделі, де все пасує один до одного тісно та ефективно.</p></div>
<div class="sect2">
<h3 id="___">З чого розпочати</h3>
<div class="paragraph"><p>Якщо це ваш перший досвід з Akka, ми рекомендуємо, щоб ви почали з виконання простого проекту <code>Hello World</code>. Дивіться посібник Quickstart щодо інструкцій по завантаженню та виконанню проклада <code>Hello World</code>. У посібнику <a href="https://developer.lightbend.com/guides/akka-quickstart-scala?_ga=2.105915075.1160774607.1575422013-1972390590.1574487700">Quickstart</a> ви знайдете приклад коду, який вказує, як визначати системи акторів, акторів та повідомлення, а також як користуватись тестовим модулем та журналом. Протягом 30 хвилин ви зможете запустити приклад <code>Hello World</code> та дизнатися, як він побудований.</p></div>
<div class="paragraph"><p>Посібник Початок Роботи надає наступний рівень інформації. Він висвітлює, чому модель акторів відповідає потребам сучасних розподілених систем, і включає посібник, який допоможе продовжити опанування Akka. Теми включають:</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_______">Чому сучасні системи потребують нової програмної моделі</h2>
<div class="sectionbody">
<div class="literalblock">
<div class="content">
<pre><code>Модель акторів запропонував десятиліття тому Carl Hewitt, як шлях для обробки паралельного виконання в високошвидкісній мережі — оточенні, що не було доступне на той час. На сьогодні обладнання та можливості інфраструктури наздогнали упереджуюче бачення Hewitt. Отже організації, що будують розподілені системи з вимогливими потребами, стикнулись з проблемами, що не можуть бути повністю вирішені за допомогою традиційної об'єктно-орієнтовної моделі (OOP), але можуть мати вигоди від моделі акторів.</code></pre>
</div></div>
<div class="paragraph"><p>Сьогодні модель акторів не тільки визнана як високоефективне рішення — вона випробовуна на виробництві для деяких найбільш вимогливих застосувань в світі. Щоб підкреслити пробеми, які вирішує система акторів, цей розділ обговорює наступні невідповідності між традиційними програмними упередженнями і реальністю сучаних багато-поточних і багато-процесорних архитектур:</p></div>
<div class="ulist"><ul>
<li>
<p>
Виклик інкапсуляції
</p>
</li>
<li>
<p>
Ілюзія загальної пам'яті на сучасних комп'ютерних архітектурах
</p>
</li>
<li>
<p>
Ілюзія стеку викликів
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="__">Виклик інкапсуляції</h3>
<div class="paragraph"><p>Головний стовп OOP є інкапсуляція. Інкапсуляція диктує, що внутрішні дані об'єкта не доступні напряму ззовні; Вони можуть бути модифіковані тільки через набір підконтрольних методів. Об'єкт відповідальний за показ безпечних операцій, що захищає інваріантну природу інкапсульованих в ньому даних.</p></div>
<div class="paragraph"><p>Наприклад, реалізація операції над впорядкованим бінарним деревом має не дозволяти порушення інваріанту впорядкованості дерева. Виклик очікує, що впорядкованість буде недоторкана, і коли виконується запит дерева щодо деякої частини даних, ми маємо покладатись на це обмеження.</p></div>
<div class="paragraph"><p>Коли ми аналізуємо рантайм поведінку OOP, ми іноді малюємо графік послідовності, що показує взаємодію викликів методів. Наприклад:</p></div>
<div class="imageblock">
<div class="content">
<img src="seq_chart.png" alt="seq_chart.png" />
</div>
</div>
<div class="paragraph"><p>Нажаль, діаграма вище насправді не представляє життя примірника під час виконання. Насправді потік виконує всі ці виклики, і примушення інварантів відбувається в тому самому потоку, в якому метод був викликаний. Оновлення діаграми разом з виконанням потоку виглядає так:</p></div>
<div class="imageblock">
<div class="content">
<img src="seq_chart_thread.png" alt="seq_chart_thread.png" />
</div>
</div>
<div class="paragraph"><p>Важливість цього прояснення стає зрозумілим, коли ми спробуємо змоделювати, що трапиться з декількома потоками. Раптово наша чудово намальована діаграма стає неадекватною. Ми можемо спробувати проілюструвати декілька потоків,що отримують доступ до тих самих примірниів:</p></div>
<div class="imageblock">
<div class="content">
<img src="seq_chart_multi_thread.png" alt="seq_chart_multi_thread.png" />
</div>
</div>
<div class="paragraph"><p>Існує розділ виконання, де два потоки отримують доступ до одного методу. Нажаль, модель інкапсуляції об'єктів нічого не гарантує щодо того, що відбувається в цьому розділі. Інструкції двох викликів можуть перетинатись в довільний спосіб, що вбиває жодну надію утримувати інваріанти непорушними без деякого типу координації між двома потоками. І тепер уявіть цю проблему, ускладнену існуванням багатьох потоків.</p></div>
<div class="paragraph"><p>Загальний підхід до вирішення цієї проблеми є додавання блокування коло ціх методів. Хоча це гарантує, що в кожний момент часу щонайбільше один потік займатиме метод, це дуже коштовна стратегія:</p></div>
<div class="ulist"><ul>
<li>
<p>
Блокування <em>серйозно</em> обмежують конкурентність, вони дуже коштовні на сучасних архитектурах CPU, вимагаючи від операційної системи важких зусиль по призупиненню та подальшого відновлення потоку.
</p>
</li>
<li>
<p>
Викликаючий потік тепер блокований, тому він не може робити жодної іншої значущої роботи. Це неприйнятно навіть в настольних додатках, ми хочемо, щоб звернені до користувача частини додатку (його інтерфейс) реагували навіть тоді, коли виконується велике фонове завдання. В бекенді блокування явно марне. Можна подумати, що це можна компенсувати запуском нових потоків, але потокі також також коштовна абстракція.
</p>
</li>
<li>
<p>
Блокування представляють нову загрозу: глухі кути.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Ці реалії призводять до безвиграшної ситуації:</p></div>
<div class="ulist"><ul>
<li>
<p>
Без достатнього блокування стан псується.
</p>
</li>
<li>
<p>
З багатьма блокваннями страждає продуктивність, і це дуже легко призводить до тупиків.
</p>
</li>
</ul></div>
<div class="paragraph"><p>На додаток блокування досить гарно роблять тільки локально. Коли доходить до координації між декількома машинами єдиною альтернативою є розподілені блокування. Нажаль, розподілені блокування на декілька порядків менш ефективні, ніж локальні блокування, і зазвичай накладають жорсткий ліміт на маштабування назовні. Протоколи розподіленого блокування потребують декількох комунікаційних звернень по мережі між декількома машинами, так що затримки доходять до стелі.</p></div>
<div class="paragraph"><p>В Об'єктно Орієнтованих мовах ми рідко думаємо про потокі або шляхи лінійного виконання взагалі. Ми часто уявляємо систему як мережу примірників об'єктів, що реагують на виклики методів, модифікують свій внутрішній стан, потім комунікують один з одним через виклик методів, рухаючи загальний стан застосування вперед:</p></div>
<div class="imageblock">
<div class="content">
<img src="object_graph.png" alt="object_graph.png" />
</div>
</div>
<div class="paragraph"><p>Однак в багато-поточному розподіленому оточенні насправді відбувається те, що потоки "перетинають" цю мережу примірників о'бєктів слідуючи за викликами методів. Як результат, потоки це дійсно те, що керує виконанням:</p></div>
<div class="imageblock">
<div class="content">
<img src="object_graph_snakes.png" alt="object_graph_snakes.png" />
</div>
</div>
<div class="sect3">
<h4 id="_">Підсумок:</h4>
<div class="ulist"><ul>
<li>
<p>
<strong>Об'єкти можуть лише гарантувати енкапсуляцію (захист інвариантів) перед лицем однопоточного доступу, багато-поточне виконання майже завжди призводить до зруйнованого внутрішнього стану. Кожний інваріант може бути порушений коли в тому самому сегмнті коду є два супречнивих потока.</strong>
</p>
</li>
<li>
<p>
<strong>Хоча блокування виглядають природним засобом підтримкм ікапсуляції з багатьма потоками, на практиці вони неефективні і просто призводять в глухий кут в любому застосуванні реального маштабу.</strong>
</p>
</li>
<li>
<p>
<strong>Блокування роблять локально, спроби зробити їх розподіленими існують, але пропонують обмежений потенціал для маштабування назовні.</strong>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="_________">Ілюзія загальної пам'яті на сучасних комп'ютерних архітектурах</h3>
<div class="paragraph"><p>Програмні моделі 80’-90’х концептуалізують, що запис у змінну означає безпосередьо запис в місце в пам'яті (що дещо затуманює воду, бо локальні змінні можуть існувати лише в регістрах). В сучасних архитектурах - якщо ми трохи спростимо речі - CPU пишуть до рядків кешу, замість записувати в пам'ять напряму. Більшість з ціх кешів локальні відносно ядра CPU, тобто записи одним ядром невидимі для іншого. Щоб зробити локальні зміни видимими для іншого ядра, і таки чином для іншого потоку, рядок кешу має бути доставлений до кешу іншого ядра.</p></div>
<div class="paragraph"><p>У JVM ми маємо чітко позначати місця пам'яті, які слід розділити по потоках, використовуючи мінливі маркери або атомні обгортки. В іншому випадку ми можемо отримати доступ до них лише у заблокованому розділі. Чому ми не позначимо всі змінні як мінливі? Оскільки доставка рядків кешу між ядрами - це дуже дорога операція! Це буде неявно утримувати причетні ядра від виконання додаткової роботи, і призводить до виникнення вузьких місць у протоколі когерентності кешу (протокол, який використовують CPU для передачі рядків кеша між основною пам'яттю та іншими процесорами). Результат - уповільнення в рази.</p></div>
<div class="paragraph"><p>Навіть для розробників, які знають про цю ситуацію, з'ясувати, які місця пам'яті слід позначати як мінливі, або які атомарні структури використовувати - це темне мистецтво.</p></div>
<div class="sect3">
<h4 id="__2">Підсумок:</h4>
<div class="ulist"><ul>
<li>
<p>
<strong>Насправді більше немає спільної пам'яті, ядра CPU явно передають шматки даних (рядки кешу) один одному, так само як це роблять мережеві комп'ютери. Міжпроцесорний зв’язок та мережевий зв’язок мають більше спільного, ніж багато хто уявляє. Зараз передача повідомлень є нормою, будь то через процесори чи мережеві комп'ютери.</strong>
</p>
</li>
<li>
<p>
<strong>Instead of hiding the message passing aspect through variables marked as shared or using atomic data structures, a more disciplined and principled approach is to keep state local to a concurrent entity and propagate data or events between concurrent entities explicitly via messages.</strong>
</p>
</li>
<li>
<p>
<strong>Замість того, щоб приховати аспект передачі повідомлення через змінні, позначені як спільні або використовуючи атомарні структури даних, більш впорядкованим та принциповим підходом є збереження стану локального значення для конкурентної сутності, та поширення даних або подій між супутніми об'єктами явно за допомогою повідомлень.</strong>
</p>
</li>
</ul></div>
</div>
</div>
<div class="sect2">
<h3 id="____2">Ілюзія стеку викликів</h3>
<div class="paragraph"><p>Сьогодні ми часто приймаємо стеки викликів як належне. Але вони були винайдені в епоху, коли одночасне програмування не було настільки важливим, оскільки багатопроцесорні системи не були поширеними. Стеки викликів не перетинають потоки, отже, не моделюють асинхронні ланцюги викликів.</p></div>
<div class="paragraph"><p>Проблема виникає, коли потік має намір делегувати завдання у "фон". На практиці це насправді означає делегування в інший потік. Це не може бути простим викликом метода/функції, оскільки виклики строго локальні для потоку. Зазвичай відбувається те, що "замовник" поміщає об'єкт у місце пам'яті, спільне з робочим потоком ("виконавець"), який, у свою чергу, підбирає його в певному циклі подій. Це дозволяє потоку "замовника" рухатися далі та виконувати інші завдання.</p></div>
<div class="paragraph"><p>Перше питання полягає в тому, як можна повідомити "замовника" про виконання завдання? Але більш серйозне питання виникає, коли завдання хибить з виключенням. Куди поширюється виняток? Він поширюватиметься на обробник винятків робочого потоку, повністю ігноруючи, хто був фактичним "замовником":</p></div>
<div class="imageblock">
<div class="content">
<img src="exception_prop.png" alt="exception_prop.png" />
</div>
</div>
<div class="paragraph"><p>Це серйозна проблема. Як робочий процес вирішує ситуацію? Він, ймовірно, не може виправити проблему, оскільки зазвичай не враховує мету невдалої задачі. Треба якось сповістити потік "замовника", але не існує стека викликів, який можна відмотати по виключенню. Повідомлення про помилку може бути здійснено лише через бічний канал, наприклад, поставивши код помилки туди, де потік "замовника" в іншому випадку очікує результату, коли той готовий. Якщо це повідомлення не встановлено, "замовник" ніколи не отримує повідомлення про помилку і завдання втрачається! <strong>Це дивно схоже на те, як працюють мережеві системи, де повідомлення/запити можуть втрачатися або виходити з ладу без будь-якого повідомлення.</strong></p></div>
<div class="paragraph"><p>Ця погана ситуація погіршується, коли справи йдуть дійсно не так, і робочій потік стикається з помилкою і опиняється в невиправній ситуації. Наприклад, внутрішній виняток, спричинений помилкою, підіймається до кореню потока і змушує потік завершитись. Це негайно викликає питання, хто повинен перезапустити нормальну роботу сервісу, розміщеного в потоці, і як він повинен бути відновлений до відомого гарного стану? На перший погляд, це може здатися вирішуваним, але ми раптом стикаємося з новими, несподіваними явищами: справжнє завдання, над яким потік працював в даний час, вже не знаходиться в спільній пам’яті, звідки беруться завдання (зазвичай це черга). Насправді, через виняток, що досягає вершини, розмотуючи весь стек викликів, стан завдання повністю втрачається! <strong>Ми втратили повідомлення, незважаючи на те, що це локальна комунікація без участі в роботі мережі (де очікуються втрати повідомлень).</strong></p></div>
<div class="sect3">
<h4 id="__3">Підсумок:</h4>
<div class="ulist"><ul>
<li>
<p>
<strong>Для досягнення будь-якої осмисленої одночасності та продуктивності на сучасних системах потоки повинні ефективно делегувати завдання між собою без блокування. При такому стилі конкурентності з-делегуванням-завдань (а тим більше з мережевими/розподіленими обчисленнями) обробка помилок на основі стека викликів руйнується, і потрібно запровадити нові, явні механізми сигналізації помилок. Відмови стають частиною предметної моделі.</strong>
</p>
</li>
<li>
<p>
<strong>Конкурентні системи з делегуванням роботи повинні обробляти несправності сервісу і мати принципові засоби для їх відновлення. Клієнти таких послуг повинні знати, що завдання/повідомлення можуть загубитися під час рестарту. Навіть якщо втрати не трапляються, відповідь може бути довільно відкладена через попередньо накопичені завдання (довга черга), затримки, спричинені прибиранням сміття тощо. В світі цього конкурентні системи повинні підтримувати терміни реагування у формі тайм-аутів, так само як мережеві/розподілені системи.</strong>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Далі подивимось, як використання моделі актора може подолати ці проблеми.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="________">Як модель актора відповідає потребам сучасних розподілених систем</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як описано в попередній темі, загальні практики програмування не відповідають належним чином потребам вимогливих сучасних систем. На щастя, нам не потрібно брати в руки все, що ми знаємо. Натомість модель актора вирішує ці недоліки принципово, дозволяючи системам вести себе таким чином, який краще відповідає нашій ментальній моделі. Абстракція моделі актора дозволяє думати про свій код з точки зору спілкування, не дуже відмінну від обмінів, які відбуваються між людьми у великій організації.</p></div>
<div class="paragraph"><p>Використання акторів дозволяє нам:</p></div>
<div class="ulist"><ul>
<li>
<p>
<strong>Застосувати інкапсуляцію, не вдаючись до блокувань.</strong>
</p>
</li>
<li>
<p>
<strong>Використовувати модель взаємодіючих сутностей, що реагують на сигнали, змінюючи стан і передаючи сигнали один одному, щоб рухати всю програму вперед.</strong>
</p>
</li>
<li>
<p>
<strong>Перестати турбуватися про механізм виконання, який не відповідає нашому світогляду.</strong>
</p>
</li>
</ul></div>
<div class="sect2">
<h3 id="______">Використання передачі повідомлення дозволяє уникнути блокування</h3>
<div class="paragraph"><p>Замість того, щоб викликати методи, актори надсилають повідомлення один одному. Надіслати повідомлення не передає потік виконання від відправника до місця призначення. Актор може надіслати повідомлення та продовжити, не блокуючи. Тому він може досягти більше за той самий проміжок часу.</p></div>
<div class="paragraph"><p>З об'єктами, коли метод повертає керування, він вивільняє контроль над потоком виконання. У цьому відношенні актори поводяться так, як об'єкти, вони реагують на повідомлення та повертають виконання, коли закінчують обробку поточного повідомлення. Таким чином, актори фактично досягають того, що ми задумували для об'єктів:</p></div>
<div class="imageblock">
<div class="content">
<img src="actor_graph.png" alt="actor_graph.png" />
</div>
</div>
<div class="paragraph"><p>Важливою відмінністю між передачею повідомлень та викликом методів є те, що повідомлення не мають зворотного значення. Відправляючи повідомлення, актор делегує роботу іншому акторові. Як ми бачили в Ілюзії стека викликів, якщо він очікував значення повернення, актору-замовнику потрібно або блокувати, або виконувати роботу іншого актора в тому самому потоці. Натомість приймаючий актор доставляє результати у повідомленні-відповіді.</p></div>
<div class="paragraph"><p>Друга ключова зміна, яка нам потрібна в нашій моделі - відновити інкапсуляцію. Актори реагують на повідомлення так само, як об'єкти "реагують" на методи, які виконуються на них. Різниця полягає в тому, що замість того, щоб декілька потоків "пронизували" нашого актора і спричиняли хаос для внутрішнього стану та інваріантів, актори виконуються незалежно від відправників повідомлення, і вони реагують на вхідні повідомлення послідовно, по одному. У той час як кожен актор обробляє надіслані йому повідомлення послідовно, різні актори працюють одночасно один з одним, щоб система акторів одночасно обробляла стільки повідомлень, скільки підтримує обладнання.</p></div>
<div class="paragraph"><p>Оскільки завжди існує максимум одне повідомлення, яке обробляється на одного актора, інваріанти актора можуть зберігатися без синхронізації. Це відбувається автоматично без використання блокувань:</p></div>
<div class="imageblock">
<div class="content">
<img src="serialized_timeline_invariants.png" alt="serialized_timeline_invariants.png" />
</div>
</div>
<div class="paragraph"><p>В результаті ось що відбувається, коли актор отримує повідомлення:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Актор додає повідомлення до кінця черги.
</p>
</li>
<li>
<p>
Якщо актор не був запланований до виконання, він позначається як готовий до виконання.
</p>
</li>
<li>
<p>
(Прихована) сутність планувальника приймає актора і починає його виконувати.
</p>
</li>
<li>
<p>
Актор підбирає повідомлення з початку черги.
</p>
</li>
<li>
<p>
Актор змінює внутрішній стан, надсилає повідомлення іншим акторам.
</p>
</li>
<li>
<p>
Актор незаплановий.
</p>
</li>
</ol></div>
<div class="paragraph"><p>Для виконання такої поведінки актори мають:</p></div>
<div class="ulist"><ul>
<li>
<p>
Поштова скринька (черга, в яку потрапляють повідомлення).
</p>
</li>
<li>
<p>
Поведінка (стан актора, внутрішні змінні тощо).
</p>
</li>
<li>
<p>
Повідомлення (фрагменти даних, що представляють сигнал, схожий на виклики методів та їх параметри).
</p>
</li>
<li>
<p>
Середовище виконання (механізм, який використовує акторів, які мають повідомлення для реагування, викликаючи їх код обробки повідомлень).
</p>
</li>
<li>
<p>
Адреса (детальніше про це пізніше).
</p>
</li>
</ul></div>
<div class="paragraph"><p>Повідомлення надходять у поштові скриньки актора. Поведінка актора описує, як актор відповідає на повідомлення (наприклад, надсилаючи більше повідомлень та/або змінюючи стан). Середовище виконання оркеструє пулом потоків, щоб повністю прозоро керувати всіма цими діями.</p></div>
<div class="paragraph"><p>Це дуже проста модель, і вона вирішує проблеми, перелічені раніше:</p></div>
<div class="ulist"><ul>
<li>
<p>
Інкапсуляція зберігається шляхом розділення виконання та сигналізації (виклики метода передають виконання, передача повідомлення ні).
</p>
</li>
<li>
<p>
Немає потреби в блокуваннях. Змінити внутрішній стан актора можливо лише за допомогою повідомлень, які обробляються по черзі, виключаючи перегони заради дотримання інваріантів.
</p>
</li>
<li>
<p>
Блоки не використовуються ніде, а відправники не заблоковані. Мільйони акторів можуть бути ефективно заплановані на десяток потоків, що досягають повного потенціалу сучасних процесорів. Делегування завдань - це природний режим роботи для акторів.
</p>
</li>
<li>
<p>
Стан акторів локальний і не поділяється, зміни та дані поширюються за допомогою повідомлень, які відображають, як насправді працює сучасна ієрархія пам'яті. У багатьох випадках це означає передачу тільки кеш-рядків, що містять дані в повідомленні, зберігаючи локальний стан та кешовані дані в початковому ядрі. Ця ж модель відображає саме віддалений зв'язок, де стан зберігається в оперативній пам'яті машин, а зміни/дані поширюються по мережі у вигляді пакетів.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_______2">Актори витончено вирішують ситуації з помилками</h3>
<div class="paragraph"><p>Оскільки у нас більше немає спільного стека викликів між акторами, які передають повідомлення один одному, нам потрібно по-іншому обробляти ситуації з помилками. Ми повинні враховувати два види помилок:</p></div>
<div class="ulist"><ul>
<li>
<p>
Перший випадок - це коли делегована задача на цільовому акторі виявилася невдалою через помилку завдання (як правило, деякі проблеми перевірки, як-от неіснуючий ідентифікатор користувача). У цьому випадку служба, інкапсульована цільовим актором, є недоторканою, помилковою є лише сама задача. Актор служби повинен відповісти відправнику повідомленням, представляючи випадок помилки. Тут немає нічого особливого, помилки є частиною справ і тому стають звичайними повідомленнями.
</p>
</li>
<li>
<p>
Другий випадок - коли сама служба стикається з внутрішньою помилкою. Akka примушує всіх акторів організуватися в ієрархію, що нагадує дерево. Тобто актор, який створює іншого актора, стає батьком цього нового актора. Це дуже схоже на те, як операційні системи організовують процеси в дерево. Так само, як і при процесах, коли актор схиблює, його батьківський актор може вирішити, як реагувати на невдачу. Крім того, якщо батьківського актора зупинено, всі його діти також припиняються. Ця послуга називається наглядом, і вона є центральною для Akka.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Стратегія наглядача, як правило, визначається батьківським актором, коли він запускає актора-дитину. Він може вирішити перезапустити дитячого актора на певні типи відмов або повністю зупинити його на інших. Діти ніколи не йдуть мовчазно мертвими (за винятком входження в нескінченний цикл). Натомість вони або схиблюють, і стратегія наглядача може відреагувати на помилку, або їх зупиняють (у такому випадку повідомляються зацікавлені сторони). Завжди існує відповідальна сутність управління актором: його батько. Рестарти не видно зовні: співпрацюючі актори можуть продовжувати надсилати повідомлення під час перезапуску цільового актора.</p></div>
<div class="paragraph"><p>Тепер коротко ознайомимось з функціоналом, який надає Akka.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_____akka">Огляд бібліотек та модулів Akka</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перш ніж заглибитися у деякі кращі практики написання акторів, буде корисно переглянути найбільш часто використовувані бібліотеки Akka. Це допоможе вам почати думати про функціонал, який ви хочете використовувати у вашій системі. Вся основна функціональність Akka доступна у вигляді програмного забезпечення з відкритим кодом (OSS). Lightbend спонсорує розробку Akka, але також може допомогти вам у комерційних пропозиціях, таких як навчання, консультації, підтримка та Enterprise Suite - всебічний набір інструментів для управління системами Akka.</p></div>
<div class="paragraph"><p>Наступні можливості включені в Akka OSS і представлені пізніше на цій сторінці:</p></div>
<div class="paragraph"><p>Бібліотека Actor - Remoting - Cluster - Cluster Sharding - Cluster Singleton - Persistence - Distributed Data - Streams - HTTP</p></div>
<div class="paragraph"><p>З Lightbend Platform Subscription ви можете використовувати Akka Enhancements, що включає:</p></div>
<div class="paragraph"><p><strong>Akka Resilience Enhancements:</strong></p></div>
<div class="paragraph"><p><strong>Split Brain Resolver</strong> - виявляє та відновлює мережеві розділи, усуваючи невідповідності даних та можливі простої.
<strong>Configuration Checker</strong> - перевірка можливих проблем із конфігурацією та журнали пропозицій.
<strong>Diagnostics Recorder</strong> - захоплює конфігурацію та системну інформацію у форматі, що дозволяє легко вирішувати проблеми під час розробки та виробництва.
<strong>Thread Starvation Detector</strong> - відстежує диспетчер системи Akka та записує попередження, якщо він перестає реагувати.
<strong>Kubernetes Lease</strong> - Відстежує диспетчер системи Akka та записує попередження, якщо вона перестає відповідати.
<strong>Fast Failover</strong> — Fast failover for Cluster Sharding.
<strong>Fast Failover</strong> - Швидке відновлення для кластерного шардінгу.</p></div>
<div class="paragraph"><p><strong>Akka Persistence Enhancements:</strong></p></div>
<div class="paragraph"><p><strong>Multi-DC Persistence</strong> - для активно-активних постійних сутностей у багатьох центрах обробки даних.
<strong>GDPR for Akka Persistence</strong> - подрібнення даних можна використовувати для забуття інформації в подіях.</p></div>
<div class="paragraph"><p>На цій сторінці не перелічено усіх доступних модулів, але ви знайдете огляд основних функціональних можливостей та ви знайдете уявлення про рівень вишуканості, якого ви можете досягти, коли ви починаєте створювати системи поверх Akka.</p></div>
<div class="sect2">
<h3 id="__actor">Бібліотека Actor</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-actor-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Основна бібліотека Akka є <code>akka-actor-typed</code>, але актори використовуються в бібліотеках Akka, забезпечуючи послідовну інтегровану модель, яка позбавляє вас від індивідуального вирішення проблем, що виникають при одночасному або розподіленому дизайні системи. З точки зору пташиного польоту, актори - це парадигма програмування, яка виконує інкапсуляцію, один із стовпів ООП, до своєї крайності. На відміну від об'єктів, актори інкапсулюють не лише свій стан, а й їх виконання. Спілкування з акторами відбувається не через виклики, а за допомогою передачі повідомлень. Хоча ця різниця може здатися незначною, вона насправді дозволяє вирватися з обмежень ООП, коли мова йде про конкурентність та віддалений зв’язок. Не хвилюйтеся, чи не буде цей опис занадто високим рівнем для повного розуміння. У наступному розділі ми пояснимо акторів детально. Наразі важливим моментом є те, що це модель, яка обробляє конкурентність та розподіл на фундаментальному рівні замість спроб виправити ці функції латками в ООП.</p></div>
<div class="paragraph"><p>Виклики, які вирішують актори, включають наступні:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як побудувати та розробити високопродуктивні конкурентні програми.
</p>
</li>
<li>
<p>
Як поводитися з помилками в багатопотоковому середовищі.
</p>
</li>
<li>
<p>
Як захистити мій проект від підводних каменів конкурентності.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_remoting">Remoting</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-remote&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Remoting дозволяє акторам, які живуть на різних комп’ютерах, безперебійно обмінюватися повідомленнями. Попри поширення як артефакт JAR, Remoting більше нагадує модуль, ніж бібліотеку. Ви вмикаєте його переважно з конфігурацією, і він має лише кілька API. Завдяки моделі актора, віддалене та локальне надсилання повідомлень виглядає точно так само. Шаблони, які ви використовуєте в локальних системах, безпосередньо переносяться на віддалені системи. Вам рідко доведеться використовувати Remoting безпосередньо, але це забезпечує основу, на якій побудована підсистема кластерів.</p></div>
<div class="paragraph"><p>Проблеми Remoting рішення включає наступне:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як адресувати системи акторів, що живуть на віддалених хостах.
</p>
</li>
<li>
<p>
Як звернутися до окремих акторів у віддалених акторських системах.
</p>
</li>
<li>
<p>
Як перетворити повідомлення в байти на дроті.
</p>
</li>
<li>
<p>
Як керувати низькорівневими, мережевими з'єднаннями (і підключеннями) між хостами, виявляти збої в роботі акторських систем і хостів, і все це прозоро.
</p>
</li>
<li>
<p>
Як мультиплексувати комунікації від неспорідненого набору акторів на одному мережевому з'єднанні, все прозоро.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_cluster">Cluster</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо у вас є набір акторських систем, які співпрацюють для вирішення якоїсь бізнес-проблеми, ви, ймовірно, хочете керувати цим набором систем впорядковано. У той час як Remoting вирішує проблему адреси та спілкування з компонентами віддалених систем, Cluster дає можливість організувати їх у «метасистему», зв’язану разом протоколом членства. У більшості випадків ви хочете використовувати модуль кластера, а не використовувати Remoting безпосередньо. Кластеризація надає додатковий набір послуг, крім Remoting, що потрібні більшості реальних програм.</p></div>
<div class="paragraph"><p>Виклики, які вирішує модуль Cluster, включають наступне:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як підтримувати набір акторських систем (кластер), які можуть спілкуватися один з одним і розглядати один одного як частину кластера.
</p>
</li>
<li>
<p>
Як безпечно додати нову систему до набору вже існуючих членів.
</p>
</li>
<li>
<p>
Як надійно виявити системи, які тимчасово недоступні.
</p>
</li>
<li>
<p>
Як видалити збійні хости/системи (або зменшити масштаб системи), щоб усі члени, що залишилися, узгодили решту підмножини кластеру.
</p>
</li>
<li>
<p>
Як розподілити обчислення між поточним набором членів.
</p>
</li>
<li>
<p>
Як призначити членів кластеру на певну роль, іншими словами, надавати певні послуги, а не інші.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_cluster_sharding">Cluster Sharding</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster-sharding-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Шардінг допомагає вирішити проблему розподілу набору акторів серед членів кластеру Акка. Шардінг - це шаблон, який здебільшого використовується разом із Persistence, щоб збалансувати велику кількість стійких сутностей (підкріплених акторами) між членами кластеру, а також перенести їх до інших вузлів, коли учасники збоять або виїздять.</p></div>
<div class="paragraph"><p>Проблеми, які вирішує Sharding, включають наступні:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як моделювати та масштабувати великий набір стаціонарних сутностей на множині систем.
</p>
</li>
<li>
<p>
Як забезпечити правильне розподілення сутностей у кластері, щоб навантаження було правильно збалансовано на всіх машинах.
</p>
</li>
<li>
<p>
Як забезпечити міграцію сутностей із впавшої системи без втрати стану.
</p>
</li>
<li>
<p>
Як переконатися, що сутність не існує в декількох системах одночасно, а отже, зберігає послідовність.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_cluster_singleton">Cluster Singleton</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster-singleton&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Загальний (насправді, трохи надто поширений) випадок використання в розподілених системах полягає в тому, щоб мати єдину сутність, відповідальну за дану задачу, яка поділяється між іншими членами кластеру та мігрується, якщо хост-система не працює. Хоча це безперечно вводить загальне вузьке місце для всього кластеру, яке обмежує масштабування, існують сценарії, коли використання цього шаблону неминуче. Кластерний синглтон дозволяє кластеру вибрати систему акторів, яка буде приймати конкретного актора, тоді як інші системи завжди можуть отримати доступ до зазначеної послуги незалежно від місця, де вона знаходиться.</p></div>
<div class="paragraph"><p>Модуль Singleton можна використовувати для вирішення таких завдань:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як переконатися, що лише один екземпляр служби працює у всьому кластері.
</p>
</li>
<li>
<p>
Як переконатися, що послуга працює, навіть якщо система, що розміщує її в даний час, виходить з ладу або вимикається в процесі зменшення масштабу.
</p>
</li>
<li>
<p>
Як дістатися до цього примірника від будь-якого члена кластера, якщо припустити, що він може мігрувати до інших систем з часом.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_persistence">Persistence</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-persistence-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і об'єкти в ООП, актори зберігають свій стан у мінливій пам'яті. Після того, як система вимкнена, навмисно або через збій, всі дані, що були в пам'яті, втрачаються. Persistence надає шаблони, що дозволяють акторам зберігати події, що призводять до їх сучасного стану. Після запуску події можуть бути відтворені для відновлення стану сутності, який приймає актор. Потік подій можна запитувати і подавати в додаткові конвеєри обробки (наприклад, зовнішній кластер Big Data) або альтернативні види (наприклад, звіти).</p></div>
<div class="paragraph"><p>Persistence вирішує такі проблеми:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як відновити стан суб'єкта/актора під час перезавантаження або збоїв у роботі системи.
</p>
</li>
<li>
<p>
Як реалізувати систему CQRS.
</p>
</li>
<li>
<p>
Як забезпечити надійну доставку повідомлень за наявності помилок мережі та збоями в системі.
</p>
</li>
<li>
<p>
Як аналізувати події домену, які призвели сутність до його поточного стану.
</p>
</li>
<li>
<p>
Як використовувати Event Sourcing подій у вашій програмі для підтримки тривалих процесів, поки проект продовжує розвиватися.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_distributed_data">Distributed Data</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-cluster-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>У ситуаціях, коли можлива узгодженість є прийнятною, можна обмінюватися даними між вузлами в кластері Akka та приймати як читання, так і записи навіть під час поділення кластеру. Цього можна досягти, використовуючи безконфліктні репліковані типи даних (CRDT), де записи на різні вузли можуть відбуватися одночасно і після цього поєднуватись передбачуваним способом. Модуль розподілених даних забезпечує інфраструктуру для обміну даними та низкою корисних типів даних.</p></div>
<div class="paragraph"><p>Розподілені дані призначені для вирішення таких завдань:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як прийняти записи навіть при розділенні кластеру.
</p>
</li>
<li>
<p>
Як обмінюватися даними, одночасно забезпечуючи локальний доступ для читання та запису з низькою затримкою.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_streams">Streams</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-stream-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.1&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Актори є фундаментальною моделлю для конкурентності, але існують загальні шаблони, коли їх використання вимагає від користувача реалізації того самого знову і знову. Дуже поширеним є сценарій, коли ланцюжок або граф акторів повинні обробляти потенційно великий або нескінченний потік послідовних подій і належним чином координувати використання ресурсів, щоб швидші етапи обробки не переповнювали повільніші ланцюги або графи. Потоки забезпечують більш високий рівень абстрагування над акторами, що спрощує написання таких обробних мереж, обробку всіх тонких деталей у фоновому режимі та надання безпечної, типізованої, компонованої моделі програмування. Потоки - це також реалізація стандарту "Реактивні потоки", що дозволяє інтегруватися з усіма сторонніми реалізаціями цього стандарту.</p></div>
<div class="paragraph"><p>Потоки вирішують такі проблеми:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як керувати потоками подій або великими наборами даних з високою продуктивністю, використовуючи конкурентність і обмежуючи використання ресурсів.
</p>
</li>
<li>
<p>
Як зібрати багаторазові фрагменти подій/обробки даних у гнучкі конвеєри.
</p>
</li>
<li>
<p>
Як гнучко підключати асинхронні сервіси один до одного з високою продуктивністю.
</p>
</li>
<li>
<p>
Як забезпечити або використовувати інтерфейси, сумісні з Реактивними потоками, для взаємодії з бібліотеками третіх сторін.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_http">HTTP</h3>
<div class="paragraph"><p>Akka HTTP - це окремий від Akka модуль.</p></div>
<div class="paragraph"><p>Фактично стандартом надання віддалених API, внутрішніх чи зовнішніх, є HTTP. Akka надає бібліотеку для побудови або споживання таких HTTP-сервісів, надаючи набір інструментів для створення HTTP-служб (та їх обслуговування) та клієнта, який може використовуватися для споживання інших послуг. Ці інструменти особливо підходять для передачі та виведення великого набору даних або подій у режимі реального часу, використовуючи базову модель Akka Streams.</p></div>
<div class="paragraph"><p>Деякі проблеми, які вирішує HTTP:</p></div>
<div class="ulist"><ul>
<li>
<p>
Як ефективно піднести послуги системи або кластеру до зовнішнього світу через HTTP API.
</p>
</li>
<li>
<p>
Як передавати великі набори даних в та з системи за допомогою HTTP.
</p>
</li>
<li>
<p>
Як передавати потокові події в систему та з неї за допомогою HTTP.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="____3">Приклад використання модуля</h3>
<div class="paragraph"><p>Модулі Akka інтегруються разом. Наприклад, подумайте про великий набір бізнес-об’єктів зі станом, таких як документи або кошики для покупок, до яких користувачі веб-сайту отримують доступ. Якщо ви будете моделювати їх як розшарджені сутності, використовуючи Sharding та Persistent, вони будуть збалансовані по кластеру, який ви можете масштабувати за потребою. Вони будуть доступні під час піків, що надходять від рекламних кампаній або перед відпусткою, навіть якщо деякі системи виходять з ладу. Ви також можете приймати потік подій домену в режимі реального часу за допомогою Persistence Query та використовувати потоки для передачі їх у потоковий механізм Fast Data. Потім сприймайте вихід цього двигуна як Stream, маніпулюйте ним за допомогою операторів Akka Streams і виставляйте його як з'єднання з веб-сокетами, що обслуговуються набором серверів HTTP з балансом навантаження, розміщених вашим кластером, щоб живити ваш інструмент бізнес-аналітики в реальному часі.</p></div>
<div class="paragraph"><p>Ми сподіваємось, що цей попередній перегляд викликав інтерес! Наступна тема представляє приклад програми, яку ми будемо будувати у підручнику цього посібника.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-12-08 00:39:53 EET
</div>
</div>
</body>
</html>
