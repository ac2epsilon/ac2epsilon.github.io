<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__">Шаблони взаємодії</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="___">Інформація про модуль</h3>
<div class="paragraph"><p>Щоб використовувати Akka Actors, додайте таку залежність у свій проект:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%%</span> <span class="s">&quot;akka-actor-typed&quot;</span> <span class="o">%</span> <span class="s">&quot;2.6.5&quot;</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_">Вступ</h3>
<div class="paragraph"><p>Взаємодія з актором в Akka здійснюється через <code>ActorRef[T]</code>, де <code>T</code> - тип повідомлень, які актор приймає, також відомий як "протокол". Це гарантує, що акторові можна надсилати лише правильний вид повідомлень, а також, що ніхто інший, крім самого Актора, не може отримати доступ до внутрішніх справ екземпляра Актора.</p></div>
<div class="paragraph"><p>Обмін повідомленнями з акторами дотримується кількох загальних зразків, давайте переглянемо кожен із них.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Стріль і забудь</h3>
<div class="paragraph"><p>Принциповий спосіб взаємодії з актором - це <code>tell</code>, що є настільки поширеним, що має спеціальну символічну назву методу: <code>actRef ! message</code>. Надіслати повідомлення з <code>tell</code> можна безпечно з будь-якого потоку. <code>tell</code> є асинхронним, що означає, що метод повертається відразу. Після виконання заяви немає гарантії, що одержувач ще не обробив повідомлення. Це також означає, що немає ніякого способу дізнатися, чи було повідомлення отримано, обробка вдалася чи не вдалася.</p></div>
<div class="paragraph"><p>Приклад:</p></div>
<div class="imageblock">
<div class="content">
<img src="fire-forget.png" alt="fire-forget.png" />
</div>
</div>
<div class="paragraph"><p>За допомогою даного протоколу та поведінки актора:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Printer</span> <span class="o">{</span>

  <span class="k">case</span> <span class="k">class</span> <span class="nc">PrintMe</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">Behavior</span><span class="o">[</span><span class="kt">PrintMe</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Behaviors</span><span class="o">.</span><span class="n">receive</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="nc">PrintMe</span><span class="o">(</span><span class="n">message</span><span class="o">))</span> <span class="k">=&gt;</span>
        <span class="n">context</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
        <span class="nc">Behaviors</span><span class="o">.</span><span class="n">same</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Стріль і забудь виглядає так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="nc">Printer</span><span class="o">(),</span> <span class="s">&quot;fire-and-forget-sample&quot;</span><span class="o">)</span>

<span class="c1">// зауважте, як система також є актором верхнього рівня ref</span>
<span class="k">val</span> <span class="n">printer</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">[</span><span class="kt">Printer.PrintMe</span><span class="o">]</span> <span class="k">=</span> <span class="n">system</span>

<span class="c1">// це все стріль і забудь</span>
<span class="n">printer</span> <span class="o">!</span> <span class="nc">Printer</span><span class="o">.</span><span class="nc">PrintMe</span><span class="o">(</span><span class="s">&quot;message 1&quot;</span><span class="o">)</span>
<span class="n">printer</span> <span class="o">!</span> <span class="nc">Printer</span><span class="o">.</span><span class="nc">PrintMe</span><span class="o">(</span><span class="s">&quot;not message 2&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="sect4">
<h5 id="___2">Корисно, коли:</h5>
<div class="paragraph"><p>It is not critical to be sure that the message was processed
There is no way to act on non successful delivery or processing
We want to minimize the number of messages created to get higher throughput (sending a response would require creating twice the number of messages)</p></div>
</div>
<div class="sect4">
<h5 id="__2">Проблеми:</h5>
<div class="paragraph"><p>If the inflow of messages is higher than the actor can process the inbox will fill up and can in the worst case cause the JVM crash with an OutOfMemoryError
If the message gets lost, the sender will not know</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_request_response">Request-Response</h3>
<div class="paragraph"><p>Many interactions between actors require one or more response message being sent back from the receiving actor. A response message can be a result of a query, some form of acknowledgment that the message was received and processed or events that the request subscribed to.</p></div>
<div class="paragraph"><p>In Akka the recipient of responses has to be encoded as a field in the message itself, which the recipient can then use to send (tell) a response back.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>request-response.png</p></div>
<div class="paragraph"><p>With the following protocol:</p></div>
<div class="paragraph"><p>Scala
case class Request(query: String, replyTo: ActorRef[Response])
case class Response(result: String)
Java
The sender would use its own ActorRef[Response], which it can access through ActorContext.self, for the replyTo.</p></div>
<div class="paragraph"><p>Scala
cookieFabric ! CookieFabric.Request("give me cookies", context.self)
Java
On the receiving side the ActorRef[Response] can then be used to send one or more responses back:</p></div>
<div class="paragraph"><p>Scala
def apply(): Behaviors.Receive[Request] =
  Behaviors.receiveMessage[Request] {
    case Request(query, replyTo) &#8658;
      // &#8230; process query &#8230;
      replyTo ! Response(s"Here are the cookies for [$query]!")
      Behaviors.same
  }
Java
Useful when:</p></div>
<div class="paragraph"><p>Subscribing to an actor that will send many response messages back
Problems:</p></div>
<div class="paragraph"><p>Actors seldom have a response message from another actor as a part of their protocol (see adapted response)
It is hard to detect that a message request was not delivered or processed (see ask)
Unless the protocol already includes a way to provide context, for example a request id that is also sent in the response, it is not possible to tie an interaction to some specific context without introducing a new, separate, actor (see ask or per session child actor)
Adapted Response
Most often the sending actor does not, and should not, support receiving the response messages of another actor. In such cases we need to provide an ActorRef of the right type and adapt the response message to a type that the sending actor can handle.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>adapted-response.png</p></div>
<div class="paragraph"><p>Scala</p></div>
<div class="paragraph"><p>object Backend {
  sealed trait Request
  final case class StartTranslationJob(taskId: Int, site: URI, replyTo: ActorRef[Response]) extends Request</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  sealed trait Response
  final case class JobStarted(taskId: Int) extends Response
  final case class JobProgress(taskId: Int, progress: Double) extends Response
  final case class JobCompleted(taskId: Int, result: URI) extends Response
}</code></pre>
</div></div>
<div class="paragraph"><p>object Frontend {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Command
final case class Translate(site: URI, replyTo: ActorRef[URI]) extends Command
private final case class WrappedBackendResponse(response: Backend.Response) extends Command</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply(backend: ActorRef[Backend.Request]): Behavior[Command] =
  Behaviors.setup[Command] { context =&gt;
    val backendResponseMapper: ActorRef[Backend.Response] =
      context.messageAdapter(rsp =&gt; WrappedBackendResponse(rsp))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def active(inProgress: Map[Int, ActorRef[URI]], count: Int): Behavior[Command] = {
  Behaviors.receiveMessage[Command] {
    case Translate(site, replyTo) =&gt;
      val taskId = count + 1
      backend ! Backend.StartTranslationJob(taskId, site, backendResponseMapper)
      active(inProgress.updated(taskId, replyTo), taskId)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    case wrapped: WrappedBackendResponse =&gt;
      wrapped.response match {
        case Backend.JobStarted(taskId) =&gt;
          context.log.info("Started {}", taskId)
          Behaviors.same
        case Backend.JobProgress(taskId, progress) =&gt;
          context.log.info2("Progress {}: {}", taskId, progress)
          Behaviors.same
        case Backend.JobCompleted(taskId, result) =&gt;
          context.log.info2("Completed {}: {}", taskId, result)
          inProgress(taskId) ! result
          active(inProgress - taskId, count)
      }
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>      active(inProgress = Map.empty, count = 0)
    }
}
Java
You can register several message adapters for different message classes. It’s only possible to have one message adapter per message class to make sure that the number of adapters are not growing unbounded if registered repeatedly. That also means that a registered adapter will replace an existing adapter for the same message class.</code></pre>
</div></div>
<div class="paragraph"><p>A message adapter will be used if the message class matches the given class or is a subclass thereof. The registered adapters are tried in reverse order of their registration order, i.e. the last registered first.</p></div>
<div class="paragraph"><p>A message adapter (and the returned ActorRef) has the same lifecycle as the receiving actor. It’s recommended to register the adapters in a top level Behaviors.setup or constructor of AbstractBehavior but it’s possible to register them later if needed.</p></div>
<div class="paragraph"><p>The adapter function is running in the receiving actor and can safely access its state, but if it throws an exception the actor is stopped.</p></div>
<div class="paragraph"><p>Useful when:</p></div>
<div class="paragraph"><p>Translating between different actor message protocols
Subscribing to an actor that will send many response messages back
Problems:</p></div>
<div class="paragraph"><p>It is hard to detect that a message request was not delivered or processed (see ask)
Only one adaption can be made per response message type, if a new one is registered the old one is replaced, for example different target actors can’t have different adaption if they use the same response types, unless some correlation is encoded in the messages
Unless the protocol already includes a way to provide context, for example a request id that is also sent in the response, it is not possible to tie an interaction to some specific context without introducing a new, separate, actor
Request-Response with ask between two actors
In an interaction where there is a 1:1 mapping between a request and a response we can use ask on the ActorContext to interact with another actor.</p></div>
<div class="paragraph"><p>The interaction has two steps, first we need to construct the outgoing message, to do that we need an ActorRef[Response] to put as recipient in the outgoing message. The second step is to transform the successful Response or failure into a message that is part of the protocol of the sending actor.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>ask-from-actor.png</p></div>
<div class="paragraph"><p>Scala
object Hal {
  sealed trait Command
  case class OpenThePodBayDoorsPlease(replyTo: ActorRef[Response]) extends Command
  case class Response(message: String)</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def apply(): Behaviors.Receive[Hal.Command] =
    Behaviors.receiveMessage[Command] {
      case OpenThePodBayDoorsPlease(replyTo) =&gt;
        replyTo ! Response("I'm sorry, Dave. I'm afraid I can't do that.")
        Behaviors.same
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>object Dave {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Command
// this is a part of the protocol that is internal to the actor itself
private case class AdaptedResponse(message: String) extends Command</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply(hal: ActorRef[Hal.Command]): Behavior[Dave.Command] =
  Behaviors.setup[Command] { context =&gt;
    // asking someone requires a timeout, if the timeout hits without response
    // the ask is failed with a TimeoutException
    implicit val timeout: Timeout = 3.seconds</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// Note: The second parameter list takes a function `ActorRef[T] =&gt; Message`,
// as OpenThePodBayDoorsPlease is a case class it has a factory apply method
// that is what we are passing as the second parameter here it could also be written
// as `ref =&gt; OpenThePodBayDoorsPlease(ref)`
context.ask(hal, Hal.OpenThePodBayDoorsPlease) {
  case Success(Hal.Response(message)) =&gt; AdaptedResponse(message)
  case Failure(_)                     =&gt; AdaptedResponse("Request failed")
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// we can also tie in request context into an interaction, it is safe to look at
// actor internal state from the transformation function, but remember that it may have
// changed at the time the response arrives and the transformation is done, best is to
// use immutable state we have closed over like here.
val requestId = 1
context.ask(hal, Hal.OpenThePodBayDoorsPlease) {
  case Success(Hal.Response(message)) =&gt; AdaptedResponse(s"$requestId: $message")
  case Failure(_)                     =&gt; AdaptedResponse(s"$requestId: Request failed")
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>      Behaviors.receiveMessage {
        // the adapted message ends up being processed like any other
        // message sent to the actor
        case AdaptedResponse(message) =&gt;
          context.log.info("Got response from hal: {}", message)
          Behaviors.same
      }
    }
}
Java
The response adapting function is running in the receiving actor and can safely access its state, but if it throws an exception the actor is stopped.</code></pre>
</div></div>
<div class="paragraph"><p>Useful when:</p></div>
<div class="paragraph"><p>Single response queries
An actor needs to know that the message was processed before continuing
To allow an actor to resend if a timely response is not produced
To keep track of outstanding requests and not overwhelm a recipient with messages (“backpressure”)
Context should be attached to the interaction but the protocol does not support that (request id, what query the response was for)
Problems:</p></div>
<div class="paragraph"><p>There can only be a single response to one ask (see per session child Actor)
When ask times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact
Finding a good value for the timeout, especially when ask triggers chained asks in the receiving actor. You want a short timeout to be responsive and answer back to the requester, but at the same time you do not want to have many false positives
Request-Response with ask from outside an Actor
Sometimes you need to interact with actors from the outside of the actor system, this can be done with fire-and-forget as described above or through another version of ask that returns a Future[Response] that is either completed with a successful response or failed with a TimeoutException if there was no response within the specified timeout.</p></div>
<div class="paragraph"><p>To do this we use ask (or the symbolic ?) implicitly added to ActorRef by akka.actor.typed.scaladsl.AskPattern._ to send a message to an actor and get a Future[Response] back. ask takes implicit Timeout and ActorSystem parameters.
Example:</p></div>
<div class="paragraph"><p>ask-from-outside.png</p></div>
<div class="paragraph"><p>Scala
object CookieFabric {
  sealed trait Command {}
  case class GiveMeCookies(count: Int, replyTo: ActorRef[Reply]) extends Command</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Reply
case class Cookies(count: Int) extends Reply
case class InvalidRequest(reason: String) extends Reply</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def apply(): Behaviors.Receive[CookieFabric.GiveMeCookies] =
    Behaviors.receiveMessage { message =&gt;
      if (message.count &gt;= 5)
        message.replyTo ! InvalidRequest("Too many cookies.")
      else
        message.replyTo ! Cookies(message.count)
      Behaviors.same
    }
}</code></pre>
</div></div>
<div class="paragraph"><p>import akka.actor.typed.scaladsl.AskPattern._
import akka.util.Timeout</p></div>
<div class="paragraph"><p>implicit val timeout: Timeout = 3.seconds

implicit val system: ActorSystem[_] = theSystem</p></div>
<div class="paragraph"><p>val result: Future[CookieFabric.Reply] = cookieFabric.ask(ref &#8658; CookieFabric.GiveMeCookies(3, ref))</p></div>
<div class="paragraph"><p>implicit val ec = system.executionContext</p></div>
<div class="paragraph"><p>result.onComplete {
  case Success(CookieFabric.Cookies(count))         &#8658; println(s"Yay, $count cookies!")
  case Success(CookieFabric.InvalidRequest(reason)) &#8658; println(s"No cookies for me. $reason")
  case Failure(ex)                                  &#8658; println(s"Boo! didn&#8217;t get cookies: ${ex.getMessage}")
}
Java
Note that validation errors are also explicit in the message protocol. The GiveMeCookies request can reply with Cookies or InvalidRequest. The requestor has to decide how to handle an InvalidRequest reply. Sometimes it should be treated as a failed Future and for that the reply can be mapped on the requestor side.</p></div>
<div class="paragraph"><p>Scala
val cookies: Future[CookieFabric.Cookies] =
  cookieFabric.ask[CookieFabric.Reply](ref &#8658; CookieFabric.GiveMeCookies(3, ref)).flatMap {
    case c: CookieFabric.Cookies             &#8658; Future.successful(c)
    case CookieFabric.InvalidRequest(reason) &#8658; Future.failed(new IllegalArgumentException(reason))
  }</p></div>
<div class="paragraph"><p>cookies.onComplete {
  case Success(CookieFabric.Cookies(count)) &#8658; println(s"Yay, $count cookies!")
  case Failure(ex)                          &#8658; println(s"Boo! didn&#8217;t get cookies: ${ex.getMessage}")
}
Java
Useful when:</p></div>
<div class="paragraph"><p>Querying an actor from outside of the actor system
Problems:</p></div>
<div class="paragraph"><p>It is easy to accidentally close over and unsafely mutable state with the callbacks on the returned Future as those will be executed on a different thread
There can only be a single response to one ask (see per session child Actor)
When ask times out, the receiving actor does not know and may still process it to completion, or even start processing it after the fact
Ignoring replies
In some situations an actor has a response for a particular request message but you are not interested in the response. In this case you can pass system.ignoreRef turning the request-response into a fire-and-forget.</p></div>
<div class="paragraph"><p>system.ignoreRef, as the name indicates, returns an ActorRef that ignores any message sent to it.</p></div>
<div class="paragraph"><p>With the same protocol as the request response above, if the sender would prefer to ignore the reply it could pass system.ignoreRef for the replyTo, which it can access through ActorContext.system.ignoreRef.</p></div>
<div class="paragraph"><p>Scala
cookieFabric ! CookieFabric.Request("don&#8217;t send cookies back", context.system.ignoreRef)
Java
Useful when:</p></div>
<div class="paragraph"><p>Sending a message for which the protocol defines a reply, but you are not interested in getting the reply
Problems:</p></div>
<div class="paragraph"><p>The returned ActorRef ignores all messages sent to it, therefore it should be used carefully.</p></div>
<div class="paragraph"><p>Passing it around inadvertently as if it was a normal ActorRef may result in broken actor-to-actor interactions.
Using it when performing an ask from outside the Actor System will cause the Future returned by the ask to timeout since it will never complete.
Finally, it’s legal to watch it, but since it’s of a special kind, it never terminates and therefore you will never receive a Terminated signal from it.
Send Future result to self
When using an API that returns a Future from an actor it’s common that you would like to use the value of the response in the actor when the Future is completed. For this purpose the ActorContext provides a pipeToSelf method.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>pipe-to-self.png</p></div>
<div class="paragraph"><p>An actor, CustomerRepository, is invoking a method on CustomerDataAccess that returns a Future.</p></div>
<div class="paragraph"><p>Scala</p></div>
<div class="paragraph"><p>trait CustomerDataAccess {
  def update(value: Customer): Future[Done]
}</p></div>
<div class="paragraph"><p>final case class Customer(id: String, version: Long, name: String, address: String)</p></div>
<div class="paragraph"><p>object CustomerRepository {
  sealed trait Command</p></div>
<div class="literalblock">
<div class="content">
<pre><code>final case class Update(value: Customer, replyTo: ActorRef[UpdateResult]) extends Command
sealed trait UpdateResult
final case class UpdateSuccess(id: String) extends UpdateResult
final case class UpdateFailure(id: String, reason: String) extends UpdateResult
private final case class WrappedUpdateResult(result: UpdateResult, replyTo: ActorRef[UpdateResult])
    extends Command</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>private val MaxOperationsInProgress = 10</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply(dataAccess: CustomerDataAccess): Behavior[Command] = {
  next(dataAccess, operationsInProgress = 0)
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>private def next(dataAccess: CustomerDataAccess, operationsInProgress: Int): Behavior[Command] = {
  Behaviors.receive { (context, command) =&gt;
    command match {
      case Update(value, replyTo) =&gt;
        if (operationsInProgress == MaxOperationsInProgress) {
          replyTo ! UpdateFailure(value.id, s"Max $MaxOperationsInProgress concurrent operations supported")
          Behaviors.same
        } else {
          val futureResult = dataAccess.update(value)
          context.pipeToSelf(futureResult) {
            // map the Future value to a message, handled by this actor
            case Success(_) =&gt; WrappedUpdateResult(UpdateSuccess(value.id), replyTo)
            case Failure(e) =&gt; WrappedUpdateResult(UpdateFailure(value.id, e.getMessage), replyTo)
          }
          // increase operationsInProgress counter
          next(dataAccess, operationsInProgress + 1)
        }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>        case WrappedUpdateResult(result, replyTo) =&gt;
          // send result to original requestor
          replyTo ! result
          // decrease operationsInProgress counter
          next(dataAccess, operationsInProgress - 1)
      }
    }
  }
}
Java
It could be tempting to just use onComplete on the Future, but that introduces the risk of accessing internal state of the actor that is not thread-safe from an external thread. For example, the numberOfPendingOperations counter in above example can’t be accessed from such callback. Therefore it is better to map the result to a message and perform further processing when receiving that message.</code></pre>
</div></div>
<div class="paragraph"><p>Useful when:</p></div>
<div class="paragraph"><p>Accessing APIs that are returning Future from an actor, such as a database or an external service
The actor needs to continue processing when the Future has completed
Keep context from the original request and use that when the Future has completed, for example an replyTo actor reference
Problems:</p></div>
<div class="paragraph"><p>Boilerplate of adding wrapper messages for the results
Per session child Actor
In some cases a complete response to a request can only be created and sent back after collecting multiple answers from other actors. For these kinds of interaction it can be good to delegate the work to a per “session” child actor. The child could also contain arbitrary logic to implement retrying, failing on timeout, tail chopping, progress inspection etc.</p></div>
<div class="paragraph"><p>Note that this is essentially how ask is implemented, if all you need is a single response with a timeout it is better to use ask.</p></div>
<div class="paragraph"><p>The child is created with the context it needs to do the work, including an ActorRef that it can respond to. When the complete result is there the child responds with the result and stops itself.</p></div>
<div class="paragraph"><p>As the protocol of the session actor is not a public API but rather an implementation detail of the parent actor, it may not always make sense to have an explicit protocol and adapt the messages of the actors that the session actor interacts with. For this use case it is possible to express that the actor can receive any message (Any).</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>per-session-child.png</p></div>
<div class="paragraph"><p>Scala

case class Keys()
case class Wallet()</p></div>
<div class="paragraph"><p>object Home {
  sealed trait Command
  case class LeaveHome(who: String, replyTo: ActorRef[ReadyToLeaveHome]) extends Command
  case class ReadyToLeaveHome(who: String, keys: Keys, wallet: Wallet)</p></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply(): Behavior[Command] = {
  Behaviors.setup[Command] { context =&gt;
    val keyCabinet: ActorRef[KeyCabinet.GetKeys] = context.spawn(KeyCabinet(), "key-cabinet")
    val drawer: ActorRef[Drawer.GetWallet] = context.spawn(Drawer(), "drawer")</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    Behaviors.receiveMessage[Command] {
      case LeaveHome(who, replyTo) =&gt;
        context.spawn(prepareToLeaveHome(who, replyTo, keyCabinet, drawer), s"leaving-$who")
        Behaviors.same
    }
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// per session actor behavior
def prepareToLeaveHome(
    whoIsLeaving: String,
    replyTo: ActorRef[ReadyToLeaveHome],
    keyCabinet: ActorRef[KeyCabinet.GetKeys],
    drawer: ActorRef[Drawer.GetWallet]): Behavior[NotUsed] = {
  // we don't _really_ care about the actor protocol here as nobody will send us
  // messages except for responses to our queries, so we just accept any kind of message
  // but narrow that to more limited types when we interact
  Behaviors
    .setup[AnyRef] { context =&gt;
      var wallet: Option[Wallet] = None
      var keys: Option[Keys] = None</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// we narrow the ActorRef type to any subtype of the actual type we accept
keyCabinet ! KeyCabinet.GetKeys(whoIsLeaving, context.self.narrow[Keys])
drawer ! Drawer.GetWallet(whoIsLeaving, context.self.narrow[Wallet])</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def nextBehavior(): Behavior[AnyRef] =
  (keys, wallet) match {
    case (Some(w), Some(k)) =&gt;
      // we got both, "session" is completed!
      replyTo ! ReadyToLeaveHome(whoIsLeaving, w, k)
      Behaviors.stopped</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  case _ =&gt;
    Behaviors.same
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>        Behaviors.receiveMessage {
          case w: Wallet =&gt;
            wallet = Some(w)
            nextBehavior()
          case k: Keys =&gt;
            keys = Some(k)
            nextBehavior()
          case _ =&gt;
            Behaviors.unhandled
        }
      }
      .narrow[NotUsed] // we don't let anyone else know we accept anything
  }
}
Java
In an actual session child you would likely want to include some form of timeout as well (see scheduling messages to self).</code></pre>
</div></div>
<div class="paragraph"><p>Useful when:</p></div>
<div class="paragraph"><p>A single incoming request should result in multiple interactions with other actors before a result can be built, for example aggregation of several results
You need to handle acknowledgement and retry messages for at-least-once delivery
Problems:</p></div>
<div class="paragraph"><p>Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped
It increases complexity, since each such child can execute concurrently with other children and the parent
General purpose response aggregator
This is similar to above Per session child Actor pattern. Sometimes you might end up repeating the same way of aggregating replies and want to extract that to a reusable actor.</p></div>
<div class="paragraph"><p>There are many variations of this pattern and that is the reason this is provided as a documentation example rather than a built in Behavior in Akka. It is intended to be adjusted to your specific needs.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>aggregator.png</p></div>
<div class="paragraph"><p>This example is an aggregator of expected number of replies. Requests for quotes are sent with the given sendRequests function to the two hotel actors, which both speak different protocols. When both expected replies have been collected they are aggregated with the given aggregateReplies function and sent back to the replyTo. If replies don’t arrive within the timeout the replies so far are aggregated and sent back to the replyTo.</p></div>
<div class="paragraph"><p>Scala
object Hotel1 {
  final case class RequestQuote(replyTo: ActorRef[Quote])
  final case class Quote(hotel: String, price: BigDecimal)
}
object Hotel2 {
  final case class RequestPrice(replyTo: ActorRef[Price])
  final case class Price(hotel: String, price: BigDecimal)
}</p></div>
<div class="paragraph"><p>type Reply = Any</p></div>
<div class="paragraph"><p>object HotelCustomer {
  sealed trait Command
  final case class Quote(hotel: String, price: BigDecimal)
  final case class AggregatedQuotes(quotes: List[Quote]) extends Command</p></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply(hotel1: ActorRef[Hotel1.RequestQuote], hotel2: ActorRef[Hotel2.RequestPrice]): Behavior[Command] = {</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>Behaviors.setup[Command] { context =&gt;
  context.spawnAnonymous(
    Aggregator[Reply, AggregatedQuotes](
      sendRequests = { replyTo =&gt;
        hotel1 ! Hotel1.RequestQuote(replyTo)
        hotel2 ! Hotel2.RequestPrice(replyTo)
      },
      expectedReplies = 2,
      context.self,
      aggregateReplies = replies =&gt;
        // The hotels have different protocols with different replies,
        // convert them to `HotelCustomer.Quote` that this actor understands.
        AggregatedQuotes(
          replies
            .map {
              case Hotel1.Quote(hotel, price) =&gt; Quote(hotel, price)
              case Hotel2.Price(hotel, price) =&gt; Quote(hotel, price)
            }
            .sortBy(_.price)
            .toList),
      timeout = 5.seconds))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>      Behaviors.receiveMessage {
        case AggregatedQuotes(quotes) =&gt;
          context.log.info("Best {}", quotes.headOption.getOrElse("Quote N/A"))
          Behaviors.same
      }
    }
  }
}
Java
The implementation of the Aggregator:</code></pre>
</div></div>
<div class="paragraph"><p>Scala
import scala.collection.immutable
import scala.concurrent.duration.FiniteDuration
import scala.reflect.ClassTag</p></div>
<div class="paragraph"><p>import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors</p></div>
<div class="paragraph"><p>object Aggregator {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Command
private case object ReceiveTimeout extends Command
private case class WrappedReply[R](reply: R) extends Command</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply[Reply: ClassTag, Aggregate](
    sendRequests: ActorRef[Reply] =&gt; Unit,
    expectedReplies: Int,
    replyTo: ActorRef[Aggregate],
    aggregateReplies: immutable.IndexedSeq[Reply] =&gt; Aggregate,
    timeout: FiniteDuration): Behavior[Command] = {
  Behaviors.setup { context =&gt;
    context.setReceiveTimeout(timeout, ReceiveTimeout)
    val replyAdapter = context.messageAdapter[Reply](WrappedReply(_))
    sendRequests(replyAdapter)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def collecting(replies: immutable.IndexedSeq[Reply]): Behavior[Command] = {
  Behaviors.receiveMessage {
    case WrappedReply(reply: Reply) =&gt;
      val newReplies = replies :+ reply
      if (newReplies.size == expectedReplies) {
        val result = aggregateReplies(newReplies)
        replyTo ! result
        Behaviors.stopped
      } else
        collecting(newReplies)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    case ReceiveTimeout =&gt;
      val aggregate = aggregateReplies(replies)
      replyTo ! aggregate
      Behaviors.stopped
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    collecting(Vector.empty)
  }
}</code></pre>
</div></div>
<div class="paragraph"><p>}
Java
Useful when:</p></div>
<div class="paragraph"><p>Aggregating replies are performed in the same way at multiple places and should be extracted to a more general purpose actor.
A single incoming request should result in multiple interactions with other actors before a result can be built, for example aggregation of several results
You need to handle acknowledgement and retry messages for at-least-once delivery
Problems:</p></div>
<div class="paragraph"><p>Message protocols with generic types are difficult since the generic types are erased in runtime
Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped
It increases complexity, since each such child can execute concurrently with other children and the parent
Latency tail chopping
This is a variation of above General purpose response aggregator pattern.</p></div>
<div class="paragraph"><p>The goal of this algorithm is to decrease tail latencies (“chop off the tail latency”) in situations where multiple destination actors can perform the same piece of work, and where an actor may occasionally respond more slowly than expected. In this case, sending the same work request (also known as a “backup request”) to another actor results in decreased response time - because it’s less probable that multiple actors are under heavy load simultaneously. This technique is explained in depth in Jeff Dean’s presentation on Achieving Rapid Response Times in Large Online Services.</p></div>
<div class="paragraph"><p>There are many variations of this pattern and that is the reason this is provided as a documentation example rather than a built in Behavior in Akka. It is intended to be adjusted to your specific needs.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>tail-chopping.png</p></div>
<div class="paragraph"><p>Scala
import scala.concurrent.duration.FiniteDuration
import scala.reflect.ClassTag</p></div>
<div class="paragraph"><p>import akka.actor.typed.ActorRef
import akka.actor.typed.Behavior
import akka.actor.typed.scaladsl.Behaviors</p></div>
<div class="paragraph"><p>object TailChopping {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Command
private case object RequestTimeout extends Command
private case object FinalTimeout extends Command
private case class WrappedReply[R](reply: R) extends Command</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def apply[Reply: ClassTag](
    sendRequest: (Int, ActorRef[Reply]) =&gt; Boolean,
    nextRequestAfter: FiniteDuration,
    replyTo: ActorRef[Reply],
    finalTimeout: FiniteDuration,
    timeoutReply: Reply): Behavior[Command] = {
  Behaviors.setup { context =&gt;
    Behaviors.withTimers { timers =&gt;
      val replyAdapter = context.messageAdapter[Reply](WrappedReply(_))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def waiting(requestCount: Int): Behavior[Command] = {
  Behaviors.receiveMessage {
    case WrappedReply(reply: Reply) =&gt;
      replyTo ! reply
      Behaviors.stopped</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>case RequestTimeout =&gt;
  sendNextRequest(requestCount + 1)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    case FinalTimeout =&gt;
      replyTo ! timeoutReply
      Behaviors.stopped
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def sendNextRequest(requestCount: Int): Behavior[Command] = {
  if (sendRequest(requestCount, replyAdapter)) {
    timers.startSingleTimer(RequestTimeout, nextRequestAfter)
  } else {
    timers.startSingleTimer(FinalTimeout, finalTimeout)
  }
  waiting(requestCount)
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>      sendNextRequest(1)
    }
  }
}</code></pre>
</div></div>
<div class="paragraph"><p>}
Java
Useful when:</p></div>
<div class="paragraph"><p>Reducing higher latency percentiles and variations of latency are important
The “work” can be done more than once with the same result, e.g. a request to retrieve information
Problems:</p></div>
<div class="paragraph"><p>Increased load since more messages are sent and “work” is performed more than once
Can’t be used when the “work” is not idempotent and must only be performed once
Message protocols with generic types are difficult since the generic types are erased in runtime
Children have life cycles that must be managed to not create a resource leak, it can be easy to miss a scenario where the session actor is not stopped
Scheduling messages to self
The following example demonstrates how to use timers to schedule messages to an actor.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>timer.png</p></div>
<div class="paragraph"><p>The Buncher actor buffers a burst of incoming messages and delivers them as a batch after a timeout or when the number of batched messages exceeds a maximum size.</p></div>
<div class="paragraph"><p>Scala
object Buncher {</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed trait Command
final case class ExcitingMessage(message: String) extends Command
final case class Batch(messages: Vector[Command])
private case object Timeout extends Command
private case object TimerKey</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def apply(target: ActorRef[Batch], after: FiniteDuration, maxSize: Int): Behavior[Command] = {
    Behaviors.withTimers(timers =&gt; new Buncher(timers, target, after, maxSize).idle())
  }
}</code></pre>
</div></div>
<div class="paragraph"><p>class Buncher(
    timers: TimerScheduler[Buncher.Command],
    target: ActorRef[Buncher.Batch],
    after: FiniteDuration,
    maxSize: Int) {
  import Buncher._</p></div>
<div class="literalblock">
<div class="content">
<pre><code>private def idle(): Behavior[Command] = {
  Behaviors.receiveMessage[Command] { message =&gt;
    timers.startSingleTimer(TimerKey, Timeout, after)
    active(Vector(message))
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def active(buffer: Vector[Command]): Behavior[Command] = {
    Behaviors.receiveMessage[Command] {
      case Timeout =&gt;
        target ! Batch(buffer)
        idle()
      case m =&gt;
        val newBuffer = buffer :+ m
        if (newBuffer.size == maxSize) {
          timers.cancel(TimerKey)
          target ! Batch(newBuffer)
          idle()
        } else
          active(newBuffer)
    }
  }
}
Java
There are a few things worth noting here:</code></pre>
</div></div>
<div class="paragraph"><p>To get access to the timers you start with Behaviors.withTimers that will pass a TimerScheduler instance to the function. This can be used with any type of Behavior, including receive, receiveMessage, but also setup or any other behavior.
Each timer has a key and if a new timer with the same key is started, the previous is cancelled. It is guaranteed that a message from the previous timer is not received, even if it was already enqueued in the mailbox when the new timer was started.
Both periodic and single message timers are supported.
The TimerScheduler is mutable in itself, because it performs and manages the side effects of registering the scheduled tasks.
The TimerScheduler is bound to the lifecycle of the actor that owns it and is cancelled automatically when the actor is stopped.
Behaviors.withTimers can also be used inside Behaviors.supervise and it will automatically cancel the started timers correctly when the actor is restarted, so that the new incarnation will not receive scheduled messages from a previous incarnation.
Schedule periodically
Scheduling of recurring messages can have two different characteristics:</p></div>
<div class="paragraph"><p>fixed-delay - The delay between sending subsequent messages will always be (at least) the given delay. Use startTimerWithFixedDelay.
fixed-rate - The frequency of execution over time will meet the given interval. Use startTimerAtFixedRate.
If you are uncertain of which one to use you should pick startTimerWithFixedDelay.</p></div>
<div class="paragraph"><p>When using fixed-delay it will not compensate the delay between messages if the scheduling is delayed longer than specified for some reason. The delay between sending subsequent messages will always be (at least) the given delay. In the long run, the frequency of messages will generally be slightly lower than the reciprocal of the specified delay.</p></div>
<div class="paragraph"><p>Fixed-delay execution is appropriate for recurring activities that require “smoothness.” In other words, it is appropriate for activities where it is more important to keep the frequency accurate in the short run than in the long run.</p></div>
<div class="paragraph"><p>When using fixed-rate it will compensate the delay for a subsequent task if the previous messages were delayed too long. In such cases, the actual sending interval will differ from the interval passed to the scheduleAtFixedRate method.</p></div>
<div class="paragraph"><p>If the tasks are delayed longer than the interval, the subsequent message will be sent immediately after the prior one. This also has the consequence that after long garbage collection pauses or other reasons when the JVM was suspended all “missed” tasks will execute when the process wakes up again. For example, scheduleAtFixedRate with an interval of 1 second and the process is suspended for 30 seconds will result in 30 messages being sent in rapid succession to catch up. In the long run, the frequency of execution will be exactly the reciprocal of the specified interval.</p></div>
<div class="paragraph"><p>Fixed-rate execution is appropriate for recurring activities that are sensitive to absolute time or where the total time to perform a fixed number of executions is important, such as a countdown timer that ticks once every second for ten seconds.</p></div>
<div class="paragraph"><p>Warning
scheduleAtFixedRate can result in bursts of scheduled messages after long garbage collection pauses, which may in worst case cause undesired load on the system. scheduleWithFixedDelay is often preferred.</p></div>
<div class="paragraph"><p>Responding to a sharded actor
When Akka Cluster is used to shard actors you need to take into account that an actor may move or get passivated.</p></div>
<div class="paragraph"><p>The normal pattern for expecting a reply is to include an ActorRef in the message, typically a message adapter. This can be used for a sharded actor but if ctx.self is sent and the sharded actor is moved or passivated then the reply will sent to dead letters.</p></div>
<div class="paragraph"><p>An alternative is to send the entityId in the message and have the reply sent via sharding.</p></div>
<div class="paragraph"><p>Example:</p></div>
<div class="paragraph"><p>sharded-response.png</p></div>
<div class="paragraph"><p>Scala

object CounterConsumer {
  sealed trait Command
  final case class NewCount(count: Long) extends Command
  val TypeKey: EntityTypeKey[Command] = EntityTypeKey[Command]("example-sharded-response")
}</p></div>
<div class="paragraph"><p>object Counter {
  trait Command
  case object Increment extends Command
  final case class GetValue(replyToEntityId: String) extends Command
  val TypeKey: EntityTypeKey[Command] = EntityTypeKey[Command]("example-sharded-counter")</p></div>
<div class="literalblock">
<div class="content">
<pre><code>private def apply(): Behavior[Command] =
  Behaviors.setup { context =&gt;
    counter(ClusterSharding(context.system), 0)
  }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>private def counter(sharding: ClusterSharding, value: Long): Behavior[Command] =
  Behaviors.receiveMessage {
    case Increment =&gt;
      counter(sharding, value + 1)
    case GetValue(replyToEntityId) =&gt;
      val replyToEntityRef = sharding.entityRefFor(CounterConsumer.TypeKey, replyToEntityId)
      replyToEntityRef ! CounterConsumer.NewCount(value)
      Behaviors.same
  }</code></pre>
</div></div>
<div class="paragraph"><p>}
Java
A disadvantage is that a message adapter can’t be used so the response has to be in the protocol of the actor being responded to. Additionally the EntityTypeKey could be included in the message if it is not known statically.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2020-06-08 01:31:42 EEST
</div>
</div>
</body>
</html>
