include::header.adoc[]

== Термінологія, поняття

У цій главі ми намагаємося створити загальну термінологію, щоб визначити міцний грунт для спілкування про одночасні, розподілені системи, на які орієнтується Акка. Зверніть увагу, що для багатьох цих термінів не існує єдиного узгодженого визначення. Ми прагнемо дати робочі визначення, які будуть використані в рамках документації Akka.

=== Конкурентність проти паралелізму

Конкурентність і паралелізм є суміжними поняттями, але існують невеликі відмінності. Конкурентність означає, що два чи більше завдань досягають прогресу, хоча вони можуть не виконуватись одночасно. Наприклад, це може бути реалізовано за допомогою розподілу часу, коли частини завдань виконуються послідовно і змішуються з частинами інших завдань. З іншого боку, паралелізм виникає тоді, коли виконання може бути справді одночасним.

=== Асинхронний проти Синхронний

Виклик методу вважається синхронним, якщо абонент не може досягти прогресу, поки метод не поверне значення або не закине виняток. З іншого боку, асинхронний виклик дозволяє абоненту прогресувати після обмеженої кількості кроків, і про завершення методу може бути сигналізовано через якийсь додатковий механізм (це може бути зареєстрований зворотний виклик, `Future` або повідомлення).

Синхронний API може використовувати блокування для реалізації синхронії, але це не є необхідністю. Дуже інтенсивне завантаження процесора може спричинити подібну поведінку, як блокування. Взагалі переважніше використовувати асинхронні API, оскільки вони гарантують, що система здатна прогресувати. Актори асинхронні за своєю суттю: актор може прогресувати після надсилання повідомлення, не чекаючи, коли відбудеться фактична доставка.

=== Неблокування проти блокування

Ми говоримо про блокування, якщо затримка однієї нитки може невизначено затримувати деякі інші потоки. Хороший приклад - ресурс, який може використовуватися виключно одним потоком, використовуючи взаємне виключення. Якщо потік нескінченно тримається на ресурсі (наприклад, випадково запущений нескінченний цикл), інші потоки, що чекають на ресурсі, не можуть прогресувати. Навпаки, незаблокування означає, що жодна нитка не здатна безстроково затримувати інших.

Неблокуючі операції мають перевагу над блокуючими, оскільки загальний прогрес системи не є тривіально гарантованим, коли він містить операції блокування.

=== Тупик проти голодування та живого блокування

Тупик виникає, коли кілька учасників чекають один одного, щоб досягти певного стану, щоб мати можливість прогресувати. Оскільки жоден з них не може прогресувати без іншого учасника, щоб досягти певного стану (проблема "Catch-22") всі дотичні підсистеми зупиняються. Тупик тісно пов'язаний з блокуванням, оскільки необхідно, щоб потік-учасник мав можливість затримувати просування інших потоків на невизначений термін.

У випадку тупика жоден учасник не може досягти прогресу, тоді як, на відміну, під час голодування трапляється, коли є учасники, які можуть досягти прогресу, але може бути один або кілька, які не можуть. Типовим сценарієм є алгоритм наївного планування, який завжди вибирає завдання з високим пріоритетом над невисокими пріоритетними. Якщо кількість вхідних завдань з високим пріоритетом постійно буде достатньо великою, жодне з низько-пріоритетними завданнями не буде завершено.

Livelock (живе блокування) схожий з тупиком, оскільки жоден з учасників не досягає успіху. Різниця, однак, полягає в тому, що замість того, щоб заморожуватися в стані очікування прогресування інших, учасники постійно змінюють свій стан. Приклад сценарію, коли двоє учасників мають два однакові ресурси. Кожен з них намагається отримати ресурс, але також перевіряє, чи потрібен інший ресурс. Якщо ресурс запитує інший учасник, він намагається отримати інший екземпляр ресурсу. У нещасному випадку може статися, що два учасники «стрибають» між двома ресурсами, ніколи не отримуючи його, завжди поступаючись іншому.

=== Стан гонки

Ми називаємо це умовою гонки, коли припущення про впорядкування набору подій можуть бути порушені зовнішніми недетермінованими ефектами. Умови перегонів часто виникають, коли кілька потоків мають загальний стан, що змінюється, і операції потоку над станом можуть бути переплетеними, викликаючи несподівану поведінку. Хоча це звичайний випадок, спільному стану не обов'язково мати перегони. Одним із прикладів може бути клієнт, який надсилає на сервер невпорядковані пакети (наприклад, дейтаграми UDP) P1, P2. Оскільки пакети можуть потенційно подорожувати різними мережевими маршрутами, можливо, сервер отримує спочатку P2 і P1 потім. Якщо повідомлення не містять інформації про їх порядок на відправку, серверу неможливо визначити, що вони були надіслані в іншому порядку. Залежно від значення пакетів це може спричинити перегони.

Примітка: Єдина гарантія, яку Акка надає щодо повідомлень, що надсилаються між певною парою акторів, - це те, що їх порядок завжди зберігається. див. Надійність доставки повідомлень

=== Неблокуючі гарантії (умови прогресу)

Як було сказано в попередніх розділах, блокування небажано з кількох причин, включаючи небезпеку тупикових ситуацій та зменшення пропускної здатності в системі. У наступних розділах ми обговорюємо різні неблокуючі властивості з різною міцністю.

==== Свобода від очікування

Метод не вимагає очікування, якщо гарантовано, що кожен виклик завершиться в кінцевій кількості кроків. Якщо метод обмежений без очікування, то кількість кроків має верхню межу.

З цього визначення випливає, що методи без очікування ніколи не блокуються, тому тупик не може статися. Крім того, оскільки кожен учасник може прогресувати після обмеженої кількості кроків (коли закінчується виклик), методи, які не чекають, не мають голодувати.

==== Свобода від блокування 

Свобода від блокування - слабша властивість, ніж свобода від очікування. У випадку неблокуючих викликів, нескінченно часто якийсь метод закінчується у визначеній кількості кроків. Це визначення означає, що жодний глухий кут не можливий для викликів без блокування. З іншого боку, гарантії того, що деякі виклики закінчуються в кінцевій кількості кроків, недостатньо для того, щоб гарантувати, що всі вони врешті-решт закінчать. Іншими словами, свободи від блокування недостатньо, щоб гарантувати відсутність голодування.

==== Свобода від перешкод

Свобода від перешкод - найслабша гарантія, що не блокує, яка обговорюється тут. Метод називається безперешкодним, якщо є момент часу, після якого він виконується ізольовано (інші потоки не роблять кроків, наприклад: стають призупиненими), і він закінчується обмеженою кількістю кроків. Усі об'єкти без блокувань не мають перешкод, але навпаки, як правило, не вірно.

Методи оптимістичного контролю за одночасністю (OCC) зазвичай не мають перешкод. Підхід OCC полягає в тому, що кожен учасник намагається виконати свою операцію над спільним об'єктом, але якщо учасник виявляє конфлікти з боку інших, він скасовує модифікації та повторює спробу за певним графіком. Якщо є момент часу, коли один із учасників залишається наодинці в спробах, операція буде успішною.

===== Рекомендована література

The Art of Multiprocessor Programming, M. Herlihy and N Shavit, 2008. ISBN 978-0123705914
Java Concurrency in Practice, B. Goetz, T. Peierls, J. Bloch, J. Bowbeer, D. Holmes and D. Lea, 2006. ISBN 978-0321349606

== Системи акторів

Актори - це об'єкти, які інкапсулюють стан та поведінку, вони спілкуються виключно, обмінюючись повідомленнями, які розміщуються у поштовій скриньці одержувача. У певному сенсі актори є найсуворішою формою об’єктно-орієнтованого програмування, але це краще для їх розгляду як людей: моделюючи рішення з акторами, передбачте групу людей і призначте їм підзадачі, упорядкуйте їх функції в організаційну структуру і подумайте про те, як повідомляти про невдачу (все з вигодою насправді не мати стосунків з людьми, це означає, що нам не потрібно стосуватися їх емоційного стану чи моральних питань). Потім результат може слугувати розумовим підгрунтям для побудови програмного забезпечення.

Примітка: `ActorSystem` - це важка структура, яка виділить 1… N потоків, тому створіть по одній в кожній логічній програмі.

=== Ієрархічна структура

Як і в економічній організації, актори природно формують ієрархії. Один актор, який повинен контролювати певну функцію в програмі, може захотіти розділити своє завдання на більш дрібні, більш керовані частини. З цією метою він запускає дитячих акторів.

Найважливішою особливістю систем акторів є те, що завдання розбиваються та делегуються до тих пір, поки вони не стануть досить маленькими, щоб їх можна було вирішувати одним складом. При цьому не тільки сама структура чітко структурована, але й отримані суб'єкти можна проміркувати, з точки зору того, які повідомлення вони оброблятимуть, як вони повинні нормально реагувати та як повинна оброблятись невдача.

Порівняйте це з багатошаровим програмним забезпеченням, яке легко перетворюється на оборонне програмування з метою уникнути витіків жодних збоїв: якщо проблема буде донесена потрібній людині, можна знайти краще рішення, ніж якщо намагатися тримати все «під килимом».

Тепер складність проектування такої системи полягає в тому, щоб вирішити, як структурувати роботу. Не існує єдиного найкращого рішення, але є кілька рекомендацій, які можуть бути корисними:

* Якщо один актор несе в собі дуже важливі дані (тобто його стан не втрачається, якщо цього можна уникнути), цей актор повинен надсилати дітям будь-які можливі небезпечні підзадачі та обробляти недоліки цих дітей, якщо це необхідно. Залежно від характеру запитів, можливо, найкраще створити нову дитину для кожного запиту, що спрощує управління станом для збору відповідей. Це відоме як "шаблон Ядро помилки" від Erlang.

* Якщо один актор залежить від іншого актора для виконання своїх обов'язків, він повинен стежити за життям іншого актора і діяти після отримання повідомлення про його припинення.

* Якщо один актор має декілька обов'язків, кожну відповідальність часто можна перекласти на окрему дитину, щоб зробити логіку та стан більш простим.

=== Конфігурація контейнера

Система акторів, як колектив співпрацюючих акторів, є природним підрозділом для управління спільними об'єктами, такими як служби планування, конфігурація, ведення журналів тощо. Кілька акторських систем з різною конфігурацією можуть співіснувати в одному JVM без проблем, немає розподіленого загального стану У самій Akka. Однак, найпоширеніший сценарій передбачає лише єдину акторську систему на JVM.

У поєднанні з прозорим зв’язком між акторськими системами - в межах одного вузла або через мережеве з'єднання - і акторські системи ідеально підходять для формування розподіленої програми.

=== Найкращі практики для актора

1. Актори повинні бути схожими на приємних колег: виконувати свою роботу ефективно, не турбуючи всіх інших без потреби і уникаючи захоплення ресурсів. У перекладі мовою програмування це означає обробляти події та генерувати відповіді (або більше запитів) в залежності від подій. Актори не повинні блокувати (тобто пасивно чекати, займаючи `Thread`) на якусь зовнішню сутність - яка може бути блокуванням, мережевим сокетом тощо - якщо це не неминуче; в останньому випадку див. нижче.

2. Не передавайте змінні об'єкти між акторами. Щоб переконатися в цьому, віддайте перевагу незмінним повідомленням. Якщо інкапсуляція акторів порушена шляхом викриття їх зовнішнього стану зовні, ви повернетесь у звичайну землю Java конкуренції з усіма недоліками.

3. Актори стають контейнерами для поведінки та стану, застосування цього означає не передачу поведінки по колу в повідомленнях (що може бути спокусливим із застосуванням замикань Scala). Одним із ризиків є випадковий поділ змінного стану між акторами, і це порушення акторської моделі, на жаль, порушує всі властивості, які роблять програмування в стилі акторів таким приємним досвідом.

4. Актор системи вищого рівня - це найглибша частина вашого Ядра помилок, він повинен відповідати лише за запуск різних підсистем вашої програми, а не містити в собі багато логіки. Віддайте перевагу справді ієрархічним системам. Це має переваги щодо поводження з помилками (як з огляду на деталізацію конфігурації, так і на продуктивність), а також зменшує навантаження на актора опікуна, що є єдиною точкою відмови при надмірному використанні.

=== Чим не варто себе турбувати

Система акторів керує ресурсами, які вона налаштована використовувати, для запуску акторів, які вона містить. У межах однієї такої системи може бути мільйони акторів, адже мантра розглядає їх як рясні, і вони важать лише біля 300 байт на екземпляр. Природно, точний порядок обробки повідомлень у великих системах не контролюється автором програми, але це також не передбачено. Зробіть крок назад і розслабтеся, поки Акка робить складну роботу за лаштунками.

=== Зупинка ActorSystem

Коли ви знаєте, що ваша програма завершила роботу, ви можете зупинити актора опікуна користувача або викликати метод припинення `terminate` на `ActorSystem`. Це запустить `CoordinatedShutdown`, зупинивши всіх діючих акторів.

Якщо ви хочете виконати деякі операції під час припинення `ActorSystem`, подивіться на `CoordinatedShutdown`.

== Що таке Actor?

Попередній розділ про Actor Systems пояснив, як актори формують ієрархії та є найменшою одиницею під час створення програми. Цей розділ розглядає одного такого актора ізольовано, пояснюючи концепції, з якими ви стикаєтесь під час його реалізації. Для більш детального ознайомлення з усіма подробицями зверніться до Вступу до акторів.

Модель актора, визначена Хьюїттом, Бішопом та Штейгером у 1973 році, - це обчислювальна модель, яка виражає саме те, що означає розподіл обчислень. Одиниці обчислень - Актори - можуть спілкуватися лише за допомогою обміну повідомленнями та після отримання повідомлення Актор може виконати такі три основні дії:

* надсилати обмежену кількість повідомлень акторам, яких він знає
* створити скінчену кількість нових акторів
* визначити поведінку, яку слід застосувати до наступного повідомлення

Актор є контейнером для стану, поведінки, поштової скриньки, дитячих акторів та стратегії супервайзера. Все це інкапсульовано за посиланням на актора. Одним із важливих аспектів є те, що актори мають чіткий життєвий цикл, вони не руйнуються автоматично, коли на них більше не посилаються; після того, як ви створили актора, ви несете відповідальність за те, щоб він врешті-решт був припинений - що також дає вам контроль над тим, як вивільняються ресурси, коли актор припиняється.

=== Посилання на актора

Як детально описано нижче, об’єкт актора потрібно захистити зовні, щоб мати користь від акторської моделі. Тому актори представлені назовні з використанням акторських посилань, які є предметами, які можна передавати  навколо вільно і без обмежень. Цей поділ на внутрішній та зовнішній об'єкт забезпечує прозорість для всіх бажаних операцій: перезапуск актора без необхідності оновлювати посилання в іншому місці, розміщення фактичного об’єкта актора на віддалених хостах, надсилання повідомлень акторам незалежно від місця їх запуску. Але найважливіший аспект полягає в тому, що неможливо зазирнути всередину актора і оволодіти його станом зовні, якщо тільки актор нерозумно не опублікує цю інформацію сам.

Посилання акторів параметризовані і на них можуть надсилатися лише повідомлення, що мають вказаний тип.

=== Стан

Об'єкти актора, як правило, містять деякі змінні, які відображають можливі стани, в яких може бути актор. Це може бути явна машина стану, або це лічильник, набір слухачів, очікувані запити тощо. Ці дані роблять актора цінним, і вони повинні бути захищені від ушкодження іншими суб'єктами. Гарна новина полягає в тому, що в акторів Akka концептуально кожен має власну легку нитку, яка повністю захищена від решти системи. Це означає, що замість того, щоб синхронізувати доступ за допомогою блокувань, ви можете написати свій акторський код, не турбуючись про конкурентність.

За лаштунками Акка запустить набори акторів на наборах реальних ниток, де зазвичай багато акторів поділяють одну нитку, і наступні виклики одного актора можуть в кінцевому підсумку оброблятися в різних потоках. Akka гарантує, що ця деталізація не впливає на одно-поточність керування станом актора.

Оскільки внутрішній стан є життєво важливим для діяльності актора, наявність непослідовного стану є фатальним. Таким чином, коли актор зазнає невдачі і перезапущений його супервізором, стан буде створений з нуля, як при першому створенні актора. Це для того, щоб забезпечити можливість самолікування системи.

За бажанням стан актора можна автоматично відновити до стану перед перезапуском, зберігаючи отримані повідомлення та відтворюючи їх після перезавантаження (див. Відновлення подій).

=== Поведінка

Щоразу, коли повідомлення обробляється, воно співвідноситься з поточною поведінкою актора. Поведінка означає функцію, яка визначає дії, які слід здійснити у відповідь на повідомлення в певний момент часу. Скажімо, переадресувати запит, якщо клієнт авторизований, і відмовити якщо ні. Така поведінка може змінюватися з часом, напр. тому що різні клієнти отримують дозвіл з часом або тому, що актор може перейти в режим «не обслуговується» і пізніше повернутися. Ці зміни досягаються шляхом кодування їх у змінних стану, які зчитуються з логіки поведінки. Або сама функція може бути замінена під час виконання, повертаючи іншу поведінку, яка буде використана для наступного повідомлення. Однак початкова поведінка, визначена під час побудови об’єкта актора, є особливою в тому сенсі, що перезапуск актора скине його поведінку до цієї початкової.

Повідомлення можуть бути надіслані на посилання актора, і за цим фасадом є поведінка, яка отримує повідомлення та діє на його основі. Зв'язок між посиланням на Актора і поведінкою може змінюватися з часом, але це не помітно зовні.

Посилання акторів параметризовані і на них можуть надсилатися лише повідомлення, що мають вказаний тип. Асоціація між посиланням на актора та його типом параметра повинна бути зроблена, коли створюється посилання на актора (та самого Актора). Для цього кожна поведінка також параметризується типом повідомлень, які вона здатна обробляти. Оскільки поведінка може змінюватися за фасадом посилання актора, позначення наступної поведінки є обмеженою операцією: наступник повинен обробляти той же тип повідомлень, що і його попередник. Це необхідно для того, щоб не визнати недійсними посилання, які посилаються на цього Актора.

Це дозволяє зробити те, що щоразу, коли повідомлення надсилається Акторові, ми можемо статистично переконатися, що тип повідомлення є таким, яким Актор заявляє, що обробляє - ми можемо уникнути помилки надсилання абсолютно безглуздих повідомлень. Однак ми не можемо статично забезпечити, що поведінка, що стоїть за посиланням на актора, буде в заданому стані, коли буде отримано наше повідомлення. Принципова причина полягає в тому, що зв'язок між посиланням актора та поведінкою є властивістю динамічного виконання, компілятор не може цього знати, перекладаючи вихідний код.

Це те саме, що і для звичайних об'єктів Java з внутрішніми змінними: при компілюванні програми ми не можемо знати, яке буде їх значення, і якщо результат виклику методу залежить від цих змінних, то результат певною мірою непевний - ми можемо лише бути впевненим, що повернене значення має заданий тип.

Тип повідомлення відповіді команди Actor описується типом посилання актора для відповіді, що міститься в повідомленні. Це дозволяє описувати розмову за її типами: відповідь буде типу A, але вона також може містити адресу типу B, яка потім дозволяє іншому Актору продовжувати розмову, надсилаючи повідомлення типу B на це нове посилання. Хоча ми не можемо статично виразити "поточний" стан Актора, ми можемо виразити поточний стан протоколу між двома Акторами, оскільки це просто задається останнім типом повідомлення, яке було отримано або надіслано.

=== Поштова скринька

Метою актора є обробка повідомлень, і ці повідомлення надсилаються актору від інших акторів (або ззовні акторської системи). Частина, яка з'єднує відправника та одержувача, - це поштова скринька актора: у кожного актора є рівно одна поштова скринька, до якої всі відправники передають свої повідомлення. Виємка відбувається в порядку виконання операцій надсилання, що означає, що повідомлення, надіслані різними суб'єктами, можуть не мати визначеного порядку під час виконання через очевидну випадковість розподілу акторів по потоках. Відправлення декількох повідомлень до однієї і тієї ж цілі від одного актора, з іншого боку, призведе до впорядкованої доставки.

Можна вибрати різні варіанти поштової скриньки, за замовчуванням - FIFO: порядок повідомлень, оброблених актором, відповідає порядку, в якому вони були введені. Зазвичай це хороший стандарт за замовчуванням, але програмам, можливо, доведеться розставити пріоритет одних повідомлень над іншими. У такому випадку поштова скринька з пріоритетом буде ставити в чергу не завжди в кінці, але в позиції, визначеній пріоритетом повідомлення, яка може бути навіть спереду. Під час використання такої черги порядок оброблюваних повідомлень, природно, визначатиметься алгоритмом черги і це, загалом, не FIFO.

Важливою особливістю, за якою Akka відрізняється від деяких інших реалізацій моделей актора, є те, що поточна поведінка завжди повинна обробляти наступне відмінене повідомлення, не існує сканування поштової скриньки для пошуку наступного. Відмова обробляти повідомлення, як правило, трактується як збій, якщо тільки ця поведінка не буде відмінена.

=== Дитячі актори

Кожен актор потенційно є батьком: якщо він створює дітей для делегування підзадач, він автоматично контролює їх. Список дітей підтримується в контексті актора, і актор має доступ до нього. Зміни списку здійснюються відгалуженням або зупиненням дітей, і ці дії відображаються негайно. Фактичні дії по створенню та припиненню відбуваються за кадром асинхронно, тому вони не «блокують» свого батька.

=== Стратегія супервізора

Остання частина актора - це його стратегія поводження з несподіваними винятками - невдачами. Обробка невдачі прозоро виконується Акка, застосовуючи одну з стратегій, описаних у "Толерантності відмов" для кожної відмови.

=== Коли Актор припиняється

Після того, як актор припиняється, тобто відмовляє таким чином, що не обробляє перезапуск, зупиняється сам або зупиняється його супервізором, він звільнить свої ресурси, витягнувши всі повідомлення, що залишилися зі своєї поштової скриньки, у «поштову скриньку мертвих листів» системи, яка пересилатиме їх у `EventStream` як `DeadLetters`. Потім поштову скриньку замінюють у посиланні актора на системну поштову скриньку, перенаправляючи всі нові повідомлення на `EventStream` як `DeadLetters`. Однак це робиться з найкращих зусиль, тому не покладайтеся на це, щоб побудувати «гарантовану доставку».

== Нагляд та моніторинг

У цій главі викладено поняття, що стоїть за наглядом, запропоновані примітиви та їх семантика. Для отримання детальної інформації про те, як це перетворюється в реальний код, зверніться до нагляду.

Нагляд змінився від класичного, детальніше про класичний нагляд див. у Класичному нагляді

=== Що означає нагляд

Є дві категорії винятку, які можуть статися у актора:

* Помилки перевірки введення, очікувані винятки, які можна обробляти звичайним `try`-`catch` або іншими інструментами мови та стандартної бібліотеки.
* Несподівані збої, наприклад, недоступний мережевий ресурс, помилка запису диска або, можливо, помилка в логіці програми.

Нагляд має справу з відмовами, і його слід відокремлювати від бізнес логіки, тоді як перевірка даних та обробка очікуваних винятків є важливою частиною бізнес-логіки. Тому нагляд додається до актора як декорація, а не щось, що переплітається з логікою обробки актора.

Залежно від характеру роботи, що підлягає нагляду, та характеру відмови, нагляд передбачає наступні три стратегії:

1. Відновіть актора, зберігаючи його накопичений внутрішній стан
2. Перезапуск актора, очистивши його накопичений внутрішній стан, з можливою затримкою, починаючи заново
3. Зупинка актора назавжди

Оскільки актори є частиною ієрархії, часто може мати сенс поширювати постійні невдачі вгору. Якщо всі діти актора несподівано зупинилися, може мати сенс перезапустити або зупинити самого актора, щоб повернутись до функціонального стану. Цього можна досягти за допомогою поєднання спостереження та нагляду за дітьми, щоб отримувати сповіщення про їх припинення. Приклад цього можна знайти в Просування збоїв вгору по ієрархії.

== Актори вищого рівня

Акторська система під час її створення запустить щонайменше двох акторів.

`/user`: користувацькій актор-охоронець
Це актор, який надає користувач верхнього рівня, призначений для завантаження програми за допомогою відгалуження підсистем у якості дітей. Коли охоронець користувача зупиняється, вся система акторів вимикається.

`/system`: системний актор-охоронець
Цей спеціальний охоронець був введений для того, щоб досягти впорядкованої послідовності вимкнення, коли ведення журналу залишається активним, поки всі нормальні актори припиняються. Навіть незважаючи на те, що реєстрація журналу здійснюється за допомогою акторів. Це реалізується наявністю системного охоронця, що спостерігає за користувацьким охоронцем, і ініціює своє власне відключення після того, коли побачив, що охоронець користувача зупинився.

=== Що означає перезапуск

Якщо представлені актором, який зазнав невдачі під час обробки певного повідомлення, причини відмови поділяються на три категорії:

1. Систематичні (тобто програмні) помилки для конкретного отриманого повідомлення
2. (Тимчасовий) збій якогось зовнішнього ресурсу, який використовується під час обробки повідомлення
3. Зруйнований внутрішній стан актора

Якщо відмова конкретно не визначається, третю причину не можна виключати, що призводить до висновку, що внутрішній стан потрібно зачистити. Якщо супервізор вирішить, що його інші діти або він сам не стали жертвою руйнування, тобто через свідоме застосування схеми ядра помилок - тоді краще перезапустити актора. Це здійснюється шляхом створення нового екземпляра базового класу поведінки та заміни невдалого екземпляра свіжим у дитячому `ActorRef`; можливість зробити це є однією з причин інкапсуляції акторів у спеціальні посилання. Потім новий актор поновлює обробку своєї поштової скриньки, що означає, що перезапуск не помітно поза межами самого актора, за винятком того, що повідомлення, під час якого сталася помилка, не буде оброблятися повторно.

=== Що означає моніторинг життєвого циклу

Примітка: Моніторинг життєвого циклу в Akka зазвичай називають DeathWatch

На відміну від описаних вище особливих відносин між батьком і дитиною, кожен актор може контролювати будь-якого іншого актора. Оскільки актори виходять із створення повністю живими, а перезавантаження не видно за межами дотичних супервізорів, єдиною зміною стану, доступною для моніторингу, є перехід від живих до мертвих. Таким чином, моніторинг використовується для прив’язки одного актора до іншого, щоб він міг реагувати на припинення іншого актора, на відміну від нагляду, який реагує на збій.

Моніторинг життєвого циклу реалізується за допомогою повідомлення про припинення, яке має отримати актор моніторингу. Поведінка за замовченням полягає у викиданні спеціального `DeathPactException`, якщо не оброблено іншим шляхом. Для того, щоб почати прослуховувати повідомлення `Terminated`, викликте `ActorContext.watch(targetActorRef)`. Щоб перестати слухати, запустіть `ActorContext.unwatch(targetActorRef)`. Важливою властивістю є те, що повідомлення буде доставлено незалежно від порядку, в якому відбувається запит моніторингу та припинення роботи цільового актора. Тобто ви все одно отримаєте повідомлення, навіть якщо на момент реєстрації ціль уже загинула.

=== Актори та винятки

Може трапитися так, що під час обробки актором повідомлення закидається  якийсь виняток, наприклад виняток із бази даних.

==== Що відбувається з повідомленням

Якщо виняток буде викинуто під час обробки повідомлення (тобто вийнято з поштової скриньки та передано поточній поведінці), це повідомлення буде втрачено. Важливо розуміти, що воно не повертається назад на поштову скриньку. Тож, якщо ви хочете спробувати обробити повідомлення, вам потрібно розібратися з ним самостійно, перехопивши виняток і повторивші дії знову. Переконайтеся, що ви обмежили кількість повторних спроб, оскільки не хочете, щоб система перейшла в живе блокування (витрачаючи багато процесорних циклів без прогресу).

==== Що відбувається з поштовою скринькою

Якщо під час обробки повідомлення закидається виняток, з поштовою скринькою нічого не відбувається. Якщо актор перезапущений, там буде та сама поштова скринька. Тож усі повідомлення в цій поштовій скриньці також будуть збережені.

==== Що відбувається з актором

Якщо код в рамках актора кидає виняток, цей актор призупиняється, і починається процес нагляду. Залежно від рішення супервізора, актор відновлюється (ніби нічого не сталося), перезапускається (затираючи свій внутрішній стан і починаючи з нуля) або припиняється.

== Посилання акторів, шляхи та адреси

У цій главі описано, як ідентифікуються та розміщуються актори в можливо розподіленій програмі Akka.

image::actor-paths-overview.png[]

Наведене вище зображення відображає взаємозв'язок між найважливішими сутностями в акторській системі. Будь ласка, прочитайте деталі.

=== Що таке посилання на актора

Посилання на актора - це підтип `ActorRef`, головна мета якого - підтримка надсилання повідомлень актору, якого він представляє. Кожен актор має доступ до свогої канонічного (локального) посилання через поле `ActorContext.self`; це посилання може бути включене у повідомлення іншим учасникам, щоб отримати відповіді.

Існує кілька різних типів посилань на акторів, які підтримуються залежно від конфігурації акторської системи:

* Суто локальні посилання акторів використовуються акторськими системами, які не налаштовані на підтримку мережевих  функцій. Ці посилання актора не працюватимуть, якщо вони надсилаються через мережеве з'єднання до віддаленої JVM.
* Локальні посилання на акторів при включеному віддаленні використовуються акторськими системами, які підтримують функції мережі для тих посилань, які представляють суб'єктів у межах одного JVM. Щоб вони також були доступні при надсиланні до інших вузлів мережі, ці посилання включають інформацію про протокол та віддалену адресацію.
* Віддалені посилання акторів представляють суб'єктів, доступних за допомогою віддаленого зв'язку, тобто надсилання до них повідомлень прозоро серіалізує повідомлення та надсилатиме їх у віддалену JVM.
* Існує кілька спеціальних типів посилань на акторів, які поводяться як місцеві акторські посилання для всіх практичних цілей:
** `PromiseActorRef` - це спеціальне представлення Обіцянки з метою завершення відповіді актора. `akka.pattern.ask` створює це посилання на актора.
** `DeadLetterActorRef` - це реалізація за замовчуванням служби листів з мертвими листами, на яку Акка пересилає всі повідомлення, пункти призначення яких вимкнено або відсутні.
** `EmptyLocalActorRef` - це те, що Акка повертає, шукаючи неіснуючий локальний шлях актора: він еквівалентний DeadLetterActorRef, але він зберігає свій шлях, щоб Акка міг пересилати його по мережі та порівнювати його з іншими існуючими посиланнями актора для цього шляху , деякі з яких могли бути отримані до смерті актора.
* Нарешті потім є кілька разових внутрішніх реалізацій, які ви ніколи не повинні бачити:
** Є посилання на актора, яке не представляє актора, а виступає лише псевдонаглядачем за кореневим охоронцем, ми називаємо його "тим, хто ходить бульбашками простору-часу".
** Перша послуга ведення журналу, запущена до фактичного запуску засобів створення акторів, є несправжнім посиланням на актора, яка приймає події журналу та друкує їх безпосередньо на стандартний вихід; це `Logging.StandardOutLogger`.

=== Що таке Акторський шлях?

Оскільки актори створені суворо ієрархічно, існує унікальна послідовність імен акторів, що задаються рекурсивно, дотримуючись зв'язків нагляду між дитиною та батьком вниз до кореня акторської системи. Ця послідовність може розглядатися як вкладання папок у файловій системі, отже, ми прийняли назву “шлях” для посилання на неї, хоча ієрархія акторів має деяку принципову відмінність від ієрархії файлової системи.

Шлях актора складається з якоря, який ідентифікує акторську систему з наступним конкатенацією елементів шляху, від кореня-охоронця до призначеного актора; елементи шляху - це імена пройдених акторів, розділені косою рисою.

==== Яка різниця між посиланням актора та шляхом?

Посилання актора позначає одного актора, а життєвий цикл посилання відповідає життєвому циклу актора; шлях актора являє собою ім'я, яке може бути або не бути існуючим актором, а сам шлях не має життєвого циклу, він ніколи не стає недійсним. Ви можете створити акторський шлях без створення актора, але ви не можете створити посилання на актора, не створивши відповідного актора.

Ви можете створити актора, припинити його, а потім створити нового актора з тим самим акторським шляхом. Новостворений актор - це нове втілення актора. Це не той самий актор. Посилання актора на старе втілення не є дійсним для нового втілення. Повідомлення, надіслані до старої посилання актора, не будуть доставлені до нового втілення, навіть якщо вони мають однаковий шлях.

==== Якорі акторського шляху

Кожен шлях актора має адресний компонент, що описує протокол і місце, за якими досяжний відповідний актор, а потім імена акторів в ієрархії від кореня вгору. Приклади:

----

"akka://my-sys/user/service-a/worker1"               // чисто локальний
"akka://my-sys@host.example.com:5678/user/service-b" // віддалений
----

Інтерпретація частини хоста та порту (тобто `host.example.comwhat678` у прикладі) залежить від використовуваного транспортного механізму, але він повинен дотримуватися структурних правил URI.

==== Логічні акторські шляхи

Унікальний шлях, отриманий при дотриманні посилань батьківського нагляду до кореневого опікуна, називається логічним акторським шляхом. Цей шлях точно відповідає походженню створення актора, тому він повністю детермінований, як тільки встановлюється конфігурація віддаленої акторської системи (а разом з нею і адресна складова шляху).

==== Псевдонім акторського шляху або символічне посилання?

Як і в деяких реальних файлових системах, ви можете думати про "псевдонім шляху" або "символічне посилання" для актора, тобто один актор може бути доступний, використовуючи більше одного шляху. Однак слід зазначити, що ієрархія акторів відрізняється від ієрархії файлової системи. Ви не можете вільно створювати акторські шляхи, як символічні зв'язки для посилання на довільних акторів.

=== Як отримуються посилання на актора?

Існує дві загальні категорії, як можна отримати посилання на акторів: створивши акторів або переглянувши їх через `Receptionist`.

=== Посилання актора та рівність шляху

Рівність `ActorRef` відповідає наміру того, що `ActorRef` відповідає втіленню цільового актора. Два посилання актора вважаються рівними, коли вони мають однаковий шлях і вказують на одне втілення актора. Посилання, що вказує на припиненого актора, не порівнюється як рівне з посиланням, що вказує на іншого (відтвореного) актора з тим самим шляхом. Зауважте, що перезапуск актора, спричинений невдачею, все ще означає, що це те саме втілення актора, тобто перезапуск не помітний для споживача `ActorRef`.

Якщо вам потрібно відслідковувати посилання на акторів у колекції та не піклуватися про точне втілення актора, ви можете використовувати `ActorPath` як ключ, оскільки ідентифікатор цільового актора не враховується при порівнянні шляхів актора.

=== Повторне використання акторських шляхів
Коли актора припиняють, його посилання вказуватиме на поштову скриньку мертвих листів, `DeathWatch` опублікує свій остаточний перехід, і взагалі не очікується, що він знову оживе (оскільки життєвий цикл актора не дозволяє цього).

=== Для чого використовується адресна частина?

При надсиланні посилання на актора через мережу це відображається шляхом. Отже, шлях повинен повністю кодувати всю інформацію, необхідну для надсилання повідомлень до відповідного актора. Це досягається за допомогою протоколу кодування, хоста та порту в адресній частині рядка шляху. Коли система актора отримує шлях актора від віддаленого вузла, вона перевіряє, чи відповідає адреса цього шляху адресі поточної акторської системи, і в такому випадку вона буде вирішена місцевим посиланням актора. В іншому випадку вона буде представлена ​​віддаленим посиланням на актора.

=== Області вищого рівня для акторських шляхів

* В корені шляху ієрархії знаходиться кореневий опікун, над яким знаходяться всі інші суб'єкти; її назва `"/"`. Наступний рівень складається з наступного:
* `"/user"` є актором-опікуном для всіх створених користувачем акторів вищого рівня; актори, створені за допомогою ActorSystem.actorOf, знаходяться нижче цього.
`"/system "` є актором-опікуном для всіх створених системою акторів вищого рівня, напр. реєстрація слухачів або акторів автоматично розгортається за конфігурацією на початку роботи системи акторів.
* `"/deadLetters"`- це актор мертвих листів, куди переадресовуються всі повідомлення, надіслані зупиненим або неіснуючим акторам,  (за найкращих зусиль: повідомлення можуть втрачатися навіть у локальній JVM).
* `"/temp"` є опікуном для всіх короткочасних створених системою акторів, напр. ті, які використовуються при впровадженні `ActorRef.ask`.
* `"/remote"` - це штучний шлях, під яким проживають усі актори, супервізорами яких є віддалені посилання на акторів

Необхідність структурувати простір імен для акторів на кшталт цього виникає з центральної та дуже простої розробницької мети: все в ієрархії - це актор, і всі актори функціонують однаково.

== Прозорість місцеположення

У попередньому розділі описано, як використовуються шляхи акторів для забезпечення прозорості місцеположення. Ця особливість заслуговує на додаткове пояснення, оскільки відповідний термін «прозоре віддалення» використовувався зовсім по-різному в контексті мов програмування, платформ та технологій.

=== Розподілення за замовчуванням

Все в Akka покликане працювати в розподіленій обстановці: усі взаємодії акторів використовують суто передачу повідомлень, і все є асинхронним. Ці зусилля були зроблені для того, щоб усі функції були доступні однаково під час роботи в одній JVM або на кластері з сотні машин. Ключовим моментом для цього є перехід від віддаленого до локального шляхом оптимізації, а не намагання перейти від локального до віддаленого шляхом узагальнення. Дивіться https://doc.akka.io/docs/misc/smli_tr-94-29.pdf [цей класичний документ] для детальної дискусії про те, чому другий підхід приречений на невдачу.

=== Шляхи, в яких прозорість порушена

Що стосується Akka, не обов'язково повинно бути правдою для програми, яка його використовує, оскільки проектування для розподіленого виконання створює деякі обмеження щодо можливого. Найбільш очевидним є те, що всі повідомлення, що надсилаються по дроту, повинні бути серійними.

Інший наслідок полягає в тому, і всі повинні бути попереджені, що всі взаємодії є повністю асинхронними, що в комп'ютерній мережі може означати, що щоб дістатися до свого одержувача повідомленню може знадобитись декілька хвилин (залежно від конфігурації). Це також означає, що ймовірність втратити повідомлення набагато вище, ніж у межах однієї JVM, де воно близьке до нуля (ще раз: жодної жорсткої гарантії!).

=== Peer-to-Peer vs. Client-Server

Akka Remoting - це комунікаційний модуль для підключення акторських систем вузол-вузол, і це основа для кластеризації Akka. Дизайн віддалення керується двома (пов'язаними) розробницькими рішеннями:

1. Зв'язок між залученими системами є симетричним: якщо система A може підключитися до системи B, тоді система B також повинна мати можливість підключитися до системи A незалежно.

2. Роль систем зв'язку є симетричною щодо моделей з'єднання: немає системи, яка приймає тільки з'єднання, і немає системи, яка тільки ініціює з'єднання.

Наслідком цих рішень є те, що неможливо безпечно створити чисті схеми клієнт-сервер із заздалегідь визначеними ролями (порушує припущення 2). Для налаштувань клієнт-сервер краще використовувати HTTP або Akka I/O.

Важливо: Використання налаштувань, що включають трансляцію мережевих адрес, завантажувальних балансирів або контейнерів Docker, порушує припущення 1, якщо не буде зроблено додаткових кроків у конфігурації мережі, щоб дозволити симетричний зв’язок між залученими системами. У таких ситуаціях Akka може бути налаштований на прив’язку до іншої мережевої адреси, ніж та, яка використовується для встановлення з'єднань між вузлами Akka. Дивіться https://doc.akka.io/docs/akka/current/remoting-artery.html#remote-configuration-nat-artery[Akka за NAT або в контейнері Docker].

=== Позначення точок для збільшення масштабів за допомогою маршрутизаторів

Окрім того, що можна запускати різні частини акторської системи на різних вузлах кластеру, також можна масштабувати на більше ядер, примноживши суб-дерева актора, які підтримують паралелізацію (подумайте, наприклад, про пошукову систему, що обробляє різні запити в паралельно). Потім клони можуть бути спрямовані за деяким принципом, наприклад, по колу. Детальнішу інформацію див. У розділі https://doc.akka.io/docs/akka/current/typed/routers.html[Маршрутизація].

== Akka та модель пам'яті Java

Основна перевага використання платформи Lightbend, включаючи Scala та Akka, полягає в тому, що вона спрощує процес написання конкурентного програмного забезпечення. У цій статті йдеться про те, як платформа Lightbend і зокрема Akka підходять до спільної пам’яті в паралельних програмах.

=== Модель пам'яті Java

До Java 5 модель пам'яті Java (JMM) була погано визначена. Можна було отримати всілякі дивні результати, коли до спільної пам'яті було доступно декілька потоків, таких як:

* потік не бачить значень, записаних іншими потоками: проблема видимості
* нитка спостерігає за "неможливою" поведінкою інших потоків, викликана тим, що вказівки не виконуються в очікуваному порядку: проблема перестановки інструкцій.

З впровадженням JSR 133 на Java 5 багато з цих питань було вирішено. JMM - це сукупність правил, заснованих на відношенні "трапляється раніше", які обмежують, коли один доступ до пам'яті повинен відбуватися перед іншим, і навпаки, коли їм дозволяється відбуватися поза порядком. Два приклади цих правил:

* Правило блокування монітора: звільнення блокування відбувається перед кожним наступним захопленням одного і того ж блокування.
* Правило мінливої змінної: запис мінливої змінної відбувається перед кожним наступним читанням тієї самої змінної.

Хоча JMM може здатися складним, специфікація намагається знайти баланс між простотою використання та можливістю записувати продуктивні та масштабовані паралельні структури даних.

=== Актори та модель пам'яті Java

З реалізацією Actor в Akka, існує два способи, коли декілька потоків можуть виконувати дії над спільною пам'яттю:

1. Якщо повідомлення надіслано актору (наприклад, іншому актору). У більшості випадків повідомлення є незмінними, але якщо це повідомлення не є належним чином сконструйованим незмінним об'єктом, без правила «відбувається раніше», одержувач міг би бачити частково ініціалізовані структури даних та, можливо, навіть значення з повітря.
2. Якщо актор вносить зміни до свого внутрішнього стану під час обробки повідомлення та отримує доступ до цього стану, обробляючи інше повідомлення через кілька хвилин. Важливо усвідомити, що за допомогою акторської моделі ви не отримуєте жодної гарантії того, що однакова нитка буде виконувати одного і того ж актора для різних повідомлень.

Щоб запобігти проблем видимості та перепорядкувати проблеми для акторів, Акка гарантує наступні два правила «відбувається раніше»:

* Правило надсила1ння актора: надсилання повідомлення актору відбувається до отримання цього повідомлення тим самим актором.
* Правило подальшої обробки актора: обробка одного повідомлення відбувається перед обробкою наступного повідомлення тим самим актором.

Примітка: В термінах перехожого це означає, що зміни внутрішніх полів актора видно, коли наступне повідомлення обробляється цим актором. Тож поля у вашого актора не повинні бути мінливими або еквівалентними.

Обидва правила застосовуються лише для одного екземпляра актора та не дійсні, якщо використовуються різні суб'єкти.

=== Ф'ючерси та модель пам'яті Java

Завершення `Future` «відбувається раніше» виклику усіх зареєстрованих до нього зворотних викликів.

Ми рекомендуємо не робити замикань над нефінальними полями (`final` в Java та `val` у Scala), і якщо ви вирішите замикатись над нефінальними полями, вони повинні бути позначені `volatile`, щоб поточне значення поля було видиме до зворотного виклику.

Якщо ви замикаєте посилання, ви також повинні переконатися, що екземпляр, на який посилається, є безпечним для потоків. Ми настійно рекомендуємо триматися подалі від об'єктів, які використовують блокування, оскільки це може спричинити проблеми з роботою та, в гіршому випадку, тупики. Такі небезпеки `synchronized`.

=== Актори та спільний стан, що змінюється

Оскільки Akka працює на JVM, є ще деякі правила, яких слід дотримуватися.

Найголовніше, що ви не повинні замикатись на внутрішній стан актора і не розголошувати його іншим потокам:

[source,scala]
----
class MyActor(context: ActorContext[MyActor.Command]) 
    extends AbstractBehavior[MyActor.Command](context) {
  import MyActor._

  var state = ""
  val mySet = mutable.Set[String]()

  def onMessage(cmd: MyActor.Command) = cmd match {
    case Message(text, otherActor) =>
/*
  Дуже погано: загальний змінний об'єкт дозволяє іншим акторам змінювати ваш стан, або ще гірше, ви можете отримати збочені умови гонки
 */
      otherActor ! mySet

      implicit val ec = context.executionContext
/*
  Приклад некоректного підходу. Дуже погано: загальний змінний стан спричинить криві помилки застосування
 */
      Future { state = "This will race" }
/*
  Приклад некоректного підходу. Дуже погано: загальний змінний стан спричинить криві помилки застосування
 */
      expensiveCalculation().foreach { result =>
        state = s"new state: $result"
      }
/*
  Приклад коректного підходу. Перетворіть результат фьючерса в повідомлення, що надсилається самому собі, коли фьючерс завершується
 */
      val futureResult = expensiveCalculation()
      context.pipeToSelf(futureResult) {
        case Success(result) => UpdateState(result)
        case Failure(ex)     => throw ex
      }
/*
  Інший приклад некоректного підходу, зміна стану актора зі зворотнього виклику фьючерса ask
 */
      import akka.actor.typed.scaladsl.AskPattern._
      implicit val timeout = Timeout(5.seconds) // треба для `ask` нижче
      implicit val scheduler = context.system.scheduler
      val future: Future[String] = otherActor.ask(Query)
      future.foreach { result =>
        state = result
      }
/*
  Замість цього використовуйте context.ask, що обертає завершення в повідомлення собі
 */
      context.ask(otherActor, Query) {
        case Success(result) => UpdateState(result)
        case Failure(ex)     => throw ex
      }
      this

    case UpdateState(newState) =>
/*
 Безпечно, доки `newState` незмінне, якщо воно змінне потребує безпечної копії
 */
      state = newState
      this
  }
}
----

Повідомлення повинні бути незмінними, щоб уникнути пастки спільного стану, що змінюється.

== Надійність доставки повідомлень

Akka допомагає вам створювати надійні програми, які використовують декілька ядер процесора в одній машині ("масштабування вгору") або розподіляються по комп'ютерній мережі ("масштабування назовні"). Основна абстракція цієї роботи полягає в тому, що всі взаємодії між вашими кодовими одиницями - акторами - відбуваються при передачі повідомлення, тому точна семантика передачі повідомлень між учасниками заслуговує на власну главу.

Для того, щоб дати деякий контекст обговоренню нижче, розгляньте додаток, який охоплює декілька хостів мережі. Основний механізм комунікації - той самий, чи надсилання актору на локальну JVM або віддаленому виконавцю, але спостерігатимуться відмінності у затримці доставки (можливо, також залежно від пропускної здатності мережевого зв’язку та розміру повідомлення) і надійність. У разі віддаленого надсилання повідомлення є більше кроків, що означає, що більше може піти не так. Інший аспект полягає в тому, що локальне надсилання передасть посилання на повідомлення всередині того ж JVM без будь-яких обмежень на базовий об'єкт, який надсилається, тоді як віддалений транспорт буде обмежувати розмір повідомлення.

Написати своїх акторів таким чином, щоб кожна взаємодія могла бути віддаленою - це безпечна, песимістична ставка. Це означає покладатися лише на ті властивості, які завжди гарантовані та про які детально йде мова нижче. Це має певний наклад у виконанні актора. Якщо ви готові пожертвувати повною прозорістю розташування (наприклад, у випадку групи тісно співпрацюючих акторів), ви можете розміщувати їх завжди в одній JVM і отримувати більш жорсткіші гарантії щодо доставки повідомлень. Деталі цього компромісу обговорюються далі.

В якості додаткової частини ми наводимо кілька вказівок на те, як створити більшу надійність зверху вбудованої. Розділ закривається, обговорюючи роль "Офісу мертвих листів".

=== Загальні правила

Це правила для надсилання повідомлень (тобто метод `tell` або `!`, який також лежить в основі шаблону запиту `ask`):

*щонайбільше одноразова доставка*, тобто не гарантована доставка

*впорядкування повідомлень на пару відправника та одержувача*

Перше правило, як правило, зустрічається і в інших реалізаціях акторів, тоді як друге характерне для Akka.

==== Обговорення: Що означає "максимум одноразово"?

Що стосується опису семантики механізму доставки, то існує три основні категорії:

* *щонайбільше одноразова доставка* означає, що для кожного повідомлення, переданого механізму, це повідомлення доставляється один раз або взагалі не доставляється; у більш простих виразах це означає, що повідомлення можуть бути втрачені.

* *щонайменше одноразова доставка* означає, що для кожного повідомлення, переданого механізму, можливе кілька спроб його доставки, таким чином, щоб принаймні одна була успішною; знову ж таки, у більш простих виразах це означає, що повідомлення можуть дублюватися, але не втрачатися.

* *рівно одноразова доставка* означає, що для кожного повідомлення, переданого механізму, рівно одна доставка здійснюється одержувачу; повідомлення не можна ні втрачати, ні дублювати.

Перша - найдешевша - найвища продуктивність, найменше накладні витрати - тому що це можна зробити в режимі підпалити-та-забуття, не підтримуючи стан на кінці відправлення або в транспортному механізмі. Друге вимагає повторних спроб для протидії транспортним втратам, що означає збереження стану на кінці відправлення та наявність механізму підтвердження на кінці прийому. Третій є найдорожчим - і, отже, найгіршим показником - тому що, крім другого, він вимагає утримувати стан на кінці прийому, щоб відфільтрувати повторювані доставки.

==== Обговорення: Чому немає гарантованої доставки?

В основі проблеми лежить питання, що саме означає ця гарантія:

1. Повідомлення надсилається в мережу?
2. Інший хост отримує повідомлення?
3. Повідомлення поміщається в поштову скриньку цільового актора?
4. Повідомлення починає оброблятися цільовим актором?
5. Повідомлення успішно оброблено цільовим актором?

Кожен з них має різні проблеми та витрати, і очевидно, що існують умови, за яких будь-яка бібліотека, що передає повідомлення, не змогла б виконати; подумайте, наприклад, про настроювані типи поштових скриньок та про те, як обмежена поштова скринька взаємоділа б із третьім пунктом, або навіть, що означатиме вирішення питання про частину «успішно» п’ятої позиції.

За цим же принципом йде міркування у "Ніхто не потребує надійного обміну повідомленнями". Єдиний змістовний спосіб відправника дізнатись, чи взаємодія була успішною - це отримання повідомлення про підтвердження бізекс рівня, яке Акка не може скласти самостійно (а також ми не пишемо фреймворк "зроби, що я маю на увазі", і ви не бажаєте щоб ми цім займались).

Акка охоплює розподілені обчислення та робить помилковість спілкування явною при передачі повідомлення, тому не намагається брехати та імітувати протікаючу абстракцію. Це модель, яка з великим успіхом застосовується в Erlang і вимагає від користувачів проектувати свої програми навколо неї. Детальніше про цей підхід ви можете прочитати в документації Erlang (розділи 10.9 та 10.10), Акка уважно дотримується цього.

Іншим моментом у цьому питанні є те, що, надаючи лише основні гарантії, ті випадки використання, які не потребують більш високої надійності, не платять витрати на їх реалізацію. Завжди можна додати більш високу надійність поверх базової, але неможливо ретро-активно видалити надійність для отримання більшої продуктивності.

==== Обговорення: Впорядкування повідомлень

Правило конкретніше полягає в тому, що для певної пари дійових осіб повідомлення, що надсилаються безпосередньо від першого до другого, не будуть надходити поза порядком. Слово безпосередньо підкреслює, що ця гарантія застосовується лише при надсиланні оператором `tell` до кінцевого пункту призначення, а не при використанні посередників або інших функцій поширення повідомлень (якщо не вказано інше).

Гарантія проілюстрована наступним чином:

- Актор А1 надсилає повідомлення M1, M2, M3 до A2
- Актор A3 надсилає повідомлення M4, M5, M6 до A2

Це означає що:

* Якщо M1 доставлений, він повинен бути доставлений до M2 та M3
* Якщо M2 доставлений, він повинен бути доставлений до M3
* Якщо M4 доставлений, він повинен бути доставлений до M5 та M6
* Якщо M5 доставлений, він повинен бути доставлений до M6
* A2 може бачити повідомлення від A1, переплетені з повідомленнями від A3
* Оскільки немає гарантованої доставки, будь-яке повідомлення може бути відхилене, тобто не надходити на A2

Примітка: Важливо зазначити, що гарантія Akka поширюється на порядок введення повідомлень у поштову скриньку одержувача. Якщо реалізація поштової скриньки не дотримується домовленості FIFO (наприклад, `PriorityMailbox`), то порядок обробки актором може відхилятися від порядку замовлення.

Зауважте, що це правило не є транзитивним:

- Актор A надсилає повідомлення актору С1 M1
- Актор А потім надсилає повідомлення актору В2 M2
- Актор В передає актору С повідомлення М2
- Актор C може приймати М1 і М2 в будь-якому порядку

Транзитивне впорядкування означало б, що M2 ніколи не отримується до M1 в акторі C (хоча будь-яке з них може бути загублене). Це впорядкування може бути порушено через різні затримки доставки повідомлень, коли A, B і C знаходяться на різних мережевих хостах, див. докладніше нижче.

Примітка: Створення актора трактується як повідомлення, яке надсилається від батька дитині, з тією ж семантикою, що обговорена вище. Надіслати повідомлення актору таким чином, який можна було б упорядкувати за допомогою цього початкового повідомлення про створення, означає, що повідомлення може не надходити, оскільки актор ще не існує. Прикладом, коли повідомлення може надходити занадто рано, було б створити віддалений розгорнутий актор R1, надіслати його посиланням на інший віддалений актор R2 і змусити R2 відправити повідомлення на R1. Прикладом чітко визначеного впорядкування є батько, який створює актора і негайно надсилає йому повідомлення.

=== Повідомлення про відмову

Зауважте, що обговорені вище гарантії впорядкування стосуються лише користувацьких повідомлень між акторами. Невдача дитини-актора повідомляється спеціальними системними повідомленнями, які не упорядковані відносно звичайних повідомлень користувачів. Зокрема:

- Дитячий актор C надсилає повідомлення M своєму батькові P
- Дитячий актор виходить з ладу з помилкою F
- Актор-батько P може отримати дві події або в порядку M, F або F, M

Причиною цього є те, що внутрішні системні повідомлення мають власні поштові скриньки. Тому впорядкування запитів користувальницьких запитів і системних повідомлень не може гарантувати впорядкування їх отримання.

=== Правила надсилання In-JVM (локального) повідомлення

==== Будьте уважні, що ви робите з цим розділом!

Не рекомендується покладатися на більш високу надійність, описану у цьому розділі, оскільки це пов'язує вашу програму лише з локальним розгортанням: програма може бути розроблена по-іншому (на відміну від використання деяких моделей обміну повідомленнями, локальних для деяких акторів), щоб бути придатний для виконання на кластері машин. Нашим кредо є "спроектуй один раз, розгорніть у будь-який бажаний спосіб", і для цього вам слід покластися лише на загальні правила.

==== Надійність надсилання локальних повідомлень

Набір тестів Akka покладається на те, щоб не втрачати повідомлення в локальному контексті (а також для не-збійних тестів також і для віддаленого розгортання). Це означає, що ми насправді докладаємо максимум зусиль, щоб наші тести були стабільними. Однак операція локального повідомлення `tell` може не працювати з тих же причин, що і звичайний виклик методу в JVM:

* StackOverflowError
* OutOfMemoryError
* інша VirtualMachineError

Окрім того, локальне надсилання може не вдаватися специфічними для Akka способами:

* якщо поштова скринька не приймає повідомлення (наприклад, повна `BoundedMailbox`)
* якщо актор отримує помилку під час обробки повідомлення або вже припинений

Хоча перше - це питання конфігурації, друге заслуговує на деяку думку: відправник повідомлення не отримує зворотного зв’язку, якщо під час обробки був виняток, і це повідомлення переходить до керівника. Це взагалі не відрізняється від втраченого повідомлення для зовнішнього спостерігача.

==== Порядок надсилання локальних повідомлень

Якщо розглянути суто поштові скриньки FIFO, вищезазначені застереження про неперехідність гарантії замовлення повідомлень усувається за певних умов. Як ви зауважите, вони є настільки тонкими, наскільки це є, і цілком можливо, що майбутні оптимізації ефективності онулюють весь цей абзац. Перелік протипоказань, можливо, не вичерпний:

* Перш ніж отримати першу відповідь від актора вищого рівня, існує блокування, яке захищає внутрішню тимчасову чергу, і це блокування не є чесним; сенс полягає в тому, що запити на постановку в чергу від різних відправників, які надходять під час побудови актора (фігурально кажучи, деталі більш заплутані), можуть бути переупорядковані залежно від планування ниток низького рівня. Оскільки повністю чесних блоквань у JVM не існує, це неможливо виправити.
* Цей же механізм використовується під час побудови `Router`, точніше маршрутизованого `ActorRef`, отже, така ж проблема існує і для акторів, розгорнутих з маршрутизаторами `Router`.
* Як було сказано вище, проблема виникає в будь-якому місці блокування, яке виконується під час побудови черги, що також може стосуватися спеціальних поштових скриньок.

Цей список складено ретельно, але, можливо, інші проблемні сценарії уникнули нашого аналізу.

==== Як локальне впорядкування стосується мережевого впорядкування

Є правило, згідно з яким для певної пари акторів повідомлення, що надсилаються безпосередньо від першого до другого, не змінюватимуть порядок отримання. Це робить для повідомлень, що надсилаються по мережі за допомогою протоколу віддаленого транспорту Akka на основі TCP.

Як пояснено в попередньому розділі, за певних умов надсилання локального повідомлення підкоряється транзитивному впорядкуванню. Це впорядкування може бути порушено через різні затримки доставки повідомлень. Наприклад:

- Актор A у вузлі-1 надсилає повідомлення M1 актору C на вузол-3
- Актор A у вузлі-1 потім надсилає повідомлення M2 актору B на вузол-2
- Актор B у вузлі-2 пересилає повідомлення M2 актору C на вузол-3
- Актор C може отримувати M1 і M2 в будь-якому порядку

Можливо, у M1 може знадобитися більше часу для "подорожі" до вузла-3, ніж для M2 для "подорожі" до вузла-3 через вузол-2.

=== Абстракції вищого рівня

На основі невеликого та послідовного інструменту, встановленого в ядрі Akka, Akka також забезпечує потужні абстракції вищого рівня.

==== Шаблони обміну повідомленнями

Як обговорювалося вище, пряма відповідь на вимогу надійної доставки є явним протоколом ACK–RETRY. У своїй найпростішій формі для цього потрібно

* спосіб ідентифікації окремих повідомлень для співвіднесення повідомлення з підтвердженням
* механізм повторного надсилання повідомлень, якщо його не визнано вчасно 
* спосіб для приймача виявити та відкинути дублікати

Третє стає необхідним завдяки визнанням, яким також не гарантовано надходження.

Протокол ACK-RETRY з підтвердженнями бізнес-рівня та дедублікацією за допомогою ідентифікаторів підтримується функцією Reliable Delivery.

Іншим способом реалізації третьої частини було б зробити обробку повідомлень ідемпотентною (байдужою до повторних застосувань) на рівні ділової логіки.

==== Походження подій

Походження подій (та шардинг подій) - це те, що робить великі веб-сайти масштабованими до мільярдів користувачів. Ідея досить проста: коли компонент (вважайте - актор) обробляє команду, він генерує перелік подій, що представляють ефект команди. Ці події, крім того, що вони застосовуються до стану компонента, також зберігаються. Приємним в цій схемі є те, що події лише коли-небудь додаються до сховища, нічого ніколи не змінюється. Це дає змогу досконалої реплікації та масштабування споживачів цього потоку подій (тобто інші компоненти можуть споживати потік подій як засіб для копіювання стану компонента на іншому континенті або реагування на зміни). Якщо стан компонента втрачено - через несправність машини або виштовхом з кешу - його можна реконструювати, відтворивши потік подій (зазвичай використовуючи знімки для прискорення процесу). Походження подій підтримується Akka Persistence.

==== Поштова скринька з явним підтвердженням

Реалізуючи власний тип поштової скриньки, можна повторити обробку повідомлень на кінці приймаючого актора, щоб вирішити тимчасові збої. Ця модель є найбільш корисною в контексті локального спілкування, коли інакше гарантії доставки є достатніми для виконання вимог програми.

Будь ласка, зауважте, що застосовуються всі застереження щодо Правил надсилань повідомлень In-JVM (Local).

=== Мертві листи

Повідомлення, які неможливо доставити (і для яких це можна встановити), будуть доставлені синтетичному акторові під назвою `/deadLetters`. Ця доставка відбувається за найкращих зусиль; вона може бути невдалою навіть у локальній JVM (наприклад, під час припинення дії актора). Повідомлення, надіслані через ненадійні мережеві транспорти, втрачаються, не перетворюючись на мертві листи.

==== Для чого я повинен використовувати мертві листи?

Основне використання цього засобу - для налагодження, особливо якщо надсилання актора не надходить послідовно (де зазвичай огляд мертвих листів скаже вам, що відправник або одержувач встановлені неправильно десь на шляху). Для того, щоб бути корисним для цієї мети, краще уникати надсилання на `DeadLetters`, де це можливо, тобто запустіть додаток час від часу з відповідним реєстратором мертвих листів (див. Докладніше) та очистіть записи в журналі. Ця вправа - як і все інше - вимагає розумного застосування здорового глузду: цілком можливо, що уникнення надсилання завершеному акторові ускладнює код відправника більше, ніж отримано в ясності виводу налагодження.

Служба мертвих листів дотримується тих самих правил стосовно гарантій доставки, що і всі інші повідомлення, що надсилаються, отже, її не можна використовувати для здійснення гарантованої доставки.

==== Як я отримую мертві листи?

Актор може підписатися на клас `akka.actor.DeadLetter` у потоці подій (про те, як це зробити, див. Event Stream) Після цього підписаний актор отримуватиме всі мертві листи, опубліковані в (локальній) системі. Мертві листи не поширюються по мережі. Якщо ви хочете зібрати їх в одному місці, вам доведеться підписати одного актора на кожний мережевий вузол і переслати їх вручну. Також врахуйте, що мертві листи створюються на вузлах, які можуть визначити, що операція надсилання не виконан. Це для віддаленого відправлення може бути локальною системою (якщо мережеве з'єднання неможливо встановити) або віддаленою (якщо актор, до якого ви надсилаєте, не існує в цей момент часу).

==== Мертві листи, які, як правило, не викликають занепокоєння

Кожен раз, коли актор не припиняється за власним рішенням, є ймовірність, що деякі повідомлення, які він надсилає собі, втрачаються. Є така ситуація, яка трапляється досить легко в складних сценаріях відключення, і, як правило, є здоровою: побачити випадки добровільної команди зупинки для скинутого актора означає, що було подано два запити на зупинку, але тільки один може досягти успіху. У цьому ж ключі ви можете побачити повідомлення `akka.actor.Terminated` від дітей, припиняючи ієрархію акторів, що з’являються серед мертвих листів, якщо батько все ще спостерігає за дитиною, коли сам батько вже припиняє існування.
