include::header.adoc[]

== Luxoft в потемках или почему Лисков курит веники.

Время от времени я прохожу собеседования на разньіх компаниях или рассьілаю какие-то потешньіе каверьі. Нет, там нет особого фейка, но ничто так не смешно и грустно как правда. Особенно часто меня приглашают собеседовать в одну компанию, условно названную тут Luxoft. Если такая компания есть на самом деле - ну что же, накладочка. 

Не спорю, некоторьіе вопросьі на самом деле проверяют минимальную адекватность. Остальньіе вопросьі относятся к таким категориям:

* бесполезньіе знания, такие как устройство GC или где вьіполняются `Future`. Ето тайна реализации, и даже зная одну из реализаций невозможно безопасно использовать ети знания, без риска вьілететь в будущем или даже сразу, но в другом контексте. Использование деталей реализации - ето тупой хак, которьій может "внезапно" вьізвать самьіе тяжельіе последствия. Разработчик огражден от деталей реализации _*for some reason*_.

* фрактальньіе, которьіе могут погрузить в бесконечную дискуссию, как например, динамическая загрузка классов/// 

* не-программистские, такие как распределение пула или оркестрация екземпляров. Ето полезньіе знания, но поскольку DevOps сечас рубят все бабло, какое есть в мире, то пусть конфигурируют и пожирают чиз-кейк.

Но есть действительно интересньіе и сложньіе вопросьі, которьіе полностью дезавуируют уровень вопрошающего. Сегодня я остановлюсь на двух интересньіх вопросах, котроьіе затрагивают один аспект Java/Scala, а именно дженерики, они же параметризованньіе типьі. 

1. Сколько есть типов полиморфизма в Java/Scala? Мой ответ - 1 тип. "Правильньій" ответ - А вот и нет, два, один через систему наследования классв и другой через дженерики. Ето сложньій тип заблуждения, и его я поясню детально.

2. (Вероятно со скепсисом) Есть закон Лискова (см. Effective Java), следуя которому субкласс может использоваться везде, где используется суперкласс. Зачем же нам механизм ко- и контр- вариантности? Как правило более хитрьій план более уязвим, как и етот вопрос.

Для того, чтобьі понять суть, надо уяснить один важньій постулат и ряд вспомогательньіх мьіслей (лемм):

*Дженерики и параметрьі типа порождают новьій тип, но не порождают новьій класс!* Как новьій цвет авто не порождает новую модель. Поетому `Array<Object>` и `Array<Int>` не находятся в иерархии ни над, ни под, ни даже рядом. Ето *ОДИН* класс. На етом етапе весь Лисков уже улетает в бездну - мьі вобще не говорим об иерархии.

Надо понимать что иерархия стабильна и во время рантайма, на ней основана истинная полиморфность времени вьполнения (на основе таблицьі виртуальньіх методов, совсем как в TurboPascal).

Все операции с дженериками и разрешением параметризации типами разрешается во время компиляции. В JVM НИЧТО не поддерживает динамические типьі. Поетому весь "полиморфизм" дженериков ето неявньій кастинг. И его много и без дженериков: 

[source,java]
----
double d = 1; // неявньій кастинг
double sq = java.lang.math.sqrt(6) // неявньій кастинг

String[] cars = {"Volvo", "BMW", "Ford", "Mazda"};
String car = cars[0];
/* хаха, кастинг - массивьі не помнят типов елементов */
----

Далее - `implicit` в Scala ето "явно неявное" преобразование, которое контролируется (будем надеяться) разработчиком. Дженерики точно так же вставляют (генерируют) нужньій кастинг, где ето надо. 

Окей, Лисков на помойке, но зачем же ети ко-конр-вариации? Только чтобьі сказать компилятору, что считать "по-лисковски" допустимьім, то ли `Array<Objaect>` считать суперклассом, то ли `Array<String>`. То есть метод поиметь дохлого Лискова так или едак, а ето уже некрофилия.

В следующий раз рассмотрм "сложньіе вопросьі", и мьі хором поимеем моноидьі, монадьі, ендоморфизм и все алгебраические системьі разом. 
