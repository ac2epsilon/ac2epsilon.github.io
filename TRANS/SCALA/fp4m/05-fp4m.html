<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>5. Типокласи Scalaz</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>5. Типокласи Scalaz</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми зробимо по більшості типокласах в <code>scalaz-core</code>. Ми не використовуємо всі в <code>drone-dynamic-agents</code>, так що ми будемо надавати окремі приклади, коли це треба.</p></div>
<div class="paragraph"><p>Була певна критика найменувань в Scalaz, та функціональному програмуванні загалом. Більшість наіменувань слідують домовленостям, введеним в мові програмування Haskell, базуючись на Category Theory. Почувайте вільно додавати псевдоніми типів, якщо дієслова, основані на первинній функціональності, простіше запам'ятати при навчанні (тобто, <code>Mappable</code>, <code>Pureable</code>, <code>FlatMappable</code>).</p></div>
<div class="paragraph"><p>Перед тим, як ми введемо ієрархію типокласів, ми загостримо нашу увагу на чотирьох найбільш важливих методах з точки зору контроля потоком: методи, які ми будемо використовувати в більшості FP застосувань:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Typeclass</p></td>
<td align="left" valign="top"><p class="table">Method</p></td>
<td align="left" valign="top"><p class="table">From</p></td>
<td align="left" valign="top"><p class="table">Given</p></td>
<td align="left" valign="top"><p class="table">To</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Functor</p></td>
<td align="left" valign="top"><p class="table">map</p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
<td align="left" valign="top"><p class="table">A &#8658; B</p></td>
<td align="left" valign="top"><p class="table">F[B]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Applicative</p></td>
<td align="left" valign="top"><p class="table">pure</p></td>
<td align="left" valign="top"><p class="table">A</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Monad</p></td>
<td align="left" valign="top"><p class="table">flatMap</p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
<td align="left" valign="top"><p class="table">A &#8658; F[B]</p></td>
<td align="left" valign="top"><p class="table">F[B]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Traverse</p></td>
<td align="left" valign="top"><p class="table">sequence</p></td>
<td align="left" valign="top"><p class="table">F[G[A]]</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">G[F[A]]</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Ми знаємо, що операції, що повертають <code>F[\_]</code> можуть виконуватись послідовно в розширеному <code>for</code> через <code>.flatMap</code>, визначеному на його <code>Monad[F]</code>. Контекст <code>F[_]</code> може бути промислений як контейнер для бажаного ефекту з <code>A</code> в якості виходу: <code>flatMap</code> дозволяє нам генерувати нові ефекти <code>F[B]</code> під час виконання, базуючись на результатах обчислення попередніх ефектів.</p></div>
<div class="paragraph"><p>Звичайно, не всі конструкції типів <code>F[_]</code> ефективні, навіть якщо вони мають <code>Monad[F]</code>. Часто вони є структурами даних. Через використання найменьш специфічної абстракції, ми можемо повторно використовувати код для <code>List</code>, <code>Either</code>, <code>Future</code> і так далі.</p></div>
<div class="paragraph"><p>Якщо вам треба тільки трансформувати вивід від <code>F[_]</code>, що є просто <code>map</code>, введене <code>Functor</code>. В Главі 3 ми виконуємо ефекти паралельно, через створення продукту і відображення по ним. В функціонально програмуванні розпаралелювальні обчислення визначаються менш потужними, ніж послідовні.</p></div>
<div class="paragraph"><p>Посеред <code>Monad</code> та <code>Functor</code> знаходиться <code>Applicative</code>, що визначає <code>pure</code>, що дозволяє нам підійняти розглянуване значення, або створити структуру даних з одного значення.</p></div>
<div class="paragraph"><p><code>.sequence</code> корисне для переаранжування конструкторів типу. Якщо ви маєте <code>F[G[\_]]</code>, але нам треба <code>G[F[_]]</code>, тобто <code>List[Future[Int]]</code>, але нам треба <code>Future[List[Int]]</code>, це є <code>.sequence</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_1_">5.1 Передмова</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ця глава довша ніж звичайно, і стисло напакована інформацією: досить логічно атакувати її за декілька раз. Запам'ятовування всього може вимагати нелюдських якостей, так що розглядайте цю главу як шлях дізнатись, де шукати додаткову інформацію.</p></div>
<div class="paragraph"><p>Помітна відсутність типокласів, що розширюють <code>Monad</code>. Вони отримують свою окрему главу пізніше.</p></div>
<div class="paragraph"><p>Scalaz використовує генерацію кода, не симуляцію. Однак для краткості ми представляємо шматки коду з <code>@typeclass</code>. Еквівалентний синтаксис доступний, коли ми робимо <code>import scalaz._, Scalaz._</code>, та доступний в пакунку <code>scalaz.syntax</code> в джерельному коді <code>scalaz</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_2__">5.2 Додавані речі</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|+|&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>

    <span class="k">def</span> <span class="n">multiply1</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span>

    <span class="k">def</span> <span class="n">multiply</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">zero</span> <span class="k">else</span> <span class="n">multiply1</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Band</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>|+|</code> відоме як оператор TIE Fighter. Існує також Advanced TIE Fighter в наступному розділі, що дуже захопливо.</p></div>
<div class="paragraph"><p>Напівгрупа <code>Semigroup</code> може бути визначене для типу, якщо два значення може бути скомбіноване. Операція має бути асоціативна, що означає, що порядок вкладених операцій не має значення:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  (a |+| b) |+| c == a |+| (b |+| c)

  (1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)</code></pre>
</div></div>
<div class="paragraph"><p><code>Monoid</code> є <code>Semigroup</code> з нульовим елементом (також називається порожнім або ідентичністю). Комбінація нуля з любим іншим <code>a</code> повинно давати <code>a</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  a |+| zero == a

  a |+| 0 == a</code></pre>
</div></div>
<div class="paragraph"><p>Це, можливо, повертає пам'ять до <code>Numeric</code> з Глави 4. Є реалізації <code>Monoid</code> для всіх примітивних чисел, але концепція додаваних речей корисна і за межами чисел.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">|+|</span> <span class="s">&quot; &quot;</span> <span class="o">|+|</span> <span class="s">&quot;world!&quot;</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;hello world!&quot;</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Band</code> має закон, що операція додавання до тих самих двох операндів ідемпотентна, тобто дає те саме значення. Прикладом може бути будь-що, що може мати тільки одне значення, як <code>Unit</code>, найменьша вища межа, або <code>Set</code>. <code>Band</code> не провадить додаткових методів, але користувачі можуть використовувати гарантії для оптимізації продуктивності.</p></div>
<div class="paragraph"><p>Viktor Klang з Lightbend притендує на фразу ефективно-одноразової доставки для обробки повідомлень, з іденпотентними операціями, тобто <code>Band.append</code>.</p></div>
<div class="paragraph"><p>Як реалістичний приклад для <code>Monoid</code>, розглянемо торгівельну систему, що має велику базу даних повторно використовуваних шаблонів торгівлі. Заповнення значень по замовчанню для нових торгів включає вибір та комбінування декількох шаблонів, з політикою поєднання “останнє правило перемагає”, якщо два шаблони мають значення для того самого поля. Робота “обирання” вже виконана для анс іншою системою, наше завдання є скомбінувати шаблони по порядку.</p></div>
<div class="paragraph"><p>Ми будемо створювати просту схему шаблонів для демонстрації принципів, але майте на увазі, що реалістична система може мати більш складні ADT.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Currency</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">EUR</span> <span class="k">extends</span> <span class="nc">Currency</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">USD</span> <span class="k">extends</span> <span class="nc">Currency</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
    <span class="n">payments</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">java.time.LocalDate</span><span class="o">],</span>
    <span class="n">ccy</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Currency</span><span class="o">],</span>
    <span class="n">otc</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми пишемо метод, що приймає шаблони: <code>List[TradeTemplate]</code>, нам треба тільки викликати</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">].</span><span class="n">zero</span>
  <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>і наша робота виконана!</p></div>
<div class="paragraph"><p>Але щоб отримати <code>zero</code> або викликати <code>|+|</code> ми маємо мати примірник  <code>Monoid[TradeTemplate]</code>. Хоча ми загалом наслідувати його в наступній главі, доки ми будемо створювати примірник на компанйоні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">TradeTemplate</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">monoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span>
      <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TradeTemplate</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">payments</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">payments</span><span class="o">,</span>
                              <span class="n">a</span><span class="o">.</span><span class="n">ccy</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">ccy</span><span class="o">,</span>
                              <span class="n">a</span><span class="o">.</span><span class="n">otc</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">otc</span><span class="o">),</span>
      <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це не робить те, що ми бажаємо, оскільки <code>Monoid[Option[A]]</code> буде додавати свій вміст, тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">None</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>в той час, коли ми бажаємо “останній закон перемагає”. Ми можемо перекрити <code>Monoid[Option[A]]</code> по замовчанню своїм власним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">lastWins</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span>
    <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">only</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">only</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="n">only</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">only</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span>   <span class="o">,</span> <span class="n">winner</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">winner</span>
    <span class="o">},</span>
    <span class="nc">None</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер все компілюється, спробуйте самі…</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.time.</span><span class="o">{</span><span class="nc">LocalDate</span> <span class="k">=&gt;</span> <span class="nc">LD</span><span class="o">}</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">templates</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">None</span><span class="o">,</span>      <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">Some</span><span class="o">(</span><span class="nc">EUR</span><span class="o">),</span> <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">LD</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">2017</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">)),</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span> <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">LD</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">2017</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">)),</span> <span class="nc">None</span><span class="o">,</span>      <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">None</span><span class="o">,</span>      <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
         <span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">TradeTemplate</span> <span class="o">=</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
                         <span class="nc">List</span><span class="o">(</span><span class="mi">2017</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">05</span><span class="o">,</span><span class="mi">2017</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">05</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що вам треба було зробити, це реалізовати один фрагмент бізнес логіки, та <code>Monoid</code> потурбується про све інше за нас!</p></div>
<div class="paragraph"><p>Зауважте, що список платежів сконкатенований. Це тому, що по замовчанню <code>Monoid[List]</code> використовує конкатенацію елементів, та це часто бажана поведінка. Якщо бізнес потреби інші, може бути простим випадком запровадити власний <code>Monoid[List[LocalDate]]</code>. Згадайте з Глави 4, що з повним поліморфізмом ми можемо мати іншу реалізацію <code>append</code>, в залежності від <code>E</code> в <code>List[E]</code>, не тільки на основі рантайм класу <code>List</code>.</p></div>
<div class="paragraph"><p>Коли ми ввели типокласу в Главі 4, ми казали, що може бути тільки одна реалізація типкласа для наданого параметра типу, тобто тільки один <code>Monoid[Option[Boolean]]</code> в застосуванні. Сирітливі примірники, як <code>lastWins</code> є простішим шляхом зруйнувати когерентність.</p></div>
<div class="paragraph"><p>Ми можемо спробувати виправдати локально зруйновану когерентність типкласів, зробивши <code>lastWins</code> приватним, але коли ми дійдемо до типокалсу <code>Plus</code>, ми побачимо кращий шлях для реалізації нашого <code>Monoid</code>. Коли ми отримаємо теговані типи, ми побачимо навіть кращий спосіб: використовуючи <code>LastOption</code> замість <code>Option</code> в нашій моделі даних.</p></div>
<div class="paragraph"><p>Будь-ласка, не ламайте когерентність типокласів самостійно, дітки.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_3___">5.3 Об'єктні речі</h2>
<div class="sectionbody">
<div class="paragraph"><p>В главі про дані та функціональність ми казали, що нотація еквівалентності JVM поламана для багатьох речей, що ми можемо покласти до ADT. Проблема в тому, що JVM була розроблена для Java, та <code>equals</code> визначений для <code>java.lang.Object</code>, чи має це сенс, чи ні. Немає способу видалити <code>equals</code>, і немає шляху гарантувати, що він реалізований.</p></div>
<div class="paragraph"><p>Однак в FP ми обираємо типокласи для поліморфної функціональності, і навіть концепція еквівалентності захоплюється під час компіляції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>  <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;===&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;/==&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">notEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">equal</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість <code>===</code> (потрійна рівність) більш типо-безпечна, ніж <code>==</code> (родвійна рівність), оскільки вона може бути скомпільована тільки коли типи ті самі на обох боках порівняння. Це відловлює багато вад.</p></div>
<div class="paragraph"><p><code>equal</code> має ті самі вимоги до реалізації, що і <code>Object.equals</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="n">commutative</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f2</span> <span class="n">implies</span> <span class="n">f2</span> <span class="o">===</span> <span class="n">f1</span>
    <span class="n">reflexive</span> <span class="n">f</span> <span class="o">===</span> <span class="n">f</span>
    <span class="n">transitive</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f2</span> <span class="o">&amp;&amp;</span> <span class="n">f2</span> <span class="o">===</span> <span class="n">f3</span> <span class="n">implies</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f3</span>
</pre></div></div></div>
<div class="paragraph"><p>Відкидаючи універсальну концепцію <code>Object.equals</code>, ми не приймаємо рівність як гарантовану, коли ми конструюємо ADT,зупиняючи нас під час компіляції від очікування еквівалентності, там де її немає.</p></div>
<div class="paragraph"><p>Продовжуючи тренд заміни старих Java концепцій, замість маючи дані типу <code>java.lang.Comparable</code>, тепер вони мають відповідний <code>Order</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;?|?&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">order</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Ordering</span>

    <span class="k">override</span>  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">order</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Ordering</span><span class="o">.</span><span class="nc">EQ</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;=&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">lte</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;=&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">gte</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">min</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">sort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">,</span> <span class="kt">F</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Ordering</span>
  <span class="k">object</span> <span class="nc">Ordering</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">LT</span> <span class="k">extends</span> <span class="nc">Ordering</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">EQ</span> <span class="k">extends</span> <span class="nc">Ordering</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">GT</span> <span class="k">extends</span> <span class="nc">Ordering</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Order</code> реалізує <code>.equal</code> в термінах нового примітиву <code>.order</code>. Коли типоклас реалізує батьківській примітивний комбінатор з наслідуваним комбінатором, правило заміни для типокласу є додавання. Якщо примірник <code>Order</code> перекривав <code>.equal</code> з причин продуктивності, він має поводитись ідентично до оригіналу.</p></div>
<div class="paragraph"><p>Речі, що мають порядок, також можуть бути дескретними, дозволяючи нам крокувати до наступного або попереднього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Enum</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">succ</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span>
    <span class="k">def</span> <span class="n">pred</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span>
    <span class="k">def</span> <span class="n">min</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;-+-&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">succn</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;---&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">predn</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>

    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|-&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">fromToL</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|--&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">fromStepToL</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|=&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">fromTo</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">EphemeralStream</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|==&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">fromStepTo</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">EphemeralStream</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="o">|--&gt;</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;m&#39;</span> <span class="o">|-&gt;</span> <span class="sc">&#39;u&#39;</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>|--&gt;</code> є Scalaz Lightsaber. Це синтаксис для Функціонального Програміста. Не таке відволікаюче або довільне як <code>fromStepToL</code>. Елегантний синтаксис… для більш цивілізованого віку.</p></div>
<div class="paragraph"><p>Ми обсудимо <code>EphemeralStream</code> в наступній главі, доки нам лише треба знати, що існує потенційно безкінечна структура даних, що уникає проблем затримання пам'яті в <code>stdlib</code> <code>Stream</code>.</p></div>
<div class="paragraph"><p>Подібно до <code>Object.equals</code>, концепція <code>.toString</code> на кожному класі не має сенсу в Java. Ми бажали б примусити рядковість під час компіляції, і це саме те, чого досягає <code>Show</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cord</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">shows</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми будемо досліджувати <code>Cord</code> більш детально в главі по типам даних, нам треба тільки знати, що це ефективна структура даних для зберігання та маніпулювання <code>String</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_5_4__">5.4 Відображувані речі</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми сконцентруємось на речах, по яких можна мандрувати та відображувати (робити меппінг), в деякому сенсі:</p></div>
<div class="sect2">
<h3 id="_5_4_1_functor">5.4.1 Functor</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">void</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
    <span class="k">def</span> <span class="n">fproduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>

    <span class="k">def</span> <span class="n">fpair</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">strengthL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">strengthR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">mapply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)((</span><span class="n">ff</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ff</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдиний абстрактний метод є <code>map</code>, і він має робити композицію, тобто меппінг за допомогою <code>f</code>, та потім знову за допомогою <code>g</code>, це те саме, що одночасне відображення за допомогою композиції <code>f</code> та <code>g</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">g</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">g</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>map</code> також має виконувати <em>no-op</em>, якщо запроваджена функція є <code>identity</code> (<code>x =&gt; x</code>)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>

  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Functor</code> визначає деякі зручні методи навколо <code>map</code>, що можуть бути оптимізовані специфічними примірниками. Документація навмисне відсутня в попередніх визначеннях, щоб заохотити до здогадок, що саме робить метод, до того як звернутись до реалізації. Будь ласка, витратьте момент на вивчення тільки сигнатури наступного, перед тим як читати далі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">void</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">fproduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

  <span class="k">def</span> <span class="n">fpair</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">strengthL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">strengthR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

  <span class="c1">// harder</span>
  <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<code>void</code> приймає примірник <code>F[A]</code>, та завжди повертає <code>F[Unit]</code>, він забуває всі значення, при цьому зберігаючи структуру.
</p>
</li>
<li>
<p>
<code>fproduct</code> приймає той самий вхід як мапу, але повертає <code>F[(A, B)]</code>, тобто він склаладає в тапли вмісту з результатом, застосовуючи функцію. Це корисно, коли ми бажаємо зберігти також вхідні значення.
</p>
</li>
<li>
<p>
<code>fpair</code> збирає всі елементи <code>A</code> в тапл <code>F[(A, A)]</code>
</p>
</li>
<li>
<p>
<code>strengthL</code> парує вміст <code>F[B]</code> з констанотою <code>A</code> зліва.
</p>
</li>
<li>
<p>
<code>strengthR</code> парує вміст <code>F[A]</code> з константою <code>B</code> зправа.
</p>
</li>
<li>
<p>
<code>lift</code> приймає функцію <code>A =&gt; B</code>, та повертає <code>F[A] =&gt; F[B]</code>. Інишими словами, він бере функцію над вмістом <code>F[A]</code>, та повертає функцію, що оперує на <code>F[A]</code> напряму.
</p>
</li>
<li>
<p>
<code>mapply</code> є головоломкою. Скажімо, ми маємо <code>F[_]</code> для функцій <code>A =&gt; B</code>, та деяке значення <code>A</code>, тоді ми можемо отримати <code>F[B]</code>. Він має сигнатуру, подібну до <code>pure</code>, але вимагає від викликаючого запровадити <code>F[A =&gt; B]</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>fpair</code>, <code>strengthL</code> та <code>strengthR</code> виглядають досить непотрібними, але вони корисні, коли ми бажаємо залишити деяку інформацію, що інакше може бути втрачена з поля зору.</p></div>
<div class="paragraph"><p><code>Functor</code> має деякий особливий синтакс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span><span class="o">](</span><span class="n">self</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">as</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">self</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">&gt;|[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">as</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.as</code> та <code>&gt;|</code> є способом заміни виводу за допомогою констант.</p></div>
<div class="paragraph"><p>Коли Scalaz провадить додаткову функціональність як синтаксис, скоріше ніж самі типокласи, це так через бінарну сумісність.</p></div>
<div class="paragraph"><p>Якщо виходить версія Scalaz X.Y.0, неможливо додати методи до типокласів в цій серії релізів для Scala 2.10 та 2.11. Так що має сенс читати обоє, джерело типокласу та його синтаксис.</p></div>
<div class="paragraph"><p>В нашому прикладі застосування, в якості гидкого хаку (яких ми навіть досі не визнавали), ми визначали <code>start</code> та <code>stop</code> для повернення їх входів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">MachineNode</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">MachineNode</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">stop</span> <span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">MachineNode</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">MachineNode</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дозволяє нам писати скорочену бізнес логіку, таку як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span>      <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
    <span class="n">update</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
<div class="paragraph"><p>та</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">stopped</span> <span class="k">&lt;-</span> <span class="n">nodes</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">stop</span><span class="o">)</span>
    <span class="n">updates</span> <span class="k">=</span> <span class="n">stopped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">).</span><span class="n">toList</span><span class="o">.</span><span class="n">toMap</span>
    <span class="n">update</span>  <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">pending</span> <span class="o">++</span> <span class="n">updates</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
<div class="paragraph"><p>Але цей хак заштовхує непотрібну складність в реалізації. Буде краще, якщо ми дозволимо нашим алгебрам повертати <code>F[Unit]</code> та використовувати <code>as</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="n">as</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>та</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">stopped</span> <span class="k">&lt;-</span> <span class="n">nodes</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="n">as</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">updates</span> <span class="k">=</span> <span class="n">stopped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">).</span><span class="n">toList</span><span class="o">.</span><span class="n">toMap</span>
    <span class="n">update</span>  <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">pending</span> <span class="o">++</span> <span class="n">updates</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_5_4_2_foldable">5.4.2 Foldable</h3>
<div class="paragraph"><p>Технічно <code>Foldable</code> призначений для структур даних, по яких можна проходити для отримання сумарного значення. Однак це приховує факт, що це одно-типокласова армія, що може запровадити більшість з того, що ви очікуєте побачити в Collections API.</p></div>
<div class="paragraph"><p>Існує так багато методів, що ми збираємось розбити їх на частини, починаючи з абстрактних методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
    <span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
    <span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Примірник <code>Foldable</code> має реалізувати тільки <code>foldMap</code> та <code>foldRight</code>, щоб отримати всю функціональність цього типокласу, хоча методи типово оптимізовані для специфічних структур даних.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>.foldMap</code> має маркетингове ім'я: <code>MapReduce</code>. Беручи <code>F[A]</code>, функцію від <code>A</code> до <code>B</code>, та спосіб комбінувати <code>B</code> (запроваджену в <code>Monoid</code>,разом з <code>zero</code> <code>B</code>), ми можемо спродукувати сумарне значення типу <code>B</code>. Немає жодного примусу щодо порядку операцій, що дозволяє паралельне виконання.
</p>
</li>
<li>
<p>
<code>foldRight</code> не вимагає, щоб його параметри мали <code>Monoid</code>, що означає, що він потребує стартове значення <code>z</code>, та спосіб комбінувати кожний елемент даних в структурі даних з сумарним значенням. Порядок для обходу елементів зправа наліво, і, таким чином, він не може бути розпаралелений.
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>foldRight</code> концептуально те саме, що і <code>foldRight</code> в Scala <code>stdlib</code>. Однак існує проблема з сигнатурою <code>stdlib</code> <code>foldRight</code>, вирішена в Scalaz: дуже великі структури даних можуть переповнити стек. <code>List.foldRight</code> махлює, реалізуючи <code>foldRight</code> як реверсований <code>foldLeft</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">override</span> <span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
    <span class="n">reverse</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">z</span><span class="o">)((</span><span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>але концепція реверсу не є універсальною, та цей обхідний шлях не може бути використаний для всіх структур даних. Скажімо, ми бажаємо знайти мале число в <code>Stream</code>, з ранішним виходом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="mi">100000</span><span class="o">).</span><span class="n">toStream</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
           <span class="o">(</span><span class="n">el</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">el</span><span class="o">)</span> <span class="o">||</span> <span class="n">acc</span>
         <span class="o">}</span>
  <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span>
    <span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Iterator</span><span class="o">.</span><span class="n">toStream</span><span class="o">(</span><span class="nc">Iterator</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1403</span><span class="o">)</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Scalaz вирішує цю проблему, беручи параметр за ім'ям для значення агрегату:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">|=&gt;</span> <span class="mi">100000</span><span class="o">).</span><span class="n">foldRight</span><span class="o">(</span><span class="kc">false</span><span class="o">)(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="k">=&gt;</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">el</span><span class="o">)</span> <span class="o">||</span> <span class="n">acc</span> <span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>що означає, що <code>acc</code> не обчислюється, доки він не буде потрібний.</p></div>
<div class="paragraph"><p>Корисно мати на увазі, що не всі операції стеко-безпечні в <code>foldRight</code>. Якщо ми запитаємо обчислення всіх елементів, ми також можемо отримати <code>StackOverflowError</code> зі Scalaz <code>EphemeralStream</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1L</span> <span class="o">|=&gt;</span> <span class="mi">100000L</span><span class="o">).</span><span class="n">foldRight</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="k">=&gt;</span> <span class="n">el</span> <span class="o">|+|</span> <span class="n">acc</span> <span class="o">)</span>
  <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span>
    <span class="n">at</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Foldable</span><span class="o">.</span><span class="nc">$anonfun$foldr$1</span><span class="o">(</span><span class="nc">Foldable</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">100</span><span class="o">)</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<code>foldLeft</code> проходить по елементах зліва направо. <code>foldLeft</code> може бути реалізований в термінах <code>foldMap</code>, але більшість примірників обирають реалізувати його, бо це дуже базова операція. Оскільки він звичайно реалізований за допомогою хвостової рекурсії, тут нема параметрів за ім'ям.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Єдине правило для <code>Foldable</code> в тому, що <code>foldLeft</code> та <code>foldRight</code> повинні кожний бути сумісним з <code>foldMap</code> для моноїдних операцій. Тобто додавати елемент до списку для <code>foldLeft</code>, та передставляти елемент перед списком для <code>foldRight</code>. Однак <code>foldLeft</code> та <code>foldRight</code> не мають бути сумісними один з одним: фактично, вони часто продукують реверс один одного.</p></div>
<div class="paragraph"><p>Простіша річ, що можна зробити з <code>foldMap</code>, це використати функцію <code>identity</code>, даючи <code>fold</code> (природна сума моноїдальних елементів), з лівими/правими варівантами, щоб дозволити вибір на основі критерів продуктивності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">sumr</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">suml</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Згадавши що ми навчились про <code>Monoid</code>, ми запишемо таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">].</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми знаємо, що це дурня, і ми маємо писати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">toIList</span><span class="o">.</span><span class="n">fold</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">TradeTemplate</span> <span class="o">=</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
                         <span class="nc">List</span><span class="o">(</span><span class="mi">2017</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">05</span><span class="o">,</span><span class="mi">2017</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">05</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.fold</code> не робить з <code>stdlib List</code>, оскільки він вже має метод з назвою <code>fold</code>, що вже робить свої власні речі в свій власний спосіб.</p></div>
<div class="paragraph"><p>Дивно названий <code>intercalate</code> всатавляє специфічний <code>A</code> між кожним елементом, перед тим, як виконати <code>fold</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">intercalate</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>що є узагальненою версією <code>stdlib mkString</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">).</span><span class="n">intercalate</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;foo,bar&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>foldLeft</code> провадить механізм отримання кожного елементу через індекс доступу, включаючи декілька інших пов'язаних методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">index</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">indexOr</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">default</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">A</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">length</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">count</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">length</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">element</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Scalaz є чистою бібліотекою для тільки загальних функцій. Коли <code>List(0)</code> може закидати виключення, <code>Foldable.index</code> повертає <code>Option[A]</code> зі зручним <code>.indexOr</code>, що повертає A коли надане значення по замовчанню. <code>.element</code> подібний до <code>stdlib</code> <code>.contains</code>, але використовує <code>Equal</code> замість хворобливо-визначеного JVM <code>equality</code>.</p></div>
<div class="paragraph"><p>Ці методи насправді виглядають як API колекцій. Та, звичайно, все з <code>Foldable</code> може бути перетворено на <code>List</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">toList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є перетворення до інших <code>stdlib</code> та <code>Scalaz</code> типів даних, таких як <code>.toSet</code>, <code>.toVector</code>, <code>.toStream</code>, <code>.to[T &lt;: TraversableLike]</code>, <code>.toIList</code> і так далі.</p></div>
<div class="paragraph"><p>В наявності корисні перевірки предикатів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">filterLength</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">all</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">any</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>filterLength</code> це спосіб підрахувати, як багато елементів <code>true</code> для предиката, <code>all</code> та <code>any</code> повертають <code>true</code>, якщо всі (або любий) елементи задовільняють предикату, та можуть виходити рано.</p></div>
<div class="paragraph"><p>Ми бачили <code>NonEmptyList</code> в попередніх главах. Для краткості ми використовували псевдоним типу <code>Nel</code> замість <code>NonEmptyList</code>.</p></div>
<div class="paragraph"><p>Також в попередніх главах ми бачили <code>IList</code>, згадайте, що це альтернатива до <code>stdlib</code> <code>List</code> з видаленими нечистими методами, як <code>apply</code>.</p></div>
<div class="paragraph"><p>Ми можемо розділити <code>F[A]</code> на частини, чий результат буде те саме <code>B</code>, за допомогою <code>splitBy</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">splitBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[(</span><span class="kt">B</span>, <span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">splitByRelation</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">splitWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">selectSplit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">findLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">findRight</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">IList</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;faz&quot;</span><span class="o">,</span> <span class="s">&quot;gaz&quot;</span><span class="o">,</span> <span class="s">&quot;baz&quot;</span><span class="o">).</span><span class="n">splitBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="n">res</span> <span class="k">=</span> <span class="o">[(</span><span class="kt">f</span>, <span class="o">[</span><span class="kt">foo</span><span class="o">])</span>, <span class="o">(</span><span class="kt">b</span>, <span class="o">[</span><span class="kt">bar</span>, <span class="kt">bar</span><span class="o">])</span>, <span class="o">(</span><span class="kt">f</span>, <span class="o">[</span><span class="kt">faz</span><span class="o">])</span>, <span class="o">(</span><span class="kt">g</span>, <span class="o">[</span><span class="kt">gaz</span><span class="o">])</span>, <span class="o">(</span><span class="kt">b</span>, <span class="o">[</span><span class="kt">baz</span><span class="o">])]</span>
</pre></div></div></div>
<div class="paragraph"><p>зауважте, що є два значення, індексовані через <code>'b'</code>.</p></div>
<div class="paragraph"><p><code>splitByRelation</code> уникає потреби для <code>Equal</code>, але ми маємо запровадити оператор порівняння.</p></div>
<div class="paragraph"><p><code>splitWith</code> розділяє елементи на групи, що або задовільняють предикату, або ні. <code>selectSplit</code> обирає групи елементів, що задовільняють предикату, відкидаючи інші. Це один з тих рідких випадків, коли два методи поділяють ту саму сигнатуру типів, але мають різне значення.</p></div>
<div class="paragraph"><p><code>findLeft</code> та <code>findRight</code> перший елемент зліва або зправа, відповідно, що задовільняє предикату.</p></div>
<div class="paragraph"><p>Надалі використовуючи <code>Equal</code> та <code>Order</code>, ми маємо окремі мектоди, що повертають групування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">distinct</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">distinctE</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">distinctBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</pre></div></div></div>
<div class="paragraph"><p><code>distinct</code> реалізований більш ефективно, ніж <code>distinctE</code>, оскільки він може використовувати впорядкування, і таким чином використовувати алгоритм швидкого сортування, що значно швидший, ніж природний <code>stdlib</code> <code>List.distinct</code>. Структури даних (такі як множини) можуть реалізувати <code>distinct</code> в своєму <code>Foldable</code> без виконання жодної роботи.</p></div>
<div class="paragraph"><p><code>distinctBy</code> дозволяє груаування по результату застосування функції до елементів. Наприклад, групувати імена по першій літері.</p></div>
<div class="paragraph"><p>Ми можемо надалі використовувати <code>Order</code> через виділення мінімального або максимального елементів (або обоє екстремуми), включаючи різні використання шаблону <code>Of</code> або <code>By</code> до першої мапи до іншого типу, або для використання іншого типу для виконання порівняння впорядкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">maximum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">maximumOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">maximumBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">minimum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">minimumOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">minimumBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">extrema</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">extremaOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">B</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">extremaBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, ми можемо запитати, який рядок <code>String</code> є максимальним <code>By</code> довжині, або яка максимальна довжина <code>Of</code> елементів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;fazz&quot;</span><span class="o">).</span><span class="n">maximumBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">fazz</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;fazz&quot;</span><span class="o">).</span><span class="n">maximumOf</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це підсумовує ключові властивості <code>Foldable</code>. Вивод такий, що будь-що, що ми очікуємо знайти в бібліотеці колекцій, можливо є в <code>Foldable</code>, та якщо ні, воно мало б там бути.</p></div>
<div class="paragraph"><p>Ми завершимо деякими варіаціями методів, що ми вже бачили. Зпочатку це методи, що приймають <code>Semigroup</code> замість <code>Monoid</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">fold1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldMap1Opt</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">sumr1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">suml1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>та повертає <code>Option</code>, щоб прийняти до уваги порожні структури даних (згадайте, що <code>Semigroup</code> не має нуля).</p></div>
<div class="paragraph"><p>Методи читаються “1-Option”, не <em>10 pt</em> як в типографіці.</p></div>
<div class="paragraph"><p>Типоклас <code>Foldable1</code> містить значно більше <code>Semigroup</code> варіантів для <code>Monoid</code> методів, показаних тут (всі з суфіксом 1), та мають сенс для структур, що ніколи не порожні, без вимоги бути <code>Monoid</code> від елементів.</p></div>
<div class="paragraph"><p>Важливо, що існують варіанти, що приймають манадичні значення повернення. Ми вже використовували <code>foldLeftM</code>, коли ми зпочатку писали бізнес логіку для нашого застосування, і тепер ми знаємо, що це походить від <code>Foldable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">foldLeftM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldRightM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldMapM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">findMapM</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">allM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">anyM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_5_4_3_traverse">5.4.3 Traverse</h3>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-23 23:54:04 EEST
</div>
</div>
</body>
</html>
