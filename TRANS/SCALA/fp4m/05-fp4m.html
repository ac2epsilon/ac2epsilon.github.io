<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="_5__scalaz">5. Типокласи Scalaz</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми зробимо прохід по більшості типокласах в <code>scalaz-core</code>. Ми не використовуємо всі в <code>drone-dynamic-agents</code>, так що ми будемо надавати окремі приклади, коли це треба.</p></div>
<div class="paragraph"><p>Була певна критика найменувань в Scalaz, та функціональному програмуванні загалом. Більшість наіменувань слідують домовленостям, введеним в мові програмування Haskell, базуючись на Category Theory. Почувайте вільно додавати псевдоніми типів, якщо дієслова, основані на первинній функціональності, простіше запам'ятати при навчанні (тобто, <code>Mappable</code>, <code>Pureable</code>, <code>FlatMappable</code>).</p></div>
<div class="paragraph"><p>Перед тим, як ми введемо ієрархію типокласів, ми загостримо нашу увагу на чотирьох найбільш важливих методах з точки зору контроля потоком: методи, які ми будемо використовувати в більшості FP застосувань:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Typeclass</p></td>
<td align="left" valign="top"><p class="table">Method</p></td>
<td align="left" valign="top"><p class="table">From</p></td>
<td align="left" valign="top"><p class="table">Given</p></td>
<td align="left" valign="top"><p class="table">To</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Functor</p></td>
<td align="left" valign="top"><p class="table">map</p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
<td align="left" valign="top"><p class="table">A &#8658; B</p></td>
<td align="left" valign="top"><p class="table">F[B]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Applicative</p></td>
<td align="left" valign="top"><p class="table">pure</p></td>
<td align="left" valign="top"><p class="table">A</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Monad</p></td>
<td align="left" valign="top"><p class="table">flatMap</p></td>
<td align="left" valign="top"><p class="table">F[A]</p></td>
<td align="left" valign="top"><p class="table">A &#8658; F[B]</p></td>
<td align="left" valign="top"><p class="table">F[B]</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Traverse</p></td>
<td align="left" valign="top"><p class="table">sequence</p></td>
<td align="left" valign="top"><p class="table">F[G[A]]</p></td>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table">G[F[A]]</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Ми знаємо, що операції, що повертають <code>F[\_]</code> можуть виконуватись послідовно в розширеному <code>for</code> через <code>.flatMap</code>, визначеному на його <code>Monad[F]</code>. Контекст <code>F[_]</code> може бути промислений як контейнер для бажаного ефекту з <code>A</code> в якості виходу: <code>flatMap</code> дозволяє нам генерувати нові ефекти <code>F[B]</code> під час виконання, базуючись на результатах обчислення попередніх ефектів.</p></div>
<div class="paragraph"><p>Звичайно, не всі конструкції типів <code>F[_]</code> ефективні, навіть якщо вони мають <code>Monad[F]</code>. Часто вони є структурами даних. Через використання найменьш специфічної абстракції, ми можемо повторно використовувати код для <code>List</code>, <code>Either</code>, <code>Future</code> і так далі.</p></div>
<div class="paragraph"><p>Якщо вам треба тільки трансформувати вивід від <code>F[_]</code>, що є просто <code>map</code>, введене через <code>Functor</code>. В Главі 3 ми виконуємо ефекти паралельно, через створення продукту і відображення по ним. В функціонально програмуванні розпаралелювальні обчислення визначаються менш потужними, ніж послідовні.</p></div>
<div class="paragraph"><p>Посеред <code>Monad</code> та <code>Functor</code> знаходиться <code>Applicative</code>, що визначає <code>pure</code>, що дозволяє нам підійняти розглянуване значення, або створити структуру даних з одного значення.</p></div>
<div class="paragraph"><p><code>.sequence</code> корисне для переаранжування конструкторів типу. Якщо ви маєте <code>F[G[\_]]</code>, але нам треба <code>G[F[_]]</code>, тобто <code>List[Future[Int]]</code>, але нам треба <code>Future[List[Int]]</code>, це є <code>.sequence</code>.</p></div>
<div class="sect2">
<h3 id="_5_1_">5.1 Передмова</h3>
<div class="paragraph"><p>Ця глава довша ніж звичайно, і стисло напакована інформацією: досить логічно атакувати її за декілька раз. Запам'ятовування всього може вимагати нелюдських якостей, так що розглядайте цю главу як шлях дізнатись, де шукати додаткову інформацію.</p></div>
<div class="paragraph"><p>Помітна відсутність типокласів, що розширюють <code>Monad</code>. Вони отримують свою окрему главу пізніше.</p></div>
<div class="paragraph"><p>Scalaz використовує генерацію кода, не симуляцію. Однак для краткості ми представляємо шматки коду з <code>@typeclass</code>. Еквівалентний синтаксис доступний, коли ми робимо <code>import scalaz._, Scalaz._</code>, та доступний в пакунку <code>scalaz.syntax</code> в джерельному коді <code>scalaz</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_5_2__">5.2 Додавані речі</h3>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|+|&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">append</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span>

    <span class="k">def</span> <span class="n">multiply1</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">A</span>

    <span class="k">def</span> <span class="n">multiply</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">zero</span> <span class="k">else</span> <span class="n">multiply1</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Band</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Semigroup</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p><code>|+|</code> відоме як оператор TIE Fighter. Існує також Advanced TIE Fighter в наступному розділі, що дуже захопливо.</p></div>
<div class="paragraph"><p>Напівгрупа <code>Semigroup</code> може бути визначене для типу, якщо два значення може бути скомбіноване. Операція має бути асоціативна, що означає, що порядок вкладених операцій не має значення:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  (a |+| b) |+| c == a |+| (b |+| c)

  (1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)</code></pre>
</div></div>
<div class="paragraph"><p><code>Monoid</code> є <code>Semigroup</code> з нульовим елементом (також називається порожнім або ідентичністю). Комбінація нуля з любим іншим <code>a</code> повинно давати <code>a</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  a |+| zero == a

  a |+| 0 == a</code></pre>
</div></div>
<div class="paragraph"><p>Це, можливо, повертає пам'ять до <code>Numeric</code> з Глави 4. Є реалізації <code>Monoid</code> для всіх примітивних чисел, але концепція додаваних речей корисна і за межами чисел.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">|+|</span> <span class="s">&quot; &quot;</span> <span class="o">|+|</span> <span class="s">&quot;world!&quot;</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;hello world!&quot;</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Band</code> має закон, що операція додавання до тих самих двох операндів ідемпотентна, тобто дає те саме значення. Прикладом може бути будь-що, що може мати тільки одне значення, як <code>Unit</code>, найменьша вища межа, або <code>Set</code>. <code>Band</code> не провадить додаткових методів, але користувачі можуть використовувати гарантії для оптимізації продуктивності.</p></div>
<div class="paragraph"><p>Viktor Klang з Lightbend притендує на фразу ефективно-одноразової доставки для обробки повідомлень, з іденпотентними операціями, тобто <code>Band.append</code>.</p></div>
<div class="paragraph"><p>Як реалістичний приклад для <code>Monoid</code>, розглянемо торгівельну систему, що має велику базу даних повторно використовуваних шаблонів торгівлі. Заповнення значень по замовчанню для нових торгів включає вибір та комбінування декількох шаблонів, з політикою поєднання “останнє правило перемагає”, якщо два шаблони мають значення для того самого поля. Робота “обирання” вже виконана для анс іншою системою, наше завдання є скомбінувати шаблони по порядку.</p></div>
<div class="paragraph"><p>Ми будемо створювати просту схему шаблонів для демонстрації принципів, але майте на увазі, що реалістична система може мати більш складні ADT.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Currency</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">EUR</span> <span class="k">extends</span> <span class="nc">Currency</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">USD</span> <span class="k">extends</span> <span class="nc">Currency</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
    <span class="n">payments</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">java.time.LocalDate</span><span class="o">],</span>
    <span class="n">ccy</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Currency</span><span class="o">],</span>
    <span class="n">otc</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми пишемо метод, що приймає шаблони: <code>List[TradeTemplate]</code>, нам треба тільки викликати</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">val</span> <span class="n">zero</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">].</span><span class="n">zero</span>
  <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>і наша робота виконана!</p></div>
<div class="paragraph"><p>Але щоб отримати <code>zero</code> або викликати <code>|+|</code> ми маємо мати примірник  <code>Monoid[TradeTemplate]</code>. Хоча ми загалом наслідувати його в наступній главі, доки ми будемо створювати примірник на компанйоні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">TradeTemplate</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">monoid</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span>
      <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">TradeTemplate</span><span class="o">(</span><span class="n">a</span><span class="o">.</span><span class="n">payments</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">payments</span><span class="o">,</span>
                              <span class="n">a</span><span class="o">.</span><span class="n">ccy</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">ccy</span><span class="o">,</span>
                              <span class="n">a</span><span class="o">.</span><span class="n">otc</span> <span class="o">|+|</span> <span class="n">b</span><span class="o">.</span><span class="n">otc</span><span class="o">),</span>
      <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це не робить те, що ми бажаємо, оскільки <code>Monoid[Option[A]]</code> буде додавати свій вміст, тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">None</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">|+|</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>в той час, коли ми бажаємо “останній закон перемагає”. Ми можемо перекрити <code>Monoid[Option[A]]</code> по замовчанню своїм власним:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">lastWins</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Monoid</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Monoid</span><span class="o">.</span><span class="n">instance</span><span class="o">(</span>
    <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="nc">None</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">only</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">only</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="n">only</span><span class="o">)</span>   <span class="k">=&gt;</span> <span class="n">only</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span>   <span class="o">,</span> <span class="n">winner</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">winner</span>
    <span class="o">},</span>
    <span class="nc">None</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер все компілюється, спробуйте самі…</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">java.time.</span><span class="o">{</span><span class="nc">LocalDate</span> <span class="k">=&gt;</span> <span class="nc">LD</span><span class="o">}</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">templates</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">None</span><span class="o">,</span>      <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">Some</span><span class="o">(</span><span class="nc">EUR</span><span class="o">),</span> <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">LD</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">2017</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">5</span><span class="o">)),</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span> <span class="nc">None</span><span class="o">),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="nc">LD</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="mi">2017</span><span class="o">,</span> <span class="mi">9</span><span class="o">,</span> <span class="mi">5</span><span class="o">)),</span> <span class="nc">None</span><span class="o">,</span>      <span class="nc">Some</span><span class="o">(</span><span class="kc">true</span><span class="o">)),</span>
           <span class="nc">TradeTemplate</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span>                     <span class="nc">None</span><span class="o">,</span>      <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
         <span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">TradeTemplate</span> <span class="o">=</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
                         <span class="nc">List</span><span class="o">(</span><span class="mi">2017</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">05</span><span class="o">,</span><span class="mi">2017</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">05</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Все що вам треба було зробити, це реалізовати один фрагмент бізнес логіки, та <code>Monoid</code> потурбується про све інше за нас!</p></div>
<div class="paragraph"><p>Зауважте, що список платежів сконкатенований. Це тому, що по замовчанню <code>Monoid[List]</code> використовує конкатенацію елементів, та це часто бажана поведінка. Якщо бізнес потреби інші, може бути простим випадком запровадити власний <code>Monoid[List[LocalDate]]</code>. Згадайте з Глави 4, що з повним поліморфізмом ми можемо мати іншу реалізацію <code>append</code>, в залежності від <code>E</code> в <code>List[E]</code>, не тільки на основі рантайм класу <code>List</code>.</p></div>
<div class="paragraph"><p>Коли ми ввели типокласу в Главі 4, ми казали, що може бути тільки одна реалізація типкласа для наданого параметра типу, тобто тільки один <code>Monoid[Option[Boolean]]</code> в застосуванні. Сирітливі примірники, як <code>lastWins</code> є простішим шляхом зруйнувати когерентність.</p></div>
<div class="paragraph"><p>Ми можемо спробувати виправдати локально зруйновану когерентність типкласів, зробивши <code>lastWins</code> приватним, але коли ми дійдемо до типокалсу <code>Plus</code>, ми побачимо кращий шлях для реалізації нашого <code>Monoid</code>. Коли ми отримаємо теговані типи, ми побачимо навіть кращий спосіб: використовуючи <code>LastOption</code> замість <code>Option</code> в нашій моделі даних.</p></div>
<div class="paragraph"><p>Будь-ласка, не ламайте когерентність типокласів самостійно, дітки.</p></div>
</div>
<div class="sect2">
<h3 id="_5_3___">5.3 Об'єктні речі</h3>
<div class="paragraph"><p>В главі про дані та функціональність ми казали, що нотація еквівалентності JVM поламана для багатьох речей, що ми можемо покласти до ADT. Проблема в тому, що JVM була розроблена для Java, та <code>equals</code> визначений для <code>java.lang.Object</code>, чи має це сенс, чи ні. Немає способу видалити <code>equals</code>, і немає шляху гарантувати, що він реалізований.</p></div>
<div class="paragraph"><p>Однак в FP ми обираємо типокласи для поліморфної функціональності, і навіть концепція еквівалентності захоплюється під час компіляції.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>  <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;===&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;/==&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">notEqual</span><span class="o">(</span><span class="n">a1</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">!</span><span class="n">equal</span><span class="o">(</span><span class="n">a1</span><span class="o">,</span> <span class="n">a2</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість <code>===</code> (потрійна рівність) більш типо-безпечна, ніж <code>==</code> (родвійна рівність), оскільки вона може бути скомпільована тільки коли типи ті самі на обох боках порівняння. Це відловлює багато вад.</p></div>
<div class="paragraph"><p><code>equal</code> має ті самі вимоги до реалізації, що і <code>Object.equals</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>    <span class="n">commutative</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f2</span> <span class="n">implies</span> <span class="n">f2</span> <span class="o">===</span> <span class="n">f1</span>
    <span class="n">reflexive</span> <span class="n">f</span> <span class="o">===</span> <span class="n">f</span>
    <span class="n">transitive</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f2</span> <span class="o">&amp;&amp;</span> <span class="n">f2</span> <span class="o">===</span> <span class="n">f3</span> <span class="n">implies</span> <span class="n">f1</span> <span class="o">===</span> <span class="n">f3</span>
</pre></div></div></div>
<div class="paragraph"><p>Відкидаючи універсальну концепцію <code>Object.equals</code>, ми не приймаємо рівність як гарантовану, коли ми конструюємо ADT,зупиняючи нас під час компіляції від очікування еквівалентності, там де її немає.</p></div>
<div class="paragraph"><p>Продовжуючи тренд заміни старих Java концепцій, замість маючи дані типу <code>java.lang.Comparable</code>, тепер вони мають відповідний <code>Order</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Equal</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;?|?&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">order</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Ordering</span>

    <span class="k">override</span>  <span class="k">def</span> <span class="n">equal</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">order</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">==</span> <span class="nc">Ordering</span><span class="o">.</span><span class="nc">EQ</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;=&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">lte</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;=&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">gte</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">max</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">min</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">sort</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">,</span> <span class="kt">F</span><span class="o">)</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Ordering</span>
  <span class="k">object</span> <span class="nc">Ordering</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">LT</span> <span class="k">extends</span> <span class="nc">Ordering</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">EQ</span> <span class="k">extends</span> <span class="nc">Ordering</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">GT</span> <span class="k">extends</span> <span class="nc">Ordering</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Order</code> реалізує <code>.equal</code> в термінах нового примітиву <code>.order</code>. Коли типоклас реалізує батьківській примітивний комбінатор з наслідуваним комбінатором, правило заміни для типокласу є додавання. Якщо примірник <code>Order</code> перекривав <code>.equal</code> з причин продуктивності, він має поводитись ідентично до оригіналу.</p></div>
<div class="paragraph"><p>Речі, що мають порядок, також можуть бути дескретними, дозволяючи нам крокувати до наступного або попереднього:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Enum</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Order</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">succ</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span>
    <span class="k">def</span> <span class="n">pred</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span>
    <span class="k">def</span> <span class="n">min</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">max</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;-+-&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">succn</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;---&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">predn</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span> <span class="o">=</span> <span class="o">...</span>

    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|-&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">fromToL</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|--&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">fromStepToL</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|=&gt;&quot;</span> <span class="o">)</span> <span class="k">def</span> <span class="n">fromTo</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">EphemeralStream</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;|==&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">fromStepTo</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">F</span><span class="o">,</span> <span class="n">step</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">to</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">EphemeralStream</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="mi">10</span> <span class="o">|--&gt;</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">12</span><span class="o">,</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">16</span><span class="o">,</span> <span class="mi">18</span><span class="o">,</span> <span class="mi">20</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="sc">&#39;m&#39;</span> <span class="o">|-&gt;</span> <span class="sc">&#39;u&#39;</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">m</span><span class="o">,</span> <span class="n">n</span><span class="o">,</span> <span class="n">o</span><span class="o">,</span> <span class="n">p</span><span class="o">,</span> <span class="n">q</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">s</span><span class="o">,</span> <span class="n">t</span><span class="o">,</span> <span class="n">u</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>|--&gt;</code> є Scalaz Lightsaber. Це синтаксис для Функціонального Програміста. Не таке відволікаюче або довільне як <code>fromStepToL</code>. Елегантний синтаксис… для більш цивілізованого віку.</p></div>
<div class="paragraph"><p>Ми обсудимо <code>EphemeralStream</code> в наступній главі, доки нам лише треба знати, що існує потенційно безкінечна структура даних, що уникає проблем затримання пам'яті в <code>stdlib</code> <code>Stream</code>.</p></div>
<div class="paragraph"><p>Подібно до <code>Object.equals</code>, концепція <code>.toString</code> на кожному класі не має сенсу в Java. Ми бажали б примусити рядковість під час компіляції, і це саме те, чого досягає <code>Show</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Show</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">Cord</span> <span class="o">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">shows</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми будемо досліджувати <code>Cord</code> більш детально в главі по типам даних, нам треба тільки знати, що це ефективна структура даних для зберігання та маніпулювання <code>String</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_5_4__">5.4 Відображувані речі</h3>
<div class="paragraph"><p>Ми сконцентруємось на речах, по яких можна мандрувати та відображувати (робити меппінг), в деякому сенсі:</p></div>
<div class="sect3">
<h4 id="_5_4_1_functor">5.4.1 Functor</h4>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">void</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="o">())</span>
    <span class="k">def</span> <span class="n">fproduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">)))</span>

    <span class="k">def</span> <span class="n">fpair</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">a</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">strengthL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>
    <span class="k">def</span> <span class="n">strengthR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">))</span>

    <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">mapply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)((</span><span class="n">ff</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ff</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Єдиний абстрактний метод є <code>map</code>, і він має робити композицію, тобто меппінг за допомогою <code>f</code>, та потім знову за допомогою <code>g</code>, це те саме, що одночасне відображення за допомогою композиції <code>f</code> та <code>g</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">g</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">andThen</span><span class="o">(</span><span class="n">g</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>map</code> також має виконувати <em>no-op</em>, якщо запроваджена функція є <code>identity</code> (<code>x =&gt; x</code>)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">identity</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>

  <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span> <span class="o">==</span> <span class="n">fa</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Functor</code> визначає деякі зручні методи навколо <code>map</code>, що можуть бути оптимізовані специфічними примірниками. Документація навмисне відсутня в попередніх визначеннях, щоб заохотити до здогадок, що саме робить метод, до того як звернутись до реалізації. Будь ласка, витратьте момент на вивчення тільки сигнатури наступного, перед тим як читати далі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">void</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">fproduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

  <span class="k">def</span> <span class="n">fpair</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">strengthL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>
  <span class="k">def</span> <span class="n">strengthR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span>

  <span class="c1">// harder</span>
  <span class="k">def</span> <span class="n">lift</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">mapply</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<code>void</code> приймає примірник <code>F[A]</code>, та завжди повертає <code>F[Unit]</code>, він забуває всі значення, при цьому зберігаючи структуру.
</p>
</li>
<li>
<p>
<code>fproduct</code> приймає той самий вхід як мапу, але повертає <code>F[(A, B)]</code>, тобто він склаладає в тапли вмісту з результатом, застосовуючи функцію. Це корисно, коли ми бажаємо зберігти також вхідні значення.
</p>
</li>
<li>
<p>
<code>fpair</code> збирає всі елементи <code>A</code> в тапл <code>F[(A, A)]</code>
</p>
</li>
<li>
<p>
<code>strengthL</code> парує вміст <code>F[B]</code> з констанотою <code>A</code> зліва.
</p>
</li>
<li>
<p>
<code>strengthR</code> парує вміст <code>F[A]</code> з константою <code>B</code> зправа.
</p>
</li>
<li>
<p>
<code>lift</code> приймає функцію <code>A =&gt; B</code>, та повертає <code>F[A] =&gt; F[B]</code>. Інишими словами, він бере функцію над вмістом <code>F[A]</code>, та повертає функцію, що оперує на <code>F[A]</code> напряму.
</p>
</li>
<li>
<p>
<code>mapply</code> є головоломкою. Скажімо, ми маємо <code>F[_]</code> для функцій <code>A =&gt; B</code>, та деяке значення <code>A</code>, тоді ми можемо отримати <code>F[B]</code>. Він має сигнатуру, подібну до <code>pure</code>, але вимагає від викликаючого запровадити <code>F[A =&gt; B]</code>.
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>fpair</code>, <code>strengthL</code> та <code>strengthR</code> виглядають досить непотрібними, але вони корисні, коли ми бажаємо залишити деяку інформацію, що інакше може бути втрачена з поля зору.</p></div>
<div class="paragraph"><p><code>Functor</code> має деякий особливий синтакс:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">FunctorOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Functor</span>, <span class="kt">A</span><span class="o">](</span><span class="n">self</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">as</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="n">self</span><span class="o">)(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">&gt;|[</span><span class="kt">B</span><span class="o">](</span><span class="n">b</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">as</span><span class="o">(</span><span class="n">b</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.as</code> та <code>&gt;|</code> є способом заміни виводу за допомогою констант.</p></div>
<div class="paragraph"><p>Коли Scalaz провадить додаткову функціональність як синтаксис, скоріше ніж самі типокласи, це так через бінарну сумісність.</p></div>
<div class="paragraph"><p>Якщо виходить версія Scalaz X.Y.0, неможливо додати методи до типокласів в цій серії релізів для Scala 2.10 та 2.11. Так що має сенс читати обоє, джерело типокласу та його синтаксис.</p></div>
<div class="paragraph"><p>В нашому прикладі застосування, в якості гидкого хаку (яких ми навіть досі не визнавали), ми визначали <code>start</code> та <code>stop</code> для повернення їх входів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">MachineNode</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">MachineNode</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">stop</span> <span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">MachineNode</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">MachineNode</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дозволяє нам писати скорочену бізнес логіку, таку як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="k">_</span>      <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="o">)</span>
    <span class="n">update</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">))</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
<div class="paragraph"><p>та</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">stopped</span> <span class="k">&lt;-</span> <span class="n">nodes</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">stop</span><span class="o">)</span>
    <span class="n">updates</span> <span class="k">=</span> <span class="n">stopped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">).</span><span class="n">toList</span><span class="o">.</span><span class="n">toMap</span>
    <span class="n">update</span>  <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">pending</span> <span class="o">++</span> <span class="n">updates</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
<div class="paragraph"><p>Але цей хак заштовхує непотрібну складність в реалізації. Буде краще, якщо ми дозволимо нашим алгебрам повертати <code>F[Unit]</code> та використовувати <code>as</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">m</span><span class="o">.</span><span class="n">start</span><span class="o">(</span><span class="n">node</span><span class="o">)</span> <span class="n">as</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">node</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>та</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">stopped</span> <span class="k">&lt;-</span> <span class="n">nodes</span><span class="o">.</span><span class="n">traverse</span><span class="o">(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">stop</span><span class="o">(</span><span class="n">a</span><span class="o">)</span> <span class="n">as</span> <span class="n">a</span><span class="o">)</span>
    <span class="n">updates</span> <span class="k">=</span> <span class="n">stopped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">-&gt;</span> <span class="n">world</span><span class="o">.</span><span class="n">time</span><span class="o">).</span><span class="n">toList</span><span class="o">.</span><span class="n">toMap</span>
    <span class="n">update</span>  <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">pending</span> <span class="k">=</span> <span class="n">world</span><span class="o">.</span><span class="n">pending</span> <span class="o">++</span> <span class="n">updates</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">update</span>
</pre></div></div></div>
</div>
</div>
<div class="sect2">
<h3 id="_5_4_2_foldable">5.4.2 Foldable</h3>
<div class="paragraph"><p>Технічно <code>Foldable</code> призначений для структур даних, по яких можна проходити для отримання сумарного значення. Однак це приховує факт, що це одно-типокласова армія, що може запровадити більшість з того, що ви очікуєте побачити в Collections API.</p></div>
<div class="paragraph"><p>Існує так багато методів, що ми збираємось розбити їх на частини, починаючи з абстрактних методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">foldMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
    <span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span>
    <span class="k">def</span> <span class="n">foldLeft</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Примірник <code>Foldable</code> має реалізувати тільки <code>foldMap</code> та <code>foldRight</code>, щоб отримати всю функціональність цього типокласу, хоча методи типово оптимізовані для специфічних структур даних.</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>.foldMap</code> має маркетингове ім'я: <code>MapReduce</code>. Беручи <code>F[A]</code>, функцію від <code>A</code> до <code>B</code>, та спосіб комбінувати <code>B</code> (запроваджену в <code>Monoid</code>,разом з <code>zero</code> <code>B</code>), ми можемо спродукувати сумарне значення типу <code>B</code>. Немає жодного примусу щодо порядку операцій, що дозволяє паралельне виконання.
</p>
</li>
<li>
<p>
<code>foldRight</code> не вимагає, щоб його параметри мали <code>Monoid</code>, що означає, що він потребує стартове значення <code>z</code>, та спосіб комбінувати кожний елемент даних в структурі даних з сумарним значенням. Порядок для обходу елементів зправа наліво, і, таким чином, він не може бути розпаралелений.
</p>
</li>
</ul></div>
<div class="paragraph"><p><code>foldRight</code> концептуально те саме, що і <code>foldRight</code> в Scala <code>stdlib</code>. Однак існує проблема з сигнатурою <code>stdlib</code> <code>foldRight</code>, вирішена в Scalaz: дуже великі структури даних можуть переповнити стек. <code>List.foldRight</code> махлює, реалізуючи <code>foldRight</code> як реверсований <code>foldLeft</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">override</span> <span class="k">def</span> <span class="n">foldRight</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=</span>
    <span class="n">reverse</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="n">z</span><span class="o">)((</span><span class="n">right</span><span class="o">,</span> <span class="n">left</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">op</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>але концепція реверсу не є універсальною, та цей обхідний шлях не може бути використаний для всіх структур даних. Скажімо, ми бажаємо знайти мале число в <code>Stream</code>, з ранішним виходом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="n">until</span> <span class="mi">100000</span><span class="o">).</span><span class="n">toStream</span><span class="o">.</span><span class="n">foldRight</span><span class="o">(</span><span class="kc">false</span><span class="o">)</span> <span class="o">{</span>
           <span class="o">(</span><span class="n">el</span><span class="o">,</span> <span class="n">acc</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">el</span><span class="o">)</span> <span class="o">||</span> <span class="n">acc</span>
         <span class="o">}</span>
  <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span>
    <span class="n">at</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="nc">Iterator</span><span class="o">.</span><span class="n">toStream</span><span class="o">(</span><span class="nc">Iterator</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">1403</span><span class="o">)</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Scalaz вирішує цю проблему, беручи параметр за ім'ям для значення агрегату:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1</span> <span class="o">|=&gt;</span> <span class="mi">100000</span><span class="o">).</span><span class="n">foldRight</span><span class="o">(</span><span class="kc">false</span><span class="o">)(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="k">=&gt;</span> <span class="n">isSmall</span><span class="o">(</span><span class="n">el</span><span class="o">)</span> <span class="o">||</span> <span class="n">acc</span> <span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>що означає, що <code>acc</code> не обчислюється, доки він не буде потрібний.</p></div>
<div class="paragraph"><p>Корисно мати на увазі, що не всі операції стеко-безпечні в <code>foldRight</code>. Якщо ми запитаємо обчислення всіх елементів, ми також можемо отримати <code>StackOverflowError</code> зі Scalaz <code>EphemeralStream</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mi">1L</span> <span class="o">|=&gt;</span> <span class="mi">100000L</span><span class="o">).</span><span class="n">foldRight</span><span class="o">(</span><span class="mi">0L</span><span class="o">)(</span><span class="n">el</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="k">=&gt;</span> <span class="n">el</span> <span class="o">|+|</span> <span class="n">acc</span> <span class="o">)</span>
  <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">StackOverflowError</span>
    <span class="n">at</span> <span class="n">scalaz</span><span class="o">.</span><span class="nc">Foldable</span><span class="o">.</span><span class="nc">$anonfun$foldr$1</span><span class="o">(</span><span class="nc">Foldable</span><span class="o">.</span><span class="n">scala</span><span class="k">:</span><span class="err">100</span><span class="o">)</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="ulist"><ul>
<li>
<p>
<code>foldLeft</code> проходить по елементах зліва направо. <code>foldLeft</code> може бути реалізований в термінах <code>foldMap</code>, але більшість примірників обирають реалізувати його, бо це дуже базова операція. Оскільки він звичайно реалізований за допомогою хвостової рекурсії, тут нема параметрів за ім'ям.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Єдине правило для <code>Foldable</code> в тому, що <code>foldLeft</code> та <code>foldRight</code> повинні кожний бути сумісним з <code>foldMap</code> для моноїдних операцій. Тобто додавати елемент до списку для <code>foldLeft</code>, та передставляти елемент перед списком для <code>foldRight</code>. Однак <code>foldLeft</code> та <code>foldRight</code> не мають бути сумісними один з одним: фактично, вони часто продукують реверс один одного.</p></div>
<div class="paragraph"><p>Простіша річ, що можна зробити з <code>foldMap</code>, це використати функцію <code>identity</code>, даючи <code>fold</code> (природна сума моноїдальних елементів), з лівими/правими варівантами, щоб дозволити вибір на основі критерів продуктивності:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">fold</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">sumr</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">suml</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Згадавши що ми навчились про <code>Monoid</code>, ми запишемо таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">Monoid</span><span class="o">[</span><span class="kt">TradeTemplate</span><span class="o">].</span><span class="n">zero</span><span class="o">)(</span><span class="k">_</span> <span class="o">|+|</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми знаємо, що це дурня, і ми маємо писати так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">templates</span><span class="o">.</span><span class="n">toIList</span><span class="o">.</span><span class="n">fold</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">TradeTemplate</span> <span class="o">=</span> <span class="nc">TradeTemplate</span><span class="o">(</span>
                         <span class="nc">List</span><span class="o">(</span><span class="mi">2017</span><span class="o">-</span><span class="mi">08</span><span class="o">-</span><span class="mi">05</span><span class="o">,</span><span class="mi">2017</span><span class="o">-</span><span class="mi">09</span><span class="o">-</span><span class="mi">05</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="nc">USD</span><span class="o">),</span>
                         <span class="nc">Some</span><span class="o">(</span><span class="kc">false</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.fold</code> не робить з <code>stdlib List</code>, оскільки він вже має метод з назвою <code>fold</code>, що вже робить свої власні речі в свій власний спосіб.</p></div>
<div class="paragraph"><p>Дивно названий <code>intercalate</code> всатавляє специфічний <code>A</code> між кожним елементом, перед тим, як виконати <code>fold</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">intercalate</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>що є узагальненою версією <code>stdlib mkString</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">).</span><span class="n">intercalate</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;foo,bar&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p><code>foldLeft</code> провадить механізм отримання кожного елементу через індекс доступу, включаючи декілька інших пов'язаних методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">index</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">indexOr</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">default</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">A</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">length</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">count</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">length</span><span class="o">(</span><span class="n">fa</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">element</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Scalaz є чистою бібліотекою для тільки загальних функцій. Коли <code>List(0)</code> може закидати виключення, <code>Foldable.index</code> повертає <code>Option[A]</code> зі зручним <code>.indexOr</code>, що повертає A коли надане значення по замовчанню. <code>.element</code> подібний до <code>stdlib</code> <code>.contains</code>, але використовує <code>Equal</code> замість хворобливо-визначеного JVM <code>equality</code>.</p></div>
<div class="paragraph"><p>Ці методи насправді виглядають як API колекцій. Та, звичайно, все з <code>Foldable</code> може бути перетворено на <code>List</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">toList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є перетворення до інших <code>stdlib</code> та <code>Scalaz</code> типів даних, таких як <code>.toSet</code>, <code>.toVector</code>, <code>.toStream</code>, <code>.to[T &lt;: TraversableLike]</code>, <code>.toIList</code> і так далі.</p></div>
<div class="paragraph"><p>В наявності корисні перевірки предикатів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">filterLength</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">all</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">any</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>filterLength</code> це спосіб підрахувати, як багато елементів <code>true</code> для предиката, <code>all</code> та <code>any</code> повертають <code>true</code>, якщо всі (або любий) елементи задовільняють предикату, та можуть виходити рано.</p></div>
<div class="paragraph"><p>Ми бачили <code>NonEmptyList</code> в попередніх главах. Для краткості ми використовували псевдоним типу <code>Nel</code> замість <code>NonEmptyList</code>.</p></div>
<div class="paragraph"><p>Також в попередніх главах ми бачили <code>IList</code>, згадайте, що це альтернатива до <code>stdlib</code> <code>List</code> з видаленими нечистими методами, як <code>apply</code>.</p></div>
<div class="paragraph"><p>Ми можемо розділити <code>F[A]</code> на частини, чий результат буде те саме <code>B</code>, за допомогою <code>splitBy</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">splitBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[(</span><span class="kt">B</span>, <span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">])]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">splitByRelation</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">r</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">splitWith</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">selectSplit</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nel</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">findLeft</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">findRight</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">IList</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span><span class="o">,</span> <span class="s">&quot;faz&quot;</span><span class="o">,</span> <span class="s">&quot;gaz&quot;</span><span class="o">,</span> <span class="s">&quot;baz&quot;</span><span class="o">).</span><span class="n">splitBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
  <span class="n">res</span> <span class="k">=</span> <span class="o">[(</span><span class="kt">f</span>, <span class="o">[</span><span class="kt">foo</span><span class="o">])</span>, <span class="o">(</span><span class="kt">b</span>, <span class="o">[</span><span class="kt">bar</span>, <span class="kt">bar</span><span class="o">])</span>, <span class="o">(</span><span class="kt">f</span>, <span class="o">[</span><span class="kt">faz</span><span class="o">])</span>, <span class="o">(</span><span class="kt">g</span>, <span class="o">[</span><span class="kt">gaz</span><span class="o">])</span>, <span class="o">(</span><span class="kt">b</span>, <span class="o">[</span><span class="kt">baz</span><span class="o">])]</span>
</pre></div></div></div>
<div class="paragraph"><p>зауважте, що є два значення, індексовані через <code>'b'</code>.</p></div>
<div class="paragraph"><p><code>splitByRelation</code> уникає потреби для <code>Equal</code>, але ми маємо запровадити оператор порівняння.</p></div>
<div class="paragraph"><p><code>splitWith</code> розділяє елементи на групи, що або задовільняють предикату, або ні. <code>selectSplit</code> обирає групи елементів, що задовільняють предикату, відкидаючи інші. Це один з тих рідких випадків, коли два методи поділяють ту саму сигнатуру типів, але мають різне значення.</p></div>
<div class="paragraph"><p><code>findLeft</code> та <code>findRight</code> перший елемент зліва або зправа, відповідно, що задовільняє предикату.</p></div>
<div class="paragraph"><p>Надалі використовуючи <code>Equal</code> та <code>Order</code>, ми маємо окремі мектоди, що повертають групування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">distinct</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">distinctE</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">distinctBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Equal</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
</pre></div></div></div>
<div class="paragraph"><p><code>distinct</code> реалізований більш ефективно, ніж <code>distinctE</code>, оскільки він може використовувати впорядкування, і таким чином використовувати алгоритм швидкого сортування, що значно швидший, ніж природний <code>stdlib</code> <code>List.distinct</code>. Структури даних (такі як множини) можуть реалізувати <code>distinct</code> в своєму <code>Foldable</code> без виконання жодної роботи.</p></div>
<div class="paragraph"><p><code>distinctBy</code> дозволяє груаування по результату застосування функції до елементів. Наприклад, групувати імена по першій літері.</p></div>
<div class="paragraph"><p>Ми можемо надалі використовувати <code>Order</code> через виділення мінімального або максимального елементів (або обоє екстремуми), включаючи різні використання шаблону <code>Of</code> або <code>By</code> до першої мапи до іншого типу, або для використання іншого типу для виконання порівняння впорядкування.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">maximum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">maximumOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">maximumBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">minimum</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">minimumOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">minimumBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="k">def</span> <span class="n">extrema</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">extremaOf</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">B</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">extremaBy</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Order</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span>
</pre></div></div></div>
<div class="paragraph"><p>Наприклад, ми можемо запитати, який рядок <code>String</code> є максимальним <code>By</code> довжині, або яка максимальна довжина <code>Of</code> елементів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;fazz&quot;</span><span class="o">).</span><span class="n">maximumBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">fazz</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="s">&quot;foo&quot;</span><span class="o">,</span> <span class="s">&quot;fazz&quot;</span><span class="o">).</span><span class="n">maximumOf</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це підсумовує ключові властивості <code>Foldable</code>. Вивод такий, що будь-що, що ми очікуємо знайти в бібліотеці колекцій, можливо є в <code>Foldable</code>, та якщо ні, воно мало б там бути.</p></div>
<div class="paragraph"><p>Ми завершимо деякими варіаціями методів, що ми вже бачили. Зпочатку це методи, що приймають <code>Semigroup</code> замість <code>Monoid</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">fold1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldMap1Opt</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">sumr1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">suml1Opt</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>та повертає <code>Option</code>, щоб прийняти до уваги порожні структури даних (згадайте, що <code>Semigroup</code> не має нуля).</p></div>
<div class="paragraph"><p>Методи читаються “1-Option”, не <em>10 pt</em> як в типографіці.</p></div>
<div class="paragraph"><p>Типоклас <code>Foldable1</code> містить значно більше <code>Semigroup</code> варіантів для <code>Monoid</code> методів, показаних тут (всі з суфіксом 1), та мають сенс для структур, що ніколи не порожні, без вимоги бути <code>Monoid</code> від елементів.</p></div>
<div class="paragraph"><p>Важливо, що існують варіанти, що приймають манадичні значення повернення. Ми вже використовували <code>foldLeftM</code>, коли ми зпочатку писали бізнес логіку для нашого застосування, і тепер ми знаємо, що це походить від <code>Foldable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">foldLeftM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">B</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldRightM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="o">=&gt;</span><span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">foldMapM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B:</span> <span class="kt">Monoid</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">findMapM</span><span class="o">[</span><span class="kt">M</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">M</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]])</span><span class="k">:</span> <span class="kt">M</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">allM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">anyM</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_5_4_3_traverse">5.4.3 Traverse</h3>
<div class="paragraph"><p><code>Traverse</code> це те, що відбувається, коли ми зкрестимо <code>Functor</code> з <code>Foldable</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Traverse</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="k">with</span> <span class="nc">Foldable</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">traverse</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">G</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span>
    <span class="k">def</span> <span class="n">sequence</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Applicative</span>, <span class="kt">A</span><span class="o">](</span><span class="n">fga</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">G</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">G</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">reverse</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">zipL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">zipR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">indexed</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">A</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">zipWithL</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">zipWithR</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">mapAccumL</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">mapAccumR</span><span class="o">[</span><span class="kt">S</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">z</span><span class="k">:</span> <span class="kt">S</span><span class="o">)(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">A</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">S</span><span class="o">,</span> <span class="n">B</span><span class="o">))</span><span class="k">:</span> <span class="o">(</span><span class="kt">S</span><span class="o">,</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>На початку цієї глави ми показали важливість <code>traverse</code> та <code>sequence</code> для перестановки конструкторів типу щоб задовільнити вимогам (тобто, <code>List[Future[_]]</code> на <code>Future[List[_]]</code>).</p></div>
<div class="paragraph"><p>В <code>Foldable</code> ми не змогли переконатись, що <code>reverse</code> було універсальною концепцією, але тепер ми можемо обертати речі.</p></div>
<div class="paragraph"><p>Ми також можемо поєднати разом дві речі, що мають <code>Traverse</code>, отримуючи <code>None</code>, коли одна сторона вичерпає свої елементи, використовуючи <code>zipL</code> або <code>zipR</code>, щоб знати, з якого боку урізати, коли довжина не співпадає. Особливий різновид <code>zip</code> є додавання індексу до кожного індексованого елементу.</p></div>
<div class="paragraph"><p><code>zipWithL</code> та <code>zipWithR</code> дозволяють комбінувати обоє частини в новий тип, та потім повертати як <code>F[C]</code>.</p></div>
<div class="paragraph"><p><code>mapAccumL</code> та <code>mapAccumR</code> є регулярні мапи, скомбіновані з аккумулятором. Якщо за старими способами Java ми мали звернутись до <code>var</code>, та посилатись до неї з <code>map</code>, нам слідувало б використовувати <code>mapAccumL</code>.</p></div>
<div class="paragraph"><p>Наприклад, скажімо ми маємо список слів, та ми бажаємо відкидати слова, які ми бачили. Алгоритму фільтрації не дозволяється обробляти список слів другий раз, так що він може бути маштабований до необмеженого потоку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">freedom</span> <span class="k">=</span>
  <span class="s">&quot;&quot;&quot;We campaign for these freedoms because everyone deserves them.</span>
<span class="s">     With these freedoms, the users (both individually and collectively)</span>
<span class="s">     control the program and what it does for them.&quot;&quot;&quot;</span>
     <span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\s+&quot;</span><span class="o">)</span>
     <span class="o">.</span><span class="n">toList</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">clean</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">replaceAll</span><span class="o">(</span><span class="s">&quot;[,.()]+&quot;</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">freedom</span>
         <span class="o">.</span><span class="n">mapAccumL</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span> <span class="o">(</span><span class="n">seen</span><span class="o">,</span> <span class="n">word</span><span class="o">)</span> <span class="k">=&gt;</span>
           <span class="k">val</span> <span class="n">cleaned</span> <span class="k">=</span> <span class="n">clean</span><span class="o">(</span><span class="n">word</span><span class="o">)</span>
           <span class="o">(</span><span class="n">seen</span> <span class="o">+</span> <span class="n">cleaned</span><span class="o">,</span> <span class="k">if</span> <span class="o">(</span><span class="n">seen</span><span class="o">(</span><span class="n">cleaned</span><span class="o">))</span> <span class="s">&quot;_&quot;</span> <span class="k">else</span> <span class="n">word</span><span class="o">)</span>
         <span class="o">}</span>
         <span class="o">.</span><span class="n">_2</span>
         <span class="o">.</span><span class="n">intercalate</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>

  <span class="n">res</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="s">&quot;&quot;&quot;We campaign for these freedoms because everyone deserves them.</span>
<span class="s">     With _ _ the users (both individually and collectively)</span>
<span class="s">     control _ program _ what it does _ _&quot;&quot;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті <code>Traverse1</code>, як <code>Foldable1</code>, провадить варіанти ціх методів для структур даних, що не можуть бути порожніми, отримуючи доступ до слабшої <code>Semigroup</code> замість <code>Monoid</code>, та <code>Apply</code> замість <code>Applicative</code>. Згадайте, що <code>Semigroup</code> не має провадити <code>.empty</code>, та <code>Apply</code> не має провадити <code>.point</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_5_4_4_align">5.4.4 Align</h3>
<div class="paragraph"><p><code>Align</code> це щодо злиття та вирівнювання всього за допомогою <code>Functor</code>. Перед розглядом <code>Align</code>, ознайомтесь з типом даних <code>\&amp;/</code>  (читається як <code>These</code>, або <code>hurray!</code>).</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">\&amp;/</span><span class="o">[</span><span class="kt">+A</span>, <span class="kt">+B</span><span class="o">]</span>
  <span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">This</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">aa</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="k">extends</span> <span class="o">(</span><span class="n">A</span> <span class="o">\&amp;/</span> <span class="nc">Nothing</span><span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">That</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">bb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="o">(</span><span class="nc">Nothing</span> <span class="o">\&amp;/</span> <span class="n">B</span><span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Both</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">aa</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">bb</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="o">(</span><span class="n">A</span> <span class="o">\&amp;/</span> <span class="n">B</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>тобто, це дані, що закодовні через включне логічне <code>OR</code>. <code>A</code> або <code>B</code>, або обоє, <code>A</code> та <code>B</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Align</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">alignWith</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="kt">\&amp;/</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">align</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span> <span class="kt">\&amp;/</span> <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">merge</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Semigroup</span><span class="o">](</span><span class="n">a1</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">def</span> <span class="n">pad</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>, <span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">padWith</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="nc">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>alignWith</code> приймає функцію від <code>A</code> або <code>B</code> (або обох) до C, та повертає підважену функціє від тапла <code>F[A]</code> та <code>F[B]</code> до <code>F[C]</code>. <code>align</code> конструює <code>\&amp;/</code> з двох <code>F[_]</code>.</p></div>
<div class="paragraph"><p><code>merge</code> дозволяє нам комбінувати два <code>F[A]</code>, коли <code>A</code> має <code>Semigroup</code>. Наприклад, реалізація <code>Semigroup[Map[K, V]]</code> збігається до <code>Semigroup[V]</code>, комбінуючи два результата елементів в комбінуванні їх значень, і як слідоцтво є те, що <code>Map[K, List[A]]</code> поводиться як мульти-меппінг:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="n">merge</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="s">&quot;bar&quot;</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">foo</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="n">bar</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>та <code>Map[K, Int]</code> просто приводить у відповідність свій вміст під час злиття:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="n">merge</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">foo</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">bar</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.pad</code> та <code>.padWith</code> призначені для часткового злиття структур даних, що можуть не мати відповідного елементу з одного боку. Наприклад, якщо ви бажаєте аргегувати неазлежні голоси, та залишити інформацію, звідки походять ці голоси:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="n">pad</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">foo</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">)),</span> <span class="n">bar</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">None</span><span class="o">,</span><span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">)))</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;bar&quot;</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">pad</span> <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;foo&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">foo</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">)),</span> <span class="n">bar</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span><span class="nc">None</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Існують зручні варіанти <code>align</code>, що використовують структуру <code>\&amp;/</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignSwap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span> <span class="kt">\&amp;/</span> <span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignA</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignB</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignThis</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignThat</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">B</span><span class="o">]]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">alignBoth</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Option</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>що має сенс, дивлячись на сигнатури типів. Приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignSwap</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Both</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Both</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="nc">That</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignA</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignB</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">4</span><span class="o">),</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="nc">None</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignThis</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignThat</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">None</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">alignBoth</span> <span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
  <span class="n">res</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span><span class="mi">4</span><span class="o">)),</span> <span class="nc">Some</span><span class="o">((</span><span class="mi">2</span><span class="o">,</span><span class="mi">5</span><span class="o">)),</span> <span class="nc">None</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що варіанти <code>A</code> та <code>B</code> використовують включне <code>OR</code>, тоді як варіанти <code>This</code> та <code>That</code> виключні,  повертаючи <code>None</code>, якщо значення з обох боків, або коли немає значення з жодного боку.</p></div>
</div>
<div class="sect2">
<h3 id="_5_5_variance">5.5 Variance</h3>
<div class="paragraph"><p>Ми маємо на мить повернутись до <code>Functor</code>, та обсудити наслідника, якого ми досі ігнорували:</p></div>
<div class="paragraph"><p><code>InvariantFunctor</code>,також відомий як еспоненціальний функтор, має метод <code>xmap</code>, що каже, що маючи функцію від <code>A</code> до <code>B</code>, та функцію від <code>B</code> до <code>A</code>, ми можемо конвертувати <code>F[A]</code> на <code>F[B]</code>.</p></div>
<div class="paragraph"><p><code>Functor</code> є скорочене ім'я для того, що мало б називатись коваріантним функтором. Але завдяки тому, що <code>Functor</code> такий популярний, він отримав своє ім'я. Подібно до цього, <code>Contravariant</code> мав би називатись контрваріантним функтором.</p></div>
<div class="paragraph"><p>Функтор реалізує <code>xmap</code> через <code>map</code>, та ігнорує функцію від <code>B</code> до <code>A</code>. <code>Contravariant</code>, з іншого боку, реалізує <code>xmap</code> через <code>contramap</code>, та ігнорує функцію від <code>A</code> до <code>B</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Contravariant</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">InvariantFunctor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">contramap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">xmap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">,</span> <span class="n">g</span><span class="k">:</span> <span class="kt">B</span> <span class="o">=&gt;</span> <span class="n">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">contramap</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">g</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Важливо зауважити, що хоча пов'язані на теоретичному рівні, слова коваріантний, контрваріантний та інваріантний напряму не посилаються на варіантність типів Scala (тобто, префікси <code>+</code> та <code>-</code>, що можуть додаватись до сигнатур). Інваріантність тут означає, що можливо відобразити вміст структури <code>F[A]</code> в <code>F[B]</code>. Використовуючи <code>identity</code> ми можемо бачити, що <code>A</code> може бути безпечно перетворено вверх або вниз в <code>B</code>, в залежності від варіантності функтора.</p></div>
<div class="paragraph"><p><code>.map</code> можна зрозуміти через його контракт: “якщо ви дасте мені <code>F</code> від <code>A</code>, та шлях перетворити <code>A</code> в B, тоді я можу дати вам <code>F</code> від <code>B”</code>.</p></div>
<div class="paragraph"><p>Подібно до цього, <code>.contramap</code> читається як: “якщо ви дасте мені <code>F</code> від <code>A</code>, та спосіб перетворити <code>B</code> в <code>A</code>, тоді я зможу дати вам <code>F</code> від B”.</p></div>
<div class="paragraph"><p>Розглянемо приклад: в нашому застосуванні ми вводимо домен-специфічні типи: <code>Alpha</code>, <code>Beta</code>, <code>Gamma</code>, тощо, щоб переконатись, що ми не змішуємо числа з фінансовими обчисленнями:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Alpha</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>але тепер ми стикаємось з проблемою, що ми не маємо жодних типокласів для ціх нових типів. Якщо ми використовуємо значення в JSON документах, ми маємо записати примірники <code>JsEncoder</code> та <code>JsDecoder</code>.</p></div>
<div class="paragraph"><p>Однак <code>JsEncoder</code> має <code>Contravariant</code>, та <code>JsDecoder</code> має <code>Functor</code>, так що ми можемо вивести примірники. Складемо контракт:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>“якщо ви дасте мені `JsDecoder` для `Double`, і спосіб перейти від `Double` до `Alpha`, тоді я зможу дати вам `JsDecoder` для `Alpha`”.
“якщо ви дасте мені `JsEncoder` для `Double`, і спосіб перейти від `Alpha` до `Double`, тоді я зможу дати вам `JsEncoder` для `Alpha`”.</code></pre>
</div></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">Alpha</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">decoder</span><span class="k">:</span> <span class="kt">JsDecoder</span><span class="o">[</span><span class="kt">Alpha</span><span class="o">]</span> <span class="k">=</span> <span class="nc">JsDecoder</span><span class="o">[</span><span class="kt">Double</span><span class="o">].</span><span class="n">map</span><span class="o">(</span><span class="nc">Alpha</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">encoder</span><span class="k">:</span> <span class="kt">JsEncoder</span><span class="o">[</span><span class="kt">Alpha</span><span class="o">]</span> <span class="k">=</span> <span class="nc">JsEncoder</span><span class="o">[</span><span class="kt">Double</span><span class="o">].</span><span class="n">contramap</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">value</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи на типокласах можуть мати свої параметри типів в контрваріантних позиціях (параметри методів) або в коваріантній позиції (тип повернення). Якщо типоклас має комбінацію коваріантних та контрваріантних позицій, він може мати інваріантний функтор. Наприклад, <code>Semigroup</code> та <code>Monoid</code> мають <code>InvariantFunctor</code>, але не <code>Functor</code> або <code>Contravariant</code>.</p></div>
</div>
<div class="sect2">
<h3 id="_5_6_apply__bind">5.6 Apply та Bind</h3>
<div class="paragraph"><p>Розглянемо цей акт розігріву до <code>Applicative</code> та <code>Monad</code></p></div>
<div class="sect3">
<h4 id="_5_6_1_apply">5.6.1 Apply</h4>
<div class="paragraph"><p><code>Apply</code> розширює <code>Functor</code> через додавання метода на ім'я <code>ap</code>, що подібний до <code>map</code> в тому, що він застосовує функцію до значень. Однак з допомогою <code>ap</code> функція в тому ж контексті, що і значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;*&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p><code>&lt;*&gt;</code> це Advanced TIE Fighter, на якому літав Дарт Вейдер. Це відповідає справам, бо виглядає як суворий предок. Або як сумний Пікачу.</p></div>
<div class="paragraph"><p>Має сенс спіймати момент, та розглянути, що це означає для простої структури даних, як <code>Option[A]</code>, маючи наступну реалізацію <code>.ap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">option</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span><span class="k">:</span> <span class="kt">Apply</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">Option</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span><span class="nc">Option</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span> <span class="k">=</span> <span class="n">f</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">ff</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fa</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">ff</span><span class="o">)</span>
      <span class="k">case</span> <span class="nc">None</span>    <span class="k">=&gt;</span> <span class="nc">None</span>
    <span class="o">}</span>
    <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб реалізувати <code>.ap</code>, спочатку ми маємо виділити функцію <code>ff: A =&gt; B</code> з <code>f: Option[A =&gt; B]</code>, потім ми можемо зробити <code>map</code> на <code>fa</code>. Виділення функції з контексту є важливою силою, що привносить <code>Apply</code>, дозволяючи декільком функціям бути скомбінованими всередині контексту.</p></div>
<div class="paragraph"><p>Повертаючись до <code>Apply</code>, ми знаходимо шаблонний <code>.applyX</code>, що дозволяє нам комбінувати паралельні функції, та потім робити <code>map</code> по їх комбінованому виходу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Functor</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="n">apply2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">apply3</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span>,<span class="kt">D</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span><span class="n">fc</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">,</span><span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span><span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="o">...</span>
    <span class="k">def</span> <span class="n">apply12</span><span class="o">[</span><span class="kt">...</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Читайте <code>.apply2</code> як контракт, що обіцяє: “якщо ви дасте мені <code>F</code> від <code>A</code>, та потім <code>F</code> від <code>B</code>, разом зі шляхом комбінувати <code>A</code> та <code>B</code> в <code>C</code>, тоді я зможу дати вам <code>F</code> для `C`”. Існує багато використань для цього контракту, та два найбільш важливі:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>конструювання деяких типокласів для типу продукта `C` зі складаючих його `A` та `B`</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>виконання ефектів паралельно, як алгебри дронів та google, що ми створили в Главі 3, та потім комбінувати їх результати.</code></pre>
</div></div>
<div class="paragraph"><p>Дійсно, <code>Apply</code> є такий корисний, що він має власний синтаксис:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ApplyOps</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span>, <span class="kt">A</span><span class="o">](</span><span class="n">self</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">*&gt;[</span><span class="kt">B</span><span class="o">](</span><span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">apply2</span><span class="o">(</span><span class="n">self</span><span class="o">,</span><span class="n">fb</span><span class="o">)((</span><span class="k">_</span><span class="o">,</span><span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">&lt;*[</span><span class="kt">B</span><span class="o">](</span><span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">apply2</span><span class="o">(</span><span class="n">self</span><span class="o">,</span><span class="n">fb</span><span class="o">)((</span><span class="n">a</span><span class="o">,</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">)</span>
    <span class="k">def</span> <span class="o">|@|[</span><span class="kt">B</span><span class="o">](</span><span class="n">fb</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">ApplicativeBuilder</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">}</span>

  <span class="k">class</span> <span class="nc">ApplicativeBuilder</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span>, <span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">a</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">b</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">tupled</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">apply2</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)(</span><span class="nc">Tuple2</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>
    <span class="k">def</span> <span class="o">|@|[</span><span class="kt">C</span><span class="o">](</span><span class="n">cc</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">ApplicativeBuilder3</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

    <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">ApplicativeBuilder3</span><span class="o">[</span><span class="kt">C</span><span class="o">](</span><span class="n">c</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="o">{</span>
      <span class="o">..</span><span class="nc">ApplicativeBuilder4</span>
        <span class="o">...</span>
          <span class="o">..</span><span class="nc">ApplicativeBuilder12</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>що є саме те, що ми використовували в Главі 3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">getBacklog</span> <span class="o">|@|</span> <span class="n">d</span><span class="o">.</span><span class="n">getAgents</span> <span class="o">|@|</span> <span class="n">m</span><span class="o">.</span><span class="n">getManaged</span> <span class="o">|@|</span> <span class="n">m</span><span class="o">.</span><span class="n">getAlive</span> <span class="o">|@|</span> <span class="n">m</span><span class="o">.</span><span class="n">getTime</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Оператор <code>|@|</code> має багато назв. Дехто називає це Синтаксисом Декартового Добутку, інші називають це Тістечко з Корицею, Адмірал Акбар або Макулай Калкін. Ми схиляємось до назви оператор Крик (The Scream), за картиною Едварда Мунка, оскільки це також звук, що видає CPU, коли він паралелізує Все Речі Разом.</p></div>
<div class="paragraph"><p>Синтаксис <code>&lt;*</code> та <code>*&gt;</code> (ліва та права пташка) надає зручний спосіб ігнорувати вивід одного з двох паралельних ефектів.</p></div>
<div class="paragraph"><p>Нажаль, хоча синтаксис <code>|@|</code> чистий, є проблема в тому, що новий об'єкт <code>ApplicativeBuilder</code> розміщується для кожного додаткового ефекта. Якщо робота прив'язана до I/O, варітсть розміщення пам'яті незначна. Але якщо робота пов'язана з навантаженням CPU використовуйте альтернативний ліфтінг з синтаксисом арності, що не продукує жодних додаткових об'єктів-посередників:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="o">^[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span>,<span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span><span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">^^[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span>,<span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span>,<span class="kt">D</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span><span class="n">fc</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">,</span><span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span><span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="o">^^^^^^[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Apply</span>, <span class="kt">...</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>використовується як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">^^^^(</span><span class="n">d</span><span class="o">.</span><span class="n">getBacklog</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">getAgents</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getManaged</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getAlive</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getTime</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або напряму викликайте <code>applyX</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">].</span><span class="n">apply5</span><span class="o">(</span><span class="n">d</span><span class="o">.</span><span class="n">getBacklog</span><span class="o">,</span> <span class="n">d</span><span class="o">.</span><span class="n">getAgents</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getManaged</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getAlive</span><span class="o">,</span> <span class="n">m</span><span class="o">.</span><span class="n">getTime</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Не дивлячись на більш загальне використання з ефектами, <code>Apply</code> також гарно робить зі структурами даних. Розгляньте переписування</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">for</span> <span class="o">{</span>
    <span class="n">foo</span> <span class="k">&lt;-</span> <span class="n">data</span><span class="o">.</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
    <span class="n">bar</span> <span class="k">&lt;-</span> <span class="n">data</span><span class="o">.</span><span class="n">bar</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">foo</span> <span class="o">+</span> <span class="n">bar</span><span class="o">.</span><span class="n">shows</span>
</pre></div></div></div>
<div class="paragraph"><p>як</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="n">foo</span> <span class="o">|@|</span> <span class="n">data</span><span class="o">.</span><span class="n">bar</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">.</span><span class="n">shows</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте комбінований вивід як тапл, саме для цього існує метод:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;tuple&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">tuple2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">tuple3</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span><span class="n">fc</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">tuple12</span><span class="o">[</span><span class="kt">...</span><span class="o">]</span>

  <span class="o">(</span><span class="n">data</span><span class="o">.</span><span class="n">foo</span> <span class="n">tuple</span> <span class="n">data</span><span class="o">.</span><span class="n">bar</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">)]</span>
</pre></div></div></div>
<div class="paragraph"><p>Також є узагальнені версії <code>ap</code> для більш ніж двох параметрів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">ap2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kt">C</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">ap3</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span>,<span class="kt">D</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span><span class="n">fc</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kt">D</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">ap12</span><span class="o">[</span><span class="kt">...</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>разом з методами <code>.lift</code>, що приймають звичайні функції, да підіймають їх в контекст <code>F[_]</code>, узагальнення <code>Functor.lift</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">lift2</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="n">lift3</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span>,<span class="kt">C</span>,<span class="kt">D</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span><span class="kt">B</span><span class="o">,</span><span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">D</span><span class="o">)</span><span class="k">:</span> <span class="o">(</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span><span class="n">F</span><span class="o">[</span><span class="kt">C</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">D</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">lift12</span><span class="o">[</span><span class="kt">...</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>та <code>.apF</code>, частково застосований синтаксис для <code>ap</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">apF</span><span class="o">[</span><span class="kt">A</span>,<span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті <code>.forever</code></p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">forever</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>повторює ефект без зупинки. Примірник <code>Apply</code> має бути стеко-безпечним, або ми отримаємо <code>StackOverflowError</code>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_5_6_2_bind">5.6.2 Bind</h3>
<div class="paragraph"><p><code>Bind</code> вводить <code>.bind</code>, синонімічний з <code>.flatMap</code>, що дозволяє функції на результатах ефектів, що повертають новий ефект, або функції на значеннях структури даних, що повертатимуть нові структури, що потім поєднуються.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Bind</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="nc">extends</span> <span class="nc">Apply</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span> <span class="o">{</span>

    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;&gt;=&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">bind</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="n">bind</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">f</span><span class="o">)</span>

    <span class="k">override</span> <span class="k">def</span> <span class="n">ap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span> <span class="k">=&gt;</span> <span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">bind</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">x</span><span class="o">))</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">apply2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span>, <span class="kt">C</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">fb</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">,</span> <span class="kt">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">C</span><span class="o">]</span> <span class="k">=</span>
      <span class="n">bind</span><span class="o">(</span><span class="n">fa</span><span class="o">)(</span><span class="n">a</span> <span class="k">=&gt;</span> <span class="n">map</span><span class="o">(</span><span class="n">fb</span><span class="o">)(</span><span class="n">b</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)))</span>

    <span class="k">def</span> <span class="n">join</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">ffa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">bind</span><span class="o">(</span><span class="n">ffa</span><span class="o">)(</span><span class="n">identity</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">mproduct</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">fa</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">])(</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">)]</span> <span class="k">=</span> <span class="o">...</span>
    <span class="k">def</span> <span class="n">ifM</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">value</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Boolean</span><span class="o">],</span> <span class="n">t</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="o">=&gt;</span><span class="n">F</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>

  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>.join</code> може бути знайомий до користувачів <code>.flatten</code> в <code>stdlib</code>, він приймає вкладений контекст, та зплющує його в один.</p></div>
<div class="paragraph"><p>Наслідувані комбінатори введені для <code>.ap</code> та <code>.apply2</code>, що потребує узгодженості з <code>.bind</code>. Ми побачимо пізніше, що це правило має наслідки для стратегій паралелізації.</p></div>
<div class="paragraph"><p>mproduct is like Functor.fproduct and pairs the function’s input with its output, inside the F.</p></div>
<div class="paragraph"><p>ifM is a way to construct a conditional data structure or effect:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; List(true, false, true).ifM(List(0), List(1, 1))
res: List[Int] = List(0, 1, 1, 0)</code></pre>
</div></div>
<div class="paragraph"><p>ifM and ap are optimised to cache and reuse code branches, compare to the longer form</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; List(true, false, true).flatMap { b =&gt; if (b) List(0) else List(1, 1) }</code></pre>
</div></div>
<div class="paragraph"><p>which produces a fresh List(0) or List(1, 1) every time the branch is invoked.</p></div>
<div class="paragraph"><p>These kinds of optimisations are possible in FP because all methods are deterministic, also known as referentially transparent.</p></div>
<div class="paragraph"><p>If a method returns a different value every time it is called, it is impure and breaks the reasoning and optimisations that we can otherwise make.</p></div>
<div class="paragraph"><p>If the F is an effect, perhaps one of our drone or Google algebras, it does not mean that the output of the call to the algebra is cached. Rather the reference to the operation is cached. The performance optimisation of ifM is only noticeable for data structures, and more pronounced with the difficulty of the work in each branch.</p></div>
<div class="paragraph"><p>We will explore the concept of determinism and value caching in more detail in the next chapter.</p></div>
<div class="paragraph"><p>Bind also has some special syntax</p></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit class BindOps[F[_]: Bind, A] (self: F[A]) {
  def &gt;&gt;[B](b: =&gt;F[B]): F[B] = Bind[F].bind(self)(_ =&gt; b)
  def &gt;&gt;![B](f: A =&gt; F[B]): F[A] = Bind[F].bind(self)(a =&gt; f(a).map(_ =&gt; a))
}</code></pre>
</div></div>
<div class="paragraph"><p>&gt;&gt; is when we wish to discard the input to bind and &gt;&gt;! is when we want to run an effect but discard its output.
5.7 Applicative and Monad</p></div>
<div class="paragraph"><p>From a functionality point of view, Applicative is Apply with a pure method, and Monad extends Applicative with Bind.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Applicative[F[_]] extends Apply[F] {
  def point[A](a: =&gt;A): F[A]
  def pure[A](a: =&gt;A): F[A] = point(a)
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Monad[F[_]] extends Applicative[F] with Bind[F]</code></pre>
</div></div>
<div class="paragraph"><p>In many ways, Applicative and Monad are the culmination of everything we’ve seen in this chapter. .pure (or .point as it is more commonly known for data structures) allows us to create effects or data structures from values.</p></div>
<div class="paragraph"><p>Instances of Applicative must meet some laws, effectively asserting that all the methods are consistent:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Identity: fa &lt;*&gt; pure(identity) === fa, (where fa is an F[A]) i.e. applying pure(identity) does nothing.
Homomorphism: pure(a) &lt;*&gt; pure(ab) === pure(ab(a)) (where ab is an A =&gt; B), i.e. applying a pure function to a pure value is the same as applying the function to the value and then using pure on the result.
Interchange: pure(a) &lt;*&gt; fab === fab &lt;*&gt; pure(f =&gt; f(a)), (where fab is an F[A =&gt; B]), i.e. pure is a left and right identity
Mappy: map(fa)(f) === fa &lt;*&gt; pure(f)</code></pre>
</div></div>
<div class="paragraph"><p>Monad adds additional laws:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>Left Identity: pure(a).bind(f) === f(a)
Right Identity: a.bind(pure(_)) === a
Associativity: fa.bind(f).bind(g) === fa.bind(a =&gt; f(a).bind(g)) where fa is an F[A], f is an A =&gt; F[B] and g is a B =&gt; F[C].</code></pre>
</div></div>
<div class="paragraph"><p>Associativity says that chained bind calls must agree with nested bind. However, it does not mean that we can rearrange the order, which would be commutativity. For example, recalling that flatMap is an alias to bind, we cannot rearrange</p></div>
<div class="literalblock">
<div class="content">
<pre><code>for {
  _ &lt;- machine.start(node1)
  _ &lt;- machine.stop(node1)
} yield true</code></pre>
</div></div>
<div class="paragraph"><p>as</p></div>
<div class="literalblock">
<div class="content">
<pre><code>for {
  _ &lt;- machine.stop(node1)
  _ &lt;- machine.start(node1)
} yield true</code></pre>
</div></div>
<div class="paragraph"><p>start and stop are non-commutative, because the intended effect of starting then stopping a node is different to stopping then starting it!</p></div>
<div class="paragraph"><p>But start is commutative with itself, and stop is commutative with itself, so we can rewrite</p></div>
<div class="literalblock">
<div class="content">
<pre><code>for {
  _ &lt;- machine.start(node1)
  _ &lt;- machine.start(node2)
} yield true</code></pre>
</div></div>
<div class="paragraph"><p>as</p></div>
<div class="literalblock">
<div class="content">
<pre><code>for {
  _ &lt;- machine.start(node2)
  _ &lt;- machine.start(node1)
} yield true</code></pre>
</div></div>
<div class="paragraph"><p>which are equivalent for our algebra, but not in general. We’re making a lot of assumptions about the Google Container API here, but this is a reasonable choice to make.</p></div>
<div class="paragraph"><p>A practical consequence is that a Monad must be commutative if its applyX methods can be allowed to run in parallel. We cheated in Chapter 3 when we ran these effects in parallel</p></div>
<div class="literalblock">
<div class="content">
<pre><code>(d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)</code></pre>
</div></div>
<div class="paragraph"><p>because we know that they are commutative among themselves. When it comes to interpreting our application, later in the book, we will have to provide evidence that these effects are in fact commutative, or an asynchronous implementation may choose to sequence the operations to be on the safe side.</p></div>
<div class="paragraph"><p>The subtleties of how we deal with (re)-ordering of effects, and what those effects are, deserves a dedicated chapter on Advanced Monads.
5.8 Divide and Conquer</p></div>
<div class="paragraph"><p>Divide is the Contravariant analogue of Apply</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Divide[F[_]] extends Contravariant[F] {
  def divide[A, B, C](fa: F[A], fb: F[B])(f: C =&gt; (A, B)): F[C] = divide2(fa, fb)(f)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def divide1[A1, Z](a1: F[A1])(f: Z =&gt; A1): F[Z] = ...
def divide2[A, B, C](fa: F[A], fb: F[B])(f: C =&gt; (A, B)): F[C] = ...
...
def divide22[...] = ...</code></pre>
</div></div>
<div class="paragraph"><p>divide says that if we can break a C into an A and a B, and we’re given an F[A] and an F[B], then we can get an F[C]. Hence, divide and conquer.</p></div>
<div class="paragraph"><p>This is a great way to generate contravariant typeclass instances for product types by breaking the products into their parts. Scalaz has an instance of Divide[Equal], let’s construct an Equal for a new product type Foo</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; case class Foo(s: String, i: Int)
scala&gt; implicit val fooEqual: Equal[Foo] =
         Divide[Equal].divide2(Equal[String], Equal[Int]) {
           (foo: Foo) =&gt; (foo.s, foo.i)
         }
scala&gt; Foo("foo", 1) === Foo("bar", 1)
res: Boolean = false</code></pre>
</div></div>
<div class="paragraph"><p>Mirroring Apply, Divide also has terse syntax for tuples. A softer divide so that we may reign approach to world domination:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>...
  def tuple2[A1, A2](a1: F[A1], a2: F[A2]): F[(A1, A2)] = ...
  ...
  def tuple22[...] = ...
}</code></pre>
</div></div>
<div class="paragraph"><p>Generally, if encoder typeclasses can provide an instance of Divide, rather than stopping at Contravariant, it makes it possible to derive instances for any case class. Similarly, decoder typeclasses can provide an Apply instance. We will explore this in a dedicated chapter on Typeclass Derivation.</p></div>
<div class="paragraph"><p>Divisible is the Contravariant analogue of Applicative and introduces .conquer, the equivalent of .pure</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Divisible[F[_]] extends Divide[F] {
  def conquer[A]: F[A]
}</code></pre>
</div></div>
<div class="paragraph"><div class="title">conquer allows creating trivial implementations where the type parameter is ignored. Such values are called universally quantified. For example, the Divisible[Equal].conquer[INil[String]] returns an implementation of Equal for an empty list of String which is always true.</div><p>5.9 Plus</p></div>
<div class="paragraph"><p>Plus is Semigroup but for type constructors, and PlusEmpty is the equivalent of Monoid (they even have the same laws) whereas IsEmpty is novel and allows us to query if an F[A] is empty:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Plus[F[_]] {
  @op("&lt;+&gt;") def plus[A](a: F[A], b: =&gt;F[A]): F[A]
}
@typeclass trait PlusEmpty[F[_]] extends Plus[F] {
  def empty[A]: F[A]
}
@typeclass trait IsEmpty[F[_]] extends PlusEmpty[F] {
  def isEmpty[A](fa: F[A]): Boolean
}</code></pre>
</div></div>
<div class="paragraph"><p>&lt;+&gt; is the TIE Interceptor, and now we’re almost out of TIE Fighters…</p></div>
<div class="paragraph"><p>Although it may look on the surface as if &lt;+&gt; behaves like |+|</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; List(2,3) |+| List(7)
res = List(2, 3, 7)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; List(2,3) &lt;+&gt; List(7)
res = List(2, 3, 7)</code></pre>
</div></div>
<div class="paragraph"><p>it is best to think of it as operating only at the F[_] level, never looking into the contents. Plus has the convention that it should ignore failures and “pick the first winner”. &lt;+&gt; can therefore be used as a mechanism for early exit (losing information) and failure-handling via fallbacks:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; Option(1) |+| Option(2)
res = Some(3)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; Option(1) &lt;+&gt; Option(2)
res = Some(1)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; Option.empty[Int] &lt;+&gt; Option(1)
res = Some(1)</code></pre>
</div></div>
<div class="paragraph"><p>For example, if we have a NonEmptyList[Option[Int]] and we want to ignore None values (failures) and pick the first winner (Some), we can call &lt;+&gt; from Foldable1.foldRight1:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; NonEmptyList(None, None, Some(1), Some(2), None)
       .foldRight1(_ &lt;+&gt; _)
res: Option[Int] = Some(1)</code></pre>
</div></div>
<div class="paragraph"><p>In fact, now that we know about Plus, we realise that we didn’t need to break typeclass coherence (when we defined a locally scoped Monoid[Option[A]]) in the section on Appendable Things. Our objective was to “pick the last winner”, which is the same as “pick the winner” if the arguments are swapped. Note the use of the TIE Interceptor for ccy and otc with arguments swapped.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
  (a, b) =&gt; TradeTemplate(a.payments |+| b.payments,
                          b.ccy &lt;+&gt; a.ccy,
                          b.otc &lt;+&gt; a.otc),
  TradeTemplate(Nil, None, None)
)</code></pre>
</div></div>
<div class="paragraph"><p>Applicative and Monad have specialised versions of PlusEmpty</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait ApplicativePlus[F[_]] extends Applicative[F] with PlusEmpty[F]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait MonadPlus[F[_]] extends Monad[F] with ApplicativePlus[F] {
  def unite[T[_]: Foldable, A](ts: F[T[A]]): F[A] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def withFilter[A](fa: F[A])(f: A =&gt; Boolean): F[A] = ...
}</code></pre>
</div></div>
<div class="literalblock">
<div class="title">unite lets us fold a data structure using the outer container’s PlusEmpty[F].monoid rather than the inner content’s Monoid. For List[Either[String, Int]] this means Left[String] values are converted into .empty, then everything is concatenated. A convenient way to discard errors:</div>
<div class="content">
<pre><code>scala&gt; List(Right(1), Left("boo"), Right(2)).unite
res: List[Int] = List(1, 2)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val boo: Either[String, Int] = Left("boo")
       boo.foldMap(a =&gt; a.pure[List])
res: List[String] = List()</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val n: Either[String, Int] = Right(1)
       n.foldMap(a =&gt; a.pure[List])
res: List[Int] = List(1)</code></pre>
</div></div>
<div class="paragraph"><p>withFilter allows us to make use of for comprehension language support as discussed in Chapter 2. It is fair to say that the Scala language has built-in language support for MonadPlus, not just Monad!</p></div>
<div class="paragraph"><p>Returning to Foldable for a moment, we can reveal some methods that we did not discuss earlier</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Foldable[F[_]] {
  ...
  def msuml[G[_]: PlusEmpty, A](fa: F[G[A]]): G[A] = ...
  def collapse[X[_]: ApplicativePlus, A](x: F[A]): X[A] = ...
  ...
}</code></pre>
</div></div>
<div class="paragraph"><p>msuml does a fold using the Monoid from the PlusEmpty[G] and collapse does a foldRight using the PlusEmpty of the target type:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; IList(Option(1), Option.empty[Int], Option(2)).fold
res: Option[Int] = Some(3) // uses Monoid[Option[Int]]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; IList(Option(1), Option.empty[Int], Option(2)).msuml
res: Option[Int] = Some(1) // uses PlusEmpty[Option].monoid</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; IList(1, 2).collapse[Option]
res: Option[Int] = Some(1)</code></pre>
</div></div>
<div class="paragraph"><p>5.10 Lone Wolves</p></div>
<div class="paragraph"><p>Some of the typeclasses in Scalaz are stand-alone and not part of the larger hierarchy.
5.10.1 Zippy</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Zip[F[_]]  {
  def zip[A, B](a: =&gt;F[A], b: =&gt;F[B]): F[(A, B)]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def zipWith[A, B, C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C)
                    (implicit F: Functor[F]): F[C] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def ap(implicit F: Functor[F]): Apply[F] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@op("&lt;*|*&gt;") def apzip[A, B](f: =&gt;F[A] =&gt; F[B], a: =&gt;F[A]): F[(A, B)] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>}</code></pre>
</div></div>
<div class="paragraph"><p>The core method is zip which is a less powerful version of Divide.tuple2, and if a Functor[F] is provided then zipWith can behave like Apply.apply2. Indeed, an Apply[F] can be created from a Zip[F] and a Functor[F] by calling ap.</p></div>
<div class="paragraph"><p>apzip takes an F[A] and a lifted function from F[A] &#8658; F[B], producing an F[(A, B)] similar to Functor.fproduct.</p></div>
<div class="paragraph"><p>&lt;*|*&gt; is the creepy Jawa operator.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Unzip[F[_]]  {
  @op("unfzip") def unzip[A, B](a: F[(A, B)]): (F[A], F[B])</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def firsts[A, B](a: F[(A, B)]): F[A] = ...
def seconds[A, B](a: F[(A, B)]): F[B] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def unzip3[A, B, C](x: F[(A, (B, C))]): (F[A], F[B], F[C]) = ...
  ...
  def unzip7[A ... H](x: F[(A, (B, ... H))]): ...
}</code></pre>
</div></div>
<div class="paragraph"><p>The core method is unzip with firsts and seconds allowing for selecting either the first or second element of a tuple in the F. Importantly, unzip is the opposite of zip.</p></div>
<div class="paragraph"><p>The methods unzip3 to unzip7 are repeated applications of unzip to save on boilerplate. For example, if handed a bunch of nested tuples, the Unzip[Id] is a handy way to flatten them:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; Unzip[Id].unzip7((1, (2, (3, (4, (5, (6, 7)))))))
res = (1,2,3,4,5,6,7)</code></pre>
</div></div>
<div class="paragraph"><p>In a nutshell, Zip and Unzip are less powerful versions of Divide and Apply, providing useful features without requiring the F to make too many promises.
5.10.2 Optional</p></div>
<div class="paragraph"><p>Optional is a generalisation of data structures that can optionally contain a value, like Option and Either.</p></div>
<div class="paragraph"><p>Recall that \/ (disjunction) is Scalaz’s improvement of scala.Either. We will also see Maybe, Scalaz’s improvement of scala.Option</p></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed abstract class Maybe[A]
final case class Empty[A]()    extends Maybe[A]
final case class Just[A](a: A) extends Maybe[A]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Optional[F[_]] {
  def pextract[B, A](fa: F[A]): F[B] \/ A</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def getOrElse[A](fa: F[A])(default: =&gt;A): A = ...
def orElse[A](fa: F[A])(alt: =&gt;F[A]): F[A] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def isDefined[A](fa: F[A]): Boolean = ...
def nonEmpty[A](fa: F[A]): Boolean = ...
def isEmpty[A](fa: F[A]): Boolean = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def toOption[A](fa: F[A]): Option[A] = ...
  def toMaybe[A](fa: F[A]): Maybe[A] = ...
}</code></pre>
</div></div>
<div class="paragraph"><p>These are methods that should be familiar, except perhaps pextract, which is a way of letting the F[_] return some implementation specific F[B] or the value. For example, Optional[Option].pextract returns Option[Nothing] \/ A, i.e. None \/ A.</p></div>
<div class="paragraph"><p>Scalaz gives a ternary operator to things that have an Optional</p></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit class OptionalOps[F[_]: Optional, A](fa: F[A]) {
  def ?[X](some: =&gt;X): Conditional[X] = new Conditional[X](some)
  final class Conditional[X](some: =&gt;X) {
    def |(none: =&gt;X): X = if (Optional[F].isDefined(fa)) some else none
  }
}</code></pre>
</div></div>
<div class="paragraph"><p>for example</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val knock_knock: Option[String] = ...
       knock_knock ? "who's there?" | "&lt;tumbleweed&gt;"</code></pre>
</div></div>
<div class="paragraph"><p>5.11 Co-things</p></div>
<div class="paragraph"><p>A co-thing typically has some opposite type signature to whatever thing does, but is not necessarily its inverse. To highlight the relationship between thing and co-thing, we will include the type signature of thing wherever we can.
5.11.1 Cobind</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Cobind[F[_]] extends Functor[F] {
  def cobind[A, B](fa: F[A])(f: F[A] =&gt; B): F[B]
//def   bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def cojoin[A](fa: F[A]): F[F[A]] = ...
//def   join[A](ffa: F[F[A]]): F[A] = ...
}</code></pre>
</div></div>
<div class="paragraph"><p>cobind (also known as coflatmap) takes an F[A] &#8658; B that acts on an F[A] rather than its elements. But this is not necessarily the full fa, it is usually some substructure as defined by cojoin (also known as coflatten) which expands a data structure.</p></div>
<div class="paragraph"><p>Compelling use-cases for Cobind are rare, although when shown in the Functor permutation table (for F[_], A and B) it is difficult to argue why any method should be less important than the others:
method  parameter
map     A &#8658; B
contramap       B &#8658; A
xmap    (A &#8658; B, B &#8658; A)
ap      F[A &#8658; B]
bind    A &#8658; F[B]
cobind  F[A] &#8658; B
5.11.2 Comonad</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Comonad[F[_]] extends Cobind[F] {
  def copoint[A](p: F[A]): A
//def   point[A](a: =&gt;A): F[A]
}</code></pre>
</div></div>
<div class="paragraph"><div class="title">copoint (also .copure) unwraps an element from its context. Effects do not typically have an instance of Comonad since would break referential transparency to interpret an IO[A] into an A. But for collection-like data structures, it is a way to construct a view of all elements alongside their neighbours.</div><p>Consider a neighbourhood (Hood for short) for a list containing all the elements to the left of an element (lefts), the element itself (the focus), and all the elements to its right (rights).</p></div>
<div class="literalblock">
<div class="content">
<pre><code>final case class Hood[A](lefts: IList[A], focus: A, rights: IList[A])</code></pre>
</div></div>
<div class="paragraph"><p>The lefts and rights should each be ordered with the nearest to the focus at the head, such that we can recover the original IList via .toIList</p></div>
<div class="literalblock">
<div class="content">
<pre><code>object Hood {
  implicit class Ops[A](hood: Hood[A]) {
    def toIList: IList[A] = hood.lefts.reverse ::: hood.focus :: hood.rights</code></pre>
</div></div>
<div class="paragraph"><p>We can write methods that let us move the focus one to the left (previous) and one to the right (next)</p></div>
<div class="literalblock">
<div class="content">
<pre><code>...
    def previous: Maybe[Hood[A]] = hood.lefts match {
      case INil() =&gt; Empty()
      case ICons(head, tail) =&gt;
        Just(Hood(tail, head, hood.focus :: hood.rights))
    }
    def next: Maybe[Hood[A]] = hood.rights match {
      case INil() =&gt; Empty()
      case ICons(head, tail) =&gt;
        Just(Hood(hood.focus :: hood.lefts, head, tail))
    }</code></pre>
</div></div>
<div class="paragraph"><p>By introducing more to repeatedly apply an optional function to Hood we can calculate all the positions that Hood can take in the list</p></div>
<div class="literalblock">
<div class="content">
<pre><code>...
    def more(f: Hood[A] =&gt; Maybe[Hood[A]]): IList[Hood[A]] =
      f(hood) match {
        case Empty() =&gt; INil()
        case Just(r) =&gt; ICons(r, r.more(f))
      }
    def positions: Hood[Hood[A]] = {
      val left  = hood.more(_.previous)
      val right = hood.more(_.next)
      Hood(left, hood, right)
    }
  }</code></pre>
</div></div>
<div class="paragraph"><p>We can now implement Comonad[Hood]</p></div>
<div class="literalblock">
<div class="content">
<pre><code>...
  implicit val comonad: Comonad[Hood] = new Comonad[Hood] {
    def map[A, B](fa: Hood[A])(f: A =&gt; B): Hood[B] =
      Hood(fa.lefts.map(f), f(fa.focus), fa.rights.map(f))
    def cobind[A, B](fa: Hood[A])(f: Hood[A] =&gt; B): Hood[B] =
      fa.positions.map(f)
    def copoint[A](fa: Hood[A]): A = fa.focus
  }
}</code></pre>
</div></div>
<div class="paragraph"><p>cojoin gives us a Hood[Hood[IList]] containing all the possible neighbourhoods in our initial IList</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val middle = Hood(IList(4, 3, 2, 1), 5, IList(6, 7, 8, 9))
scala&gt; middle.cojoin
res = Hood(
        [Hood([3,2,1],4,[5,6,7,8,9]),
         Hood([2,1],3,[4,5,6,7,8,9]),
         Hood([1],2,[3,4,5,6,7,8,9]),
         Hood([],1,[2,3,4,5,6,7,8,9])],
        Hood([4,3,2,1],5,[6,7,8,9]),
        [Hood([5,4,3,2,1],6,[7,8,9]),
         Hood([6,5,4,3,2,1],7,[8,9]),
         Hood([7,6,5,4,3,2,1],8,[9]),
         Hood([8,7,6,5,4,3,2,1],9,[])])</code></pre>
</div></div>
<div class="paragraph"><p>Indeed, cojoin is just positions! We can override it with a more direct (and performant) implementation</p></div>
<div class="literalblock">
<div class="content">
<pre><code>override def cojoin[A](fa: Hood[A]): Hood[Hood[A]] = fa.positions</code></pre>
</div></div>
<div class="paragraph"><p>Comonad generalises the concept of Hood to arbitrary data structures. Hood is an example of a zipper (unrelated to Zip). Scalaz comes with a Zipper data type for streams (i.e. infinite 1D data structures), which we will discuss in the next chapter.</p></div>
<div class="paragraph"><p>One application of a zipper is for cellular automata, which compute the value of each cell in the next generation by performing a computation based on the neighbourhood of that cell.
5.11.3 Cozip</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Cozip[F[_]] {
  def cozip[A, B](x: F[A \/ B]): F[A] \/ F[B]
//def   zip[A, B](a: =&gt;F[A], b: =&gt;F[B]): F[(A, B)]
//def unzip[A, B](a: F[(A, B)]): (F[A], F[B])</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def cozip3[A, B, C](x: F[A \/ (B \/ C)]): F[A] \/ (F[B] \/ F[C]) = ...
  ...
  def cozip7[A ... H](x: F[(A \/ (... H))]): F[A] \/ (... F[H]) = ...
}</code></pre>
</div></div>
<div class="paragraph"><p>Although named cozip, it is perhaps more appropriate to talk about its symmetry with unzip. Whereas unzip splits F[<em>] of tuples (products) into tuples of F[</em>], cozip splits F[<em>] of disjunctions (coproducts) into disjunctions of F[</em>].
5.12 Bi-things</p></div>
<div class="paragraph"><p>Sometimes we may find ourselves with a thing that has two type holes and we want to map over both sides. For example we might be tracking failures in the left of an Either and we want to do something with the failure messages.</p></div>
<div class="paragraph"><p>The Functor / Foldable / Traverse typeclasses have bizarro relatives that allow us to map both ways.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Bifunctor[F[_, _]] {
  def bimap[A, B, C, D](fab: F[A, B])(f: A =&gt; C, g: B =&gt; D): F[C, D]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  @op("&lt;-:") def leftMap[A, B, C](fab: F[A, B])(f: A =&gt; C): F[C, B] = ...
  @op(":-&gt;") def rightMap[A, B, D](fab: F[A, B])(g: B =&gt; D): F[A, D] = ...
  @op("&lt;:&gt;") def umap[A, B](faa: F[A, A])(f: A =&gt; B): F[B, B] = ...
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Bifoldable[F[_, _]] {
  def bifoldMap[A, B, M: Monoid](fa: F[A, B])(f: A =&gt; M)(g: B =&gt; M): M</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def bifoldRight[A,B,C](fa: F[A, B], z: =&gt;C)(f: (A, =&gt;C) =&gt; C)(g: (B, =&gt;C) =&gt; C): C
def bifoldLeft[A,B,C](fa: F[A, B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C): C = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def bifoldMap1[A, B, M: Semigroup](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M): Option[M] = ...
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Bitraverse[F[_, _]] extends Bifunctor[F] with Bifoldable[F] {
  def bitraverse[G[_]: Applicative, A, B, C, D](fab: F[A, B])
                                               (f: A =&gt; G[C])
                                               (g: B =&gt; G[D]): G[F[C, D]]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def bisequence[G[_]: Applicative, A, B](x: F[G[A], G[B]]): G[F[A, B]] = ...
}</code></pre>
</div></div>
<div class="paragraph"><p>&#8592;: and :&#8594; are the happy operators!</p></div>
<div class="paragraph"><p>Although the type signatures are verbose, these are nothing more than the core methods of Functor, Foldable and Bitraverse taking two functions instead of one, often requiring both functions to return the same type so that their results can be combined with a Monoid or Semigroup.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val a: Either[String, Int] = Left("fail")
       val b: Either[String, Int] = Right(13)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; b.bimap(_.toUpperCase, _ * 2)
res: Either[String, Int] = Right(26)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; a.bimap(_.toUpperCase, _ * 2)
res: Either[String, Int] = Left(FAIL)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; b :-&gt; (_ * 2)
res: Either[String,Int] = Right(26)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; a :-&gt; (_ * 2)
res: Either[String, Int] = Left(fail)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; { s: String =&gt; s.length } &lt;-: a
res: Either[Int, Int] = Left(4)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; a.bifoldMap(_.length)(identity)
res: Int = 4</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; b.bitraverse(s =&gt; Future(s.length), i =&gt; Future(i))
res: Future[Either[Int, Int]] = Future(&lt;not completed&gt;)</code></pre>
</div></div>
<div class="paragraph"><p>In addition, we can revisit MonadPlus (recall it is Monad with the ability to filterWith and unite) and see that it can separate Bifoldable contents of a Monad</p></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait MonadPlus[F[_]] {
  ...
  def separate[G[_, _]: Bifoldable, A, B](value: F[G[A, B]]): (F[A], F[B]) = ...
  ...
}</code></pre>
</div></div>
<div class="paragraph"><p>This is very useful if we have a collection of bi-things and we want to reorganise them into a collection of A and a collection of B</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val list: List[Either[Int, String]] =
         List(Right("hello"), Left(1), Left(2), Right("world"))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; list.separate
res: (List[Int], List[String]) = (List(1, 2), List(hello, world))</code></pre>
</div></div>
<div class="paragraph"><p>5.13 Summary</p></div>
<div class="paragraph"><p>That was a lot of material! We have just explored a standard library of polymorphic functionality. But to put it into perspective: there are more traits in the Scala stdlib Collections API than typeclasses in Scalaz.</p></div>
<div class="paragraph"><p>It is normal for an FP application to only touch a small percentage of the typeclass hierarchy, with most functionality coming from domain-specific algebras and typeclasses. Even if the domain-specific typeclasses are just specialised clones of something in Scalaz, it is OK to refactor it later.</p></div>
<div class="paragraph"><p>To help, we have included a cheat-sheet of the typeclasses and their primary methods in the Appendix, inspired by Adam Rosien’s Scalaz Cheatsheet.</p></div>
<div class="paragraph"><p>To help further, Valentin Kasas explains how to combine N things:</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-25 02:11:32 EEST
</div>
</div>
</body>
</html>
