<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>2. Розширення for</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>2. Розширення for</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>Розширення <code>for</code> в Scala є ідеальною абстракцією для послідовних програм, що взаємодіють зі світом. Оскільки ми будемо багато використовувати його, ми ще раз вивчимо принципи <code>for</code>, та як <code>Scalaz</code> може допомогти нам писати чистіший код.</p></div>
<div class="paragraph"><p>Ця глава не намагається писати чисті програми, ці прийоми також стосуються не-FP коду.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_2_1__">2.1 Синтаксичний цукор</h2>
<div class="sectionbody">
<div class="paragraph"><p>В Scala <code>for</code> є простим правилом переписування, що також називається синтаксичним цукром, що не має жодної контекстуальної інформації.</p></div>
<div class="paragraph"><p>Щоб побачити, що робить <code>for</code> розширення ми використаємо можливість <em>show and reify</em> в <code>REPL</code> для друку того, як виглядає код після виведення типів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.reflect.runtime.universe._</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span> <span class="k">=</span> <span class="nc">Option</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span> <span class="o">{</span> <span class="n">reify</span> <span class="o">{</span>
           <span class="k">for</span> <span class="o">{</span> <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">a</span> <span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="n">b</span> <span class="o">;</span> <span class="n">k</span> <span class="k">&lt;-</span> <span class="n">c</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span>
         <span class="o">}</span> <span class="o">}</span>

  <span class="n">res</span><span class="k">:</span>
  <span class="kt">$read.a.flatMap</span><span class="o">(</span>
    <span class="o">((</span><span class="kt">i</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kt">$read.b.flatMap</span><span class="o">(</span>
      <span class="o">((</span><span class="kt">j</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kt">$read.c.map</span><span class="o">(</span>
        <span class="o">((</span><span class="kt">k</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="kt">i.$plus</span><span class="o">(</span><span class="kt">j</span><span class="o">)</span><span class="kt">.$plus</span><span class="o">(</span><span class="kt">k</span><span class="o">)))))))</span>
</pre></div></div></div>
<div class="paragraph"><p>Є багато шуму через додатковий цукор (як <code>+</code> переписане як <code>$plus</code>, тощо). ми будемо пропускати <code>show</code> та <code>reify</code> для краткості, коли рядок <code>REPL</code> виглядає як <code>reify&gt;</code>, та вручну підчищатимемо згенерований код, так щоб він не ставав відволікаючим.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">reify</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">{</span> <span class="n">i</span> <span class="k">&lt;-</span> <span class="n">a</span> <span class="o">;</span> <span class="n">j</span> <span class="k">&lt;-</span> <span class="n">b</span> <span class="o">;</span> <span class="n">k</span> <span class="k">&lt;-</span> <span class="n">c</span> <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="o">)</span>

  <span class="n">a</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
    <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">.</span><span class="n">flatMap</span> <span class="o">{</span>
      <span class="n">j</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
        <span class="n">k</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">}}}</span>
</pre></div></div></div>
<div class="paragraph"><p>The rule of thumb is that every &#8592; (called a generator) is a nested flatMap call, with the final generator a map containing the yield body.</p></div>
<div class="paragraph"><p>2.1.1 Assignment
We can assign values inline like ij = i + j (a val keyword is not needed).</p></div>
<div class="literalblock">
<div class="content">
<pre><code>reify&gt; for {
         i &lt;- a
         j &lt;- b
         ij = i + j
         k &lt;- c
       } yield (ij + k)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  a.flatMap {
    i =&gt; b.map { j =&gt; (j, i + j) }.flatMap {
      case (j, ij) =&gt; c.map {
        k =&gt; ij + k }}}
A map over the b introduces the ij which is flat-mapped along with the j, then the final map for the code in the yield.</code></pre>
</div></div>
<div class="paragraph"><p>Unfortunately we cannot assign before any generators. It has been requested as a language feature but has not been implemented: <a href="https://github.com/scala/bug/issues/907">https://github.com/scala/bug/issues/907</a></p></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; for {
           initial = getDefault
           i &lt;- a
         } yield initial + i
  &lt;console&gt;:1: error: '&lt;-' expected but '=' found.
We can workaround the limitation by defining a val outside the for</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val initial = getDefault
  scala&gt; for { i &lt;- a } yield initial + i
or create an Option out of the initial assignment</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; for {
           initial &lt;- Option(getDefault)
           i &lt;- a
         } yield initial + i
val doesn’t have to assign to a single value, it can be anything that works as a case in a pattern match.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val (first, second) = ("hello", "world")
first: String = hello
second: String = world</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val list: List[Int] = ...
  scala&gt; val head :: tail = list
  head: Int = 1
  tail: List[Int] = List(2, 3)
The same is true for assignment in for comprehensions</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val maybe = Option(("hello", "world"))
  scala&gt; for {
           entry &lt;- maybe
           (first, _) = entry
         } yield first
  res: Some(hello)
But be careful not to miss any cases or there will be a runtime exception (a totality failure).</code></pre>
</div></div>
<div class="dlist"><dl>
<dt class="hdlist1">
scala&gt; val a 
</dt>
<dd>
<p>
tail = list
  caught scala.MatchError: List()
2.1.2 Filter
It is possible to put if statements after a generator to filter values by a predicate
</p>
<div class="literalblock">
<div class="content">
<pre><code>reify&gt; for {
         i  &lt;- a
         j  &lt;- b
         if i &gt; j
         k  &lt;- c
       } yield (i + j + k)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  a.flatMap {
    i =&gt; b.withFilter {
      j =&gt; i &gt; j }.flatMap {
        j =&gt; c.map {
          k =&gt; i + j + k }}}
Older versions of Scala used filter, but Traversable.filter creates new collections for every predicate, so withFilter was introduced as the more performant alternative. We can accidentally trigger a withFilter by providing type information, interpreted as a pattern match.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>reify&gt; for { i: Int &lt;- a } yield i</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  a.withFilter {
    case i: Int =&gt; true
    case _      =&gt; false
  }.map { case i: Int =&gt; i }
Like assignment, a generator can use a pattern match on the left hand side. But unlike assignment (which throws MatchError on failure), generators are filtered and will not fail at runtime. However, there is an inefficient double application of the pattern.</code></pre>
</div></div>
</dd>
</dl></div>
<div class="paragraph"><p>The compiler plugin better-monadic-for produces alternative, better, desugarings than the Scala compiler. This example is interpreted as:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>reify&gt; for { i: Int &lt;- a } yield i</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  a.map { (i: Int) =&gt; i}
instead of inefficient double matching (in the best case) and silent filtering at runtime (in the worst case). Highly recommended.</code></pre>
</div></div>
<div class="paragraph"><p>2.1.3 For Each
Finally, if there is no yield, the compiler will use foreach instead of flatMap, which is only useful for side-effects.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>reify&gt; for { i &lt;- a ; j &lt;- b } println(s"$i $j")</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  a.foreach { i =&gt; b.foreach { j =&gt; println(s"$i $j") } }
2.1.4 Summary
The full set of methods supported by for comprehensions do not share a common super type; each generated snippet is independently compiled. If there were a trait, it would roughly look like:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  trait ForComprehensible[C[_]] {
    def map[A, B](f: A =&gt; B): C[B]
    def flatMap[A, B](f: A =&gt; C[B]): C[B]
    def withFilter[A](p: A =&gt; Boolean): C[A]
    def foreach[A](f: A =&gt; Unit): Unit
  }
If the context (C[_]) of a for comprehension doesn’t provide its own map and flatMap, all is not lost. If an implicit scalaz.Bind[T] is available for T, it will provide map and flatMap.</code></pre>
</div></div>
<div class="paragraph"><p>It often surprises developers when inline Future calculations in a for comprehension do not run in parallel:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>import scala.concurrent._
import ExecutionContext.Implicits.global</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    i &lt;- Future { expensiveCalc() }
    j &lt;- Future { anotherExpensiveCalc() }
  } yield (i + j)
This is because the flatMap spawning anotherExpensiveCalc is strictly after expensiveCalc. To ensure that two Future calculations begin in parallel, start them outside the for comprehension.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  val a = Future { expensiveCalc() }
  val b = Future { anotherExpensiveCalc() }
  for { i &lt;- a ; j &lt;- b } yield (i + j)
for comprehensions are fundamentally for defining sequential programs. We will show a far superior way of defining parallel computations in a later chapter. Spoiler: don’t use Future.</code></pre>
</div></div>
<div class="paragraph"><p>2.2 Unhappy path
So far we’ve only looked at the rewrite rules, not what is happening in map and flatMap. Consider what happens when the for context decides that it cannot proceed any further.</p></div>
<div class="paragraph"><p>In the Option example, the yield is only called when i,j,k are all defined.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    i &lt;- a
    j &lt;- b
    k &lt;- c
  } yield (i + j + k)
If any of a,b,c are None, the comprehension short-circuits with None but it doesn’t tell us what went wrong.</code></pre>
</div></div>
<div class="paragraph"><p>There are many functions in the wild that take Option parameters but actually require all parameters to exist. An alternative to throwing a runtime exception is to use a for comprehension, giving us totality (a return value for every input):</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def namedThings(
    someName  : Option[String],
    someNumber: Option[Int]
  ): Option[String] = for {
    name   &lt;- someName
    number &lt;- someNumber
  } yield s"$number ${name}s"
but this is verbose, clunky and bad style. If a function requires every input then it should make its requirement explicit, pushing the responsibility of dealing with optional parameters to its caller.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def namedThings(name: String, num: Int) = s"$num ${name}s"
If we use Either, then a Left will cause the for comprehension to short circuit with extra information, much better than Option for error reporting:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val a = Right(1)
scala&gt; val b = Right(2)
scala&gt; val c: Either[String, Int] = Left("sorry, no c")
scala&gt; for { i &lt;- a ; j &lt;- b ; k &lt;- c } yield (i + j + k)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  Left(sorry, no c)
And lastly, let’s see what happens with a Future that fails:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; import scala.concurrent._
  scala&gt; import ExecutionContext.Implicits.global
  scala&gt; for {
           i &lt;- Future.failed[Int](new Throwable)
           j &lt;- Future { println("hello") ; 1 }
         } yield (i + j)
  scala&gt; Await.result(f, duration.Duration.Inf)
  caught java.lang.Throwable
The Future that prints to the terminal is never called because, like Option and Either, the for comprehension short circuits.</code></pre>
</div></div>
<div class="paragraph"><p>Short circuiting for the unhappy path is a common and important theme. for comprehensions cannot express resource cleanup: there is no way to try / finally. This is good, in FP it puts a clear ownership of responsibility for unexpected error recovery and resource cleanup onto the context (which is usually a Monad as we will see later), not the business logic.</p></div>
<div class="paragraph"><p>2.3 Gymnastics
Although it is easy to rewrite simple sequential code as a for comprehension, sometimes we will want to do something that appears to require mental summersaults. This section collects some practical examples and how to deal with them.</p></div>
<div class="paragraph"><p>2.3.1 Fallback Logic
Say we are calling out to a method that returns an Option. If it is not successful we want to fallback to another method (and so on and so on), like when we’re using a cache:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>def getFromRedis(s: String): Option[String]
def getFromSql(s: String): Option[String]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  getFromRedis(key) orElse getFromSql(key)
If we have to do this for an asynchronous version of the same API</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def getFromRedis(s: String): Future[Option[String]]
  def getFromSql(s: String): Future[Option[String]]
then we have to be careful not to do extra work because</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    cache &lt;- getFromRedis(key)
    sql   &lt;- getFromSql(key)
  } yield cache orElse sql
will run both queries. We can pattern match on the first result but the type is wrong</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    cache &lt;- getFromRedis(key)
    res   &lt;- cache match {
               case Some(_) =&gt; cache !!! wrong type !!!
               case None    =&gt; getFromSql(key)
             }
  } yield res
We need to create a Future from the cache</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    cache &lt;- getFromRedis(key)
    res   &lt;- cache match {
               case Some(_) =&gt; Future.successful(cache)
               case None    =&gt; getFromSql(key)
             }
  } yield res
Future.successful creates a new Future, much like an Option or List constructor.</code></pre>
</div></div>
<div class="paragraph"><p>2.3.2 Early Exit
Say we have some condition that should exit early with a successful value.</p></div>
<div class="paragraph"><p>If we want to exit early with an error, it is standard practice in OOP to throw an exception</p></div>
<div class="literalblock">
<div class="content">
<pre><code>def getA: Int = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  val a = getA
  require(a &gt; 0, s"$a must be positive")
  a * 10
which can be rewritten async</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def getA: Future[Int] = ...
def error(msg: String): Future[Nothing] =
  Future.failed(new RuntimeException(msg))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    a &lt;- getA
    b &lt;- if (a &lt;= 0) error(s"$a must be positive")
         else Future.successful(a)
  } yield b * 10
But if we want to exit early with a successful return value, the simple synchronous code:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def getB: Int = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  val a = getA
  if (a &lt;= 0) 0
  else a * getB
translates into a nested for comprehension when our dependencies are asynchronous:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def getB: Future[Int] = ...</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    a &lt;- getA
    c &lt;- if (a &lt;= 0) Future.successful(0)
         else for { b &lt;- getB } yield a * b
  } yield c
If there is an implicit Monad[T] for T[_] (i.e. T is monadic) then Scalaz lets us create a T[A] from a value a: A by calling a.pure[T].</code></pre>
</div></div>
<div class="paragraph"><p>Scalaz provides Monad[Future], and .pure[Future] calls Future.successful. Besides pure being slightly shorter to type, it is a general concept that works beyond Future, and is therefore recommended.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    a &lt;- getA
    c &lt;- if (a &lt;= 0) 0.pure[Future]
         else for { b &lt;- getB } yield a * b
  } yield c
2.4 Incomprehensible
The context we’re comprehending over must stay the same: we cannot mix contexts.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; def option: Option[Int] = ...
  scala&gt; def future: Future[Int] = ...
  scala&gt; for {
           a &lt;- option
           b &lt;- future
         } yield a * b
  &lt;console&gt;:23: error: type mismatch;
   found   : Future[Int]
   required: Option[?]
           b &lt;- future
                ^
Nothing can help us mix arbitrary contexts in a for comprehension because the meaning is not well defined.</code></pre>
</div></div>
<div class="paragraph"><p>But when we have nested contexts the intention is usually obvious yet the compiler still doesn’t accept our code.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; def getA: Future[Option[Int]] = ...
  scala&gt; def getB: Future[Option[Int]] = ...
  scala&gt; for {
           a &lt;- getA
           b &lt;- getB
         } yield a * b
                   ^
  &lt;console&gt;:30: error: value * is not a member of Option[Int]
Here we want for to take care of the outer context and let us write our code on the inner Option. Hiding the outer context is exactly what a monad transformer does, and Scalaz provides implementations for Option and Either named OptionT and EitherT respectively.</code></pre>
</div></div>
<div class="paragraph"><p>The outer context can be anything that normally works in a for comprehension, but it needs to stay the same throughout.</p></div>
<div class="paragraph"><p>We create an OptionT from each method call. This changes the context of the for from Future[Option[_]] to OptionT[Future, _].</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
         } yield a * b
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
.run returns us to the original context</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; result.run
  res: Future[Option[Int]] = Future(&lt;not completed&gt;)
The monad transformer also allows us to mix Future[Option[_]] calls with methods that just return plain Future via .liftM[OptionT] (provided by scalaz):</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; def getC: Future[Int] = ...
  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
           c &lt;- getC.liftM[OptionT]
         } yield a * b / c
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
and we can mix with methods that return plain Option by wrapping them in Future.successful (.pure[Future]) followed by OptionT</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; def getD: Option[Int] = ...
  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
           c &lt;- getC.liftM[OptionT]
           d &lt;- OptionT(getD.pure[Future])
         } yield (a * b) / (c * d)
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
It is messy again, but it is better than writing nested flatMap and map by hand. We can clean it up with a DSL that handles all the required conversions into OptionT[Future, _]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def liftFutureOption[A](f: Future[Option[A]]) = OptionT(f)
  def liftFuture[A](f: Future[A]) = f.liftM[OptionT]
  def liftOption[A](o: Option[A]) = OptionT(o.pure[Future])
  def lift[A](a: A)               = liftOption(Option(a))
combined with the |&gt; operator, which applies the function on the right to the value on the left, to visually separate the logic from the transformers</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val result = for {
           a &lt;- getA       |&gt; liftFutureOption
           b &lt;- getB       |&gt; liftFutureOption
           c &lt;- getC       |&gt; liftFuture
           d &lt;- getD       |&gt; liftOption
           e &lt;- 10         |&gt; lift
         } yield e * (a * b) / (c * d)
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
|&gt; is often called the thrush operator because of its uncanny resemblance to the cute bird. Those who do not like symbolic operators can use the alias .into.</code></pre>
</div></div>
<div class="paragraph"><p>This approach also works for Either (and others) as the inner context, but their lifting methods are more complex and require parameters. Scalaz provides monad transformers for a lot of its own types, so it is worth checking if one is available.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-06 02:02:10 EEST
</div>
</div>
</body>
</html>
