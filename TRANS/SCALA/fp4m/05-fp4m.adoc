include::header.adoc[]

5. Типокласи Scalaz
===================

В цій главі ми зробимо по більшості типокласах в `scalaz-core`. Ми не використовуємо всі в `drone-dynamic-agents`, так що ми будемо надавати окремі приклади, коли це треба.

Була певна критика найменувань в Scalaz, та функціональному програмуванні загалом. Більшість наіменувань слідують домовленостям, введеним в мові програмування Haskell, базуючись на Category Theory. Почувайте вільно додавати псевдоніми типів, якщо дієслова, основані на первинній функціональності, простіше запам'ятати при навчанні (тобто, `Mappable`, `Pureable`, `FlatMappable`).

Перед тим, як ми введемо ієрархію типокласів, ми загостримо нашу увагу на чотирьох найбільш важливих методах з точки зору контроля потоком: методи, які ми будемо використовувати в більшості FP застосувань:

|===
|Typeclass|Method|From|Given|To
|Functor|map|F[A]|A => B|F[B]
|Applicative|pure|A||F[A]
|Monad|flatMap|F[A]|A => F[B]|F[B]
|Traverse|sequence|F[G[A]]||G[F[A]]
|===

Ми знаємо, що операції, що повертають `F[\_]` можуть виконуватись послідовно в розширеному `for` через `.flatMap`, визначеному на його `Monad[F]`. Контекст `F[_]` може бути промислений як контейнер для бажаного ефекту з `A` в якості виходу: `flatMap` дозволяє нам генерувати нові ефекти `F[B]` під час виконання, базуючись на результатах обчислення попередніх ефектів.

Звичайно, не всі конструкції типів `F[_]` ефективні, навіть якщо вони мають `Monad[F]`. Часто вони є структурами даних. Через використання найменьш специфічної абстракції, ми можемо повторно використовувати код для `List`, `Either`, `Future` і так далі.

Якщо вам треба тільки трансформувати вивід від `F[_]`, що є просто `map`, введене `Functor`. В Главі 3 ми виконуємо ефекти паралельно, через створення продукту і відображення по ним. В функціонально програмуванні розпаралелювальні обчислення визначаються менш потужними, ніж послідовні.

Посеред `Monad` та `Functor` знаходиться `Applicative`, що визначає `pure`, що дозволяє нам підійняти розглянуване значення, або створити структуру даних з одного значення.

`.sequence` корисне для переаранжування конструкторів типу. Якщо ви маєте `F[G[\_]]`, але нам треба `G[F[_]]`, тобто `List[Future[Int]]`, але нам треба `Future[List[Int]]`, це є `.sequence`.

5.1 Передмова
-------------

Ця глава довша ніж звичайно, і стисло напакована інформацією: досить логічно атакувати її за декілька раз. Запам'ятовування всього може вимагати нелюдських якостей, так що розглядайте цю главу як шлях дізнатись, де шукати додаткову інформацію.

Помітна відсутність типокласів, що розширюють `Monad`. Вони отримують свою окрему главу пізніше.

Scalaz використовує генерацію кода, не симуляцію. Однак для краткості ми представляємо шматки коду з `@typeclass`. Еквівалентний синтаксис доступний, коли ми робимо `import scalaz._, Scalaz._`, та доступний в пакунку `scalaz.syntax` в джерельному коді `scalaz`.

5.2 Додавані речі
-----------------
[source,scala]
----
  @typeclass trait Semigroup[A] {
    @op("|+|") def append(x: A, y: =>A): A
  
    def multiply1(value: F, n: Int): F = ...
  }
  
  @typeclass trait Monoid[A] extends Semigroup[A] {
    def zero: A
  
    def multiply(value: F, n: Int): F =
      if (n <= 0) zero else multiply1(value, n - 1)
  }
  
  @typeclass trait Band[A] extends Semigroup[A]
----
`|+|` відоме як оператор TIE Fighter. Існує також Advanced TIE Fighter в наступному розділі, що дуже захопливо.

Напівгрупа `Semigroup` може бути визначене для типу, якщо два значення може бути скомбіноване. Операція має бути асоціативна, що означає, що порядок вкладених операцій не має значення:
----
  (a |+| b) |+| c == a |+| (b |+| c)
  
  (1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)
----
`Monoid` є `Semigroup` з нульовим елементом (також називається порожнім або ідентичністю). Комбінація нуля з любим іншим `a` повинно давати `a`.
----
  a |+| zero == a
  
  a |+| 0 == a
----
Це, можливо, повертає пам'ять до `Numeric` з Глави 4. Є реалізації `Monoid` для всіх примітивних чисел, але концепція додаваних речей корисна і за межами чисел.
[source,scala]
----
  scala> "hello" |+| " " |+| "world!"
  res: String = "hello world!"
  
  scala> List(1, 2) |+| List(3, 4)
  res: List[Int] = List(1, 2, 3, 4)
----
`Band` має закон, що операція додавання до тих самих двох операндів ідемпотентна, тобто дає те саме значення. Прикладом може бути будь-що, що може мати тільки одне значення, як `Unit`, найменьша вища межа, або `Set`. `Band` не провадить додаткових методів, але користувачі можуть використовувати гарантії для оптимізації продуктивності.

Viktor Klang з Lightbend притендує на фразу ефективно-одноразової доставки для обробки повідомлень, з іденпотентними операціями, тобто `Band.append`.

Як реалістичний приклад для `Monoid`, розглянемо торгівельну систему, що має велику базу даних повторно використовуваних шаблонів торгівлі. Заповнення значень по замовчанню для нових торгів включає вибір та комбінування декількох шаблонів, з політикою поєднання “останнє правило перемагає”, якщо два шаблони мають значення для того самого поля. Робота “обирання” вже виконана для анс іншою системою, наше завдання є скомбінувати шаблони по порядку.

Ми будемо створювати просту схему шаблонів для демонстрації принципів, але майте на увазі, що реалістична система може мати більш складні ADT.
[source,scala]
----
  sealed abstract class Currency
  case object EUR extends Currency
  case object USD extends Currency
  
  final case class TradeTemplate(
    payments: List[java.time.LocalDate],
    ccy: Option[Currency],
    otc: Option[Boolean]
  )
----
Якщо ми пишемо метод, що приймає шаблони: `List[TradeTemplate]`, нам треба тільки викликати
[source,scala]
----
  val zero = Monoid[TradeTemplate].zero
  templates.foldLeft(zero)(_ |+| _)
----
і наша робота виконана!

Але щоб отримати `zero` або викликати `|+|` ми маємо мати примірник  `Monoid[TradeTemplate]`. Хоча ми загалом наслідувати його в наступній главі, доки ми будемо створювати примірник на компанйоні:
[source,scala]
----
  object TradeTemplate {
    implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
      (a, b) => TradeTemplate(a.payments |+| b.payments,
                              a.ccy |+| b.ccy,
                              a.otc |+| b.otc),
      TradeTemplate(Nil, None, None)
    )
  }
----
Однак це не робить те, що ми бажаємо, оскільки `Monoid[Option[A]]` буде додавати свій вміст, тобто:
[source,scala]
----
  scala> Option(2) |+| None
  res: Option[Int] = Some(2)
  scala> Option(2) |+| Option(1)
  res: Option[Int] = Some(3)
----
в той час, коли ми бажаємо “останній закон перемагає”. Ми можемо перекрити `Monoid[Option[A]]` по замовчанню своїм власним:
[source,scala]
----
  implicit def lastWins[A]: Monoid[Option[A]] = Monoid.instance(
    {
      case (None, None)   => None
      case (only, None)   => only
      case (None, only)   => only
      case (_   , winner) => winner
    },
    None
  )
----
Тепер все компілюється, спробуйте самі…
[source,scala]
----
  scala> import java.time.{LocalDate => LD}
  scala> val templates = List(
           TradeTemplate(Nil,                     None,      None),
           TradeTemplate(Nil,                     Some(EUR), None),
           TradeTemplate(List(LD.of(2017, 8, 5)), Some(USD), None),
           TradeTemplate(List(LD.of(2017, 9, 5)), None,      Some(true)),
           TradeTemplate(Nil,                     None,      Some(false))
         )
  
  scala> templates.foldLeft(zero)(_ |+| _)
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
----
Все що вам треба було зробити, це реалізовати один фрагмент бізнес логіки, та `Monoid` потурбується про све інше за нас!

Зауважте, що список платежів сконкатенований. Це тому, що по замовчанню `Monoid[List]` використовує конкатенацію елементів, та це часто бажана поведінка. Якщо бізнес потреби інші, може бути простим випадком запровадити власний `Monoid[List[LocalDate]]`. Згадайте з Глави 4, що з повним поліморфізмом ми можемо мати іншу реалізацію `append`, в залежності від `E` в `List[E]`, не тільки на основі рантайм класу `List`.

Коли ми ввели типокласу в Главі 4, ми казали, що може бути тільки одна реалізація типкласа для наданого параметра типу, тобто тільки один `Monoid[Option[Boolean]]` в застосуванні. Сирітливі примірники, як `lastWins` є простішим шляхом зруйнувати когерентність.

Ми можемо спробувати виправдати локально зруйновану когерентність типкласів, зробивши `lastWins` приватним, але коли ми дійдемо до типокалсу `Plus`, ми побачимо кращий шлях для реалізації нашого `Monoid`. Коли ми отримаємо теговані типи, ми побачимо навіть кращий спосіб: використовуючи `LastOption` замість `Option` в нашій моделі даних.

Будь-ласка, не ламайте когерентність типокласів самостійно, дітки.

5.3 Об'єктні речі
-----------------
В главі про дані та функціональність ми казали, що нотація еквівалентності JVM поламана для багатьох речей, що ми можемо покласти до ADT. Проблема в тому, що JVM була розроблена для Java, та `equals` визначений для `java.lang.Object`, чи має це сенс, чи ні. Немає способу видалити `equals`, і немає шляху гарантувати, що він реалізований.

Однак в FP ми обираємо типокласи для поліморфної функціональності, і навіть концепція еквівалентності захоплюється під час компіляції.
[source,scala]
----
  @typeclass trait Equal[F]  {
    @op("===") def equal(a1: F, a2: F): Boolean
    @op("/==") def notEqual(a1: F, a2: F): Boolean = !equal(a1, a2)
  }
----
Замість `===` (потрійна рівність) більш типо-безпечна, ніж `==` (родвійна рівність), оскільки вона може бути скомпільована тільки коли типи ті самі на обох боках порівняння. Це відловлює багато вад.

`equal` має ті самі вимоги до реалізації, що і `Object.equals`
[source,scala]
----
    commutative f1 === f2 implies f2 === f1
    reflexive f === f
    transitive f1 === f2 && f2 === f3 implies f1 === f3
----
Відкидаючи універсальну концепцію `Object.equals`, ми не приймаємо рівність як гарантовану, коли ми конструюємо ADT,зупиняючи нас під час компіляції від очікування еквівалентності, там де її немає.

Продовжуючи тренд заміни старих Java концепцій, замість маючи дані типу `java.lang.Comparable`, тепер вони мають відповідний `Order`:
[source,scala]
----
  @typeclass trait Order[F] extends Equal[F] {
    @op("?|?") def order(x: F, y: F): Ordering
  
    override  def equal(x: F, y: F): Boolean = order(x, y) == Ordering.EQ
    @op("<" ) def lt(x: F, y: F): Boolean = ...
    @op("<=") def lte(x: F, y: F): Boolean = ...
    @op(">" ) def gt(x: F, y: F): Boolean = ...
    @op(">=") def gte(x: F, y: F): Boolean = ...
  
    def max(x: F, y: F): F = ...
    def min(x: F, y: F): F = ...
    def sort(x: F, y: F): (F, F) = ...
  }
  
  sealed abstract class Ordering
  object Ordering {
    case object LT extends Ordering
    case object EQ extends Ordering
    case object GT extends Ordering
  }
----
`Order` реалізує `.equal` в термінах нового примітиву `.order`. Коли типоклас реалізує батьківській примітивний комбінатор з наслідуваним комбінатором, правило заміни для типокласу є додавання. Якщо примірник `Order` перекривав `.equal` з причин продуктивності, він має поводитись ідентично до оригіналу.

Речі, що мають порядок, також можуть бути дескретними, дозволяючи нам крокувати до наступного або попереднього:
[source,scala]
----
  @typeclass trait Enum[F] extends Order[F] {
    def succ(a: F): F
    def pred(a: F): F
    def min: Option[F]
    def max: Option[F]
  
    @op("-+-") def succn(n: Int, a: F): F = ...
    @op("---") def predn(n: Int, a: F): F = ...
  
    @op("|->" ) def fromToL(from: F, to: F): List[F] = ...
    @op("|-->") def fromStepToL(from: F, step: Int, to: F): List[F] = ...
    @op("|=>" ) def fromTo(from: F, to: F): EphemeralStream[F] = ...
    @op("|==>") def fromStepTo(from: F, step: Int, to: F): EphemeralStream[F] = ...
  }

  scala> 10 |--> (2, 20)
  res: List[Int] = List(10, 12, 14, 16, 18, 20)
  
  scala> 'm' |-> 'u'
  res: List[Char] = List(m, n, o, p, q, r, s, t, u)
----
`|-->` є Scalaz Lightsaber. Це синтаксис для Функціонального Програміста. Не таке відволікаюче або довільне як `fromStepToL`. Елегантний синтаксис… для більш цивілізованого віку.

Ми обсудимо `EphemeralStream` в наступній главі, доки нам лише треба знати, що існує потенційно безкінечна структура даних, що уникає проблем затримання пам'яті в `stdlib` `Stream`.

Подібно до `Object.equals`, концепція `.toString` на кожному класі не має сенсу в Java. Ми бажали б примусити рядковість під час компіляції, і це саме те, чого досягає `Show`:
[source,scala]
----
  trait Show[F] {
    def show(f: F): Cord = ...
    def shows(f: F): String = ...
  }
----
Ми будемо досліджувати `Cord` більш детально в главі по типам даних, нам треба тільки знати, що це ефективна структура даних для зберігання та маніпулювання `String`.

5.4 Відображувані речі
----------------------
Ми сконцентруємось на речах, по яких можна мандрувати та відображувати (робити меппінг), в деякому сенсі:

5.4.1 Functor
~~~~~~~~~~~~~
[source,scala]
----
  @typeclass trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
  
    def void[A](fa: F[A]): F[Unit] = map(fa)(_ => ())
    def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)] = map(fa)(a => (a, f(a)))
  
    def fpair[A](fa: F[A]): F[(A, A)] = map(fa)(a => (a, a))
    def strengthL[A, B](a: A, f: F[B]): F[(A, B)] = map(f)(b => (a, b))
    def strengthR[A, B](f: F[A], b: B): F[(A, B)] = map(f)(a => (a, b))
  
    def lift[A, B](f: A => B): F[A] => F[B] = map(_)(f)
    def mapply[A, B](a: A)(f: F[A => B]): F[B] = map(f)((ff: A => B) => ff(a))
  }
----
Єдиний абстрактний метод є `map`, і він має робити композицію, тобто меппінг за допомогою `f`, та потім знову за допомогою `g`, це те саме, що одночасне відображення за допомогою композиції `f` та `g`:
[source,scala]
----
  fa.map(f).map(g) == fa.map(f.andThen(g))
----
`map` також має виконувати _no-op_, якщо запроваджена функція є `identity` (`x => x`)
[source,scala]
----
  fa.map(identity) == fa
  
  fa.map(x => x) == fa
----
`Functor` визначає деякі зручні методи навколо `map`, що можуть бути оптимізовані специфічними примірниками. Документація навмисне відсутня в попередніх визначеннях, щоб заохотити до здогадок, що саме робить метод, до того як звернутись до реалізації. Будь ласка, витратьте момент на вивчення тільки сигнатури наступного, перед тим як читати далі:
[source,scala]
----
  def void[A](fa: F[A]): F[Unit]
  def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)]
  
  def fpair[A](fa: F[A]): F[(A, A)]
  def strengthL[A, B](a: A, f: F[B]): F[(A, B)]
  def strengthR[A, B](f: F[A], b: B): F[(A, B)]
  
  // harder
  def lift[A, B](f: A => B): F[A] => F[B]
  def mapply[A, B](a: A)(f: F[A => B]): F[B]
----
* `void` приймає примірник `F[A]`, та завжди повертає `F[Unit]`, він забуває всі значення, при цьому зберігаючи структуру.

* `fproduct` приймає той самий вхід як мапу, але повертає `F[(A, B)]`, тобто він склаладає в тапли вмісту з результатом, застосовуючи функцію. Це корисно, коли ми бажаємо зберігти також вхідні значення.
    
* `fpair` збирає всі елементи `A` в тапл `F[(A, A)]`

* `strengthL` парує вміст `F[B]` з констанотою `A` зліва.

* `strengthR` парує вміст `F[A]` з константою `B` зправа.

* `lift` приймає функцію `A => B`, та повертає `F[A] => F[B]`. Інишими словами, він бере функцію над вмістом `F[A]`, та повертає функцію, що оперує на `F[A]` напряму.

* `mapply` є головоломкою. Скажімо, ми маємо `F[_]` для функцій `A => B`, та деяке значення `A`, тоді ми можемо отримати `F[B]`. Він має сигнатуру, подібну до `pure`, але вимагає від викликаючого запровадити `F[A => B]`.

`fpair`, `strengthL` та `strengthR` виглядають досить непотрібними, але вони корисні, коли ми бажаємо залишити деяку інформацію, що інакше може бути втрачена з поля зору.

`Functor` має деякий особливий синтакс:
[source,scala]
----
  implicit class FunctorOps[F[_]: Functor, A](self: F[A]) {
    def as[B](b: =>B): F[B] = Functor[F].map(self)(_ => b)
    def >|[B](b: =>B): F[B] = as(b)
  }
----
`.as` та `>|` є способом заміни виводу за допомогою констант.

Коли Scalaz провадить додаткову функціональність як синтаксис, скоріше ніж самі типокласи, це так через бінарну сумісність.

Якщо виходить версія Scalaz X.Y.0, неможливо додати методи до типокласів в цій серії релізів для Scala 2.10 та 2.11. Так що має сенс читати обоє, джерело типокласу та його синтаксис.

В нашому прикладі застосування, в якості гидкого хаку (яких ми навіть досі не визнавали), ми визначали `start` та `stop` для повернення їх входів:
[source,scala]
----
  def start(node: MachineNode): F[MachineNode]
  def stop (node: MachineNode): F[MachineNode]
----
Це дозволяє нам писати скорочену бізнес логіку, таку як:
[source,scala]
----
  for {
    _      <- m.start(node)
    update = world.copy(pending = Map(node -> world.time))
  } yield update
----
та
[source,scala]
----
  for {
    stopped <- nodes.traverse(m.stop)
    updates = stopped.map(_ -> world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
----
Але цей хак заштовхує непотрібну складність в реалізації. Буде краще, якщо ми дозволимо нашим алгебрам повертати `F[Unit]` та використовувати `as`:
[source,scala]
----
  m.start(node) as world.copy(pending = Map(node -> world.time))
----
та
[source,scala]
----
  for {
    stopped <- nodes.traverse(a => m.stop(a) as a)
    updates = stopped.map(_ -> world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
----

5.4.2 Foldable
~~~~~~~~~~~~~~
Технічно `Foldable` призначений для структур даних, по яких можна проходити для отримання сумарного значення. Однак це приховує факт, що це одно-типокласова армія, що може запровадити більшість з того, що ви очікуєте побачити в Collections API.

Існує так багато методів, що ми збираємось розбити їх на частини, починаючи з абстрактних методів:
[source,scala]
----
  @typeclass trait Foldable[F[_]] {
    def foldMap[A, B: Monoid](fa: F[A])(f: A => B): B
    def foldRight[A, B](fa: F[A], z: =>B)(f: (A, =>B) => B): B
    def foldLeft[A, B](fa: F[A], z: B)(f: (B, A) => B): B = ...
----
Примірник `Foldable` має реалізувати тільки `foldMap` та `foldRight`, щоб отримати всю функціональність цього типокласу, хоча методи типово оптимізовані для специфічних структур даних.

* `.foldMap` має маркетингове ім'я: `MapReduce`. Беручи `F[A]`, функцію від `A` до `B`, та спосіб комбінувати `B` (запроваджену в `Monoid`,разом з `zero` `B`), ми можемо спродукувати сумарне значення типу `B`. Немає жодного примусу щодо порядку операцій, що дозволяє паралельне виконання.

* `foldRight` не вимагає, щоб його параметри мали `Monoid`, що означає, що він потребує стартове значення `z`, та спосіб комбінувати кожний елемент даних в структурі даних з сумарним значенням. Порядок для обходу елементів зправа наліво, і, таким чином, він не може бути розпаралелений.

`foldRight` концептуально те саме, що і `foldRight` в Scala `stdlib`. Однак існує проблема з сигнатурою `stdlib` `foldRight`, вирішена в Scalaz: дуже великі структури даних можуть переповнити стек. `List.foldRight` махлює, реалізуючи `foldRight` як реверсований `foldLeft`:
[source,scala]
----
  override def foldRight[B](z: B)(op: (A, B) => B): B =
    reverse.foldLeft(z)((right, left) => op(left, right))
----
але концепція реверсу не є універсальною, та цей обхідний шлях не може бути використаний для всіх структур даних. Скажімо, ми бажаємо знайти мале число в `Stream`, з ранішним виходом:
[source,scala]
----
  scala> def isSmall(i: Int): Boolean = i < 10
  scala> (1 until 100000).toStream.foldRight(false) {
           (el, acc) => isSmall(el) || acc
         }
  java.lang.StackOverflowError
    at scala.collection.Iterator.toStream(Iterator.scala:1403)
    ...
----
Scalaz вирішує цю проблему, беручи параметр за ім'ям для значення агрегату:
[source,scala]
----
  scala> (1 |=> 100000).foldRight(false)(el => acc => isSmall(el) || acc )
  res: Boolean = true
----
що означає, що `acc` не обчислюється, доки він не буде потрібний.

Корисно мати на увазі, що не всі операції стеко-безпечні в `foldRight`. Якщо ми запитаємо обчислення всіх елементів, ми також можемо отримати `StackOverflowError` зі Scalaz `EphemeralStream`:
[source,scala]
----
  scala> (1L |=> 100000L).foldRight(0L)(el => acc => el |+| acc )
  java.lang.StackOverflowError
    at scalaz.Foldable.$anonfun$foldr$1(Foldable.scala:100)
    ...
----

* `foldLeft` проходить по елементах зліва направо. `foldLeft` може бути реалізований в термінах `foldMap`, але більшість примірників обирають реалізувати його, бо це дуже базова операція. Оскільки він звичайно реалізований за допомогою хвостової рекурсії, тут нема параметрів за ім'ям.

Єдине правило для `Foldable` в тому, що `foldLeft` та `foldRight` повинні кожний бути сумісним з `foldMap` для моноїдних операцій. Тобто додавати елемент до списку для `foldLeft`, та передставляти елемент перед списком для `foldRight`. Однак `foldLeft` та `foldRight` не мають бути сумісними один з одним: фактично, вони часто продукують реверс один одного.

Простіша річ, що можна зробити з `foldMap`, це використати функцію `identity`, даючи `fold` (природна сума моноїдальних елементів), з лівими/правими варівантами, щоб дозволити вибір на основі критерів продуктивності:
[source,scala]
----
  def fold[A: Monoid](t: F[A]): A = ...
  def sumr[A: Monoid](fa: F[A]): A = ...
  def suml[A: Monoid](fa: F[A]): A = ...
----
Згадавши що ми навчились про `Monoid`, ми запишемо таке:
[source,scala]
----
  scala> templates.foldLeft(Monoid[TradeTemplate].zero)(_ |+| _)
----
Тепер ми знаємо, що це дурня, і ми маємо писати так:
[source,scala]
----
  scala> templates.toIList.fold
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
----
`.fold` не робить з `stdlib List`, оскільки він вже має метод з назвою `fold`, що вже робить свої власні речі в свій власний спосіб.

Дивно названий `intercalate` всатавляє специфічний `A` між кожним елементом, перед тим, як виконати `fold`:
[source,scala]
----
  def intercalate[A: Monoid](fa: F[A], a: A): A = ...
----
що є узагальненою версією `stdlib mkString`:
[source,scala]
----
  scala> List("foo", "bar").intercalate(",")
  res: String = "foo,bar"
----
`foldLeft` провадить механізм отримання кожного елементу через індекс доступу, включаючи декілька інших пов'язаних методів:
[source,scala]
----
  def index[A](fa: F[A], i: Int): Option[A] = ...
  def indexOr[A](fa: F[A], default: =>A, i: Int): A = ...
  def length[A](fa: F[A]): Int = ...
  def count[A](fa: F[A]): Int = length(fa)
  def empty[A](fa: F[A]): Boolean = ...
  def element[A: Equal](fa: F[A], a: A): Boolean = ...
----
Scalaz є чистою бібліотекою для тільки загальних функцій. Коли `List(0)` може закидати виключення, `Foldable.index` повертає `Option[A]` зі зручним `.indexOr`, що повертає A коли надане значення по замовчанню. `.element` подібний до `stdlib` `.contains`, але використовує `Equal` замість хворобливо-визначеного JVM `equality`.

Ці методи насправді виглядають як API колекцій. Та, звичайно, все з `Foldable` може бути перетворено на `List`:
[source,scala]
----
  def toList[A](fa: F[A]): List[A] = ...
----
Також є перетворення до інших `stdlib` та `Scalaz` типів даних, таких як `.toSet`, `.toVector`, `.toStream`, `.to[T <: TraversableLike]`, `.toIList` і так далі.

В наявності корисні перевірки предикатів:
[source,scala]
----
  def filterLength[A](fa: F[A])(f: A => Boolean): Int = ...
  def all[A](fa: F[A])(p: A => Boolean): Boolean = ...
  def any[A](fa: F[A])(p: A => Boolean): Boolean = ...
----

`filterLength` це спосіб підрахувати, як багато елементів `true` для предиката, `all` та `any` повертають `true`, якщо всі (або любий) елементи задовільняють предикату, та можуть виходити рано.

Ми бачили `NonEmptyList` в попередніх главах. Для краткості ми використовували псевдоним типу `Nel` замість `NonEmptyList`.

Також в попередніх главах ми бачили `IList`, згадайте, що це альтернатива до `stdlib` `List` з видаленими нечистими методами, як `apply`.

Ми можемо розділити `F[A]` на частини, чий результат буде те саме `B`, за допомогою `splitBy`:
[source,scala]
----
  def splitBy[A, B: Equal](fa: F[A])(f: A => B): IList[(B, Nel[A])] = ...
  def splitByRelation[A](fa: F[A])(r: (A, A) => Boolean): IList[Nel[A]] = ...
  def splitWith[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...
  def selectSplit[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...
  
  def findLeft[A](fa: F[A])(f: A => Boolean): Option[A] = ...
  def findRight[A](fa: F[A])(f: A => Boolean): Option[A] = ...
----
наприклад:
[source,scala]
----
  scala> IList("foo", "bar", "bar", "faz", "gaz", "baz").splitBy(_.charAt(0))
  res = [(f, [foo]), (b, [bar, bar]), (f, [faz]), (g, [gaz]), (b, [baz])]
----
зауважте, що є два значення, індексовані через `'b'`.

`splitByRelation` уникає потреби для `Equal`, але ми маємо запровадити оператор порівняння.

`splitWith` розділяє елементи на групи, що або задовільняють предикату, або ні. `selectSplit` обирає групи елементів, що задовільняють предикату, відкидаючи інші. Це один з тих рідких випадків, коли два методи поділяють ту саму сигнатуру типів, але мають різне значення.

`findLeft` та `findRight` перший елемент зліва або зправа, відповідно, що задовільняє предикату.

Надалі використовуючи `Equal` та `Order`, ми маємо окремі мектоди, що повертають групування.
[source,scala]
----
  def distinct[A: Order](fa: F[A]): IList[A] = ...
  def distinctE[A: Equal](fa: F[A]): IList[A] = ...
  def distinctBy[A, B: Equal](fa: F[A])(f: A => B): IList[A] =
----
`distinct` реалізований більш ефективно, ніж `distinctE`, оскільки він може використовувати впорядкування, і таким чином використовувати алгоритм швидкого сортування, що значно швидший, ніж природний `stdlib` `List.distinct`. Структури даних (такі як множини) можуть реалізувати `distinct` в своєму `Foldable` без виконання жодної роботи.

`distinctBy` дозволяє груаування по результату застосування функції до елементів. Наприклад, групувати імена по першій літері.

Ми можемо надалі використовувати `Order` через виділення мінімального або максимального елементів (або обоє екстремуми), включаючи різні використання шаблону `Of` або `By` до першої мапи до іншого типу, або для використання іншого типу для виконання порівняння впорядкування.
[source,scala]
----
  def maximum[A: Order](fa: F[A]): Option[A] = ...
  def maximumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def maximumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...
  
  def minimum[A: Order](fa: F[A]): Option[A] = ...
  def minimumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def minimumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...
  
  def extrema[A: Order](fa: F[A]): Option[(A, A)] = ...
  def extremaOf[A, B: Order](fa: F[A])(f: A => B): Option[(B, B)] = ...
  def extremaBy[A, B: Order](fa: F[A])(f: A => B): Option[(A, A)] =
----
Наприклад, ми можемо запитати, який рядок `String` є максимальним `By` довжині, або яка максимальна довжина `Of` елементів.
[source,scala]
----
  scala> List("foo", "fazz").maximumBy(_.length)
  res: Option[String] = Some(fazz)
  
  scala> List("foo", "fazz").maximumOf(_.length)
  res: Option[Int] = Some(4)
----
Це підсумовує ключові властивості `Foldable`. Вивод такий, що будь-що, що ми очікуємо знайти в бібліотеці колекцій, можливо є в `Foldable`, та якщо ні, воно мало б там бути.

Ми завершимо деякими варіаціями методів, що ми вже бачили. Зпочатку це методи, що приймають `Semigroup` замість `Monoid`:
[source,scala]
----
  def fold1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def foldMap1Opt[A, B: Semigroup](fa: F[A])(f: A => B): Option[B] = ...
  def sumr1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def suml1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  ...
----
та повертає `Option`, щоб прийняти до уваги порожні структури даних (згадайте, що `Semigroup` не має нуля).

Методи читаються “1-Option”, не _10 pt_ як в типографіці.

Типоклас `Foldable1` містить значно більше `Semigroup` варіантів для `Monoid` методів, показаних тут (всі з суфіксом 1), та мають сенс для структур, що ніколи не порожні, без вимоги бути `Monoid` від елементів.

Важливо, що існують варіанти, що приймають манадичні значення повернення. Ми вже використовували `foldLeftM`, коли ми зпочатку писали бізнес логіку для нашого застосування, і тепер ми знаємо, що це походить від `Foldable`:
[source,scala]
----
  def foldLeftM[G[_]: Monad, A, B](fa: F[A], z: B)(f: (B, A) => G[B]): G[B] = ...
  def foldRightM[G[_]: Monad, A, B](fa: F[A], z: =>B)(f: (A, =>B) => G[B]): G[B] = ...
  def foldMapM[G[_]: Monad, A, B: Monoid](fa: F[A])(f: A => G[B]): G[B] = ...
  def findMapM[M[_]: Monad, A, B](fa: F[A])(f: A => M[Option[B]]): M[Option[B]] = ...
  def allM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
  def anyM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
  ...
----

5.4.3 Traverse
~~~~~~~~~~~~~~

