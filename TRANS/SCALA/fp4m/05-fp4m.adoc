include::header.adoc[]

== 5. Типокласи Scalaz

В цій главі ми зробимо прохід по більшості типокласах в `scalaz-core`. Ми не використовуємо всі в `drone-dynamic-agents`, так що ми будемо надавати окремі приклади, коли це треба.

Була певна критика найменувань в Scalaz, та функціональному програмуванні загалом. Більшість наіменувань слідують домовленостям, введеним в мові програмування Haskell, базуючись на Category Theory. Почувайте вільно додавати псевдоніми типів, якщо дієслова, основані на первинній функціональності, простіше запам'ятати при навчанні (тобто, `Mappable`, `Pureable`, `FlatMappable`).

Перед тим, як ми введемо ієрархію типокласів, ми загостримо нашу увагу на чотирьох найбільш важливих методах з точки зору контроля потоком: методи, які ми будемо використовувати в більшості FP застосувань:

|===
|Typeclass|Method|From|Given|To
|Functor|map|F[A]|A => B|F[B]
|Applicative|pure|A||F[A]
|Monad|flatMap|F[A]|A => F[B]|F[B]
|Traverse|sequence|F[G[A]]||G[F[A]]
|===

Ми знаємо, що операції, що повертають `F[\_]` можуть виконуватись послідовно в розширеному `for` через `.flatMap`, визначеному на його `Monad[F]`. Контекст `F[_]` може бути промислений як контейнер для бажаного ефекту з `A` в якості виходу: `flatMap` дозволяє нам генерувати нові ефекти `F[B]` під час виконання, базуючись на результатах обчислення попередніх ефектів.

Звичайно, не всі конструкції типів `F[_]` ефективні, навіть якщо вони мають `Monad[F]`. Часто вони є структурами даних. Через використання найменьш специфічної абстракції, ми можемо повторно використовувати код для `List`, `Either`, `Future` і так далі.

Якщо вам треба тільки трансформувати вивід від `F[_]`, що є просто `map`, введене через `Functor`. В Главі 3 ми виконуємо ефекти паралельно, через створення продукту і відображення по ним. В функціонально програмуванні розпаралелювальні обчислення визначаються менш потужними, ніж послідовні.

Посеред `Monad` та `Functor` знаходиться `Applicative`, що визначає `pure`, що дозволяє нам підійняти розглянуване значення, або створити структуру даних з одного значення.

`.sequence` корисне для переаранжування конструкторів типу. Якщо ви маєте `F[G[\_]]`, але нам треба `G[F[_]]`, тобто `List[Future[Int]]`, але нам треба `Future[List[Int]]`, це є `.sequence`.

=== 5.1 Передмова

Ця глава довша ніж звичайно, і стисло напакована інформацією: досить логічно атакувати її за декілька раз. Запам'ятовування всього може вимагати нелюдських якостей, так що розглядайте цю главу як шлях дізнатись, де шукати додаткову інформацію.

Помітна відсутність типокласів, що розширюють `Monad`. Вони отримують свою окрему главу пізніше.

Scalaz використовує генерацію кода, не симуляцію. Однак для краткості ми представляємо шматки коду з `@typeclass`. Еквівалентний синтаксис доступний, коли ми робимо `import scalaz._, Scalaz._`, та доступний в пакунку `scalaz.syntax` в джерельному коді `scalaz`.

=== 5.2 Додавані речі

[source,scala]
----
  @typeclass trait Semigroup[A] {
    @op("|+|") def append(x: A, y: =>A): A
  
    def multiply1(value: F, n: Int): F = ...
  }
  
  @typeclass trait Monoid[A] extends Semigroup[A] {
    def zero: A
  
    def multiply(value: F, n: Int): F =
      if (n <= 0) zero else multiply1(value, n - 1)
  }
  
  @typeclass trait Band[A] extends Semigroup[A]
----
`|+|` відоме як оператор TIE Fighter. Існує також Advanced TIE Fighter в наступному розділі, що дуже захопливо.

Напівгрупа `Semigroup` може бути визначене для типу, якщо два значення може бути скомбіноване. Операція має бути асоціативна, що означає, що порядок вкладених операцій не має значення:
----
  (a |+| b) |+| c == a |+| (b |+| c)
  
  (1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)
----
`Monoid` є `Semigroup` з нульовим елементом (також називається порожнім або ідентичністю). Комбінація нуля з любим іншим `a` повинно давати `a`.
----
  a |+| zero == a
  
  a |+| 0 == a
----
Це, можливо, повертає пам'ять до `Numeric` з Глави 4. Є реалізації `Monoid` для всіх примітивних чисел, але концепція додаваних речей корисна і за межами чисел.
[source,scala]
----
  scala> "hello" |+| " " |+| "world!"
  res: String = "hello world!"
  
  scala> List(1, 2) |+| List(3, 4)
  res: List[Int] = List(1, 2, 3, 4)
----
`Band` має закон, що операція додавання до тих самих двох операндів ідемпотентна, тобто дає те саме значення. Прикладом може бути будь-що, що може мати тільки одне значення, як `Unit`, найменьша вища межа, або `Set`. `Band` не провадить додаткових методів, але користувачі можуть використовувати гарантії для оптимізації продуктивності.

Viktor Klang з Lightbend притендує на фразу ефективно-одноразової доставки для обробки повідомлень, з іденпотентними операціями, тобто `Band.append`.

Як реалістичний приклад для `Monoid`, розглянемо торгівельну систему, що має велику базу даних повторно використовуваних шаблонів торгівлі. Заповнення значень по замовчанню для нових торгів включає вибір та комбінування декількох шаблонів, з політикою поєднання “останнє правило перемагає”, якщо два шаблони мають значення для того самого поля. Робота “обирання” вже виконана для анс іншою системою, наше завдання є скомбінувати шаблони по порядку.

Ми будемо створювати просту схему шаблонів для демонстрації принципів, але майте на увазі, що реалістична система може мати більш складні ADT.
[source,scala]
----
  sealed abstract class Currency
  case object EUR extends Currency
  case object USD extends Currency
  
  final case class TradeTemplate(
    payments: List[java.time.LocalDate],
    ccy: Option[Currency],
    otc: Option[Boolean]
  )
----
Якщо ми пишемо метод, що приймає шаблони: `List[TradeTemplate]`, нам треба тільки викликати
[source,scala]
----
  val zero = Monoid[TradeTemplate].zero
  templates.foldLeft(zero)(_ |+| _)
----
і наша робота виконана!

Але щоб отримати `zero` або викликати `|+|` ми маємо мати примірник  `Monoid[TradeTemplate]`. Хоча ми загалом наслідувати його в наступній главі, доки ми будемо створювати примірник на компанйоні:
[source,scala]
----
  object TradeTemplate {
    implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
      (a, b) => TradeTemplate(a.payments |+| b.payments,
                              a.ccy |+| b.ccy,
                              a.otc |+| b.otc),
      TradeTemplate(Nil, None, None)
    )
  }
----
Однак це не робить те, що ми бажаємо, оскільки `Monoid[Option[A]]` буде додавати свій вміст, тобто:
[source,scala]
----
  scala> Option(2) |+| None
  res: Option[Int] = Some(2)
  scala> Option(2) |+| Option(1)
  res: Option[Int] = Some(3)
----
в той час, коли ми бажаємо “останній закон перемагає”. Ми можемо перекрити `Monoid[Option[A]]` по замовчанню своїм власним:
[source,scala]
----
  implicit def lastWins[A]: Monoid[Option[A]] = Monoid.instance(
    {
      case (None, None)   => None
      case (only, None)   => only
      case (None, only)   => only
      case (_   , winner) => winner
    },
    None
  )
----
Тепер все компілюється, спробуйте самі…
[source,scala]
----
  scala> import java.time.{LocalDate => LD}
  scala> val templates = List(
           TradeTemplate(Nil,                     None,      None),
           TradeTemplate(Nil,                     Some(EUR), None),
           TradeTemplate(List(LD.of(2017, 8, 5)), Some(USD), None),
           TradeTemplate(List(LD.of(2017, 9, 5)), None,      Some(true)),
           TradeTemplate(Nil,                     None,      Some(false))
         )
  
  scala> templates.foldLeft(zero)(_ |+| _)
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
----
Все що вам треба було зробити, це реалізовати один фрагмент бізнес логіки, та `Monoid` потурбується про све інше за нас!

Зауважте, що список платежів сконкатенований. Це тому, що по замовчанню `Monoid[List]` використовує конкатенацію елементів, та це часто бажана поведінка. Якщо бізнес потреби інші, може бути простим випадком запровадити власний `Monoid[List[LocalDate]]`. Згадайте з Глави 4, що з повним поліморфізмом ми можемо мати іншу реалізацію `append`, в залежності від `E` в `List[E]`, не тільки на основі рантайм класу `List`.

Коли ми ввели типокласу в Главі 4, ми казали, що може бути тільки одна реалізація типкласа для наданого параметра типу, тобто тільки один `Monoid[Option[Boolean]]` в застосуванні. Сирітливі примірники, як `lastWins` є простішим шляхом зруйнувати когерентність.

Ми можемо спробувати виправдати локально зруйновану когерентність типкласів, зробивши `lastWins` приватним, але коли ми дійдемо до типокалсу `Plus`, ми побачимо кращий шлях для реалізації нашого `Monoid`. Коли ми отримаємо теговані типи, ми побачимо навіть кращий спосіб: використовуючи `LastOption` замість `Option` в нашій моделі даних.

Будь-ласка, не ламайте когерентність типокласів самостійно, дітки.

=== 5.3 Об'єктні речі

В главі про дані та функціональність ми казали, що нотація еквівалентності JVM поламана для багатьох речей, що ми можемо покласти до ADT. Проблема в тому, що JVM була розроблена для Java, та `equals` визначений для `java.lang.Object`, чи має це сенс, чи ні. Немає способу видалити `equals`, і немає шляху гарантувати, що він реалізований.

Однак в FP ми обираємо типокласи для поліморфної функціональності, і навіть концепція еквівалентності захоплюється під час компіляції.
[source,scala]
----
  @typeclass trait Equal[F]  {
    @op("===") def equal(a1: F, a2: F): Boolean
    @op("/==") def notEqual(a1: F, a2: F): Boolean = !equal(a1, a2)
  }
----
Замість `===` (потрійна рівність) більш типо-безпечна, ніж `==` (родвійна рівність), оскільки вона може бути скомпільована тільки коли типи ті самі на обох боках порівняння. Це відловлює багато вад.

`equal` має ті самі вимоги до реалізації, що і `Object.equals`
[source,scala]
----
    commutative f1 === f2 implies f2 === f1
    reflexive f === f
    transitive f1 === f2 && f2 === f3 implies f1 === f3
----
Відкидаючи універсальну концепцію `Object.equals`, ми не приймаємо рівність як гарантовану, коли ми конструюємо ADT,зупиняючи нас під час компіляції від очікування еквівалентності, там де її немає.

Продовжуючи тренд заміни старих Java концепцій, замість маючи дані типу `java.lang.Comparable`, тепер вони мають відповідний `Order`:
[source,scala]
----
  @typeclass trait Order[F] extends Equal[F] {
    @op("?|?") def order(x: F, y: F): Ordering
  
    override  def equal(x: F, y: F): Boolean = order(x, y) == Ordering.EQ
    @op("<" ) def lt(x: F, y: F): Boolean = ...
    @op("<=") def lte(x: F, y: F): Boolean = ...
    @op(">" ) def gt(x: F, y: F): Boolean = ...
    @op(">=") def gte(x: F, y: F): Boolean = ...
  
    def max(x: F, y: F): F = ...
    def min(x: F, y: F): F = ...
    def sort(x: F, y: F): (F, F) = ...
  }
  
  sealed abstract class Ordering
  object Ordering {
    case object LT extends Ordering
    case object EQ extends Ordering
    case object GT extends Ordering
  }
----
`Order` реалізує `.equal` в термінах нового примітиву `.order`. Коли типоклас реалізує батьківській примітивний комбінатор з наслідуваним комбінатором, правило заміни для типокласу є додавання. Якщо примірник `Order` перекривав `.equal` з причин продуктивності, він має поводитись ідентично до оригіналу.

Речі, що мають порядок, також можуть бути дескретними, дозволяючи нам крокувати до наступного або попереднього:
[source,scala]
----
  @typeclass trait Enum[F] extends Order[F] {
    def succ(a: F): F
    def pred(a: F): F
    def min: Option[F]
    def max: Option[F]
  
    @op("-+-") def succn(n: Int, a: F): F = ...
    @op("---") def predn(n: Int, a: F): F = ...
  
    @op("|->" ) def fromToL(from: F, to: F): List[F] = ...
    @op("|-->") def fromStepToL(from: F, step: Int, to: F): List[F] = ...
    @op("|=>" ) def fromTo(from: F, to: F): EphemeralStream[F] = ...
    @op("|==>") def fromStepTo(from: F, step: Int, to: F): EphemeralStream[F] = ...
  }

  scala> 10 |--> (2, 20)
  res: List[Int] = List(10, 12, 14, 16, 18, 20)
  
  scala> 'm' |-> 'u'
  res: List[Char] = List(m, n, o, p, q, r, s, t, u)
----
`|-->` є Scalaz Lightsaber. Це синтаксис для Функціонального Програміста. Не таке відволікаюче або довільне як `fromStepToL`. Елегантний синтаксис… для більш цивілізованого віку.

Ми обсудимо `EphemeralStream` в наступній главі, доки нам лише треба знати, що існує потенційно безкінечна структура даних, що уникає проблем затримання пам'яті в `stdlib` `Stream`.

Подібно до `Object.equals`, концепція `.toString` на кожному класі не має сенсу в Java. Ми бажали б примусити рядковість під час компіляції, і це саме те, чого досягає `Show`:
[source,scala]
----
  trait Show[F] {
    def show(f: F): Cord = ...
    def shows(f: F): String = ...
  }
----
Ми будемо досліджувати `Cord` більш детально в главі по типам даних, нам треба тільки знати, що це ефективна структура даних для зберігання та маніпулювання `String`.

=== 5.4 Відображувані речі

Ми сконцентруємось на речах, по яких можна мандрувати та відображувати (робити меппінг), в деякому сенсі:

==== 5.4.1 Functor

[source,scala]
----
  @typeclass trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
  
    def void[A](fa: F[A]): F[Unit] = map(fa)(_ => ())
    def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)] = map(fa)(a => (a, f(a)))
  
    def fpair[A](fa: F[A]): F[(A, A)] = map(fa)(a => (a, a))
    def strengthL[A, B](a: A, f: F[B]): F[(A, B)] = map(f)(b => (a, b))
    def strengthR[A, B](f: F[A], b: B): F[(A, B)] = map(f)(a => (a, b))
  
    def lift[A, B](f: A => B): F[A] => F[B] = map(_)(f)
    def mapply[A, B](a: A)(f: F[A => B]): F[B] = map(f)((ff: A => B) => ff(a))
  }
----
Єдиний абстрактний метод є `map`, і він має робити композицію, тобто меппінг за допомогою `f`, та потім знову за допомогою `g`, це те саме, що одночасне відображення за допомогою композиції `f` та `g`:
[source,scala]
----
  fa.map(f).map(g) == fa.map(f.andThen(g))
----
`map` також має виконувати _no-op_, якщо запроваджена функція є `identity` (`x => x`)
[source,scala]
----
  fa.map(identity) == fa
  
  fa.map(x => x) == fa
----
`Functor` визначає деякі зручні методи навколо `map`, що можуть бути оптимізовані специфічними примірниками. Документація навмисне відсутня в попередніх визначеннях, щоб заохотити до здогадок, що саме робить метод, до того як звернутись до реалізації. Будь ласка, витратьте момент на вивчення тільки сигнатури наступного, перед тим як читати далі:
[source,scala]
----
  def void[A](fa: F[A]): F[Unit]
  def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)]
  
  def fpair[A](fa: F[A]): F[(A, A)]
  def strengthL[A, B](a: A, f: F[B]): F[(A, B)]
  def strengthR[A, B](f: F[A], b: B): F[(A, B)]
  
  // harder
  def lift[A, B](f: A => B): F[A] => F[B]
  def mapply[A, B](a: A)(f: F[A => B]): F[B]
----
* `void` приймає примірник `F[A]`, та завжди повертає `F[Unit]`, він забуває всі значення, при цьому зберігаючи структуру.

* `fproduct` приймає той самий вхід як мапу, але повертає `F[(A, B)]`, тобто він склаладає в тапли вмісту з результатом, застосовуючи функцію. Це корисно, коли ми бажаємо зберігти також вхідні значення.
    
* `fpair` збирає всі елементи `A` в тапл `F[(A, A)]`

* `strengthL` парує вміст `F[B]` з констанотою `A` зліва.

* `strengthR` парує вміст `F[A]` з константою `B` зправа.

* `lift` приймає функцію `A => B`, та повертає `F[A] => F[B]`. Інишими словами, він бере функцію над вмістом `F[A]`, та повертає функцію, що оперує на `F[A]` напряму.

* `mapply` є головоломкою. Скажімо, ми маємо `F[_]` для функцій `A => B`, та деяке значення `A`, тоді ми можемо отримати `F[B]`. Він має сигнатуру, подібну до `pure`, але вимагає від викликаючого запровадити `F[A => B]`.

`fpair`, `strengthL` та `strengthR` виглядають досить непотрібними, але вони корисні, коли ми бажаємо залишити деяку інформацію, що інакше може бути втрачена з поля зору.

`Functor` має деякий особливий синтакс:
[source,scala]
----
  implicit class FunctorOps[F[_]: Functor, A](self: F[A]) {
    def as[B](b: =>B): F[B] = Functor[F].map(self)(_ => b)
    def >|[B](b: =>B): F[B] = as(b)
  }
----
`.as` та `>|` є способом заміни виводу за допомогою констант.

Коли Scalaz провадить додаткову функціональність як синтаксис, скоріше ніж самі типокласи, це так через бінарну сумісність.

Якщо виходить версія Scalaz X.Y.0, неможливо додати методи до типокласів в цій серії релізів для Scala 2.10 та 2.11. Так що має сенс читати обоє, джерело типокласу та його синтаксис.

В нашому прикладі застосування, в якості гидкого хаку (яких ми навіть досі не визнавали), ми визначали `start` та `stop` для повернення їх входів:
[source,scala]
----
  def start(node: MachineNode): F[MachineNode]
  def stop (node: MachineNode): F[MachineNode]
----
Це дозволяє нам писати скорочену бізнес логіку, таку як:
[source,scala]
----
  for {
    _      <- m.start(node)
    update = world.copy(pending = Map(node -> world.time))
  } yield update
----
та
[source,scala]
----
  for {
    stopped <- nodes.traverse(m.stop)
    updates = stopped.map(_ -> world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
----
Але цей хак заштовхує непотрібну складність в реалізації. Буде краще, якщо ми дозволимо нашим алгебрам повертати `F[Unit]` та використовувати `as`:
[source,scala]
----
  m.start(node) as world.copy(pending = Map(node -> world.time))
----
та
[source,scala]
----
  for {
    stopped <- nodes.traverse(a => m.stop(a) as a)
    updates = stopped.map(_ -> world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
----

5.4.2 Foldable
~~~~~~~~~~~~~~
Технічно `Foldable` призначений для структур даних, по яких можна проходити для отримання сумарного значення. Однак це приховує факт, що це одно-типокласова армія, що може запровадити більшість з того, що ви очікуєте побачити в Collections API.

Існує так багато методів, що ми збираємось розбити їх на частини, починаючи з абстрактних методів:
[source,scala]
----
  @typeclass trait Foldable[F[_]] {
    def foldMap[A, B: Monoid](fa: F[A])(f: A => B): B
    def foldRight[A, B](fa: F[A], z: =>B)(f: (A, =>B) => B): B
    def foldLeft[A, B](fa: F[A], z: B)(f: (B, A) => B): B = ...
----
Примірник `Foldable` має реалізувати тільки `foldMap` та `foldRight`, щоб отримати всю функціональність цього типокласу, хоча методи типово оптимізовані для специфічних структур даних.

* `.foldMap` має маркетингове ім'я: `MapReduce`. Беручи `F[A]`, функцію від `A` до `B`, та спосіб комбінувати `B` (запроваджену в `Monoid`,разом з `zero` `B`), ми можемо спродукувати сумарне значення типу `B`. Немає жодного примусу щодо порядку операцій, що дозволяє паралельне виконання.

* `foldRight` не вимагає, щоб його параметри мали `Monoid`, що означає, що він потребує стартове значення `z`, та спосіб комбінувати кожний елемент даних в структурі даних з сумарним значенням. Порядок для обходу елементів зправа наліво, і, таким чином, він не може бути розпаралелений.

`foldRight` концептуально те саме, що і `foldRight` в Scala `stdlib`. Однак існує проблема з сигнатурою `stdlib` `foldRight`, вирішена в Scalaz: дуже великі структури даних можуть переповнити стек. `List.foldRight` махлює, реалізуючи `foldRight` як реверсований `foldLeft`:
[source,scala]
----
  override def foldRight[B](z: B)(op: (A, B) => B): B =
    reverse.foldLeft(z)((right, left) => op(left, right))
----
але концепція реверсу не є універсальною, та цей обхідний шлях не може бути використаний для всіх структур даних. Скажімо, ми бажаємо знайти мале число в `Stream`, з ранішним виходом:
[source,scala]
----
  scala> def isSmall(i: Int): Boolean = i < 10
  scala> (1 until 100000).toStream.foldRight(false) {
           (el, acc) => isSmall(el) || acc
         }
  java.lang.StackOverflowError
    at scala.collection.Iterator.toStream(Iterator.scala:1403)
    ...
----
Scalaz вирішує цю проблему, беручи параметр за ім'ям для значення агрегату:
[source,scala]
----
  scala> (1 |=> 100000).foldRight(false)(el => acc => isSmall(el) || acc )
  res: Boolean = true
----
що означає, що `acc` не обчислюється, доки він не буде потрібний.

Корисно мати на увазі, що не всі операції стеко-безпечні в `foldRight`. Якщо ми запитаємо обчислення всіх елементів, ми також можемо отримати `StackOverflowError` зі Scalaz `EphemeralStream`:
[source,scala]
----
  scala> (1L |=> 100000L).foldRight(0L)(el => acc => el |+| acc )
  java.lang.StackOverflowError
    at scalaz.Foldable.$anonfun$foldr$1(Foldable.scala:100)
    ...
----

* `foldLeft` проходить по елементах зліва направо. `foldLeft` може бути реалізований в термінах `foldMap`, але більшість примірників обирають реалізувати його, бо це дуже базова операція. Оскільки він звичайно реалізований за допомогою хвостової рекурсії, тут нема параметрів за ім'ям.

Єдине правило для `Foldable` в тому, що `foldLeft` та `foldRight` повинні кожний бути сумісним з `foldMap` для моноїдних операцій. Тобто додавати елемент до списку для `foldLeft`, та передставляти елемент перед списком для `foldRight`. Однак `foldLeft` та `foldRight` не мають бути сумісними один з одним: фактично, вони часто продукують реверс один одного.

Простіша річ, що можна зробити з `foldMap`, це використати функцію `identity`, даючи `fold` (природна сума моноїдальних елементів), з лівими/правими варівантами, щоб дозволити вибір на основі критерів продуктивності:
[source,scala]
----
  def fold[A: Monoid](t: F[A]): A = ...
  def sumr[A: Monoid](fa: F[A]): A = ...
  def suml[A: Monoid](fa: F[A]): A = ...
----
Згадавши що ми навчились про `Monoid`, ми запишемо таке:
[source,scala]
----
  scala> templates.foldLeft(Monoid[TradeTemplate].zero)(_ |+| _)
----
Тепер ми знаємо, що це дурня, і ми маємо писати так:
[source,scala]
----
  scala> templates.toIList.fold
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
----
`.fold` не робить з `stdlib List`, оскільки він вже має метод з назвою `fold`, що вже робить свої власні речі в свій власний спосіб.

Дивно названий `intercalate` всатавляє специфічний `A` між кожним елементом, перед тим, як виконати `fold`:
[source,scala]
----
  def intercalate[A: Monoid](fa: F[A], a: A): A = ...
----
що є узагальненою версією `stdlib mkString`:
[source,scala]
----
  scala> List("foo", "bar").intercalate(",")
  res: String = "foo,bar"
----
`foldLeft` провадить механізм отримання кожного елементу через індекс доступу, включаючи декілька інших пов'язаних методів:
[source,scala]
----
  def index[A](fa: F[A], i: Int): Option[A] = ...
  def indexOr[A](fa: F[A], default: =>A, i: Int): A = ...
  def length[A](fa: F[A]): Int = ...
  def count[A](fa: F[A]): Int = length(fa)
  def empty[A](fa: F[A]): Boolean = ...
  def element[A: Equal](fa: F[A], a: A): Boolean = ...
----
Scalaz є чистою бібліотекою для тільки загальних функцій. Коли `List(0)` може закидати виключення, `Foldable.index` повертає `Option[A]` зі зручним `.indexOr`, що повертає A коли надане значення по замовчанню. `.element` подібний до `stdlib` `.contains`, але використовує `Equal` замість хворобливо-визначеного JVM `equality`.

Ці методи насправді виглядають як API колекцій. Та, звичайно, все з `Foldable` може бути перетворено на `List`:
[source,scala]
----
  def toList[A](fa: F[A]): List[A] = ...
----
Також є перетворення до інших `stdlib` та `Scalaz` типів даних, таких як `.toSet`, `.toVector`, `.toStream`, `.to[T <: TraversableLike]`, `.toIList` і так далі.

В наявності корисні перевірки предикатів:
[source,scala]
----
  def filterLength[A](fa: F[A])(f: A => Boolean): Int = ...
  def all[A](fa: F[A])(p: A => Boolean): Boolean = ...
  def any[A](fa: F[A])(p: A => Boolean): Boolean = ...
----

`filterLength` це спосіб підрахувати, як багато елементів `true` для предиката, `all` та `any` повертають `true`, якщо всі (або любий) елементи задовільняють предикату, та можуть виходити рано.

Ми бачили `NonEmptyList` в попередніх главах. Для краткості ми використовували псевдоним типу `Nel` замість `NonEmptyList`.

Також в попередніх главах ми бачили `IList`, згадайте, що це альтернатива до `stdlib` `List` з видаленими нечистими методами, як `apply`.

Ми можемо розділити `F[A]` на частини, чий результат буде те саме `B`, за допомогою `splitBy`:
[source,scala]
----
  def splitBy[A, B: Equal](fa: F[A])(f: A => B): IList[(B, Nel[A])] = ...
  def splitByRelation[A](fa: F[A])(r: (A, A) => Boolean): IList[Nel[A]] = ...
  def splitWith[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...
  def selectSplit[A](fa: F[A])(p: A => Boolean): List[Nel[A]] = ...
  
  def findLeft[A](fa: F[A])(f: A => Boolean): Option[A] = ...
  def findRight[A](fa: F[A])(f: A => Boolean): Option[A] = ...
----
наприклад:
[source,scala]
----
  scala> IList("foo", "bar", "bar", "faz", "gaz", "baz").splitBy(_.charAt(0))
  res = [(f, [foo]), (b, [bar, bar]), (f, [faz]), (g, [gaz]), (b, [baz])]
----
зауважте, що є два значення, індексовані через `'b'`.

`splitByRelation` уникає потреби для `Equal`, але ми маємо запровадити оператор порівняння.

`splitWith` розділяє елементи на групи, що або задовільняють предикату, або ні. `selectSplit` обирає групи елементів, що задовільняють предикату, відкидаючи інші. Це один з тих рідких випадків, коли два методи поділяють ту саму сигнатуру типів, але мають різне значення.

`findLeft` та `findRight` перший елемент зліва або зправа, відповідно, що задовільняє предикату.

Надалі використовуючи `Equal` та `Order`, ми маємо окремі мектоди, що повертають групування.
[source,scala]
----
  def distinct[A: Order](fa: F[A]): IList[A] = ...
  def distinctE[A: Equal](fa: F[A]): IList[A] = ...
  def distinctBy[A, B: Equal](fa: F[A])(f: A => B): IList[A] =
----
`distinct` реалізований більш ефективно, ніж `distinctE`, оскільки він може використовувати впорядкування, і таким чином використовувати алгоритм швидкого сортування, що значно швидший, ніж природний `stdlib` `List.distinct`. Структури даних (такі як множини) можуть реалізувати `distinct` в своєму `Foldable` без виконання жодної роботи.

`distinctBy` дозволяє груаування по результату застосування функції до елементів. Наприклад, групувати імена по першій літері.

Ми можемо надалі використовувати `Order` через виділення мінімального або максимального елементів (або обоє екстремуми), включаючи різні використання шаблону `Of` або `By` до першої мапи до іншого типу, або для використання іншого типу для виконання порівняння впорядкування.
[source,scala]
----
  def maximum[A: Order](fa: F[A]): Option[A] = ...
  def maximumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def maximumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...
  
  def minimum[A: Order](fa: F[A]): Option[A] = ...
  def minimumOf[A, B: Order](fa: F[A])(f: A => B): Option[B] = ...
  def minimumBy[A, B: Order](fa: F[A])(f: A => B): Option[A] = ...
  
  def extrema[A: Order](fa: F[A]): Option[(A, A)] = ...
  def extremaOf[A, B: Order](fa: F[A])(f: A => B): Option[(B, B)] = ...
  def extremaBy[A, B: Order](fa: F[A])(f: A => B): Option[(A, A)] =
----
Наприклад, ми можемо запитати, який рядок `String` є максимальним `By` довжині, або яка максимальна довжина `Of` елементів.
[source,scala]
----
  scala> List("foo", "fazz").maximumBy(_.length)
  res: Option[String] = Some(fazz)
  
  scala> List("foo", "fazz").maximumOf(_.length)
  res: Option[Int] = Some(4)
----
Це підсумовує ключові властивості `Foldable`. Вивод такий, що будь-що, що ми очікуємо знайти в бібліотеці колекцій, можливо є в `Foldable`, та якщо ні, воно мало б там бути.

Ми завершимо деякими варіаціями методів, що ми вже бачили. Зпочатку це методи, що приймають `Semigroup` замість `Monoid`:
[source,scala]
----
  def fold1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def foldMap1Opt[A, B: Semigroup](fa: F[A])(f: A => B): Option[B] = ...
  def sumr1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def suml1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  ...
----
та повертає `Option`, щоб прийняти до уваги порожні структури даних (згадайте, що `Semigroup` не має нуля).

Методи читаються “1-Option”, не _10 pt_ як в типографіці.

Типоклас `Foldable1` містить значно більше `Semigroup` варіантів для `Monoid` методів, показаних тут (всі з суфіксом 1), та мають сенс для структур, що ніколи не порожні, без вимоги бути `Monoid` від елементів.

Важливо, що існують варіанти, що приймають манадичні значення повернення. Ми вже використовували `foldLeftM`, коли ми зпочатку писали бізнес логіку для нашого застосування, і тепер ми знаємо, що це походить від `Foldable`:
[source,scala]
----
  def foldLeftM[G[_]: Monad, A, B](fa: F[A], z: B)(f: (B, A) => G[B]): G[B] = ...
  def foldRightM[G[_]: Monad, A, B](fa: F[A], z: =>B)(f: (A, =>B) => G[B]): G[B] = ...
  def foldMapM[G[_]: Monad, A, B: Monoid](fa: F[A])(f: A => G[B]): G[B] = ...
  def findMapM[M[_]: Monad, A, B](fa: F[A])(f: A => M[Option[B]]): M[Option[B]] = ...
  def allM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
  def anyM[G[_]: Monad, A](fa: F[A])(p: A => G[Boolean]): G[Boolean] = ...
  ...
----

5.4.3 Traverse
~~~~~~~~~~~~~~
`Traverse` це те, що відбувається, коли ми зкрестимо `Functor` з `Foldable`:
[source,scala]
----
  trait Traverse[F[_]] extends Functor[F] with Foldable[F] {
    def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]
    def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] = ...
  
    def reverse[A](fa: F[A]): F[A] = ...
  
    def zipL[A, B](fa: F[A], fb: F[B]): F[(A, Option[B])] = ...
    def zipR[A, B](fa: F[A], fb: F[B]): F[(Option[A], B)] = ...
    def indexed[A](fa: F[A]): F[(Int, A)] = ...
    def zipWithL[A, B, C](fa: F[A], fb: F[B])(f: (A, Option[B]) => C): F[C] = ...
    def zipWithR[A, B, C](fa: F[A], fb: F[B])(f: (Option[A], B) => C): F[C] = ...
  
    def mapAccumL[S, A, B](fa: F[A], z: S)(f: (S, A) => (S, B)): (S, F[B]) = ...
    def mapAccumR[S, A, B](fa: F[A], z: S)(f: (S, A) => (S, B)): (S, F[B]) = ...
  }
----
На початку цієї глави ми показали важливість `traverse` та `sequence` для перестановки конструкторів типу щоб задовільнити вимогам (тобто, `List[Future[\_]]` на `Future[List[_]]`).

В `Foldable` ми не змогли переконатись, що `reverse` було універсальною концепцією, але тепер ми можемо обертати речі.

Ми також можемо поєднати разом дві речі, що мають `Traverse`, отримуючи `None`, коли одна сторона вичерпає свої елементи, використовуючи `zipL` або `zipR`, щоб знати, з якого боку урізати, коли довжина не співпадає. Особливий різновид `zip` є додавання індексу до кожного індексованого елементу.

`zipWithL` та `zipWithR` дозволяють комбінувати обоє частини в новий тип, та потім повертати як `F[C]`.

`mapAccumL` та `mapAccumR` є регулярні мапи, скомбіновані з аккумулятором. Якщо за старими способами Java ми мали звернутись до `var`, та посилатись до неї з `map`, нам слідувало б використовувати `mapAccumL`.

Наприклад, скажімо ми маємо список слів, та ми бажаємо відкидати слова, які ми бачили. Алгоритму фільтрації не дозволяється обробляти список слів другий раз, так що він може бути маштабований до необмеженого потоку:
[source,scala]
----
  scala> val freedom =
  """We campaign for these freedoms because everyone deserves them.
     With these freedoms, the users (both individually and collectively)
     control the program and what it does for them."""
     .split("\\s+")
     .toList
  
  scala> def clean(s: String): String = s.toLowerCase.replaceAll("[,.()]+", "")
  
  scala> freedom
         .mapAccumL(Set.empty[String]) { (seen, word) =>
           val cleaned = clean(word)
           (seen + cleaned, if (seen(cleaned)) "_" else word)
         }
         ._2
         .intercalate(" ")
  
  res: String =
  """We campaign for these freedoms because everyone deserves them.
     With _ _ the users (both individually and collectively)
     control _ program _ what it does _ _"""
----
Нарешті `Traverse1`, як `Foldable1`, провадить варіанти ціх методів для структур даних, що не можуть бути порожніми, отримуючи доступ до слабшої `Semigroup` замість `Monoid`, та `Apply` замість `Applicative`. Згадайте, що `Semigroup` не має провадити `.empty`, та `Apply` не має провадити `.point`.

5.4.4 Align
~~~~~~~~~~~
`Align` це щодо злиття та вирівнювання всього за допомогою `Functor`. Перед розглядом `Align`, ознайомтесь з типом даних `\&/`  (читається як `These`, або `hurray!`).
[source,scala]
----
  sealed abstract class \&/[+A, +B]
  final case class This[A](aa: A) extends (A \&/ Nothing)
  final case class That[B](bb: B) extends (Nothing \&/ B)
  final case class Both[A, B](aa: A, bb: B) extends (A \&/ B)
----
тобто, це дані, що закодовні через включне логічне `OR`. `A` або `B`, або обоє, `A` та `B`.
[source,scala]
----
  @typeclass trait Align[F[_]] extends Functor[F] {
    def alignWith[A, B, C](f: A \&/ B => C): (F[A], F[B]) => F[C]
    def align[A, B](a: F[A], b: F[B]): F[A \&/ B] = ...
  
    def merge[A: Semigroup](a1: F[A], a2: F[A]): F[A] = ...
  
    def pad[A, B]: (F[A], F[B]) => F[(Option[A], Option[B])] = ...
    def padWith[A, B, C](f: (Option[A], Option[B]) => C): (F[A], F[B]) => F[C] = ...
----
`alignWith` приймає функцію від `A` або `B` (або обох) до C, та повертає підважену функціє від тапла `F[A]` та `F[B]` до `F[C]`. `align` конструює `\&/` з двох `F[_]`.

`merge` дозволяє нам комбінувати два `F[A]`, коли `A` має `Semigroup`. Наприклад, реалізація `Semigroup[Map[K, V]]` збігається до `Semigroup[V]`, комбінуючи два результата елементів в комбінуванні їх значень, і як слідоцтво є те, що `Map[K, List[A]]` поводиться як мульти-меппінг:
[source,scala]
----
  scala> Map("foo" -> List(1)) merge Map("foo" -> List(1), "bar" -> List(2))
  res = Map(foo -> List(1, 1), bar -> List(2))
----
та `Map[K, Int]` просто приводить у відповідність свій вміст під час злиття:
[source,scala]
----
  scala> Map("foo" -> 1) merge Map("foo" -> 1, "bar" -> 2)
  res = Map(foo -> 2, bar -> 2)
----
`.pad` та `.padWith` призначені для часткового злиття структур даних, що можуть не мати відповідного елементу з одного боку. Наприклад, якщо ви бажаєте аргегувати неазлежні голоси, та залишити інформацію, звідки походять ці голоси:
[source,scala]
----
  scala> Map("foo" -> 1) pad Map("foo" -> 1, "bar" -> 2)
  res = Map(foo -> (Some(1),Some(1)), bar -> (None,Some(2)))
  
  scala> Map("foo" -> 1, "bar" -> 2) pad Map("foo" -> 1)
  res = Map(foo -> (Some(1),Some(1)), bar -> (Some(2),None))
----
Існують зручні варіанти `align`, що використовують структуру `\&/`:
[source,scala]
----
  ...
    def alignSwap[A, B](a: F[A], b: F[B]): F[B \&/ A] = ...
    def alignA[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
    def alignB[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
    def alignThis[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
    def alignThat[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
    def alignBoth[A, B](a: F[A], b: F[B]): F[Option[(A, B)]] = ...
  }
----
що має сенс, дивлячись на сигнатури типів. Приклади:
[source,scala]
----
  scala> List(1,2,3) alignSwap List(4,5)
  res = List(Both(4,1), Both(5,2), That(3))
  
  scala> List(1,2,3) alignA List(4,5)
  res = List(Some(1), Some(2), Some(3))
  
  scala> List(1,2,3) alignB List(4,5)
  res = List(Some(4), Some(5), None)
  
  scala> List(1,2,3) alignThis List(4,5)
  res = List(None, None, Some(3))
  
  scala> List(1,2,3) alignThat List(4,5)
  res = List(None, None, None)
  
  scala> List(1,2,3) alignBoth List(4,5)
  res = List(Some((1,4)), Some((2,5)), None)
----
Зауважте, що варіанти `A` та `B` використовують включне `OR`, тоді як варіанти `This` та `That` виключні,  повертаючи `None`, якщо значення з обох боків, або коли немає значення з жодного боку.

5.5 Variance
~~~~~~~~~~~~
Ми маємо на мить повернутись до `Functor`, та обсудити наслідника, якого ми досі ігнорували:

`InvariantFunctor`,також відомий як еспоненціальний функтор, має метод `xmap`, що каже, що маючи функцію від `A` до `B`, та функцію від `B` до `A`, ми можемо конвертувати `F[A]` на `F[B]`.

`Functor` є скорочене ім'я для того, що мало б називатись коваріантним функтором. Але завдяки тому, що `Functor` такий популярний, він отримав своє ім'я. Подібно до цього, `Contravariant` мав би називатись контрваріантним функтором.

Функтор реалізує `xmap` через `map`, та ігнорує функцію від `B` до `A`. `Contravariant`, з іншого боку, реалізує `xmap` через `contramap`, та ігнорує функцію від `A` до `B`:
[source,scala]
----
  @typeclass trait InvariantFunctor[F[_]] {
    def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B]
    ...
  }
  
  @typeclass trait Functor[F[_]] extends InvariantFunctor[F] {
    def map[A, B](fa: F[A])(f: A => B): F[B]
    def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B] = map(fa)(f)
    ...
  }
  
  @typeclass trait Contravariant[F[_]] extends InvariantFunctor[F] {
    def contramap[A, B](fa: F[A])(f: B => A): F[B]
    def xmap[A, B](fa: F[A], f: A => B, g: B => A): F[B] = contramap(fa)(g)
    ...
  }
----
Важливо зауважити, що хоча пов'язані на теоретичному рівні, слова коваріантний, контрваріантний та інваріантний напряму не посилаються на варіантність типів Scala (тобто, префікси `+` та `-`, що можуть додаватись до сигнатур). Інваріантність тут означає, що можливо відобразити вміст структури `F[A]` в `F[B]`. Використовуючи `identity` ми можемо бачити, що `A` може бути безпечно перетворено вверх або вниз в `B`, в залежності від варіантності функтора.

`.map` можна зрозуміти через його контракт: “якщо ви дасте мені `F` від `A`, та шлях перетворити `A` в B, тоді я можу дати вам `F` від `B”`.

Подібно до цього, `.contramap` читається як: “якщо ви дасте мені `F` від `A`, та спосіб перетворити `B` в `A`, тоді я зможу дати вам `F` від B”.

Розглянемо приклад: в нашому застосуванні ми вводимо домен-специфічні типи: `Alpha`, `Beta`, `Gamma`, тощо, щоб переконатись, що ми не змішуємо числа з фінансовими обчисленнями:
[source,scala]
----
  final case class Alpha(value: Double)
----
але тепер ми стикаємось з проблемою, що ми не маємо жодних типокласів для ціх нових типів. Якщо ми використовуємо значення в JSON документах, ми маємо записати примірники `JsEncoder` та `JsDecoder`.

Однак `JsEncoder` має `Contravariant`, та `JsDecoder` має `Functor`, так що ми можемо вивести примірники. Складемо контракт:

    “якщо ви дасте мені `JsDecoder` для `Double`, і спосіб перейти від `Double` до `Alpha`, тоді я зможу дати вам `JsDecoder` для `Alpha`”.
    “якщо ви дасте мені `JsEncoder` для `Double`, і спосіб перейти від `Alpha` до `Double`, тоді я зможу дати вам `JsEncoder` для `Alpha`”.
[source,scala]
----
  object Alpha {
    implicit val decoder: JsDecoder[Alpha] = JsDecoder[Double].map(Alpha(_))
    implicit val encoder: JsEncoder[Alpha] = JsEncoder[Double].contramap(_.value)
  }
----
Методи на типокласах можуть мати свої параметри типів в контрваріантних позиціях (параметри методів) або в коваріантній позиції (тип повернення). Якщо типоклас має комбінацію коваріантних та контрваріантних позицій, він може мати інваріантний функтор. Наприклад, `Semigroup` та `Monoid` мають `InvariantFunctor`, але не `Functor` або `Contravariant`.

=== 5.6 Apply та Bind

Розглянемо цей акт розігріву до `Applicative` та `Monad`

==== 5.6.1 Apply

`Apply` розширює `Functor` через додавання метода на ім'я `ap`, що подібний до `map` в тому, що він застосовує функцію до значень. Однак з допомогою `ap` функція в тому ж контексті, що і значення.
[source,scala]
----
  @typeclass trait Apply[F[_]] extends Functor[F] {
    @op("<*>") def ap[A, B](fa: =>F[A])(f: =>F[A => B]): F[B]
    ...
----
`<*>` це Advanced TIE Fighter, на якому літав Дарт Вейдер. Це відповідає справам, бо виглядає як суворий предок. Або як сумний Пікачу.

Має сенс спіймати момент, та розглянути, що це означає для простої структури даних, як `Option[A]`, маючи наступну реалізацію `.ap`:
[source,scala]
----
  implicit def option[A]: Apply[Option[A]] = new Apply[Option[A]] {
    override def ap[A, B](fa: =>Option[A])(f: =>Option[A => B]) = f match {
      case Some(ff) => fa.map(ff)
      case None    => None
    }
    ...
  }
----
Щоб реалізувати `.ap`, спочатку ми маємо виділити функцію `ff: A => B` з `f: Option[A => B]`, потім ми можемо зробити `map` на `fa`. Виділення функції з контексту є важливою силою, що привносить `Apply`, дозволяючи декільком функціям бути скомбінованими всередині контексту.

Повертаючись до `Apply`, ми знаходимо шаблонний `.applyX`, що дозволяє нам комбінувати паралельні функції, та потім робити `map` по їх комбінованому виходу:
[source,scala]
----
  @typeclass trait Apply[F[_]] extends Functor[F] {
    ...
    def apply2[A,B,C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C): F[C] = ...
    def apply3[A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: (A,B,C) =>D): F[D] = ...
    ...
    def apply12[...]
----

Читайте `.apply2` як контракт, що обіцяє: “якщо ви дасте мені `F` від `A`, та потім `F` від `B`, разом зі шляхом комбінувати `A` та `B` в `C`, тоді я зможу дати вам `F` для `C`”. Існує багато використань для цього контракту, та два найбільш важливі:

    конструювання деяких типокласів для типу продукта `C` зі складаючих його `A` та `B`

    виконання ефектів паралельно, як алгебри дронів та google, що ми створили в Главі 3, та потім комбінувати їх результати.

Дійсно, `Apply` є такий корисний, що він має власний синтаксис:
[source,scala]
----
  implicit class ApplyOps[F[_]: Apply, A](self: F[A]) {
    def *>[B](fb: F[B]): F[B] = Apply[F].apply2(self,fb)((_,b) => b)
    def <*[B](fb: F[B]): F[A] = Apply[F].apply2(self,fb)((a,_) => a)
    def |@|[B](fb: F[B]): ApplicativeBuilder[F, A, B] = ...
  }
  
  class ApplicativeBuilder[F[_]: Apply, A, B](a: F[A], b: F[B]) {
    def tupled: F[(A, B)] = Apply[F].apply2(a, b)(Tuple2(_))
    def |@|[C](cc: F[C]): ApplicativeBuilder3[C] = ...
  
    sealed abstract class ApplicativeBuilder3[C](c: F[C]) {
      ..ApplicativeBuilder4
        ...
          ..ApplicativeBuilder12
  }
----
що є саме те, що ми використовували в Главі 3:
[source,scala]
----
  (d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)
----
Оператор `|@|` має багато назв. Дехто називає це Синтаксисом Декартового Добутку, інші називають це Тістечко з Корицею, Адмірал Акбар або Макулай Калкін. Ми схиляємось до назви оператор Крик (The Scream), за картиною Едварда Мунка, оскільки це також звук, що видає CPU, коли він паралелізує Все Речі Разом.

Синтаксис `<*` та `*>` (ліва та права пташка) надає зручний спосіб ігнорувати вивід одного з двох паралельних ефектів.

Нажаль, хоча синтаксис `|@|` чистий, є проблема в тому, що новий об'єкт `ApplicativeBuilder` розміщується для кожного додаткового ефекта. Якщо робота прив'язана до I/O, варітсть розміщення пам'яті незначна. Але якщо робота пов'язана з навантаженням CPU використовуйте альтернативний ліфтінг з синтаксисом арності, що не продукує жодних додаткових об'єктів-посередників:
[source,scala]
----
  def ^[F[_]: Apply,A,B,C](fa: =>F[A],fb: =>F[B])(f: (A,B) =>C): F[C] = ...
  def ^^[F[_]: Apply,A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: (A,B,C) =>D): F[D] = ...
  ...
  def ^^^^^^[F[_]: Apply, ...]
----
використовується як:
[source,scala]
----
  ^^^^(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
----
або напряму викликайте `applyX`:
[source,scala]
----
  Apply[F].apply5(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
----
Не дивлячись на більш загальне використання з ефектами, `Apply` також гарно робить зі структурами даних. Розгляньте переписування
[source,scala]
----
  for {
    foo <- data.foo: Option[String]
    bar <- data.bar: Option[Int]
  } yield foo + bar.shows
----
як
[source,scala]
----
  (data.foo |@| data.bar)(_ + _.shows)
----
Якщо ви бажаєте комбінований вивід як тапл, саме для цього існує метод:
[source,scala]
----
  @op("tuple") def tuple2[A,B](fa: =>F[A],fb: =>F[B]): F[(A,B)] = ...
  def tuple3[A,B,C](fa: =>F[A],fb: =>F[B],fc: =>F[C]): F[(A,B,C)] = ...
  ...
  def tuple12[...]

  (data.foo tuple data.bar) : Option[(String, Int)]
----
Також є узагальнені версії `ap` для більш ніж двох параметрів:
[source,scala]
----
  def ap2[A,B,C](fa: =>F[A],fb: =>F[B])(f: F[(A,B) => C]): F[C] = ...
  def ap3[A,B,C,D](fa: =>F[A],fb: =>F[B],fc: =>F[C])(f: F[(A,B,C) => D]): F[D] = ...
  ...
  def ap12[...]
----
разом з методами `.lift`, що приймають звичайні функції, да підіймають їх в контекст `F[_]`, узагальнення `Functor.lift`:
[source,scala]
----
  def lift2[A,B,C](f: (A,B) => C): (F[A],F[B]) => F[C] = ...
  def lift3[A,B,C,D](f: (A,B,C) => D): (F[A],F[B],F[C]) => F[D] = ...
  ...
  def lift12[...]
----
та `.apF`, частково застосований синтаксис для `ap`:
[source,scala]
---- 
  def apF[A,B](f: =>F[A => B]): F[A] => F[B] = ...
----

Нарешті `.forever`
[source,scala]
----
  def forever[A, B](fa: F[A]): F[B] = ...
----
повторює ефект без зупинки. Примірник `Apply` має бути стеко-безпечним, або ми отримаємо `StackOverflowError`.

5.6.2 Bind
~~~~~~~~~~
`Bind` вводить `.bind`, синонімічний з `.flatMap`, що дозволяє функції на результатах ефектів, що повертають новий ефект, або функції на значеннях структури даних, що повертатимуть нові структури, що потім поєднуються.
[source,scala]
----
  @typeclass trait Bind[F[_]] extends Apply[F] {
  
    @op(">>=") def bind[A, B](fa: F[A])(f: A => F[B]): F[B]
    def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B] = bind(fa)(f)
  
    override def ap[A, B](fa: =>F[A])(f: =>F[A => B]): F[B] =
      bind(f)(x => map(fa)(x))
    override def apply2[A, B, C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C): F[C] =
      bind(fa)(a => map(fb)(b => f(a, b)))
  
    def join[A](ffa: F[F[A]]): F[A] = bind(ffa)(identity)
  
    def mproduct[A, B](fa: F[A])(f: A => F[B]): F[(A, B)] = ...
    def ifM[B](value: F[Boolean], t: =>F[B], f: =>F[B]): F[B] = ...
  
  }
----
`.join` може бути знайомий до користувачів `.flatten` в `stdlib`, він приймає вкладений контекст, та зплющує його в один.

Наслідувані комбінатори введені для `.ap` та `.apply2`, що потребує узгодженості з `.bind`. Ми побачимо пізніше, що це правило має наслідки для стратегій паралелізації.

mproduct is like Functor.fproduct and pairs the function’s input with its output, inside the F.

ifM is a way to construct a conditional data structure or effect:

  scala> List(true, false, true).ifM(List(0), List(1, 1))
  res: List[Int] = List(0, 1, 1, 0)

ifM and ap are optimised to cache and reuse code branches, compare to the longer form

  scala> List(true, false, true).flatMap { b => if (b) List(0) else List(1, 1) }

which produces a fresh List(0) or List(1, 1) every time the branch is invoked.

These kinds of optimisations are possible in FP because all methods are deterministic, also known as referentially transparent.

If a method returns a different value every time it is called, it is impure and breaks the reasoning and optimisations that we can otherwise make.

If the F is an effect, perhaps one of our drone or Google algebras, it does not mean that the output of the call to the algebra is cached. Rather the reference to the operation is cached. The performance optimisation of ifM is only noticeable for data structures, and more pronounced with the difficulty of the work in each branch.

We will explore the concept of determinism and value caching in more detail in the next chapter.

Bind also has some special syntax

  implicit class BindOps[F[_]: Bind, A] (self: F[A]) {
    def >>[B](b: =>F[B]): F[B] = Bind[F].bind(self)(_ => b)
    def >>![B](f: A => F[B]): F[A] = Bind[F].bind(self)(a => f(a).map(_ => a))
  }

>> is when we wish to discard the input to bind and >>! is when we want to run an effect but discard its output.
5.7 Applicative and Monad

From a functionality point of view, Applicative is Apply with a pure method, and Monad extends Applicative with Bind.

  @typeclass trait Applicative[F[_]] extends Apply[F] {
    def point[A](a: =>A): F[A]
    def pure[A](a: =>A): F[A] = point(a)
  }
  
  @typeclass trait Monad[F[_]] extends Applicative[F] with Bind[F]

In many ways, Applicative and Monad are the culmination of everything we’ve seen in this chapter. .pure (or .point as it is more commonly known for data structures) allows us to create effects or data structures from values.

Instances of Applicative must meet some laws, effectively asserting that all the methods are consistent:

    Identity: fa <*> pure(identity) === fa, (where fa is an F[A]) i.e. applying pure(identity) does nothing.
    Homomorphism: pure(a) <*> pure(ab) === pure(ab(a)) (where ab is an A => B), i.e. applying a pure function to a pure value is the same as applying the function to the value and then using pure on the result.
    Interchange: pure(a) <*> fab === fab <*> pure(f => f(a)), (where fab is an F[A => B]), i.e. pure is a left and right identity
    Mappy: map(fa)(f) === fa <*> pure(f)

Monad adds additional laws:

    Left Identity: pure(a).bind(f) === f(a)
    Right Identity: a.bind(pure(_)) === a
    Associativity: fa.bind(f).bind(g) === fa.bind(a => f(a).bind(g)) where fa is an F[A], f is an A => F[B] and g is a B => F[C].

Associativity says that chained bind calls must agree with nested bind. However, it does not mean that we can rearrange the order, which would be commutativity. For example, recalling that flatMap is an alias to bind, we cannot rearrange

  for {
    _ <- machine.start(node1)
    _ <- machine.stop(node1)
  } yield true

as

  for {
    _ <- machine.stop(node1)
    _ <- machine.start(node1)
  } yield true

start and stop are non-commutative, because the intended effect of starting then stopping a node is different to stopping then starting it!

But start is commutative with itself, and stop is commutative with itself, so we can rewrite

  for {
    _ <- machine.start(node1)
    _ <- machine.start(node2)
  } yield true

as

  for {
    _ <- machine.start(node2)
    _ <- machine.start(node1)
  } yield true

which are equivalent for our algebra, but not in general. We’re making a lot of assumptions about the Google Container API here, but this is a reasonable choice to make.

A practical consequence is that a Monad must be commutative if its applyX methods can be allowed to run in parallel. We cheated in Chapter 3 when we ran these effects in parallel

  (d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)

because we know that they are commutative among themselves. When it comes to interpreting our application, later in the book, we will have to provide evidence that these effects are in fact commutative, or an asynchronous implementation may choose to sequence the operations to be on the safe side.

The subtleties of how we deal with (re)-ordering of effects, and what those effects are, deserves a dedicated chapter on Advanced Monads.
5.8 Divide and Conquer

Divide is the Contravariant analogue of Apply

  @typeclass trait Divide[F[_]] extends Contravariant[F] {
    def divide[A, B, C](fa: F[A], fb: F[B])(f: C => (A, B)): F[C] = divide2(fa, fb)(f)
  
    def divide1[A1, Z](a1: F[A1])(f: Z => A1): F[Z] = ...
    def divide2[A, B, C](fa: F[A], fb: F[B])(f: C => (A, B)): F[C] = ...
    ...
    def divide22[...] = ...

divide says that if we can break a C into an A and a B, and we’re given an F[A] and an F[B], then we can get an F[C]. Hence, divide and conquer.

This is a great way to generate contravariant typeclass instances for product types by breaking the products into their parts. Scalaz has an instance of Divide[Equal], let’s construct an Equal for a new product type Foo

  scala> case class Foo(s: String, i: Int)
  scala> implicit val fooEqual: Equal[Foo] =
           Divide[Equal].divide2(Equal[String], Equal[Int]) {
             (foo: Foo) => (foo.s, foo.i)
           }
  scala> Foo("foo", 1) === Foo("bar", 1)
  res: Boolean = false

Mirroring Apply, Divide also has terse syntax for tuples. A softer divide so that we may reign approach to world domination:

  ...
    def tuple2[A1, A2](a1: F[A1], a2: F[A2]): F[(A1, A2)] = ...
    ...
    def tuple22[...] = ...
  }

Generally, if encoder typeclasses can provide an instance of Divide, rather than stopping at Contravariant, it makes it possible to derive instances for any case class. Similarly, decoder typeclasses can provide an Apply instance. We will explore this in a dedicated chapter on Typeclass Derivation.

Divisible is the Contravariant analogue of Applicative and introduces .conquer, the equivalent of .pure

  @typeclass trait Divisible[F[_]] extends Divide[F] {
    def conquer[A]: F[A]
  }

.conquer allows creating trivial implementations where the type parameter is ignored. Such values are called universally quantified. For example, the Divisible[Equal].conquer[INil[String]] returns an implementation of Equal for an empty list of String which is always true.
5.9 Plus

Plus is Semigroup but for type constructors, and PlusEmpty is the equivalent of Monoid (they even have the same laws) whereas IsEmpty is novel and allows us to query if an F[A] is empty:

  @typeclass trait Plus[F[_]] {
    @op("<+>") def plus[A](a: F[A], b: =>F[A]): F[A]
  }
  @typeclass trait PlusEmpty[F[_]] extends Plus[F] {
    def empty[A]: F[A]
  }
  @typeclass trait IsEmpty[F[_]] extends PlusEmpty[F] {
    def isEmpty[A](fa: F[A]): Boolean
  }

<+> is the TIE Interceptor, and now we’re almost out of TIE Fighters…

Although it may look on the surface as if <+> behaves like |+|

  scala> List(2,3) |+| List(7)
  res = List(2, 3, 7)
  
  scala> List(2,3) <+> List(7)
  res = List(2, 3, 7)

it is best to think of it as operating only at the F[_] level, never looking into the contents. Plus has the convention that it should ignore failures and “pick the first winner”. <+> can therefore be used as a mechanism for early exit (losing information) and failure-handling via fallbacks:

  scala> Option(1) |+| Option(2)
  res = Some(3)
  
  scala> Option(1) <+> Option(2)
  res = Some(1)
  
  scala> Option.empty[Int] <+> Option(1)
  res = Some(1)

For example, if we have a NonEmptyList[Option[Int]] and we want to ignore None values (failures) and pick the first winner (Some), we can call <+> from Foldable1.foldRight1:

  scala> NonEmptyList(None, None, Some(1), Some(2), None)
         .foldRight1(_ <+> _)
  res: Option[Int] = Some(1)

In fact, now that we know about Plus, we realise that we didn’t need to break typeclass coherence (when we defined a locally scoped Monoid[Option[A]]) in the section on Appendable Things. Our objective was to “pick the last winner”, which is the same as “pick the winner” if the arguments are swapped. Note the use of the TIE Interceptor for ccy and otc with arguments swapped.

  implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
    (a, b) => TradeTemplate(a.payments |+| b.payments,
                            b.ccy <+> a.ccy,
                            b.otc <+> a.otc),
    TradeTemplate(Nil, None, None)
  )

Applicative and Monad have specialised versions of PlusEmpty

  @typeclass trait ApplicativePlus[F[_]] extends Applicative[F] with PlusEmpty[F]
  
  @typeclass trait MonadPlus[F[_]] extends Monad[F] with ApplicativePlus[F] {
    def unite[T[_]: Foldable, A](ts: F[T[A]]): F[A] = ...
  
    def withFilter[A](fa: F[A])(f: A => Boolean): F[A] = ...
  }

.unite lets us fold a data structure using the outer container’s PlusEmpty[F].monoid rather than the inner content’s Monoid. For List[Either[String, Int]] this means Left[String] values are converted into .empty, then everything is concatenated. A convenient way to discard errors:

  scala> List(Right(1), Left("boo"), Right(2)).unite
  res: List[Int] = List(1, 2)
  
  scala> val boo: Either[String, Int] = Left("boo")
         boo.foldMap(a => a.pure[List])
  res: List[String] = List()
  
  scala> val n: Either[String, Int] = Right(1)
         n.foldMap(a => a.pure[List])
  res: List[Int] = List(1)

withFilter allows us to make use of for comprehension language support as discussed in Chapter 2. It is fair to say that the Scala language has built-in language support for MonadPlus, not just Monad!

Returning to Foldable for a moment, we can reveal some methods that we did not discuss earlier

  @typeclass trait Foldable[F[_]] {
    ...
    def msuml[G[_]: PlusEmpty, A](fa: F[G[A]]): G[A] = ...
    def collapse[X[_]: ApplicativePlus, A](x: F[A]): X[A] = ...
    ...
  }

msuml does a fold using the Monoid from the PlusEmpty[G] and collapse does a foldRight using the PlusEmpty of the target type:

  scala> IList(Option(1), Option.empty[Int], Option(2)).fold
  res: Option[Int] = Some(3) // uses Monoid[Option[Int]]
  
  scala> IList(Option(1), Option.empty[Int], Option(2)).msuml
  res: Option[Int] = Some(1) // uses PlusEmpty[Option].monoid
  
  scala> IList(1, 2).collapse[Option]
  res: Option[Int] = Some(1)

5.10 Lone Wolves

Some of the typeclasses in Scalaz are stand-alone and not part of the larger hierarchy.
5.10.1 Zippy

  @typeclass trait Zip[F[_]]  {
    def zip[A, B](a: =>F[A], b: =>F[B]): F[(A, B)]
  
    def zipWith[A, B, C](fa: =>F[A], fb: =>F[B])(f: (A, B) => C)
                        (implicit F: Functor[F]): F[C] = ...
  
    def ap(implicit F: Functor[F]): Apply[F] = ...
  
    @op("<*|*>") def apzip[A, B](f: =>F[A] => F[B], a: =>F[A]): F[(A, B)] = ...
  
  }

The core method is zip which is a less powerful version of Divide.tuple2, and if a Functor[F] is provided then zipWith can behave like Apply.apply2. Indeed, an Apply[F] can be created from a Zip[F] and a Functor[F] by calling ap.

apzip takes an F[A] and a lifted function from F[A] => F[B], producing an F[(A, B)] similar to Functor.fproduct.

<*|*> is the creepy Jawa operator.

  @typeclass trait Unzip[F[_]]  {
    @op("unfzip") def unzip[A, B](a: F[(A, B)]): (F[A], F[B])
  
    def firsts[A, B](a: F[(A, B)]): F[A] = ...
    def seconds[A, B](a: F[(A, B)]): F[B] = ...
  
    def unzip3[A, B, C](x: F[(A, (B, C))]): (F[A], F[B], F[C]) = ...
    ...
    def unzip7[A ... H](x: F[(A, (B, ... H))]): ...
  }

The core method is unzip with firsts and seconds allowing for selecting either the first or second element of a tuple in the F. Importantly, unzip is the opposite of zip.

The methods unzip3 to unzip7 are repeated applications of unzip to save on boilerplate. For example, if handed a bunch of nested tuples, the Unzip[Id] is a handy way to flatten them:

  scala> Unzip[Id].unzip7((1, (2, (3, (4, (5, (6, 7)))))))
  res = (1,2,3,4,5,6,7)

In a nutshell, Zip and Unzip are less powerful versions of Divide and Apply, providing useful features without requiring the F to make too many promises.
5.10.2 Optional

Optional is a generalisation of data structures that can optionally contain a value, like Option and Either.

Recall that \/ (disjunction) is Scalaz’s improvement of scala.Either. We will also see Maybe, Scalaz’s improvement of scala.Option

  sealed abstract class Maybe[A]
  final case class Empty[A]()    extends Maybe[A]
  final case class Just[A](a: A) extends Maybe[A]

  @typeclass trait Optional[F[_]] {
    def pextract[B, A](fa: F[A]): F[B] \/ A
  
    def getOrElse[A](fa: F[A])(default: =>A): A = ...
    def orElse[A](fa: F[A])(alt: =>F[A]): F[A] = ...
  
    def isDefined[A](fa: F[A]): Boolean = ...
    def nonEmpty[A](fa: F[A]): Boolean = ...
    def isEmpty[A](fa: F[A]): Boolean = ...
  
    def toOption[A](fa: F[A]): Option[A] = ...
    def toMaybe[A](fa: F[A]): Maybe[A] = ...
  }

These are methods that should be familiar, except perhaps pextract, which is a way of letting the F[_] return some implementation specific F[B] or the value. For example, Optional[Option].pextract returns Option[Nothing] \/ A, i.e. None \/ A.

Scalaz gives a ternary operator to things that have an Optional

  implicit class OptionalOps[F[_]: Optional, A](fa: F[A]) {
    def ?[X](some: =>X): Conditional[X] = new Conditional[X](some)
    final class Conditional[X](some: =>X) {
      def |(none: =>X): X = if (Optional[F].isDefined(fa)) some else none
    }
  }

for example

  scala> val knock_knock: Option[String] = ...
         knock_knock ? "who's there?" | "<tumbleweed>"

5.11 Co-things

A co-thing typically has some opposite type signature to whatever thing does, but is not necessarily its inverse. To highlight the relationship between thing and co-thing, we will include the type signature of thing wherever we can.
5.11.1 Cobind

  @typeclass trait Cobind[F[_]] extends Functor[F] {
    def cobind[A, B](fa: F[A])(f: F[A] => B): F[B]
  //def   bind[A, B](fa: F[A])(f: A => F[B]): F[B]
  
    def cojoin[A](fa: F[A]): F[F[A]] = ...
  //def   join[A](ffa: F[F[A]]): F[A] = ...
  }

cobind (also known as coflatmap) takes an F[A] => B that acts on an F[A] rather than its elements. But this is not necessarily the full fa, it is usually some substructure as defined by cojoin (also known as coflatten) which expands a data structure.

Compelling use-cases for Cobind are rare, although when shown in the Functor permutation table (for F[_], A and B) it is difficult to argue why any method should be less important than the others:
method 	parameter
map 	A => B
contramap 	B => A
xmap 	(A => B, B => A)
ap 	F[A => B]
bind 	A => F[B]
cobind 	F[A] => B
5.11.2 Comonad

  @typeclass trait Comonad[F[_]] extends Cobind[F] {
    def copoint[A](p: F[A]): A
  //def   point[A](a: =>A): F[A]
  }

.copoint (also .copure) unwraps an element from its context. Effects do not typically have an instance of Comonad since would break referential transparency to interpret an IO[A] into an A. But for collection-like data structures, it is a way to construct a view of all elements alongside their neighbours.

Consider a neighbourhood (Hood for short) for a list containing all the elements to the left of an element (lefts), the element itself (the focus), and all the elements to its right (rights).

  final case class Hood[A](lefts: IList[A], focus: A, rights: IList[A])

The lefts and rights should each be ordered with the nearest to the focus at the head, such that we can recover the original IList via .toIList

  object Hood {
    implicit class Ops[A](hood: Hood[A]) {
      def toIList: IList[A] = hood.lefts.reverse ::: hood.focus :: hood.rights

We can write methods that let us move the focus one to the left (previous) and one to the right (next)

  ...
      def previous: Maybe[Hood[A]] = hood.lefts match {
        case INil() => Empty()
        case ICons(head, tail) =>
          Just(Hood(tail, head, hood.focus :: hood.rights))
      }
      def next: Maybe[Hood[A]] = hood.rights match {
        case INil() => Empty()
        case ICons(head, tail) =>
          Just(Hood(hood.focus :: hood.lefts, head, tail))
      }

By introducing more to repeatedly apply an optional function to Hood we can calculate all the positions that Hood can take in the list

  ...
      def more(f: Hood[A] => Maybe[Hood[A]]): IList[Hood[A]] =
        f(hood) match {
          case Empty() => INil()
          case Just(r) => ICons(r, r.more(f))
        }
      def positions: Hood[Hood[A]] = {
        val left  = hood.more(_.previous)
        val right = hood.more(_.next)
        Hood(left, hood, right)
      }
    }

We can now implement Comonad[Hood]

  ...
    implicit val comonad: Comonad[Hood] = new Comonad[Hood] {
      def map[A, B](fa: Hood[A])(f: A => B): Hood[B] =
        Hood(fa.lefts.map(f), f(fa.focus), fa.rights.map(f))
      def cobind[A, B](fa: Hood[A])(f: Hood[A] => B): Hood[B] =
        fa.positions.map(f)
      def copoint[A](fa: Hood[A]): A = fa.focus
    }
  }

cojoin gives us a Hood[Hood[IList]] containing all the possible neighbourhoods in our initial IList

  scala> val middle = Hood(IList(4, 3, 2, 1), 5, IList(6, 7, 8, 9))
  scala> middle.cojoin
  res = Hood(
          [Hood([3,2,1],4,[5,6,7,8,9]),
           Hood([2,1],3,[4,5,6,7,8,9]),
           Hood([1],2,[3,4,5,6,7,8,9]),
           Hood([],1,[2,3,4,5,6,7,8,9])],
          Hood([4,3,2,1],5,[6,7,8,9]),
          [Hood([5,4,3,2,1],6,[7,8,9]),
           Hood([6,5,4,3,2,1],7,[8,9]),
           Hood([7,6,5,4,3,2,1],8,[9]),
           Hood([8,7,6,5,4,3,2,1],9,[])])

Indeed, cojoin is just positions! We can override it with a more direct (and performant) implementation

  override def cojoin[A](fa: Hood[A]): Hood[Hood[A]] = fa.positions

Comonad generalises the concept of Hood to arbitrary data structures. Hood is an example of a zipper (unrelated to Zip). Scalaz comes with a Zipper data type for streams (i.e. infinite 1D data structures), which we will discuss in the next chapter.

One application of a zipper is for cellular automata, which compute the value of each cell in the next generation by performing a computation based on the neighbourhood of that cell.
5.11.3 Cozip

  @typeclass trait Cozip[F[_]] {
    def cozip[A, B](x: F[A \/ B]): F[A] \/ F[B]
  //def   zip[A, B](a: =>F[A], b: =>F[B]): F[(A, B)]
  //def unzip[A, B](a: F[(A, B)]): (F[A], F[B])
  
    def cozip3[A, B, C](x: F[A \/ (B \/ C)]): F[A] \/ (F[B] \/ F[C]) = ...
    ...
    def cozip7[A ... H](x: F[(A \/ (... H))]): F[A] \/ (... F[H]) = ...
  }

Although named cozip, it is perhaps more appropriate to talk about its symmetry with unzip. Whereas unzip splits F[_] of tuples (products) into tuples of F[_], cozip splits F[_] of disjunctions (coproducts) into disjunctions of F[_].
5.12 Bi-things

Sometimes we may find ourselves with a thing that has two type holes and we want to map over both sides. For example we might be tracking failures in the left of an Either and we want to do something with the failure messages.

The Functor / Foldable / Traverse typeclasses have bizarro relatives that allow us to map both ways.

  @typeclass trait Bifunctor[F[_, _]] {
    def bimap[A, B, C, D](fab: F[A, B])(f: A => C, g: B => D): F[C, D]
  
    @op("<-:") def leftMap[A, B, C](fab: F[A, B])(f: A => C): F[C, B] = ...
    @op(":->") def rightMap[A, B, D](fab: F[A, B])(g: B => D): F[A, D] = ...
    @op("<:>") def umap[A, B](faa: F[A, A])(f: A => B): F[B, B] = ...
  }
  
  @typeclass trait Bifoldable[F[_, _]] {
    def bifoldMap[A, B, M: Monoid](fa: F[A, B])(f: A => M)(g: B => M): M
  
    def bifoldRight[A,B,C](fa: F[A, B], z: =>C)(f: (A, =>C) => C)(g: (B, =>C) => C): C
    def bifoldLeft[A,B,C](fa: F[A, B], z: C)(f: (C, A) => C)(g: (C, B) => C): C = ...
  
    def bifoldMap1[A, B, M: Semigroup](fa: F[A,B])(f: A => M)(g: B => M): Option[M] = ...
  }
  
  @typeclass trait Bitraverse[F[_, _]] extends Bifunctor[F] with Bifoldable[F] {
    def bitraverse[G[_]: Applicative, A, B, C, D](fab: F[A, B])
                                                 (f: A => G[C])
                                                 (g: B => G[D]): G[F[C, D]]
  
    def bisequence[G[_]: Applicative, A, B](x: F[G[A], G[B]]): G[F[A, B]] = ...
  }

<-: and :-> are the happy operators!

Although the type signatures are verbose, these are nothing more than the core methods of Functor, Foldable and Bitraverse taking two functions instead of one, often requiring both functions to return the same type so that their results can be combined with a Monoid or Semigroup.

  scala> val a: Either[String, Int] = Left("fail")
         val b: Either[String, Int] = Right(13)
  
  scala> b.bimap(_.toUpperCase, _ * 2)
  res: Either[String, Int] = Right(26)
  
  scala> a.bimap(_.toUpperCase, _ * 2)
  res: Either[String, Int] = Left(FAIL)
  
  scala> b :-> (_ * 2)
  res: Either[String,Int] = Right(26)
  
  scala> a :-> (_ * 2)
  res: Either[String, Int] = Left(fail)
  
  scala> { s: String => s.length } <-: a
  res: Either[Int, Int] = Left(4)
  
  scala> a.bifoldMap(_.length)(identity)
  res: Int = 4
  
  scala> b.bitraverse(s => Future(s.length), i => Future(i))
  res: Future[Either[Int, Int]] = Future(<not completed>)

In addition, we can revisit MonadPlus (recall it is Monad with the ability to filterWith and unite) and see that it can separate Bifoldable contents of a Monad

  @typeclass trait MonadPlus[F[_]] {
    ...
    def separate[G[_, _]: Bifoldable, A, B](value: F[G[A, B]]): (F[A], F[B]) = ...
    ...
  }

This is very useful if we have a collection of bi-things and we want to reorganise them into a collection of A and a collection of B

  scala> val list: List[Either[Int, String]] =
           List(Right("hello"), Left(1), Left(2), Right("world"))
  
  scala> list.separate
  res: (List[Int], List[String]) = (List(1, 2), List(hello, world))

5.13 Summary

That was a lot of material! We have just explored a standard library of polymorphic functionality. But to put it into perspective: there are more traits in the Scala stdlib Collections API than typeclasses in Scalaz.

It is normal for an FP application to only touch a small percentage of the typeclass hierarchy, with most functionality coming from domain-specific algebras and typeclasses. Even if the domain-specific typeclasses are just specialised clones of something in Scalaz, it is OK to refactor it later.

To help, we have included a cheat-sheet of the typeclasses and their primary methods in the Appendix, inspired by Adam Rosien’s Scalaz Cheatsheet.

To help further, Valentin Kasas explains how to combine N things:
