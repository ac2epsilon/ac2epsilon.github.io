<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 9]><!-->
<html class=" wf-notosans-n7-active wf-notosans-i4-active wf-notosans-i7-active wf-notoserif-n7-active wf-notoserif-i4-active wf-notoserif-i7-active wf-notosans-n4-active wf-notoserif-n4-active wf-active js no-touch multiplebgs svg inlinesvg svgclippaths no-ie8compat" style="" lang="en"><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible">
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<meta content="en" name="Content-Language">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-57x57-b83f183ad6b00aa74d8e692126c7017e.png" sizes="57x57">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-60x60-6dc1c10b7145a2f1156af5b798565268.png" sizes="60x60">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-72x72-5037b667b6f7a8d5ba8c4ffb4a62ec2d.png" sizes="72x72">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-76x76-57860ca8a817754d2861e8d0ef943b23.png" sizes="76x76">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-114x114-27f9c42684f2a77945643b35b28df6e3.png" sizes="114x114">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-120x120-3819f03d1bad1584719af0212396a6fc.png" sizes="120x120">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-144x144-a79479b4595dc7ca2f3e6f5b962d16fd.png" sizes="144x144">
<link rel="apple-touch-icon-precomposed" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/apple-touch-icon-152x152-aafe015ef1c22234133158a89b29daf5.png" sizes="152x152">
<link rel="icon" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/favicon-16x16-c1207cd2f3a20fd50de0e585b4b307a3.png" sizes="16x16">
<link rel="icon" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/favicon-32x32-e9b1d6ef3d96ed8918c54316cdea011f.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/favicon-96x96-842fcd3e7786576fc20d38bbf94837fc.png" sizes="96x96">
<link rel="icon" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/favicon-128x128-e97066b91cc21b104c63bc7530ff819f.png" sizes="128x128">
<link rel="icon" type="image/png" href="https://d3g6anj9jkury9.cloudfront.net/assets/favicons/favicon-196x196-b8cab44cf725c4fa0aafdbd237cdc4ed.png" sizes="196x196">
<meta content="Leanpub" name="application-name">
<meta content="#ffffff" name="msapplication-TileColor">
<meta content="favicons/mstile-144x144.png" name="msapplication-TileImage">
<meta content="favicons/mstile-150x150.png" name="msapplication-square150x150logo">
<meta content="favicons/mstile-310x150.png" name="msapplication-wide310x150logo">
<meta content="favicons/mstile-310x310.png" name="msapplication-square310x310logo">
<meta content="favicons/mstile-70x70.png" name="msapplication-square70x70logo">

<title>Read Functional Programming for Mortals | Leanpub</title>
<link href="https://fonts.googleapis.com/" rel="dns-prefetch">
<script type="text/javascript" async="" src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/ec.js"></script><script async="" src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/uwt.js"></script><script async="" src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/analytics.js"></script><script type="text/javascript" async="" src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/recaptcha__uk.js"></script><script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/webfont.js"></script>
<link rel="stylesheet" href="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/css.css" media="all"><script>
  if (typeof WebFont !== 'undefined') {
    WebFont.load({
      google: {
        families: [
          'Noto Sans:400,700,400i,700i',
          'Noto Serif:400,700,400i,700i',
        ]
      }
    });
  }
</script>

<link rel="stylesheet" media="screen" href="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/font_awesome-f7d95bde64062dd89b417f07c933597d.css">
<link rel="stylesheet" media="all" href="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/application-0650168f222c26241fcf5532cc4b7b06.css">

<script>
  var _rollbarConfig = {
      accessToken: "3d279f41d3804636adbbba833c2c0d2d",
      captureUncaught: true,
      captureUnhandledRejections: true,
      code_version: "10f6afa59750085bca24534e61126c5d50b0c2aa",
      payload: {
        environment: "production"
      }
  };
  // Rollbar Snippet
  !function(r){function o(n){if(e[n])return e[n].exports;var t=e[n]={exports:{},id:n,loaded:!1};return r[n].call(t.exports,t,t.exports,o),t.loaded=!0,t.exports}var e={};return o.m=r,o.c=e,o.p="",o(0)}([function(r,o,e){"use strict";var n=e(1),t=e(4);_rollbarConfig=_rollbarConfig||{},_rollbarConfig.rollbarJsUrl=_rollbarConfig.rollbarJsUrl||"https://cdnjs.cloudflare.com/ajax/libs/rollbar.js/2.5.2/rollbar.min.js",_rollbarConfig.async=void 0===_rollbarConfig.async||_rollbarConfig.async;var a=n.setupShim(window,_rollbarConfig),l=t(_rollbarConfig);window.rollbar=n.Rollbar,a.loadFull(window,document,!_rollbarConfig.async,_rollbarConfig,l)},function(r,o,e){"use strict";function n(r){return function(){try{return r.apply(this,arguments)}catch(r){try{console.error("[Rollbar]: Internal error",r)}catch(r){}}}}function t(r,o){this.options=r,this._rollbarOldOnError=null;var e=s++;this.shimId=function(){return e},"undefined"!=typeof window&&window._rollbarShims&&(window._rollbarShims[e]={handler:o,messages:[]})}function a(r,o){if(r){var e=o.globalAlias||"Rollbar";if("object"==typeof r[e])return r[e];r._rollbarShims={},r._rollbarWrappedError=null;var t=new p(o);return n(function(){o.captureUncaught&&(t._rollbarOldOnError=r.onerror,i.captureUncaughtExceptions(r,t,!0),i.wrapGlobals(r,t,!0)),o.captureUnhandledRejections&&i.captureUnhandledRejections(r,t,!0);var n=o.autoInstrument;return o.enabled!==!1&&(void 0===n||n===!0||"object"==typeof n&&n.network)&&r.addEventListener&&(r.addEventListener("load",t.captureLoad.bind(t)),r.addEventListener("DOMContentLoaded",t.captureDomContentLoaded.bind(t))),r[e]=t,t})()}}function l(r){return n(function(){var o=this,e=Array.prototype.slice.call(arguments,0),n={shim:o,method:r,args:e,ts:new Date};window._rollbarShims[this.shimId()].messages.push(n)})}var i=e(2),s=0,d=e(3),c=function(r,o){return new t(r,o)},p=function(r){return new d(c,r)};t.prototype.loadFull=function(r,o,e,t,a){var l=function(){var o;if(void 0===r._rollbarDidLoad){o=new Error("rollbar.js did not load");for(var e,n,t,l,i=0;e=r._rollbarShims[i++];)for(e=e.messages||[];n=e.shift();)for(t=n.args||[],i=0;i<t.length;++i)if(l=t[i],"function"==typeof l){l(o);break}}"function"==typeof a&&a(o)},i=!1,s=o.createElement("script"),d=o.getElementsByTagName("script")[0],c=d.parentNode;s.crossOrigin="",s.src=t.rollbarJsUrl,e||(s.async=!0),s.onload=s.onreadystatechange=n(function(){if(!(i||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState)){s.onload=s.onreadystatechange=null;try{c.removeChild(s)}catch(r){}i=!0,l()}}),c.insertBefore(s,d)},t.prototype.wrap=function(r,o,e){try{var n;if(n="function"==typeof o?o:function(){return o||{}},"function"!=typeof r)return r;if(r._isWrap)return r;if(!r._rollbar_wrapped&&(r._rollbar_wrapped=function(){e&&"function"==typeof e&&e.apply(this,arguments);try{return r.apply(this,arguments)}catch(e){var o=e;throw o&&("string"==typeof o&&(o=new String(o)),o._rollbarContext=n()||{},o._rollbarContext._wrappedSource=r.toString(),window._rollbarWrappedError=o),o}},r._rollbar_wrapped._isWrap=!0,r.hasOwnProperty))for(var t in r)r.hasOwnProperty(t)&&(r._rollbar_wrapped[t]=r[t]);return r._rollbar_wrapped}catch(o){return r}};for(var u="log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleUnhandledRejection,captureEvent,captureDomContentLoaded,captureLoad".split(","),f=0;f<u.length;++f)t.prototype[u[f]]=l(u[f]);r.exports={setupShim:a,Rollbar:p}},function(r,o){"use strict";function e(r,o,e){if(r){var t;if("function"==typeof o._rollbarOldOnError)t=o._rollbarOldOnError;else if(r.onerror){for(t=r.onerror;t._rollbarOldOnError;)t=t._rollbarOldOnError;o._rollbarOldOnError=t}var a=function(){var e=Array.prototype.slice.call(arguments,0);n(r,o,t,e)};e&&(a._rollbarOldOnError=t),r.onerror=a}}function n(r,o,e,n){r._rollbarWrappedError&&(n[4]||(n[4]=r._rollbarWrappedError),n[5]||(n[5]=r._rollbarWrappedError._rollbarContext),r._rollbarWrappedError=null),o.handleUncaughtException.apply(o,n),e&&e.apply(r,n)}function t(r,o,e){if(r){"function"==typeof r._rollbarURH&&r._rollbarURH.belongsToShim&&r.removeEventListener("unhandledrejection",r._rollbarURH);var n=function(r){var e,n,t;try{e=r.reason}catch(r){e=void 0}try{n=r.promise}catch(r){n="[unhandledrejection] error getting `promise` from event"}try{t=r.detail,!e&&t&&(e=t.reason,n=t.promise)}catch(r){}e||(e="[unhandledrejection] error getting `reason` from event"),o&&o.handleUnhandledRejection&&o.handleUnhandledRejection(e,n)};n.belongsToShim=e,r._rollbarURH=n,r.addEventListener("unhandledrejection",n)}}function a(r,o,e){if(r){var n,t,a="EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");for(n=0;n<a.length;++n)t=a[n],r[t]&&r[t].prototype&&l(o,r[t].prototype,e)}}function l(r,o,e){if(o.hasOwnProperty&&o.hasOwnProperty("addEventListener")){for(var n=o.addEventListener;n._rollbarOldAdd&&n.belongsToShim;)n=n._rollbarOldAdd;var t=function(o,e,t){n.call(this,o,r.wrap(e),t)};t._rollbarOldAdd=n,t.belongsToShim=e,o.addEventListener=t;for(var a=o.removeEventListener;a._rollbarOldRemove&&a.belongsToShim;)a=a._rollbarOldRemove;var l=function(r,o,e){a.call(this,r,o&&o._rollbar_wrapped||o,e)};l._rollbarOldRemove=a,l.belongsToShim=e,o.removeEventListener=l}}r.exports={captureUncaughtExceptions:e,captureUnhandledRejections:t,wrapGlobals:a}},function(r,o){"use strict";function e(r,o){this.impl=r(o,this),this.options=o,n(e.prototype)}function n(r){for(var o=function(r){return function(){var o=Array.prototype.slice.call(arguments,0);if(this.impl[r])return this.impl[r].apply(this.impl,o)}},e="log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleUnhandledRejection,_createItem,wrap,loadFull,shimId,captureEvent,captureDomContentLoaded,captureLoad".split(","),n=0;n<e.length;n++)r[e[n]]=o(e[n])}e.prototype._swapAndProcessMessages=function(r,o){this.impl=r(this.options);for(var e,n,t;e=o.shift();)n=e.method,t=e.args,this[n]&&"function"==typeof this[n]&&("captureDomContentLoaded"===n||"captureLoad"===n?this[n].apply(this,[t[0],e.ts]):this[n].apply(this,t));return this},r.exports=e},function(r,o){"use strict";r.exports=function(r){return function(o){if(!o&&!window._rollbarInitialized){r=r||{};for(var e,n,t=r.globalAlias||"Rollbar",a=window.rollbar,l=function(r){return new a(r)},i=0;e=window._rollbarShims[i++];)n||(n=e.handler),e.handler._swapAndProcessMessages(l,e.messages);window[t]=n,window._rollbarInitialized=!0}}}}]);
  // End Rollbar Snippet
</script>

<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/api.js"></script>
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/modernizr-6f6f590d4beb241834c7bf44f1147c87.js"></script>
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/jsapi"></script>
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/chartkick-ebce4400b12dc6a0bf57810075dd89ff.js"></script>
<link rel="stylesheet" media="screen" href="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/header-bundle-7a3fd45b4ad3c588602f.css">
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/MathJax.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  
  ga('create', 'UA-911230-9', 'auto');  // Replace with your property ID.
  ga('require', 'ec');
  
  // Visitor type parameters (only settable from non cached)
  
  
  
  
  ga('send', 'pageview');
</script>

<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/js" type="text/javascript" async="true"></script><style></style><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 5px 0px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 5px; -webkit-border-radius: 5px; -moz-border-radius: 5px; -khtml-border-radius: 5px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 1px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: .7em}
.MathJax_MenuRadioCheck.RTL {right: .7em; left: auto}
.MathJax_MenuLabel {padding: 1px 2em 3px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #DDDDDD; margin: 4px 3px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: #606872; color: white}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1px; bottom: 2px; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style><style type="text/css">.MathJax_Display {text-align: center; margin: 1em 0em; position: relative; display: block!important; text-indent: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; width: 100%}
.MathJax .merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MathJax .MJX-monospace {font-family: monospace}
.MathJax .MJX-sans-serif {font-family: sans-serif}
#MathJax_Tooltip {background-color: InfoBackground; color: InfoText; border: 1px solid black; box-shadow: 2px 2px 5px #AAAAAA; -webkit-box-shadow: 2px 2px 5px #AAAAAA; -moz-box-shadow: 2px 2px 5px #AAAAAA; -khtml-box-shadow: 2px 2px 5px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true'); padding: 3px 4px; z-index: 401; position: absolute; left: 0; top: 0; width: auto; height: auto; display: none}
.MathJax {display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 100%; font-size-adjust: none; text-indent: 0; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0; min-height: 0; border: 0; padding: 0; margin: 0}
.MathJax:focus, body :focus .MathJax {display: inline-table}
.MathJax img, .MathJax nobr, .MathJax a {border: 0; padding: 0; margin: 0; max-width: none; max-height: none; min-width: 0; min-height: 0; vertical-align: 0; line-height: normal; text-decoration: none}
img.MathJax_strut {border: 0!important; padding: 0!important; margin: 0!important; vertical-align: 0!important}
.MathJax span {display: inline; position: static; border: 0; padding: 0; margin: 0; vertical-align: 0; line-height: normal; text-decoration: none}
.MathJax nobr {white-space: nowrap!important}
.MathJax img {display: inline!important; float: none!important}
.MathJax * {transition: none; -webkit-transition: none; -moz-transition: none; -ms-transition: none; -o-transition: none}
.MathJax_Processing {visibility: hidden; position: fixed; width: 0; height: 0; overflow: hidden}
.MathJax_Processed {display: none!important}
.MathJax_ExBox {display: block!important; overflow: hidden; width: 1px; height: 60ex; min-height: 0; max-height: none}
.MathJax .MathJax_EmBox {display: block!important; overflow: hidden; width: 1px; height: 60em; min-height: 0; max-height: none}
.MathJax .MathJax_HitBox {cursor: text; background: white; opacity: 0; filter: alpha(opacity=0)}
.MathJax .MathJax_HitBox * {filter: none; opacity: 1; background: transparent}
#MathJax_Tooltip * {filter: none; opacity: 1; background: transparent}
@font-face {font-family: MathJax_Blank; src: url('about:blank')}
.MathJax .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body id="reads-show"><div style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px none; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;"><div id="MathJax_Hidden"></div></div><div id="MathJax_Message" style="display: none;"></div>

<div class="flash" id="js-flash-prototype">
<div class="flash__progress-bar"></div>
<div class="container--large">
<div class="flash__message"></div>
<div class="flash__close-icon">

<svg xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" height="25px" id="Layer_1" style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="25px" xml:space="preserve"><path d="M437.5,386.6L306.9,256l130.6-130.6c14.1-14.1,14.1-36.8,0-50.9c-14.1-14.1-36.8-14.1-50.9,0L256,205.1L125.4,74.5  c-14.1-14.1-36.8-14.1-50.9,0c-14.1,14.1-14.1,36.8,0,50.9L205.1,256L74.5,386.6c-14.1,14.1-14.1,36.8,0,50.9  c14.1,14.1,36.8,14.1,50.9,0L256,306.9l130.6,130.6c14.1,14.1,36.8,14.1,50.9,0C451.5,423.4,451.5,400.6,437.5,386.6z"></path></svg>

</div>
</div>
</div>


<div id="react-header-root"><header class="header"><div class="container--large"><div class="header__section--left"><a class="header__mobile-menu-icon"><i class="fa fa-bars"></i></a><div class="mobile-menu "><header class="mobile-menu__header"><button type="button" class="btn--close"><!--?xml version="1.0" ?--><svg height="25px" id="Layer_1" style="enable-background:new 0 0 512 512;" version="1.1" viewBox="0 0 512 512" width="25px" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink"><path d="M437.5,386.6L306.9,256l130.6-130.6c14.1-14.1,14.1-36.8,0-50.9c-14.1-14.1-36.8-14.1-50.9,0L256,205.1L125.4,74.5  c-14.1-14.1-36.8-14.1-50.9,0c-14.1,14.1-14.1,36.8,0,50.9L205.1,256L74.5,386.6c-14.1,14.1-14.1,36.8,0,50.9  c14.1,14.1,36.8,14.1,50.9,0L256,306.9l130.6,130.6c14.1,14.1,36.8,14.1,50.9,0C451.5,423.4,451.5,400.6,437.5,386.6z"></path></svg>
</button><div class="mobile-menu__header__logo"><a href="https://leanpub.com/"><div><!--?xml version="1.0" encoding="utf-8"?-->
<!-- Generator: Adobe Illustrator 19.2.1, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="128px" height="87.407px" viewBox="0 0 128 87.407" style="enable-background:new 0 0 128 87.407;" xml:space="preserve">
<style type="text/css">
	.st0{fill:#231F20;}
	.st1{fill:#FFFFFF;}
</style>
<path class="st0" d="M118.343,7.884C114.047,5.467,102.725,0,88.202,0C75.161,0,67.739,4.009,64,6.583
	C60.261,4.009,52.839,0,39.798,0C25.275,0,13.953,5.467,9.657,7.884L0,87.407h0.288c5.46,0,10.834-1.259,15.772-3.589
	c5.504-2.597,14.182-5.652,24.545-5.652c12.606,0,19.781,5.627,23.395,9.241c3.614-3.614,10.789-9.241,23.395-9.241
	c10.363,0,19.041,3.055,24.545,5.652c4.938,2.33,10.313,3.589,15.772,3.589H128L118.343,7.884z"></path>
<path class="st1" d="M111.652,74.536c-5.112-2.103-10.271-3.541-15.332-4.274c-2.974-0.431-5.977-0.649-8.925-0.649
	c-8.383,0-15.957,2.09-22.512,6.213L64,76.374l-0.878-0.546c-6.56-4.125-14.134-6.215-22.517-6.215
	c-2.948,0-5.951,0.219-8.925,0.649c-5.062,0.733-10.221,2.171-15.333,4.274L9.85,77.209l7.752-63.796l0.574-0.254
	c6.535-2.888,14.92-4.612,22.429-4.612c9.302,0,17.167,2.962,23.395,8.808c6.228-5.846,14.092-8.808,23.395-8.808
	c7.51,0,15.895,1.724,22.43,4.612l0.574,0.254l7.752,63.796L111.652,74.536z"></path>
<path class="st0" d="M88.824,66.095c-0.797-0.031-1.591-0.047-2.382-0.047c-8.366,0-15.95,2.028-22.542,6.025
	c-6.595-3.998-14.177-6.025-22.542-6.025c-2.942,0-5.938,0.214-8.904,0.636c-5.05,0.718-10.191,2.124-15.278,4.179l-2.902,1.172
	l6.885-55.627c5.955-2.479,13.455-3.95,20.199-3.95c8.757,0,16.088,2.838,21.789,8.436l0.752,0.739l0.752-0.739
	c5.493-5.393,12.502-8.217,20.838-8.417L88.824,66.095z"></path>
</svg>
</div></a></div><span style="width: 25px;"></span></header><div class="mobile-menu__search"><div class="search" role="search"><form class="search__form" method="get"><label class="search__label" for="search-query">Search Query</label><button type="submit" class="search__button"><i class="fa fa-search"></i></button><input type="text" name="search" id="search-query" class="search__input" placeholder="Search Leanpub..."></form></div></div><nav class="mobile-menu__nav"><ul><li><a href="https://leanpub.com/">Home</a></li><li><a href="https://leanpub.com/bookstore">Store</a></li><li><a href="https://leanpub.com/user_dashboard/library">Read</a></li><li><a href="https://leanpub.com/help">Support</a></li><li><a href="https://leanpub.com/podcasts/frontmatter">Podcast</a></li></ul></nav><footer class="mobile-menu__footer"><div class="mobile-menu__session-links"><a href="https://leanpub.com/sign_in">Sign In</a><a href="https://leanpub.com/sign_up">Sign up</a></div></footer></div></div><div class="header__section--center"><div class="header__logo--black"><a href="https://leanpub.com/"><div><!--?xml version="1.0" encoding="UTF-8"?-->
<svg width="348px" height="238px" viewBox="0 0 348 238" version="1.1" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 45.1 (43504) - http://www.bohemiancoding.com/sketch -->
    <title>Leanpub</title>
    <desc>The Leanpub Logo is a Registered Trademark</desc>
    <defs></defs>
    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="logo-black" fill-rule="nonzero" fill="#FFFFFF">
            <path d="M321.584,21.423 C309.91,14.855 279.145,0 239.679,0 C204.243,0 184.073,10.893 173.913,17.889 C163.754,10.893 143.584,0 108.148,0 C68.682,0 37.917,14.855 26.242,21.423 L0,237.519 L0.783,237.519 C15.619,237.519 30.224,234.098 43.643,227.767 C58.6,220.71 82.181,212.407 110.341,212.407 C144.596,212.407 164.093,227.698 173.914,237.519 C183.735,227.698 203.232,212.407 237.487,212.407 C265.647,212.407 289.228,220.71 304.185,227.767 C317.603,234.098 332.208,237.519 347.045,237.519 L347.828,237.519 L321.584,21.423 Z M303.403,202.544 C289.511,196.829 275.494,192.922 261.739,190.929 C253.658,189.759 245.498,189.165 237.486,189.165 C214.707,189.165 194.125,194.845 176.311,206.048 L173.913,207.539 L171.528,206.055 C153.702,194.845 133.119,189.165 110.34,189.165 C102.328,189.165 94.169,189.759 86.089,190.929 C72.334,192.921 58.315,196.829 44.423,202.544 L26.764,209.809 L47.831,36.451 L49.391,35.762 C67.149,27.914 89.934,23.229 110.341,23.229 C135.619,23.229 156.99,31.278 173.914,47.165 C190.838,31.279 212.208,23.229 237.486,23.229 C257.893,23.229 280.678,27.915 298.436,35.762 L299.996,36.451 L321.061,209.809 L303.403,202.544 Z M241.984,181.205 C239.806,181.119 237.634,181.073 235.472,181.073 C212.601,181.073 191.868,186.72 173.846,197.85 C155.815,186.717 135.087,181.073 112.22,181.073 C104.176,181.073 95.986,181.668 87.877,182.843 C74.07,184.842 60.017,188.758 46.109,194.479 L38.176,197.742 L56.999,42.849 C73.28,35.946 93.782,31.849 112.221,31.849 C136.162,31.849 156.204,39.753 171.79,55.34 L173.847,57.397 L175.903,55.34 C190.92,40.323 210.083,32.46 232.871,31.903 L241.984,181.205 Z" id="Shape"></path>
        </g>
    </g>
</svg>
</div></a></div><div class="HeaderRootSwitcher"><div class="DropdownContainer"><div class="DropdownMenu HeaderRootSwitcher__Dropdown"><a class="lp-link" href="https://leanpub.com/user_dashboard/settings">Account</a><a class="lp-link" href="https://community.leanpub.com/">Forums</a><a class="lp-link" href="https://leanpub.com/user_dashboard/library">Library</a><a class="lp-link" href="https://leanpub.com/overview">Overview</a><a class="lp-link" href="https://leanpub.com/user_dashboard/purchases">Purchases</a><a class="lp-link" href="https://leanpub.com/">Store</a></div><button class="DropdownContainer__Trigger"><strong>Store</strong></button></div></div><div class="MobileDropdown"><div class="HeaderRootSwitcher"><div class="DropdownContainer"><div class="DropdownMenu HeaderRootSwitcher__Dropdown"><div class="StaticLinks"><a class="lp-link" href="https://leanpub.com/apps">Apps</a><a class="lp-link" href="https://leanpub.com/bookstore">Bestsellers</a><a class="lp-link" href="https://leanpub.com/">Featured</a><a class="lp-link" href="https://leanpub.com/newsletters">Newsletters</a><a class="lp-link" href="https://leanpub.com/podcasts/frontmatter">Podcast</a><a class="lp-link" href="https://leanpub.com/manual/read">Support</a><a class="lp-link" href="https://leanpub.com/authors">Why Leanpub</a></div></div><button class="DropdownContainer__Trigger"><a>Menu</a></button></div></div></div><div class="StaticLinks"><a class="lp-link" href="https://leanpub.com/apps">Apps</a><a class="lp-link" href="https://leanpub.com/bookstore">Bestsellers</a><a class="lp-link" href="https://leanpub.com/">Featured</a><a class="lp-link" href="https://leanpub.com/newsletters">Newsletters</a><a class="lp-link" href="https://leanpub.com/podcasts/frontmatter">Podcast</a><a class="lp-link" href="https://leanpub.com/manual/read">Support</a><a class="lp-link" href="https://leanpub.com/authors">Why Leanpub</a></div></div><div class="header__section--right"><div class="header__search"><div class="header-search-wrapper"><div class="search" role="search"><form class="search__form" method="get"><label class="search__label" for="search-query">Search Query</label><button type="submit" class="search__button"><i class="fa fa-search"></i></button><input type="text" name="search" id="search-query" class="search__input" placeholder="Search Leanpub..."></form></div></div></div><div class="header__session-buttons"><nav class="header__nav"><ul class="header__nav-list"><li class="header__nav-item"><a href="https://leanpub.com/sign_in">Sign In</a></li><li class="header__nav-item"><a href="https://leanpub.com/sign_up">Sign Up</a></li></ul></nav></div></div></div></header></div>
<script>
  window.__BASE_URL__ = "https://leanpub.com/"
</script>
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/polyfill-bundle-f68035007967c654f008.js"></script>
<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/header-bundle-7a3fd45b4ad3c588602f.js"></script>

<div class="scroll-wrapper read-online-scrolled" id="scroll-wrapper">

<div class="main">


<div class="container--large" id="read-online" lang="en">
<header class="read-online-slidable scrolled">
<div class="read-upsell">
<a href="https://leanpub.com/fpmortals"><img alt="Functional Programming for Mortals" src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/small.png"></a>
<div>
<div class="book-title">Functional Programming for Mortals</div>
</div>
</div>
<a class="btn--solid" href="https://leanpub.com/fpmortals">Buy on Leanpub</a>
<hr>
</header>
<section class="read">
<div class="read-online-header read-online-slidable scrolled">
<button class="toggle-sidebar btn btn--plain">
<div class="fa fa-list-ol"></div>
</button>
<h5>Functional Programming for Mortals</h5>
</div>
<div id="leanpub-toc">
<h2>Table of Contents</h2>
<ol class="toc">
<ul class="toc no-parts">
  <li>
    <a href="#leanpub-auto-about-this-book">About This Book</a>
  </li>
  <li>
    <a href="#leanpub-auto-copyleft-notice">Copyleft Notice</a>
  </li>
  <li>
    <a href="#leanpub-auto-thanks">Thanks</a>
  </li>
  <li>
    <a href="#leanpub-auto-practicalities">Practicalities</a>
  </li>
  <li>
    <a href="#leanpub-auto-introduction"><span class="section-number">1. </span>Introduction</a>
    <ul>
      <li>
        <a href="#leanpub-auto-abstracting-over-execution"><span class="section-number">1.1 </span>Abstracting over Execution</a>
      </li>
      <li>
        <a href="#leanpub-auto-pure-functional-programming"><span class="section-number">1.2 </span>Pure Functional Programming</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-for-comprehensions"><span class="section-number">2. </span>For Comprehensions</a>
    <ul>
      <li>
        <a href="#leanpub-auto-syntax-sugar"><span class="section-number">2.1 </span>Syntax Sugar</a>
      </li>
      <li>
        <a href="#leanpub-auto-unhappy-path"><span class="section-number">2.2 </span>Unhappy path</a>
      </li>
      <li>
        <a href="#leanpub-auto-gymnastics"><span class="section-number">2.3 </span>Gymnastics</a>
      </li>
      <li>
        <a href="#leanpub-auto-incomprehensible"><span class="section-number">2.4 </span>Incomprehensible</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-application-design"><span class="section-number">3. </span>Application Design</a>
    <ul>
      <li>
        <a href="#leanpub-auto-specification"><span class="section-number">3.1 </span>Specification</a>
      </li>
      <li>
        <a href="#leanpub-auto-interfaces--algebras"><span class="section-number">3.2 </span>Interfaces / Algebras</a>
      </li>
      <li>
        <a href="#leanpub-auto-business-logic"><span class="section-number">3.3 </span>Business Logic</a>
      </li>
      <li>
        <a href="#leanpub-auto-unit-tests"><span class="section-number">3.4 </span>Unit Tests</a>
      </li>
      <li>
        <a href="#leanpub-auto-parallel"><span class="section-number">3.5 </span>Parallel</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-1"><span class="section-number">3.6 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-data-and-functionality"><span class="section-number">4. </span>Data and Functionality</a>
    <ul>
      <li>
        <a href="#leanpub-auto-data"><span class="section-number">4.1 </span>Data</a>
      </li>
      <li>
        <a href="#leanpub-auto-functionality"><span class="section-number">4.2 </span>Functionality</a>
      </li>
      <li>
        <a href="#leanpub-auto-modelling-oauth2"><span class="section-number">4.3 </span>Modelling OAuth2</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-2"><span class="section-number">4.4 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-scalaz-typeclasses"><span class="section-number">5. </span>Scalaz Typeclasses</a>
    <ul>
      <li>
        <a href="#leanpub-auto-agenda"><span class="section-number">5.1 </span>Agenda</a>
      </li>
      <li>
        <a href="#leanpub-auto-appendable-things"><span class="section-number">5.2 </span>Appendable Things</a>
      </li>
      <li>
        <a href="#leanpub-auto-objecty-things"><span class="section-number">5.3 </span>Objecty Things</a>
      </li>
      <li>
        <a href="#leanpub-auto-mappable-things"><span class="section-number">5.4 </span>Mappable Things</a>
      </li>
      <li>
        <a href="#leanpub-auto-variance"><span class="section-number">5.5 </span>Variance</a>
      </li>
      <li>
        <a href="#leanpub-auto-apply-and-bind"><span class="section-number">5.6 </span>Apply and Bind</a>
      </li>
      <li>
        <a href="#leanpub-auto-applicative-and-monad"><span class="section-number">5.7 </span>Applicative and Monad</a>
      </li>
      <li>
        <a href="#leanpub-auto-divide-and-conquer"><span class="section-number">5.8 </span>Divide and Conquer</a>
      </li>
      <li>
        <a href="#leanpub-auto-plus"><span class="section-number">5.9 </span>Plus</a>
      </li>
      <li>
        <a href="#leanpub-auto-lone-wolves"><span class="section-number">5.10 </span>Lone Wolves</a>
      </li>
      <li>
        <a href="#leanpub-auto-co-things"><span class="section-number">5.11 </span>Co-things</a>
      </li>
      <li>
        <a href="#leanpub-auto-bi-things"><span class="section-number">5.12 </span>Bi-things</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-3"><span class="section-number">5.13 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-scalaz-data-types"><span class="section-number">6. </span>Scalaz Data Types</a>
    <ul>
      <li>
        <a href="#leanpub-auto-type-variance"><span class="section-number">6.1 </span>Type Variance</a>
      </li>
      <li>
        <a href="#leanpub-auto-evaluation"><span class="section-number">6.2 </span>Evaluation</a>
      </li>
      <li>
        <a href="#leanpub-auto-memoisation"><span class="section-number">6.3 </span>Memoisation</a>
      </li>
      <li>
        <a href="#leanpub-auto-tagging"><span class="section-number">6.4 </span>Tagging</a>
      </li>
      <li>
        <a href="#leanpub-auto-natural-transformations"><span class="section-number">6.5 </span>Natural Transformations</a>
      </li>
      <li>
        <a href="#leanpub-auto-isomorphism"><span class="section-number">6.6 </span><code>Isomorphism</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-containers"><span class="section-number">6.7 </span>Containers</a>
      </li>
      <li>
        <a href="#leanpub-auto-collections"><span class="section-number">6.8 </span>Collections</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-4"><span class="section-number">6.9 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-advanced-monads"><span class="section-number">7. </span>Advanced Monads</a>
    <ul>
      <li>
        <a href="#leanpub-auto-always-in-motion-is-the-future"><span class="section-number">7.1 </span>Always in motion is the <code>Future</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-effects-and-side-effects"><span class="section-number">7.2 </span>Effects and Side Effects</a>
      </li>
      <li>
        <a href="#leanpub-auto-stack-safety"><span class="section-number">7.3 </span>Stack Safety</a>
      </li>
      <li>
        <a href="#leanpub-auto-monad-transformer-library"><span class="section-number">7.4 </span>Monad Transformer Library</a>
      </li>
      <li>
        <a href="#leanpub-auto-a-free-lunch"><span class="section-number">7.5 </span>A Free Lunch</a>
      </li>
      <li>
        <a href="#leanpub-auto-parallel-1"><span class="section-number">7.6 </span><code>Parallel</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-io"><span class="section-number">7.7 </span><code>IO</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-5"><span class="section-number">7.8 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-typeclass-derivation"><span class="section-number">8. </span>Typeclass Derivation</a>
    <ul>
      <li>
        <a href="#leanpub-auto-running-examples"><span class="section-number">8.1 </span>Running Examples</a>
      </li>
      <li>
        <a href="#leanpub-auto-scalaz-deriving"><span class="section-number">8.2 </span><code>scalaz-deriving</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-magnolia"><span class="section-number">8.3 </span>Magnolia</a>
      </li>
      <li>
        <a href="#leanpub-auto-shapeless"><span class="section-number">8.4 </span>Shapeless</a>
      </li>
      <li>
        <a href="#leanpub-auto-performance-1"><span class="section-number">8.5 </span>Performance</a>
      </li>
      <li>
        <a href="#leanpub-auto-summary-6"><span class="section-number">8.6 </span>Summary</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-wiring-up-the-application"><span class="section-number">9. </span>Wiring up the Application</a>
    <ul>
      <li>
        <a href="#leanpub-auto-overview"><span class="section-number">9.1 </span>Overview</a>
      </li>
      <li>
        <a href="#leanpub-auto-main"><span class="section-number">9.2 </span><code>Main</code></a>
      </li>
      <li>
        <a href="#leanpub-auto-blaze"><span class="section-number">9.3 </span>Blaze</a>
      </li>
      <li>
        <a href="#leanpub-auto-thank-you"><span class="section-number">9.4 </span>Thank You</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-typeclass-cheatsheet">Typeclass Cheatsheet</a>
  </li>
  <li>
    <a href="#leanpub-auto-haskell">Haskell</a>
    <ul>
      <li>
        <a href="#leanpub-auto-data-2">Data</a>
      </li>
      <li>
        <a href="#leanpub-auto-functions">Functions</a>
      </li>
      <li>
        <a href="#leanpub-auto-typeclasses">Typeclasses</a>
      </li>
      <li>
        <a href="#leanpub-auto-algebras">Algebras</a>
      </li>
      <li>
        <a href="#leanpub-auto-modules">Modules</a>
      </li>
      <li>
        <a href="#leanpub-auto-evaluation-1">Evaluation</a>
      </li>
      <li>
        <a href="#leanpub-auto-next-steps">Next Steps</a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#leanpub-auto-third-party-licenses">Third Party Licenses</a>
    <ul>
      <li>
        <a href="#leanpub-auto-scala-license">Scala License</a>
      </li>
      <li>
        <a href="#leanpub-auto-scalaz-license">Scalaz License</a>
      </li>
    </ul>
  </li>
</ul>

</ol>
</div>
<div id="leanpub-main" class="kramdown">
<blockquote>
  <p>“Love is wise; hatred is foolish. In this world, which is getting more
and more closely interconnected, we have to learn to tolerate each
other, we have to learn to put up with the fact that some people say
things that we don’t like. We can only live together in that way. But
if we are to live together, and not die together, we must learn a kind
of charity and a kind of tolerance, which is absolutely vital to the
continuation of human life on this planet.”</p>

  <p>― Bertrand Russell</p>
</blockquote>

<h2 id="leanpub-auto-about-this-book">
<a class="anchor-link" href="#leanpub-auto-about-this-book"><i class="fa fa-link"></i></a>About This Book</h2>

<p>This book is for the typical Scala developer, probably with a Java background,
who is both sceptical and curious about the <strong>Functional Programming</strong> (FP)
paradigm. This book justifies every concept with practical examples, including
writing a web application.</p>

<p>This book uses <a href="https://github.com/scalaz/scalaz">Scalaz 7.2</a>, the most popular, stable, principled and
comprehensive Functional Programming framework for Scala.</p>

<p>This book is designed to be read from cover to cover, in the order presented,
with a rest between chapters. Earlier chapters encourage coding styles that we
will later discredit: similar to how we learn Newton’s theory of gravity as
children, and progress to Riemann / Einstein / Maxwell if we become students of
physics.</p>

<p>A computer is not necessary to follow along, but studying the Scalaz source code
is encouraged. Some of the more complex code snippets are available with <a href="https://github.com/fommil/fpmortals/">the
book’s source code</a> and those who want practical exercises are encouraged to
(re-)implement Scalaz (and the example application) using the partial
descriptions presented in this book.</p>

<p>We also recommend <a href="https://www.manning.com/books/functional-programming-in-scala">The Red Book</a> as further reading. It teaches how to write an FP
library in Scala from first principles.</p>

<h2 id="leanpub-auto-copyleft-notice">
<a class="anchor-link" href="#leanpub-auto-copyleft-notice"><i class="fa fa-link"></i></a>Copyleft Notice</h2>

<p>This book is <strong>Libre</strong> and follows the philosophy of <a href="https://www.gnu.org/philosophy/free-sw.en.html">Free Software</a>: you can use
this book as you like, the <a href="https://github.com/fommil/fpmortals/">source is available</a> you can redistribute this book
and you can distribute your own version. That means you can print it, photocopy
it, e-mail it, upload it to websites, change it, translate it, charge for it,
remix it, delete bits, and draw all over it.</p>

<p>This book is <strong>Copyleft</strong>: if you change the book and distribute your own version,
you must also pass these freedoms to its recipients.</p>

<p>This book uses the <a href="https://creativecommons.org/licenses/by-sa/4.0/legalcode">Creative Commons Attribution ShareAlike 4.0 International</a> (CC
BY-SA 4.0) license.</p>

<p>All original code snippets in this book are separately <a href="https://wiki.creativecommons.org/wiki/CC0">CC0</a> licensed, you may use
them without restriction. Excerpts from Scalaz and related libraries maintain
their license, reproduced in full in the appendix.</p>

<p>The example application <code>drone-dynamic-agents</code> is distributed under the terms of
the <a href="https://www.gnu.org/licenses/gpl-3.0.en.html">GPLv3</a>: only the snippets in this book are available without restriction.</p>

<h2 id="leanpub-auto-thanks">
<a class="anchor-link" href="#leanpub-auto-thanks"><i class="fa fa-link"></i></a>Thanks</h2>

<p>Diego Esteban Alonso Blas, Raúl Raja Martínez and Peter Neyens of 47
degrees, Rúnar Bjarnason, Tony Morris, John de Goes and Edward Kmett
for their help explaining the principles of FP. Kenji Yoshida and
Jason Zaugg for being the main authors of Scalaz, and Paul Chiusano /
Miles Sabin for fixing a critical bug in the Scala compiler (<a href="https://issues.scala-lang.org/browse/SI-2712">SI-2712</a>).</p>

<p>Thanks to the readers who gave feedback on early drafts of this text.</p>

<p>Some material was particularly helpful for my own understanding of the concepts
that are in this book. Thanks to Juan Manuel Serrano for <a href="https://skillsmatter.com/skillscasts/9904-london-scala-march-meetup#video">All Roads Lead to
Lambda</a>, Pere Villega for <a href="http://perevillega.com/understanding-free-monads">On Free Monads</a>, Dick Wall and Josh Suereth for <a href="https://www.youtube.com/watch?v=WDaw2yXAa50">For:
What is it Good For?</a>, Erik Bakker for <a href="https://www.youtube.com/watch?v=hGMndafDcc8">Options in Futures, how to unsuck them</a>,
Noel Markham for <a href="https://www.47deg.com/presentations/2017/06/01/ADT-for-the-win/">ADTs for the Win!</a>, Sukant Hajra for <a href="https://www.youtube.com/watch?v=QtZJATIPB0k">Classy Monad Transformers</a>,
Luka Jacobowitz for <a href="https://lukajcb.github.io/blog/functional/2018/01/03/optimizing-tagless-final.html">Optimizing Tagless Final</a>, Vincent Marquez for <a href="https://www.youtube.com/watch?v=JPVagd9W4Lo">Index your
State</a>, Gabriel Gonzalez for <a href="http://www.haskellforall.com/2012/12/the-continuation-monad.html">The Continuation Monad</a>, and Yi Lin Wei / Zainab Ali
for their tutorials at Hack The Tower meetups.</p>

<p>The helpul souls who patiently explained things to me: Merlin Göttlinger, Edmund
Noble, Fabio Labella, Adelbert Chang, Michael Pilquist, Paul Snively, Daniel
Spiewak, Stephen Compall, Brian McKenna, Ryan Delucchi, Pedro Rodriguez, Emily
Pillmore, Aaron Vargo, Tomas Mikula, Jean-Baptiste Giraudeau, Itamar Ravid, Ross
A. Baker, Alexander Konovalov, Harrison Houghton, Alexandre Archambault,
Christopher Davenport, Jose Cardona, Isaac Elliott.</p>

<h2 id="leanpub-auto-practicalities">
<a class="anchor-link" href="#leanpub-auto-practicalities"><i class="fa fa-link"></i></a>Practicalities</h2>

<p>To set up a project that uses the libraries presented in this book, use a recent
version of Scala with FP-specific features enabled (e.g. in <code>build.sbt</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scalaVersion in ThisBuild := "2.12.6"
  scalacOptions in ThisBuild ++= Seq(
    "-language:_",
    "-Ypartial-unification",
    "-Xfatal-warnings"
  )
  
  libraryDependencies ++= Seq(
    "com.github.mpilquist" %% "simulacrum"     % "0.13.0",
    "org.scalaz"           %% "scalaz-core"    % "7.2.26"
  )
  
  addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.7")
  addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.1" cross CrossVersion.full)
</pre></div>

</figure>

<p>In order to keep our snippets short, we will omit the <code>import</code>
section. Unless told otherwise, assume that all snippets have the
following imports:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import scalaz._, Scalaz._
  import simulacrum._
</pre></div>

</figure>




<h2 id="leanpub-auto-introduction">
<a class="anchor-link" href="#leanpub-auto-introduction"><i class="fa fa-link"></i></a><span class="section-number">1. </span>Introduction</h2>

<p>It is human instinct to be sceptical of a new paradigm. To put some
perspective on how far we have come, and the shifts we have already
accepted on the JVM, let’s start with a quick recap of the last 20
years.</p>

<p>Java 1.2 introduced the Collections API, allowing us to write methods
that abstracted over mutable collections. It was useful for writing
general purpose algorithms and was the bedrock of our codebases.</p>

<p>But there was a problem, we had to perform runtime casting:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  public String first(Collection collection) {
    return (String)(collection.get(0));
  }
</pre></div>

</figure>

<p>In response, developers defined domain objects in their business logic
that were effectively <code>CollectionOfThings</code>, and the Collection API
became implementation detail.</p>

<p>In 2005, Java 5 introduced <em>generics</em>, allowing us to define
<code>Collection&lt;Thing&gt;</code>, abstracting over the container <strong>and</strong> its
elements. Generics changed how we wrote Java.</p>

<p>The author of the Java generics compiler, Martin Odersky, then created
Scala with a stronger type system, immutable data and multiple
inheritance. This brought about a fusion of object oriented (OOP) and
functional programming (FP).</p>

<p>For most developers, FP means using immutable data as much as
possible, but mutable state is still a necessary evil that must be
isolated and managed, e.g. with Akka actors or <code>synchronized</code> classes.
This style of FP results in simpler programs that are easier to
parallelise and distribute, an improvement over Java. But it is only
scratching the surface of the benefits of FP, as we will discover in
this book.</p>

<p>Scala also brings <code>Future</code>, making it easy to write asynchronous
applications. But when a <code>Future</code> makes it into a return type,
<em>everything</em> needs to be rewritten to accomodate it, including the
tests, which are now subject to arbitrary timeouts.</p>

<p>We have a problem similar to Java 1.0: there is no way of abstracting
over execution, much as we had no way of abstracting over collections.</p>

<h3 id="leanpub-auto-abstracting-over-execution">
<a class="anchor-link" href="#leanpub-auto-abstracting-over-execution"><i class="fa fa-link"></i></a><span class="section-number">1.1 </span>Abstracting over Execution</h3>

<p>Say we want to interact with the user over the command line interface. We can
<code>read</code> what the user types and we can <code>write</code> a message to them.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait TerminalSync {
    def read(): String
    def write(t: String): Unit
  }
  
  trait TerminalAsync {
    def read(): Future[String]
    def write(t: String): Future[Unit]
  }
</pre></div>

</figure>

<p>How do we write generic code that does something as simple as echo the user’s
input synchronously or asynchronously depending on our runtime implementation?</p>

<p>We could write a synchronous version and wrap it with <code>Future</code> but now
we have to worry about which thread pool we should be using for the
work, or we could <code>Await.result</code> on the <code>Future</code> and introduce thread
blocking. In either case, it is a lot of boilerplate and we are
fundamentally dealing with different APIs that are not unified.</p>

<p>We can solve the problem, like Java 1.2, with a common parent using the <em>higher
kinded types</em> (HKT) Scala language feature.</p>

<aside>
  <p><strong>Higher Kinded Types</strong> allow us to use a <em>type constructor</em> in our type
parameters, which looks like <code>C[_]</code>. This is a way of saying that
whatever <code>C</code> is, it must take a type parameter. For example:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  trait Foo[C[_]] {
    def create(i: Int): C[Int]
  }
</pre></div>

  </figure>

  <p><code>List</code> is a type constructor because it takes a type (e.g. <code>Int</code>) and constructs
a type (<code>List[Int]</code>). We can implement <code>Foo</code> using <code>List</code>:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object FooList extends Foo[List] {
    def create(i: Int): List[Int] = List(i)
  }
</pre></div>

  </figure>

  <p>We can implement <code>Foo</code> for anything with a type parameter hole, e.g.
<code>Either[String, _]</code>. Unfortunately it is a bit clunky and we have to
create a type alias to trick the compiler into accepting it:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  type EitherString[T] = Either[String, T]
</pre></div>

  </figure>

  <p>Type aliases don’t define new types, they just use substitution and
don’t provide extra type safety. The compiler substitutes
<code>EitherString[T]</code> with <code>Either[String, T]</code> everywhere. This technique
can be used to trick the compiler into accepting types with one hole
when it would otherwise think there are two, like when we implement
<code>Foo</code> with <code>EitherString</code>:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object FooEitherString extends Foo[EitherString] {
    def create(i: Int): Either[String, Int] = Right(i)
  }
</pre></div>

  </figure>

  <p>Alternatively, the <a href="https://github.com/non/kind-projector/">kind projector</a> plugin allows us to avoid the <code>type</code>
alias and use <code>?</code> syntax to tell the compiler where the type hole is:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object FooEitherString extends Foo[Either[String, ?]] {
    def create(i: Int): Either[String, Int] = Right(i)
  }
</pre></div>

  </figure>

  <p>Finally, there is this one weird trick we can use when we want to ignore the
type constructor. Define a type alias to be equal to its parameter:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  type Id[T] = T
</pre></div>

  </figure>

  <p>Before proceeding, understand that <code>Id[Int]</code> is the same thing as <code>Int</code>, by
substituting <code>Int</code> into <code>T</code>. Because <code>Id</code> is a valid type constructor we can use
<code>Id</code> in an implementation of <code>Foo</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object FooId extends Foo[Id] {
    def create(i: Int): Int = i
  }
</pre></div>

  </figure>

</aside>

<p>We want to define <code>Terminal</code> for a type constructor <code>C[_]</code>. By
defining <code>Now</code> to construct to its type parameter (like <code>Id</code>), we can
implement a common interface for synchronous and asynchronous
terminals:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Terminal[C[_]] {
    def read: C[String]
    def write(t: String): C[Unit]
  }
  
  type Now[X] = X
  
  object TerminalSync extends Terminal[Now] {
    def read: String = ???
    def write(t: String): Unit = ???
  }
  
  object TerminalAsync extends Terminal[Future] {
    def read: Future[String] = ???
    def write(t: String): Future[Unit] = ???
  }
</pre></div>

</figure>

<p>We can think of <code>C</code> as a <em>Context</em> because we say “in the context of
executing <code>Now</code>” or “in the <code>Future</code>”.</p>

<p>But we know nothing about <code>C</code> and we cannot do anything with a
<code>C[String]</code>. What we need is a kind of execution environment that lets
us call a method returning <code>C[T]</code> and then be able to do something
with the <code>T</code>, including calling another method on <code>Terminal</code>. We also
need a way of wrapping a value as a <code>C[_]</code>. This signature works well:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Execution[C[_]] {
    def chain[A, B](c: C[A])(f: A =&gt; C[B]): C[B]
    def create[B](b: B): C[B]
  }
</pre></div>

</figure>

<p>letting us write:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def echo[C[_]](t: Terminal[C], e: Execution[C]): C[String] =
    e.chain(t.read) { in: String =&gt;
      e.chain(t.write(in)) { _: Unit =&gt;
        e.create(in)
      }
    }
</pre></div>

</figure>

<p>We can now share the <code>echo</code> implementation between synchronous and
asynchronous codepaths. We can write a mock implementation of
<code>Terminal[Now]</code> and use it in our tests without any timeouts.</p>

<p>Implementations of <code>Execution[Now]</code> and <code>Execution[Future]</code> are
reusable by generic methods like <code>echo</code>.</p>

<p>But the code for <code>echo</code> is horrible!</p>

<p>The <code>implicit class</code> Scala language feature gives <code>C</code> some methods.
We will call these methods <code>flatMap</code> and <code>map</code> for reasons that will
become clearer in a moment. Each method takes an <code>implicit
Execution[C]</code>, but this is nothing more than the <code>flatMap</code> and <code>map</code>
that we’re used to on <code>Seq</code>, <code>Option</code> and <code>Future</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Execution {
    implicit class Ops[A, C[_]](c: C[A]) {
      def flatMap[B](f: A =&gt; C[B])(implicit e: Execution[C]): C[B] =
            e.chain(c)(f)
      def map[B](f: A =&gt; B)(implicit e: Execution[C]): C[B] =
            e.chain(c)(f andThen e.create)
    }
  }
  
  def echo[C[_]](implicit t: Terminal[C], e: Execution[C]): C[String] =
    t.read.flatMap { in: String =&gt;
      t.write(in).map { _: Unit =&gt;
        in
      }
    }
</pre></div>

</figure>

<p>We can now reveal why we used <code>flatMap</code> as the method name: it lets us
use a <em>for comprehension</em>, which is just syntax sugar over nested
<code>flatMap</code> and <code>map</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def echo[C[_]](implicit t: Terminal[C], e: Execution[C]): C[String] =
    for {
      in &lt;- t.read
       _ &lt;- t.write(in)
    } yield in
</pre></div>

</figure>

<p>Our <code>Execution</code> has the same signature as a trait in Scalaz called <code>Monad</code>,
except <code>chain</code> is <code>bind</code> and <code>create</code> is <code>pure</code>. We say that <code>C</code> is <em>monadic</em>
when there is an implicit <code>Monad[C]</code> available. In addition, Scalaz has the <code>Id</code>
type alias.</p>

<p>The takeaway is: if we write methods that operate on monadic types,
then we can write sequential code that abstracts over its execution
context. Here, we have shown an abstraction over synchronous and
asynchronous execution but it can also be for the purpose of more
rigorous error handling (where <code>C[_]</code> is <code>Either[Error, _]</code>), managing
access to volatile state, performing I/O, or auditing of the session.</p>

<h3 id="leanpub-auto-pure-functional-programming">
<a class="anchor-link" href="#leanpub-auto-pure-functional-programming"><i class="fa fa-link"></i></a><span class="section-number">1.2 </span>Pure Functional Programming</h3>

<p>Functional Programming is the act of writing programs with <em>pure functions</em>.
Pure functions have three properties:</p>

<ul>
  <li>
<strong>Total</strong>: return a value for every possible input</li>
  <li>
<strong>Deterministic</strong>: return the same value for the same input</li>
  <li>
<strong>Inculpable</strong>: no (direct) interaction with the world or program state.</li>
</ul>

<p>Together, these properties give us an unprecedented ability to reason about our
code. For example, input validation is easier to isolate with totality, caching
is possible when functions are deterministic, and interacting with the world is
easier to control, and test, when functions are inculpable.</p>

<p>The kinds of things that break these properties are <em>side effects</em>: directly
accessing or changing mutable state (e.g. maintaining a <code>var</code> in a class or
using a legacy API that is impure), communicating with external resources (e.g.
files or network lookup), or throwing and catching exceptions.</p>

<p>We write pure functions by avoiding exceptions, and interacting with the world
only through a safe <code>F[_]</code> execution context.</p>

<p>In the previous section, we abstracted over execution and defined <code>echo[Id]</code> and
<code>echo[Future]</code>. We might reasonably expect that calling any <code>echo</code> will not
perform any side effects, because it is pure. However, if we use <code>Future</code> or
<code>Id</code> as the execution context, our application will start listening to stdin:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val futureEcho: Future[String] = echo[Future]
</pre></div>

</figure>

<p>We have broken purity and are no longer writing FP code: <code>futureEcho</code> is the
result of running <code>echo</code> once. <code>Future</code> conflates the definition of a program
with <em>interpreting</em> it (running it). As a result, applications built with
<code>Future</code> are difficult to reason about.</p>

<aside>
  <p>An expression is <em>referentially transparent</em> if it can be replaced with its
corresponding value without changing the program’s behaviour.</p>

  <p>Pure functions are referentially transparent, allowing for a great deal of code
reuse, performance optimisation, understanding, and control of a program.</p>

  <p>Impure functions are not referentially transparent. We cannot replace
<code>echo[Future]</code> with a value, such as <code>val futureEcho</code>, since the pesky user can
type something different the second time.</p>

</aside>

<p>We can define a simple safe <code>F[_]</code> execution context</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class IO[A](val interpret: () =&gt; A) {
    def map[B](f: A =&gt; B): IO[B] = IO(f(interpret()))
    def flatMap[B](f: A =&gt; IO[B]): IO[B] = IO(f(interpret()).interpret())
  }
  object IO {
    def apply[A](a: =&gt;A): IO[A] = new IO(() =&gt; a)
  }
</pre></div>

</figure>

<p>which lazily evaluates a thunk. <code>IO</code> is just a data structure that references
(potentially) impure code, it isn’t actually running anything. We can implement
<code>Terminal[IO]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object TerminalIO extends Terminal[IO] {
    def read: IO[String]           = IO { io.StdIn.readLine }
    def write(t: String): IO[Unit] = IO { println(t) }
  }
</pre></div>

</figure>

<p>and call <code>echo[IO]</code> to get back a value</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val delayed: IO[String] = echo[IO]
</pre></div>

</figure>

<p>This <code>val delayed</code> can be reused, it is just the definition of the work to be
done. We can map the <code>String</code> and compose additional programs, much as we would
map over a <code>Future</code>. <code>IO</code> keeps us honest that we are depending on some
interaction with the world, but does not prevent us from accessing the output of
that interaction.</p>

<p>The impure code inside the <code>IO</code> is only evaluated when we <code>.interpret()</code> the
value, which is an impure action</p>

<figure class="code">
<div class="highlight"><pre><code></code>  delayed.interpret()
</pre></div>

</figure>

<p>An application composed of <code>IO</code> programs is only interpreted once, in the <code>main</code>
method, which is also called <em>the end of the world</em>.</p>

<p>In this book, we expand on the concepts introduced in this chapter and show how
to write maintainable, pure functions, that achieve our business’s objectives.</p>


<h2 id="leanpub-auto-for-comprehensions">
<a class="anchor-link" href="#leanpub-auto-for-comprehensions"><i class="fa fa-link"></i></a><span class="section-number">2. </span>For Comprehensions</h2>

<p>Scala’s <code>for</code> comprehension is the ideal FP abstraction for sequential
programs that interact with the world. Since we will be using it a lot,
we’re going to relearn the principles of <code>for</code> and how Scalaz can help
us to write cleaner code.</p>

<p>This chapter doesn’t try to write pure programs and the techniques are
applicable to non-FP codebases.</p>

<h3 id="leanpub-auto-syntax-sugar">
<a class="anchor-link" href="#leanpub-auto-syntax-sugar"><i class="fa fa-link"></i></a><span class="section-number">2.1 </span>Syntax Sugar</h3>

<p>Scala’s <code>for</code> is just a simple rewrite rule, also called <em>syntax
sugar</em>, that doesn’t have any contextual information.</p>

<p>To see what a <code>for</code> comprehension is doing, we use the <code>show</code> and
<code>reify</code> feature in the REPL to print out what code looks like after
type inference.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import scala.reflect.runtime.universe._
  scala&gt; val a, b, c = Option(1)
  scala&gt; show { reify {
           for { i &lt;- a ; j &lt;- b ; k &lt;- c } yield (i + j + k)
         } }
  
  res:
  $read.a.flatMap(
    ((i) =&gt; $read.b.flatMap(
      ((j) =&gt; $read.c.map(
        ((k) =&gt; i.$plus(j).$plus(k)))))))
</pre></div>

</figure>

<p>There is a lot of noise due to additional sugarings (e.g. <code>+</code> is
rewritten <code>$plus</code>, etc). We will skip the <code>show</code> and <code>reify</code> for brevity
when the REPL line is <code>reify&gt;</code>, and manually clean up the generated
code so that it doesn’t become a distraction.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for { i &lt;- a ; j &lt;- b ; k &lt;- c } yield (i + j + k)
  
  a.flatMap {
    i =&gt; b.flatMap {
      j =&gt; c.map {
        k =&gt; i + j + k }}}
</pre></div>

</figure>

<p>The rule of thumb is that every <code>&lt;-</code> (called a <em>generator</em>) is a
nested <code>flatMap</code> call, with the final generator a <code>map</code> containing the
<code>yield</code> body.</p>

<h4 id="leanpub-auto-assignment">
<a class="anchor-link" href="#leanpub-auto-assignment"><i class="fa fa-link"></i></a><span class="section-number">2.1.1 </span>Assignment</h4>

<p>We can assign values inline like <code>ij = i + j</code> (a <code>val</code> keyword is not
needed).</p>

<figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for {
           i &lt;- a
           j &lt;- b
           ij = i + j
           k &lt;- c
         } yield (ij + k)
  
  a.flatMap {
    i =&gt; b.map { j =&gt; (j, i + j) }.flatMap {
      case (j, ij) =&gt; c.map {
        k =&gt; ij + k }}}
</pre></div>

</figure>

<p>A <code>map</code> over the <code>b</code> introduces the <code>ij</code> which is flat-mapped along
with the <code>j</code>, then the final <code>map</code> for the code in the <code>yield</code>.</p>

<p>Unfortunately we cannot assign before any generators. It has been
requested as a language feature but has not been implemented:
<a href="https://github.com/scala/bug/issues/907">https://github.com/scala/bug/issues/907</a></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; for {
           initial = getDefault
           i &lt;- a
         } yield initial + i
  &lt;console&gt;:1: error: '&lt;-' expected but '=' found.
</pre></div>

</figure>

<p>We can workaround the limitation by defining a <code>val</code> outside the <code>for</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val initial = getDefault
  scala&gt; for { i &lt;- a } yield initial + i
</pre></div>

</figure>

<p>or create an <code>Option</code> out of the initial assignment</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; for {
           initial &lt;- Option(getDefault)
           i &lt;- a
         } yield initial + i
</pre></div>

</figure>

<aside>
  <p><code>val</code> doesn’t have to assign to a single value, it can be anything
that works as a <code>case</code> in a pattern match.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val (first, second) = ("hello", "world")
  first: String = hello
  second: String = world
  
  scala&gt; val list: List[Int] = ...
  scala&gt; val head :: tail = list
  head: Int = 1
  tail: List[Int] = List(2, 3)
</pre></div>

  </figure>

  <p>The same is true for assignment in <code>for</code> comprehensions</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val maybe = Option(("hello", "world"))
  scala&gt; for {
           entry &lt;- maybe
           (first, _) = entry
         } yield first
  res: Some(hello)
</pre></div>

  </figure>

  <p>But be careful not to miss any cases or there will be a runtime exception (a
<em>totality</em> failure).</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val a :: tail = list
  caught scala.MatchError: List()
</pre></div>

  </figure>

</aside>

<h4 id="leanpub-auto-filter">
<a class="anchor-link" href="#leanpub-auto-filter"><i class="fa fa-link"></i></a><span class="section-number">2.1.2 </span>Filter</h4>

<p>It is possible to put <code>if</code> statements after a generator to filter
values by a predicate</p>

<figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for {
           i  &lt;- a
           j  &lt;- b
           if i &gt; j
           k  &lt;- c
         } yield (i + j + k)
  
  a.flatMap {
    i =&gt; b.withFilter {
      j =&gt; i &gt; j }.flatMap {
        j =&gt; c.map {
          k =&gt; i + j + k }}}
</pre></div>

</figure>

<p>Older versions of Scala used <code>filter</code>, but <code>Traversable.filter</code> creates new
collections for every predicate, so <code>withFilter</code> was introduced as the more
performant alternative. We can accidentally trigger a <code>withFilter</code> by providing
type information, interpreted as a pattern match.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for { i: Int &lt;- a } yield i
  
  a.withFilter {
    case i: Int =&gt; true
    case _      =&gt; false
  }.map { case i: Int =&gt; i }
</pre></div>

</figure>

<p>Like assignment, a generator can use a pattern match on the left hand side. But
unlike assignment (which throws <code>MatchError</code> on failure), generators are
<em>filtered</em> and will not fail at runtime. However, there is an inefficient double
application of the pattern.</p>

<aside>
  <p>The compiler plugin <a href="https://github.com/oleg-py/better-monadic-for"><code>better-monadic-for</code></a> produces alternative, <strong>better</strong>,
desugarings than the Scala compiler. This example is interpreted as:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for { i: Int &lt;- a } yield i
  
  a.map { (i: Int) =&gt; i}
</pre></div>

  </figure>

  <p>instead of inefficient double matching (in the best case) and silent filtering
at runtime (in the worst case). Highly recommended.</p>

</aside>

<h4 id="leanpub-auto-for-each">
<a class="anchor-link" href="#leanpub-auto-for-each"><i class="fa fa-link"></i></a><span class="section-number">2.1.3 </span>For Each</h4>

<p>Finally, if there is no <code>yield</code>, the compiler will use <code>foreach</code>
instead of <code>flatMap</code>, which is only useful for side-effects.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  reify&gt; for { i &lt;- a ; j &lt;- b } println(s"$i $j")
  
  a.foreach { i =&gt; b.foreach { j =&gt; println(s"$i $j") } }
</pre></div>

</figure>

<h4 id="leanpub-auto-summary">
<a class="anchor-link" href="#leanpub-auto-summary"><i class="fa fa-link"></i></a><span class="section-number">2.1.4 </span>Summary</h4>

<p>The full set of methods supported by <code>for</code> comprehensions do not share
a common super type; each generated snippet is independently compiled.
If there were a trait, it would roughly look like:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait ForComprehensible[C[_]] {
    def map[A, B](f: A =&gt; B): C[B]
    def flatMap[A, B](f: A =&gt; C[B]): C[B]
    def withFilter[A](p: A =&gt; Boolean): C[A]
    def foreach[A](f: A =&gt; Unit): Unit
  }
</pre></div>

</figure>

<p>If the context (<code>C[_]</code>) of a <code>for</code> comprehension doesn’t provide its
own <code>map</code> and <code>flatMap</code>, all is not lost. If an implicit
<code>scalaz.Bind[T]</code> is available for <code>T</code>, it will provide <code>map</code> and
<code>flatMap</code>.</p>

<aside>
  <p>It often surprises developers when inline <code>Future</code> calculations in a
<code>for</code> comprehension do not run in parallel:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  import scala.concurrent._
  import ExecutionContext.Implicits.global
  
  for {
    i &lt;- Future { expensiveCalc() }
    j &lt;- Future { anotherExpensiveCalc() }
  } yield (i + j)
</pre></div>

  </figure>

  <p>This is because the <code>flatMap</code> spawning <code>anotherExpensiveCalc</code> is
strictly <strong>after</strong> <code>expensiveCalc</code>. To ensure that two <code>Future</code>
calculations begin in parallel, start them outside the <code>for</code>
comprehension.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  val a = Future { expensiveCalc() }
  val b = Future { anotherExpensiveCalc() }
  for { i &lt;- a ; j &lt;- b } yield (i + j)
</pre></div>

  </figure>

  <p><code>for</code> comprehensions are fundamentally for defining sequential
programs. We will show a far superior way of defining parallel
computations in a later chapter. Spoiler: don’t use <code>Future</code>.</p>

</aside>

<h3 id="leanpub-auto-unhappy-path">
<a class="anchor-link" href="#leanpub-auto-unhappy-path"><i class="fa fa-link"></i></a><span class="section-number">2.2 </span>Unhappy path</h3>

<p>So far we’ve only looked at the rewrite rules, not what is happening in <code>map</code>
and <code>flatMap</code>. Consider what happens when the <code>for</code> context decides that it
cannot proceed any further.</p>

<p>In the <code>Option</code> example, the <code>yield</code> is only called when <code>i,j,k</code> are
all defined.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    i &lt;- a
    j &lt;- b
    k &lt;- c
  } yield (i + j + k)
</pre></div>

</figure>

<p>If any of <code>a,b,c</code> are <code>None</code>, the comprehension short-circuits with
<code>None</code> but it doesn’t tell us what went wrong.</p>

<aside>
  <p>There are many functions in the wild that take <code>Option</code> parameters but actually
require all parameters to exist. An alternative to throwing a runtime exception
is to use a <code>for</code> comprehension, giving us totality (a return value for every
input):</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def namedThings(
    someName  : Option[String],
    someNumber: Option[Int]
  ): Option[String] = for {
    name   &lt;- someName
    number &lt;- someNumber
  } yield s"$number ${name}s"
</pre></div>

  </figure>

  <p>but this is verbose, clunky and bad style. If a function requires
every input then it should make its requirement explicit, pushing the
responsibility of dealing with optional parameters to its caller.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def namedThings(name: String, num: Int) = s"$num ${name}s"
</pre></div>

  </figure>

</aside>

<p>If we use <code>Either</code>, then a <code>Left</code> will cause the <code>for</code> comprehension
to short circuit with extra information, much better than <code>Option</code> for
error reporting:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val a = Right(1)
  scala&gt; val b = Right(2)
  scala&gt; val c: Either[String, Int] = Left("sorry, no c")
  scala&gt; for { i &lt;- a ; j &lt;- b ; k &lt;- c } yield (i + j + k)
  
  Left(sorry, no c)
</pre></div>

</figure>

<p>And lastly, let’s see what happens with a <code>Future</code> that fails:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import scala.concurrent._
  scala&gt; import ExecutionContext.Implicits.global
  scala&gt; for {
           i &lt;- Future.failed[Int](new Throwable)
           j &lt;- Future { println("hello") ; 1 }
         } yield (i + j)
  scala&gt; Await.result(f, duration.Duration.Inf)
  caught java.lang.Throwable
</pre></div>

</figure>

<p>The <code>Future</code> that prints to the terminal is never called because, like
<code>Option</code> and <code>Either</code>, the <code>for</code> comprehension short circuits.</p>

<p>Short circuiting for the unhappy path is a common and important theme.
<code>for</code> comprehensions cannot express resource cleanup: there is no way
to <code>try</code> / <code>finally</code>. This is good, in FP it puts a clear ownership of
responsibility for unexpected error recovery and resource cleanup onto
the context (which is usually a <code>Monad</code> as we will see later), not the
business logic.</p>

<h3 id="leanpub-auto-gymnastics">
<a class="anchor-link" href="#leanpub-auto-gymnastics"><i class="fa fa-link"></i></a><span class="section-number">2.3 </span>Gymnastics</h3>

<p>Although it is easy to rewrite simple sequential code as a <code>for</code>
comprehension, sometimes we will want to do something that appears to
require mental summersaults. This section collects some practical
examples and how to deal with them.</p>

<h4 id="leanpub-auto-fallback-logic">
<a class="anchor-link" href="#leanpub-auto-fallback-logic"><i class="fa fa-link"></i></a><span class="section-number">2.3.1 </span>Fallback Logic</h4>

<p>Say we are calling out to a method that returns an <code>Option</code>. If it is not
successful we want to fallback to another method (and so on and so on), like
when we’re using a cache:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getFromRedis(s: String): Option[String]
  def getFromSql(s: String): Option[String]
  
  getFromRedis(key) orElse getFromSql(key)
</pre></div>

</figure>

<p>If we have to do this for an asynchronous version of the same API</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getFromRedis(s: String): Future[Option[String]]
  def getFromSql(s: String): Future[Option[String]]
</pre></div>

</figure>

<p>then we have to be careful not to do extra work because</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    cache &lt;- getFromRedis(key)
    sql   &lt;- getFromSql(key)
  } yield cache orElse sql
</pre></div>

</figure>

<p>will run both queries. We can pattern match on the first result but
the type is wrong</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    cache &lt;- getFromRedis(key)
    res   &lt;- cache match {
               case Some(_) =&gt; cache !!! wrong type !!!
               case None    =&gt; getFromSql(key)
             }
  } yield res
</pre></div>

</figure>

<p>We need to create a <code>Future</code> from the <code>cache</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    cache &lt;- getFromRedis(key)
    res   &lt;- cache match {
               case Some(_) =&gt; Future.successful(cache)
               case None    =&gt; getFromSql(key)
             }
  } yield res
</pre></div>

</figure>

<p><code>Future.successful</code> creates a new <code>Future</code>, much like an <code>Option</code> or
<code>List</code> constructor.</p>

<h4 id="leanpub-auto-early-exit">
<a class="anchor-link" href="#leanpub-auto-early-exit"><i class="fa fa-link"></i></a><span class="section-number">2.3.2 </span>Early Exit</h4>

<p>Say we have some condition that should exit early with a successful value.</p>

<p>If we want to exit early with an error, it is standard practice in OOP to throw
an exception</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getA: Int = ...
  
  val a = getA
  require(a &gt; 0, s"$a must be positive")
  a * 10
</pre></div>

</figure>

<p>which can be rewritten async</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getA: Future[Int] = ...
  def error(msg: String): Future[Nothing] =
    Future.failed(new RuntimeException(msg))
  
  for {
    a &lt;- getA
    b &lt;- if (a &lt;= 0) error(s"$a must be positive")
         else Future.successful(a)
  } yield b * 10
</pre></div>

</figure>

<p>But if we want to exit early with a successful return value, the simple
synchronous code:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getB: Int = ...
  
  val a = getA
  if (a &lt;= 0) 0
  else a * getB
</pre></div>

</figure>

<p>translates into a nested <code>for</code> comprehension when our dependencies are
asynchronous:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def getB: Future[Int] = ...
  
  for {
    a &lt;- getA
    c &lt;- if (a &lt;= 0) Future.successful(0)
         else for { b &lt;- getB } yield a * b
  } yield c
</pre></div>

</figure>

<aside>
  <p>If there is an implicit <code>Monad[T]</code> for <code>T[_]</code> (i.e. <code>T</code> is monadic) then Scalaz
lets us create a <code>T[A]</code> from a value <code>a: A</code> by calling <code>a.pure[T]</code>.</p>

  <p>Scalaz provides <code>Monad[Future]</code>, and <code>.pure[Future]</code> calls <code>Future.successful</code>.
Besides <code>pure</code> being slightly shorter to type, it is a general concept that
works beyond <code>Future</code>, and is therefore recommended.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  for {
    a &lt;- getA
    c &lt;- if (a &lt;= 0) 0.pure[Future]
         else for { b &lt;- getB } yield a * b
  } yield c
</pre></div>

  </figure>

</aside>

<h3 id="leanpub-auto-incomprehensible">
<a class="anchor-link" href="#leanpub-auto-incomprehensible"><i class="fa fa-link"></i></a><span class="section-number">2.4 </span>Incomprehensible</h3>

<p>The context we’re comprehending over must stay the same: we cannot mix
contexts.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def option: Option[Int] = ...
  scala&gt; def future: Future[Int] = ...
  scala&gt; for {
           a &lt;- option
           b &lt;- future
         } yield a * b
  &lt;console&gt;:23: error: type mismatch;
   found   : Future[Int]
   required: Option[?]
           b &lt;- future
                ^
</pre></div>

</figure>

<p>Nothing can help us mix arbitrary contexts in a <code>for</code> comprehension
because the meaning is not well defined.</p>

<p>But when we have nested contexts the intention is usually obvious yet
the compiler still doesn’t accept our code.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def getA: Future[Option[Int]] = ...
  scala&gt; def getB: Future[Option[Int]] = ...
  scala&gt; for {
           a &lt;- getA
           b &lt;- getB
         } yield a * b
                   ^
  &lt;console&gt;:30: error: value * is not a member of Option[Int]
</pre></div>

</figure>

<p>Here we want <code>for</code> to take care of the outer context and let us write
our code on the inner <code>Option</code>. Hiding the outer context is exactly
what a <em>monad transformer</em> does, and Scalaz provides implementations
for <code>Option</code> and <code>Either</code> named <code>OptionT</code> and <code>EitherT</code> respectively.</p>

<p>The outer context can be anything that normally works in a <code>for</code>
comprehension, but it needs to stay the same throughout.</p>

<p>We create an <code>OptionT</code> from each method call. This changes the context
of the <code>for</code> from <code>Future[Option[_]]</code> to <code>OptionT[Future, _]</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
         } yield a * b
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
</pre></div>

</figure>

<p><code>.run</code> returns us to the original context</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; result.run
  res: Future[Option[Int]] = Future(&lt;not completed&gt;)
</pre></div>

</figure>

<p>The monad transformer also allows us to mix <code>Future[Option[_]]</code> calls with
methods that just return plain <code>Future</code> via <code>.liftM[OptionT]</code> (provided by
scalaz):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def getC: Future[Int] = ...
  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
           c &lt;- getC.liftM[OptionT]
         } yield a * b / c
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
</pre></div>

</figure>

<p>and we can mix with methods that return plain <code>Option</code> by wrapping
them in <code>Future.successful</code> (<code>.pure[Future]</code>) followed by <code>OptionT</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def getD: Option[Int] = ...
  scala&gt; val result = for {
           a &lt;- OptionT(getA)
           b &lt;- OptionT(getB)
           c &lt;- getC.liftM[OptionT]
           d &lt;- OptionT(getD.pure[Future])
         } yield (a * b) / (c * d)
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
</pre></div>

</figure>

<p>It is messy again, but it is better than writing nested <code>flatMap</code> and
<code>map</code> by hand. We can clean it up with a DSL that handles all the
required conversions into <code>OptionT[Future, _]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftFutureOption[A](f: Future[Option[A]]) = OptionT(f)
  def liftFuture[A](f: Future[A]) = f.liftM[OptionT]
  def liftOption[A](o: Option[A]) = OptionT(o.pure[Future])
  def lift[A](a: A)               = liftOption(Option(a))
</pre></div>

</figure>

<p>combined with the <code>|&gt;</code> operator, which applies the function on the
right to the value on the left, to visually separate the logic from
the transformers</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val result = for {
           a &lt;- getA       |&gt; liftFutureOption
           b &lt;- getB       |&gt; liftFutureOption
           c &lt;- getC       |&gt; liftFuture
           d &lt;- getD       |&gt; liftOption
           e &lt;- 10         |&gt; lift
         } yield e * (a * b) / (c * d)
  result: OptionT[Future, Int] = OptionT(Future(&lt;not completed&gt;))
</pre></div>

</figure>

<aside>
  <p><code>|&gt;</code> is often called the <em>thrush operator</em> because of its uncanny resemblance to
the cute bird. Those who do not like symbolic operators can use the alias
<code>.into</code>.</p>

</aside>

<p>This approach also works for <code>Either</code> (and others) as the inner context, but
their lifting methods are more complex and require parameters. Scalaz provides
monad transformers for a lot of its own types, so it is worth checking if one is
available.</p>

<h2 id="leanpub-auto-application-design">
<a class="anchor-link" href="#leanpub-auto-application-design"><i class="fa fa-link"></i></a><span class="section-number">3. </span>Application Design</h2>

<p>In this chapter we will write the business logic and tests for a purely
functional server application. The source code for this application is included
under the <code>example</code> directory along with the book’s source, however it is
recommended not to read the source code until the final chapter as there will be
significant refactors as we learn more about FP.</p>

<h3 id="leanpub-auto-specification">
<a class="anchor-link" href="#leanpub-auto-specification"><i class="fa fa-link"></i></a><span class="section-number">3.1 </span>Specification</h3>

<p>Our application will manage a just-in-time build farm on a shoestring
budget. It will listen to a <a href="https://github.com/drone/drone">Drone</a> Continuous Integration server, and
spawn worker agents using <a href="https://cloud.google.com/container-engine/">Google Container Engine</a> (GKE) to meet the
demand of the work queue.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/architecture.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Drone receives work when a contributor submits a github pull request
to a managed project. Drone assigns the work to its agents, each
processing one job at a time.</p>

<p>The goal of our app is to ensure that there are enough agents to
complete the work, with a cap on the number of agents, whilst
minimising the total cost. Our app needs to know the number of items
in the <em>backlog</em> and the number of available <em>agents</em>.</p>

<p>Google can spawn <em>nodes</em>, each can host multiple drone agents. When an
agent starts up, it registers itself with drone and drone takes care
of the lifecycle (including keep-alive calls to detect removed
agents).</p>

<p>GKE charges a fee per minute of uptime, rounded up to the nearest hour
for each node. One does not simply spawn a new node for each job in
the work queue, we must re-use nodes and retain them until their 58th
minute to get the most value for money.</p>

<p>Our app needs to be able to start and stop nodes, as well as check
their status (e.g. uptimes, list of inactive nodes) and to know what
time GKE believes it to be.</p>

<p>In addition, there is no API to talk directly to an <em>agent</em> so we do
not know if any individual agent is performing any work for the drone
server. If we accidentally stop an agent whilst it is performing work,
it is inconvenient and requires a human to restart the job.</p>

<p>Contributors can manually add agents to the farm, so counting agents
and nodes is not equivalent. We don’t need to supply any nodes if
there are agents available.</p>

<p>The failure mode should always be to take the least costly option.</p>

<p>Both Drone and GKE have a JSON over REST API with OAuth 2.0
authentication.</p>

<h3 id="leanpub-auto-interfaces--algebras">
<a class="anchor-link" href="#leanpub-auto-interfaces--algebras"><i class="fa fa-link"></i></a><span class="section-number">3.2 </span>Interfaces / Algebras</h3>

<p>We will now codify the architecture diagram from the previous section. Firstly,
we need to define a simple data type to capture a millisecond timestamp because
such a simple thing does not exist in either the Java or Scala standard
libraries:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import scala.concurrent.duration._
  
  final case class Epoch(millis: Long) extends AnyVal {
    def +(d: FiniteDuration): Epoch = Epoch(millis + d.toMillis)
    def -(e: Epoch): FiniteDuration = (millis - e.millis).millis
  }
</pre></div>

</figure>

<p>In FP, an <em>algebra</em> takes the place of an <code>interface</code> in Java, or the
set of valid messages for an <code>Actor</code> in Akka. This is the layer where
we define all side-effecting interactions of our system.</p>

<p>There is tight iteration between writing the business logic and the
algebra: it is a good level of abstraction to design a system.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Drone[F[_]] {
    def getBacklog: F[Int]
    def getAgents: F[Int]
  }
  
  final case class MachineNode(id: String)
  trait Machines[F[_]] {
    def getTime: F[Epoch]
    def getManaged: F[NonEmptyList[MachineNode]]
    def getAlive: F[Map[MachineNode, Epoch]]
    def start(node: MachineNode): F[MachineNode]
    def stop(node: MachineNode): F[MachineNode]
  }
</pre></div>

</figure>

<p>We’ve used <code>NonEmptyList</code>, easily created by calling <code>.toNel</code> on the
stdlib’s <code>List</code> (returning an <code>Option[NonEmptyList]</code>), otherwise
everything should be familiar.</p>

<aside>
  <p>It is good practice in FP to encode constraints in parameters <strong>and</strong> return types
— it means we never need to handle situations that are impossible. However,
this often conflicts with <em>Postel’s law</em> “be liberal in what you accept from
others”.</p>

  <p>Although we agree that parameters should be as general as possible, we do not
agree that a function should take <code>Seq</code> unless it can handle empty <code>Seq</code>,
otherwise the only course of action would be to exception, breaking totality and
causing a side effect.</p>

  <p>We prefer <code>NonEmptyList</code>, not because it is a <code>List</code>, but because of its
non-empty property. When we learn about Scalaz’s typeclass hierarchy, we will
see a better way to request non-emptyness.</p>

</aside>

<h3 id="leanpub-auto-business-logic">
<a class="anchor-link" href="#leanpub-auto-business-logic"><i class="fa fa-link"></i></a><span class="section-number">3.3 </span>Business Logic</h3>

<p>Now we write the business logic that defines the application’s
behaviour, considering only the happy path.</p>

<p>We need a <code>WorldView</code> class to hold a snapshot of our knowledge of the
world. If we were designing this application in Akka, <code>WorldView</code>
would probably be a <code>var</code> in a stateful <code>Actor</code>.</p>

<p><code>WorldView</code> aggregates the return values of all the methods in the
algebras, and adds a <em>pending</em> field to track unfulfilled requests.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class WorldView(
    backlog: Int,
    agents: Int,
    managed: NonEmptyList[MachineNode],
    alive: Map[MachineNode, Epoch],
    pending: Map[MachineNode, Epoch],
    time: Epoch
  )
</pre></div>

</figure>

<p>Now we are ready to write our business logic, but we need to indicate
that we depend on <code>Drone</code> and <code>Machines</code>.</p>

<p>We can write the interface for the business logic</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait DynAgents[F[_]] {
    def initial: F[WorldView]
    def update(old: WorldView): F[WorldView]
    def act(world: WorldView): F[WorldView]
  }
</pre></div>

</figure>

<p>and implement it with a <em>module</em>. A module depends only on other modules,
algebras and pure functions, and can be abstracted over <code>F</code>. If an
implementation of an algebraic interface is tied to a specific type, e.g. <code>IO</code>,
it is called an <em>interpreter</em>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class DynAgentsModule[F[_]: Monad](D: Drone[F], M: Machines[F])
    extends DynAgents[F] {
</pre></div>

</figure>

<p>The <code>Monad</code> context bound means that <code>F</code> is <em>monadic</em>, allowing us to use <code>map</code>,
<code>pure</code> and, of course, <code>flatMap</code> via <code>for</code> comprehensions.</p>

<p>We have access to the algebra of <code>Drone</code> and <code>Machines</code> as <code>D</code> and <code>M</code>,
respectively. Using a single capital letter name is a common naming convention
for monad and algebra implementations.</p>

<p>Our business logic will run in an infinite loop (pseudocode)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  state = initial()
  while True:
    state = update(state)
    state = act(state)
</pre></div>

</figure>

<h4 id="leanpub-auto-initial">
<a class="anchor-link" href="#leanpub-auto-initial"><i class="fa fa-link"></i></a><span class="section-number">3.3.1 </span>initial</h4>

<p>In <code>initial</code> we call all external services and aggregate their results
into a <code>WorldView</code>. We default the <code>pending</code> field to an empty <code>Map</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def initial: F[WorldView] = for {
    db &lt;- D.getBacklog
    da &lt;- D.getAgents
    mm &lt;- M.getManaged
    ma &lt;- M.getAlive
    mt &lt;- M.getTime
  } yield WorldView(db, da, mm, ma, Map.empty, mt)
</pre></div>

</figure>

<p>Recall from Chapter 1 that <code>flatMap</code> (i.e. when we use the <code>&lt;-</code>
generator) allows us to operate on a value that is computed at
runtime. When we return an <code>F[_]</code> we are returning another program to
be interpreted at runtime, that we can then <code>flatMap</code>. This is how we
safely chain together sequential side-effecting code, whilst being
able to provide a pure implementation for tests. FP could be described
as Extreme Mocking.</p>

<h4 id="leanpub-auto-update">
<a class="anchor-link" href="#leanpub-auto-update"><i class="fa fa-link"></i></a><span class="section-number">3.3.2 </span>update</h4>

<p><code>update</code> should call <code>initial</code> to refresh our world view, preserving
known <code>pending</code> actions.</p>

<p>If a node has changed state, we remove it from <code>pending</code> and if a
pending action is taking longer than 10 minutes to do anything, we
assume that it failed and forget that we asked to do it.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def update(old: WorldView): F[WorldView] = for {
    snap &lt;- initial
    changed = symdiff(old.alive.keySet, snap.alive.keySet)
    pending = (old.pending -- changed).filterNot {
      case (_, started) =&gt; (snap.time - started) &gt;= 10.minutes
    }
    update = snap.copy(pending = pending)
  } yield update
  
  private def symdiff[T](a: Set[T], b: Set[T]): Set[T] =
    (a union b) -- (a intersect b)
</pre></div>

</figure>

<p>Concrete functions like <code>.symdiff</code> don’t need test interpreters, they have
explicit inputs and outputs, so we could move all pure code into standalone
methods on a stateless <code>object</code>, testable in isolation. We’re happy testing only
the public methods, preferring that our business logic is easy to read.</p>

<h4 id="leanpub-auto-act">
<a class="anchor-link" href="#leanpub-auto-act"><i class="fa fa-link"></i></a><span class="section-number">3.3.3 </span>act</h4>

<p>The <code>act</code> method is slightly more complex, so we will split it into two
parts for clarity: detection of when an action needs to be taken,
followed by taking action. This simplification means that we can only
perform one action per invocation, but that is reasonable because we
can control the invocations and may choose to re-run <code>act</code> until no
further action is taken.</p>

<p>We write the scenario detectors as extractors for <code>WorldView</code>, which
is nothing more than an expressive way of writing <code>if</code> / <code>else</code>
conditions.</p>

<p>We need to add agents to the farm if there is a backlog of work, we
have no agents, we have no nodes alive, and there are no pending
actions. We return a candidate node that we would like to start:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private object NeedsAgent {
    def unapply(world: WorldView): Option[MachineNode] = world match {
      case WorldView(backlog, 0, managed, alive, pending, _)
           if backlog &gt; 0 &amp;&amp; alive.isEmpty &amp;&amp; pending.isEmpty
             =&gt; Option(managed.head)
      case _ =&gt; None
    }
  }
</pre></div>

</figure>

<p>If there is no backlog, we should stop all nodes that have become stale (they
are not doing any work). However, since Google charge per hour we only shut down
machines in their 58th minute to get the most out of our money. We return the
non-empty list of nodes to stop.</p>

<p>As a financial safety net, all nodes should have a maximum lifetime of
5 hours.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private object Stale {
    def unapply(world: WorldView): Option[NonEmptyList[MachineNode]] = world match {
      case WorldView(backlog, _, _, alive, pending, time) if alive.nonEmpty =&gt;
        (alive -- pending.keys).collect {
          case (n, started) if backlog == 0 &amp;&amp; (time - started).toMinutes % 60 &gt;= 58 =&gt; n
          case (n, started) if (time - started) &gt;= 5.hours =&gt; n
        }.toList.toNel
  
      case _ =&gt; None
    }
  }
</pre></div>

</figure>

<p>Now that we have detected the scenarios that can occur, we can write
the <code>act</code> method. When we schedule a node to be started or stopped, we
add it to <code>pending</code> noting the time that we scheduled the action.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def act(world: WorldView): F[WorldView] = world match {
    case NeedsAgent(node) =&gt;
      for {
        _ &lt;- M.start(node)
        update = world.copy(pending = Map(node -&gt; world.time))
      } yield update
  
    case Stale(nodes) =&gt;
      nodes.foldLeftM(world) { (world, n) =&gt;
        for {
          _ &lt;- M.stop(n)
          update = world.copy(pending = world.pending + (n -&gt; world.time))
        } yield update
      }
  
    case _ =&gt; world.pure[F]
  }
</pre></div>

</figure>

<p>Because <code>NeedsAgent</code> and <code>Stale</code> do not cover all possible situations,
we need a catch-all <code>case _</code> to do nothing. Recall from Chapter 2 that
<code>.pure</code> creates the <code>for</code>’s (monadic) context from a value.</p>

<p><code>foldLeftM</code> is like <code>foldLeft</code>, but each iteration of the fold may return a
monadic value. In our case, each iteration of the fold returns <code>F[WorldView]</code>.
The <code>M</code> is for Monadic. We will find more of these <em>lifted</em> methods that behave
as one would expect, taking monadic values in place of values.</p>

<h3 id="leanpub-auto-unit-tests">
<a class="anchor-link" href="#leanpub-auto-unit-tests"><i class="fa fa-link"></i></a><span class="section-number">3.4 </span>Unit Tests</h3>

<p>The FP approach to writing applications is a designer’s dream: delegate writing
the implementations of algebras to team members while focusing on making
business logic meet the requirements.</p>

<p>Our application is highly dependent on timing and third party webservices. If
this was a traditional OOP application, we’d create mocks for all the method
calls, or test actors for the outgoing mailboxes. FP mocking is equivalent to
providing an alternative implementation of dependency algebras. The algebras
already isolate the parts of the system that need to be <em>mocked</em>, i.e.
interpreted differently in the unit tests.</p>

<p>We will start with some test data</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Data {
    val node1   = MachineNode("1243d1af-828f-4ba3-9fc0-a19d86852b5a")
    val node2   = MachineNode("550c4943-229e-47b0-b6be-3d686c5f013f")
    val managed = NonEmptyList(node1, node2)
  
    val time1: Epoch = epoch"2017-03-03T18:07:00Z"
    val time2: Epoch = epoch"2017-03-03T18:59:00Z" // +52 mins
    val time3: Epoch = epoch"2017-03-03T19:06:00Z" // +59 mins
    val time4: Epoch = epoch"2017-03-03T23:07:00Z" // +5 hours
  
    val needsAgents = WorldView(5, 0, managed, Map.empty, Map.empty, time1)
  }
  import Data._
</pre></div>

</figure>

<aside>
  <p>The <code>epoch</code> string interpolator is written with Jon Pretty’s <a href="https://github.com/propensive/contextual">contextual</a> library,
giving us compiletime safety around string constructors of a type:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  import java.time.Instant
  object EpochInterpolator extends Verifier[Epoch] {
    def check(s: String): Either[(Int, String), Epoch] =
      try Right(Epoch(Instant.parse(s).toEpochMilli))
      catch { case _ =&gt; Left((0, "not in ISO-8601 format")) }
  }
  implicit class EpochMillisStringContext(sc: StringContext) {
    val epoch = Prefix(EpochInterpolator, sc)
  }
</pre></div>

  </figure>

</aside>

<p>We implement algebras by extending <code>Drone</code> and <code>Machines</code> with a specific
monadic context, <code>Id</code> being the simplest.</p>

<p>Our “mock” implementations simply play back a fixed <code>WorldView</code>. We’ve
isolated the state of our system, so we can use <code>var</code> to store the
state:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class Mutable(state: WorldView) {
    var started, stopped: Int = 0
  
    private val D: Drone[Id] = new Drone[Id] {
      def getBacklog: Int = state.backlog
      def getAgents: Int = state.agents
    }
  
    private val M: Machines[Id] = new Machines[Id] {
      def getAlive: Map[MachineNode, Epoch] = state.alive
      def getManaged: NonEmptyList[MachineNode] = state.managed
      def getTime: Epoch = state.time
      def start(node: MachineNode): MachineNode = { started += 1 ; node }
      def stop(node: MachineNode): MachineNode = { stopped += 1 ; node }
    }
  
    val program = new DynAgentsModule[Id](D, M)
  }
</pre></div>

</figure>

<aside>
  <p>We will return to this code later on and replace <code>var</code> with something safer.</p>

</aside>

<p>When we write a unit test (here using <code>FlatSpec</code> from Scalatest), we create an
instance of <code>Mutable</code> and then import all of its members.</p>

<p>Our implicit <code>drone</code> and <code>machines</code> both use the <code>Id</code> execution
context and therefore interpreting this program with them returns an
<code>Id[WorldView]</code> that we can assert on.</p>

<p>In this trivial case we just check that the <code>initial</code> method returns
the same value that we use in the static implementations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  "Business Logic" should "generate an initial world view" in {
    val mutable = new Mutable(needsAgents)
    import mutable._
  
    program.initial shouldBe needsAgents
  }
</pre></div>

</figure>

<p>We can create more advanced tests of the <code>update</code> and <code>act</code> methods,
helping us flush out bugs and refine the requirements:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  it should "remove changed nodes from pending" in {
    val world = WorldView(0, 0, managed, Map(node1 -&gt; time3), Map.empty, time3)
    val mutable = new Mutable(world)
    import mutable._
  
    val old = world.copy(alive = Map.empty,
                         pending = Map(node1 -&gt; time2),
                         time = time2)
    program.update(old) shouldBe world
  }
  
  it should "request agents when needed" in {
    val mutable = new Mutable(needsAgents)
    import mutable._
  
    val expected = needsAgents.copy(
      pending = Map(node1 -&gt; time1)
    )
  
    program.act(needsAgents) shouldBe expected
  
    mutable.stopped shouldBe 0
    mutable.started shouldBe 1
  }
</pre></div>

</figure>

<p>It would be boring to go through the full test suite. The following tests are
easy to implement using the same approach:</p>

<ul>
  <li>not request agents when pending</li>
  <li>don’t shut down agents if nodes are too young</li>
  <li>shut down agents when there is no backlog and nodes will shortly incur new costs</li>
  <li>not shut down agents if there are pending actions</li>
  <li>shut down agents when there is no backlog if they are too old</li>
  <li>shut down agents, even if they are potentially doing work, if they are too old</li>
  <li>ignore unresponsive pending actions during update</li>
</ul>

<p>All of these tests are synchronous and isolated to the test runner’s
thread (which could be running tests in parallel). If we’d designed
our test suite in Akka, our tests would be subject to arbitrary
timeouts and failures would be hidden in logfiles.</p>

<p>The productivity boost of simple tests for business logic cannot be
overstated. Consider that 90% of an application developer’s time
interacting with the customer is in refining, updating and fixing
these business rules. Everything else is implementation detail.</p>

<h3 id="leanpub-auto-parallel">
<a class="anchor-link" href="#leanpub-auto-parallel"><i class="fa fa-link"></i></a><span class="section-number">3.5 </span>Parallel</h3>

<p>The application that we have designed runs each of its algebraic
methods sequentially. But there are some obvious places where work can
be performed in parallel.</p>

<h4 id="leanpub-auto-initial-1">
<a class="anchor-link" href="#leanpub-auto-initial-1"><i class="fa fa-link"></i></a><span class="section-number">3.5.1 </span>initial</h4>

<p>In our definition of <code>initial</code> we could ask for all the information we
need at the same time instead of one query at a time.</p>

<p>As opposed to <code>flatMap</code> for sequential operations, Scalaz uses
<code>Apply</code> syntax for parallel operations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ^^^^(D.getBacklog, D.getAgents, M.getManaged, M.getAlive, M.getTime)
</pre></div>

</figure>

<p>which can also use infix notation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (D.getBacklog |@| D.getAgents |@| M.getManaged |@| M.getAlive |@| M.getTime)
</pre></div>

</figure>

<p>If each of the parallel operations returns a value in the same monadic
context, we can apply a function to the results when they all return.
Rewriting <code>initial</code> to take advantage of this:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def initial: F[WorldView] =
    ^^^^(D.getBacklog, D.getAgents, M.getManaged, M.getAlive, M.getTime) {
      case (db, da, mm, ma, mt) =&gt; WorldView(db, da, mm, ma, Map.empty, mt)
    }
</pre></div>

</figure>

<h4 id="leanpub-auto-act-1">
<a class="anchor-link" href="#leanpub-auto-act-1"><i class="fa fa-link"></i></a><span class="section-number">3.5.2 </span>act</h4>

<p>In the current logic for <code>act</code>, we are stopping each node
sequentially, waiting for the result, and then proceeding. But we
could stop all the nodes in parallel and then update our view of the
world.</p>

<p>A disadvantage of doing it this way is that any failures will cause us
to short-circuit before updating the <code>pending</code> field. But that is a
reasonable tradeoff since our <code>update</code> will gracefully handle the case
where a <code>node</code> is shut down unexpectedly.</p>

<p>We need a method that operates on <code>NonEmptyList</code> that allows us to
<code>map</code> each element into an <code>F[MachineNode]</code>, returning an
<code>F[NonEmptyList[MachineNode]]</code>. The method is called <code>traverse</code>, and
when we <code>flatMap</code> over it we get a <code>NonEmptyList[MachineNode]</code> that we
can deal with in a simple way:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    stopped &lt;- nodes.traverse(M.stop)
    updates = stopped.map(_ -&gt; world.time).toList.toMap
    update = world.copy(pending = world.pending ++ updates)
  } yield update
</pre></div>

</figure>

<p>Arguably, this is easier to understand than the sequential version.</p>

<h3 id="leanpub-auto-summary-1">
<a class="anchor-link" href="#leanpub-auto-summary-1"><i class="fa fa-link"></i></a><span class="section-number">3.6 </span>Summary</h3>

<ol class="numeric">
  <li>
<em>algebras</em> define the interface between systems.</li>
  <li>
<em>modules</em> are implementations of an algebra in terms of other algebras.</li>
  <li>
<em>interpreters</em> are concrete implementations of an algebra for a fixed <code>F[_]</code>.</li>
  <li>Test interpreters can replace the side-effecting parts of the system,
giving a high amount of test coverage.</li>
</ol>

<h2 id="leanpub-auto-data-and-functionality">
<a class="anchor-link" href="#leanpub-auto-data-and-functionality"><i class="fa fa-link"></i></a><span class="section-number">4. </span>Data and Functionality</h2>

<p>From OOP we are used to thinking about data and functionality
together: class hierarchies carry methods, and traits can demand that
data fields exist. Runtime polymorphism of an object is in terms of
“is a” relationships, requiring classes to inherit from common
interfaces. This can get messy as a codebase grows. Simple data types
become obscured by hundreds of lines of methods, trait mixins suffer
from initialisation order errors, and testing / mocking of highly
coupled components becomes a chore.</p>

<p>FP takes a different approach, defining data and functionality
separately. In this chapter, we will cover the basics of data types
and the advantages of constraining ourselves to a subset of the Scala
language. We will also discover <em>typeclasses</em> as a way to achieve
compiletime polymorphism: thinking about functionality of a data
structure in terms of “has a” rather than “is a” relationships.</p>

<h3 id="leanpub-auto-data">
<a class="anchor-link" href="#leanpub-auto-data"><i class="fa fa-link"></i></a><span class="section-number">4.1 </span>Data</h3>

<p>The fundamental building blocks of data types are</p>

<ul>
  <li>
<code>final case class</code> also known as <em>products</em>
</li>
  <li>
<code>sealed abstract class</code> also known as <em>coproducts</em>
</li>
  <li>
<code>case object</code> and <code>Int</code>, <code>Double</code>, <code>String</code> (etc) <em>values</em>
</li>
</ul>

<p>with no methods or fields other than the constructor parameters. We prefer
<code>abstract class</code> to <code>trait</code> in order to get better binary compatibility and to
discourage trait mixing.</p>

<p>The collective name for <em>products</em>, <em>coproducts</em> and <em>values</em> is
<em>Algebraic Data Type</em> (ADT).</p>

<p>We compose data types from the <code>AND</code> and <code>XOR</code> (exclusive <code>OR</code>)
Boolean algebra: a product contains every type that it is composed of,
but a coproduct can be only one. For example</p>

<ul>
  <li>product: <code>ABC = a AND b AND c</code>
</li>
  <li>coproduct: <code>XYZ = x XOR y XOR z</code>
</li>
</ul>

<p>written in Scala</p>

<figure class="code">
<div class="highlight"><pre><code></code>  // values
  case object A
  type B = String
  type C = Int
  
  // product
  final case class ABC(a: A.type, b: B, c: C)
  
  // coproduct
  sealed abstract class XYZ
  case object X extends XYZ
  case object Y extends XYZ
  final case class Z(b: B) extends XYZ
</pre></div>

</figure>

<h4 id="leanpub-auto-recursive-adts">
<a class="anchor-link" href="#leanpub-auto-recursive-adts"><i class="fa fa-link"></i></a><span class="section-number">4.1.1 </span>Recursive ADTs</h4>

<p>When an ADT refers to itself, we call it a <em>Recursive Algebraic Data Type</em>.</p>

<p><code>scalaz.IList</code>, a safe alternative to the stdlib <code>List</code>, is recursive because
<code>ICons</code> contains a reference to <code>IList</code>.:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IList[A]
  final case class INil[A]() extends IList[A]
  final case class ICons[A](head: A, tail: IList[A]) extends IList[A]
</pre></div>

</figure>

<h4 id="leanpub-auto-functions-on-adts">
<a class="anchor-link" href="#leanpub-auto-functions-on-adts"><i class="fa fa-link"></i></a><span class="section-number">4.1.2 </span>Functions on ADTs</h4>

<p>ADTs can contain <em>pure functions</em></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class UserConfiguration(accepts: Int =&gt; Boolean)
</pre></div>

</figure>

<p>But ADTs that contain functions come with some caveats as they don’t
translate perfectly onto the JVM. For example, legacy <code>Serializable</code>,
<code>hashCode</code>, <code>equals</code> and <code>toString</code> do not behave as one might
reasonably expect.</p>

<p>Unfortunately, <code>Serializable</code> is used by popular frameworks, despite
far superior alternatives. A common pitfall is forgetting that
<code>Serializable</code> may attempt to serialise the entire closure of a
function, which can crash production servers. A similar caveat applies
to legacy Java classes such as <code>Throwable</code>, which can carry references
to arbitrary objects.</p>

<p>We will explore alternatives to the legacy methods when we discuss the
Scalaz library in the next chapter, at the cost of losing
interoperability with some legacy Java and Scala code.</p>

<h4 id="leanpub-auto-exhaustivity">
<a class="anchor-link" href="#leanpub-auto-exhaustivity"><i class="fa fa-link"></i></a><span class="section-number">4.1.3 </span>Exhaustivity</h4>

<p>It is important that we use <code>sealed abstract class</code>, not just
<code>abstract class</code>, when defining a data type. Sealing a <code>class</code> means
that all subtypes must be defined in the same file, allowing the
compiler to know about them in pattern match exhaustivity checks and
in macros that eliminate boilerplate. e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; sealed abstract class Foo
         final case class Bar(flag: Boolean) extends Foo
         final case object Baz extends Foo
  
  scala&gt; def thing(foo: Foo) = foo match {
           case Bar(_) =&gt; true
         }
  &lt;console&gt;:14: error: match may not be exhaustive.
  It would fail on the following input: Baz
         def thing(foo: Foo) = foo match {
                               ^
</pre></div>

</figure>

<p>This shows the developer what they have broken when they add a new
product to the codebase. We’re using <code>-Xfatal-warnings</code>, otherwise
this is just a warning.</p>

<p>However, the compiler will not perform exhaustivity checking if the
<code>class</code> is not sealed or if there are guards, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def thing(foo: Foo) = foo match {
           case Bar(flag) if flag =&gt; true
         }
  
  scala&gt; thing(Baz)
  scala.MatchError: Baz (of class Baz$)
    at .thing(&lt;console&gt;:15)
</pre></div>

</figure>

<p>To remain safe, don’t use guards on <code>sealed</code> types.</p>

<p>The <a href="https://github.com/scala/scala/pull/5617"><code>-Xstrict-patmat-analysis</code></a> flag has been proposed as a language
improvement to perform additional pattern matcher checks.</p>

<h4 id="leanpub-auto-alternative-products-and-coproducts">
<a class="anchor-link" href="#leanpub-auto-alternative-products-and-coproducts"><i class="fa fa-link"></i></a><span class="section-number">4.1.4 </span>Alternative Products and Coproducts</h4>

<p>Another form of product is a tuple, which is like an unlabelled <code>final
case class</code>.</p>

<p><code>(A.type, B, C)</code> is equivalent to <code>ABC</code> in the above example but it is best to
use <code>final case class</code> when part of an ADT because the lack of names is awkward
to deal with, and <code>case class</code> has much better performance for primitive values.</p>

<p>Another form of coproduct is when we nest <code>Either</code> types. e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  Either[X.type, Either[Y.type, Z]]
</pre></div>

</figure>

<p>equivalent to the <code>XYZ</code> sealed abstract class. A cleaner syntax to define
nested <code>Either</code> types is to create an alias type ending with a colon,
allowing infix notation with association from the right:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type |:[L,R] = Either[L, R]
  
  X.type |: Y.type |: Z
</pre></div>

</figure>

<p>This is useful to create anonymous coproducts when we cannot put all
the implementations into the same source file.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Accepted = String |: Long |: Boolean
</pre></div>

</figure>

<p>Yet another alternative coproduct is to create a custom <code>sealed abstract class</code>
with <code>final case class</code> definitions that simply wrap the desired type:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Accepted
  final case class AcceptedString(value: String) extends Accepted
  final case class AcceptedLong(value: Long) extends Accepted
  final case class AcceptedBoolean(value: Boolean) extends Accepted
</pre></div>

</figure>

<p>Pattern matching on these forms of coproduct can be tedious, which is why <a href="https://contributors.scala-lang.org/t/733">Union
Types</a> are being explored in the Dotty next-generation Scala compiler. Macros
such as <a href="https://github.com/propensive/totalitarian">totalitarian</a> and <a href="https://github.com/frees-io/iota">iotaz</a> exist as alternative ways of encoding anonymous
coproducts.</p>

<h4 id="leanpub-auto-convey-information">
<a class="anchor-link" href="#leanpub-auto-convey-information"><i class="fa fa-link"></i></a><span class="section-number">4.1.5 </span>Convey Information</h4>

<p>Besides being a container for necessary business information, data
types can be used to encode constraints. For example,</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class NonEmptyList[A](head: A, tail: IList[A])
</pre></div>

</figure>

<p>can never be empty. This makes <code>scalaz.NonEmptyList</code> a useful data type despite
containing the same information as <code>IList</code>.</p>

<p>Product types often contain types that are far more general than is allowed. In
traditional OOP this would be handled with input validation through assertions:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Person(name: String, age: Int) {
    require(name.nonEmpty &amp;&amp; age &gt; 0) // breaks Totality, don't do this!
  }
</pre></div>

</figure>

<p>Instead, we can use the <code>Either</code> data type to provide <code>Right[Person]</code> for valid
instances and protect invalid instances from propagating. Note that the
constructor is <code>private</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Person private(name: String, age: Int)
  object Person {
    def apply(name: String, age: Int): Either[String, Person] = {
      if (name.nonEmpty &amp;&amp; age &gt; 0) Right(new Person(name, age))
      else Left(s"bad input: $name, $age")
    }
  }
  
  def welcome(person: Person): String =
    s"${person.name} you look wonderful at ${person.age}!"
  
  for {
    person &lt;- Person("", -1)
  } yield welcome(person)
</pre></div>

</figure>

<h5 id="leanpub-auto-refined-data-types">
<a class="anchor-link" href="#leanpub-auto-refined-data-types"><i class="fa fa-link"></i></a><span class="section-number">4.1.5.1 </span>Refined Data Types</h5>

<p>A clean way to restrict the values of a general type is with the <code>refined</code>
library, providing a suite of restrictions to the contents of data. To install
refined, add the following to <code>build.sbt</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  libraryDependencies += "eu.timepit" %% "refined-scalaz" % "0.9.2"
</pre></div>

</figure>

<p>and the following imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import eu.timepit.refined
  import refined.api.Refined
</pre></div>

</figure>

<p><code>Refined</code> allows us to define <code>Person</code> using adhoc refined types to capture
requirements exactly, written <code>A Refined B</code>.</p>

<aside>
  <p>All types with two parameters can be written <em>infix</em> in Scala. For example,
<code>Either[String, Int]</code> is the same as <code>String Either Int</code>. It is conventional for
<code>Refined</code> to be written infix since <code>A Refined B</code> can be read as “an <code>A</code> that
meets the requirements defined in <code>B</code>”.</p>

</aside>

<figure class="code">
<div class="highlight"><pre><code></code>  import refined.numeric.Positive
  import refined.collection.NonEmpty
  
  final case class Person(
    name: String Refined NonEmpty,
    age: Int Refined Positive
  )
</pre></div>

</figure>

<p>The underlying value can be obtained with <code>.value</code>. We can construct a
value at runtime using <code>.refineV</code>, returning an <code>Either</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import refined.refineV
  scala&gt; refineV[NonEmpty]("")
  Left(Predicate isEmpty() did not fail.)
  
  scala&gt; refineV[NonEmpty]("Sam")
  Right(Sam)
</pre></div>

</figure>

<p>If we add the following import</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import refined.auto._
</pre></div>

</figure>

<p>we can construct valid values at compiletime and get an error if the provided
value does not meet the requirements</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val sam: String Refined NonEmpty = "Sam"
  Sam
  
  scala&gt; val empty: String Refined NonEmpty = ""
  &lt;console&gt;:21: error: Predicate isEmpty() did not fail.
</pre></div>

</figure>

<p>More complex requirements can be captured, for example we can use the built-in
rule <code>MaxSize</code> with the following imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import refined.W
  import refined.boolean.And
  import refined.collection.MaxSize
</pre></div>

</figure>

<p>capturing the requirement that the <code>String</code> must be both non-empty and have a
maximum size of 10 characters:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Name = NonEmpty And MaxSize[W.`10`.T]
  
  final case class Person(
    name: String Refined Name,
    age: Int Refined Positive
  )
</pre></div>

</figure>

<aside>
  <p>The <code>W</code> notation is short for “witness”. This syntax will be much simpler in
Scala 2.13, which has support for <em>literal types</em>:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  type Name = NonEmpty And MaxSize[10]
</pre></div>

  </figure>

</aside>

<p>It is easy to define custom requirements that are not covered by the refined
library. For example in <code>drone-dynamaic-agents</code> we will need a way of ensuring
that a <code>String</code> contains <code>application/x-www-form-urlencoded</code> content. We can
create a <code>Refined</code> rule using the Java regular expression library:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class UrlEncoded
  object UrlEncoded {
    private[this] val valid: Pattern =
      Pattern.compile("\\A(\\p{Alnum}++|[-.*_+=&amp;]++|%\\p{XDigit}{2})*\\z")
  
    implicit def urlValidate: Validate.Plain[String, UrlEncoded] =
      Validate.fromPredicate(
        s =&gt; valid.matcher(s).find(),
        identity,
        new UrlEncoded {}
      )
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-simple-to-share">
<a class="anchor-link" href="#leanpub-auto-simple-to-share"><i class="fa fa-link"></i></a><span class="section-number">4.1.6 </span>Simple to Share</h4>

<p>By not providing any functionality, ADTs can have a minimal set of
dependencies. This makes them easy to publish and share with other
developers. By using a simple data modelling language, it makes it
possible to interact with cross-discipline teams, such as DBAs, UI
developers and business analysts, using the actual code instead of a
hand written document as the source of truth.</p>

<p>Furthermore, tooling can be more easily written to produce or consume
schemas from other programming languages and wire protocols.</p>

<h4 id="leanpub-auto-counting-complexity">
<a class="anchor-link" href="#leanpub-auto-counting-complexity"><i class="fa fa-link"></i></a><span class="section-number">4.1.7 </span>Counting Complexity</h4>

<p>The complexity of a data type is the count of values that can exist. A good data
type has the least amount of complexity it needs to hold the information it
conveys, and no more.</p>

<p>Values have a built-in complexity:</p>

<ul>
  <li>
<code>Unit</code> has one value (why it is called “unit”)</li>
  <li>
<code>Boolean</code> has two values</li>
  <li>
<code>Int</code> has 4,294,967,295 values</li>
  <li>
<code>String</code> has effectively infinite values</li>
</ul>

<p>To find the complexity of a product, we multiply the complexity of
each part.</p>

<ul>
  <li>
<code>(Boolean, Boolean)</code> has 4 values (<code>2*2</code>)</li>
  <li>
<code>(Boolean, Boolean, Boolean)</code> has 8 values (<code>2*2*2</code>)</li>
</ul>

<p>To find the complexity of a coproduct, we add the complexity of each
part.</p>

<ul>
  <li>
<code>(Boolean |: Boolean)</code> has 4 values (<code>2+2</code>)</li>
  <li>
<code>(Boolean |: Boolean |: Boolean)</code> has 6 values (<code>2+2+2</code>)</li>
</ul>

<p>To find the complexity of a ADT with a type parameter, multiply each part by the
complexity of the type parameter:</p>

<ul>
  <li>
<code>Option[Boolean]</code> has 3 values, <code>Some[Boolean]</code> and <code>None</code> (<code>2+1</code>)</li>
</ul>

<p>In FP, functions are <em>total</em> and must return an value for every
input, no <code>Exception</code>. Minimising the complexity of inputs and outputs
is the best way to achieve totality. As a rule of thumb, it is a sign
of a badly designed function when the complexity of a function’s
return value is larger than the product of its inputs: it is a source
of entropy.</p>

<p>The complexity of a total function is the number of possible functions that can
satisfy the type signature: the output to the power of the input.</p>

<ul>
  <li>
<code>Unit =&gt; Boolean</code> has complexity 2</li>
  <li>
<code>Boolean =&gt; Boolean</code> has complexity 4</li>
  <li>
<code>Option[Boolean] =&gt; Option[Boolean]</code> has complexity 27</li>
  <li>
<code>Boolean =&gt; Int</code> is a mere quintillion going on a sextillion.</li>
  <li>
<code>Int =&gt; Boolean</code> is so big that if all implementations were assigned a unique
number, each would require 4 gigabytes to represent.</li>
</ul>

<p>In reality, <code>Int =&gt; Boolean</code> will be something simple like <code>isOdd</code>, <code>isEven</code> or
a sparse <code>BitSet</code>. This function, when used in an ADT, could be better replaced
with a coproduct labelling the limited set of functions that are relevant.</p>

<p>When our complexity is “infinity in, infinity out” we should introduce
restrictive data types and validation closer to the point of input with
<code>Refined</code> from the previous section.</p>

<p>The ability to count the complexity of a type signature has one other practical
application: we can find simpler type signatures with High School algebra! To go
from a type signature to its algebra of complexity, simply replace</p>

<ul>
  <li>
<code>Either[A, B]</code> with <code>a + b</code>
</li>
  <li>
<code>(A, B)</code> with <code>a * b</code>
</li>
  <li>
<code>A =&gt; B</code> with <code>b ^ a</code>
</li>
</ul>

<p>do some rearranging, and convert back. For example, say we’ve designed a
framework based on callbacks and we’ve managed to work ourselves into the
situation where we have created this type signature:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (A =&gt; C) =&gt; ((B =&gt; C) =&gt; C)
</pre></div>

</figure>

<p>We can convert and rearrange</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (c ^ (c ^ b)) ^ (c ^ a)
  = c ^ ((c ^ b) * (c ^ a))
  = c ^ (c ^ (a + b))
</pre></div>

</figure>

<p>then convert back to types and get</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (Either[A, B] =&gt; C) =&gt; C
</pre></div>

</figure>

<p>which is much simpler: we only need to ask the users of our framework to provide
a <code>Either[A, B] =&gt; C</code>.</p>

<p>The same line of reasoning can be used to prove that</p>

<figure class="code">
<div class="highlight"><pre><code></code>  A =&gt; B =&gt; C
</pre></div>

</figure>

<p>is equivalent to</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (A, B) =&gt; C
</pre></div>

</figure>

<p>also known as <em>Currying</em>.</p>

<h4 id="leanpub-auto-prefer-coproduct-over-product">
<a class="anchor-link" href="#leanpub-auto-prefer-coproduct-over-product"><i class="fa fa-link"></i></a><span class="section-number">4.1.8 </span>Prefer Coproduct over Product</h4>

<p>An archetypal modelling problem that comes up a lot is when there are
mutually exclusive configuration parameters <code>a</code>, <code>b</code> and <code>c</code>. The
product <code>(a: Boolean, b: Boolean, c: Boolean)</code> has complexity 8
whereas the coproduct</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Config
  object Config {
    case object A extends Config
    case object B extends Config
    case object C extends Config
  }
</pre></div>

</figure>

<p>has a complexity of 3. It is better to model these configuration
parameters as a coproduct rather than allowing 5 invalid states to
exist.</p>

<p>The complexity of a data type also has implications on testing. It is
practically impossible to test every possible input to a function, but it is
easy to test a sample of values with the <a href="https://www.scalacheck.org/">Scalacheck</a> property testing framework.
If a random sample of a data type has a low probability of being valid, it is a
sign that the data is modelled incorrectly.</p>

<h4 id="leanpub-auto-optimisations">
<a class="anchor-link" href="#leanpub-auto-optimisations"><i class="fa fa-link"></i></a><span class="section-number">4.1.9 </span>Optimisations</h4>

<p>A big advantage of using a simplified subset of the Scala language to
represent data types is that tooling can optimise the JVM bytecode
representation.</p>

<p>For example, we could pack <code>Boolean</code> and <code>Option</code> fields into an <code>Array[Byte]</code>,
cache values, memoise <code>hashCode</code>, optimise <code>equals</code>, use <code>@switch</code> statements
when pattern matching, and much more.</p>

<p>These optimisations are not applicable to OOP <code>class</code> hierarchies that
may be managing state, throwing exceptions, or providing adhoc method
implementations.</p>

<h3 id="leanpub-auto-functionality">
<a class="anchor-link" href="#leanpub-auto-functionality"><i class="fa fa-link"></i></a><span class="section-number">4.2 </span>Functionality</h3>

<p>Pure functions are typically defined as methods on an <code>object</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  package object math {
    def sin(x: Double): Double = java.lang.Math.sin(x)
    ...
  }
  
  math.sin(1.0)
</pre></div>

</figure>

<p>However, it can be clunky to use <code>object</code> methods since it reads
inside-out, not left to right. In addition, a function on an <code>object</code>
steals the namespace. If we were to define <code>sin(t: T)</code> somewhere else
we get <em>ambiguous reference</em> errors. This is the same problem as
Java’s static methods vs class methods.</p>

<aside class="warning blurb">
    <p>The sort of developer who puts methods on a <code>trait</code>, requiring users to mix it
with the <em>cake pattern</em>, is going straight to hell. It leaks internal
implementation detail to public APIs, bloats bytecode, makes binary
compatibility basically impossible, and confuses IDE autocompleters.</p>

</aside>

<p>With the <code>implicit class</code> language feature (also known as <em>extension
methodology</em> or <em>syntax</em>), and a little boilerplate, we can get the
familiar style:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; implicit class DoubleOps(x: Double) {
           def sin: Double = math.sin(x)
         }
  
  scala&gt; (1.0).sin
  res: Double = 0.8414709848078965
</pre></div>

</figure>

<p>Often it is best to just skip the <code>object</code> definition and go straight
for an <code>implicit class</code>, keeping boilerplate to a minimum:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
</pre></div>

</figure>

<aside>
  <p><code>implicit class</code> is syntax sugar for an implicit conversion:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  implicit def DoubleOps(x: Double): DoubleOps = new DoubleOps(x)
  class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
</pre></div>

  </figure>

  <p>Which unfortunately has a runtime cost: each time the extension method
is called, an intermediate <code>DoubleOps</code> will be constructed and then
thrown away. This can contribute to GC pressure in hotspots.</p>

  <p>There is a slightly more verbose form of <code>implicit class</code> that avoids
the allocation and is therefore preferred:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  implicit final class DoubleOps(private val x: Double) extends AnyVal {
    def sin: Double = java.lang.Math.sin(x)
  }
</pre></div>

  </figure>

</aside>

<h4 id="leanpub-auto-polymorphic-functions">
<a class="anchor-link" href="#leanpub-auto-polymorphic-functions"><i class="fa fa-link"></i></a><span class="section-number">4.2.1 </span>Polymorphic Functions</h4>

<p>The more common kind of function is a polymorphic function, which
lives in a <em>typeclass</em>. A typeclass is a trait that:</p>

<ul>
  <li>holds no state</li>
  <li>has a type parameter</li>
  <li>has at least one abstract method (<em>primitive combinators</em>)</li>
  <li>may contain <em>generalised</em> methods (<em>derived combinators</em>)</li>
  <li>may extend other typeclasses</li>
</ul>

<p>There can only be one implementation of a typeclass for any given type
parameter, a property known as <em>typeclass coherence</em>. Typeclasses look
superficially similar to algebraic interfaces from the previous chapter, but
algebras do not have to be coherent.</p>

<aside>
  <p>Typeclass coherence is primarily about consistency, and the consistency gives us
the confidence to use <code>implicit</code> parameters. It would be difficult to reason
about code that performs differently depending on the implicit imports that are
in scope. Typeclass coherence effectively says that imports should not impact
the behaviour of the code.</p>

  <p>Additionally, typeclass coherence allows us to globally cache implicits at
runtime and save memory allocations, gaining performance improvements from
reduced pressure on the garbage collector.</p>

</aside>

<p>Typeclasses are used in the Scala stdlib. We will explore a simplified
version of <code>scala.math.Numeric</code> to demonstrate the principle:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Ordering[T] {
    def compare(x: T, y: T): Int
  
    def lt(x: T, y: T): Boolean = compare(x, y) &lt; 0
    def gt(x: T, y: T): Boolean = compare(x, y) &gt; 0
  }
  
  trait Numeric[T] extends Ordering[T] {
    def plus(x: T, y: T): T
    def times(x: T, y: T): T
    def negate(x: T): T
    def zero: T
  
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
</pre></div>

</figure>

<p>We can see all the key features of a typeclass in action:</p>

<ul>
  <li>there is no state</li>
  <li>
<code>Ordering</code> and <code>Numeric</code> have type parameter <code>T</code>
</li>
  <li>
<code>Ordering</code> has abstract <code>compare</code> and <code>Numeric</code> has abstract <code>plus</code>,
<code>times</code>, <code>negate</code> and <code>zero</code>
</li>
  <li>
<code>Ordering</code> defines generalised <code>lt</code> and <code>gt</code> based on <code>compare</code>,
<code>Numeric</code> defines <code>abs</code> in terms of <code>lt</code>, <code>negate</code> and <code>zero</code>.</li>
  <li>
<code>Numeric</code> extends <code>Ordering</code>
</li>
</ul>

<p>We can now write functions for types that “have a” <code>Numeric</code>
typeclass:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {
    import N._
    times(negate(abs(t)), t)
  }
</pre></div>

</figure>

<p>We are no longer dependent on the OOP hierarchy of our input types,
i.e. we don’t demand that our input “is a” <code>Numeric</code>, which is vitally
important if we want to support a third party class that we cannot
redefine.</p>

<p>Another advantage of typeclasses is that the association of
functionality to data is at compiletime, as opposed to OOP runtime
dynamic dispatch.</p>

<p>For example, whereas the <code>List</code> class can only have one implementation
of a method, a typeclass method allows us to have a different
implementation depending on the <code>List</code> contents and therefore offload
work to compiletime instead of leaving it to runtime.</p>

<h4 id="leanpub-auto-syntax">
<a class="anchor-link" href="#leanpub-auto-syntax"><i class="fa fa-link"></i></a><span class="section-number">4.2.2 </span>Syntax</h4>

<p>The syntax for writing <code>signOfTheTimes</code> is clunky, there are some
things we can do to clean it up.</p>

<p>Downstream users will prefer to see our method use <em>context bounds</em>,
since the signature reads cleanly as “takes a <code>T</code> that has a
<code>Numeric</code>”</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def signOfTheTimes[T: Numeric](t: T): T = ...
</pre></div>

</figure>

<p>but now we have to use <code>implicitly[Numeric[T]]</code> everywhere. By
defining boilerplate on the companion of the typeclass</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  }
</pre></div>

</figure>

<p>we can obtain the implicit with less noise</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def signOfTheTimes[T: Numeric](t: T): T = {
    val N = Numeric[T]
    import N._
    times(negate(abs(t)), t)
  }
</pre></div>

</figure>

<p>But it is still worse for us as the implementors. We have the
syntactic problem of inside-out static methods vs class methods. We
deal with this by introducing <code>ops</code> on the typeclass companion:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  
    object ops {
      implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {
        def +(o: T): T = N.plus(t, o)
        def *(o: T): T = N.times(t, o)
        def unary_-: T = N.negate(t)
        def abs: T = N.abs(t)
  
        // duplicated from Ordering.ops
        def &lt;(o: T): T = N.lt(t, o)
        def &gt;(o: T): T = N.gt(t, o)
      }
    }
  }
</pre></div>

</figure>

<p>Note that <code>-x</code> is expanded into <code>x.unary_-</code> by the compiler’s syntax
sugar, which is why we define <code>unary_-</code> as an extension method. We can
now write the much cleaner:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
</pre></div>

</figure>

<p>The good news is that we never need to write this boilerplate because
<a href="https://github.com/mpilquist/simulacrum">Simulacrum</a> provides a <code>@typeclass</code>
macro annotation that automatically generates the <code>apply</code> and <code>ops</code>. It even
allows us to define alternative (usually symbolic) names for common methods. In
full:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import simulacrum._
  
  @typeclass trait Ordering[T] {
    def compare(x: T, y: T): Int
    @op("&lt;") def lt(x: T, y: T): Boolean = compare(x, y) &lt; 0
    @op("&gt;") def gt(x: T, y: T): Boolean = compare(x, y) &gt; 0
  }
  
  @typeclass trait Numeric[T] extends Ordering[T] {
    @op("+") def plus(x: T, y: T): T
    @op("*") def times(x: T, y: T): T
    @op("unary_-") def negate(x: T): T
    def zero: T
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
  
  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
</pre></div>

</figure>

<p>When there is a custom symbolic <code>@op</code>, it can be pronounced like its method
name. e.g. <code>&lt;</code> is pronounced “less than”, not “left angle bracket”.</p>

<h4 id="leanpub-auto-instances">
<a class="anchor-link" href="#leanpub-auto-instances"><i class="fa fa-link"></i></a><span class="section-number">4.2.3 </span>Instances</h4>

<p><em>Instances</em> of <code>Numeric</code> (which are also instances of <code>Ordering</code>) are
defined as an <code>implicit val</code> that extends the typeclass, and can
provide optimised implementations for the generalised methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val NumericDouble: Numeric[Double] = new Numeric[Double] {
    def plus(x: Double, y: Double): Double = x + y
    def times(x: Double, y: Double): Double = x * y
    def negate(x: Double): Double = -x
    def zero: Double = 0.0
    def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)
  
    // optimised
    override def lt(x: Double, y: Double): Boolean = x &lt; y
    override def gt(x: Double, y: Double): Boolean = x &gt; y
    override def abs(x: Double): Double = java.lang.Math.abs(x)
  }
</pre></div>

</figure>

<p>Although we are using <code>+</code>, <code>*</code>, <code>unary_-</code>, <code>&lt;</code> and <code>&gt;</code> here, which are
the ops (and could be an infinite loop!), these methods exist already
on <code>Double</code>. Class methods are always used in preference to extension
methods. Indeed, the Scala compiler performs special handling of
primitives and converts these method calls into raw <code>dadd</code>, <code>dmul</code>,
<code>dcmpl</code> and <code>dcmpg</code> bytecode instructions, respectively.</p>

<p>We can also implement <code>Numeric</code> for Java’s <code>BigDecimal</code> class (avoid
<code>scala.BigDecimal</code>, <a href="https://github.com/scala/bug/issues/9670">it is fundamentally broken</a>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import java.math.{ BigDecimal =&gt; BD }
  
  implicit val NumericBD: Numeric[BD] = new Numeric[BD] {
    def plus(x: BD, y: BD): BD = x.add(y)
    def times(x: BD, y: BD): BD = x.multiply(y)
    def negate(x: BD): BD = x.negate
    def zero: BD = BD.ZERO
    def compare(x: BD, y: BD): Int = x.compareTo(y)
  }
</pre></div>

</figure>

<p>We could create our own data structure for complex numbers:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Complex[T](r: T, i: T)
</pre></div>

</figure>

<p>And derive a <code>Numeric[Complex[T]]</code> if <code>Numeric[T]</code> exists. Since these
instances depend on the type parameter, it is a <code>def</code>, not a <code>val</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def numericComplex[T: Numeric]: Numeric[Complex[T]] =
    new Numeric[Complex[T]] {
      type CT = Complex[T]
      def plus(x: CT, y: CT): CT = Complex(x.r + y.r, x.i + y.i)
      def times(x: CT, y: CT): CT =
        Complex(x.r * y.r + (-x.i * y.i), x.r * y.i + x.i * y.r)
      def negate(x: CT): CT = Complex(-x.r, -x.i)
      def zero: CT = Complex(Numeric[T].zero, Numeric[T].zero)
      def compare(x: CT, y: CT): Int = {
        val real = (Numeric[T].compare(x.r, y.r))
        if (real != 0) real
        else Numeric[T].compare(x.i, y.i)
      }
    }
</pre></div>

</figure>

<p>The observant reader may notice that <code>abs</code> is not at all what a
mathematician would expect. The correct return value for <code>abs</code> should
be <code>T</code>, not <code>Complex[T]</code>.</p>

<p><code>scala.math.Numeric</code> tries to do too much and does not generalise
beyond real numbers. This is a good lesson that smaller, well defined,
typeclasses are often better than a monolithic collection of overly
specific features.</p>

<h4 id="leanpub-auto-implicit-resolution">
<a class="anchor-link" href="#leanpub-auto-implicit-resolution"><i class="fa fa-link"></i></a><span class="section-number">4.2.4 </span>Implicit Resolution</h4>

<p>We’ve discussed implicits a lot: this section is to clarify what
implicits are and how they work.</p>

<p><em>Implicit parameters</em> are when a method requests that a unique
instance of a particular type is in the <em>implicit scope</em> of the
caller, with special syntax for typeclass instances. Implicit
parameters are a clean way to thread configuration through an
application.</p>

<p>In this example, <code>foo</code> requires that typeclass instances of <code>Numeric</code> and
<code>Typeable</code> are available for <code>A</code>, as well as an implicit <code>Handler</code> object that
takes two type parameters</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[A: Numeric: Typeable](implicit A: Handler[String, A]) = ...
</pre></div>

</figure>

<p><em>Implicit conversion</em> is when an <code>implicit def</code> exists. One such use
of implicit conversions is to enable extension methodology. When the
compiler is resolving a call to a method, it first checks if the
method exists on the type, then its ancestors (Java-like rules). If it
fails to find a match, it will search the <em>implicit scope</em> for
conversions to other types, then search for methods on those types.</p>

<p>Another use for implicit conversions is <em>typeclass derivation</em>. In the
previous section we wrote an <code>implicit def</code> that derived a
<code>Numeric[Complex[T]]</code> if a <code>Numeric[T]</code> is in the implicit scope. It
is possible to chain together many <code>implicit def</code> (including
recursively) which is the basis of <em>typeful programming</em>, allowing for
computations to be performed at compiletime rather than runtime.</p>

<p>The glue that combines implicit parameters (receivers) with implicit
conversion (providers) is implicit resolution.</p>

<p>First, the normal variable scope is searched for implicits, in order:</p>

<ul>
  <li>local scope, including scoped imports (e.g. the block or method)</li>
  <li>outer scope, including scoped imports (e.g. members in the class)</li>
  <li>ancestors (e.g. members in the super class)</li>
  <li>the current package object</li>
  <li>ancestor package objects (when using nested packages)</li>
  <li>the file’s imports</li>
</ul>

<p>If that fails to find a match, the special scope is searched, which
looks for implicit instances inside a type’s companion, its package
object, outer objects (if nested), and then repeated for ancestors.
This is performed, in order, for the:</p>

<ul>
  <li>given parameter type</li>
  <li>expected parameter type</li>
  <li>type parameter (if there is one)</li>
</ul>

<p>If two matching implicits are found in the same phase of implicit
resolution, an <em>ambiguous implicit</em> error is raised.</p>

<p>Implicits are often defined on a <code>trait</code>, which is then extended by an
object. This is to try and control the priority of an implicit
relative to another more specific one, to avoid ambiguous implicits.</p>

<p>The Scala Language Specification is rather vague for corner cases, and
the compiler implementation is the <em>de facto</em> standard. There are some
rules of thumb that we will use throughout this book, e.g. prefer
<code>implicit val</code> over <code>implicit object</code> despite the temptation of less
typing. It is a <a href="https://github.com/scala/bug/issues/10411">quirk of implicit resolution</a> that <code>implicit object</code> on
companion objects are not treated the same as <code>implicit val</code>.</p>

<p>Implicit resolution falls short when there is a hierarchy of typeclasses, like
<code>Ordering</code> and <code>Numeric</code>. If we write a function that takes an implicit
<code>Ordering</code>, and we call it for a primitive type which has an instance of
<code>Numeric</code> defined on the <code>Numeric</code> companion, the compiler will fail to find it.</p>

<p>Implicit resolution is particularly hit-or-miss <a href="https://github.com/scala/bug/issues/10582">if type aliases are used</a> where
the <em>shape</em> of the implicit parameters are changed. For example an implicit
parameter using an alias such as <code>type Values[A] = List[Option[A]]</code> will
probably fail to find implicits defined as raw <code>List[Option[A]]</code> because the
shape is changed from a <em>thing of things</em> of <code>A</code> to a <em>thing</em> of <code>A</code>.</p>

<h3 id="leanpub-auto-modelling-oauth2">
<a class="anchor-link" href="#leanpub-auto-modelling-oauth2"><i class="fa fa-link"></i></a><span class="section-number">4.3 </span>Modelling OAuth2</h3>

<p>We will finish this chapter with a practical example of data modelling
and typeclass derivation, combined with algebra / module design from
the previous chapter.</p>

<p>In our <code>drone-dynamic-agents</code> application, we must communicate with Drone and
Google Cloud using JSON over REST. Both services use <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a> for authentication.
There are many ways to interpret OAuth2, but we will focus on the version that
works for Google Cloud (the Drone version is even simpler).</p>

<h4 id="leanpub-auto-description">
<a class="anchor-link" href="#leanpub-auto-description"><i class="fa fa-link"></i></a><span class="section-number">4.3.1 </span>Description</h4>

<p>Every Google Cloud application needs to have an <em>OAuth 2.0 Client Key</em>
set up at</p>

<figure class="code">
<div class="highlight"><pre><code></code>  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
</pre></div>

</figure>

<p>Obtaining a <em>Client ID</em> and a <em>Client secret</em>.</p>

<p>The application can then obtain a one time <em>code</em> by making the user
perform an <em>Authorization Request</em> in their browser (yes, really, <strong>in
their browser</strong>). We need to make this page open in the browser:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&amp;\
    prompt=consent&amp;\
    response_type=code&amp;\
    scope={SCOPE}&amp;\
    access_type=offline&amp;\
    client_id={CLIENT_ID}
</pre></div>

</figure>

<p>The <em>code</em> is delivered to the <code>{CALLBACK_URI}</code> in a <code>GET</code> request. To
capture it in our application, we need to have a web server listening
on <code>localhost</code>.</p>

<p>Once we have the <em>code</em>, we can perform an <em>Access Token Request</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&amp;\
    redirect_uri={CALLBACK_URI}&amp;\
    client_id={CLIENT_ID}&amp;\
    client_secret={CLIENT_SECRET}&amp;\
    scope={SCOPE}&amp;\
    grant_type=authorization_code
</pre></div>

</figure>

<p>which gives a JSON response payload</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }
</pre></div>

</figure>

<p><em>Bearer tokens</em> typically expire after an hour, and can be refreshed
by sending an HTTP request with any valid <em>refresh token</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&amp;
    grant_type=refresh_token&amp;
    refresh_token={REFRESH_TOKEN}&amp;
    client_id={CLIENT_ID}
</pre></div>

</figure>

<p>responding with</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }
</pre></div>

</figure>

<p>All userland requests to the server should include the header</p>

<figure class="code">
<div class="highlight"><pre><code></code>  Authorization: Bearer BEARER_TOKEN
</pre></div>

</figure>

<p>after substituting the actual <code>BEARER_TOKEN</code>.</p>

<p>Google expires all but the most recent 50 <em>bearer tokens</em>, so the
expiry times are just guidance. The <em>refresh tokens</em> persist between
sessions and can be expired manually by the user. We can therefore
have a one-time setup application to obtain the refresh token and then
include the refresh token as configuration for the user’s install of
the headless server.</p>

<p>Drone doesn’t implement the <code>/auth</code> endpoint, or the refresh, and simply
provides a <code>BEARER_TOKEN</code> through their user interface.</p>

<h4 id="leanpub-auto-data-1">
<a class="anchor-link" href="#leanpub-auto-data-1"><i class="fa fa-link"></i></a><span class="section-number">4.3.2 </span>Data</h4>

<p>The first step is to model the data needed for OAuth2. We create an ADT with
fields having exactly the same name as required by the OAuth2 server. We will
use <code>String</code> and <code>Long</code> for brevity, but we could use refined types if they leak
into our business models.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import refined.api.Refined
  import refined.string.Url
  
  final case class AuthRequest(
    redirect_uri: String Refined Url,
    scope: String,
    client_id: String,
    prompt: String = "consent",
    response_type: String = "code",
    access_type: String = "offline"
  )
  final case class AccessRequest(
    code: String,
    redirect_uri: String Refined Url,
    client_id: String,
    client_secret: String,
    scope: String = "",
    grant_type: String = "authorization_code"
  )
  final case class AccessResponse(
    access_token: String,
    token_type: String,
    expires_in: Long,
    refresh_token: String
  )
  final case class RefreshRequest(
    client_secret: String,
    refresh_token: String,
    client_id: String,
    grant_type: String = "refresh_token"
  )
  final case class RefreshResponse(
    access_token: String,
    token_type: String,
    expires_in: Long
  )
</pre></div>

</figure>

<aside class="warning blurb">
    <p>Avoid using <code>java.net.URL</code> at all costs: it uses DNS to resolve the
hostname part when performing <code>toString</code>, <code>equals</code> or <code>hashCode</code>.</p>

  <p>Apart from being insane, and <strong>very very</strong> slow, these methods can throw
I/O exceptions (are not <em>pure</em>), and can change depending on the
network configuration (are not <em>deterministic</em>).</p>

  <p>The refined type <code>String Refined Url</code> allows us to perform equality checks based
on the <code>String</code> and we can safely construct a <code>URL</code> only if it is needed by a
legacy API.</p>

  <p>That said, in high performance code we would prefer to skip <code>java.net.URL</code>
entirely and use a third party URL parser such as <a href="https://github.com/anthonynsimon/jurl">jurl</a>, because even the safe
parts of <code>java.net.*</code> are extremely slow at scale.</p>

</aside>

<h4 id="leanpub-auto-functionality-1">
<a class="anchor-link" href="#leanpub-auto-functionality-1"><i class="fa fa-link"></i></a><span class="section-number">4.3.3 </span>Functionality</h4>

<p>We need to marshal the data classes we defined in the previous section into
JSON, URLs and POST-encoded forms. Since this requires polymorphism, we will
need typeclasses.</p>

<p><a href="https://github.com/scalaz/scalaz-deriving/tree/master/examples/jsonformat/src"><code>jsonformat</code></a> is a simple JSON library that we will study in more detail in a
later chapter, as it has been written with principled FP and ease of readability
as its primary design objectives. It consists of a JSON AST and encoder /
decoder typeclasses:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  package jsonformat
  
  sealed abstract class JsValue
  final case object JsNull                                    extends JsValue
  final case class JsObject(fields: IList[(String, JsValue)]) extends JsValue
  final case class JsArray(elements: IList[JsValue])          extends JsValue
  final case class JsBoolean(value: Boolean)                  extends JsValue
  final case class JsString(value: String)                    extends JsValue
  final case class JsDouble(value: Double)                    extends JsValue
  final case class JsInteger(value: Long)                     extends JsValue
  
  @typeclass trait JsEncoder[A] {
    def toJson(obj: A): JsValue
  }
  
  @typeclass trait JsDecoder[A] {
    def fromJson(json: JsValue): String \/ A
  }
</pre></div>

</figure>

<aside>
  <p><code>\/</code> is Scalaz’s <code>Either</code> and has a <code>.flatMap</code>. We can use it in <code>for</code>
comprehensions, whereas stdlib <code>Either</code> does not support <code>.flatMap</code> prior to
Scala 2.12. It is spoken as <em>disjunction</em>, or <em>angry rabbit</em>.</p>

  <p><code>scala.Either</code> was <a href="https://issues.scala-lang.org/browse/SI-250">contributed to
the Scala standard library</a> by the creator of Scalaz, Tony Morris, in 2007.
<code>\/</code> was created when unsafe methods were added to <code>Either</code>.</p>

</aside>

<p>We need instances of <code>JsDecoder[AccessResponse]</code> and <code>JsDecoder[RefreshResponse]</code>.
We can do this by making use of a helper function:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class JsValueOps(j: JsValue) {
    def getAs[A: JsDecoder](key: String): String \/ A = ...
  }
</pre></div>

</figure>

<p>We put the instances on the companions of our data types, so that they are
always in the implicit scope:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import jsonformat._, JsDecoder.ops._
  
  object AccessResponse {
    implicit val json: JsDecoder[AccessResponse] = j =&gt;
      for {
        acc &lt;- j.getAs[String]("access_token")
        tpe &lt;- j.getAs[String]("token_type")
        exp &lt;- j.getAs[Long]("expires_in")
        ref &lt;- j.getAs[String]("refresh_token")
      } yield AccessResponse(acc, tpe, exp, ref)
  }
  
  object RefreshResponse {
    implicit val json: JsDecoder[RefreshResponse] = j =&gt;
      for {
        acc &lt;- j.getAs[String]("access_token")
        tpe &lt;- j.getAs[String]("token_type")
        exp &lt;- j.getAs[Long]("expires_in")
      } yield RefreshResponse(acc, tpe, exp)
  }
</pre></div>

</figure>

<p>We can then parse a string into an <code>AccessResponse</code> or a <code>RefreshResponse</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import jsonformat._, JsDecoder.ops._
  scala&gt; val json = JsParser("""
                       {
                         "access_token": "BEARER_TOKEN",
                         "token_type": "Bearer",
                         "expires_in": 3600,
                         "refresh_token": "REFRESH_TOKEN"
                       }
                       """)
  
  scala&gt; json.map(_.as[AccessResponse])
  AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
</pre></div>

</figure>

<p>We need to write our own typeclasses for URL and POST encoding. The
following is a reasonable design:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  // URL query key=value pairs, in un-encoded form.
  final case class UrlQuery(params: List[(String, String)])
  
  @typeclass trait UrlQueryWriter[A] {
    def toUrlQuery(a: A): UrlQuery
  }
  
  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
</pre></div>

</figure>

<p>We need to provide typeclass instances for basic types:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import java.net.URLEncoder
  
  object UrlEncodedWriter {
    implicit val encoded: UrlEncodedWriter[String Refined UrlEncoded] = identity
  
    implicit val string: UrlEncodedWriter[String] =
      (s =&gt; Refined.unsafeApply(URLEncoder.encode(s, "UTF-8")))
  
    implicit val url: UrlEncodedWriter[String Refined Url] =
      (s =&gt; s.value.toUrlEncoded)
  
    implicit val long: UrlEncodedWriter[Long] =
      (s =&gt; Refined.unsafeApply(s.toString))
  
    implicit def ilist[K: UrlEncodedWriter, V: UrlEncodedWriter]
      : UrlEncodedWriter[IList[(K, V)]] = { m =&gt;
      val raw = m.map {
        case (k, v) =&gt; k.toUrlEncoded.value + "=" + v.toUrlEncoded.value
      }.intercalate("&amp;")
      Refined.unsafeApply(raw) // by deduction
    }
  
  }
</pre></div>

</figure>

<p>We use <code>Refined.unsafeApply</code> when we can logically deduce that the contents of
the string are already url encoded, bypassing any further checks.</p>

<p><code>ilist</code> is an example of simple typeclass derivation, much as we derived
<code>Numeric[Complex]</code> from the underlying numeric representation. The
<code>.intercalate</code> method is like <code>.mkString</code> but more general.</p>

<aside>
  <p><code>UrlEncodedWriter</code> is making use of the <em>Single Abstract Method</em> (SAM types)
Scala language feature. The full form of the above is</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
</pre></div>

  </figure>

  <p>When the Scala compiler expects a class (which has a single abstract
method) but receives a lambda, it fills in the boilerplate
automatically.</p>

  <p>Prior to SAM types, a common pattern was to define a method named
<code>instance</code> on the typeclass companion</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def instance[T](f: T =&gt; String): UrlEncodedWriter[T] =
    new UrlEncodedWriter[T] {
      override def toUrlEncoded(t: T): String = f(t)
    }
</pre></div>

  </figure>

  <p>allowing for</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  implicit val string: UrlEncodedWriter[String] = instance { s =&gt; ... }
</pre></div>

  </figure>

  <p>This pattern is still used in code that must support older versions of
Scala, or for typeclasses instances that need to provide more than one
method.</p>

  <p>Note that there are a lot of bugs around SAM types, as they do not interact with
all the language features. Revert to the non-SAM variant if there are any
strange compiler crashes.</p>

</aside>

<p>In a dedicated chapter on <em>Typeclass Derivation</em> we will calculate instances of
<code>UrlQueryWriter</code> automatically, as well as clean up what
we have already written, but for now we will write the boilerplate for the types
we wish to convert:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import UrlEncodedWriter.ops._
  object AuthRequest {
    implicit val query: UrlQueryWriter[AuthRequest] = { a =&gt;
      UrlQuery(List(
        ("redirect_uri"  -&gt; a.redirect_uri.value),
        ("scope"         -&gt; a.scope),
        ("client_id"     -&gt; a.client_id),
        ("prompt"        -&gt; a.prompt),
        ("response_type" -&gt; a.response_type),
        ("access_type"   -&gt; a.access_type))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =&gt;
      IList(
        "code"          -&gt; a.code.toUrlEncoded,
        "redirect_uri"  -&gt; a.redirect_uri.toUrlEncoded,
        "client_id"     -&gt; a.client_id.toUrlEncoded,
        "client_secret" -&gt; a.client_secret.toUrlEncoded,
        "scope"         -&gt; a.scope.toUrlEncoded,
        "grant_type"    -&gt; a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =&gt;
      IList(
        "client_secret" -&gt; r.client_secret.toUrlEncoded,
        "refresh_token" -&gt; r.refresh_token.toUrlEncoded,
        "client_id"     -&gt; r.client_id.toUrlEncoded,
        "grant_type"    -&gt; r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-module">
<a class="anchor-link" href="#leanpub-auto-module"><i class="fa fa-link"></i></a><span class="section-number">4.3.4 </span>Module</h4>

<p>That concludes the data and functionality modelling required to implement
OAuth2. Recall from the previous chapter that we define components that need to
interact with the world as algebras, and we define business logic in a module,
so it can be thoroughly tested.</p>

<p>We define our dependency algebras, and use context bounds to show that our
responses must have a <code>JsDecoder</code> and our <code>POST</code> payload must have a
<code>UrlEncodedWriter</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait JsonClient[F[_]] {
    def get[A: JsDecoder](
      uri: String Refined Url,
      headers: IList[(String, String)]
    ): F[A]
  
    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String] = IList.empty
    ): F[A]
  }
</pre></div>

</figure>

<p>Note that we only define the happy path in the <code>JsonClient</code> API. We will get
around to error handling in a later chapter.</p>

<p>Obtaining a <code>CodeToken</code> from the Google <code>OAuth2</code> server involves</p>

<ol class="numeric">
  <li>starting an HTTP server on the local machine, and obtaining its port number.</li>
  <li>making the user open a web page in their browser, which allows them to log in
with their Google credentials and authorise the application, with a redirect
back to the local machine.</li>
  <li>capturing the code, informing the user of next steps, and closing the HTTP
server.</li>
</ol>

<p>We can model this with three methods on a <code>UserInteraction</code> algebra.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class CodeToken(token: String, redirect_uri: String Refined Url)
  
  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
</pre></div>

</figure>

<p>It almost sounds easy when put like that.</p>

<p>We also need an algebra to abstract over the local system time</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
</pre></div>

</figure>

<p>And introduce data types that we will use in the refresh logic</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class ServerConfig(
    auth: String Refined Url,
    access: String Refined Url,
    refresh: String Refined Url,
    scope: String,
    clientId: String,
    clientSecret: String
  )
  final case class RefreshToken(token: String)
  final case class BearerToken(token: String, expires: Epoch)
</pre></div>

</figure>

<p>Now we can write an OAuth2 client module:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import http.encoding.UrlQueryWriter.ops._
  
  class OAuth2Client[F[_]: Monad](
    config: ServerConfig
  )(
    user: UserInteraction[F],
    client: JsonClient[F],
    clock: LocalClock[F]
  ) {
    def authenticate: F[CodeToken] =
      for {
        callback &lt;- user.start
        params   = AuthRequest(callback, config.scope, config.clientId)
        _        &lt;- user.open(params.toUrlQuery.forUrl(config.auth))
        code     &lt;- user.stop
      } yield code
  
    def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
      for {
        request &lt;- AccessRequest(code.token,
                                 code.redirect_uri,
                                 config.clientId,
                                 config.clientSecret).pure[F]
        msg     &lt;- client.post[AccessRequest, AccessResponse](
                     config.access, request)
        time    &lt;- clock.now
        expires = time + msg.expires_in.seconds
        refresh = RefreshToken(msg.refresh_token)
        bearer  = BearerToken(msg.access_token, expires)
      } yield (refresh, bearer)
  
    def bearer(refresh: RefreshToken): F[BearerToken] =
      for {
        request &lt;- RefreshRequest(config.clientSecret,
                                  refresh.token,
                                  config.clientId).pure[F]
        msg     &lt;- client.post[RefreshRequest, RefreshResponse](
                     config.refresh, request)
        time    &lt;- clock.now
        expires = time + msg.expires_in.seconds
        bearer  = BearerToken(msg.access_token, expires)
      } yield bearer
  }
</pre></div>

</figure>

<h3 id="leanpub-auto-summary-2">
<a class="anchor-link" href="#leanpub-auto-summary-2"><i class="fa fa-link"></i></a><span class="section-number">4.4 </span>Summary</h3>

<ul>
  <li>
<em>algebraic data types</em> (ADTs) are defined as <em>products</em> (<code>final case class</code>)
and <em>coproducts</em> (<code>sealed abstract class</code>).</li>
  <li>
<code>Refined</code> types enforce constraints on values.</li>
  <li>concrete functions can be defined in an <code>implicit class</code> to maintain
left-to-right flow.</li>
  <li>polymorphic functions are defined in <em>typeclasses</em>. Functionality is provided
via “has a” <em>context bounds</em>, rather than “is a” class hierarchies.</li>
  <li>typeclass <em>instances</em> are implementations of a typeclass.</li>
  <li>
<code>@simulacrum.typeclass</code> generates <code>.ops</code> on the companion, providing
convenient syntax for typeclass functions.</li>
  <li>
<em>typeclass derivation</em> is compiletime composition of typeclass
instances.</li>
</ul>

<h2 id="leanpub-auto-scalaz-typeclasses">
<a class="anchor-link" href="#leanpub-auto-scalaz-typeclasses"><i class="fa fa-link"></i></a><span class="section-number">5. </span>Scalaz Typeclasses</h2>

<p>In this chapter we will tour most of the typeclasses in <code>scalaz-core</code>.
We don’t use everything in <code>drone-dynamic-agents</code> so we will give
standalone examples when appropriate.</p>

<p>There has been criticism of the naming in Scalaz, and functional programming in
general. Most names follow the conventions introduced in the Haskell programming
language, based on <em>Category Theory</em>. Feel free to set up <code>type</code> aliases if
verbs based on the primary functionality are easier to remember when learning
(e.g. <code>Mappable</code>, <code>Pureable</code>, <code>FlatMappable</code>).</p>

<p>Before we introduce the typeclass hierarchy, we will peek at the four
most important methods from a control flow perspective: the methods we
will use the most in typical FP applications:</p>

<table>
  <thead>
    <tr>
      <th>Typeclass</th>
      <th>Method</th>
      <th>From</th>
      <th>Given</th>
      <th>To</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Functor</code></td>
      <td><code>map</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; B</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td><code>Applicative</code></td>
      <td><code>pure</code></td>
      <td><code>A</code></td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Monad</code></td>
      <td><code>flatMap</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; F[B]</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td><code>Traverse</code></td>
      <td><code>sequence</code></td>
      <td><code>F[G[A]]</code></td>
      <td>&nbsp;</td>
      <td><code>G[F[A]]</code></td>
    </tr>
  </tbody>

</table>

<p>We know that operations which return a <code>F[_]</code> can be run sequentially
in a <code>for</code> comprehension by <code>.flatMap</code>, defined on its <code>Monad[F]</code>. The
context <code>F[_]</code> can be thought of as a container for an intentional
<em>effect</em> with <code>A</code> as the output: <code>flatMap</code> allows us to generate new
effects <code>F[B]</code> at runtime based on the results of evaluating previous
effects.</p>

<p>Of course, not all type constructors <code>F[_]</code> are effectful, even if
they have a <code>Monad[F]</code>. Often they are data structures. By using the
least specific abstraction, we can reuse code for <code>List</code>, <code>Either</code>,
<code>Future</code> and more.</p>

<p>If we only need to transform the output from an <code>F[_]</code>, that is just
<code>map</code>, introduced by <code>Functor</code>. In Chapter 3, we ran effects in
parallel by creating a product and mapping over them. In Functional
Programming, parallelisable computations are considered <strong>less</strong>
powerful than sequential ones.</p>

<p>In between <code>Monad</code> and <code>Functor</code> is <code>Applicative</code>, defining <code>pure</code>
that lets us lift a value into an effect, or create a data structure
from a single value.</p>

<p><code>.sequence</code> is useful for rearranging type constructors. If we have an <code>F[G[_]]</code>
but need a <code>G[F[_]]</code>, e.g. <code>List[Future[Int]]</code> but need a <code>Future[List[Int]]</code>,
that is <code>.sequence</code>.</p>

<h3 id="leanpub-auto-agenda">
<a class="anchor-link" href="#leanpub-auto-agenda"><i class="fa fa-link"></i></a><span class="section-number">5.1 </span>Agenda</h3>

<p>This chapter is longer than usual and jam-packed with information: it is
perfectly reasonable to attack it over several sittings. Remembering everything
would require super-human powers, so treat this chapter as a way of knowing
where to look for more information.</p>

<p>Notably absent are typeclasses that extend <code>Monad</code>. They get their own chapter
later.</p>

<p>Scalaz uses code generation, not simulacrum. However, for brevity, we present
code snippets with <code>@typeclass</code>. Equivalent syntax is available when we <code>import
scalaz._, Scalaz._</code> and is available under the <code>scalaz.syntax</code> package in the
scalaz source code.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-core-tree.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>



<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-core-cliques.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>



<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-core-loners.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h3 id="leanpub-auto-appendable-things">
<a class="anchor-link" href="#leanpub-auto-appendable-things"><i class="fa fa-link"></i></a><span class="section-number">5.2 </span>Appendable Things</h3>


<div class="figure-wrapper center">
  <figure class="image" style="width: 25%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-semigroup.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Semigroup[A] {
    @op("|+|") def append(x: A, y: =&gt;A): A
  
    def multiply1(value: F, n: Int): F = ...
  }
  
  @typeclass trait Monoid[A] extends Semigroup[A] {
    def zero: A
  
    def multiply(value: F, n: Int): F =
      if (n &lt;= 0) zero else multiply1(value, n - 1)
  }
  
  @typeclass trait Band[A] extends Semigroup[A]
</pre></div>

</figure>

<aside>
  <p><code>|+|</code> is known as the TIE Fighter operator. There is an Advanced TIE
Fighter in an upcoming section, which is very exciting.</p>

</aside>

<p>A <code>Semigroup</code> can be defined for a type if two values can be combined. The
operation must be <em>associative</em>, meaning that the order of nested operations
should not matter, i.e.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (a |+| b) |+| c == a |+| (b |+| c)
  
  (1 |+| 2) |+| 3 == 1 |+| (2 |+| 3)
</pre></div>

</figure>

<p>A <code>Monoid</code> is a <code>Semigroup</code> with a <em>zero</em> element (also called <em>empty</em>
or <em>identity</em>). Combining <code>zero</code> with any other <code>a</code> should give <code>a</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  a |+| zero == a
  
  a |+| 0 == a
</pre></div>

</figure>

<p>This is probably bringing back memories of <code>Numeric</code> from Chapter 4. There are
implementations of <code>Monoid</code> for all the primitive numbers, but the concept of
<em>appendable</em> things is useful beyond numbers.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; "hello" |+| " " |+| "world!"
  res: String = "hello world!"
  
  scala&gt; List(1, 2) |+| List(3, 4)
  res: List[Int] = List(1, 2, 3, 4)
</pre></div>

</figure>

<p><code>Band</code> has the law that the <code>append</code> operation of the same two
elements is <em>idempotent</em>, i.e. gives the same value. Examples are
anything that can only be one value, such as <code>Unit</code>, least upper
bounds, or a <code>Set</code>. <code>Band</code> provides no further methods yet users can
make use of the guarantees for performance optimisation.</p>

<aside>
  <p>Viktor Klang, of Lightbend fame, lays claim to the phrase
<a href="https://twitter.com/viktorklang/status/789036133434978304">effectively-once delivery</a> for message processing with idempotent
operations, i.e. <code>Band.append</code>.</p>

</aside>

<p>As a realistic example for <code>Monoid</code>, consider a trading system that has a large
database of reusable trade templates. Populating the default values for a new
trade involves selecting and combining multiple templates, with a “last rule
wins” merge policy if two templates provide a value for the same field. The
“selecting” work is already done for us by another system, it is our job to
combine the templates in order.</p>

<p>We will create a simple template schema to demonstrate the principle,
but keep in mind that a realistic system would have a more complicated
ADT.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Currency
  case object EUR extends Currency
  case object USD extends Currency
  
  final case class TradeTemplate(
    payments: List[java.time.LocalDate],
    ccy: Option[Currency],
    otc: Option[Boolean]
  )
</pre></div>

</figure>

<p>If we write a method that takes <code>templates: List[TradeTemplate]</code>, we
only need to call</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val zero = Monoid[TradeTemplate].zero
  templates.foldLeft(zero)(_ |+| _)
</pre></div>

</figure>

<p>and our job is done!</p>

<p>But to get <code>zero</code> or call <code>|+|</code> we must have an instance of
<code>Monoid[TradeTemplate]</code>. Although we will generically derive this in a
later chapter, for now we will create an instance on the companion:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object TradeTemplate {
    implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
      (a, b) =&gt; TradeTemplate(a.payments |+| b.payments,
                              a.ccy |+| b.ccy,
                              a.otc |+| b.otc),
      TradeTemplate(Nil, None, None)
    )
  }
</pre></div>

</figure>

<p>However, this doesn’t do what we want because <code>Monoid[Option[A]]</code> will append
its contents, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Option(2) |+| None
  res: Option[Int] = Some(2)
  scala&gt; Option(2) |+| Option(1)
  res: Option[Int] = Some(3)
</pre></div>

</figure>

<p>whereas we want “last rule wins”. We can override the default
<code>Monoid[Option[A]]</code> with our own:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def lastWins[A]: Monoid[Option[A]] = Monoid.instance(
    {
      case (None, None)   =&gt; None
      case (only, None)   =&gt; only
      case (None, only)   =&gt; only
      case (_   , winner) =&gt; winner
    },
    None
  )
</pre></div>

</figure>

<p>Now everything compiles, let’s try it out…</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import java.time.{LocalDate =&gt; LD}
  scala&gt; val templates = List(
           TradeTemplate(Nil,                     None,      None),
           TradeTemplate(Nil,                     Some(EUR), None),
           TradeTemplate(List(LD.of(2017, 8, 5)), Some(USD), None),
           TradeTemplate(List(LD.of(2017, 9, 5)), None,      Some(true)),
           TradeTemplate(Nil,                     None,      Some(false))
         )
  
  scala&gt; templates.foldLeft(zero)(_ |+| _)
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
</pre></div>

</figure>

<p>All we needed to do was implement one piece of business logic and
<code>Monoid</code> took care of everything else for us!</p>

<p>Note that the list of <code>payments</code> are concatenated. This is because the
default <code>Monoid[List]</code> uses concatenation of elements and happens to
be the desired behaviour. If the business requirement was different,
it would be a simple case of providing a custom
<code>Monoid[List[LocalDate]]</code>. Recall from Chapter 4 that with compiletime
polymorphism we can have a different implementation of <code>append</code>
depending on the <code>E</code> in <code>List[E]</code>, not just the base runtime class
<code>List</code>.</p>

<aside>
  <p>When we introduced typeclasses in Chapter 4 we said that there can only be one
implementation of a typeclass for a given type parameter, e.g. there is only one
<code>Monoid[Option[Boolean]]</code> in the application. <em>Orphan instances</em> such as
<code>lastWins</code> are the easiest way to break coherence.</p>

  <p>We could try to justify locally breaking typeclass coherence by making
<code>lastWins</code> private, but when we get to the <code>Plus</code> typeclass we will see a better
way to implement our <code>Monoid</code>. When we get to tagged types, we will see an even
better way: using <code>LastOption</code> instead of <code>Option</code> in our data model.</p>

  <p>Please don’t break typeclass coherence at home, kids.</p>

</aside>

<h3 id="leanpub-auto-objecty-things">
<a class="anchor-link" href="#leanpub-auto-objecty-things"><i class="fa fa-link"></i></a><span class="section-number">5.3 </span>Objecty Things</h3>

<p>In the chapter on Data and Functionality we said that the JVM’s notion
of equality breaks down for many things that we can put into an ADT.
The problem is that the JVM was designed for Java, and <code>equals</code> is
defined on <code>java.lang.Object</code> whether it makes sense or not. There is
no way to remove <code>equals</code> and no way to guarantee that it is
implemented.</p>

<p>However, in FP we prefer typeclasses for polymorphic functionality and even the
concept of equality is captured at compiletime.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 20%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-comparable.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Equal[F]  {
    @op("===") def equal(a1: F, a2: F): Boolean
    @op("/==") def notEqual(a1: F, a2: F): Boolean = !equal(a1, a2)
  }
</pre></div>

</figure>

<p>Indeed <code>===</code> (<em>triple equals</em>) is more typesafe than <code>==</code> (<em>double
equals</em>) because it can only be compiled when the types are the same
on both sides of the comparison. This catches a lot of bugs.</p>

<p><code>equal</code> has the same implementation requirements as <code>Object.equals</code></p>

<ul>
  <li>
<em>commutative</em> <code>f1 === f2</code> implies <code>f2 === f1</code>
</li>
  <li>
<em>reflexive</em> <code>f === f</code>
</li>
  <li>
<em>transitive</em> <code>f1 === f2 &amp;&amp; f2 === f3</code> implies <code>f1 === f3</code>
</li>
</ul>

<p>By throwing away the universal concept of <code>Object.equals</code> we don’t
take equality for granted when we construct an ADT, stopping us at
compiletime from expecting equality when there is none.</p>

<p>Continuing the trend of replacing old Java concepts, rather than data
<em>being a</em> <code>java.lang.Comparable</code>, they now <em>have an</em> <code>Order</code> according
to:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Order[F] extends Equal[F] {
    @op("?|?") def order(x: F, y: F): Ordering
  
    override  def equal(x: F, y: F): Boolean = order(x, y) == Ordering.EQ
    @op("&lt;" ) def lt(x: F, y: F): Boolean = ...
    @op("&lt;=") def lte(x: F, y: F): Boolean = ...
    @op("&gt;" ) def gt(x: F, y: F): Boolean = ...
    @op("&gt;=") def gte(x: F, y: F): Boolean = ...
  
    def max(x: F, y: F): F = ...
    def min(x: F, y: F): F = ...
    def sort(x: F, y: F): (F, F) = ...
  }
  
  sealed abstract class Ordering
  object Ordering {
    case object LT extends Ordering
    case object EQ extends Ordering
    case object GT extends Ordering
  }
</pre></div>

</figure>

<p><code>Order</code> implements <code>.equal</code> in terms of the new primitive <code>.order</code>. When a
typeclass implements a parent’s <em>primitive combinator</em> with a <em>derived
combinator</em>, an <strong>implied law of substitution</strong> for the typeclass is added. If an
instance of <code>Order</code> were to override <code>.equal</code> for performance reasons, it must
behave identically the same as the original.</p>

<p>Things that have an order may also be discrete, allowing us to walk
successors and predecessors:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Enum[F] extends Order[F] {
    def succ(a: F): F
    def pred(a: F): F
    def min: Option[F]
    def max: Option[F]
  
    @op("-+-") def succn(n: Int, a: F): F = ...
    @op("---") def predn(n: Int, a: F): F = ...
  
    @op("|-&gt;" ) def fromToL(from: F, to: F): List[F] = ...
    @op("|--&gt;") def fromStepToL(from: F, step: Int, to: F): List[F] = ...
    @op("|=&gt;" ) def fromTo(from: F, to: F): EphemeralStream[F] = ...
    @op("|==&gt;") def fromStepTo(from: F, step: Int, to: F): EphemeralStream[F] = ...
  }
</pre></div>

</figure>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; 10 |--&gt; (2, 20)
  res: List[Int] = List(10, 12, 14, 16, 18, 20)
  
  scala&gt; 'm' |-&gt; 'u'
  res: List[Char] = List(m, n, o, p, q, r, s, t, u)
</pre></div>

</figure>

<aside>
  <p><code>|--&gt;</code> is Scalaz’s Lightsaber. This is the syntax of a Functional
Programmer. Not as clumsy or random as <code>fromStepToL</code>. An elegant
syntax… for a more civilised age.</p>

</aside>

<p>We will discuss <code>EphemeralStream</code> in the next chapter, for now we just need to
know that it is a potentially infinite data structure that avoids the memory
retention problems in the stdlib <code>Stream</code>.</p>

<p>Similarly to <code>Object.equals</code>, the concept of <code>.toString</code> on every <code>class</code> does
not make sense in Java. We would like to enforce stringyness at compiletime and
this is exactly what <code>Show</code> achieves:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Show[F] {
    def show(f: F): Cord = ...
    def shows(f: F): String = ...
  }
</pre></div>

</figure>

<p>We will explore <code>Cord</code> in more detail in the chapter on data types, we need only
know that it is an efficient data structure for storing and manipulating
<code>String</code>.</p>

<h3 id="leanpub-auto-mappable-things">
<a class="anchor-link" href="#leanpub-auto-mappable-things"><i class="fa fa-link"></i></a><span class="section-number">5.4 </span>Mappable Things</h3>

<p>We’re focusing on things that can be mapped over, or traversed, in
some sense:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-mappable.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-functor">
<a class="anchor-link" href="#leanpub-auto-functor"><i class="fa fa-link"></i></a><span class="section-number">5.4.1 </span>Functor</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Functor[F[_]] {
    def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
  
    def void[A](fa: F[A]): F[Unit] = map(fa)(_ =&gt; ())
    def fproduct[A, B](fa: F[A])(f: A =&gt; B): F[(A, B)] = map(fa)(a =&gt; (a, f(a)))
  
    def fpair[A](fa: F[A]): F[(A, A)] = map(fa)(a =&gt; (a, a))
    def strengthL[A, B](a: A, f: F[B]): F[(A, B)] = map(f)(b =&gt; (a, b))
    def strengthR[A, B](f: F[A], b: B): F[(A, B)] = map(f)(a =&gt; (a, b))
  
    def lift[A, B](f: A =&gt; B): F[A] =&gt; F[B] = map(_)(f)
    def mapply[A, B](a: A)(f: F[A =&gt; B]): F[B] = map(f)((ff: A =&gt; B) =&gt; ff(a))
  }
</pre></div>

</figure>

<p>The only abstract method is <code>map</code>, and it must <em>compose</em>, i.e. mapping
with <code>f</code> and then again with <code>g</code> is the same as mapping once with the
composition of <code>f</code> and <code>g</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  fa.map(f).map(g) == fa.map(f.andThen(g))
</pre></div>

</figure>

<p>The <code>map</code> should also perform a no-op if the provided function is
<code>identity</code> (i.e. <code>x =&gt; x</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  fa.map(identity) == fa
  
  fa.map(x =&gt; x) == fa
</pre></div>

</figure>

<p><code>Functor</code> defines some convenience methods around <code>map</code> that can be optimised by
specific instances. The documentation has been intentionally omitted in the
above definitions to encourage guessing what a method does before looking at the
implementation. Please spend a moment studying only the type signature of the
following before reading further:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def void[A](fa: F[A]): F[Unit]
  def fproduct[A, B](fa: F[A])(f: A =&gt; B): F[(A, B)]
  
  def fpair[A](fa: F[A]): F[(A, A)]
  def strengthL[A, B](a: A, f: F[B]): F[(A, B)]
  def strengthR[A, B](f: F[A], b: B): F[(A, B)]
  
  // harder
  def lift[A, B](f: A =&gt; B): F[A] =&gt; F[B]
  def mapply[A, B](a: A)(f: F[A =&gt; B]): F[B]
</pre></div>

</figure>

<ol class="numeric">
  <li>
<code>void</code> takes an instance of the <code>F[A]</code> and always returns an
<code>F[Unit]</code>, it forgets all the values whilst preserving the
structure.</li>
  <li>
<code>fproduct</code> takes the same input as <code>map</code> but returns <code>F[(A, B)]</code>,
i.e. it tuples the contents with the result of applying the
function. This is useful when we wish to retain the input.</li>
  <li>
<code>fpair</code> twins all the elements of <code>A</code> into a tuple <code>F[(A, A)]</code>
</li>
  <li>
<code>strengthL</code> pairs the contents of an <code>F[B]</code> with a constant <code>A</code> on
the left.</li>
  <li>
<code>strengthR</code> pairs the contents of an <code>F[A]</code> with a constant <code>B</code> on
the right.</li>
  <li>
<code>lift</code> takes a function <code>A =&gt; B</code> and returns a <code>F[A] =&gt; F[B]</code>. In
other words, it takes a function over the contents of an <code>F[A]</code> and
returns a function that operates <strong>on</strong> the <code>F[A]</code> directly.</li>
  <li>
<code>mapply</code> is a mind bender. Say we have an <code>F[_]</code> of functions <code>A
   =&gt; B</code> and a value <code>A</code>, then we can get an <code>F[B]</code>. It has a similar
signature to <code>pure</code> but requires the caller to provide the <code>F[A =&gt;
   B]</code>.</li>
</ol>

<p><code>fpair</code>, <code>strengthL</code> and <code>strengthR</code> look pretty useless, but they are
useful when we wish to retain some information that would otherwise be
lost to scope.</p>

<p><code>Functor</code> has some special syntax:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class FunctorOps[F[_]: Functor, A](self: F[A]) {
    def as[B](b: =&gt;B): F[B] = Functor[F].map(self)(_ =&gt; b)
    def &gt;|[B](b: =&gt;B): F[B] = as(b)
  }
</pre></div>

</figure>

<p><code>.as</code> and <code>&gt;|</code> are a way of replacing the output with a constant.</p>

<aside>
  <p>When Scalaz provides additional functionality as syntax, rather than on the
typeclass itself, it is because of binary compatibility.</p>

  <p>When a <code>X.Y.0</code> version of Scalaz is released, it is not possible to add methods
to typeclasses in that release series for Scala 2.10 and 2.11. It is therefore
worth reading both the typeclass source and its syntax.</p>

</aside>

<p>In our example application, as a nasty hack (which we didn’t even
admit to until now), we defined <code>start</code> and <code>stop</code> to return their
input:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def start(node: MachineNode): F[MachineNode]
  def stop (node: MachineNode): F[MachineNode]
</pre></div>

</figure>

<p>This allowed us to write terse business logic such as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _      &lt;- m.start(node)
    update = world.copy(pending = Map(node -&gt; world.time))
  } yield update
</pre></div>

</figure>

<p>and</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    stopped &lt;- nodes.traverse(m.stop)
    updates = stopped.map(_ -&gt; world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
</pre></div>

</figure>

<p>But this hack pushes unnecessary complexity into the implementations. It is
better if we let our algebras return <code>F[Unit]</code> and use <code>as</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  m.start(node) as world.copy(pending = Map(node -&gt; world.time))
</pre></div>

</figure>

<p>and</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    stopped &lt;- nodes.traverse(a =&gt; m.stop(a) as a)
    updates = stopped.map(_ -&gt; world.time).toList.toMap
    update  = world.copy(pending = world.pending ++ updates)
  } yield update
</pre></div>

</figure>

<h4 id="leanpub-auto-foldable">
<a class="anchor-link" href="#leanpub-auto-foldable"><i class="fa fa-link"></i></a><span class="section-number">5.4.2 </span>Foldable</h4>

<p>Technically, <code>Foldable</code> is for data structures that can be walked to produce a
summary value. However, this undersells the fact that it is a one-typeclass army
that can provide most of what we would expect to see in a Collections API.</p>

<p>There are so many methods we are going to have to split them out,
beginning with the abstract methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Foldable[F[_]] {
    def foldMap[A, B: Monoid](fa: F[A])(f: A =&gt; B): B
    def foldRight[A, B](fa: F[A], z: =&gt;B)(f: (A, =&gt;B) =&gt; B): B
    def foldLeft[A, B](fa: F[A], z: B)(f: (B, A) =&gt; B): B = ...
</pre></div>

</figure>

<p>An instance of <code>Foldable</code> need only implement <code>foldMap</code> and
<code>foldRight</code> to get all of the functionality in this typeclass,
although methods are typically optimised for specific data structures.</p>

<p><code>.foldMap</code> has a marketing buzzword name: <strong>MapReduce</strong>. Given an <code>F[A]</code>, a
function from <code>A</code> to <code>B</code>, and a way to combine <code>B</code> (provided by the <code>Monoid</code>,
along with a zero <code>B</code>), we can produce a summary value of type <code>B</code>. There is no
enforced operation order, allowing for parallel computation.</p>

<p><code>foldRight</code> does not require its parameters to have a <code>Monoid</code>,
meaning that it needs a starting value <code>z</code> and a way to combine each
element of the data structure with the summary value. The order for
traversing the elements is from right to left and therefore it cannot
be parallelised.</p>

<aside>
  <p><code>foldRight</code> is conceptually the same as the <code>foldRight</code> in the Scala
stdlib. However, there is a problem with the stdlib <code>foldRight</code>
signature, solved in Scalaz: very large data structures can stack
overflow. <code>List.foldRight</code> cheats by implementing <code>foldRight</code> as a
reversed <code>foldLeft</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  override def foldRight[B](z: B)(op: (A, B) =&gt; B): B =
    reverse.foldLeft(z)((right, left) =&gt; op(left, right))
</pre></div>

  </figure>

  <p>but the concept of reversing is not universal and this workaround cannot be used
for all data structures. Say we want to find a small number in a <code>Stream</code>, with
an early exit:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def isSmall(i: Int): Boolean = i &lt; 10
  scala&gt; (1 until 100000).toStream.foldRight(false) {
           (el, acc) =&gt; isSmall(el) || acc
         }
  java.lang.StackOverflowError
    at scala.collection.Iterator.toStream(Iterator.scala:1403)
    ...
</pre></div>

  </figure>

  <p>Scalaz solves the problem by taking a <em>byname</em> parameter for the
aggregate value</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; (1 |=&gt; 100000).foldRight(false)(el =&gt; acc =&gt; isSmall(el) || acc )
  res: Boolean = true
</pre></div>

  </figure>

  <p>which means that the <code>acc</code> is not evaluated unless it is needed.</p>

  <p>It is worth baring in mind that not all operations are stack safe in
<code>foldRight</code>. If we were to require evaluation of all elements, we can
also get a <code>StackOverflowError</code> with Scalaz’s <code>EphemeralStream</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; (1L |=&gt; 100000L).foldRight(0L)(el =&gt; acc =&gt; el |+| acc )
  java.lang.StackOverflowError
    at scalaz.Foldable.$anonfun$foldr$1(Foldable.scala:100)
    ...
</pre></div>

  </figure>

</aside>

<p><code>foldLeft</code> traverses elements from left to right. <code>foldLeft</code> can be
implemented in terms of <code>foldMap</code>, but most instances choose to
implement it because it is such a basic operation. Since it is usually
implemented with tail recursion, there are no <em>byname</em> parameters.</p>

<p>The only law for <code>Foldable</code> is that <code>foldLeft</code> and <code>foldRight</code> should
each be consistent with <code>foldMap</code> for monoidal operations. e.g.
appending an element to a list for <code>foldLeft</code> and prepending an
element to a list for <code>foldRight</code>. However, <code>foldLeft</code> and <code>foldRight</code>
do not need to be consistent with each other: in fact they often
produce the reverse of each other.</p>

<p>The simplest thing to do with <code>foldMap</code> is to use the <code>identity</code>
function, giving <code>fold</code> (the natural sum of the monoidal elements),
with left/right variants to allow choosing based on performance
criteria:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def fold[A: Monoid](t: F[A]): A = ...
  def sumr[A: Monoid](fa: F[A]): A = ...
  def suml[A: Monoid](fa: F[A]): A = ...
</pre></div>

</figure>

<p>Recall that when we learnt about <code>Monoid</code>, we wrote this:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; templates.foldLeft(Monoid[TradeTemplate].zero)(_ |+| _)
</pre></div>

</figure>

<p>We now know this is silly and we should have written:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; templates.toIList.fold
  res: TradeTemplate = TradeTemplate(
                         List(2017-08-05,2017-09-05),
                         Some(USD),
                         Some(false))
</pre></div>

</figure>

<p><code>.fold</code> doesn’t work on stdlib <code>List</code> because it already has a method
called <code>fold</code> that does it is own thing in its own special way.</p>

<p>The strangely named <code>intercalate</code> inserts a specific <code>A</code> between each
element before performing the <code>fold</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def intercalate[A: Monoid](fa: F[A], a: A): A = ...
</pre></div>

</figure>

<p>which is a generalised version of the stdlib’s <code>mkString</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List("foo", "bar").intercalate(",")
  res: String = "foo,bar"
</pre></div>

</figure>

<p>The <code>foldLeft</code> provides the means to obtain any element by traversal
index, including a bunch of other related methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def index[A](fa: F[A], i: Int): Option[A] = ...
  def indexOr[A](fa: F[A], default: =&gt;A, i: Int): A = ...
  def length[A](fa: F[A]): Int = ...
  def count[A](fa: F[A]): Int = length(fa)
  def empty[A](fa: F[A]): Boolean = ...
  def element[A: Equal](fa: F[A], a: A): Boolean = ...
</pre></div>

</figure>

<p>Scalaz is a pure library of only <em>total functions</em>. Whereas <code>List(0)</code> can throw
an exception, <code>Foldable.index</code> returns an <code>Option[A]</code> with the convenient
<code>.indexOr</code> returning an <code>A</code> when a default value is provided. <code>.element</code> is
similar to the stdlib <code>.contains</code> but uses <code>Equal</code> rather than ill-defined JVM
equality.</p>

<p>These methods <em>really</em> sound like a collections API. And, of course,
anything with a <code>Foldable</code> can be converted into a <code>List</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def toList[A](fa: F[A]): List[A] = ...
</pre></div>

</figure>

<p>There are also conversions to other stdlib and Scalaz data types such
as <code>.toSet</code>, <code>.toVector</code>, <code>.toStream</code>, <code>.to[T &lt;: TraversableLike]</code>,
<code>.toIList</code> and so on.</p>

<p>There are useful predicate checks</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def filterLength[A](fa: F[A])(f: A =&gt; Boolean): Int = ...
  def all[A](fa: F[A])(p: A =&gt; Boolean): Boolean = ...
  def any[A](fa: F[A])(p: A =&gt; Boolean): Boolean = ...
</pre></div>

</figure>

<p><code>filterLength</code> is a way of counting how many elements are <code>true</code> for a
predicate, <code>all</code> and <code>any</code> return <code>true</code> if all (or any) element meets
the predicate, and may exit early.</p>

<aside>
  <p>We’ve seen the <code>NonEmptyList</code> in previous chapters. For the sake of
brevity we use a type alias <code>Nel</code> in place of <code>NonEmptyList</code>.</p>

  <p>We’ve also seen <code>IList</code> in previous chapters, recall that it is an
alternative to stdlib <code>List</code> with impure methods, like <code>apply</code>,
removed.</p>

</aside>

<p>We can split an <code>F[A]</code> into parts that result in the same <code>B</code> with
<code>splitBy</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def splitBy[A, B: Equal](fa: F[A])(f: A =&gt; B): IList[(B, Nel[A])] = ...
  def splitByRelation[A](fa: F[A])(r: (A, A) =&gt; Boolean): IList[Nel[A]] = ...
  def splitWith[A](fa: F[A])(p: A =&gt; Boolean): List[Nel[A]] = ...
  def selectSplit[A](fa: F[A])(p: A =&gt; Boolean): List[Nel[A]] = ...
  
  def findLeft[A](fa: F[A])(f: A =&gt; Boolean): Option[A] = ...
  def findRight[A](fa: F[A])(f: A =&gt; Boolean): Option[A] = ...
</pre></div>

</figure>

<p>for example</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; IList("foo", "bar", "bar", "faz", "gaz", "baz").splitBy(_.charAt(0))
  res = [(f, [foo]), (b, [bar, bar]), (f, [faz]), (g, [gaz]), (b, [baz])]
</pre></div>

</figure>

<p>noting that there are two values indexed by <code>'b'</code>.</p>

<p><code>splitByRelation</code> avoids the need for an <code>Equal</code> but we must provide
the comparison operator.</p>

<p><code>splitWith</code> splits the elements into groups that alternatively satisfy
and don’t satisfy the predicate. <code>selectSplit</code> selects groups of
elements that satisfy the predicate, discarding others. This is one of
those rare occasions when two methods share the same type signature
but have different meanings.</p>

<p><code>findLeft</code> and <code>findRight</code> are for extracting the first element (from
the left, or right, respectively) that matches a predicate.</p>

<p>Making further use of <code>Equal</code> and <code>Order</code>, we have the <code>distinct</code>
methods which return groupings.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def distinct[A: Order](fa: F[A]): IList[A] = ...
  def distinctE[A: Equal](fa: F[A]): IList[A] = ...
  def distinctBy[A, B: Equal](fa: F[A])(f: A =&gt; B): IList[A] =
</pre></div>

</figure>

<p><code>distinct</code> is implemented more efficiently than <code>distinctE</code> because it
can make use of ordering and therefore use a quicksort-esque algorithm
that is much faster than the stdlib’s naive <code>List.distinct</code>. Data
structures (such as sets) can implement <code>distinct</code> in their <code>Foldable</code>
without doing any work.</p>

<p><code>distinctBy</code> allows grouping by the result of applying a function to
the elements. For example, grouping names by their first letter.</p>

<p>We can make further use of <code>Order</code> by extracting the minimum or
maximum element (or both extrema) including variations using the <code>Of</code>
or <code>By</code> pattern to first map to another type or to use a different
type to do the order comparison.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def maximum[A: Order](fa: F[A]): Option[A] = ...
  def maximumOf[A, B: Order](fa: F[A])(f: A =&gt; B): Option[B] = ...
  def maximumBy[A, B: Order](fa: F[A])(f: A =&gt; B): Option[A] = ...
  
  def minimum[A: Order](fa: F[A]): Option[A] = ...
  def minimumOf[A, B: Order](fa: F[A])(f: A =&gt; B): Option[B] = ...
  def minimumBy[A, B: Order](fa: F[A])(f: A =&gt; B): Option[A] = ...
  
  def extrema[A: Order](fa: F[A]): Option[(A, A)] = ...
  def extremaOf[A, B: Order](fa: F[A])(f: A =&gt; B): Option[(B, B)] = ...
  def extremaBy[A, B: Order](fa: F[A])(f: A =&gt; B): Option[(A, A)] =
</pre></div>

</figure>

<p>For example we can ask which <code>String</code> is maximum <code>By</code> length, or what
is the maximum length <code>Of</code> the elements.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List("foo", "fazz").maximumBy(_.length)
  res: Option[String] = Some(fazz)
  
  scala&gt; List("foo", "fazz").maximumOf(_.length)
  res: Option[Int] = Some(4)
</pre></div>

</figure>

<p>This concludes the key features of <code>Foldable</code>. The takeaway is that anything
we’d expect to find in a collection library is probably on <code>Foldable</code> and if it
isn’t already, it probably should be.</p>

<p>We will conclude with some variations of the methods we’ve already seen.
First there are methods that take a <code>Semigroup</code> instead of a <code>Monoid</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def fold1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def foldMap1Opt[A, B: Semigroup](fa: F[A])(f: A =&gt; B): Option[B] = ...
  def sumr1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  def suml1Opt[A: Semigroup](fa: F[A]): Option[A] = ...
  ...
</pre></div>

</figure>

<p>returning <code>Option</code> to account for empty data structures (recall that
<code>Semigroup</code> does not have a <code>zero</code>).</p>

<aside>
  <p>The methods read “one-Option”, not <code>10 pt</code> as in typesetting.</p>

</aside>

<p>The typeclass <code>Foldable1</code> contains a lot more <code>Semigroup</code> variants of
the <code>Monoid</code> methods shown here (all suffixed <code>1</code>) and makes sense for
data structures which are never empty, without requiring a <code>Monoid</code> on
the elements.</p>

<p>Importantly, there are variants that take monadic return values. We already used
<code>foldLeftM</code> when we first wrote the business logic of our application, now we
know that it is from <code>Foldable</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foldLeftM[G[_]: Monad, A, B](fa: F[A], z: B)(f: (B, A) =&gt; G[B]): G[B] = ...
  def foldRightM[G[_]: Monad, A, B](fa: F[A], z: =&gt;B)(f: (A, =&gt;B) =&gt; G[B]): G[B] = ...
  def foldMapM[G[_]: Monad, A, B: Monoid](fa: F[A])(f: A =&gt; G[B]): G[B] = ...
  def findMapM[M[_]: Monad, A, B](fa: F[A])(f: A =&gt; M[Option[B]]): M[Option[B]] = ...
  def allM[G[_]: Monad, A](fa: F[A])(p: A =&gt; G[Boolean]): G[Boolean] = ...
  def anyM[G[_]: Monad, A](fa: F[A])(p: A =&gt; G[Boolean]): G[Boolean] = ...
  ...
</pre></div>

</figure>

<h4 id="leanpub-auto-traverse">
<a class="anchor-link" href="#leanpub-auto-traverse"><i class="fa fa-link"></i></a><span class="section-number">5.4.3 </span>Traverse</h4>

<p><code>Traverse</code> is what happens when we cross a <code>Functor</code> with a <code>Foldable</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Traverse[F[_]] extends Functor[F] with Foldable[F] {
    def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A =&gt; G[B]): G[F[B]]
    def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] = ...
  
    def reverse[A](fa: F[A]): F[A] = ...
  
    def zipL[A, B](fa: F[A], fb: F[B]): F[(A, Option[B])] = ...
    def zipR[A, B](fa: F[A], fb: F[B]): F[(Option[A], B)] = ...
    def indexed[A](fa: F[A]): F[(Int, A)] = ...
    def zipWithL[A, B, C](fa: F[A], fb: F[B])(f: (A, Option[B]) =&gt; C): F[C] = ...
    def zipWithR[A, B, C](fa: F[A], fb: F[B])(f: (Option[A], B) =&gt; C): F[C] = ...
  
    def mapAccumL[S, A, B](fa: F[A], z: S)(f: (S, A) =&gt; (S, B)): (S, F[B]) = ...
    def mapAccumR[S, A, B](fa: F[A], z: S)(f: (S, A) =&gt; (S, B)): (S, F[B]) = ...
  }
</pre></div>

</figure>

<p>At the beginning of the chapter we showed the importance of <code>traverse</code>
and <code>sequence</code> for swapping around type constructors to fit a
requirement (e.g. <code>List[Future[_]]</code> to <code>Future[List[_]]</code>).</p>

<p>In <code>Foldable</code> we weren’t able to assume that <code>reverse</code> was a universal
concept, but now we can reverse a thing.</p>

<p>We can also <code>zip</code> together two things that have a <code>Traverse</code>, getting
back <code>None</code> when one side runs out of elements, using <code>zipL</code> or <code>zipR</code>
to decide which side to truncate when the lengths don’t match. A
special case of <code>zip</code> is to add an index to every entry with
<code>indexed</code>.</p>

<p><code>zipWithL</code> and <code>zipWithR</code> allow combining the two sides of a <code>zip</code>
into a new type, and then returning just an <code>F[C]</code>.</p>

<p><code>mapAccumL</code> and <code>mapAccumR</code> are regular <code>map</code> combined with an accumulator. If
we find our old Java ways make us want to reach for a <code>var</code>, and refer to it
from a <code>map</code>, we should be using <code>mapAccumL</code>.</p>

<p>For example, let’s say we have a list of words and we want to blank
out words we’ve already seen. The filtering algorithm is not allowed
to process the list of words a second time so it can be scaled to an
infinite stream:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val freedom =
  """We campaign for these freedoms because everyone deserves them.
     With these freedoms, the users (both individually and collectively)
     control the program and what it does for them."""
     .split("\\s+")
     .toList
  
  scala&gt; def clean(s: String): String = s.toLowerCase.replaceAll("[,.()]+", "")
  
  scala&gt; freedom
         .mapAccumL(Set.empty[String]) { (seen, word) =&gt;
           val cleaned = clean(word)
           (seen + cleaned, if (seen(cleaned)) "_" else word)
         }
         ._2
         .intercalate(" ")
  
  res: String =
  """We campaign for these freedoms because everyone deserves them.
     With _ _ the users (both individually and collectively)
     control _ program _ what it does _ _"""
</pre></div>

</figure>

<p>Finally <code>Traverse1</code>, like <code>Foldable1</code>, provides variants of these methods for
data structures that cannot be empty, accepting the weaker <code>Semigroup</code> instead
of a <code>Monoid</code>, and an <code>Apply</code> instead of an <code>Applicative</code>. Recall that
<code>Semigroup</code> does not have to provide an <code>.empty</code>, and <code>Apply</code> does not have to
provide a <code>.point</code>.</p>

<h4 id="leanpub-auto-align">
<a class="anchor-link" href="#leanpub-auto-align"><i class="fa fa-link"></i></a><span class="section-number">5.4.4 </span>Align</h4>

<p><code>Align</code> is about merging and padding anything with a <code>Functor</code>. Before
looking at <code>Align</code>, meet the <code>\&amp;/</code> data type (spoken as <em>These</em>, or
<em>hurray!</em>).</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class \&amp;/[+A, +B]
  final case class This[A](aa: A) extends (A \&amp;/ Nothing)
  final case class That[B](bb: B) extends (Nothing \&amp;/ B)
  final case class Both[A, B](aa: A, bb: B) extends (A \&amp;/ B)
</pre></div>

</figure>

<p>i.e. it is a data encoding of inclusive logical <code>OR</code>. <code>A</code> or <code>B</code> or both <code>A</code> and
<code>B</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Align[F[_]] extends Functor[F] {
    def alignWith[A, B, C](f: A \&amp;/ B =&gt; C): (F[A], F[B]) =&gt; F[C]
    def align[A, B](a: F[A], b: F[B]): F[A \&amp;/ B] = ...
  
    def merge[A: Semigroup](a1: F[A], a2: F[A]): F[A] = ...
  
    def pad[A, B]: (F[A], F[B]) =&gt; F[(Option[A], Option[B])] = ...
    def padWith[A, B, C](f: (Option[A], Option[B]) =&gt; C): (F[A], F[B]) =&gt; F[C] = ...
</pre></div>

</figure>

<p><code>alignWith</code> takes a function from either an <code>A</code> or a <code>B</code> (or both) to
a <code>C</code> and returns a lifted function from a tuple of <code>F[A]</code> and <code>F[B]</code>
to an <code>F[C]</code>. <code>align</code> constructs a <code>\&amp;/</code> out of two <code>F[_]</code>.</p>

<p><code>merge</code> allows us to combine two <code>F[A]</code> when <code>A</code> has a <code>Semigroup</code>. For example,
the implementation of <code>Semigroup[Map[K, V]]</code> defers to <code>Semigroup[V]</code>, combining
two entries results in combining their values, having the consequence that
<code>Map[K, List[A]]</code> behaves like a multimap:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Map("foo" -&gt; List(1)) merge Map("foo" -&gt; List(1), "bar" -&gt; List(2))
  res = Map(foo -&gt; List(1, 1), bar -&gt; List(2))
</pre></div>

</figure>

<p>and a <code>Map[K, Int]</code> simply tally their contents when merging:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Map("foo" -&gt; 1) merge Map("foo" -&gt; 1, "bar" -&gt; 2)
  res = Map(foo -&gt; 2, bar -&gt; 2)
</pre></div>

</figure>

<p><code>.pad</code> and <code>.padWith</code> are for partially merging two data structures that might
be missing values on one side. For example if we wanted to aggregate independent
votes and retain the knowledge of where the votes came from</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Map("foo" -&gt; 1) pad Map("foo" -&gt; 1, "bar" -&gt; 2)
  res = Map(foo -&gt; (Some(1),Some(1)), bar -&gt; (None,Some(2)))
  
  scala&gt; Map("foo" -&gt; 1, "bar" -&gt; 2) pad Map("foo" -&gt; 1)
  res = Map(foo -&gt; (Some(1),Some(1)), bar -&gt; (Some(2),None))
</pre></div>

</figure>

<p>There are convenient variants of <code>align</code> that make use of the
structure of <code>\&amp;/</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    def alignSwap[A, B](a: F[A], b: F[B]): F[B \&amp;/ A] = ...
    def alignA[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
    def alignB[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
    def alignThis[A, B](a: F[A], b: F[B]): F[Option[A]] = ...
    def alignThat[A, B](a: F[A], b: F[B]): F[Option[B]] = ...
    def alignBoth[A, B](a: F[A], b: F[B]): F[Option[(A, B)]] = ...
  }
</pre></div>

</figure>

<p>which should make sense from their type signatures. Examples:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List(1,2,3) alignSwap List(4,5)
  res = List(Both(4,1), Both(5,2), That(3))
  
  scala&gt; List(1,2,3) alignA List(4,5)
  res = List(Some(1), Some(2), Some(3))
  
  scala&gt; List(1,2,3) alignB List(4,5)
  res = List(Some(4), Some(5), None)
  
  scala&gt; List(1,2,3) alignThis List(4,5)
  res = List(None, None, Some(3))
  
  scala&gt; List(1,2,3) alignThat List(4,5)
  res = List(None, None, None)
  
  scala&gt; List(1,2,3) alignBoth List(4,5)
  res = List(Some((1,4)), Some((2,5)), None)
</pre></div>

</figure>

<p>Note that the <code>A</code> and <code>B</code> variants use inclusive <code>OR</code>, whereas the
<code>This</code> and <code>That</code> variants are exclusive, returning <code>None</code> if there is
a value in both sides, or no value on either side.</p>

<h3 id="leanpub-auto-variance">
<a class="anchor-link" href="#leanpub-auto-variance"><i class="fa fa-link"></i></a><span class="section-number">5.5 </span>Variance</h3>

<p>We must return to <code>Functor</code> for a moment and discuss an ancestor that
we previously ignored:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-variance.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p><code>InvariantFunctor</code>, also known as the <em>exponential functor</em>, has a
method <code>xmap</code> which says that given a function from <code>A</code> to <code>B</code>, and a
function from <code>B</code> to <code>A</code>, then we can convert <code>F[A]</code> to <code>F[B]</code>.</p>

<p><code>Functor</code> is a short name for what should be <em>covariant functor</em>. But
since <code>Functor</code> is so popular it gets the nickname. Likewise
<code>Contravariant</code> should really be <em>contravariant functor</em>.</p>

<p><code>Functor</code> implements <code>xmap</code> with <code>map</code> and ignores the function from
<code>B</code> to <code>A</code>. <code>Contravariant</code>, on the other hand, implements <code>xmap</code> with
<code>contramap</code> and ignores the function from <code>A</code> to <code>B</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait InvariantFunctor[F[_]] {
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B]
    ...
  }
  
  @typeclass trait Functor[F[_]] extends InvariantFunctor[F] {
    def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B] = map(fa)(f)
    ...
  }
  
  @typeclass trait Contravariant[F[_]] extends InvariantFunctor[F] {
    def contramap[A, B](fa: F[A])(f: B =&gt; A): F[B]
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B] = contramap(fa)(g)
    ...
  }
</pre></div>

</figure>

<p>It is important to note that, although related at a theoretical level,
the words <em>covariant</em>, <em>contravariant</em> and <em>invariant</em> do not directly
refer to Scala type variance (i.e. <code>+</code> and <code>-</code> prefixes that may be
written in type signatures). <em>Invariance</em> here means that it is
possible to map the contents of a structure <code>F[A]</code> into <code>F[B]</code>. Using
<code>identity</code> we can see that <code>A</code> can be safely downcast (or upcast) into
<code>B</code> depending on the variance of the functor.</p>

<p><code>.map</code> may be understand by its contract “if you give me an <code>F</code> of <code>A</code> and a way
to turn an <code>A</code> into a <code>B</code>, then I can give you an <code>F</code> of <code>B</code>”.</p>

<p>Likewise, <code>.contramap</code> reads as “if you give me an <code>F</code> of <code>A</code> and a way to turn
a <code>B</code> into a <code>A</code>, then I can give you an <code>F</code> of <code>B</code>”.</p>

<p>We will consider an example: in our application we introduce domain specific
types <code>Alpha</code>, <code>Beta</code>, <code>Gamma</code>, etc, to ensure that we don’t mix up numbers in a
financial calculation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Alpha(value: Double)
</pre></div>

</figure>

<p>but now we’re faced with the problem that we don’t have any typeclasses for
these new types. If we use the values in JSON documents, we have to write
instances of <code>JsEncoder</code> and <code>JsDecoder</code>.</p>

<p>However, <code>JsEncoder</code> has a <code>Contravariant</code> and <code>JsDecoder</code> has a <code>Functor</code>, so
we can derive instances. Filling in the contract:</p>

<ul>
  <li>“if you give me a <code>JsDecoder</code> for a <code>Double</code>, and a way to go from a <code>Double</code>
to an <code>Alpha</code>, then I can give you a <code>JsDecoder</code> for an <code>Alpha</code>”.</li>
  <li>“if you give me a <code>JsEncoder</code> for a <code>Double</code>, and a way to go from an <code>Alpha</code>
to a <code>Double</code>, then I can give you a <code>JsEncoder</code> for an <code>Alpha</code>”.</li>
</ul>

<figure class="code">
<div class="highlight"><pre><code></code>  object Alpha {
    implicit val decoder: JsDecoder[Alpha] = JsDecoder[Double].map(Alpha(_))
    implicit val encoder: JsEncoder[Alpha] = JsEncoder[Double].contramap(_.value)
  }
</pre></div>

</figure>

<p>Methods on a typeclass can have their type parameters in <em>contravariant
position</em> (method parameters) or in <em>covariant position</em> (return type). If a
typeclass has a combination of covariant and contravariant positions, it might
have an <em>invariant functor</em>. For example, <code>Semigroup</code> and <code>Monoid</code> have an
<code>InvariantFunctor</code>, but not a <code>Functor</code> or a <code>Contravariant</code>.</p>

<h3 id="leanpub-auto-apply-and-bind">
<a class="anchor-link" href="#leanpub-auto-apply-and-bind"><i class="fa fa-link"></i></a><span class="section-number">5.6 </span>Apply and Bind</h3>

<p>Consider this the warm-up act to <code>Applicative</code> and <code>Monad</code></p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-apply.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-apply">
<a class="anchor-link" href="#leanpub-auto-apply"><i class="fa fa-link"></i></a><span class="section-number">5.6.1 </span>Apply</h4>

<p><code>Apply</code> extends <code>Functor</code> by adding a method named <code>ap</code> which is
similar to <code>map</code> in that it applies a function to values. However,
with <code>ap</code>, the function is in the same context as the values.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Apply[F[_]] extends Functor[F] {
    @op("&lt;*&gt;") def ap[A, B](fa: =&gt;F[A])(f: =&gt;F[A =&gt; B]): F[B]
    ...
</pre></div>

</figure>

<aside>
  <p><code>&lt;*&gt;</code> is the Advanced TIE Fighter, as flown by Darth Vader. Appropriate since it
looks like an angry parent. Or a sad Pikachu.</p>

</aside>

<p>It is worth taking a moment to consider what that means for a simple data
structure like <code>Option[A]</code>, having the following implementation of <code>.ap</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def option[A]: Apply[Option[A]] = new Apply[Option[A]] {
    override def ap[A, B](fa: =&gt;Option[A])(f: =&gt;Option[A =&gt; B]) = f match {
      case Some(ff) =&gt; fa.map(ff)
      case None    =&gt; None
    }
    ...
  }
</pre></div>

</figure>

<p>To implement <code>.ap</code>, we must first extract the function <code>ff: A =&gt; B</code> from <code>f:
Option[A =&gt; B]</code>, then we can map over <code>fa</code>. The extraction of the function from
the context is the important power that <code>Apply</code> brings, allowing multiple
function to be combined inside the context.</p>

<p>Returning to <code>Apply</code>, we find <code>.applyX</code> boilerplate that allows us to combine
parallel functions and then map over their combined output:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Apply[F[_]] extends Functor[F] {
    ...
    def apply2[A,B,C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C): F[C] = ...
    def apply3[A,B,C,D](fa: =&gt;F[A],fb: =&gt;F[B],fc: =&gt;F[C])(f: (A,B,C) =&gt;D): F[D] = ...
    ...
    def apply12[...]
</pre></div>

</figure>

<p>Read <code>.apply2</code> as a contract promising: “if you give me an <code>F</code> of <code>A</code> and an <code>F</code>
of <code>B</code>, with a way of combining <code>A</code> and <code>B</code> into a <code>C</code>, then I can give you an
<code>F</code> of <code>C</code>”. There are many uses for this contract and the two most important are:</p>

<ul>
  <li>constructing some typeclasses for a product type <code>C</code> from its constituents <code>A</code>
and <code>B</code>
</li>
  <li>performing <em>effects</em> in parallel, like the drone and google algebras we
created in Chapter 3, and then combining their results.</li>
</ul>

<p>Indeed, <code>Apply</code> is so useful that it has special syntax:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class ApplyOps[F[_]: Apply, A](self: F[A]) {
    def *&gt;[B](fb: F[B]): F[B] = Apply[F].apply2(self,fb)((_,b) =&gt; b)
    def &lt;*[B](fb: F[B]): F[A] = Apply[F].apply2(self,fb)((a,_) =&gt; a)
    def |@|[B](fb: F[B]): ApplicativeBuilder[F, A, B] = ...
  }
  
  class ApplicativeBuilder[F[_]: Apply, A, B](a: F[A], b: F[B]) {
    def tupled: F[(A, B)] = Apply[F].apply2(a, b)(Tuple2(_))
    def |@|[C](cc: F[C]): ApplicativeBuilder3[C] = ...
  
    sealed abstract class ApplicativeBuilder3[C](c: F[C]) {
      ..ApplicativeBuilder4
        ...
          ..ApplicativeBuilder12
  }
</pre></div>

</figure>

<p>which is exactly what we used in Chapter 3:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)
</pre></div>

</figure>

<aside>
  <p>The <code>|@|</code> operator has many names. Some call it the <em>Cartesian Product Syntax</em>,
others call it the <em>Cinnamon Bun</em>, the <em>Admiral Ackbar</em> or the <em>Macaulay
Culkin</em>. We prefer to call it <em>The Scream</em> operator, after the Munch painting,
because it is also the sound our CPU makes when it is parallelising All The
Things.</p>

</aside>

<p>The syntax <code>&lt;*</code> and <code>*&gt;</code> (left bird and right bird) offer a convenient way to
ignore the output from one of two parallel effects.</p>

<p>Unfortunately, although the <code>|@|</code> syntax is clear, there is a problem
in that a new <code>ApplicativeBuilder</code> object is allocated for each
additional effect. If the work is I/O-bound, the memory allocation
cost is insignificant. However, when performing CPU-bound work, use
the alternative <em>lifting with arity</em> syntax, which does not produce
any intermediate objects:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def ^[F[_]: Apply,A,B,C](fa: =&gt;F[A],fb: =&gt;F[B])(f: (A,B) =&gt;C): F[C] = ...
  def ^^[F[_]: Apply,A,B,C,D](fa: =&gt;F[A],fb: =&gt;F[B],fc: =&gt;F[C])(f: (A,B,C) =&gt;D): F[D] = ...
  ...
  def ^^^^^^[F[_]: Apply, ...]
</pre></div>

</figure>

<p>used like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ^^^^(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
</pre></div>

</figure>

<p>or directly call <code>applyX</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  Apply[F].apply5(d.getBacklog, d.getAgents, m.getManaged, m.getAlive, m.getTime)
</pre></div>

</figure>

<p>Despite being more commonly used with effects, <code>Apply</code> works just as well with
data structures. Consider rewriting</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    foo &lt;- data.foo: Option[String]
    bar &lt;- data.bar: Option[Int]
  } yield foo + bar.shows
</pre></div>

</figure>

<p>as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (data.foo |@| data.bar)(_ + _.shows)
</pre></div>

</figure>

<p>If we only want the combined output as a tuple, methods exist to do
just that:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @op("tuple") def tuple2[A,B](fa: =&gt;F[A],fb: =&gt;F[B]): F[(A,B)] = ...
  def tuple3[A,B,C](fa: =&gt;F[A],fb: =&gt;F[B],fc: =&gt;F[C]): F[(A,B,C)] = ...
  ...
  def tuple12[...]
</pre></div>

</figure>

<figure class="code">
<div class="highlight"><pre><code></code>  (data.foo tuple data.bar) : Option[(String, Int)]
</pre></div>

</figure>

<p>There are also the generalised versions of <code>ap</code> for more than two
parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def ap2[A,B,C](fa: =&gt;F[A],fb: =&gt;F[B])(f: F[(A,B) =&gt; C]): F[C] = ...
  def ap3[A,B,C,D](fa: =&gt;F[A],fb: =&gt;F[B],fc: =&gt;F[C])(f: F[(A,B,C) =&gt; D]): F[D] = ...
  ...
  def ap12[...]
</pre></div>

</figure>

<p>along with <code>.lift</code> methods that take normal functions and lift them into the
<code>F[_]</code> context, the generalisation of <code>Functor.lift</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def lift2[A,B,C](f: (A,B) =&gt; C): (F[A],F[B]) =&gt; F[C] = ...
  def lift3[A,B,C,D](f: (A,B,C) =&gt; D): (F[A],F[B],F[C]) =&gt; F[D] = ...
  ...
  def lift12[...]
</pre></div>

</figure>

<p>and <code>.apF</code>, a partially applied syntax for <code>ap</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def apF[A,B](f: =&gt;F[A =&gt; B]): F[A] =&gt; F[B] = ...
</pre></div>

</figure>

<p>Finally <code>.forever</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def forever[A, B](fa: F[A]): F[B] = ...
</pre></div>

</figure>

<p>repeating an effect without stopping. The instance of <code>Apply</code> must be
stack safe or we will get <code>StackOverflowError</code>.</p>

<h4 id="leanpub-auto-bind">
<a class="anchor-link" href="#leanpub-auto-bind"><i class="fa fa-link"></i></a><span class="section-number">5.6.2 </span>Bind</h4>

<p><code>Bind</code> introduces <code>.bind</code>, synonymous with <code>.flatMap</code>, which allows functions
over the result of an effect to return a new effect, or for functions over the
values of a data structure to return new data structures that are then joined.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Bind[F[_]] extends Apply[F] {
  
    @op("&gt;&gt;=") def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
    def flatMap[A, B](fa: F[A])(f: A =&gt; F[B]): F[B] = bind(fa)(f)
  
    override def ap[A, B](fa: =&gt;F[A])(f: =&gt;F[A =&gt; B]): F[B] =
      bind(f)(x =&gt; map(fa)(x))
    override def apply2[A, B, C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C): F[C] =
      bind(fa)(a =&gt; map(fb)(b =&gt; f(a, b)))
  
    def join[A](ffa: F[F[A]]): F[A] = bind(ffa)(identity)
  
    def mproduct[A, B](fa: F[A])(f: A =&gt; F[B]): F[(A, B)] = ...
    def ifM[B](value: F[Boolean], t: =&gt;F[B], f: =&gt;F[B]): F[B] = ...
  
  }
</pre></div>

</figure>

<p>The <code>.join</code> may be familiar to users of <code>.flatten</code> in the stdlib, it takes a
nested context and squashes it into one.</p>

<p>Derived combinators are introduced for <code>.ap</code> and <code>.apply2</code> that require
consistency with <code>.bind</code>. We will see later that this law has consequences for
parallelisation strategies.</p>

<p><code>mproduct</code> is like <code>Functor.fproduct</code> and pairs the function’s input
with its output, inside the <code>F</code>.</p>

<p><code>ifM</code> is a way to construct a conditional data structure or effect:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List(true, false, true).ifM(List(0), List(1, 1))
  res: List[Int] = List(0, 1, 1, 0)
</pre></div>

</figure>

<p><code>ifM</code> and <code>ap</code> are optimised to cache and reuse code branches, compare
to the longer form</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List(true, false, true).flatMap { b =&gt; if (b) List(0) else List(1, 1) }
</pre></div>

</figure>

<p>which produces a fresh <code>List(0)</code> or <code>List(1, 1)</code> every time the branch
is invoked.</p>

<aside>
  <p>These kinds of optimisations are possible in FP because all methods
are deterministic, also known as <em>referentially transparent</em>.</p>

  <p>If a method returns a different value every time it is called, it is
<em>impure</em> and breaks the reasoning and optimisations that we can
otherwise make.</p>

  <p>If the <code>F</code> is an effect, perhaps one of our drone or Google algebras,
it does not mean that the output of the call to the algebra is cached.
Rather the reference to the operation is cached. The performance
optimisation of <code>ifM</code> is only noticeable for data structures, and more
pronounced with the difficulty of the work in each branch.</p>

  <p>We will explore the concept of determinism and value caching in more
detail in the next chapter.</p>

</aside>

<p><code>Bind</code> also has some special syntax</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class BindOps[F[_]: Bind, A] (self: F[A]) {
    def &gt;&gt;[B](b: =&gt;F[B]): F[B] = Bind[F].bind(self)(_ =&gt; b)
    def &gt;&gt;![B](f: A =&gt; F[B]): F[A] = Bind[F].bind(self)(a =&gt; f(a).map(_ =&gt; a))
  }
</pre></div>

</figure>

<p><code>&gt;&gt;</code> is when we wish to discard the input to <code>bind</code> and <code>&gt;&gt;!</code> is when
we want to run an effect but discard its output.</p>

<h3 id="leanpub-auto-applicative-and-monad">
<a class="anchor-link" href="#leanpub-auto-applicative-and-monad"><i class="fa fa-link"></i></a><span class="section-number">5.7 </span>Applicative and Monad</h3>

<p>From a functionality point of view, <code>Applicative</code> is <code>Apply</code> with a
<code>pure</code> method, and <code>Monad</code> extends <code>Applicative</code> with <code>Bind</code>.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-applicative.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Applicative[F[_]] extends Apply[F] {
    def point[A](a: =&gt;A): F[A]
    def pure[A](a: =&gt;A): F[A] = point(a)
  }
  
  @typeclass trait Monad[F[_]] extends Applicative[F] with Bind[F]
</pre></div>

</figure>

<p>In many ways, <code>Applicative</code> and <code>Monad</code> are the culmination of everything we’ve
seen in this chapter. <code>.pure</code> (or <code>.point</code> as it is more commonly known for data
structures) allows us to create effects or data structures from values.</p>

<p>Instances of <code>Applicative</code> must meet some laws, effectively asserting
that all the methods are consistent:</p>

<ul>
  <li>
<strong>Identity</strong>: <code>fa &lt;*&gt; pure(identity) === fa</code>, (where <code>fa</code> is an <code>F[A]</code>) i.e.
applying <code>pure(identity)</code> does nothing.</li>
  <li>
<strong>Homomorphism</strong>: <code>pure(a) &lt;*&gt; pure(ab) === pure(ab(a))</code> (where <code>ab</code> is an <code>A =&gt;
  B</code>), i.e. applying a <code>pure</code> function to a <code>pure</code> value is the same as applying
the function to the value and then using <code>pure</code> on the result.</li>
  <li>
<strong>Interchange</strong>: <code>pure(a) &lt;*&gt; fab === fab &lt;*&gt; pure(f =&gt; f(a))</code>, (where <code>fab</code> is
an <code>F[A =&gt; B]</code>), i.e. <code>pure</code> is a left and right identity</li>
  <li>
<strong>Mappy</strong>: <code>map(fa)(f) === fa &lt;*&gt; pure(f)</code>
</li>
</ul>

<p><code>Monad</code> adds additional laws:</p>

<ul>
  <li>
<strong>Left Identity</strong>: <code>pure(a).bind(f) === f(a)</code>
</li>
  <li>
<strong>Right Identity</strong>: <code>a.bind(pure(_)) === a</code>
</li>
  <li>
<strong>Associativity</strong>: <code>fa.bind(f).bind(g) === fa.bind(a =&gt; f(a).bind(g))</code> where
<code>fa</code> is an <code>F[A]</code>, <code>f</code> is an <code>A =&gt; F[B]</code> and <code>g</code> is a <code>B =&gt; F[C]</code>.</li>
</ul>

<p>Associativity says that chained <code>bind</code> calls must agree with nested
<code>bind</code>. However, it does not mean that we can rearrange the order,
which would be <em>commutativity</em>. For example, recalling that <code>flatMap</code>
is an alias to <code>bind</code>, we cannot rearrange</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _ &lt;- machine.start(node1)
    _ &lt;- machine.stop(node1)
  } yield true
</pre></div>

</figure>

<p>as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _ &lt;- machine.stop(node1)
    _ &lt;- machine.start(node1)
  } yield true
</pre></div>

</figure>

<p><code>start</code> and <code>stop</code> are <strong>non</strong>-<em>commutative</em>, because the intended
effect of starting then stopping a node is different to stopping then
starting it!</p>

<p>But <code>start</code> is commutative with itself, and <code>stop</code> is commutative with
itself, so we can rewrite</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _ &lt;- machine.start(node1)
    _ &lt;- machine.start(node2)
  } yield true
</pre></div>

</figure>

<p>as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _ &lt;- machine.start(node2)
    _ &lt;- machine.start(node1)
  } yield true
</pre></div>

</figure>

<p>which are equivalent for our algebra, but not in general. We’re making a lot of
assumptions about the Google Container API here, but this is a reasonable choice
to make.</p>

<p>A practical consequence is that a <code>Monad</code> must be <em>commutative</em> if its
<code>applyX</code> methods can be allowed to run in parallel. We cheated in
Chapter 3 when we ran these effects in parallel</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (d.getBacklog |@| d.getAgents |@| m.getManaged |@| m.getAlive |@| m.getTime)
</pre></div>

</figure>

<p>because we know that they are commutative among themselves. When it comes to
interpreting our application, later in the book, we will have to provide
evidence that these effects are in fact commutative, or an asynchronous
implementation may choose to sequence the operations to be on the safe side.</p>

<p>The subtleties of how we deal with (re)-ordering of effects, and what
those effects are, deserves a dedicated chapter on Advanced Monads.</p>

<h3 id="leanpub-auto-divide-and-conquer">
<a class="anchor-link" href="#leanpub-auto-divide-and-conquer"><i class="fa fa-link"></i></a><span class="section-number">5.8 </span>Divide and Conquer</h3>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-divide.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p><code>Divide</code> is the <code>Contravariant</code> analogue of <code>Apply</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Divide[F[_]] extends Contravariant[F] {
    def divide[A, B, C](fa: F[A], fb: F[B])(f: C =&gt; (A, B)): F[C] = divide2(fa, fb)(f)
  
    def divide1[A1, Z](a1: F[A1])(f: Z =&gt; A1): F[Z] = ...
    def divide2[A, B, C](fa: F[A], fb: F[B])(f: C =&gt; (A, B)): F[C] = ...
    ...
    def divide22[...] = ...
</pre></div>

</figure>

<p><code>divide</code> says that if we can break a <code>C</code> into an <code>A</code> and a <code>B</code>, and
we’re given an <code>F[A]</code> and an <code>F[B]</code>, then we can get an <code>F[C]</code>. Hence,
<em>divide and conquer</em>.</p>

<p>This is a great way to generate contravariant typeclass instances for
product types by breaking the products into their parts. Scalaz has an
instance of <code>Divide[Equal]</code>, let’s construct an <code>Equal</code> for a new
product type <code>Foo</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; case class Foo(s: String, i: Int)
  scala&gt; implicit val fooEqual: Equal[Foo] =
           Divide[Equal].divide2(Equal[String], Equal[Int]) {
             (foo: Foo) =&gt; (foo.s, foo.i)
           }
  scala&gt; Foo("foo", 1) === Foo("bar", 1)
  res: Boolean = false
</pre></div>

</figure>

<p>Mirroring <code>Apply</code>, <code>Divide</code> also has terse syntax for tuples. A softer
<em>divide so that we may reign</em> approach to world domination:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    def tuple2[A1, A2](a1: F[A1], a2: F[A2]): F[(A1, A2)] = ...
    ...
    def tuple22[...] = ...
  }
</pre></div>

</figure>

<p>Generally, if encoder typeclasses can provide an instance of <code>Divide</code>,
rather than stopping at <code>Contravariant</code>, it makes it possible to
derive instances for any <code>case class</code>. Similarly, decoder typeclasses
can provide an <code>Apply</code> instance. We will explore this in a dedicated
chapter on Typeclass Derivation.</p>

<p><code>Divisible</code> is the <code>Contravariant</code> analogue of <code>Applicative</code> and introduces
<code>.conquer</code>, the equivalent of <code>.pure</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Divisible[F[_]] extends Divide[F] {
    def conquer[A]: F[A]
  }
</pre></div>

</figure>

<p><code>.conquer</code> allows creating trivial implementations where the type parameter is
ignored. Such values are called <em>universally quantified</em>. For example, the
<code>Divisible[Equal].conquer[INil[String]]</code> returns an implementation of <code>Equal</code>
for an empty list of <code>String</code> which is always <code>true</code>.</p>

<h3 id="leanpub-auto-plus">
<a class="anchor-link" href="#leanpub-auto-plus"><i class="fa fa-link"></i></a><span class="section-number">5.9 </span>Plus</h3>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-plus.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p><code>Plus</code> is <code>Semigroup</code> but for type constructors, and <code>PlusEmpty</code> is
the equivalent of <code>Monoid</code> (they even have the same laws) whereas
<code>IsEmpty</code> is novel and allows us to query if an <code>F[A]</code> is empty:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Plus[F[_]] {
    @op("&lt;+&gt;") def plus[A](a: F[A], b: =&gt;F[A]): F[A]
  }
  @typeclass trait PlusEmpty[F[_]] extends Plus[F] {
    def empty[A]: F[A]
  }
  @typeclass trait IsEmpty[F[_]] extends PlusEmpty[F] {
    def isEmpty[A](fa: F[A]): Boolean
  }
</pre></div>

</figure>

<aside>
  <p><code>&lt;+&gt;</code> is the TIE Interceptor, and now we’re almost out of TIE
Fighters…</p>

</aside>

<p>Although it may look on the surface as if <code>&lt;+&gt;</code> behaves like <code>|+|</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List(2,3) |+| List(7)
  res = List(2, 3, 7)
  
  scala&gt; List(2,3) &lt;+&gt; List(7)
  res = List(2, 3, 7)
</pre></div>

</figure>

<p>it is best to think of it as operating only at the <code>F[_]</code> level, never looking
into the contents. <code>Plus</code> has the convention that it should ignore failures and
“pick the first winner”. <code>&lt;+&gt;</code> can therefore be used as a mechanism for early
exit (losing information) and failure-handling via fallbacks:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Option(1) |+| Option(2)
  res = Some(3)
  
  scala&gt; Option(1) &lt;+&gt; Option(2)
  res = Some(1)
  
  scala&gt; Option.empty[Int] &lt;+&gt; Option(1)
  res = Some(1)
</pre></div>

</figure>

<p>For example, if we have a <code>NonEmptyList[Option[Int]]</code> and we want to ignore
<code>None</code> values (failures) and pick the first winner (<code>Some</code>), we can call <code>&lt;+&gt;</code>
from <code>Foldable1.foldRight1</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; NonEmptyList(None, None, Some(1), Some(2), None)
         .foldRight1(_ &lt;+&gt; _)
  res: Option[Int] = Some(1)
</pre></div>

</figure>

<p>In fact, now that we know about <code>Plus</code>, we realise that we didn’t need to break
typeclass coherence (when we defined a locally scoped <code>Monoid[Option[A]]</code>) in
the section on Appendable Things. Our objective was to “pick the last winner”,
which is the same as “pick the winner” if the arguments are swapped. Note the
use of the TIE Interceptor for <code>ccy</code> and <code>otc</code> with arguments swapped.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
    (a, b) =&gt; TradeTemplate(a.payments |+| b.payments,
                            b.ccy &lt;+&gt; a.ccy,
                            b.otc &lt;+&gt; a.otc),
    TradeTemplate(Nil, None, None)
  )
</pre></div>

</figure>

<p><code>Applicative</code> and <code>Monad</code> have specialised versions of <code>PlusEmpty</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait ApplicativePlus[F[_]] extends Applicative[F] with PlusEmpty[F]
  
  @typeclass trait MonadPlus[F[_]] extends Monad[F] with ApplicativePlus[F] {
    def unite[T[_]: Foldable, A](ts: F[T[A]]): F[A] = ...
  
    def withFilter[A](fa: F[A])(f: A =&gt; Boolean): F[A] = ...
  }
</pre></div>

</figure>

<p><code>.unite</code> lets us fold a data structure using the outer container’s
<code>PlusEmpty[F].monoid</code> rather than the inner content’s <code>Monoid</code>. For
<code>List[Either[String, Int]]</code> this means <code>Left[String]</code> values are converted into
<code>.empty</code>, then everything is concatenated. A convenient way to discard errors:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List(Right(1), Left("boo"), Right(2)).unite
  res: List[Int] = List(1, 2)
  
  scala&gt; val boo: Either[String, Int] = Left("boo")
         boo.foldMap(a =&gt; a.pure[List])
  res: List[String] = List()
  
  scala&gt; val n: Either[String, Int] = Right(1)
         n.foldMap(a =&gt; a.pure[List])
  res: List[Int] = List(1)
</pre></div>

</figure>

<p><code>withFilter</code> allows us to make use of <code>for</code> comprehension language
support as discussed in Chapter 2. It is fair to say that the Scala
language has built-in language support for <code>MonadPlus</code>, not just
<code>Monad</code>!</p>

<p>Returning to <code>Foldable</code> for a moment, we can reveal some methods that
we did not discuss earlier</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Foldable[F[_]] {
    ...
    def msuml[G[_]: PlusEmpty, A](fa: F[G[A]]): G[A] = ...
    def collapse[X[_]: ApplicativePlus, A](x: F[A]): X[A] = ...
    ...
  }
</pre></div>

</figure>

<p><code>msuml</code> does a <code>fold</code> using the <code>Monoid</code> from the <code>PlusEmpty[G]</code> and
<code>collapse</code> does a <code>foldRight</code> using the <code>PlusEmpty</code> of the target
type:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; IList(Option(1), Option.empty[Int], Option(2)).fold
  res: Option[Int] = Some(3) // uses Monoid[Option[Int]]
  
  scala&gt; IList(Option(1), Option.empty[Int], Option(2)).msuml
  res: Option[Int] = Some(1) // uses PlusEmpty[Option].monoid
  
  scala&gt; IList(1, 2).collapse[Option]
  res: Option[Int] = Some(1)
</pre></div>

</figure>

<h3 id="leanpub-auto-lone-wolves">
<a class="anchor-link" href="#leanpub-auto-lone-wolves"><i class="fa fa-link"></i></a><span class="section-number">5.10 </span>Lone Wolves</h3>

<p>Some of the typeclasses in Scalaz are stand-alone and not part of the
larger hierarchy.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-loners.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-zippy">
<a class="anchor-link" href="#leanpub-auto-zippy"><i class="fa fa-link"></i></a><span class="section-number">5.10.1 </span>Zippy</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Zip[F[_]]  {
    def zip[A, B](a: =&gt;F[A], b: =&gt;F[B]): F[(A, B)]
  
    def zipWith[A, B, C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C)
                        (implicit F: Functor[F]): F[C] = ...
  
    def ap(implicit F: Functor[F]): Apply[F] = ...
  
    @op("&lt;*|*&gt;") def apzip[A, B](f: =&gt;F[A] =&gt; F[B], a: =&gt;F[A]): F[(A, B)] = ...
  
  }
</pre></div>

</figure>

<p>The core method is <code>zip</code> which is a less powerful version of
<code>Divide.tuple2</code>, and if a <code>Functor[F]</code> is provided then <code>zipWith</code> can
behave like <code>Apply.apply2</code>. Indeed, an <code>Apply[F]</code> can be created from
a <code>Zip[F]</code> and a <code>Functor[F]</code> by calling <code>ap</code>.</p>

<p><code>apzip</code> takes an <code>F[A]</code> and a lifted function from <code>F[A] =&gt; F[B]</code>,
producing an <code>F[(A, B)]</code> similar to <code>Functor.fproduct</code>.</p>

<aside>
  <p><code>&lt;*|*&gt;</code> is the creepy Jawa operator.</p>

</aside>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Unzip[F[_]]  {
    @op("unfzip") def unzip[A, B](a: F[(A, B)]): (F[A], F[B])
  
    def firsts[A, B](a: F[(A, B)]): F[A] = ...
    def seconds[A, B](a: F[(A, B)]): F[B] = ...
  
    def unzip3[A, B, C](x: F[(A, (B, C))]): (F[A], F[B], F[C]) = ...
    ...
    def unzip7[A ... H](x: F[(A, (B, ... H))]): ...
  }
</pre></div>

</figure>

<p>The core method is <code>unzip</code> with <code>firsts</code> and <code>seconds</code> allowing for
selecting either the first or second element of a tuple in the <code>F</code>.
Importantly, <code>unzip</code> is the opposite of <code>zip</code>.</p>

<p>The methods <code>unzip3</code> to <code>unzip7</code> are repeated applications of <code>unzip</code>
to save on boilerplate. For example, if handed a bunch of nested
tuples, the <code>Unzip[Id]</code> is a handy way to flatten them:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Unzip[Id].unzip7((1, (2, (3, (4, (5, (6, 7)))))))
  res = (1,2,3,4,5,6,7)
</pre></div>

</figure>

<p>In a nutshell, <code>Zip</code> and <code>Unzip</code> are less powerful versions of
<code>Divide</code> and <code>Apply</code>, providing useful features without requiring the
<code>F</code> to make too many promises.</p>

<h4 id="leanpub-auto-optional">
<a class="anchor-link" href="#leanpub-auto-optional"><i class="fa fa-link"></i></a><span class="section-number">5.10.2 </span>Optional</h4>

<p><code>Optional</code> is a generalisation of data structures that can optionally
contain a value, like <code>Option</code> and <code>Either</code>.</p>

<p>Recall that <code>\/</code> (<em>disjunction</em>) is Scalaz’s improvement of
<code>scala.Either</code>. We will also see <code>Maybe</code>, Scalaz’s improvement of
<code>scala.Option</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Maybe[A]
  final case class Empty[A]()    extends Maybe[A]
  final case class Just[A](a: A) extends Maybe[A]
</pre></div>

</figure>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Optional[F[_]] {
    def pextract[B, A](fa: F[A]): F[B] \/ A
  
    def getOrElse[A](fa: F[A])(default: =&gt;A): A = ...
    def orElse[A](fa: F[A])(alt: =&gt;F[A]): F[A] = ...
  
    def isDefined[A](fa: F[A]): Boolean = ...
    def nonEmpty[A](fa: F[A]): Boolean = ...
    def isEmpty[A](fa: F[A]): Boolean = ...
  
    def toOption[A](fa: F[A]): Option[A] = ...
    def toMaybe[A](fa: F[A]): Maybe[A] = ...
  }
</pre></div>

</figure>

<p>These are methods that should be familiar, except perhaps <code>pextract</code>,
which is a way of letting the <code>F[_]</code> return some implementation
specific <code>F[B]</code> or the value. For example, <code>Optional[Option].pextract</code>
returns <code>Option[Nothing] \/ A</code>, i.e. <code>None \/ A</code>.</p>

<p>Scalaz gives a ternary operator to things that have an <code>Optional</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class OptionalOps[F[_]: Optional, A](fa: F[A]) {
    def ?[X](some: =&gt;X): Conditional[X] = new Conditional[X](some)
    final class Conditional[X](some: =&gt;X) {
      def |(none: =&gt;X): X = if (Optional[F].isDefined(fa)) some else none
    }
  }
</pre></div>

</figure>

<p>for example</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val knock_knock: Option[String] = ...
         knock_knock ? "who's there?" | "&lt;tumbleweed&gt;"
</pre></div>

</figure>

<h3 id="leanpub-auto-co-things">
<a class="anchor-link" href="#leanpub-auto-co-things"><i class="fa fa-link"></i></a><span class="section-number">5.11 </span>Co-things</h3>

<p>A <em>co-thing</em> typically has some opposite type signature to whatever
<em>thing</em> does, but is not necessarily its inverse. To highlight the
relationship between <em>thing</em> and <em>co-thing</em>, we will include the type
signature of <em>thing</em> wherever we can.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 100%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-cothings.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>



<div class="figure-wrapper center">
  <figure class="image" style="width: 80%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-coloners.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h4 id="leanpub-auto-cobind">
<a class="anchor-link" href="#leanpub-auto-cobind"><i class="fa fa-link"></i></a><span class="section-number">5.11.1 </span>Cobind</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Cobind[F[_]] extends Functor[F] {
    def cobind[A, B](fa: F[A])(f: F[A] =&gt; B): F[B]
  //def   bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  
    def cojoin[A](fa: F[A]): F[F[A]] = ...
  //def   join[A](ffa: F[F[A]]): F[A] = ...
  }
</pre></div>

</figure>

<p><code>cobind</code> (also known as <code>coflatmap</code>) takes an <code>F[A] =&gt; B</code> that acts on
an <code>F[A]</code> rather than its elements. But this is not necessarily the
full <code>fa</code>, it is usually some substructure as defined by <code>cojoin</code>
(also known as <code>coflatten</code>) which expands a data structure.</p>

<p>Compelling use-cases for <code>Cobind</code> are rare, although when shown in the
<code>Functor</code> permutation table (for <code>F[_]</code>, <code>A</code> and <code>B</code>) it is difficult
to argue why any method should be less important than the others:</p>

<table>
  <thead>
    <tr>
      <th>method</th>
      <th>parameter</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>map</code></td>
      <td><code>A =&gt; B</code></td>
    </tr>
    <tr>
      <td><code>contramap</code></td>
      <td><code>B =&gt; A</code></td>
    </tr>
    <tr>
      <td><code>xmap</code></td>
      <td><code>(A =&gt; B, B =&gt; A)</code></td>
    </tr>
    <tr>
      <td><code>ap</code></td>
      <td><code>F[A =&gt; B]</code></td>
    </tr>
    <tr>
      <td><code>bind</code></td>
      <td><code>A =&gt; F[B]</code></td>
    </tr>
    <tr>
      <td><code>cobind</code></td>
      <td><code>F[A] =&gt; B</code></td>
    </tr>
  </tbody>

</table>

<h4 id="leanpub-auto-comonad">
<a class="anchor-link" href="#leanpub-auto-comonad"><i class="fa fa-link"></i></a><span class="section-number">5.11.2 </span>Comonad</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Comonad[F[_]] extends Cobind[F] {
    def copoint[A](p: F[A]): A
  //def   point[A](a: =&gt;A): F[A]
  }
</pre></div>

</figure>

<p><code>.copoint</code> (also <code>.copure</code>) unwraps an element from its context. Effects do not
typically have an instance of <code>Comonad</code> since would break referential
transparency to interpret an <code>IO[A]</code> into an <code>A</code>. But for collection-like <em>data
structures</em>, it is a way to construct a view of all elements alongside their
neighbours.</p>

<p>Consider a <em>neighbourhood</em> (<code>Hood</code> for short) for a list containing all the
elements to the left of an element (<code>lefts</code>), the element itself (the <code>focus</code>),
and all the elements to its right (<code>rights</code>).</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Hood[A](lefts: IList[A], focus: A, rights: IList[A])
</pre></div>

</figure>

<p>The <code>lefts</code> and <code>rights</code> should each be ordered with the nearest to
the <code>focus</code> at the head, such that we can recover the original <code>IList</code>
via <code>.toIList</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Hood {
    implicit class Ops[A](hood: Hood[A]) {
      def toIList: IList[A] = hood.lefts.reverse ::: hood.focus :: hood.rights
</pre></div>

</figure>

<p>We can write methods that let us move the focus one to the left
(<code>previous</code>) and one to the right (<code>next</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
      def previous: Maybe[Hood[A]] = hood.lefts match {
        case INil() =&gt; Empty()
        case ICons(head, tail) =&gt;
          Just(Hood(tail, head, hood.focus :: hood.rights))
      }
      def next: Maybe[Hood[A]] = hood.rights match {
        case INil() =&gt; Empty()
        case ICons(head, tail) =&gt;
          Just(Hood(hood.focus :: hood.lefts, head, tail))
      }
</pre></div>

</figure>

<p>By introducing <code>more</code> to repeatedly apply an optional function to
<code>Hood</code> we can calculate <em>all</em> the <code>positions</code> that <code>Hood</code> can take in
the list</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
      def more(f: Hood[A] =&gt; Maybe[Hood[A]]): IList[Hood[A]] =
        f(hood) match {
          case Empty() =&gt; INil()
          case Just(r) =&gt; ICons(r, r.more(f))
        }
      def positions: Hood[Hood[A]] = {
        val left  = hood.more(_.previous)
        val right = hood.more(_.next)
        Hood(left, hood, right)
      }
    }
</pre></div>

</figure>

<p>We can now implement <code>Comonad[Hood]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    implicit val comonad: Comonad[Hood] = new Comonad[Hood] {
      def map[A, B](fa: Hood[A])(f: A =&gt; B): Hood[B] =
        Hood(fa.lefts.map(f), f(fa.focus), fa.rights.map(f))
      def cobind[A, B](fa: Hood[A])(f: Hood[A] =&gt; B): Hood[B] =
        fa.positions.map(f)
      def copoint[A](fa: Hood[A]): A = fa.focus
    }
  }
</pre></div>

</figure>

<p><code>cojoin</code> gives us a <code>Hood[Hood[IList]]</code> containing all the possible
neighbourhoods in our initial <code>IList</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val middle = Hood(IList(4, 3, 2, 1), 5, IList(6, 7, 8, 9))
  scala&gt; middle.cojoin
  res = Hood(
          [Hood([3,2,1],4,[5,6,7,8,9]),
           Hood([2,1],3,[4,5,6,7,8,9]),
           Hood([1],2,[3,4,5,6,7,8,9]),
           Hood([],1,[2,3,4,5,6,7,8,9])],
          Hood([4,3,2,1],5,[6,7,8,9]),
          [Hood([5,4,3,2,1],6,[7,8,9]),
           Hood([6,5,4,3,2,1],7,[8,9]),
           Hood([7,6,5,4,3,2,1],8,[9]),
           Hood([8,7,6,5,4,3,2,1],9,[])])
</pre></div>

</figure>

<p>Indeed, <code>cojoin</code> is just <code>positions</code>! We can <code>override</code> it with a more
direct (and performant) implementation</p>

<figure class="code">
<div class="highlight"><pre><code></code>  override def cojoin[A](fa: Hood[A]): Hood[Hood[A]] = fa.positions
</pre></div>

</figure>

<p><code>Comonad</code> generalises the concept of <code>Hood</code> to arbitrary data
structures. <code>Hood</code> is an example of a <em>zipper</em> (unrelated to <code>Zip</code>).
Scalaz comes with a <code>Zipper</code> data type for streams (i.e. infinite 1D
data structures), which we will discuss in the next chapter.</p>

<p>One application of a zipper is for <em>cellular automata</em>, which compute
the value of each cell in the next generation by performing a
computation based on the neighbourhood of that cell.</p>

<h4 id="leanpub-auto-cozip">
<a class="anchor-link" href="#leanpub-auto-cozip"><i class="fa fa-link"></i></a><span class="section-number">5.11.3 </span>Cozip</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Cozip[F[_]] {
    def cozip[A, B](x: F[A \/ B]): F[A] \/ F[B]
  //def   zip[A, B](a: =&gt;F[A], b: =&gt;F[B]): F[(A, B)]
  //def unzip[A, B](a: F[(A, B)]): (F[A], F[B])
  
    def cozip3[A, B, C](x: F[A \/ (B \/ C)]): F[A] \/ (F[B] \/ F[C]) = ...
    ...
    def cozip7[A ... H](x: F[(A \/ (... H))]): F[A] \/ (... F[H]) = ...
  }
</pre></div>

</figure>

<p>Although named <code>cozip</code>, it is perhaps more appropriate to talk about
its symmetry with <code>unzip</code>. Whereas <code>unzip</code> splits <code>F[_]</code> of tuples
(products) into tuples of <code>F[_]</code>, <code>cozip</code> splits <code>F[_]</code> of
disjunctions (coproducts) into disjunctions of <code>F[_]</code>.</p>

<h3 id="leanpub-auto-bi-things">
<a class="anchor-link" href="#leanpub-auto-bi-things"><i class="fa fa-link"></i></a><span class="section-number">5.12 </span>Bi-things</h3>

<p>Sometimes we may find ourselves with a thing that has two type holes
and we want to <code>map</code> over both sides. For example we might be tracking
failures in the left of an <code>Either</code> and we want to do something with the
failure messages.</p>

<p>The <code>Functor</code> / <code>Foldable</code> / <code>Traverse</code> typeclasses have bizarro
relatives that allow us to map both ways.</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 30%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-bithings.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Bifunctor[F[_, _]] {
    def bimap[A, B, C, D](fab: F[A, B])(f: A =&gt; C, g: B =&gt; D): F[C, D]
  
    @op("&lt;-:") def leftMap[A, B, C](fab: F[A, B])(f: A =&gt; C): F[C, B] = ...
    @op(":-&gt;") def rightMap[A, B, D](fab: F[A, B])(g: B =&gt; D): F[A, D] = ...
    @op("&lt;:&gt;") def umap[A, B](faa: F[A, A])(f: A =&gt; B): F[B, B] = ...
  }
  
  @typeclass trait Bifoldable[F[_, _]] {
    def bifoldMap[A, B, M: Monoid](fa: F[A, B])(f: A =&gt; M)(g: B =&gt; M): M
  
    def bifoldRight[A,B,C](fa: F[A, B], z: =&gt;C)(f: (A, =&gt;C) =&gt; C)(g: (B, =&gt;C) =&gt; C): C
    def bifoldLeft[A,B,C](fa: F[A, B], z: C)(f: (C, A) =&gt; C)(g: (C, B) =&gt; C): C = ...
  
    def bifoldMap1[A, B, M: Semigroup](fa: F[A,B])(f: A =&gt; M)(g: B =&gt; M): Option[M] = ...
  }
  
  @typeclass trait Bitraverse[F[_, _]] extends Bifunctor[F] with Bifoldable[F] {
    def bitraverse[G[_]: Applicative, A, B, C, D](fab: F[A, B])
                                                 (f: A =&gt; G[C])
                                                 (g: B =&gt; G[D]): G[F[C, D]]
  
    def bisequence[G[_]: Applicative, A, B](x: F[G[A], G[B]]): G[F[A, B]] = ...
  }
</pre></div>

</figure>

<aside>
  <p><code>&lt;-:</code> and <code>:-&gt;</code> are the happy operators!</p>

</aside>

<p>Although the type signatures are verbose, these are nothing more than
the core methods of <code>Functor</code>, <code>Foldable</code> and <code>Bitraverse</code> taking two
functions instead of one, often requiring both functions to return the
same type so that their results can be combined with a <code>Monoid</code> or
<code>Semigroup</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val a: Either[String, Int] = Left("fail")
         val b: Either[String, Int] = Right(13)
  
  scala&gt; b.bimap(_.toUpperCase, _ * 2)
  res: Either[String, Int] = Right(26)
  
  scala&gt; a.bimap(_.toUpperCase, _ * 2)
  res: Either[String, Int] = Left(FAIL)
  
  scala&gt; b :-&gt; (_ * 2)
  res: Either[String,Int] = Right(26)
  
  scala&gt; a :-&gt; (_ * 2)
  res: Either[String, Int] = Left(fail)
  
  scala&gt; { s: String =&gt; s.length } &lt;-: a
  res: Either[Int, Int] = Left(4)
  
  scala&gt; a.bifoldMap(_.length)(identity)
  res: Int = 4
  
  scala&gt; b.bitraverse(s =&gt; Future(s.length), i =&gt; Future(i))
  res: Future[Either[Int, Int]] = Future(&lt;not completed&gt;)
</pre></div>

</figure>

<p>In addition, we can revisit <code>MonadPlus</code> (recall it is <code>Monad</code> with the
ability to <code>filterWith</code> and <code>unite</code>) and see that it can <code>separate</code>
<code>Bifoldable</code> contents of a <code>Monad</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadPlus[F[_]] {
    ...
    def separate[G[_, _]: Bifoldable, A, B](value: F[G[A, B]]): (F[A], F[B]) = ...
    ...
  }
</pre></div>

</figure>

<p>This is very useful if we have a collection of bi-things and we want
to reorganise them into a collection of <code>A</code> and a collection of <code>B</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val list: List[Either[Int, String]] =
           List(Right("hello"), Left(1), Left(2), Right("world"))
  
  scala&gt; list.separate
  res: (List[Int], List[String]) = (List(1, 2), List(hello, world))
</pre></div>

</figure>

<h3 id="leanpub-auto-summary-3">
<a class="anchor-link" href="#leanpub-auto-summary-3"><i class="fa fa-link"></i></a><span class="section-number">5.13 </span>Summary</h3>

<p>That was a lot of material! We have just explored a standard library
of polymorphic functionality. But to put it into perspective: there
are more traits in the Scala stdlib Collections API than typeclasses
in Scalaz.</p>

<p>It is normal for an FP application to only touch a small percentage of the
typeclass hierarchy, with most functionality coming from domain-specific
algebras and typeclasses. Even if the domain-specific typeclasses are just
specialised clones of something in Scalaz, it is OK to refactor it later.</p>

<p>To help, we have included a cheat-sheet of the typeclasses and their
primary methods in the Appendix, inspired by Adam Rosien’s <a href="http://arosien.github.io/scalaz-cheatsheets/typeclasses.pdf">Scalaz
Cheatsheet</a>.</p>

<p>To help further, Valentin Kasas explains how to <a href="https://twitter.com/ValentinKasas/status/879414703340081156">combine <code>N</code> things</a>:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/shortest-fp-book.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<h2 id="leanpub-auto-scalaz-data-types">
<a class="anchor-link" href="#leanpub-auto-scalaz-data-types"><i class="fa fa-link"></i></a><span class="section-number">6. </span>Scalaz Data Types</h2>

<p>Who doesn’t love a good data structure? The answer is <em>nobody</em>, because data
structures are awesome.</p>

<p>In this chapter we will explore the <em>collection-like</em> data types in Scalaz, as
well as data types that augment the Scala language with useful semantics and
additional type safety.</p>

<p>The primary reason we care about having lots of collections at our disposal is
performance. A vector and a list can do the same things, but their performance
characteristics are different: a vector has constant lookup cost whereas a list
must be traversed.</p>

<aside class="warning blurb">
    <p>Performance estimates - including claims in this chapter - should be taken with
a pinch of salt. Modern processor design, memory pipelining, and JVM garbage
collection can invalidate intuitive reasoning based on operation counting.</p>

  <p>A hard truth of modern computers is that empirical performance tests, for a
specific task, can shock and surprise: e.g. lookup in a <code>List</code> is often faster
in practice than in a <code>Vector</code>. Use a tool such as <a href="http://openjdk.java.net/projects/code-tools/jmh/">JMH</a> when performance testing.</p>

</aside>

<p>All of the collections presented here are <em>persistent</em>: if we add or remove an
element we can still use the old version. Structural sharing is essential to the
performance of persistent data structures, otherwise the entire collection is
rebuilt with every operation.</p>

<p>Unlike the Java and Scala collections, there is no hierarchy to the data types
in Scalaz: these collections are much simpler to understand. Polymorphic
functionality is provided by optimised instances of the typeclasses we studied
in the previous chapter. This makes it a lot easier to swap implementations for
performance reasons, and to provide our own.</p>

<h3 id="leanpub-auto-type-variance">
<a class="anchor-link" href="#leanpub-auto-type-variance"><i class="fa fa-link"></i></a><span class="section-number">6.1 </span>Type Variance</h3>

<p>Many of Scalaz’s data types are <em>invariant</em> in their type parameters.
For example, <code>IList[A]</code> is <strong>not</strong> a subtype of <code>IList[B]</code> when <code>A &lt;:
B</code>.</p>

<h4 id="leanpub-auto-covariance">
<a class="anchor-link" href="#leanpub-auto-covariance"><i class="fa fa-link"></i></a><span class="section-number">6.1.1 </span>Covariance</h4>

<p>The problem with <em>covariant</em> type parameters, such as <code>class
List[+A]</code>, is that <code>List[A]</code> is a subtype of <code>List[Any]</code> and it is
easy to accidentally lose type information.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; List("hello") ++ List(' ') ++ List("world!")
  res: List[Any] = List(hello,  , world!)
</pre></div>

</figure>

<p>Note that the second list is a <code>List[Char]</code> and the compiler has
unhelpfully inferred the <em>Least Upper Bound</em> (LUB) to be <code>Any</code>.
Compare to <code>IList</code>, which requires explicit <code>.widen[Any]</code> to permit
the heinous crime:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; IList("hello") ++ IList(' ') ++ IList("world!")
  &lt;console&gt;:35: error: type mismatch;
   found   : Char(' ')
   required: String
  
  scala&gt; IList("hello").widen[Any]
           ++ IList(' ').widen[Any]
           ++ IList("world!").widen[Any]
  res: IList[Any] = [hello, ,world!]
</pre></div>

</figure>

<p>Similarly, when the compiler infers a type <code>with Product with
Serializable</code> it is a strong indicator that accidental widening has
occurred due to covariance.</p>

<p>Unfortunately we must be careful when constructing invariant data
types because LUB calculations are performed on the parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; IList("hello", ' ', "world")
  res: IList[Any] = [hello, ,world]
</pre></div>

</figure>

<p>Another similar problem arises from Scala’s <code>Nothing</code> type, which is a subtype
of all other types, including <code>sealed</code> ADTs, <code>final</code> classes, primitives and
<code>null</code>.</p>

<p>There are no values of type <code>Nothing</code>: functions that take a <code>Nothing</code> as a
parameter cannot be run and functions that return <code>Nothing</code> will never return.
<code>Nothing</code> was introduced as a mechanism to enable covariant type parameters, but
a consequence is that we can write un-runnable code, by accident. Scalaz says we
do not need covariant type parameters which means that we are limiting ourselves
to writing practical code that can be run.</p>

<h4 id="leanpub-auto-contrarivariance">
<a class="anchor-link" href="#leanpub-auto-contrarivariance"><i class="fa fa-link"></i></a><span class="section-number">6.1.2 </span>Contrarivariance</h4>

<p>On the other hand, <em>contravariant</em> type parameters, such as <code>trait
Thing[-A]</code>, can expose devastating <a href="https://issues.scala-lang.org/browse/SI-2509">bugs in the compiler</a>. Consider Paul
Phillips’ (ex-<code>scalac</code> team) demonstration of what he calls
<em>contrarivariance</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; :paste
         trait Thing[-A]
         def f(x: Thing[ Seq[Int]]): Byte   = 1
         def f(x: Thing[List[Int]]): Short  = 2
  
  scala&gt; f(new Thing[ Seq[Int]] { })
         f(new Thing[List[Int]] { })
  
  res = 1
  res = 2
</pre></div>

</figure>

<p>As expected, the compiler is finding the most specific argument in
each call to <code>f</code>. However, implicit resolution gives unexpected
results:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; :paste
         implicit val t1: Thing[ Seq[Int]] =
           new Thing[ Seq[Int]] { override def toString = "1" }
         implicit val t2: Thing[List[Int]] =
           new Thing[List[Int]] { override def toString = "2" }
  
  scala&gt; implicitly[Thing[ Seq[Int]]]
         implicitly[Thing[List[Int]]]
  
  res = 1
  res = 1
</pre></div>

</figure>

<p>Implicit resolution flips its definition of “most specific” for contravariant
types, rendering them useless for typeclasses or anything that requires
polymorphic functionality. The behaviour is fixed in Dotty.</p>

<h4 id="leanpub-auto-limitations-of-subtyping">
<a class="anchor-link" href="#leanpub-auto-limitations-of-subtyping"><i class="fa fa-link"></i></a><span class="section-number">6.1.3 </span>Limitations of subtyping</h4>

<p><code>scala.Option</code> has a method <code>.flatten</code> which will convert
<code>Option[Option[B]]</code> into an <code>Option[B]</code>. However, Scala’s type system
is unable to let us write the required type signature. Consider the
following that appears correct, but has a subtle bug:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Option[+A] {
    def flatten[B, A &lt;: Option[B]]: Option[B] = ...
  }
</pre></div>

</figure>

<p>The <code>A</code> introduced on <code>.flatten</code> is shadowing the <code>A</code> introduced on
the class. It is equivalent to writing</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Option[+A] {
    def flatten[B, C &lt;: Option[B]]: Option[B] = ...
  }
</pre></div>

</figure>

<p>which is not the constraint we want.</p>

<p>To workaround this limitation, Scala defines infix classes <code>&lt;:&lt;</code> and
<code>=:=</code> along with implicit evidence that always creates a <em>witness</em></p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class &lt;:&lt;[-From, +To] extends (From =&gt; To)
  implicit def conforms[A]: A &lt;:&lt; A = new &lt;:&lt;[A, A] { def apply(x: A): A = x }
  
  sealed abstract class =:=[ From,  To] extends (From =&gt; To)
  implicit def tpEquals[A]: A =:= A = new =:=[A, A] { def apply(x: A): A = x }
</pre></div>

</figure>

<p><code>=:=</code> can be used to require that two type parameters are exactly the
same and <code>&lt;:&lt;</code> is used to describe subtype relationships, letting us
implement <code>.flatten</code> as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Option[+A] {
    def flatten[B](implicit ev: A &lt;:&lt; Option[B]): Option[B] = this match {
      case None        =&gt; None
      case Some(value) =&gt; ev(value)
    }
  }
  final case class Some[+A](value: A) extends Option[A]
  case object None                    extends Option[Nothing]
</pre></div>

</figure>

<p>Scalaz improves on <code>&lt;:&lt;</code> and <code>=:=</code> with <em>Liskov</em> (aliased to <code>&lt;~&lt;</code>)
and <em>Leibniz</em> (<code>===</code>).</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Liskov[-A, +B] {
    def apply(a: A): B = ...
    def subst[F[-_]](p: F[B]): F[A]
  
    def andThen[C](that: Liskov[B, C]): Liskov[A, C] = ...
    def onF[X](fa: X =&gt; A): X =&gt; B = ...
    ...
  }
  object Liskov {
    type &lt;~&lt;[-A, +B] = Liskov[A, B]
    type &gt;~&gt;[+B, -A] = Liskov[A, B]
  
    implicit def refl[A]: (A &lt;~&lt; A) = ...
    implicit def isa[A, B &gt;: A]: A &lt;~&lt; B = ...
  
    implicit def witness[A, B](lt: A &lt;~&lt; B): A =&gt; B = ...
    ...
  }
  
  // type signatures have been simplified
  sealed abstract class Leibniz[A, B] {
    def apply(a: A): B = ...
    def subst[F[_]](p: F[A]): F[B]
  
    def flip: Leibniz[B, A] = ...
    def andThen[C](that: Leibniz[B, C]): Leibniz[A, C] = ...
    def onF[X](fa: X =&gt; A): X =&gt; B = ...
    ...
  }
  object Leibniz {
    type ===[A, B] = Leibniz[A, B]
  
    implicit def refl[A]: Leibniz[A, A] = ...
  
    implicit def subst[A, B](a: A)(implicit f: A === B): B = ...
    implicit def witness[A, B](f: A === B): A =&gt; B = ...
    ...
  }
</pre></div>

</figure>

<p>Other than generally useful methods and implicit conversions, the
Scalaz <code>&lt;~&lt;</code> and <code>===</code> evidence is more principled than in the stdlib.</p>

<aside>
  <p>Liskov is named after Barbara Liskov of <em>Liskov substitution
principle</em> fame, the foundation of Object Oriented Programming.</p>

  <p>Gottfried Wilhelm Leibniz basically invented <em>everything</em> in the 17th
century. He believed in a <a href="https://en.wikipedia.org/wiki/Monad_(philosophy)">God called Monad</a>. Eugenio Moggi later reused
the name for what we know as <code>scalaz.Monad</code>. Not a God, just a mere
mortal.</p>

</aside>

<h3 id="leanpub-auto-evaluation">
<a class="anchor-link" href="#leanpub-auto-evaluation"><i class="fa fa-link"></i></a><span class="section-number">6.2 </span>Evaluation</h3>

<p>Java is a <em>strict</em> evaluation language: all the parameters to a method
must be evaluated to a <em>value</em> before the method is called. Scala
introduces the notion of <em>by-name</em> parameters on methods with <code>a: =&gt;A</code>
syntax. These parameters are wrapped up as a zero argument function
which is called every time the <code>a</code> is referenced. We seen <em>by-name</em> a
lot in the typeclasses.</p>

<p>Scala also has <em>by-need</em> evaluation of values, with the <code>lazy</code>
keyword: the computation is evaluated at most once to produce the
value. Unfortunately, Scala does not support <em>by-need</em> evaluation of
method parameters.</p>

<aside>
  <p>If the calculation of a <code>lazy val</code> throws an exception, it is retried
every time it is accessed. Because exceptions can break referential
transparency, we limit our discussion to <code>lazy val</code> calculations that
do not throw exceptions.</p>

</aside>

<p>Scalaz formalises the three evaluation strategies with an ADT</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Name[A] {
    def value: A
  }
  object Name {
    def apply[A](a: =&gt;A) = new Name[A] { def value = a }
    ...
  }
  
  sealed abstract class Need[A] extends Name[A]
  object Need {
    def apply[A](a: =&gt;A): Need[A] = new Need[A] {
      private lazy val value0: A = a
      def value = value0
    }
    ...
  }
  
  final case class Value[A](value: A) extends Need[A]
</pre></div>

</figure>

<p>The weakest form of evaluation is <code>Name</code>, giving no computational
guarantees. Next is <code>Need</code>, guaranteeing <em>at most once</em> evaluation,
whereas <code>Value</code> is pre-computed and therefore <em>exactly once</em>
evaluation.</p>

<p>If we wanted to be super-pedantic we could go back to all the
typeclasses and make their methods take <code>Name</code>, <code>Need</code> or <code>Value</code>
parameters. Instead we can assume that normal parameters can always be
wrapped in a <code>Value</code>, and <em>by-name</em> parameters can be wrapped with
<code>Name</code>.</p>

<p>When we write <em>pure programs</em>, we are free to replace any <code>Name</code> with
<code>Need</code> or <code>Value</code>, and vice versa, with no change to the correctness
of the program. This is the essence of <em>referential transparency</em>: the
ability to replace a computation by its value, or a value by its
computation.</p>

<p>In functional programming we almost always want <code>Value</code> or <code>Need</code>
(also known as <em>strict</em> and <em>lazy</em>): there is little value in <code>Name</code>.
Because there is no language level support for lazy method parameters,
methods typically ask for a <em>by-name</em> parameter and then convert it
into a <code>Need</code> internally, getting a boost to performance.</p>

<aside>
  <p><code>Lazy</code> (with a capital <code>L</code>) is often used in core Scala libraries for
data types with <em>by-name</em> semantics: a misnomer that has stuck.</p>

  <p>More generally, we’re all pretty lazy about how we talk about laziness: it can
be good to seek clarification about what kind of laziness is being discussed. Or
don’t. Because, lazy.</p>

</aside>

<p><code>Name</code> provides instances of the following typeclasses</p>

<ul>
  <li><code>Monad</code></li>
  <li><code>Comonad</code></li>
  <li><code>Traverse1</code></li>
  <li><code>Align</code></li>
  <li>
<code>Zip</code> / <code>Unzip</code> / <code>Cozip</code>
</li>
</ul>

<aside>
  <p><em>by-name</em> and <em>lazy</em> are not the free lunch they appear to be. When
Scala converts <em>by-name</em> parameters and <code>lazy val</code> into bytecode,
there is an object allocation overhead.</p>

  <p>Before rewriting everything to use <em>by-name</em> parameters, ensure that
the cost of the overhead does not eclipse the saving. There is no
benefit unless there is the possibility of <strong>not</strong> evaluating. High
performance code that runs in a tight loop and always evaluates will
suffer.</p>

</aside>

<h3 id="leanpub-auto-memoisation">
<a class="anchor-link" href="#leanpub-auto-memoisation"><i class="fa fa-link"></i></a><span class="section-number">6.3 </span>Memoisation</h3>

<p>Scalaz has the capability to memoise functions, formalised by <code>Memo</code>,
which doesn’t make any guarantees about evaluation because of the
diversity of implementations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Memo[K, V] {
    def apply(z: K =&gt; V): K =&gt; V
  }
  object Memo {
    def memo[K, V](f: (K =&gt; V) =&gt; K =&gt; V): Memo[K, V]
  
    def nilMemo[K, V]: Memo[K, V] = memo[K, V](identity)
  
    def arrayMemo[V &gt;: Null : ClassTag](n: Int): Memo[Int, V] = ...
    def doubleArrayMemo(n: Int, sentinel: Double = 0.0): Memo[Int, Double] = ...
  
    def immutableHashMapMemo[K, V]: Memo[K, V] = ...
    def immutableTreeMapMemo[K: scala.Ordering, V]: Memo[K, V] = ...
  }
</pre></div>

</figure>

<p><code>memo</code> allows us to create custom implementations of <code>Memo</code>, <code>nilMemo</code>
doesn’t memoise, evaluating the function normally. The remaining
implementations intercept calls to the function and cache results
backed by stdlib collection implementations.</p>

<p>To use <code>Memo</code> we simply wrap a function with a <code>Memo</code> implementation
and then call the memoised function:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def foo(n: Int): String = {
           println("running")
           if (n &gt; 10) "wibble" else "wobble"
         }
  
  scala&gt; val mem = Memo.arrayMemo[String](100)
         val mfoo = mem(foo)
  
  scala&gt; mfoo(1)
  running // evaluated
  res: String = wobble
  
  scala&gt; mfoo(1)
  res: String = wobble // memoised
</pre></div>

</figure>

<p>If the function takes more than one parameter, we must <code>tupled</code> the
method, with the memoised version taking a tuple.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; def bar(n: Int, m: Int): String = "hello"
         val mem = Memo.immutableHashMapMemo[(Int, Int), String]
         val mbar = mem((bar _).tupled)
  
  scala&gt; mbar((1, 2))
  res: String = "hello"
</pre></div>

</figure>

<p><code>Memo</code> is typically treated as a special construct and the usual rule
about <em>purity</em> is relaxed for implementations. To be pure only
requires that our implementations of <code>Memo</code> are referential
transparent in the evaluation of <code>K =&gt; V</code>. We may use mutable data and
perform I/O in the implementation of <code>Memo</code>, e.g. with an LRU or
distributed cache, without having to declare an effect in the type
signature. Other functional programming languages have automatic
memoisation managed by their runtime environment and <code>Memo</code> is our way
of extending the JVM to have similar support, unfortunately only on an
opt-in basis.</p>

<h3 id="leanpub-auto-tagging">
<a class="anchor-link" href="#leanpub-auto-tagging"><i class="fa fa-link"></i></a><span class="section-number">6.4 </span>Tagging</h3>

<p>In the section introducing <code>Monoid</code> we built a <code>Monoid[TradeTemplate]</code> and
realised that Scalaz does not do what we wanted with <code>Monoid[Option[A]]</code>. This
is not an oversight of Scalaz: often we find that a data type can implement a
fundamental typeclass in multiple valid ways and that the default implementation
doesn’t do what we want, or simply isn’t defined.</p>

<p>Basic examples are <code>Monoid[Boolean]</code> (conjunction <code>&amp;&amp;</code> vs disjunction <code>||</code>) and
<code>Monoid[Int]</code> (multiplication vs addition).</p>

<p>To implement <code>Monoid[TradeTemplate]</code> we found ourselves either breaking
typeclass coherency, or using a different typeclass.</p>

<p><code>scalaz.Tag</code> is designed to address the multiple typeclass implementation
problem without breaking typeclass coherency.</p>

<p>The definition is quite contorted, but the syntax to use it is very clean. This
is how we trick the compiler into allowing us to define an infix type <code>A @@ T</code>
that is erased to <code>A</code> at runtime:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type @@[A, T] = Tag.k.@@[A, T]
  
  object Tag {
    @inline val k: TagKind = IdTagKind
    @inline def apply[A, T](a: A): A @@ T = k(a)
    ...
  
    final class TagOf[T] private[Tag]() { ... }
    def of[T]: TagOf[T] = new TagOf[T]
  }
  sealed abstract class TagKind {
    type @@[A, T]
    def apply[A, T](a: A): A @@ T
    ...
  }
  private[scalaz] object IdTagKind extends TagKind {
    type @@[A, T] = A
    @inline override def apply[A, T](a: A): A = a
    ...
  }
</pre></div>

</figure>

<aside>
  <p>i.e. we tag things with Princess Leia hair buns <code>@@</code>.</p>

</aside>

<p>Some useful tags are provided in the <code>Tags</code> object</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Tags {
    sealed trait First
    val First = Tag.of[First]
  
    sealed trait Last
    val Last = Tag.of[Last]
  
    sealed trait Multiplication
    val Multiplication = Tag.of[Multiplication]
  
    sealed trait Disjunction
    val Disjunction = Tag.of[Disjunction]
  
    sealed trait Conjunction
    val Conjunction = Tag.of[Conjunction]
  
    ...
  }
</pre></div>

</figure>

<p><code>First</code> / <code>Last</code> are used to select <code>Monoid</code> instances that pick the first or
last non-zero operand. <code>Multiplication</code> is for numeric multiplication instead of
addition. <code>Disjunction</code> / <code>Conjunction</code> are to select <code>&amp;&amp;</code> or <code>||</code>,
respectively.</p>

<p>In our <code>TradeTemplate</code>, instead of using <code>Option[Currency]</code> we can use
<code>Option[Currency] @@ Tags.Last</code>. Indeed this is so common that we can use the
built-in alias, <code>LastOption</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  type LastOption[A] = Option[A] @@ Tags.Last
</pre></div>

</figure>

<p>letting us write a much cleaner <code>Monoid[TradeTemplate]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class TradeTemplate(
    payments: List[java.time.LocalDate],
    ccy: LastOption[Currency],
    otc: LastOption[Boolean]
  )
  object TradeTemplate {
    implicit val monoid: Monoid[TradeTemplate] = Monoid.instance(
      (a, b) =&gt;
        TradeTemplate(a.payments |+| b.payments,
                      a.ccy |+| b.ccy,
                      a.otc |+| b.otc),
        TradeTemplate(Nil, Tag(None), Tag(None))
    )
  }
</pre></div>

</figure>

<p>To create a raw value of type <code>LastOption</code>, we apply <code>Tag</code> to an <code>Option</code>. Here
we are calling <code>Tag(None)</code>.</p>

<p>In the chapter on typeclass derivation, we will go one step further and
automatically derive the <code>monoid</code>.</p>

<p>It is tempting to use <code>Tag</code> to markup data types for some form of validation
(e.g. <code>String @@ PersonName</code>), but this should be avoided because there are no
checks on the content of the runtime value. <code>Tag</code> should only be used for
typeclass selection purposes. Prefer the <code>Refined</code> library, introduced in
Chapter 4, to constrain values.</p>

<h3 id="leanpub-auto-natural-transformations">
<a class="anchor-link" href="#leanpub-auto-natural-transformations"><i class="fa fa-link"></i></a><span class="section-number">6.5 </span>Natural Transformations</h3>

<p>A function from one type to another is written as <code>A =&gt; B</code> in Scala, which is
syntax sugar for a <code>Function1[A, B]</code>. Scalaz provides similar syntax sugar <code>F ~&gt;
G</code> for functions over type constructors <code>F[_]</code> to <code>G[_]</code>.</p>

<p>These <code>F ~&gt; G</code> are called <em>natural transformations</em> and are <em>universally
quantified</em> because they don’t care about the contents of <code>F[_]</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type ~&gt;[-F[_], +G[_]] = NaturalTransformation[F, G]
  trait NaturalTransformation[-F[_], +G[_]] {
    def apply[A](fa: F[A]): G[A]
  
    def compose[E[_]](f: E ~&gt; F): E ~&gt; G = ...
    def andThen[H[_]](f: G ~&gt; H): F ~&gt; H = ...
  }
</pre></div>

</figure>

<p>An example of a natural transformation is a function that converts an <code>IList</code>
into a <code>List</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val convert = new (IList ~&gt; List) {
           def apply[A](fa: IList[A]): List[A] = fa.toList
         }
  
  scala&gt; convert(IList(1, 2, 3))
  res: List[Int] = List(1, 2, 3)
</pre></div>

</figure>

<p>Or, more concisely, making use of <code>kind-projector</code>’s syntax sugar:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val convert = λ[IList ~&gt; List](_.toList)
  
  scala&gt; val convert = Lambda[IList ~&gt; List](_.toList)
</pre></div>

</figure>

<p>However, in day-to-day development, it is far more likely that we will use a
natural transformation to map between algebras. For example, in
<code>drone-dynamic-agents</code> we may want to implement our Google Container Engine
<code>Machines</code> algebra with an off-the-shelf algebra, <code>BigMachines</code>. Instead of
changing all our business logic and tests to use this new <code>BigMachines</code>
interface, we may be able to write a transformation from <code>Machines ~&gt;
BigMachines</code>. We will return to this idea in the chapter on Advanced Monads.</p>

<h3 id="leanpub-auto-isomorphism">
<a class="anchor-link" href="#leanpub-auto-isomorphism"><i class="fa fa-link"></i></a><span class="section-number">6.6 </span><code>Isomorphism</code>
</h3>

<p>Sometimes we have two types that are really the same thing, causing
compatibility problems because the compiler doesn’t know what we know. This
typically happens when we use third party code that is the same as something we
already have.</p>

<p>This is when <code>Isomorphism</code> can help us out. An isomorphism defines a formal “is
equivalent to” relationship between two types. There are three variants, to
account for types of different shapes:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Isomorphism {
    trait Iso[Arr[_, _], A, B] {
      def to: Arr[A, B]
      def from: Arr[B, A]
    }
    type IsoSet[A, B] = Iso[Function1, A, B]
    type &lt;=&gt;[A, B] = IsoSet[A, B]
    object IsoSet {
      def apply[A, B](to: A =&gt; B, from: B =&gt; A): A &lt;=&gt; B = ...
    }
  
    trait Iso2[Arr[_[_], _[_]], F[_], G[_]] {
      def to: Arr[F, G]
      def from: Arr[G, F]
    }
    type IsoFunctor[F[_], G[_]] = Iso2[NaturalTransformation, F, G]
    type &lt;~&gt;[F[_], G[_]] = IsoFunctor[F, G]
    object IsoFunctor {
      def apply[F[_], G[_]](to: F ~&gt; G, from: G ~&gt; F): F &lt;~&gt; G = ...
    }
  
    trait Iso3[Arr[_[_, _], _[_, _]], F[_, _], G[_, _]] {
      def to: Arr[F, G]
      def from: Arr[G, F]
    }
    type IsoBifunctor[F[_, _], G[_, _]] = Iso3[~~&gt;, F, G]
    type &lt;~~&gt;[F[_, _], G[_, _]] = IsoBifunctor[F, G]
  
    ...
  }
</pre></div>

</figure>

<p>The type aliases <code>IsoSet</code>, <code>IsoFunctor</code> and <code>IsoBifunctor</code> cover the common
cases: a regular function, natural transformation and binatural. Convenience
functions allow us to generate instances from existing functions or natural
transformations. However, it is often easier to use one of the abstract
<code>Template</code> classes to define an isomorphism. For example:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val listIListIso: List &lt;~&gt; IList =
    new IsoFunctorTemplate[List, IList] {
      def to[A](fa: List[A]) = fromList(fa)
      def from[A](fa: IList[A]) = fa.toList
    }
</pre></div>

</figure>

<p>If we introduce an isomorphism, we can generate many of the standard
typeclasses. For example</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait IsomorphismSemigroup[F, G] extends Semigroup[F] {
    implicit def G: Semigroup[G]
    def iso: F &lt;=&gt; G
    def append(f1: F, f2: =&gt;F): F = iso.from(G.append(iso.to(f1), iso.to(f2)))
  }
</pre></div>

</figure>

<p>allows us to derive a <code>Semigroup[F]</code> for a type <code>F</code> if we have an <code>F &lt;=&gt; G</code> and
a <code>Semigroup[G]</code>. Almost all the typeclasses in the hierarchy provide an
isomorphic variant. If we find ourselves copying and pasting a typeclass
implementation, it is worth considering if <code>Isomorphism</code> is the better solution.</p>

<h3 id="leanpub-auto-containers">
<a class="anchor-link" href="#leanpub-auto-containers"><i class="fa fa-link"></i></a><span class="section-number">6.7 </span>Containers</h3>

<h4 id="leanpub-auto-maybe">
<a class="anchor-link" href="#leanpub-auto-maybe"><i class="fa fa-link"></i></a><span class="section-number">6.7.1 </span>Maybe</h4>

<p>We have already encountered Scalaz’s improvement over <code>scala.Option</code>, called
<code>Maybe</code>. It is an improvement because it is invariant and does not have any
unsafe methods like <code>Option.get</code>, which can throw an exception.</p>

<p>It is typically used to represent when a thing may be
present or not without giving any extra context as to why it may be
missing.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Maybe[A] { ... }
  object Maybe {
    final case class Empty[A]()    extends Maybe[A]
    final case class Just[A](a: A) extends Maybe[A]
  
    def empty[A]: Maybe[A] = Empty()
    def just[A](a: A): Maybe[A] = Just(a)
  
    def fromOption[A](oa: Option[A]): Maybe[A] = ...
    def fromNullable[A](a: A): Maybe[A] = if (null == a) empty else just(a)
    ...
  }
</pre></div>

</figure>

<p>The <code>.empty</code> and <code>.just</code> companion methods are preferred to creating
raw <code>Empty</code> or <code>Just</code> instances because they return a <code>Maybe</code>, helping
with type inference. This pattern is often referred to as returning a
<em>sum type</em>, which is when we have multiple implementations of a
<code>sealed trait</code> but never use a specific subtype in a method signature.</p>

<p>A convenient <code>implicit class</code> allows us to call <code>.just</code> on any value
and receive a <code>Maybe</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class MaybeOps[A](self: A) {
    def just: Maybe[A] = Maybe.just(self)
  }
</pre></div>

</figure>

<p><code>Maybe</code> has a typeclass instance for all the things</p>

<ul>
  <li><code>Align</code></li>
  <li><code>Traverse</code></li>
  <li>
<code>MonadPlus</code> / <code>IsEmpty</code>
</li>
  <li><code>Cobind</code></li>
  <li>
<code>Cozip</code> / <code>Zip</code> / <code>Unzip</code>
</li>
  <li><code>Optional</code></li>
</ul>

<p>and delegate instances depending on <code>A</code></p>

<ul>
  <li>
<code>Monoid</code> / <code>Band</code>
</li>
  <li>
<code>Equal</code> / <code>Order</code> / <code>Show</code>
</li>
</ul>

<p>In addition to the above, <code>Maybe</code> has functionality that is not supported by a
polymorphic typeclass.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Maybe[A] {
    def cata[B](f: A =&gt; B, b: =&gt;B): B = this match {
      case Just(a) =&gt; f(a)
      case Empty() =&gt; b
    }
  
    def |(a: =&gt;A): A = cata(identity, a)
    def toLeft[B](b: =&gt;B): A \/ B = cata(\/.left, \/-(b))
    def toRight[B](b: =&gt;B): B \/ A = cata(\/.right, -\/(b))
    def &lt;\/[B](b: =&gt;B): A \/ B = toLeft(b)
    def \/&gt;[B](b: =&gt;B): B \/ A = toRight(b)
  
    def orZero(implicit A: Monoid[A]): A = getOrElse(A.zero)
    def orEmpty[F[_]: Applicative: PlusEmpty]: F[A] =
      cata(Applicative[F].point(_), PlusEmpty[F].empty)
    ...
  }
</pre></div>

</figure>

<p><code>.cata</code> is a terser alternative to <code>.map(f).getOrElse(b)</code> and has the
simpler form <code>|</code> if the map is <code>identity</code> (i.e. just <code>.getOrElse</code>).</p>

<p><code>.toLeft</code> and <code>.toRight</code>, and their symbolic aliases, create a disjunction
(explained in the next section) by taking a fallback for the <code>Empty</code> case.</p>

<p><code>.orZero</code> takes a <code>Monoid</code> to define the default value.</p>

<p><code>.orEmpty</code> uses an <code>ApplicativePlus</code> to create a single element or
empty container, not forgetting that we already get support for stdlib
collections from the <code>Foldable</code> instance’s <code>.to</code> method.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; 1.just.orZero
  res: Int = 1
  
  scala&gt; Maybe.empty[Int].orZero
  res: Int = 0
  
  scala&gt; Maybe.empty[Int].orEmpty[IList]
  res: IList[Int] = []
  
  scala&gt; 1.just.orEmpty[IList]
  res: IList[Int] = [1]
  
  scala&gt; 1.just.to[List] // from Foldable
  res: List[Int] = List(1)
</pre></div>

</figure>

<aside>
  <p>Methods are defined in OOP style on <code>Maybe</code>, contrary to our Chapter 4
lesson to use an <code>object</code> or <code>implicit class</code>. This is a common theme
in Scalaz and the reason is largely historical:</p>

  <ul>
    <li>text editors failed to find extension methods, but this now works
seamlessly in IntelliJ, ENSIME and ScalaIDE.</li>
    <li>there are corner cases where the compiler would fail to infer the
types and not be able to find the extension method.</li>
    <li>the stdlib defines some <code>implicit class</code> instances that add methods
to all values, with conflicting method names. <code>+</code> is the most
prominent example, turning everything into a concatenated <code>String</code>.</li>
  </ul>

  <p>The same is true for functionality that is provided by typeclass
instances, such as these methods which are otherwise provided by
<code>Optional</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Maybe[A] {
    def getOrElse(a: =&gt;A): A = ...
    ...
  }
</pre></div>

  </figure>

  <p>However, recent versions of Scala have addressed many bugs and we are
now less likely to encounter problems.</p>

</aside>

<h4 id="leanpub-auto-either">
<a class="anchor-link" href="#leanpub-auto-either"><i class="fa fa-link"></i></a><span class="section-number">6.7.2 </span>Either</h4>

<p>Scalaz’s improvement over <code>scala.Either</code> is symbolic, but it is common
to speak about it as <em>either</em> or <code>Disjunction</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class \/[+A, +B] { ... }
  final case class -\/[+A](a: A) extends (A \/ Nothing)
  final case class \/-[+B](b: B) extends (Nothing \/ B)
  
  type Disjunction[+A, +B] = \/[A, B]
  
  object \/ {
    def left [A, B]: A =&gt; A \/ B = -\/(_)
    def right[A, B]: B =&gt; A \/ B = \/-(_)
  
    def fromEither[A, B](e: Either[A, B]): A \/ B = ...
    ...
  }
</pre></div>

</figure>

<p>with corresponding syntax</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class EitherOps[A](val self: A) {
    final def left [B]: (A \/ B) = -\/(self)
    final def right[B]: (B \/ A) = \/-(self)
  }
</pre></div>

</figure>

<p>allowing for easy construction of values. Note that the extension
method takes the type of the <em>other side</em>. So if we wish to create a
<code>String \/ Int</code> and we have an <code>Int</code>, we must pass <code>String</code> when
calling <code>.right</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; 1.right[String]
  res: String \/ Int = \/-(1)
  
  scala&gt; "hello".left[Int]
  res: String \/ Int = -\/(hello)
</pre></div>

</figure>

<p>The symbolic nature of <code>\/</code> makes it read well in type signatures when
shown infix. Note that symbolic types in Scala associate from the left
and nested <code>\/</code> must have parentheses, e.g. <code>(A \/ (B \/ (C \/ D))</code>.</p>

<p><code>\/</code> has right-biased (i.e. <code>flatMap</code> applies to <code>\/-</code>) typeclass
instances for:</p>

<ul>
  <li>
<code>Monad</code> / <code>MonadError</code>
</li>
  <li>
<code>Traverse</code> / <code>Bitraverse</code>
</li>
  <li><code>Plus</code></li>
  <li><code>Optional</code></li>
  <li><code>Cozip</code></li>
</ul>

<p>and depending on the contents</p>

<ul>
  <li>
<code>Equal</code> / <code>Order</code>
</li>
  <li>
<code>Semigroup</code> / <code>Monoid</code> / <code>Band</code>
</li>
</ul>

<p>In addition, there are custom methods</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class \/[+A, +B] { self =&gt;
    def fold[X](l: A =&gt; X, r: B =&gt; X): X = self match {
      case -\/(a) =&gt; l(a)
      case \/-(b) =&gt; r(b)
    }
  
    def swap: (B \/ A) = self match {
      case -\/(a) =&gt; \/-(a)
      case \/-(b) =&gt; -\/(b)
    }
  
    def |[BB &gt;: B](x: =&gt;BB): BB = getOrElse(x) // Optional[_]
    def |||[C, BB &gt;: B](x: =&gt;C \/ BB): C \/ BB = orElse(x) // Optional[_]
  
    def +++[AA &gt;: A: Semigroup, BB &gt;: B: Semigroup](x: =&gt;AA \/ BB): AA \/ BB = ...
  
    def toEither: Either[A, B] = ...
  
    final class SwitchingDisjunction[X](right: =&gt;X) {
      def &lt;&lt;?:(left: =&gt;X): X = ...
    }
    def :?&gt;&gt;[X](right: =&gt;X) = new SwitchingDisjunction[X](right)
    ...
  }
</pre></div>

</figure>

<p><code>.fold</code> is similar to <code>Maybe.cata</code> and requires that both the left and
right sides are mapped to the same type.</p>

<p><code>.swap</code> swaps a left into a right and a right into a left.</p>

<p>The <code>|</code> alias to <code>getOrElse</code> appears similarly to <code>Maybe</code>. We also get
<code>|||</code> as an alias to <code>orElse</code>.</p>

<p><code>+++</code> is for combining disjunctions with lefts taking preference over
right:</p>

<ul>
  <li>
<code>right(v1) +++ right(v2)</code> gives <code>right(v1 |+| v2)</code>
</li>
  <li>
<code>right(v1) +++ left (v2)</code> gives <code>left (v2)</code>
</li>
  <li>
<code>left (v1) +++ right(v2)</code> gives <code>left (v1)</code>
</li>
  <li>
<code>left (v1) +++ left (v2)</code> gives <code>left (v1 |+| v2)</code>
</li>
</ul>

<p><code>.toEither</code> is provided for backwards compatibility with the Scala
stdlib.</p>

<p>The combination of <code>:?&gt;&gt;</code> and <code>&lt;&lt;?:</code> allow for a convenient syntax to
ignore the contents of an <code>\/</code>, but pick a default based on its type</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; 1 &lt;&lt;?: foo :?&gt;&gt; 2
  res: Int = 2 // foo is a \/-
  
  scala&gt; 1 &lt;&lt;?: foo.swap :?&gt;&gt; 2
  res: Int = 1
</pre></div>

</figure>

<h4 id="leanpub-auto-validation">
<a class="anchor-link" href="#leanpub-auto-validation"><i class="fa fa-link"></i></a><span class="section-number">6.7.3 </span>Validation</h4>

<p>At first sight, <code>Validation</code> (aliased with <code>\?/</code>, <em>happy Elvis</em>)
appears to be a clone of <code>Disjunction</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Validation[+E, +A] { ... }
  final case class Success[A](a: A) extends Validation[Nothing, A]
  final case class Failure[E](e: E) extends Validation[E, Nothing]
  
  type ValidationNel[E, +X] = Validation[NonEmptyList[E], X]
  
  object Validation {
    type \?/[+E, +A] = Validation[E, A]
  
    def success[E, A]: A =&gt; Validation[E, A] = Success(_)
    def failure[E, A]: E =&gt; Validation[E, A] = Failure(_)
    def failureNel[E, A](e: E): ValidationNel[E, A] = Failure(NonEmptyList(e))
  
    def lift[E, A](a: A)(f: A =&gt; Boolean, fail: E): Validation[E, A] = ...
    def liftNel[E, A](a: A)(f: A =&gt; Boolean, fail: E): ValidationNel[E, A] = ...
    def fromEither[E, A](e: Either[E, A]): Validation[E, A] = ...
    ...
  }
</pre></div>

</figure>

<p>With convenient syntax</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class ValidationOps[A](self: A) {
    def success[X]: Validation[X, A] = Validation.success[X, A](self)
    def successNel[X]: ValidationNel[X, A] = success
    def failure[X]: Validation[A, X] = Validation.failure[A, X](self)
    def failureNel[X]: ValidationNel[A, X] = Validation.failureNel[A, X](self)
  }
</pre></div>

</figure>

<p>However, the data structure itself is not the complete story.
<code>Validation</code> intentionally does not have an instance of any <code>Monad</code>,
restricting itself to success-biased versions of:</p>

<ul>
  <li><code>Applicative</code></li>
  <li>
<code>Traverse</code> / <code>Bitraverse</code>
</li>
  <li><code>Cozip</code></li>
  <li><code>Plus</code></li>
  <li><code>Optional</code></li>
</ul>

<p>and depending on the contents</p>

<ul>
  <li>
<code>Equal</code> / <code>Order</code>
</li>
  <li><code>Show</code></li>
  <li>
<code>Semigroup</code> / <code>Monoid</code>
</li>
</ul>

<p>The big advantage of restricting to <code>Applicative</code> is that <code>Validation</code>
is explicitly for situations where we wish to report all failures,
whereas <code>Disjunction</code> is used to stop at the first failure. To
accommodate failure accumulation, a popular form of <code>Validation</code> is
<code>ValidationNel</code>, having a <code>NonEmptyList[E]</code> in the failure position.</p>

<p>Consider performing input validation of data provided by a user using
<code>Disjunction</code> and <code>flatMap</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; :paste
         final case class Credentials(user: Username, name: Fullname)
         final case class Username(value: String) extends AnyVal
         final case class Fullname(value: String) extends AnyVal
  
         def username(in: String): String \/ Username =
           if (in.isEmpty) "empty username".left
           else if (in.contains(" ")) "username contains spaces".left
           else Username(in).right
  
         def realname(in: String): String \/ Fullname =
           if (in.isEmpty) "empty real name".left
           else Fullname(in).right
  
  scala&gt; for {
           u &lt;- username("sam halliday")
           r &lt;- realname("")
         } yield Credentials(u, r)
  res = -\/(username contains spaces)
</pre></div>

</figure>

<p>If we use <code>|@|</code> syntax</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; (username("sam halliday") |@| realname("")) (Credentials.apply)
  res = -\/(username contains spaces)
</pre></div>

</figure>

<p>we still get back the first failure. This is because <code>Disjunction</code> is
a <code>Monad</code>, its <code>.applyX</code> methods must be consistent with <code>.flatMap</code>
and not assume that any operations can be performed out of order.
Compare to:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; :paste
         def username(in: String): ValidationNel[String, Username] =
           if (in.isEmpty) "empty username".failureNel
           else if (in.contains(" ")) "username contains spaces".failureNel
           else Username(in).success
  
         def realname(in: String): ValidationNel[String, Fullname] =
           if (in.isEmpty) "empty real name".failureNel
           else Fullname(in).success
  
  scala&gt; (username("sam halliday") |@| realname("")) (Credentials.apply)
  res = Failure(NonEmpty[username contains spaces,empty real name])
</pre></div>

</figure>

<p>This time, we get back all the failures!</p>

<p><code>Validation</code> has many of the same methods as <code>Disjunction</code>, such as
<code>.fold</code>, <code>.swap</code> and <code>+++</code>, plus some extra:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Validation[+E, +A] {
    def append[F &gt;: E: Semigroup, B &gt;: A: Semigroup](x: F \?/ B]): F \?/ B = ...
  
    def disjunction: (E \/ A) = ...
    ...
  }
</pre></div>

</figure>

<p><code>.append</code> (aliased by <code>+|+</code>) has the same type signature as <code>+++</code> but
prefers the <code>success</code> case</p>

<ul>
  <li>
<code>failure(v1) +|+ failure(v2)</code> gives <code>failure(v1 |+| v2)</code>
</li>
  <li>
<code>failure(v1) +|+ success(v2)</code> gives <code>success(v2)</code>
</li>
  <li>
<code>success(v1) +|+ failure(v2)</code> gives <code>success(v1)</code>
</li>
  <li>
<code>success(v1) +|+ success(v2)</code> gives <code>success(v1 |+| v2)</code>
</li>
</ul>

<aside>
  <p><code>+|+</code> the surprised c3p0 operator.</p>

</aside>

<p><code>.disjunction</code> converts a <code>Validated[A, B]</code> into an <code>A \/ B</code>.
Disjunction has the mirror <code>.validation</code> and <code>.validationNel</code> to
convert into <code>Validation</code>, allowing for easy conversion between
sequential and parallel failure accumulation.</p>

<p><code>\/</code> and <code>Validation</code> are the more performant FP equivalent of a checked
exception for input validation, avoiding both a stacktrace and requiring the
caller to deal with the failure resulting in more robust systems.</p>

<aside>
  <p>One of the slowest things on the JVM is to create an exception, due to the
resources required to construct the stacktrace. It is traditional to use
exceptions for input validation and parsing, which can be thousands of times
slower than the equivalent functions written with <code>\/</code> or <code>Validation</code>.</p>

  <p>Some people claim that predictable exceptions for input validation are
referentially transparent because they will occur every time. However, the
stacktrace inside the exception depends on the call chain, giving a different
value depending on who calls it, thus breaking referential transparency.
Regardless, throwing an exception is not pure because it means the function is
not <em>Total</em>.</p>

</aside>

<h4 id="leanpub-auto-these">
<a class="anchor-link" href="#leanpub-auto-these"><i class="fa fa-link"></i></a><span class="section-number">6.7.4 </span>These</h4>

<p>We encountered <code>These</code>, a data encoding of inclusive logical <code>OR</code>,
when we learnt about <code>Align</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class \&amp;/[+A, +B] { ... }
  object \&amp;/ {
    type These[A, B] = A \&amp;/ B
  
    final case class This[A](aa: A) extends (A \&amp;/ Nothing)
    final case class That[B](bb: B) extends (Nothing \&amp;/ B)
    final case class Both[A, B](aa: A, bb: B) extends (A \&amp;/ B)
  
    def apply[A, B](a: A, b: B): These[A, B] = Both(a, b)
  }
</pre></div>

</figure>

<p>with convenient construction syntax</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class TheseOps[A](self: A) {
    final def wrapThis[B]: A \&amp;/ B = \&amp;/.This(self)
    final def wrapThat[B]: B \&amp;/ A = \&amp;/.That(self)
  }
  implicit class ThesePairOps[A, B](self: (A, B)) {
    final def both: A \&amp;/ B = \&amp;/.Both(self._1, self._2)
  }
</pre></div>

</figure>

<p><code>These</code> has typeclass instances for</p>

<ul>
  <li><code>Monad</code></li>
  <li><code>Bitraverse</code></li>
  <li><code>Traverse</code></li>
  <li><code>Cobind</code></li>
</ul>

<p>and depending on contents</p>

<ul>
  <li>
<code>Semigroup</code> / <code>Monoid</code> / <code>Band</code>
</li>
  <li>
<code>Equal</code> / <code>Order</code>
</li>
  <li><code>Show</code></li>
</ul>

<p><code>These</code> (<code>\&amp;/</code>) has many of the methods we have come to expect of
<code>Disjunction</code> (<code>\/</code>) and <code>Validation</code> (<code>\?/</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class \&amp;/[+A, +B] {
    def fold[X](s: A =&gt; X, t: B =&gt; X, q: (A, B) =&gt; X): X = ...
    def swap: (B \&amp;/ A) = ...
  
    def append[X &gt;: A: Semigroup, Y &gt;: B: Semigroup](o: =&gt;(X \&amp;/ Y)): X \&amp;/ Y = ...
  
    def &amp;&amp;&amp;[X &gt;: A: Semigroup, C](t: X \&amp;/ C): X \&amp;/ (B, C) = ...
    ...
  }
</pre></div>

</figure>

<p><code>.append</code> has 9 possible arrangements and data is never thrown away
because cases of <code>This</code> and <code>That</code> can always be converted into a
<code>Both</code>.</p>

<p><code>.flatMap</code> is right-biased (<code>Both</code> and <code>That</code>), taking a <code>Semigroup</code>
of the left content (<code>This</code>) to combine rather than break early. <code>&amp;&amp;&amp;</code>
is a convenient way of binding over two of <em>these</em>, creating a tuple
on the right and dropping data if it is not present in each of
<em>these</em>.</p>

<p>Although it is tempting to use <code>\&amp;/</code> in return types, overuse is an
anti-pattern. The main reason to use <code>\&amp;/</code> is to combine or split
potentially infinite <em>streams</em> of data in finite memory. Convenient
functions exist on the companion to deal with <code>EphemeralStream</code>
(aliased here to fit in a single line) or anything with a <code>MonadPlus</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  type EStream[A] = EphemeralStream[A]
  
  object \&amp;/ {
    def concatThisStream[A, B](x: EStream[A \&amp;/ B]): EStream[A] = ...
    def concatThis[F[_]: MonadPlus, A, B](x: F[A \&amp;/ B]): F[A] = ...
  
    def concatThatStream[A, B](x: EStream[A \&amp;/ B]): EStream[B] = ...
    def concatThat[F[_]: MonadPlus, A, B](x: F[A \&amp;/ B]): F[B] = ...
  
    def unalignStream[A, B](x: EStream[A \&amp;/ B]): (EStream[A], EStream[B]) = ...
    def unalign[F[_]: MonadPlus, A, B](x: F[A \&amp;/ B]): (F[A], F[B]) = ...
  
    def merge[A: Semigroup](t: A \&amp;/ A): A = ...
    ...
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-higher-kinded-either">
<a class="anchor-link" href="#leanpub-auto-higher-kinded-either"><i class="fa fa-link"></i></a><span class="section-number">6.7.5 </span>Higher Kinded Either</h4>

<p>The <code>Coproduct</code> data type (not to be confused with the more general concept of a
<em>coproduct</em> in an ADT) wraps <code>Disjunction</code> for type constructors:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A]) { ... }
  object Coproduct {
    def leftc[F[_], G[_], A](x: F[A]): Coproduct[F, G, A] = Coproduct(-\/(x))
    def rightc[F[_], G[_], A](x: G[A]): Coproduct[F, G, A] = Coproduct(\/-(x))
    ...
  }
</pre></div>

</figure>

<p>Typeclass instances simply delegate to those of the <code>F[_]</code> and <code>G[_]</code>.</p>

<p>The most popular use case for <code>Coproduct</code> is when we want to create an anonymous
coproduct of multiple ADTs.</p>

<h4 id="leanpub-auto-not-so-eager">
<a class="anchor-link" href="#leanpub-auto-not-so-eager"><i class="fa fa-link"></i></a><span class="section-number">6.7.6 </span>Not So Eager</h4>

<p>Built-in Scala tuples, and basic data types like <code>Maybe</code> and
<code>Disjunction</code> are eagerly-evaluated value types.</p>

<p>For convenience, <em>by-name</em> alternatives to <code>Name</code> are provided, having
the expected typeclass instances:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class LazyTuple2[A, B] {
    def _1: A
    def _2: B
  }
  ...
  sealed abstract class LazyTuple4[A, B, C, D] {
    def _1: A
    def _2: B
    def _3: C
    def _4: D
  }
  
  sealed abstract class LazyOption[+A] { ... }
  private final case class LazySome[A](a: () =&gt; A) extends LazyOption[A]
  private case object LazyNone extends LazyOption[Nothing]
  
  sealed abstract class LazyEither[+A, +B] { ... }
  private case class LazyLeft[A, B](a: () =&gt; A) extends LazyEither[A, B]
  private case class LazyRight[A, B](b: () =&gt; B) extends LazyEither[A, B]
</pre></div>

</figure>

<p>The astute reader will note that <code>Lazy*</code> is a misnomer, and these data
types should perhaps be: <code>ByNameTupleX</code>, <code>ByNameOption</code> and
<code>ByNameEither</code>.</p>

<h4 id="leanpub-auto-const">
<a class="anchor-link" href="#leanpub-auto-const"><i class="fa fa-link"></i></a><span class="section-number">6.7.7 </span>Const</h4>

<p><code>Const</code>, for <em>constant</em>, is a wrapper for a value of type <code>A</code>, along with a
spare type parameter <code>B</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Const[A, B](getConst: A)
</pre></div>

</figure>

<p><code>Const</code> provides an instance of <code>Applicative[Const[A, ?]]</code> if there is a
<code>Monoid[A]</code> available:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def applicative[A: Monoid]: Applicative[Const[A, ?]] =
    new Applicative[Const[A, ?]] {
      def point[B](b: =&gt;B): Const[A, B] =
        Const(Monoid[A].zero)
      def ap[B, C](fa: =&gt;Const[A, B])(fbc: =&gt;Const[A, B =&gt; C]): Const[A, C] =
        Const(fbc.getConst |+| fa.getConst)
    }
</pre></div>

</figure>

<p>The most important thing about this <code>Applicative</code> is that it ignores the <code>B</code>
parameters, continuing on without failing and only combining the constant values
that it encounters.</p>

<p>Going back to our example application <code>drone-dynamic-agents</code>, we should first
refactor our <code>logic.scala</code> file to use <code>Applicative</code> instead of <code>Monad</code>. We
wrote <code>logic.scala</code> before we learnt about <code>Applicative</code> and now we know better:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class DynAgentsModule[F[_]: Applicative](D: Drone[F], M: Machines[F])
    extends DynAgents[F] {
    ...
    def act(world: WorldView): F[WorldView] = world match {
      case NeedsAgent(node) =&gt;
        M.start(node) &gt;| world.copy(pending = Map(node -&gt; world.time))
  
      case Stale(nodes) =&gt;
        nodes.traverse { node =&gt;
          M.stop(node) &gt;| node
        }.map { stopped =&gt;
          val updates = stopped.strengthR(world.time).toList.toMap
          world.copy(pending = world.pending ++ updates)
        }
  
      case _ =&gt; world.pure[F]
    }
    ...
  }
</pre></div>

</figure>

<p>Since our business logic only requires an <code>Applicative</code>, we can write mock
implementations with <code>F[a]</code> as <code>Const[String, a]</code>. In each case, we return the
name of the function that is called:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object ConstImpl {
    type F[a] = Const[String, a]
  
    private val D = new Drone[F] {
      def getBacklog: F[Int] = Const("backlog")
      def getAgents: F[Int]  = Const("agents")
    }
  
    private val M = new Machines[F] {
      def getAlive: F[Map[MachineNode, Epoch]]     = Const("alive")
      def getManaged: F[NonEmptyList[MachineNode]] = Const("managed")
      def getTime: F[Epoch]                        = Const("time")
      def start(node: MachineNode): F[Unit]        = Const("start")
      def stop(node: MachineNode): F[Unit]         = Const("stop")
    }
  
    val program = new DynAgentsModule[F](D, M)
  }
</pre></div>

</figure>

<p>With this interpretation of our program, we can assert on the methods that are
called:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  it should "call the expected methods" in {
    import ConstImpl._
  
    val alive    = Map(node1 -&gt; time1, node2 -&gt; time1)
    val world    = WorldView(1, 1, managed, alive, Map.empty, time4)
  
    program.act(world).getConst shouldBe "stopstop"
  }
</pre></div>

</figure>

<p>Alternatively, we could have counted total method calls by using <code>Const[Int, ?]</code>
or an <code>IMap[String, Int]</code>.</p>

<p>With this test, we’ve gone beyond traditional <em>Mock</em> testing with a <code>Const</code> test
that asserts on <em>what is called</em> without having to provide implementations. This
is useful if our specification demands that we make certain calls for certain
input, e.g. for accounting purposes. Furthermore, we’ve achieved this with
compiletime safety.</p>

<p>Taking this line of thinking a little further, say we want to monitor (in
production) the nodes that we are stopping in <code>act</code>. We can create
implementations of <code>Drone</code> and <code>Machines</code> with <code>Const</code>, calling it from our
wrapped version of <code>act</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class Monitored[U[_]: Functor](program: DynAgents[U]) {
    type F[a] = Const[Set[MachineNode], a]
    private val D = new Drone[F] {
      def getBacklog: F[Int] = Const(Set.empty)
      def getAgents: F[Int]  = Const(Set.empty)
    }
    private val M = new Machines[F] {
      def getAlive: F[Map[MachineNode, Epoch]]     = Const(Set.empty)
      def getManaged: F[NonEmptyList[MachineNode]] = Const(Set.empty)
      def getTime: F[Epoch]                        = Const(Set.empty)
      def start(node: MachineNode): F[Unit]        = Const(Set.empty)
      def stop(node: MachineNode): F[Unit]         = Const(Set(node))
    }
    val monitor = new DynAgentsModule[F](D, M)
  
    def act(world: WorldView): U[(WorldView, Set[MachineNode])] = {
      val stopped = monitor.act(world).getConst
      program.act(world).strengthR(stopped)
    }
  }
</pre></div>

</figure>

<p>We can do this because <code>monitor</code> is <em>pure</em> and running it produces no side
effects.</p>

<p>This runs the program with <code>ConstImpl</code>, extracting all the calls to
<code>Machines.stop</code>, then returning it alongside the <code>WorldView</code>. We can unit test
this:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  it should "monitor stopped nodes" in {
    val underlying = new Mutable(needsAgents).program
  
    val alive = Map(node1 -&gt; time1, node2 -&gt; time1)
    val world = WorldView(1, 1, managed, alive, Map.empty, time4)
    val expected = world.copy(pending = Map(node1 -&gt; time4, node2 -&gt; time4))
  
    val monitored = new Monitored(underlying)
    monitored.act(world) shouldBe (expected -&gt; Set(node1, node2))
  }
</pre></div>

</figure>

<p>We have used <code>Const</code> to do something that looks like <em>Aspect Oriented
Programming</em>, once popular in Java. We built on top of our business logic to
support a monitoring concern, without having to complicate the business logic.</p>

<p>It gets even better. We can run <code>ConstImpl</code> in production to gather what we want
to <code>stop</code>, and then provide an <strong>optimised</strong> implementation of <code>act</code> that can make
use of implementation-specific batched calls.</p>

<p>The silent hero of this story is <code>Applicative</code>. <code>Const</code> lets us show off what is
possible. If we need to change our program to require a <code>Monad</code>, we can no
longer use <code>Const</code> and must write full mocks to be able to assert on what is
called under certain inputs. The <em>Rule of Least Power</em> demands that we use
<code>Applicative</code> instead of <code>Monad</code> wherever we can.</p>

<h3 id="leanpub-auto-collections">
<a class="anchor-link" href="#leanpub-auto-collections"><i class="fa fa-link"></i></a><span class="section-number">6.8 </span>Collections</h3>

<p>Unlike the stdlib Collections API, the Scalaz approach describes collection
behaviours in the typeclass hierarchy, e.g. <code>Foldable</code>, <code>Traverse</code>, <code>Monoid</code>.
What remains to be studied are the implementations in terms of data structures,
which have different performance characteristics and niche methods.</p>

<p>This section goes into the implementation details for each data type. It is not
essential to remember everything presented here: the goal is to gain a high
level understanding of how each data structure works.</p>

<p>Because all the collection data types provide more or less the same list of
typeclass instances, we shall avoid repeating the list, which is often some
variation of:</p>

<ul>
  <li><code>Monoid</code></li>
  <li>
<code>Traverse</code> / <code>Foldable</code>
</li>
  <li>
<code>MonadPlus</code> / <code>IsEmpty</code>
</li>
  <li>
<code>Cobind</code> / <code>Comonad</code>
</li>
  <li>
<code>Zip</code> / <code>Unzip</code>
</li>
  <li><code>Align</code></li>
  <li>
<code>Equal</code> / <code>Order</code>
</li>
  <li><code>Show</code></li>
</ul>

<p>Data structures that are provably non-empty are able to provide</p>

<ul>
  <li>
<code>Traverse1</code> / <code>Foldable1</code>
</li>
</ul>

<p>and provide <code>Semigroup</code> instead of <code>Monoid</code>, <code>Plus</code> instead of <code>IsEmpty</code>.</p>

<h4 id="leanpub-auto-lists">
<a class="anchor-link" href="#leanpub-auto-lists"><i class="fa fa-link"></i></a><span class="section-number">6.8.1 </span>Lists</h4>

<p>We have used <code>IList[A]</code> and <code>NonEmptyList[A]</code> so many times by now that they
should be familiar. They codify a classic linked list data structure:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IList[A] {
    def ::(a: A): IList[A] = ...
    def :::(as: IList[A]): IList[A] = ...
    def toList: List[A] = ...
    def toNel: Option[NonEmptyList[A]] = ...
    ...
  }
  final case class INil[A]() extends IList[A]
  final case class ICons[A](head: A, tail: IList[A]) extends IList[A]
  
  final case class NonEmptyList[A](head: A, tail: IList[A]) {
    def &lt;::(b: A): NonEmptyList[A] = nel(b, head :: tail)
    def &lt;:::(bs: IList[A]): NonEmptyList[A] = ...
    ...
  }
</pre></div>

</figure>

<aside>
  <p>The source code for Scalaz 7.3 reveals that <code>INil</code> is implemented as</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract case class INil[A] private() extends IList[A]
  object INil {
    private[this] val value: INil[Nothing] = new INil[Nothing]{}
    def apply[A](): IList[A] = value.asInstanceOf[IList[A]]
  }
</pre></div>

  </figure>

  <p>which exploits JVM implementation details to avoid an object allocation when
creating an <code>INil</code>.</p>

  <p>This optimisation is manually applied to all zero-parameter classes. Indeed,
Scalaz is full of many optimisations of this nature: debated and accepted only
when presented with evidence of a significant performance boost and no risk of a
semantic change.</p>

</aside>

<p>The main advantage of <code>IList</code> over stdlib <code>List</code> is that there are no
unsafe methods, like <code>.head</code> which throws an exception on an empty
list.</p>

<p>In addition, <code>IList</code> is a <strong>lot</strong> simpler, having no hierarchy and a
much smaller bytecode footprint. Furthermore, the stdlib <code>List</code> has a
terrifying implementation that uses <code>var</code> to workaround performance
problems in the stdlib collection design:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  package scala.collection.immutable
  
  sealed abstract class List[+A]
    extends AbstractSeq[A]
    with LinearSeq[A]
    with GenericTraversableTemplate[A, List]
    with LinearSeqOptimized[A, List[A]] { ... }
  case object Nil extends List[Nothing] { ... }
  final case class ::[B](
    override val head: B,
    private[scala] var tl: List[B]
  ) extends List[B] { ... }
</pre></div>

</figure>

<p><code>List</code> creation requires careful, and slow, <code>Thread</code> synchronisation
to ensure safe publishing. <code>IList</code> requires no such hacks and can
therefore outperform <code>List</code>.</p>

<aside>
  <p>Isn’t <code>NonEmptyList</code> just the same as <code>ICons</code>? Yes, at a data structure level.
But the difference is that <code>ICons</code> is part of the <code>IList</code> ADT whereas
<code>NonEmptyList</code> is outside it. Typeclass instances should always be provided at
the level of an ADT, not for each entry, to avoid complexity.</p>

</aside>

<h4 id="leanpub-auto-ephemeralstream">
<a class="anchor-link" href="#leanpub-auto-ephemeralstream"><i class="fa fa-link"></i></a><span class="section-number">6.8.2 </span><code>EphemeralStream</code>
</h4>

<p>The stdlib <code>Stream</code> is a lazy version of <code>List</code>, but is riddled with
memory leaks and unsafe methods. <code>EphemeralStream</code> does not keep
references to computed values, helping to alleviate the memory
retention problem, and removing unsafe methods in the same spirit as
<code>IList</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class EphemeralStream[A] {
    def headOption: Option[A]
    def tailOption: Option[EphemeralStream[A]]
    ...
  }
  // private implementations
  object EphemeralStream extends EphemeralStreamInstances {
    type EStream[A] = EphemeralStream[A]
  
    def emptyEphemeralStream[A]: EStream[A] = ...
    def cons[A](a: =&gt;A, as: =&gt;EStream[A]): EStream[A] = ...
    def unfold[A, B](start: =&gt;B)(f: B =&gt; Option[(A, B)]): EStream[A] = ...
    def iterate[A](start: A)(f: A =&gt; A): EStream[A] = ...
  
    implicit class ConsWrap[A](e: =&gt;EStream[A]) {
      def ##::(h: A): EStream[A] = cons(h, e)
    }
    object ##:: {
      def unapply[A](xs: EStream[A]): Option[(A, EStream[A])] =
        if (xs.isEmpty) None
        else Some((xs.head(), xs.tail()))
    }
    ...
  }
</pre></div>

</figure>

<aside>
  <p>The use of the word <em>stream</em> for a data structure of this nature comes down to
legacy. <em>Stream</em> is now used by marketing departments alongside the ✨ <em>Reactive
Manifesto</em> ✨ and implementing frameworks like Akka Streams.</p>

</aside>

<p><code>.cons</code>, <code>.unfold</code> and <code>.iterate</code> are mechanisms for creating streams, and the
convenient syntax <code>##::</code> puts a new element at the head of a by-name <code>EStream</code>
reference. <code>.unfold</code> is for creating a finite (but possibly infinite) stream by
repeatedly applying a function <code>f</code> to get the next value and input for the
following <code>f</code>. <code>.iterate</code> creates an infinite stream by repeating a function <code>f</code>
on the previous element.</p>

<p><code>EStream</code> may appear in pattern matches with the symbol <code>##::</code>,
matching the syntax for <code>.cons</code>.</p>

<aside>
  <p><code>##::</code> sort of looks like an Exogorth: a giant space worm that lives
on an asteroid.</p>

</aside>

<p>Although <code>EStream</code> addresses the value memory retention problem, it is
still possible to suffer from <em>slow memory leaks</em> if a live reference
points to the head of an infinite stream. Problems of this nature, as
well as the need to compose effectful streams, are why fs2 exists.</p>

<h4 id="leanpub-auto-corecursivelist">
<a class="anchor-link" href="#leanpub-auto-corecursivelist"><i class="fa fa-link"></i></a><span class="section-number">6.8.3 </span><code>CorecursiveList</code>
</h4>

<p><em>Corecursion</em> is when we start from a base state and produce subsequent steps
deterministically, like the <code>EphemeralStream.unfold</code> method that we just
studied:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def unfold[A, B](b: =&gt;B)(f: B =&gt; Option[(A, B)]): EStream[A] = ...
</pre></div>

</figure>

<p>Contrast to <em>recursion</em>, which breaks data into a base state and then
terminates.</p>

<p>A <code>CorecursiveList</code> is a data encoding of <code>EphemeralStream.unfold</code>, offering an
alternative to <code>EStream</code> that may perform better in some circumstances:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class CorecursiveList[A] {
    type S
    def init: S
    def step: S =&gt; Maybe[(S, A)]
  }
  
  object CorecursiveList {
    private final case class CorecursiveListImpl[S0, A](
      init: S0,
      step: S0 =&gt; Maybe[(S0, A)]
    ) extends CorecursiveList[A] { type S = S0 }
  
    def apply[S, A](init: S)(step: S =&gt; Maybe[(S, A)]): CorecursiveList[A] =
      CorecursiveListImpl(init, step)
  
    ...
  }
</pre></div>

</figure>

<p>Corecursion is useful when implementing <code>Comonad.cojoin</code>, like our <code>Hood</code>
example. <code>CorecursiveList</code> is a good way to codify non-linear recurrence
equations like those used in biology population models, control systems, macro
economics, and investment banking models.</p>

<h4 id="leanpub-auto-immutablearray">
<a class="anchor-link" href="#leanpub-auto-immutablearray"><i class="fa fa-link"></i></a><span class="section-number">6.8.4 </span><code>ImmutableArray</code>
</h4>

<p>A simple wrapper around mutable stdlib <code>Array</code>, with primitive
specialisations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ImmutableArray[+A] {
    def ++[B &gt;: A: ClassTag](o: ImmutableArray[B]): ImmutableArray[B]
    ...
  }
  object ImmutableArray {
    final class StringArray(s: String) extends ImmutableArray[Char] { ... }
    sealed class ImmutableArray1[+A](as: Array[A]) extends ImmutableArray[A] { ... }
    final class ofRef[A &lt;: AnyRef](as: Array[A]) extends ImmutableArray1[A](as)
    ...
    final class ofLong(as: Array[Long]) extends ImmutableArray1[Long](as)
  
    def fromArray[A](x: Array[A]): ImmutableArray[A] = ...
    def fromString(str: String): ImmutableArray[Char] = ...
    ...
  }
</pre></div>

</figure>

<p><code>Array</code> is unrivalled in terms of read performance and heap size.
However, there is zero structural sharing when creating new arrays,
therefore arrays are typically used only when their contents are not
expected to change, or as a way of safely wrapping raw data from a
legacy system.</p>

<h4 id="leanpub-auto-dequeue">
<a class="anchor-link" href="#leanpub-auto-dequeue"><i class="fa fa-link"></i></a><span class="section-number">6.8.5 </span><code>Dequeue</code>
</h4>

<p>A <code>Dequeue</code> (pronounced like a “deck” of cards) is a linked list that
allows items to be put onto or retrieved from the front (<code>cons</code>) or
the back (<code>snoc</code>) in constant time. Removing an element from either
end is constant time on average.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Dequeue[A] {
    def frontMaybe: Maybe[A]
    def backMaybe: Maybe[A]
  
    def ++(o: Dequeue[A]): Dequeue[A] = ...
    def +:(a: A): Dequeue[A] = cons(a)
    def :+(a: A): Dequeue[A] = snoc(a)
    def cons(a: A): Dequeue[A] = ...
    def snoc(a: A): Dequeue[A] = ...
    def uncons: Maybe[(A, Dequeue[A])] = ...
    def unsnoc: Maybe[(A, Dequeue[A])] = ...
    ...
  }
  private final case class SingletonDequeue[A](single: A) extends Dequeue[A] { ... }
  private final case class FullDequeue[A](
    front: NonEmptyList[A],
    fsize: Int,
    back: NonEmptyList[A],
    backSize: Int) extends Dequeue[A] { ... }
  private final case object EmptyDequeue extends Dequeue[Nothing] { ... }
  
  object Dequeue {
    def empty[A]: Dequeue[A] = EmptyDequeue()
    def apply[A](as: A*): Dequeue[A] = ...
    def fromFoldable[F[_]: Foldable, A](fa: F[A]): Dequeue[A] = ...
    ...
  }
</pre></div>

</figure>

<p>The way it works is that there are two lists, one for the front data
and another for the back. Consider an instance holding symbols <code>a0,
a1, a2, a3, a4, a5, a6</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  FullDequeue(
    NonEmptyList('a0, IList('a1, 'a2, 'a3)), 4,
    NonEmptyList('a6, IList('a5, 'a4)), 3)
</pre></div>

</figure>

<p>which can be visualised as</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 30%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/dequeue.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Note that the list holding the <code>back</code> is in reverse order.</p>

<p>Reading the <code>snoc</code> (final element) is a simple lookup into
<code>back.head</code>. Adding an element to the end of the <code>Dequeue</code> means
adding a new element to the head of the <code>back</code>, and recreating the
<code>FullDequeue</code> wrapper (which will increase <code>backSize</code> by one). Almost
all of the original structure is shared. Compare to adding a new
element to the end of an <code>IList</code>, which would involve recreating the
entire structure.</p>

<p>The <code>frontSize</code> and <code>backSize</code> are used to re-balance the <code>front</code> and
<code>back</code> so that they are always approximately the same size.
Re-balancing means that some operations can be slower than others
(e.g. when the entire structure must be rebuilt) but because it
happens only occasionally, we can take the average of the cost and say
that it is constant.</p>

<h4 id="leanpub-auto-dlist">
<a class="anchor-link" href="#leanpub-auto-dlist"><i class="fa fa-link"></i></a><span class="section-number">6.8.6 </span><code>DList</code>
</h4>

<p>Linked lists have poor performance characteristics when large lists are appended
together. Consider the work that goes into evaluating the following:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ((as ::: bs) ::: (cs ::: ds)) ::: (es ::: (fs ::: gs))
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/dlist-list-append.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>This creates six intermediate lists, traversing and rebuilding every list three
times (except for <code>gs</code> which is shared between all stages).</p>

<p>The <code>DList</code> (for <em>difference list</em>) is a more efficient solution for this
scenario. Instead of performing the calculations at each stage, it is
represented as a function <code>IList[A] =&gt; IList[A]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class DList[A](f: IList[A] =&gt; IList[A]) {
    def toIList: IList[A] = f(IList.empty)
    def ++(as: DList[A]): DList[A] = DList(xs =&gt; f(as.f(xs)))
    ...
  }
  object DList {
    def fromIList[A](as: IList[A]): DList[A] = DList(xs =&gt; as ::: xs)
  }
</pre></div>

</figure>

<aside>
  <p>This is a simplified implementation: it has a stack overflow bug that we will
fix in the chapter on Advanced Monads.</p>

</aside>

<p>The equivalent calculation is (the symbols created via <code>DList.fromIList</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (((a ++ b) ++ (c ++ d)) ++ (e ++ (f ++ g))).toIList
</pre></div>

</figure>

<p>which breaks the work into <em>right-associative</em> (i.e. fast) appends</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (as ::: (bs ::: (cs ::: (ds ::: (es ::: (fs ::: gs))))))
</pre></div>

</figure>

<p>utilising the fast constructor on <code>IList</code>.</p>

<p>As always, there is no free lunch. There is a memory allocation overhead that
can slow down code that naturally results in right-associative appends. The
largest speedup is when <code>IList</code> operations are <em>left-associative</em>, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ((((((as ::: bs) ::: cs) ::: ds) ::: es) ::: fs) ::: gs)
</pre></div>

</figure>

<p>Difference lists suffer from bad marketing. If they were called a
<code>ListBuilderFactory</code> they’d probably be in the standard library.</p>

<h4 id="leanpub-auto-iset">
<a class="anchor-link" href="#leanpub-auto-iset"><i class="fa fa-link"></i></a><span class="section-number">6.8.7 </span><code>ISet</code>
</h4>

<p>Tree structures are excellent for storing ordered data, with every <em>binary node</em>
holding elements that are <em>less than</em> in one branch, and <em>greater than</em> in the
other. However, naive implementations of a tree structure can become
<em>unbalanced</em> depending on the insertion order. It is possible to maintain a
perfectly balanced tree, but it is incredibly inefficient as every insertion
effectively rebuilds the entire tree.</p>

<p><code>ISet</code> is an implementation of a tree of <em>bounded balance</em>, meaning that it is
approximately balanced, using the <code>size</code> of each branch to balance a node.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ISet[A] {
    val size: Int = this match {
      case Tip()        =&gt; 0
      case Bin(_, l, r) =&gt; 1 + l.size + r.size
    }
    ...
  }
  object ISet {
    private final case class Tip[A]() extends ISet[A]
    private final case class Bin[A](a: A, l: ISet[A], r: ISet[A]) extends ISet[A]
  
    def empty[A]: ISet[A] = Tip()
    def singleton[A](x: A): ISet[A] = Bin(x, Tip(), Tip())
    def fromFoldable[F[_]: Foldable, A: Order](xs: F[A]): ISet[A] =
      xs.foldLeft(empty[A])((a, b) =&gt; a insert b)
    ...
  }
</pre></div>

</figure>

<p><code>ISet</code> requires <code>A</code> to have an <code>Order</code>. The <code>Order[A]</code> instance must remain the
same between calls or internal assumptions will be invalid, leading to data
corruption: i.e. we are assuming typeclass coherence such that <code>Order[A]</code> is
unique for any <code>A</code>.</p>

<p>The <code>ISet</code> ADT unfortunately permits invalid trees. We strive to write ADTs that
fully describe what is and isn’t valid through type restrictions, but sometimes
there are situations where it can only be achieved by the inspired touch of an
immortal. Instead, <code>Tip</code> / <code>Bin</code> are <code>private</code>, to stop users from accidentally
constructing invalid trees. <code>.insert</code> is the only way to build an <code>ISet</code>,
therefore defining what constitutes a valid tree.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ISet[A] {
    ...
    def contains(x: A)(implicit o: Order[A]): Boolean = ...
    def union(other: ISet[A])(implicit o: Order[A]): ISet[A] = ...
    def delete(x: A)(implicit o: Order[A]): ISet[A] = ...
  
    def insert(x: A)(implicit o: Order[A]): ISet[A] = this match {
      case Tip() =&gt; ISet.singleton(x)
      case self @ Bin(y, l, r) =&gt; o.order(x, y) match {
        case LT =&gt; balanceL(y, l.insert(x), r)
        case GT =&gt; balanceR(y, l, r.insert(x))
        case EQ =&gt; self
      }
    }
    ...
  }
</pre></div>

</figure>

<p>The internal methods <code>.balanceL</code> and <code>.balanceR</code> are mirrors of each other, so
we only study <code>.balanceL</code>, which is called when the value we are inserting is
<em>less than</em> the current node. It is also called by the <code>.delete</code> method.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def balanceL[A](y: A, left: ISet[A], right: ISet[A]): ISet[A] = (left, right) match {
  ...
</pre></div>

</figure>

<p>Balancing requires us to classify the scenarios that can occur. We will go
through each possible scenario, visualising the <code>(y, left, right)</code> on the left
side of the page, with the balanced structure on the right, also known as the
<em>rotated tree</em>.</p>

<ul>
  <li>filled circles visualise a <code>Tip</code>
</li>
  <li>three columns visualise the <code>left | value | right</code> fields of <code>Bin</code>
</li>
  <li>diamonds visualise any <code>ISet</code>
</li>
</ul>

<p>The first scenario is the trivial case, which is when both the <code>left</code> and
<code>right</code> are <code>Tip</code>. In fact we will never encounter this scenario from <code>.insert</code>,
but we hit it in <code>.delete</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Tip(), Tip()) =&gt; singleton(y)
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-1.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>The second case is when <code>left</code> is a <code>Bin</code> containing only <code>Tip</code>, we don’t need
to balance anything, we just create the obvious connection:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Bin(lx, Tip(), Tip()), Tip()) =&gt; Bin(y, left, Tip())
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-2.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>The third case is when it starts to get interesting: <code>left</code> is a <code>Bin</code>
containing a <code>Bin</code> in its <code>right</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Bin(lx, Tip(), Bin(lrx, _, _)), Tip()) =&gt;
    Bin(lrx, singleton(lx), singleton(y))
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-3.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>But what happened to the two diamonds sitting below <code>lrx</code>? Didn’t we just lose
information? No, we didn’t lose information, because we can reason (based on
size balancing) that they are always <code>Tip</code>! There is no rule in any of the
following scenarios (or in <code>.balanceR</code>) that can produce a tree of the shape
where the diamonds are <code>Bin</code>.</p>

<p>The fourth case is the opposite of the third case.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Bin(lx, ll, Tip()), Tip()) =&gt; Bin(lx, ll, singleton(y))
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 70%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-4.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>The fifth case is when we have full trees on both sides of the <code>left</code> and we
must use their relative sizes to decide on how to re-balance.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Bin(lx, ll, lr), Tip()) if (2*ll.size &gt; lr.size) =&gt;
    Bin(lx, ll, Bin(y, lr, Tip()))
  case (Bin(lx, ll, Bin(lrx, lrl, lrr)), Tip()) =&gt;
    Bin(lrx, Bin(lx, ll, lrl), Bin(y, lrr, Tip()))
</pre></div>

</figure>

<p>For the first branch, <code>2*ll.size &gt; lr.size</code></p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-5a.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>and for the second branch <code>2*ll.size &lt;= lr.size</code></p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 75%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-5b.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>The sixth scenario introduces a tree on the <code>right</code>. When the <code>left</code> is empty we
create the obvious connection. This scenario never arises from <code>.insert</code> because
the <code>left</code> is always non-empty:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Tip(), r) =&gt; Bin(y, Tip(), r)
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-6.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>The final scenario is when we have non-empty trees on both sides. Unless the
<code>left</code> is three times or more the size of the <code>right</code>, we can do the simple
thing and create a new <code>Bin</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  case _ if l.size &lt;= 3 * r.size =&gt; Bin(y, l, r)
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-7a.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>However, should the <code>left</code> be more than three times the size of the <code>right</code>, we
must balance based on the relative sizes of <code>ll</code> and <code>lr</code>, like in scenario
five.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case (Bin(lx, ll, lr), r) if (2*ll.size &gt; lr.size) =&gt;
    Bin(lx, ll, Bin(y, lr, r))
  case (Bin(lx, ll, Bin(lrx, lrl, lrr)), r) =&gt;
    Bin(lrx, Bin(lx, ll, lrl), Bin(y, lrr, r))
</pre></div>

</figure>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-7b.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>



<div class="figure-wrapper center">
  <figure class="image" style="width: 75%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/balanceL-7c.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>This concludes our study of the <code>.insert</code> method and how the <code>ISet</code> is
constructed. It should be of no surprise that <code>Foldable</code> is implemented in terms
of depth-first search along the <code>left</code> or <code>right</code>, as appropriate. Methods such
as <code>.minimum</code> and <code>.maximum</code> are optimal because the data structure already
encodes the ordering.</p>

<p>It is worth noting that some typeclass methods <em>cannot</em> be implemented as
efficiently as we would like. Consider the signature of <code>Foldable.element</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Foldable[F[_]] {
    ...
    def element[A: Equal](fa: F[A], a: A): Boolean
    ...
  }
</pre></div>

</figure>

<p>The obvious implementation for <code>.element</code> is to defer to (almost) binary-search
<code>ISet.contains</code>. However, it is not possible because <code>.element</code> provides <code>Equal</code>
whereas <code>.contains</code> requires <code>Order</code>.</p>

<p><code>ISet</code> is unable to provide a <code>Functor</code> for the same reason. In practice this
turns out to be a sensible constraint: performing a <code>.map</code> would involve
rebuilding the entire structure. It is sensible to convert to some other
datatype, such as <code>IList</code>, perform the <code>.map</code>, and convert back. A consequence
is that it is not possible to have <code>Traverse[ISet]</code> or <code>Applicative[ISet]</code>.</p>

<h4 id="leanpub-auto-imap">
<a class="anchor-link" href="#leanpub-auto-imap"><i class="fa fa-link"></i></a><span class="section-number">6.8.8 </span><code>IMap</code>
</h4>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ==&gt;&gt;[A, B] {
    val size: Int = this match {
      case Tip()           =&gt; 0
      case Bin(_, _, l, r) =&gt; 1 + l.size + r.size
    }
  }
  object ==&gt;&gt; {
    type IMap[A, B] = A ==&gt;&gt; B
  
    private final case class Tip[A, B]() extends (A ==&gt;&gt; B)
    private final case class Bin[A, B](
      key: A,
      value: B,
      left: A ==&gt;&gt; B,
      right: A ==&gt;&gt; B
    ) extends ==&gt;&gt;[A, B]
  
    def apply[A: Order, B](x: (A, B)*): A ==&gt;&gt; B = ...
  
    def empty[A, B]: A ==&gt;&gt; B = Tip[A, B]()
    def singleton[A, B](k: A, x: B): A ==&gt;&gt; B = Bin(k, x, Tip(), Tip())
    def fromFoldable[F[_]: Foldable, A: Order, B](fa: F[(A, B)]): A ==&gt;&gt; B = ...
    ...
  }
</pre></div>

</figure>

<p>This is very familiar! Indeed, <code>IMap</code> (an alias to the lightspeed operator
<code>==&gt;&gt;</code>) is another size-balanced tree, but with an extra <code>value: B</code> field in
each binary branch, allowing it to store key/value pairs. Only the key type <code>A</code>
needs an <code>Order</code> and a suite of convenient methods are provided to allow easy
entry updating</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ==&gt;&gt;[A, B] {
    ...
    def adjust(k: A, f: B =&gt; B)(implicit o: Order[A]): A ==&gt;&gt; B = ...
    def adjustWithKey(k: A, f: (A, B) =&gt; B)(implicit o: Order[A]): A ==&gt;&gt; B = ...
    ...
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-stricttree-and-tree">
<a class="anchor-link" href="#leanpub-auto-stricttree-and-tree"><i class="fa fa-link"></i></a><span class="section-number">6.8.9 </span><code>StrictTree</code> and <code>Tree</code>
</h4>

<p>Both <code>StrictTree</code> and <code>Tree</code> are implementations of a <em>Rose Tree</em>, a tree
structure with an unbounded number of branches in every node (unfortunately
built from standard library collections for legacy reasons):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case class StrictTree[A](
    rootLabel: A,
    subForest: Vector[StrictTree[A]]
  )
</pre></div>

</figure>

<p><code>Tree</code> is a <em>by-need</em> version of <code>StrictTree</code> with convenient constructors</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class Tree[A](
    rootc: Need[A],
    forestc: Need[Stream[Tree[A]]]
  ) {
    def rootLabel = rootc.value
    def subForest = forestc.value
  }
  object Tree {
    object Node {
      def apply[A](root: =&gt;A, forest: =&gt;Stream[Tree[A]]): Tree[A] = ...
    }
    object Leaf {
      def apply[A](root: =&gt;A): Tree[A] = ...
    }
  }
</pre></div>

</figure>

<p>The user of a Rose Tree is expected to manually balance it, which makes it
suitable for cases where it is useful to encode domain knowledge of a hierarchy
into the data structure. For example, in artificial intelligence, a Rose Tree
can be used in <a href="https://arxiv.org/abs/1203.3468">clustering algorithms</a> to organise data into a hierarchy of
increasingly similar things. It is possible to represent XML documents with a
Rose Tree.</p>

<p>When working with hierarchical data, consider using a Rose Tree instead of
rolling a custom data structure.</p>

<h4 id="leanpub-auto-fingertree">
<a class="anchor-link" href="#leanpub-auto-fingertree"><i class="fa fa-link"></i></a><span class="section-number">6.8.10 </span><code>FingerTree</code>
</h4>

<p>Finger trees are generalised sequences with amortised constant cost lookup and
logarithmic concatenation. <code>A</code> is the type of data, ignore <code>V</code> for now:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class FingerTree[V, A] {
    def +:(a: A): FingerTree[V, A] = ...
    def :+(a: =&gt;A): FingerTree[V, A] = ...
    def &lt;++&gt;(right: =&gt;FingerTree[V, A]): FingerTree[V, A] = ...
    ...
  }
  object FingerTree {
    private class Empty[V, A]() extends FingerTree[V, A]
    private class Single[V, A](v: V, a: =&gt;A) extends FingerTree[V, A]
    private class Deep[V, A](
      v: V,
      left: Finger[V, A],
      spine: =&gt;FingerTree[V, Node[V, A]],
      right: Finger[V, A]
    ) extends FingerTree[V, A]
  
    sealed abstract class Finger[V, A]
    final case class One[V, A](v: V, a1: A) extends Finger[V, A]
    final case class Two[V, A](v: V, a1: A, a2: A) extends Finger[V, A]
    final case class Three[V, A](v: V, a1: A, a2: A, a3: A) extends Finger[V, A]
    final case class Four[V, A](v: V, a1: A, a2: A, a3: A, a4: A) extends Finger[V, A]
  
    sealed abstract class Node[V, A]
    private class Node2[V, A](v: V, a1: =&gt;A, a2: =&gt;A) extends Node[V, A]
    private class Node3[V, A](v: V, a1: =&gt;A, a2: =&gt;A, a3: =&gt;A) extends Node[V, A]
    ...
  }
</pre></div>

</figure>

<aside>
  <p><code>&lt;++&gt;</code> is the TIE Bomber. Admittedly, sending in the proton torpedoes is a bit
of an overreaction: it is the same thing as the regular <code>Monoid</code> TIE Fighter
<code>|+|</code>.</p>

</aside>

<p>Visualising <code>FingerTree</code> as dots, <code>Finger</code> as boxes and <code>Node</code> as boxes within
boxes:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 35%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/fingertree.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Adding elements to the front of a <code>FingerTree</code> with <code>+:</code> is efficient because
<code>Deep</code> simply adds the new element to its <code>left</code> finger. If the finger is a
<code>Four</code>, we rebuild the <code>spine</code> to take 3 of the elements as a <code>Node3</code>. Adding to
the end, <code>:+</code>, is the same but in reverse.</p>

<p>Appending <code>|+|</code> (also <code>&lt;++&gt;</code>) is more efficient than adding one element at a
time because the case of two <code>Deep</code> trees can retain the outer branches,
rebuilding the spine based on the 16 possible combinations of the two <code>Finger</code>
values in the middle.</p>

<p>In the above we skipped over <code>V</code>. Not shown in the ADT description is an
<code>implicit measurer: Reducer[A, V]</code> on every element of the ADT.</p>

<aside>
  <p>Storing typeclass instances on the ADT is considered bad style and also
increases the memory requirement by 64 bits for every entry. The implementation
of <code>FingerTree</code> is almost a decade old and is due a rewrite.</p>

</aside>

<p><code>Reducer</code> is an extension of <code>Monoid</code> that allows for single elements to be
added to an <code>M</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  class Reducer[C, M: Monoid] {
    def unit(c: C): M
  
    def snoc(m: M, c: C): M = append(m, unit(c))
    def cons(c: C, m: M): M = append(unit(c), m)
  }
</pre></div>

</figure>

<p>For example, <code>Reducer[A, IList[A]]</code> can provide an efficient <code>.cons</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def reducer[A]: Reducer[A, IList[A]] = new Reducer[A, IList[A]] {
    override def unit(a: A): IList[A] = IList.single(a)
    override def cons(a: A, as: IList[A]): IList[A] = a :: as
  }
</pre></div>

</figure>

<aside>
  <p><code>Reducer</code> should have been called <code>CanActuallyBuildFrom</code>, in honour of the
similarly named stdlib <code>class</code>, since it is effectively a collection builder.</p>

</aside>

<h5 id="leanpub-auto-indseq">
<a class="anchor-link" href="#leanpub-auto-indseq"><i class="fa fa-link"></i></a><span class="section-number">6.8.10.1 </span><code>IndSeq</code>
</h5>

<p>If we use <code>Int</code> as <code>V</code>, we can get an indexed sequence, where the measure is
<em>size</em>, allowing us to perform index-based lookup by comparing the desired index
with the size at each branch in the structure:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class IndSeq[A](val self: FingerTree[Int, A])
  object IndSeq {
    private implicit def sizer[A]: Reducer[A, Int] = _ =&gt; 1
    def apply[A](as: A*): IndSeq[A] = ...
  }
</pre></div>

</figure>

<p>Another use of <code>FingerTree</code> is as an ordered sequence, where the measure stores
the largest value contained by each branch:</p>

<h5 id="leanpub-auto-ordseq">
<a class="anchor-link" href="#leanpub-auto-ordseq"><i class="fa fa-link"></i></a><span class="section-number">6.8.10.2 </span><code>OrdSeq</code>
</h5>

<figure class="code">
<div class="highlight"><pre><code></code>  final class OrdSeq[A: Order](val self: FingerTree[LastOption[A], A]) {
    def partition(a: A): (OrdSeq[A], OrdSeq[A]) = ...
    def insert(a: A): OrdSeq[A] = ...
    def ++(xs: OrdSeq[A]): OrdSeq[A] = ...
  }
  object OrdSeq {
    private implicit def keyer[A]: Reducer[A, LastOption[A]] = a =&gt; Tag(Some(a))
    def apply[A: Order](as: A*): OrdSeq[A] = ...
  }
</pre></div>

</figure>

<p><code>OrdSeq</code> has no typeclass instances so it is only useful for incrementally
building up an ordered sequence, with duplicates. We can access the underlying
<code>FingerTree</code> when needed.</p>

<h5 id="leanpub-auto-cord">
<a class="anchor-link" href="#leanpub-auto-cord"><i class="fa fa-link"></i></a><span class="section-number">6.8.10.3 </span><code>Cord</code>
</h5>

<p>The most common use of <code>FingerTree</code> is as an intermediate holder for <code>String</code>
representations in <code>Show</code>. Building a single <code>String</code> can be thousands of times
faster than the default <code>case class</code> implementation of nested <code>.toString</code>, which
builds a <code>String</code> for every layer in the ADT.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Cord(self: FingerTree[Int, String]) {
    override def toString: String = {
      val sb = new java.lang.StringBuilder(self.measure)
      self.foreach(sb.append) // locally scoped side effect
      sb.toString
    }
    ...
  }
</pre></div>

</figure>

<p>For example, the <code>Cord[String]</code> instance returns a <code>Three</code> with the string in
the middle and quotes on either side</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val show: Show[String] = s =&gt; Cord(FingerTree.Three("\"", s, "\""))
</pre></div>

</figure>

<p>Therefore a <code>String</code> renders as it is written in source code</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val s = "foo"
         s.toString
  res: String = foo
  
  scala&gt; s.show
  res: Cord = "foo"
</pre></div>

</figure>

<aside>
  <p>The <code>Cord</code> in Scalaz 7.2 is unfortunately not as efficient as it could be. This
has been fixed in Scalaz 7.3 by a <a href="https://github.com/scalaz/scalaz/pull/1793">custom data structure optimised for <code>String</code>
concatenation</a>.</p>

</aside>

<h4 id="leanpub-auto-heap-priority-queue">
<a class="anchor-link" href="#leanpub-auto-heap-priority-queue"><i class="fa fa-link"></i></a><span class="section-number">6.8.11 </span><code>Heap</code> Priority Queue</h4>

<p>A <em>priority queue</em> is a data structure that allows fast insertion of ordered
elements, allowing duplicates, with fast access to the <em>minimum</em> value (highest
priority). The structure is not required to store the non-minimal elements in
order. A naive implementation of a priority queue could be</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Vip[A] private (val peek: Maybe[A], xs: IList[A]) {
    def push(a: A)(implicit O: Order[A]): Vip[A] = peek match {
      case Maybe.Just(min) if a &lt; min =&gt; Vip(a.just, min :: xs)
      case _                          =&gt; Vip(peek, a :: xs)
    }
  
    def pop(implicit O: Order[A]): Maybe[(A, Vip[A])] = peek strengthR reorder
    private def reorder(implicit O: Order[A]): Vip[A] = xs.sorted match {
      case INil()           =&gt; Vip(Maybe.empty, IList.empty)
      case ICons(min, rest) =&gt; Vip(min.just, rest)
    }
  }
  object Vip {
    def fromList[A: Order](xs: IList[A]): Vip[A] = Vip(Maybe.empty, xs).reorder
  }
</pre></div>

</figure>

<p>This <code>push</code> is a very fast <code>O(1)</code>, but <code>reorder</code> (and therefore <code>pop</code>) relies on
<code>IList.sorted</code> costing <code>O(n log n)</code>.</p>

<p>Scalaz encodes a priority queue with a tree structure where every node has a
value less than its children. <code>Heap</code> has fast push (<code>insert</code>), <code>union</code>, <code>size</code>,
pop (<code>uncons</code>) and peek (<code>minimumO</code>) operations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Heap[A] {
    def insert(a: A)(implicit O: Order[A]): Heap[A] = ...
    def +(a: A)(implicit O: Order[A]): Heap[A] = insert(a)
  
    def union(as: Heap[A])(implicit O: Order[A]): Heap[A] = ...
  
    def uncons(implicit O: Order[A]): Option[(A, Heap[A])] = minimumO strengthR deleteMin
    def minimumO: Option[A] = ...
    def deleteMin(implicit O: Order[A]): Heap[A] = ...
  
    ...
  }
  object Heap {
    def fromData[F[_]: Foldable, A: Order](as: F[A]): Heap[A] = ...
  
    private final case class Ranked[A](rank: Int, value: A)
  
    private final case class Empty[A]() extends Heap[A]
    private final case class NonEmpty[A](
      size: Int,
      tree: Tree[Ranked[A]]
    ) extends Heap[A]
  
    ...
  }
</pre></div>

</figure>

<aside>
  <p><code>size</code> is memoized in the ADT to enable instant calculation of
<code>Foldable.length</code>, at a cost of 64 bits per entry. A variant of <code>Heap</code> could be
created with a smaller footprint, but slower <code>Foldable.length</code>.</p>

</aside>

<p><code>Heap</code> is implemented with a Rose <code>Tree</code> of <code>Ranked</code> values, where the <code>rank</code> is
the depth of a subtree, allowing us to depth-balance the tree. We manually
maintain the tree so the <code>minimum</code> value is at the top. An advantage of encoding
the minimum value in the data structure is that <code>minimumO</code> (also known as
<em>peek</em>) is a free lookup:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def minimumO: Option[A] = this match {
    case Empty()                        =&gt; None
    case NonEmpty(_, Tree.Node(min, _)) =&gt; Some(min.value)
  }
</pre></div>

</figure>

<p>When inserting a new entry, we compare to the current minimum and replace if the
new entry is lower:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def insert(a: A)(implicit O: Order[A]): Heap[A] = this match {
    case Empty() =&gt;
      NonEmpty(1, Tree.Leaf(Ranked(0, a)))
    case NonEmpty(size, tree @ Tree.Node(min, _)) if a &lt;= min.value =&gt;
      NonEmpty(size + 1, Tree.Node(Ranked(0, a), Stream(tree)))
  ...
</pre></div>

</figure>

<p>Insertions of non-minimal values result in an <em>unordered</em> structure in the
branches of the minimum. When we encounter two or more subtrees of equal rank,
we optimistically put the minimum to the front:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    case NonEmpty(size, Tree.Node(min,
           (t1 @ Tree.Node(Ranked(r1, x1), xs1)) #::
           (t2 @ Tree.Node(Ranked(r2, x2), xs2)) #:: ts)) if r1 == r2 =&gt;
      lazy val t0 = Tree.Leaf(Ranked(0, a))
      val sub =
        if (x1 &lt;= a &amp;&amp; x1 &lt;= x2)
          Tree.Node(Ranked(r1 + 1, x1), t0 #:: t2 #:: xs1)
        else if (x2 &lt;= a &amp;&amp; x2 &lt;= x1)
          Tree.Node(Ranked(r2 + 1, x2), t0 #:: t1 #:: xs2)
        else
          Tree.Node(Ranked(r1 + 1, a), t1 #:: t2 #:: Stream())
  
      NonEmpty(size + 1, Tree.Node(Ranked(0, min.value), sub #:: ts))
  
    case NonEmpty(size,  Tree.Node(min, rest)) =&gt;
      val t0 = Tree.Leaf(Ranked(0, a))
      NonEmpty(size + 1, Tree.Node(Ranked(0, min.value), t0 #:: rest))
  }
</pre></div>

</figure>

<p>Avoiding a full ordering of the tree makes <code>insert</code> very fast, <code>O(1)</code>, such that
producers adding to the queue are not penalised. However, the consumer pays the
cost when calling <code>uncons</code>, with <code>deleteMin</code> costing <code>O(log n)</code> because it must
search for the minimum value, and remove it from the tree by rebuilding. That Is
fast when compared to the naive implementation.</p>

<p>The <code>union</code> operation also delays ordering allowing it to be <code>O(1)</code>.</p>

<p>If the <code>Order[Foo]</code> does not correctly capture the priority we want for the
<code>Heap[Foo]</code>, we can use <code>Tag</code> and provide a custom <code>Order[Foo @@ Custom]</code> for a
<code>Heap[Foo @@ Custom]</code>.</p>

<h4 id="leanpub-auto-diev-discrete-intervals">
<a class="anchor-link" href="#leanpub-auto-diev-discrete-intervals"><i class="fa fa-link"></i></a><span class="section-number">6.8.12 </span><code>Diev</code> (Discrete Intervals)</h4>

<p>We can efficiently encode the (unordered) integer values 6, 9, 2, 13, 8, 14, 10,
7, 5 as inclusive intervals <code>[2, 2], [5, 10], [13, 14]</code>. <code>Diev</code> is an efficient
encoding of <em>intervals</em> for elements <code>A</code> that have an <code>Enum[A]</code>, getting more
efficient as the contents become denser.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Diev[A] {
    def +(interval: (A, A)): Diev[A]
    def +(value: A): Diev[A]
    def ++(other: Diev[A]): Diev[A]
  
    def -(interval: (A, A)): Diev[A]
    def -(value: A): Diev[A]
    def --(other: Diev[A]): Diev[A]
  
    def intervals: Vector[(A, A)]
    def contains(value: A): Boolean
    def contains(interval: (A, A)): Boolean
    ...
  }
  object Diev {
    private final case class DieVector[A: Enum](
      intervals: Vector[(A, A)]
    ) extends Diev[A]
  
    def empty[A: Enum]: Diev[A] = ...
    def fromValuesSeq[A: Enum](values: Seq[A]): Diev[A] = ...
    def fromIntervalsSeq[A: Enum](intervals: Seq[(A, A)]): Diev[A] = ...
  }
</pre></div>

</figure>

<p>When updating the <code>Diev</code>, adjacent intervals are merged (and then ordered) such
that there is a unique representation for a given set of values.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; Diev.fromValuesSeq(List(6, 9, 2, 13, 8, 14, 10, 7, 5))
  res: Diev[Int] = ((2,2)(5,10)(13,14))
  
  scala&gt; Diev.fromValuesSeq(List(6, 9, 2, 13, 8, 14, 10, 7, 5).reverse)
  res: Diev[Int] = ((2,2)(5,10)(13,14))
</pre></div>

</figure>

<p>A great usecase for <code>Diev</code> is for storing time periods. For example, in our
<code>TradeTemplate</code> from the previous chapter</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class TradeTemplate(
    payments: List[java.time.LocalDate],
    ccy: Option[Currency],
    otc: Option[Boolean]
  )
</pre></div>

</figure>

<p>if we find that the <code>payments</code> are very dense, we may wish to swap to a <code>Diev</code>
representation for performance reasons, without any change in our business logic
because we used <code>Monoid</code>, not any <code>List</code> specific methods. We would, however,
have to provide an <code>Enum[LocalDate]</code>, which is an otherwise useful thing to
have.</p>

<h4 id="leanpub-auto-oneand">
<a class="anchor-link" href="#leanpub-auto-oneand"><i class="fa fa-link"></i></a><span class="section-number">6.8.13 </span><code>OneAnd</code>
</h4>

<p>Recall that <code>Foldable</code> is the Scalaz equivalent of a collections API and
<code>Foldable1</code> is for non-empty collections. So far we have only seen
<code>NonEmptyList</code> to provide a <code>Foldable1</code>. The simple data structure <code>OneAnd</code>
wraps any other collection to turn it into a <code>Foldable1</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class OneAnd[F[_], A](head: A, tail: F[A])
</pre></div>

</figure>

<p><code>NonEmptyList[A]</code> could be an alias to <code>OneAnd[IList, A]</code>. Similarly, we can
create non-empty <code>Stream</code>, <code>DList</code> and <code>Tree</code> structures. However it may break
ordering and uniqueness characteristics of the underlying structure: a
<code>OneAnd[ISet, A]</code> is not a non-empty <code>ISet</code>, it is an <code>ISet</code> with a guaranteed
first element that may also be in the <code>ISet</code>.</p>

<h3 id="leanpub-auto-summary-4">
<a class="anchor-link" href="#leanpub-auto-summary-4"><i class="fa fa-link"></i></a><span class="section-number">6.9 </span>Summary</h3>

<p>In this chapter we have skimmed over the data types that Scalaz has to offer.</p>

<p>It is not necessary to remember everything from this chapter: think of each
section as having planted the kernel of an idea.</p>

<p>The world of functional data structures is an active area of research. Academic
publications appear regularly with new approaches to old problems. Implementing
a functional data structure from the literature is a good contribution to the
Scalaz ecosystem.</p>

<h2 id="leanpub-auto-advanced-monads">
<a class="anchor-link" href="#leanpub-auto-advanced-monads"><i class="fa fa-link"></i></a><span class="section-number">7. </span>Advanced Monads</h2>

<p>You have to know things like Advanced Monads in order to be an advanced
functional programmer.</p>

<p>However, we are developers yearning for a simple life, and our idea of
“advanced” is modest. To put it into context: <code>scala.concurrent.Future</code> is more
complicated and nuanced than any <code>Monad</code> in this chapter.</p>

<p>In this chapter we will study some of the most important implementations of
<code>Monad</code>.</p>

<h3 id="leanpub-auto-always-in-motion-is-the-future">
<a class="anchor-link" href="#leanpub-auto-always-in-motion-is-the-future"><i class="fa fa-link"></i></a><span class="section-number">7.1 </span>Always in motion is the <code>Future</code>
</h3>

<p>The biggest problem with <code>Future</code> is that it eagerly schedules work during
construction. As we discovered in the introduction, <code>Future</code> conflates the
definition of a program with <em>interpreting</em> it (i.e. running it).</p>

<p><code>Future</code> is also bad from a performance perspective: every time <code>.flatMap</code> is
called, a closure is submitted to an <code>Executor</code>, resulting in unnecessary thread
scheduling and context switching. It is not unusual to see 50% of our CPU power
dealing with thread scheduling, instead of doing the work. So much so that
parallelising work with <code>Future</code> can often make it <em>slower</em>.</p>

<p>Combined, eager evaluation and executor submission means that it is impossible
to know when a job started, when it finished, or the sub-tasks that were spawned
to calculate the final result. It should not surprise us that performance
monitoring “solutions” for <code>Future</code> based frameworks are a solid earner for the
modern day snake oil merchant.</p>

<p>Furthermore, <code>Future.flatMap</code> requires an <code>ExecutionContext</code> to be in implicit
scope: users are forced to think about business logic and execution semantics at
the same time.</p>

<aside>
  <p>If <code>Future</code> was a Star Wars character, it would be Anakin Skywalker: the fallen
chosen one, rushing in and breaking things without thinking.</p>

</aside>

<h3 id="leanpub-auto-effects-and-side-effects">
<a class="anchor-link" href="#leanpub-auto-effects-and-side-effects"><i class="fa fa-link"></i></a><span class="section-number">7.2 </span>Effects and Side Effects</h3>

<p>If we cannot call side-effecting methods in our business logic, or in <code>Future</code>
(or <code>Id</code>, or <code>Either</code>, or <code>Const</code>, etc), <strong>when can</strong> we write them? The answer
is: in a <code>Monad</code> that delays execution until it is interpreted at the
application’s entrypoint. We can now refer to I/O and mutation as an <em>effect</em> on
the world, captured by the type system, as opposed to having a hidden
<em>side-effect</em>.</p>

<p>The simplest implementation of such a <code>Monad</code> is <code>IO</code>, formalising the version
we wrote in the introduction:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class IO[A](val interpret: () =&gt; A)
  object IO {
    def apply[A](a: =&gt;A): IO[A] = new IO(() =&gt; a)
  
    implicit val monad: Monad[IO] = new Monad[IO] {
      def point[A](a: =&gt;A): IO[A] = IO(a)
      def bind[A, B](fa: IO[A])(f: A =&gt; IO[B]): IO[B] = IO(f(fa.interpret()).interpret())
    }
  }
</pre></div>

</figure>

<p>The <code>.interpret</code> method is only called once, in the entrypoint of an
application:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def main(args: Array[String]): Unit = program.interpret()
</pre></div>

</figure>

<p>However, there are two big problems with this simple <code>IO</code>:</p>

<ol class="numeric">
  <li>it can stack overflow</li>
  <li>it doesn’t support parallel computations</li>
</ol>

<p>Both of these problems will be overcome in this chapter. However, no matter how
complicated the internal implementation of a <code>Monad</code>, the principles described
here remain true: we’re modularising the definition of a program and its
execution, such that we can capture effects in type signatures, allowing us to
reason about them, and reuse more code.</p>

<aside>
  <p>The Scala compiler will happily allow us to call side-effecting methods from
unsafe code blocks. The <a href="https://scalacenter.github.io/scalafix/">Scalafix</a> linting tool can ban side-effecting methods at
compiletime, unless called from inside a deferred <code>Monad</code> like <code>IO</code>.</p>

</aside>

<h3 id="leanpub-auto-stack-safety">
<a class="anchor-link" href="#leanpub-auto-stack-safety"><i class="fa fa-link"></i></a><span class="section-number">7.3 </span>Stack Safety</h3>

<p>On the JVM, every method call adds an entry to the call stack of the <code>Thread</code>,
like adding to the front of a <code>List</code>. When the method completes, the method at
the <code>head</code> is thrown away. The maximum length of the call stack is determined by
the <code>-Xss</code> flag when starting up <code>java</code>. Tail recursive methods are detected by
the Scala compiler and do not add an entry. If we hit the limit, by calling too
many chained methods, we get a <code>StackOverflowError</code>.</p>

<p>Unfortunately, every nested call to our <code>IO</code>’s <code>.flatMap</code> adds another method
call to the stack. The easiest way to see this is to repeat an action forever,
and see if it survives for longer than a few seconds. We can use <code>.forever</code>,
from <code>Apply</code> (a parent of <code>Monad</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val hello = IO { println("hello") }
  scala&gt; Apply[IO].forever(hello).interpret()
  
  hello
  hello
  hello
  ...
  hello
  java.lang.StackOverflowError
      at java.io.FileOutputStream.write(FileOutputStream.java:326)
      at ...
      at monadio.IO$$anon$1.$anonfun$bind$1(monadio.scala:18)
      at monadio.IO$$anon$1.$anonfun$bind$1(monadio.scala:18)
      at ...
</pre></div>

</figure>

<p>Scalaz has a typeclass that <code>Monad</code> instances can implement if they are stack
safe: <code>BindRec</code> requires a constant stack space for recursive <code>bind</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait BindRec[F[_]] extends Bind[F] {
    def tailrecM[A, B](f: A =&gt; F[A \/ B])(a: A): F[B]
  
    override def forever[A, B](fa: F[A]): F[B] = ...
  }
</pre></div>

</figure>

<p>We don’t need <code>BindRec</code> for all programs, but it is essential for a general
purpose <code>Monad</code> implementation.</p>

<p>The way to achieve stack safety is to convert method calls into references to an
ADT, the <code>Free</code> monad:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Free[S[_], A]
  object Free {
    private final case class Return[S[_], A](a: A)     extends Free[S, A]
    private final case class Suspend[S[_], A](a: S[A]) extends Free[S, A]
    private final case class Gosub[S[_], A0, B](
      a: Free[S, A0],
      f: A0 =&gt; Free[S, B]
    ) extends Free[S, B] { type A = A0 }
    ...
  }
</pre></div>

</figure>

<aside>
  <p><code>SUSPEND</code>, <code>RETURN</code> and <code>GOSUB</code> are a tip of the hat to the <code>BASIC</code> commands of
the same name: pausing, completing, and continuing a subroutine, respectively.</p>

</aside>

<p>The <code>Free</code> ADT is a natural data type representation of the <code>Monad</code> interface:</p>

<ol class="numeric">
  <li>
<code>Return</code> represents <code>.point</code>
</li>
  <li>
<code>Gosub</code> represents <code>.bind</code> / <code>.flatMap</code>
</li>
</ol>

<p>When an ADT mirrors the arguments of related functions, it is called a <em>Church
encoding</em>.</p>

<p><code>Free</code> is named because it can be <em>generated for free</em> for any <code>S[_]</code>. For
example, we could set <code>S</code> to be the <code>Drone</code> or <code>Machines</code> algebras from Chapter
3 and generate a data structure representation of our program. We will return to
why this is useful at the end of this chapter.</p>

<h4 id="leanpub-auto-trampoline">
<a class="anchor-link" href="#leanpub-auto-trampoline"><i class="fa fa-link"></i></a><span class="section-number">7.3.1 </span><code>Trampoline</code>
</h4>

<p><code>Free</code> is more general than we need for now. Setting the algebra <code>S[_]</code> to <code>()
=&gt; ?</code>, a deferred calculation or <em>thunk</em>, we get <code>Trampoline</code> and can implement
a stack safe <code>Monad</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Free {
    type Trampoline[A] = Free[() =&gt; ?, A]
    implicit val trampoline: Monad[Trampoline] with BindRec[Trampoline] =
      new Monad[Trampoline] with BindRec[Trampoline] {
        def point[A](a: =&gt;A): Trampoline[A] = Return(a)
        def bind[A, B](fa: Trampoline[A])(f: A =&gt; Trampoline[B]): Trampoline[B] =
          Gosub(fa, f)
  
        def tailrecM[A, B](f: A =&gt; Trampoline[A \/ B])(a: A): Trampoline[B] =
          bind(f(a)) {
            case -\/(a) =&gt; tailrecM(f)(a)
            case \/-(b) =&gt; point(b)
          }
      }
    ...
  }
</pre></div>

</figure>

<p>The <code>BindRec</code> implementation, <code>.tailrecM</code>, runs <code>.bind</code> until we get a <code>B</code>.
Although this is not technically a <code>@tailrec</code> implementation, it uses constant
stack space because each call returns a heap object, with delayed recursion.</p>

<aside>
  <p>Called <code>Trampoline</code> because every time we <code>.bind</code> on the stack, we <em>bounce</em> back
to the heap.</p>

  <p>The only Star Wars reference involving bouncing is Yoda’s duel with Dooku. We
shall not speak of this again.</p>

</aside>

<p>Convenient functions are provided to create a <code>Trampoline</code> eagerly (<code>.done</code>) or
by-name (<code>.delay</code>). We can also create a <code>Trampoline</code> from a by-name
<code>Trampoline</code> (<code>.suspend</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Trampoline {
    def done[A](a: A): Trampoline[A]                  = Return(a)
    def delay[A](a: =&gt;A): Trampoline[A]               = suspend(done(a))
    def suspend[A](a: =&gt;Trampoline[A]): Trampoline[A] = unit &gt;&gt; a
  
    private val unit: Trampoline[Unit] = Suspend(() =&gt; done(()))
  }
</pre></div>

</figure>

<p>When we see <code>Trampoline[A]</code> in a codebase we can always mentally substitute it
with <code>A</code>, because it is simply adding stack safety to the pure computation. We
get the <code>A</code> by interpreting <code>Free</code>, provided by <code>.run</code>.</p>

<aside>
  <p>It is instructive, although not necessary, to understand how <code>Free.run</code> is
implemented: <code>.resume</code> evaluates a single layer of the <code>Free</code>, and <code>go</code> runs it
to completion.</p>

  <p>In the following <code>Trampoline[A]</code> is used as a synonym for <code>Free[() =&gt; ?, A]</code> to
make the code easier to read.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Trampoline[A] {
    def run: A = go(f =&gt; f())
  
    def go(f: () =&gt; Trampoline[A] =&gt; Trampoline[A]): A = {
      @tailrec def go2(t: Trampoline[A]): A = t.resume match {
        case -\/(s) =&gt; go2(f(s))
        case \/-(r) =&gt; r
      }
      go2(this)
    }
  
    @tailrec def resume: () =&gt; Trampoline[A] \/ A = this match {
      case Return(a) =&gt; \/-(a)
      case Suspend(t) =&gt; -\/(t.map(Return(_)))
      case Gosub(Return(a), f) =&gt; f(a).resume
      case Gosub(Suspend(t), f) =&gt; -\/(t.map(f))
      case Gosub(Gosub(a, g), f) =&gt; a &gt;&gt;= (z =&gt; g(z) &gt;&gt;= f).resume
    }
    ...
  }
</pre></div>

  </figure>

  <p>The case that is most likely to cause confusion is when we have nested <code>Gosub</code>:
apply the inner function <code>g</code> then pass it to the outer one <code>f</code>, it is just
function composition.</p>

</aside>

<h4 id="leanpub-auto-example-stack-safe-dlist">
<a class="anchor-link" href="#leanpub-auto-example-stack-safe-dlist"><i class="fa fa-link"></i></a><span class="section-number">7.3.2 </span>Example: Stack Safe <code>DList</code>
</h4>

<p>In the previous chapter we described the data type <code>DList</code> as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class DList[A](f: IList[A] =&gt; IList[A]) {
    def toIList: IList[A] = f(IList.empty)
    def ++(as: DList[A]): DList[A] = DList(xs =&gt; f(as.f(xs)))
    ...
  }
</pre></div>

</figure>

<p>However, the actual implementation looks more like:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class DList[A](f: IList[A] =&gt; Trampoline[IList[A]]) {
    def toIList: IList[A] = f(IList.empty).run
    def ++(as: =&gt;DList[A]): DList[A] = DList(xs =&gt; suspend(as.f(xs) &gt;&gt;= f))
    ...
  }
</pre></div>

</figure>

<p>Instead of applying nested calls to <code>f</code> we use a suspended <code>Trampoline</code>. We
interpret the trampoline with <code>.run</code> only when needed, e.g. in <code>toIList</code>. The
changes are minimal, but we now have a stack safe <code>DList</code> that can rearrange the
concatenation of a large number lists without blowing the stack!</p>

<h4 id="leanpub-auto-stack-safe-io">
<a class="anchor-link" href="#leanpub-auto-stack-safe-io"><i class="fa fa-link"></i></a><span class="section-number">7.3.3 </span>Stack Safe <code>IO</code>
</h4>

<p>Similarly, our <code>IO</code> can be made stack safe thanks to <code>Trampoline</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class IO[A](val tramp: Trampoline[A]) {
    def unsafePerformIO(): A = tramp.run
  }
  object IO {
    def apply[A](a: =&gt;A): IO[A] = new IO(Trampoline.delay(a))
  
    implicit val Monad: Monad[IO] with BindRec[IO] =
      new Monad[IO] with BindRec[IO] {
        def point[A](a: =&gt;A): IO[A] = IO(a)
        def bind[A, B](fa: IO[A])(f: A =&gt; IO[B]): IO[B] =
          new IO(fa.tramp &gt;&gt;= (a =&gt; f(a).tramp))
        def tailrecM[A, B](f: A =&gt; IO[A \/ B])(a: A): IO[B] = ...
      }
  }
</pre></div>

</figure>

<aside>
  <p>We heard you like <code>Monad</code>, so we made you a <code>Monad</code> out of a <code>Monad</code>, so you can
monadically bind when you are monadically binding.</p>

</aside>

<p>The interpreter, <code>.unsafePerformIO()</code>, has an intentionally scary name to
discourage using it except in the entrypoint of the application.</p>

<p>This time, we don’t get a stack overflow error:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val hello = IO { println("hello") }
  scala&gt; Apply[IO].forever(hello).unsafePerformIO()
  
  hello
  hello
  hello
  ...
  hello
</pre></div>

</figure>

<p>Using a <code>Trampoline</code> typically introduces a performance regression vs a regular
reference. It is <code>Free</code> in the sense of <em>freely generated</em>, not <em>free as in
beer</em>.</p>

<aside>
  <p>Always benchmark instead of accepting sweeping statements about performance: it
may well be the case that the garbage collector performs better for an
application when using <code>Free</code> because of the reduced size of retained objects in
the stack.</p>

</aside>

<h3 id="leanpub-auto-monad-transformer-library">
<a class="anchor-link" href="#leanpub-auto-monad-transformer-library"><i class="fa fa-link"></i></a><span class="section-number">7.4 </span>Monad Transformer Library</h3>

<p>Monad transformers are data structures that wrap an underlying value and provide
a monadic <em>effect</em>.</p>

<p>For example, in Chapter 2 we used <code>OptionT</code> to let us use <code>F[Option[A]]</code> in a
<code>for</code> comprehension as if it was just a <code>F[A]</code>. This gave our program the effect
of an <em>optional</em> value. Alternatively, we can get the effect of optionality if
we have a <code>MonadPlus</code>.</p>

<p>This subset of data types and extensions to <code>Monad</code> are often referred to as the
<em>Monad Transformer Library</em> (MTL), summarised below. In this section, we will
explain each of the transformers, why they are useful, and how they work.</p>

<table>
  <thead>
    <tr>
      <th>Effect</th>
      <th>Underlying</th>
      <th>Transformer</th>
      <th>Typeclass</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>optionality</td>
      <td><code>F[Maybe[A]]</code></td>
      <td><code>MaybeT</code></td>
      <td><code>MonadPlus</code></td>
    </tr>
    <tr>
      <td>errors</td>
      <td><code>F[E \/ A]</code></td>
      <td><code>EitherT</code></td>
      <td><code>MonadError</code></td>
    </tr>
    <tr>
      <td>a runtime value</td>
      <td><code>A =&gt; F[B]</code></td>
      <td><code>ReaderT</code></td>
      <td><code>MonadReader</code></td>
    </tr>
    <tr>
      <td>journal / multitask</td>
      <td><code>F[(W, A)]</code></td>
      <td><code>WriterT</code></td>
      <td><code>MonadTell</code></td>
    </tr>
    <tr>
      <td>evolving state</td>
      <td><code>S =&gt; F[(S, A)]</code></td>
      <td><code>StateT</code></td>
      <td><code>MonadState</code></td>
    </tr>
    <tr>
      <td>keep calm &amp; carry on</td>
      <td><code>F[E \&amp;/ A]</code></td>
      <td><code>TheseT</code></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>control flow</td>
      <td><code>(A =&gt; F[B]) =&gt; F[B]</code></td>
      <td><code>ContT</code></td>
      <td>&nbsp;</td>
    </tr>
  </tbody>

</table>

<h4 id="leanpub-auto-monadtrans">
<a class="anchor-link" href="#leanpub-auto-monadtrans"><i class="fa fa-link"></i></a><span class="section-number">7.4.1 </span><code>MonadTrans</code>
</h4>

<p>Each transformer has the general shape <code>T[F[_], A]</code>, providing at least an
instance of <code>Monad</code> and <code>Hoist</code> (and therefore <code>MonadTrans</code>):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadTrans[T[_[_], _]] {
    def liftM[F[_]: Monad, A](a: F[A]): T[F, A]
  }
  
  @typeclass trait Hoist[F[_[_], _]] extends MonadTrans[F] {
    def hoist[M[_]: Monad, N[_]](f: M ~&gt; N): F[M, ?] ~&gt; F[N, ?]
  }
</pre></div>

</figure>

<aside>
  <p><code>T[_[_], _]</code> is another example of a higher kinded type. It says that <code>T</code> takes
two type parameters: the first also takes a type parameter, written <code>_[_]</code>, and
the second does not take any type parameters, written <code>_</code>.</p>

</aside>

<p><code>.liftM</code> lets us create a monad transformer if we have an <code>F[A]</code>. For example,
we can create an <code>OptionT[IO, String]</code> by calling <code>.liftM[OptionT]</code> on an
<code>IO[String]</code>.</p>

<p><code>.hoist</code> is the same idea, but for natural transformations.</p>

<p>Generally, there are three ways to create a monad transformer:</p>

<ul>
  <li>from the underlying, using the transformer’s constructor</li>
  <li>from a single value <code>A</code>, using <code>.pure</code> from the <code>Monad</code> syntax</li>
  <li>from an <code>F[A]</code>, using <code>.liftM</code> from the <code>MonadTrans</code> syntax</li>
</ul>

<p>Due to the way that type inference works in Scala, this often means that a
complex type parameter must be explicitly written. As a workaround, transformers
provide convenient constructors on their companion that are easier to use.</p>

<h4 id="leanpub-auto-maybet">
<a class="anchor-link" href="#leanpub-auto-maybet"><i class="fa fa-link"></i></a><span class="section-number">7.4.2 </span><code>MaybeT</code>
</h4>

<p><code>OptionT</code>, <code>MaybeT</code> and <code>LazyOptionT</code> have similar implementations, providing
optionality through <code>Option</code>, <code>Maybe</code> and <code>LazyOption</code>, respectively. We will
focus on <code>MaybeT</code> to avoid repetition.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class MaybeT[F[_], A](run: F[Maybe[A]])
  object MaybeT {
    def just[F[_]: Applicative, A](v: =&gt;A): MaybeT[F, A] =
      MaybeT(Maybe.just(v).pure[F])
    def empty[F[_]: Applicative, A]: MaybeT[F, A] =
      MaybeT(Maybe.empty.pure[F])
    ...
  }
</pre></div>

</figure>

<p>providing a <code>MonadPlus</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def monad[F[_]: Monad] = new MonadPlus[MaybeT[F, ?]] {
    def point[A](a: =&gt;A): MaybeT[F, A] = MaybeT.just(a)
    def bind[A, B](fa: MaybeT[F, A])(f: A =&gt; MaybeT[F, B]): MaybeT[F, B] =
      MaybeT(fa.run &gt;&gt;= (_.cata(f(_).run, Maybe.empty.pure[F])))
  
    def empty[A]: MaybeT[F, A] = MaybeT.empty
    def plus[A](a: MaybeT[F, A], b: =&gt;MaybeT[F, A]): MaybeT[F, A] = a orElse b
  }
</pre></div>

</figure>

<p>This monad looks fiddly, but it is just delegating everything to the <code>Monad[F]</code>
and then re-wrapping with a <code>MaybeT</code>. It is plumbing.</p>

<p>With this monad we can write logic that handles optionality in the <code>F[_]</code>
context, rather than carrying around <code>Option</code> or <code>Maybe</code>.</p>

<p>For example, say we are interfacing with a social media website to count the
number of stars a user has, and we start with a <code>String</code> that may or may not
correspond to a user. We have this algebra:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Twitter[F[_]] {
    def getUser(name: String): F[Maybe[User]]
    def getStars(user: User): F[Int]
  }
  def T[F[_]](implicit t: Twitter[F]): Twitter[F] = t
</pre></div>

</figure>

<p>We need to call <code>getUser</code> followed by <code>getStars</code>. If we use <code>Monad</code> as our
context, our function is difficult because we have to handle the <code>Empty</code> case:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def stars[F[_]: Monad: Twitter](name: String): F[Maybe[Int]] = for {
    maybeUser  &lt;- T.getUser(name)
    maybeStars &lt;- maybeUser.traverse(T.getStars)
  } yield maybeStars
</pre></div>

</figure>

<p>However, if we have a <code>MonadPlus</code> as our context, we can suck <code>Maybe</code> into the
<code>F[_]</code> with <code>.orEmpty</code>, and forget about it:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def stars[F[_]: MonadPlus: Twitter](name: String): F[Int] = for {
    user  &lt;- T.getUser(name) &gt;&gt;= (_.orEmpty[F])
    stars &lt;- T.getStars(user)
  } yield stars
</pre></div>

</figure>

<p>However adding a <code>MonadPlus</code> requirement can cause problems downstream if the
context does not have one. The solution is to either change the context of the
program to <code>MaybeT[F, ?]</code> (lifting the <code>Monad[F]</code> into a <code>MonadPlus</code>), or to
explicitly use <code>MaybeT</code> in the return type, at the cost of slightly more code:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def stars[F[_]: Monad: Twitter](name: String): MaybeT[F, Int] = for {
    user  &lt;- MaybeT(T.getUser(name))
    stars &lt;- T.getStars(user).liftM[MaybeT]
  } yield stars
</pre></div>

</figure>

<p>The decision to require a more powerful <code>Monad</code> vs returning a transformer is
something that each team can decide for themselves based on the interpreters
that they plan on using for their program.</p>

<h4 id="leanpub-auto-eithert">
<a class="anchor-link" href="#leanpub-auto-eithert"><i class="fa fa-link"></i></a><span class="section-number">7.4.3 </span><code>EitherT</code>
</h4>

<p>An optional value is a special case of a value that may be an error, but we
don’t know anything about the error. <code>EitherT</code> (and the lazy variant
<code>LazyEitherT</code>) allows us to use any type we want as the error value, providing
contextual information about what went wrong.</p>

<p><code>EitherT</code> is a wrapper around an <code>F[A \/ B]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class EitherT[F[_], A, B](run: F[A \/ B])
  object EitherT {
    def either[F[_]: Applicative, A, B](d: A \/ B): EitherT[F, A, B] = ...
    def leftT[F[_]: Functor, A, B](fa: F[A]): EitherT[F, A, B] = ...
    def rightT[F[_]: Functor, A, B](fb: F[B]): EitherT[F, A, B] = ...
    def pureLeft[F[_]: Applicative, A, B](a: A): EitherT[F, A, B] = ...
    def pure[F[_]: Applicative, A, B](b: B): EitherT[F, A, B] = ...
    ...
  }
</pre></div>

</figure>

<p>The <code>Monad</code> is a <code>MonadError</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadError[F[_], E] extends Monad[F] {
    def raiseError[A](e: E): F[A]
    def handleError[A](fa: F[A])(f: E =&gt; F[A]): F[A]
  }
</pre></div>

</figure>

<p><code>.raiseError</code> and <code>.handleError</code> are self-descriptive: the equivalent of <code>throw</code>
and <code>catch</code> an exception, respectively.</p>

<p><code>MonadError</code> has some addition syntax for dealing with common problems:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit final class MonadErrorOps[F[_], E, A](self: F[A])(implicit val F: MonadError[F, E])\
 {
    def attempt: F[E \/ A] = ...
    def recover(f: E =&gt; A): F[A] = ...
    def emap[B](f: A =&gt; E \/ B): F[B] = ...
  }
</pre></div>

</figure>

<p><code>.attempt</code> brings errors into the value, which is useful for exposing errors in
subsystems as first class values.</p>

<p><code>.recover</code> is for turning an error into a value for all cases, as opposed to
<code>.handleError</code> which takes an <code>F[A]</code> and therefore allows partial recovery.</p>

<p><code>.emap</code>, <em>either</em> map, is to apply transformations that can fail.</p>

<p>The <code>MonadError</code> for <code>EitherT</code> is:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def monad[F[_]: Monad, E] = new MonadError[EitherT[F, E, ?], E] {
    def monad[F[_]: Monad, E] = new MonadError[EitherT[F, E, ?], E] {
    def bind[A, B](fa: EitherT[F, E, A])
                  (f: A =&gt; EitherT[F, E, B]): EitherT[F, E, B] =
      EitherT(fa.run &gt;&gt;= (_.fold(_.left[B].pure[F], b =&gt; f(b).run)))
    def point[A](a: =&gt;A): EitherT[F, E, A] = EitherT.pure(a)
  
    def raiseError[A](e: E): EitherT[F, E, A] = EitherT.pureLeft(e)
    def handleError[A](fa: EitherT[F, E, A])
                      (f: E =&gt; EitherT[F, E, A]): EitherT[F, E, A] =
      EitherT(fa.run &gt;&gt;= {
        case -\/(e) =&gt; f(e).run
        case right =&gt; right.pure[F]
      })
  }
</pre></div>

</figure>

<p>It should be of no surprise that we can rewrite the <code>MonadPlus</code> example with
<code>MonadError</code>, inserting informative error messages:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def stars[F[_]: Twitter](name: String)
                          (implicit F: MonadError[F, String]): F[Int] = for {
    user  &lt;- T.getUser(name) &gt;&gt;= (_.orError(s"user '$name' not found")(F))
    stars &lt;- T.getStars(user)
  } yield stars
</pre></div>

</figure>

<p>where <code>.orError</code> is a convenience method on <code>Maybe</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Maybe[A] {
    ...
    def orError[F[_], E](e: E)(implicit F: MonadError[F, E]): F[A] =
      cata(F.point(_), F.raiseError(e))
  }
</pre></div>

</figure>

<aside>
  <p>It is common to use <code>implicit</code> parameter blocks instead of context bounds when
the signature of the typeclass has more than one parameter.</p>

  <p>It is also common practice to name the implicit parameter after the primary
type, in this case <code>F</code>.</p>

</aside>

<p>The version using <code>EitherT</code> directly looks like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def stars[F[_]: Monad: Twitter](name: String): EitherT[F, String, Int] = for {
    user &lt;- EitherT(T.getUser(name).map(_ \/&gt; s"user '$name' not found"))
    stars &lt;- EitherT.rightT(T.getStars(user))
  } yield stars
</pre></div>

</figure>

<p>The simplest instance of <code>MonadError</code> is for <code>\/</code>, perfect for testing business
logic that requires a <code>MonadError</code>. For example,</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class MockTwitter extends Twitter[String \/ ?] {
    def getUser(name: String): String \/ Maybe[User] =
      if (name.contains(" ")) Maybe.empty.right
      else if (name === "wobble") "connection error".left
      else User(name).just.right
  
    def getStars(user: User): String \/ Int =
      if (user.name.startsWith("w")) 10.right
      else "stars have been replaced by hearts".left
  }
</pre></div>

</figure>

<p>Our unit tests for <code>.stars</code> might cover these cases:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; stars("wibble")
  \/-(10)
  
  scala&gt; stars("wobble")
  -\/(connection error)
  
  scala&gt; stars("i'm a fish")
  -\/(user 'i'm a fish' not found)
  
  scala&gt; stars("fommil")
  -\/(stars have been replaced by hearts)
</pre></div>

</figure>

<p>As we’ve now seen several times, we can focus on testing the pure business logic
without distraction.</p>

<p>Finally, if we return to our <code>JsonClient</code> algebra from Chapter 4.3</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait JsonClient[F[_]] {
    def get[A: JsDecoder](
      uri: String Refined Url,
      headers: IList[(String, String)]
    ): F[A]
    ...
  }
</pre></div>

</figure>

<p>recall that we only coded the happy path into the API. If our interpreter for
this algebra only works for an <code>F</code> having a <code>MonadError</code> we get to define the
kinds of errors as a tangential concern. Indeed, we can have <strong>two</strong> layers of
error if we define the interpreter for a <code>EitherT[IO, JsonClient.Error, ?]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsonClient {
    sealed abstract class Error
    final case class ServerError(status: Int)       extends Error
    final case class DecodingError(message: String) extends Error
  }
</pre></div>

</figure>

<p>which cover I/O (network) problems, server status problems, and issues with our
modelling of the server’s JSON payloads.</p>

<h5 id="leanpub-auto-choosing-an-error-type">
<a class="anchor-link" href="#leanpub-auto-choosing-an-error-type"><i class="fa fa-link"></i></a><span class="section-number">7.4.3.1 </span>Choosing an error type</h5>

<p>The community is undecided on the best strategy for the error type <code>E</code> in
<code>MonadError</code>.</p>

<p>One school of thought says that we should pick something general, like a
<code>String</code>. The other school says that an application should have an ADT of
errors, allowing different errors to be reported or handled differently. An
unprincipled gang prefers using <code>Throwable</code> for maximum JVM compatibility.</p>

<p>There are two problems with an ADT of errors on the application level:</p>

<ul>
  <li>it is very awkward to create a new error. One file becomes a monolithic
repository of errors, aggregating the ADTs of individual subsystems.</li>
  <li>no matter how granular the errors are, the resolution is often the same: log
it and try it again, or give up. We don’t need an ADT for this.</li>
</ul>

<p>An error ADT is of value if every entry allows a different kind of recovery to
be performed.</p>

<p>A compromise between an error ADT and a <code>String</code> is an intermediary format. JSON
is a good choice as it can be understood by most logging and monitoring
frameworks.</p>

<p>A problem with not having a stacktrace is that it can be hard to localise which
piece of code was the source of an error. With <a href="https://github.com/lihaoyi/sourcecode/"><code>sourcecode</code> by Li Haoyi</a>, we can
include contextual information as metadata in our errors:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Meta(fqn: String, file: String, line: Int)
  object Meta {
    implicit def gen(implicit fqn: sourcecode.FullName,
                              file: sourcecode.File,
                              line: sourcecode.Line): Meta =
      new Meta(fqn.value, file.value, line.value)
  }
  
  final case class Err(msg: String)(implicit val meta: Meta)
</pre></div>

</figure>

<p>Although <code>Err</code> is referentially transparent, the implicit construction of a
<code>Meta</code> does <strong>not</strong> appear to be referentially transparent from a natural reading:
two calls to <code>Meta.gen</code> (invoked implicitly when creating an <code>Err</code>) will produce
different values because the location in the source code impacts the returned
value:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; println(Err("hello world").meta)
  Meta(com.acme,&lt;console&gt;,10)
  
  scala&gt; println(Err("hello world").meta)
  Meta(com.acme,&lt;console&gt;,11)
</pre></div>

</figure>

<p>To understand this, we have to appreciate that <code>sourcecode.*</code> methods are macros
that are generating source code for us. If we were to write the above explicitly
it is clear what is happening:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; println(Err("hello world")(Meta("com.acme", "&lt;console&gt;", 10)).meta)
  Meta(com.acme,&lt;console&gt;,10)
  
  scala&gt; println(Err("hello world")(Meta("com.acme", "&lt;console&gt;", 11)).meta)
  Meta(com.acme,&lt;console&gt;,11)
</pre></div>

</figure>

<p>Yes, we’ve made a deal with the macro devil, but we could also write the <code>Meta</code>
manually and have it go out of date quicker than our documentation.</p>

<h4 id="leanpub-auto-readert">
<a class="anchor-link" href="#leanpub-auto-readert"><i class="fa fa-link"></i></a><span class="section-number">7.4.4 </span><code>ReaderT</code>
</h4>

<p>The reader monad wraps <code>A =&gt; F[B]</code> allowing a program <code>F[B]</code> to depend on a
runtime value <code>A</code>. For those familiar with dependency injection, the reader
monad is the FP equivalent of Spring or Guice’s <code>@Inject</code>, without the XML and
reflection.</p>

<p><code>ReaderT</code> is just an alias to another more generally useful data type named
after the mathematician <em>Heinrich Kleisli</em>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type ReaderT[F[_], A, B] = Kleisli[F, A, B]
  
  final case class Kleisli[F[_], A, B](run: A =&gt; F[B]) {
    def dimap[C, D](f: C =&gt; A, g: B =&gt; D)(implicit F: Functor[F]): Kleisli[F, C, D] =
      Kleisli(c =&gt; run(f(c)).map(g))
  
    def &gt;=&gt;[C](k: Kleisli[F, B, C])(implicit F: Bind[F]): Kleisli[F, A, C] = ...
    def &gt;==&gt;[C](k: B =&gt; F[C])(implicit F: Bind[F]): Kleisli[F, A, C] = this &gt;=&gt; Kleisli(k)
    ...
  }
  object Kleisli {
    implicit def kleisliFn[F[_], A, B](k: Kleisli[F, A, B]): A =&gt; F[B] = k.run
    ...
  }
</pre></div>

</figure>

<aside>
  <p>Some people call <code>&gt;=&gt;</code> the <em>fish operator</em>. There’s always a bigger fish, hence
<code>&gt;==&gt;</code>. They are also called <em>Kleisli arrows</em>.</p>

</aside>

<p>An <code>implicit</code> conversion on the companion allows us to use a <code>Kleisli</code> in place
of a function, so we can provide it as the parameter to a monad’s <code>.bind</code>, or
<code>&gt;&gt;=</code>.</p>

<p>The most common use for <code>ReaderT</code> is to provide environment information to a
program. In <code>drone-dynamic-agents</code> we need access to the user’s Oauth 2.0
Refresh Token to be able to contact Google. The obvious thing is to load the
<code>RefreshTokens</code> from disk on startup, and make every method take a
<code>RefreshToken</code> parameter. In fact, this is such a common requirement that Martin
Odersky has proposed <a href="https://www.scala-lang.org/blog/2016/12/07/implicit-function-types.html">implicit functions</a>.</p>

<p>A better solution is for our program to have an algebra that provides the
configuration when needed, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait ConfigReader[F[_]] {
    def token: F[RefreshToken]
  }
</pre></div>

</figure>

<p>We have reinvented <code>MonadReader</code>, the typeclass associated to <code>ReaderT</code>, where
<code>.ask</code> is the same as our <code>.token</code>, and <code>S</code> is <code>RefreshToken</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadReader[F[_], S] extends Monad[F] {
    def ask: F[S]
  
    def local[A](f: S =&gt; S)(fa: F[A]): F[A]
  }
</pre></div>

</figure>

<p>with the implementation</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def monad[F[_]: Monad, R] = new MonadReader[Kleisli[F, R, ?], R] {
    def point[A](a: =&gt;A): Kleisli[F, R, A] = Kleisli(_ =&gt; F.point(a))
    def bind[A, B](fa: Kleisli[F, R, A])(f: A =&gt; Kleisli[F, R, B]) =
      Kleisli(a =&gt; Monad[F].bind(fa.run(a))(f))
  
    def ask: Kleisli[F, R, R] = Kleisli(_.pure[F])
    def local[A](f: R =&gt; R)(fa: Kleisli[F, R, A]): Kleisli[F, R, A] =
      Kleisli(f andThen fa.run)
  }
</pre></div>

</figure>

<p>A law of <code>MonadReader</code> is that the <code>S</code> cannot change between invocations, i.e.
<code>ask &gt;&gt; ask === ask</code>. For our usecase, this is to say that the configuration is
read once. If we decide later that we want to reload configuration every time we
need it, e.g. allowing us to change the token without restarting the
application, we can reintroduce <code>ConfigReader</code> which has no such law.</p>

<p>In our OAuth 2.0 implementation we could first move the <code>Monad</code> evidence onto the
methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def bearer(refresh: RefreshToken)(implicit F: Monad[F]): F[BearerToken] =
    for { ...
</pre></div>

</figure>

<p>and then refactor the <code>refresh</code> parameter to be part of the <code>Monad</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def bearer(implicit F: MonadReader[F, RefreshToken]): F[BearerToken] =
    for {
      refresh &lt;- F.ask
</pre></div>

</figure>

<p>Any parameter can be moved into the <code>MonadReader</code>. This is of most value to
immediate callers when they simply want to thread through this information from
above. With <code>ReaderT</code>, we can reserve <code>implicit</code> parameter blocks entirely for
the use of typeclasses, reducing the mental burden of using Scala.</p>

<p>The other method in <code>MonadReader</code> is <code>.local</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def local[A](f: S =&gt; S)(fa: F[A]): F[A]
</pre></div>

</figure>

<p>We can change <code>S</code> and run a program <code>fa</code> within that local context, returning to
the original <code>S</code>. A use case for <code>.local</code> is to generate a “stack trace” that
makes sense to our domain. giving us nested logging! Leaning on the <code>Meta</code> data
structure from the previous section, we define a function to checkpoint:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def traced[A](fa: F[A])(implicit F: MonadReader[F, IList[Meta]]): F[A] =
    F.local(Meta.gen :: _)(fa)
</pre></div>

</figure>

<p>and we can use it to wrap functions that operate in this context.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo: F[Foo] = traced(getBar) &gt;&gt;= barToFoo
</pre></div>

</figure>

<p>automatically passing through anything that is not explicitly traced. A compiler
plugin or macro could do the opposite, opting everything in by default.</p>

<p>If we access <code>.ask</code> we can see the breadcrumb trail of exactly how we were
called, without the distraction of bytecode implementation details. A
referentially transparent stacktrace!</p>

<p>A defensive programmer may wish to truncate the <code>IList[Meta]</code> at a certain
length to avoid the equivalent of a stack overflow. Indeed, a more appropriate
data structure is <code>Dequeue</code>.</p>

<p><code>.local</code> can also be used to keep track of contextual information that is
directly relevant to the task at hand, like the number of spaces that must
indent a line when pretty printing a human readable file format, bumping it by
two spaces when we enter a nested structure.</p>

<aside>
  <p>Not four spaces. Not eight spaces. Not a TAB.</p>

  <p>Two spaces. Exactly two spaces. This is a magic number we can hardcode, because
every other number is <strong>wrong</strong>.</p>

</aside>

<p>Finally, if we cannot request a <code>MonadReader</code> because our application does not
provide one, we can always return a <code>ReaderT</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def bearer(implicit F: Monad[F]): ReaderT[F, RefreshToken, BearerToken] =
    ReaderT( token =&gt; for {
    ...
</pre></div>

</figure>

<p>If a caller receives a <code>ReaderT</code>, and they have the <code>token</code> parameter to hand,
they can call <code>access.run(token)</code> and get back an <code>F[BearerToken]</code>.</p>

<p>Admittedly, since we don’t have many callers, we should just revert to a regular
function parameter. <code>MonadReader</code> is of most use when:</p>

<ol class="numeric">
  <li>we may wish to refactor the code later to reload config</li>
  <li>the value is not needed by intermediate callers</li>
  <li>or, we want to locally scope some variable</li>
</ol>

<p>Dotty can keep its implicit functions… we already have <code>ReaderT</code> and
<code>MonadReader</code>.</p>

<h4 id="leanpub-auto-writert">
<a class="anchor-link" href="#leanpub-auto-writert"><i class="fa fa-link"></i></a><span class="section-number">7.4.5 </span><code>WriterT</code>
</h4>

<p>The opposite to reading is writing. The <code>WriterT</code> monad transformer is typically
for writing to a journal.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class WriterT[F[_], W, A](run: F[(W, A)])
  object WriterT {
    def put[F[_]: Functor, W, A](value: F[A])(w: W): WriterT[F, W, A] = ...
    def putWith[F[_]: Functor, W, A](value: F[A])(w: A =&gt; W): WriterT[F, W, A] = ...
    ...
  }
</pre></div>

</figure>

<p>The wrapped type is <code>F[(W, A)]</code> with the journal accumulated in <code>W</code>.</p>

<p>There is not just one associated monad, but two! <code>MonadTell</code> and <code>MonadListen</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadTell[F[_], W] extends Monad[F] {
    def writer[A](w: W, v: A): F[A]
    def tell(w: W): F[Unit] = ...
  
    def :++&gt;[A](fa: F[A])(w: =&gt;W): F[A] = ...
    def :++&gt;&gt;[A](fa: F[A])(f: A =&gt; W): F[A] = ...
  }
  
  @typeclass trait MonadListen[F[_], W] extends MonadTell[F, W] {
    def listen[A](fa: F[A]): F[(A, W)]
  
    def written[A](fa: F[A]): F[W] = ...
  }
</pre></div>

</figure>

<p><code>MonadTell</code> is for writing to the journal and <code>MonadListen</code> is to recover it.
The <code>WriterT</code> implementation is</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def monad[F[_]: Monad, W: Monoid] = new MonadListen[WriterT[F, W, ?], W] {
    def point[A](a: =&gt;A) = WriterT((Monoid[W].zero, a).point)
    def bind[A, B](fa: WriterT[F, W, A])(f: A =&gt; WriterT[F, W, B]) = WriterT(
      fa.run &gt;&gt;= { case (wa, a) =&gt; f(a).run.map { case (wb, b) =&gt; (wa |+| wb, b) } })
  
    def writer[A](w: W, v: A) = WriterT((w -&gt; v).point)
    def listen[A](fa: WriterT[F, W, A]) = WriterT(
      fa.run.map { case (w, a) =&gt; (w, (a, w)) })
  }
</pre></div>

</figure>

<p>The most obvious example is to use <code>MonadTell</code> for logging, or audit reporting.
Reusing <code>Meta</code> from our error reporting we could imagine creating a log
structure like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait Log
  final case class Debug(msg: String)(implicit m: Meta)   extends Log
  final case class Info(msg: String)(implicit m: Meta)    extends Log
  final case class Warning(msg: String)(implicit m: Meta) extends Log
</pre></div>

</figure>

<p>and use <code>Dequeue[Log]</code> as our journal type. We could change our OAuth2
<code>authenticate</code> method to</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def debug(msg: String)(implicit m: Meta): Dequeue[Log] = Dequeue(Debug(msg))
  
  def authenticate: F[CodeToken] =
    for {
      callback &lt;- user.start :++&gt; debug("started the webserver")
      params   = AuthRequest(callback, config.scope, config.clientId)
      url      = config.auth.withQuery(params.toUrlQuery)
      _        &lt;- user.open(url) :++&gt; debug(s"user visiting $url")
      code     &lt;- user.stop :++&gt; debug("stopped the webserver")
    } yield code
</pre></div>

</figure>

<p>We could even combine this with the <code>ReaderT</code> traces and get structured logs.</p>

<p>The caller can recover the logs with <code>.written</code> and do something with them.</p>

<p>However, there is a strong argument that logging deserves its own algebra. The
log level is often needed at the point of creation for performance reasons and
writing out the logs is typically managed at the application level rather than
something each component needs to be concerned about.</p>

<p>The <code>W</code> in <code>WriterT</code> has a <code>Monoid</code>, allowing us to journal any kind of
<em>monoidic</em> calculation as a secondary value along with our primary program. For
example, counting the number of times we do something, building up an
explanation of a calculation, or building up a <code>TradeTemplate</code> for a new trade
while we price it.</p>

<p>A popular specialisation of <code>WriterT</code> is when the monad is <code>Id</code>, meaning the
underlying <code>run</code> value is just a simple tuple <code>(W, A)</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Writer[W, A] = WriterT[Id, W, A]
  object WriterT {
    def writer[W, A](v: (W, A)): Writer[W, A] = WriterT[Id, W, A](v)
    def tell[W](w: W): Writer[W, Unit] = WriterT((w, ()))
    ...
  }
  final implicit class WriterOps[A](self: A) {
    def set[W](w: W): Writer[W, A] = WriterT(w -&gt; self)
    def tell: Writer[A, Unit] = WriterT.tell(self)
  }
</pre></div>

</figure>

<p>which allows us to let any value carry around a secondary monoidal calculation,
without needing a context <code>F[_]</code>.</p>

<p>In a nutshell, <code>WriterT</code> / <code>MonadTell</code> is how to multi-task in FP.</p>

<h4 id="leanpub-auto-statet">
<a class="anchor-link" href="#leanpub-auto-statet"><i class="fa fa-link"></i></a><span class="section-number">7.4.6 </span><code>StateT</code>
</h4>

<p><code>StateT</code> lets us <code>.put</code>, <code>.get</code> and <code>.modify</code> a value that is handled by the
monadic context. It is the FP replacement of <code>var</code>.</p>

<p>If we were to write an impure method that has access to some mutable state, held
in a <code>var</code>, it might have the signature <code>() =&gt; F[A]</code> and return a different
value on every call, breaking referential transparency. With pure FP the
function takes the state as input and returns the updated state as output, which
is why the underlying type of <code>StateT</code> is <code>S =&gt; F[(S, A)]</code>.</p>

<p>The associated monad is <code>MonadState</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadState[F[_], S] extends Monad[F] {
    def put(s: S): F[Unit]
    def get: F[S]
  
    def modify(f: S =&gt; S): F[Unit] = get &gt;&gt;= (s =&gt; put(f(s)))
    ...
  }
</pre></div>

</figure>

<aside>
  <p><code>S</code> must be an immutable type: <code>.modify</code> is not an escape hatch to update a
mutable data structure. Mutability is impure and is only allowed within an <code>IO</code>
block.</p>

</aside>

<p><code>StateT</code> is implemented slightly differently than the monad transformers we have
studied so far. Instead of being a <code>case class</code> it is an ADT with two members:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class StateT[F[_], S, A]
  object StateT {
    def apply[F[_], S, A](f: S =&gt; F[(S, A)]): StateT[F, S, A] = Point(f)
  
    private final case class Point[F[_], S, A](
      run: S =&gt; F[(S, A)]
    ) extends StateT[F, S, A]
    private final case class FlatMap[F[_], S, A, B](
      a: StateT[F, S, A],
      f: (S, A) =&gt; StateT[F, S, B]
    ) extends StateT[F, S, B]
    ...
  }
</pre></div>

</figure>

<p>which are a specialised form of <code>Trampoline</code>, giving us stack safety when we
want to recover the underlying data structure, <code>.run</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class StateT[F[_], S, A] {
    def run(initial: S)(implicit F: Monad[F]): F[(S, A)] = this match {
      case Point(f) =&gt; f(initial)
      case FlatMap(Point(f), g) =&gt;
        f(initial) &gt;&gt;= { case (s, x) =&gt; g(s, x).run(s) }
      case FlatMap(FlatMap(f, g), h) =&gt;
        FlatMap(f, (s, x) =&gt; FlatMap(g(s, x), h)).run(initial)
    }
    ...
  }
</pre></div>

</figure>

<p><code>StateT</code> can straightforwardly implement <code>MonadState</code> with its ADT:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def monad[F[_]: Applicative, S] = new MonadState[StateT[F, S, ?], S] {
    def point[A](a: =&gt;A) = Point(s =&gt; (s, a).point[F])
    def bind[A, B](fa: StateT[F, S, A])(f: A =&gt; StateT[F, S, B]) =
      FlatMap(fa, (_, a: A) =&gt; f(a))
  
    def get       = Point(s =&gt; (s, s).point[F])
    def put(s: S) = Point(_ =&gt; (s, ()).point[F])
  }
</pre></div>

</figure>

<p>With <code>.pure</code> mirrored on the companion as <code>.stateT</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object StateT {
    def stateT[F[_]: Applicative, S, A](a: A): StateT[F, S, A] = ...
    ...
  }
</pre></div>

</figure>

<p>and <code>MonadTrans.liftM</code> providing the <code>F[A] =&gt; StateT[F, S, A]</code> constructor as
usual.</p>

<p>A common variant of <code>StateT</code> is when <code>F = Id</code>, giving the underlying type
signature <code>S =&gt; (S, A)</code>. Scalaz provides a type alias and convenience functions
for interacting with the <code>State</code> monad transformer directly, and mirroring
<code>MonadState</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type State[a] = StateT[Id, a]
  object State {
    def apply[S, A](f: S =&gt; (S, A)): State[S, A] = StateT[Id, S, A](f)
    def state[S, A](a: A): State[S, A] = State((_, a))
  
    def get[S]: State[S, S] = State(s =&gt; (s, s))
    def put[S](s: S): State[S, Unit] = State(_ =&gt; (s, ()))
    def modify[S](f: S =&gt; S): State[S, Unit] = ...
    ...
  }
</pre></div>

</figure>

<p>For an example we can return to the business logic tests of
<code>drone-dynamic-agents</code>. Recall from Chapter 3 that we created <code>Mutable</code> as test
interpreters for our application and we stored the number of <code>started</code> and
<code>stoped</code> nodes in <code>var</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class Mutable(state: WorldView) {
    var started, stopped: Int = 0
  
    implicit val drone: Drone[Id] = new Drone[Id] { ... }
    implicit val machines: Machines[Id] = new Machines[Id] { ... }
    val program = new DynAgentsModule[Id]
  }
</pre></div>

</figure>

<p>We now know that we can write a much better test simulator with <code>State</code>. We will
take the opportunity to upgrade the accuracy of the simulation at the same time.
Recall that a core domain object is our application’s view of the world:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class WorldView(
    backlog: Int,
    agents: Int,
    managed: NonEmptyList[MachineNode],
    alive: Map[MachineNode, Epoch],
    pending: Map[MachineNode, Epoch],
    time: Epoch
  )
</pre></div>

</figure>

<p>Since we’re writing a simulation of the world for our tests, we can create a
data type that captures the ground truth of everything</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class World(
    backlog: Int,
    agents: Int,
    managed: NonEmptyList[MachineNode],
    alive: Map[MachineNode, Epoch],
    started: Set[MachineNode],
    stopped: Set[MachineNode],
    time: Epoch
  )
</pre></div>

</figure>

<aside>
  <p>We have not yet rewritten the application to fully make use Scalaz data types
and typeclasses, and we are still relying on stdlib collections. There is no
urgency to update as this is straightforward and these types can be used in a
pure FP manner.</p>

</aside>

<p>The key difference being that the <code>started</code> and <code>stopped</code> nodes can be separated
out. Our interpreter can be implemented in terms of <code>State[World, a]</code> and we can
write our tests to assert on what both the <code>World</code> and <code>WorldView</code> looks like
after the business logic has run.</p>

<p>The interpreters, which are mocking out contacting external Drone and Google
services, may be implemented like this:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import State.{ get, modify }
  object StateImpl {
    type F[a] = State[World, a]
  
    private val D = new Drone[F] {
      def getBacklog: F[Int] = get.map(_.backlog)
      def getAgents: F[Int]  = get.map(_.agents)
    }
  
    private val M = new Machines[F] {
      def getAlive: F[Map[MachineNode, Epoch]]   = get.map(_.alive)
      def getManaged: F[NonEmptyList[MachineNode]] = get.map(_.managed)
      def getTime: F[Epoch]                      = get.map(_.time)
  
      def start(node: MachineNode): F[Unit] =
        modify(w =&gt; w.copy(started = w.started + node))
      def stop(node: MachineNode): F[Unit] =
        modify(w =&gt; w.copy(stopped = w.stopped + node))
    }
  
    val program = new DynAgentsModule[F](D, M)
  }
</pre></div>

</figure>

<p>and we can rewrite our tests to follow a convention where:</p>

<ul>
  <li>
<code>world1</code> is the state of the world before running the program</li>
  <li>
<code>view1</code> is the application’s belief about the world</li>
  <li>
<code>world2</code> is the state of the world after running the program</li>
  <li>
<code>view2</code> is the application’s belief after running the program</li>
</ul>

<p>For example,</p>

<figure class="code">
<div class="highlight"><pre><code></code>  it should "request agents when needed" in {
    val world1          = World(5, 0, managed, Map(), Set(), Set(), time1)
    val view1           = WorldView(5, 0, managed, Map(), Map(), time1)
  
    val (world2, view2) = StateImpl.program.act(view1).run(world1)
  
    view2.shouldBe(view1.copy(pending = Map(node1 -&gt; time1)))
    world2.stopped.shouldBe(world1.stopped)
    world2.started.shouldBe(Set(node1))
  }
</pre></div>

</figure>

<p>We would be forgiven for looking back to our business logic loop</p>

<figure class="code">
<div class="highlight"><pre><code></code>  state = initial()
  while True:
    state = update(state)
    state = act(state)
</pre></div>

</figure>

<p>and use <code>StateT</code> to manage the <code>state</code>. However, our <code>DynAgents</code> business logic
requires only <code>Applicative</code> and we would be violating the <em>Rule of Least Power</em>
to require the more powerful <code>MonadState</code>. It is therefore entirely reasonable
to handle the state manually by passing it in to <code>update</code> and <code>act</code>, and let
whoever calls us use a <code>StateT</code> if they wish.</p>

<h4 id="leanpub-auto-indexedstatet">
<a class="anchor-link" href="#leanpub-auto-indexedstatet"><i class="fa fa-link"></i></a><span class="section-number">7.4.7 </span><code>IndexedStateT</code>
</h4>

<p>The code that we have studied thus far is not how Scalaz implements <code>StateT</code>.
Instead, a type alias points to <code>IndexedStateT</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  type StateT[F[_], S, A] = IndexedStateT[F, S, S, A]
</pre></div>

</figure>

<p>The implementation of <code>IndexedStateT</code> is much as we have studied, with an extra
type parameter allowing the input state <code>S1</code> and output state <code>S2</code> to differ:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IndexedStateT[F[_], -S1, S2, A] {
    def run(initial: S1)(implicit F: Bind[F]): F[(S2, A)] = ...
    ...
  }
  object IndexedStateT {
    def apply[F[_], S1, S2, A](
      f: S1 =&gt; F[(S2, A)]
    ): IndexedStateT[F, S1, S2, A] = Wrap(f)
  
    private final case class Wrap[F[_], S1, S2, A](
      run: S1 =&gt; F[(S2, A)]
    ) extends IndexedStateT[F, S1, S2, A]
    private final case class FlatMap[F[_], S1, S2, S3, A, B](
      a: IndexedStateT[F, S1, S2, A],
      f: (S2, A) =&gt; IndexedStateT[F, S2, S3, B]
    ) extends IndexedStateT[F, S1, S3, B]
    ...
  }
</pre></div>

</figure>

<p><code>IndexedStateT</code> does not have a <code>MonadState</code> when <code>S1 != S2</code>, although it has a
<code>Monad</code>.</p>

<p>The following example is adapted from <a href="https://www.youtube.com/watch?v=JPVagd9W4Lo">Index your State</a> by Vincent Marquez.
Consider the scenario where we must design an algebraic interface for an <code>Int</code>
to <code>String</code> lookup. This may have a networked implementation and the order of
calls is essential. Our first attempt at the API may look something like:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Cache[F[_]] {
    def read(k: Int): F[Maybe[String]]
  
    def lock: F[Unit]
    def update(k: Int, v: String): F[Unit]
    def commit: F[Unit]
  }
</pre></div>

</figure>

<p>with runtime errors if <code>.update</code> or <code>.commit</code> is called without a <code>.lock</code>. A
more complex design may involve multiple traits and a custom DSL that nobody
remembers how to use.</p>

<p>Instead, we can use <code>IndexedStateT</code> to require that the caller is in the correct
state. First we define our possible states as an ADT</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Status
  final case class Ready()                          extends Status
  final case class Locked(on: ISet[Int])            extends Status
  final case class Updated(values: Int ==&gt;&gt; String) extends Status
</pre></div>

</figure>

<p>and then revisit our algebra</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Cache[M[_]] {
    type F[in, out, a] = IndexedStateT[M, in, out, a]
  
    def read(k: Int): F[Ready, Ready, Maybe[String]]
    def readLocked(k: Int): F[Locked, Locked, Maybe[String]]
    def readUncommitted(k: Int): F[Updated, Updated, Maybe[String]]
  
    def lock: F[Ready, Locked, Unit]
    def update(k: Int, v: String): F[Locked, Updated, Unit]
    def commit: F[Updated, Ready, Unit]
  }
</pre></div>

</figure>

<p>which will give a compiletime error if we try to <code>.update</code> without a <code>.lock</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
        a1 &lt;- C.read(13)
        _  &lt;- C.update(13, "wibble")
        _  &lt;- C.commit
      } yield a1
  
  [error]  found   : IndexedStateT[M,Locked,Ready,Maybe[String]]
  [error]  required: IndexedStateT[M,Ready,?,?]
  [error]       _  &lt;- C.update(13, "wibble")
  [error]          ^
</pre></div>

</figure>

<p>but allowing us to construct functions that can be composed by explicitly
including their state:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def wibbleise[M[_]: Monad](C: Cache[M]): F[Ready, Ready, String] =
    for {
      _  &lt;- C.lock
      a1 &lt;- C.readLocked(13)
      a2 = a1.cata(_ + "'", "wibble")
      _  &lt;- C.update(13, a2)
      _  &lt;- C.commit
    } yield a2
</pre></div>

</figure>

<aside>
  <p>We introduced code duplication in our API when we defined multiple <code>.read</code>
operations</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def read(k: Int): F[Ready, Ready, Maybe[String]]
  def readLocked(k: Int): F[Locked, Locked, Maybe[String]]
  def readUncommitted(k: Int): F[Updated, Updated, Maybe[String]]
</pre></div>

  </figure>

  <p>Instead of</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def read[S &lt;: Status](k: Int): F[S, S, Maybe[String]]
</pre></div>

  </figure>

  <p>The reason we didn’t do this is, <em>because subtyping</em>. This (broken) code would
compile with the inferred type signature <code>F[Nothing, Ready, Maybe[String]]</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  for {
    a1 &lt;- C.read(13)
    _  &lt;- C.update(13, "wibble")
    _  &lt;- C.commit
  } yield a1
</pre></div>

  </figure>

  <p>Scala has a <code>Nothing</code> type which is the subtype of all other types. Thankfully,
this code can not make it to runtime, as it would be impossible to call it, but
it is a bad API since users need to remember to add type ascriptions.</p>

  <p>Another approach would be to stop the compiler from inferring <code>Nothing</code>. Scalaz
provides implicit evidence to assert that a type is not inferred as <code>Nothing</code>
and we can use it instead:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  def read[S &lt;: Status](k: Int)(implicit NN: NotNothing[S]): F[S, S, Maybe[String]]
</pre></div>

  </figure>

  <p>The choice of which of the three alternative APIs to prefer is left to the
personal taste of the API designer.</p>

</aside>

<h4 id="leanpub-auto-indexedreaderwriterstatet">
<a class="anchor-link" href="#leanpub-auto-indexedreaderwriterstatet"><i class="fa fa-link"></i></a><span class="section-number">7.4.8 </span><code>IndexedReaderWriterStateT</code>
</h4>

<p>Those wanting to have a combination of <code>ReaderT</code>, <code>WriterT</code> and <code>IndexedStateT</code>
will not be disappointed. The transformer <code>IndexedReaderWriterStateT</code> wraps <code>(R,
S1) =&gt; F[(W, A, S2)]</code> with <code>R</code> having <code>Reader</code> semantics, <code>W</code> for monoidic
writes, and the <code>S</code> parameters for indexed state updates.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IndexedReaderWriterStateT[F[_], -R, W, -S1, S2, A] {
    def run(r: R, s: S1)(implicit F: Monad[F]): F[(W, A, S2)] = ...
    ...
  }
  object IndexedReaderWriterStateT {
    def apply[F[_], R, W, S1, S2, A](f: (R, S1) =&gt; F[(W, A, S2)]) = ...
  }
  
  type ReaderWriterStateT[F[_], -R, W, S, A] = IndexedReaderWriterStateT[F, R, W, S, S, A]
  object ReaderWriterStateT {
    def apply[F[_], R, W, S, A](f: (R, S) =&gt; F[(W, A, S)]) = ...
  }
</pre></div>

</figure>

<p>Abbreviations are provided because otherwise, let’s be honest, these types are
so long they look like they are part of a J2EE API:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type IRWST[F[_], -R, W, -S1, S2, A] = IndexedReaderWriterStateT[F, R, W, S1, S2, A]
  val IRWST = IndexedReaderWriterStateT
  type RWST[F[_], -R, W, S, A] = ReaderWriterStateT[F, R, W, S, A]
  val RWST = ReaderWriterStateT
</pre></div>

</figure>

<p><code>IRWST</code> is a more efficient implementation than a manually created transformer
<em>stack</em> of <code>ReaderT[WriterT[IndexedStateT[F, ...], ...], ...]</code>.</p>

<h4 id="leanpub-auto-theset">
<a class="anchor-link" href="#leanpub-auto-theset"><i class="fa fa-link"></i></a><span class="section-number">7.4.9 </span><code>TheseT</code>
</h4>

<p><code>TheseT</code> allows errors to either abort the calculation or to be accumulated if
there is some partial success. Hence <em>keep calm and carry on</em>.</p>

<p>The underlying data type is <code>F[A \&amp;/ B]</code> with <code>A</code> being the error type,
requiring a <code>Semigroup</code> to enable the accumulation of errors.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class TheseT[F[_], A, B](run: F[A \&amp;/ B])
  object TheseT {
    def `this`[F[_]: Functor, A, B](a: F[A]): TheseT[F, A, B] = ...
    def that[F[_]: Functor, A, B](b: F[B]): TheseT[F, A, B] = ...
    def both[F[_]: Functor, A, B](ab: F[(A, B)]): TheseT[F, A, B] = ...
  
    implicit def monad[F[_]: Monad, A: Semigroup] = new Monad[TheseT[F, A, ?]] {
      def bind[B, C](fa: TheseT[F, A, B])(f: B =&gt; TheseT[F, A, C]) =
        TheseT(fa.run &gt;&gt;= {
          case This(a) =&gt; a.wrapThis[C].point[F]
          case That(b) =&gt; f(b).run
          case Both(a, b) =&gt;
            f(b).run.map {
              case This(a_)     =&gt; (a |+| a_).wrapThis[C]
              case That(c_)     =&gt; Both(a, c_)
              case Both(a_, c_) =&gt; Both(a |+| a_, c_)
            }
        })
  
      def point[B](b: =&gt;B) = TheseT(b.wrapThat.point[F])
    }
  }
</pre></div>

</figure>

<p>There is no special monad associated with <code>TheseT</code>, it is just a regular
<code>Monad</code>. If we wish to abort a calculation we can return a <code>This</code> value, but we
accumulate errors when we return a <code>Both</code> which also contains a successful part
of the calculation.</p>

<p><code>TheseT</code> can also be thought of from a different angle: <code>A</code> does not need to be
an <em>error</em>. Similarly to <code>WriterT</code>, the <code>A</code> may be a secondary calculation that
we are computing along with the primary calculation <code>B</code>. <code>TheseT</code> allows early
exit when something special about <code>A</code> demands it, like when Charlie Bucket found
the last golden ticket (<code>A</code>) he threw away his chocolate bar (<code>B</code>).</p>

<h4 id="leanpub-auto-contt">
<a class="anchor-link" href="#leanpub-auto-contt"><i class="fa fa-link"></i></a><span class="section-number">7.4.10 </span><code>ContT</code>
</h4>

<p><em>Continuation Passing Style</em> (CPS) is a style of programming where functions
never return, instead <em>continuing</em> to the next computation. CPS is popular in
Javascript and Lisp as they allow non-blocking I/O via callbacks when data is
available. A direct translation of the pattern into impure Scala looks like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[I, A](input: I)(next: A =&gt; Unit): Unit = next(doSomeStuff(input))
</pre></div>

</figure>

<p>We can make this pure by introducing an <code>F[_]</code> context</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_], I, A](input: I)(next: A =&gt; F[Unit]): F[Unit]
</pre></div>

</figure>

<p>and refactor to return a function for the provided input</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_], I, A](input: I): (A =&gt; F[Unit]) =&gt; F[Unit]
</pre></div>

</figure>

<p><code>ContT</code> is just a container for this signature, with a <code>Monad</code> instance</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class ContT[F[_], B, A](_run: (A =&gt; F[B]) =&gt; F[B]) {
    def run(f: A =&gt; F[B]): F[B] = _run(f)
  }
  object IndexedContT {
    implicit def monad[F[_], B] = new Monad[ContT[F, B, ?]] {
      def point[A](a: =&gt;A) = ContT(_(a))
      def bind[A, C](fa: ContT[F, B, A])(f: A =&gt; ContT[F, B, C]) =
        ContT(c_fb =&gt; fa.run(a =&gt; f(a).run(c_fb)))
    }
  }
</pre></div>

</figure>

<p>and convenient syntax to create a <code>ContT</code> from a monadic value:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class ContTOps[F[_]: Monad, A](self: F[A]) {
    def cps[B]: ContT[F, B, A] = ContT(a_fb =&gt; self &gt;&gt;= a_fb)
  }
</pre></div>

</figure>

<p>However, the simple callback use of continuations brings nothing to pure
functional programming because we already know how to sequence non-blocking,
potentially distributed, computations: that is what <code>Monad</code> is for and we can do
this with <code>.bind</code> or a <code>Kleisli</code> arrow. To see why continuations are useful we
need to consider a more complex example under a rigid design constraint.</p>

<h5 id="leanpub-auto-control-flow">
<a class="anchor-link" href="#leanpub-auto-control-flow"><i class="fa fa-link"></i></a><span class="section-number">7.4.10.1 </span>Control Flow</h5>

<p>Say we have modularised our application into components that can perform I/O,
with each component owned by a different development team:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class A0()
  final case class A1()
  final case class A2()
  final case class A3()
  final case class A4()
  
  def bar0(a4: A4): IO[A0] = ...
  def bar2(a1: A1): IO[A2] = ...
  def bar3(a2: A2): IO[A3] = ...
  def bar4(a3: A3): IO[A4] = ...
</pre></div>

</figure>

<p>Our goal is to produce an <code>A0</code> given an <code>A1</code>. Whereas Javascript and Lisp would
reach for continuations to solve this problem (because the I/O could block) we
can just chain the functions</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def simple(a: A1): IO[A0] = bar2(a) &gt;&gt;= bar3 &gt;&gt;= bar4 &gt;&gt;= bar0
</pre></div>

</figure>

<p>We can lift <code>.simple</code> into its continuation form by using the convenient <code>.cps</code>
syntax and a little bit of extra boilerplate for each step:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo1(a: A1): ContT[IO, A0, A2] = bar2(a).cps
  def foo2(a: A2): ContT[IO, A0, A3] = bar3(a).cps
  def foo3(a: A3): ContT[IO, A0, A4] = bar4(a).cps
  
  def flow(a: A1): IO[A0]  = (foo1(a) &gt;&gt;= foo2 &gt;&gt;= foo3).run(bar0)
</pre></div>

</figure>

<p>So what does this buy us? Firstly, it is worth noting that the control flow of
this application is left to right</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/contt-simple.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>What if we are the authors of <code>foo2</code> and we want to post-process the <code>a0</code> that
we receive from the right (downstream), i.e. we want to split our <code>foo2</code> into
<code>foo2a</code> and <code>foo2b</code></p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 75%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/contt-process1.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Add the constraint that we cannot change the definition of <code>flow</code> or <code>bar0</code>.
Perhaps it is not our code and is defined by the framework we are using.</p>

<p>It is not possible to process the output of <code>a0</code> by modifying any of the
remaining <code>barX</code> methods. However, with <code>ContT</code> we can modify <code>foo2</code> to process
the result of the <code>next</code> continuation:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 45%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/contt-process2.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Which can be defined with</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =&gt;
    for {
      a3  &lt;- bar3(a)
      a0  &lt;- next(a3)
    } yield process(a0)
  }
</pre></div>

</figure>

<p>We are not limited to <code>.map</code> over the return value, we can <code>.bind</code> into another
control flow turning the linear flow into a graph!</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 50%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/contt-elsewhere.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  def elsewhere: ContT[IO, A0, A4] = ???
  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =&gt;
    for {
      a3  &lt;- bar3(a)
      a0  &lt;- next(a3)
      a0_ &lt;- if (check(a0)) a0.pure[IO]
             else elsewhere.run(bar0)
    } yield a0_
  }
</pre></div>

</figure>

<p>Or we can stay within the original flow and retry everything downstream</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 45%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/contt-retry.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<figure class="code">
<div class="highlight"><pre><code></code>  def foo2(a: A2): ContT[IO, A0, A3] = ContT { next =&gt;
    for {
      a3  &lt;- bar3(a)
      a0  &lt;- next(a3)
      a0_ &lt;- if (check(a0)) a0.pure[IO]
             else next(a3)
    } yield a0_
  }
</pre></div>

</figure>

<p>This is just one retry, not an infinite loop. For example, we might want
downstream to reconfirm a potentially dangerous action.</p>

<p>Finally, we can perform actions that are specific to the context of the <code>ContT</code>,
in this case <code>IO</code> which lets us do error handling and resource cleanup:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo2(a: A2): ContT[IO, A0, A3] = bar3(a).ensuring(cleanup).cps
</pre></div>

</figure>

<h5 id="leanpub-auto-when-to-order-spaghetti">
<a class="anchor-link" href="#leanpub-auto-when-to-order-spaghetti"><i class="fa fa-link"></i></a><span class="section-number">7.4.10.2 </span>When to Order Spaghetti</h5>

<p>It is not an accident that these diagrams look like spaghetti, that is just what
happens when we start messing with control flow. All the mechanisms we’ve
discussed in this section are simple to implement directly if we can edit the
definition of <code>flow</code>, therefore we do not typically need to use <code>ContT</code>.</p>

<p>However, if we are designing a framework, we should consider exposing the plugin
system as <code>ContT</code> callbacks to allow our users more power over their control
flow. Sometimes the customer just really wants the spaghetti.</p>

<p>For example, if the Scala compiler was written using CPS, it would allow for a
principled approach to communication between compiler phases. A compiler plugin
would be able to perform some action based on the inferred type of an
expression, computed at a later stage in the compile. Similarly, continuations
would be a good API for an extensible build tool or text editor.</p>

<p>A caveat with <code>ContT</code> is that it is not stack safe, so cannot be used for
programs that run forever.</p>

<h5 id="leanpub-auto-great-kid-dont-get-contt">
<a class="anchor-link" href="#leanpub-auto-great-kid-dont-get-contt"><i class="fa fa-link"></i></a><span class="section-number">7.4.10.3 </span>Great, kid. Don’t get <code>ContT</code>.</h5>

<p>A more complex variant of <code>ContT</code> called <code>IndexedContT</code> wraps <code>(A =&gt; F[B]) =&gt;
F[C]</code>. The new type parameter <code>C</code> allows the return type of the entire
computation to be different to the return type between each component. But if
<code>B</code> is not equal to <code>C</code> then there is no <code>Monad</code>.</p>

<p>Not missing an opportunity to generalise as much as possible, <code>IndexedContT</code> is
actually implemented in terms of an even more general structure (note the extra
<code>s</code> before the <code>T</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class IndexedContsT[W[_], F[_], C, B, A](_run: W[A =&gt; F[B]] =&gt; F[C])
  
  type IndexedContT[f[_], c, b, a] = IndexedContsT[Id, f, c, b, a]
  type ContT[f[_], b, a]           = IndexedContsT[Id, f, b, b, a]
  type ContsT[w[_], f[_], b, a]    = IndexedContsT[w, f, b, b, a]
  type Cont[b, a]                  = IndexedContsT[Id, Id, b, b, a]
</pre></div>

</figure>

<p>where <code>W[_]</code> has a <code>Comonad</code>, and <code>ContT</code> is actually implemented as a type
alias. Companion objects exist for these type aliases with convenient
constructors.</p>

<p>Admittedly, five type parameters is perhaps a generalisation too far. But then
again, over-generalisation is consistent with the sensibilities of
continuations.</p>

<h4 id="leanpub-auto-transformer-stacks-and-ambiguous-implicits">
<a class="anchor-link" href="#leanpub-auto-transformer-stacks-and-ambiguous-implicits"><i class="fa fa-link"></i></a><span class="section-number">7.4.11 </span>Transformer Stacks and Ambiguous Implicits</h4>

<p>This concludes our tour of the monad transformers in Scalaz.</p>

<p>When multiple transformers are combined, we call this a <em>transformer stack</em> and
although it is verbose, it is possible to read off the features by reading the
transformers. For example if we construct an <code>F[_]</code> context which is a set of
composed transformers, such as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Ctx[A] = StateT[EitherT[IO, E, ?], S, A]
</pre></div>

</figure>

<p>we know that we are adding error handling with error type <code>E</code> (there is a
<code>MonadError[Ctx, E]</code>) and we are managing state <code>A</code> (there is a <code>MonadState[Ctx,
S]</code>).</p>

<p>But there are unfortunately practical drawbacks to using monad transformers and
their companion <code>Monad</code> typeclasses:</p>

<ol class="numeric">
  <li>Multiple implicit <code>Monad</code> parameters mean that the compiler cannot find the
correct syntax to use for the context.</li>
  <li>Monads do not compose in the general case, which means that the order of
nesting of the transformers is important.</li>
  <li>All the interpreters must be lifted into the common context. For example, we
might have an implementation of some algebra that uses for <code>IO</code> and now we
need to wrap it with <code>StateT</code> and <code>EitherT</code> even though they are unused
inside the interpreter.</li>
  <li>There is a performance cost associated to each layer. And some monad
transformers are worse than others. <code>StateT</code> is particularly bad but even
<code>EitherT</code> can cause memory allocation problems for high throughput
applications.</li>
</ol>

<p>We need to talk about workarounds.</p>

<h5 id="leanpub-auto-no-syntax">
<a class="anchor-link" href="#leanpub-auto-no-syntax"><i class="fa fa-link"></i></a><span class="section-number">7.4.11.1 </span>No Syntax</h5>

<p>Say we have an algebra</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Lookup[F[_]] {
    def look: F[Int]
  }
</pre></div>

</figure>

<p>and some data types</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Problem(bad: Int)
  final case class Table(last: Int)
</pre></div>

</figure>

<p>that we want to use in our business logic</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_]](L: Lookup[F])(
    implicit
      E: MonadError[F, Problem],
      S: MonadState[F, Table]
  ): F[Int] = for {
    old &lt;- S.get
    i   &lt;- L.look
    _   &lt;- if (i === old.last) E.raiseError(Problem(i))
           else ().pure[F]
  } yield i
</pre></div>

</figure>

<p>The first problem we encounter is that this fails to compile</p>

<figure class="code">
<div class="highlight"><pre><code></code>  [error] value flatMap is not a member of type parameter F[Table]
  [error]     old &lt;- S.get
  [error]              ^
</pre></div>

</figure>

<p>There are some tactical solutions to this problem. The most obvious is to make
all the parameters explicit</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo1[F[_]: Monad](
    L: Lookup[F],
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = ...
</pre></div>

</figure>

<p>and require only <code>Monad</code> to be passed implicitly via context bounds. However,
this means that we must manually wire up the <code>MonadError</code> and <code>MonadState</code> when
calling <code>foo1</code> and when calling out to another method that requires an
<code>implicit</code>.</p>

<p>A second solution is to leave the parameters <code>implicit</code> and use name shadowing
to make all but one of the parameters explicit. This allows upstream to use
implicit resolution when calling us but we still need to pass parameters
explicitly if we call out.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @inline final def shadow[A, B, C](a: A, b: B)(f: (A, B) =&gt; C): C = f(a, b)
  
  def foo2a[F[_]: Monad](L: Lookup[F])(
    implicit
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = shadow(E, S) { (E, S) =&gt; ...
</pre></div>

</figure>

<p>or we could shadow just one <code>Monad</code>, leaving the other one to provide our syntax
and to be available for when we call out to other methods</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @inline final def shadow[A, B](a: A)(f: A =&gt; B): B = f(a)
  ...
  
  def foo2b[F[_]](L: Lookup[F])(
    implicit
    E: MonadError[F, Problem],
    S: MonadState[F, Table]
  ): F[Int] = shadow(E) { E =&gt; ...
</pre></div>

</figure>

<p>A third option, with a higher up-front cost, is to create a custom <code>Monad</code>
typeclass that holds <code>implicit</code> references to the two <code>Monad</code> classes that we
care about</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait MonadErrorState[F[_], E, S] {
    implicit def E: MonadError[F, E]
    implicit def S: MonadState[F, S]
  }
</pre></div>

</figure>

<p>and a derivation of the typeclass given a <code>MonadError</code> and <code>MonadState</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object MonadErrorState {
    implicit def create[F[_], E, S](
      implicit
        E0: MonadError[F, E],
        S0: MonadState[F, S]
    ) = new MonadErrorState[F, E, S] {
      def E: MonadError[F, E] = E0
      def S: MonadState[F, S] = S0
    }
  }
</pre></div>

</figure>

<p>Now if we want access to <code>S</code> or <code>E</code> we get them via <code>F.S</code> or <code>F.E</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo3a[F[_]: Monad](L: Lookup[F])(
    implicit F: MonadErrorState[F, Problem, Table]
  ): F[Int] =
    for {
      old &lt;- F.S.get
      i   &lt;- L.look
      _ &lt;- if (i === old.last) F.E.raiseError(Problem(i))
      else ().pure[F]
    } yield i
</pre></div>

</figure>

<p>Like the second solution, we can choose one of the <code>Monad</code> instances to be
<code>implicit</code> within the block, achieved by importing it</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo3b[F[_]](L: Lookup[F])(
    implicit F: MonadErrorState[F, Problem, Table]
  ): F[Int] = {
    import F.E
    ...
  }
</pre></div>

</figure>

<h5 id="leanpub-auto-composing-transformers">
<a class="anchor-link" href="#leanpub-auto-composing-transformers"><i class="fa fa-link"></i></a><span class="section-number">7.4.11.2 </span>Composing Transformers</h5>

<p>An <code>EitherT[StateT[...], ...]</code> has a <code>MonadError</code> but does not have a
<code>MonadState</code>, whereas <code>StateT[EitherT[...], ...]</code> can provide both.</p>

<p>The workaround is to study the implicit derivations on the companion of the
transformers and to make sure that the outer most transformer provides
everything we need.</p>

<p>A rule of thumb is that more complex transformers go on the outside, with this
chapter presenting transformers in increasing order of complex.</p>

<h5 id="leanpub-auto-lifting-interpreters">
<a class="anchor-link" href="#leanpub-auto-lifting-interpreters"><i class="fa fa-link"></i></a><span class="section-number">7.4.11.3 </span>Lifting Interpreters</h5>

<p>Continuing the same example, let’s say our <code>Lookup</code> algebra has an <code>IO</code>
interpreter</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object LookupRandom extends Lookup[IO] {
    def look: IO[Int] = IO { util.Random.nextInt }
  }
</pre></div>

</figure>

<p>but we want our context to be</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Ctx[A] = StateT[EitherT[IO, Problem, ?], Table, A]
</pre></div>

</figure>

<p>to give us a <code>MonadError</code> and a <code>MonadState</code>. This means we need to wrap
<code>LookupRandom</code> to operate over <code>Ctx</code>.</p>

<aside>
  <p>The odds of getting the types correct on the first attempt are approximately
3,720 to one.</p>

</aside>

<p>Firstly, we want to make use of the <code>.liftM</code> syntax on <code>Monad</code>, which uses
<code>MonadTrans</code> to lift from our starting <code>F[A]</code> into <code>G[F, A]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class MonadOps[F[_]: Monad, A](fa: F[A]) {
    def liftM[G[_[_], _]: MonadTrans]: G[F, A] = ...
    ...
  }
</pre></div>

</figure>

<p>It is important to realise that the type parameters to <code>.liftM</code> have two type
holes, one of shape <code>_[_]</code> and another of shape <code>_</code>. If we create type aliases
of this shape</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Ctx0[F[_], A] = StateT[EitherT[F, Problem, ?], Table, A]
  type Ctx1[F[_], A] = EitherT[F, Problem, A]
  type Ctx2[F[_], A] = StateT[F, Table, A]
</pre></div>

</figure>

<p>We can abstract over <code>MonadTrans</code> to lift a <code>Lookup[F]</code> to any <code>Lookup[G[F, ?]]</code>
where <code>G</code> is a Monad Transformer:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftM[F[_]: Monad, G[_[_], _]: MonadTrans](f: Lookup[F]) =
    new Lookup[G[F, ?]] {
      def look: G[F, Int] = f.look.liftM[G]
    }
</pre></div>

</figure>

<p>Allowing us to wrap once for <code>EitherT</code>, and then again for <code>StateT</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  val wrap1 = Lookup.liftM[IO, Ctx1](LookupRandom)
  val wrap2: Lookup[Ctx] = Lookup.liftM[EitherT[IO, Problem, ?], Ctx2](wrap1)
</pre></div>

</figure>

<p>Another way to achieve this, in a single step, is to use <code>MonadIO</code> which enables
lifting an <code>IO</code> into a transformer stack:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait MonadIO[F[_]] extends Monad[F] {
    def liftIO[A](ioa: IO[A]): F[A]
  }
</pre></div>

</figure>

<p>with <code>MonadIO</code> instances for all the common combinations of transformers.</p>

<p>The boilerplate overhead to lift an <code>IO</code> interpreter to anything with a
<code>MonadIO</code> instance is therefore two lines of code (for the interpreter
definition), plus one line per element of the algebra, and a final line to call
it:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftIO[F[_]: MonadIO](io: Lookup[IO]) = new Lookup[F] {
    def look: F[Int] = io.look.liftIO[F]
  }
  
  val L: Lookup[Ctx] = Lookup.liftIO(LookupRandom)
</pre></div>

</figure>

<aside>
  <p>A compiler plugin that automatically produces <code>.liftM</code>, <code>.liftIO</code>, and
additional boilerplate that arises in this chapter, would be a great
contribution to the ecosystem!</p>

</aside>

<h5 id="leanpub-auto-performance">
<a class="anchor-link" href="#leanpub-auto-performance"><i class="fa fa-link"></i></a><span class="section-number">7.4.11.4 </span>Performance</h5>

<p>The biggest problem with Monad Transformers is their performance overhead.
<code>EitherT</code> has a reasonably low overhead, with every <code>.flatMap</code> call generating a
handful of objects, but this can impact high throughput applications where every
object allocation matters. Other transformers, such as <code>StateT</code>, effectively add
a trampoline, and <code>ContT</code> keeps the entire call-chain retained in memory.</p>

<aside>
  <p>Some applications do not care about allocations if they are bounded by network
or I/O. Always measure.</p>

</aside>

<p>If performance becomes a problem, the solution is to not use Monad Transformers.
At least not the transformer data structures. A big advantage of the <code>Monad</code>
typeclasses, like <code>MonadState</code> is that we can create an optimised <code>F[_]</code> for our
application that provides the typeclasses naturally. We will learn how to create
an optimal <code>F[_]</code> over the next two chapters, when we deep dive into two
structures which we have already seen: <code>Free</code> and <code>IO</code>.</p>

<h3 id="leanpub-auto-a-free-lunch">
<a class="anchor-link" href="#leanpub-auto-a-free-lunch"><i class="fa fa-link"></i></a><span class="section-number">7.5 </span>A Free Lunch</h3>

<p>Our industry craves safe high-level languages, trading developer efficiency and
reliability for reduced runtime performance.</p>

<p>The Just In Time (JIT) compiler on the JVM performs so well that simple
functions can have comparable performance to their C or C++ equivalents,
ignoring the cost of garbage collection. However, the JIT only performs <em>low
level optimisations</em>: branch prediction, inlining methods, unrolling loops, and
so on.</p>

<p>The JIT does not perform optimisations of our business logic, for example
batching network calls or parallelising independent tasks. The developer is
responsible for writing the business logic and optimisations at the same time,
reducing readability and making it harder to maintain. It would be good if
optimisation was a tangential concern.</p>

<p>If instead, we have a data structure that describes our business logic in terms
of high level concepts, not machine instructions, we can perform <em>high level
optimisation</em>. Data structures of this nature are typically called <em>Free</em>
structures and can be generated for free for the members of the algebraic
interfaces of our program. For example, a <em>Free Applicative</em> can be generated
that allows us to batch or de-duplicate expensive network I/O.</p>

<p>In this section we will learn how to create free structures, and how they can be
used.</p>

<h4 id="leanpub-auto-free-monad">
<a class="anchor-link" href="#leanpub-auto-free-monad"><i class="fa fa-link"></i></a><span class="section-number">7.5.1 </span><code>Free</code> (<code>Monad</code>)</h4>

<p>Fundamentally, a monad describes a sequential program where every step depends
on the previous one. We are therefore limited to modifications that only know
about things that we’ve already run and the next thing we are going to run.</p>

<aside>
  <p>It was trendy, circa 2015, to write FP programs in terms of <code>Free</code> so this is as
much an exercise in how to understand <code>Free</code> code as it is to be able to write
or use it.</p>

  <p>There is a lot of boilerplate to create a free structure. We shall use this
study of <code>Free</code> to learn how to generate the boilerplate.</p>

</aside>

<p>As a refresher, <code>Free</code> is the data structure representation of a <code>Monad</code> and is
defined by three members</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Free[S[_], A] {
    def mapSuspension[T[_]](f: S ~&gt; T): Free[T, A] = ...
    def foldMap[M[_]: Monad](f: S ~&gt; M): M[A] = ...
    ...
  }
  object Free {
    implicit def monad[S[_], A]: Monad[Free[S, A]] = ...
  
    private final case class Suspend[S[_], A](a: S[A]) extends Free[S, A]
    private final case class Return[S[_], A](a: A)     extends Free[S, A]
    private final case class Gosub[S[_], A0, B](
      a: Free[S, A0],
      f: A0 =&gt; Free[S, B]
    ) extends Free[S, B] { type A = A0 }
  
    def liftF[S[_], A](value: S[A]): Free[S, A] = Suspend(value)
    ...
  }
</pre></div>

</figure>

<ul>
  <li>
<code>Suspend</code> represents a program that has not yet been interpreted</li>
  <li>
<code>Return</code> is <code>.pure</code>
</li>
  <li>
<code>Gosub</code> is <code>.bind</code>
</li>
</ul>

<p>A <code>Free[S, A]</code> can be <em>freely generated</em> for any algebra <code>S</code>. To make this
explicit, consider our application’s <code>Machines</code> algebra</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Machines[F[_]] {
    def getTime: F[Epoch]
    def getManaged: F[NonEmptyList[MachineNode]]
    def getAlive: F[Map[MachineNode, Epoch]]
    def start(node: MachineNode): F[Unit]
    def stop(node: MachineNode): F[Unit]
  }
</pre></div>

</figure>

<p>We define a freely generated <code>Free</code> for <code>Machines</code> by creating an ADT with a
data type for each element of the algebra. Each data type has the same input
parameters as its corresponding element, is parameterised over the return type,
and has the same name:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Machines {
    sealed abstract class Ast[A]
    final case class GetTime()                extends Ast[Epoch]
    final case class GetManaged()             extends Ast[NonEmptyList[MachineNode]]
    final case class GetAlive()               extends Ast[Map[MachineNode, Epoch]]
    final case class Start(node: MachineNode) extends Ast[Unit]
    final case class Stop(node: MachineNode)  extends Ast[Unit]
    ...
</pre></div>

</figure>

<p>The ADT defines an Abstract Syntax Tree (AST) because each member is
representing a computation in a program.</p>

<aside class="warning blurb">
    <p>The freely generated <code>Free</code> for <code>Machines</code> is <code>Free[Machines.Ast, ?]</code>, i.e. for
the AST, not <code>Free[Machines, ?]</code>. It is easy to make a mistake, since the latter
will compile, but is meaningless.</p>

</aside>

<p>We then define <code>.liftF</code>, an implementation of <code>Machines</code>, with <code>Free[Ast, ?]</code> as
the context. Every method simply delegates to <code>Free.liftT</code> to create a <code>Suspend</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    def liftF = new Machines[Free[Ast, ?]] {
      def getTime = Free.liftF(GetTime())
      def getManaged = Free.liftF(GetManaged())
      def getAlive = Free.liftF(GetAlive())
      def start(node: MachineNode) = Free.liftF(Start(node))
      def stop(node: MachineNode) = Free.liftF(Stop(node))
    }
  }
</pre></div>

</figure>

<p>When we construct our program, parameterised over a <code>Free</code>, we run it by
providing an <em>interpreter</em> (a natural transformation <code>Ast ~&gt; M</code>) to the
<code>.foldMap</code> method. For example, if we could provide an interpreter that maps to
<code>IO</code> we can construct an <code>IO[Unit]</code> program via the free AST</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def program[F[_]: Monad](M: Machines[F]): F[Unit] = ...
  
  val interpreter: Machines.Ast ~&gt; IO = ...
  
  val app: IO[Unit] = program[Free[Machines.Ast, ?]](Machines.liftF)
                        .foldMap(interpreter)
</pre></div>

</figure>

<p>For completeness, an interpreter that delegates to a direct implementation is
easy to write. This might be useful if the rest of the application is using
<code>Free</code> as the context and we already have an <code>IO</code> implementation that we want to
use:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def interpreter[F[_]](f: Machines[F]): Ast ~&gt; F = λ[Ast ~&gt; F] {
    case GetTime()    =&gt; f.getTime
    case GetManaged() =&gt; f.getManaged
    case GetAlive()   =&gt; f.getAlive
    case Start(node)  =&gt; f.start(node)
    case Stop(node)   =&gt; f.stop(node)
  }
</pre></div>

</figure>

<p>But our business logic needs more than just <code>Machines</code>, we also need access to
the <code>Drone</code> algebra, recall defined as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Drone[F[_]] {
    def getBacklog: F[Int]
    def getAgents: F[Int]
  }
  object Drone {
    sealed abstract class Ast[A]
    ...
    def liftF = ...
    def interpreter = ...
  }
</pre></div>

</figure>

<p>What we want is for our AST to be a combination of the <code>Machines</code> and <code>Drone</code>
ASTs. We studied <code>Coproduct</code> in Chapter 6, a higher kinded disjunction:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Coproduct[F[_], G[_], A](run: F[A] \/ G[A])
</pre></div>

</figure>

<p>We can use the context <code>Free[Coproduct[Machines.Ast, Drone.Ast, ?], ?]</code>.</p>

<p>We could manually create the coproduct but we would be swimming in boilerplate,
and we’d have to do it all again if we wanted to add a third algebra.</p>

<p>The <code>scalaz.Inject</code> typeclass helps:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type :&lt;:[F[_], G[_]] = Inject[F, G]
  sealed abstract class Inject[F[_], G[_]] {
    def inj[A](fa: F[A]): G[A]
    def prj[A](ga: G[A]): Option[F[A]]
  }
  object Inject {
    implicit def left[F[_], G[_]]: F :&lt;: Coproduct[F, G, ?]] = ...
    ...
  }
</pre></div>

</figure>

<p>The <code>implicit</code> derivations generate <code>Inject</code> instances when we need them,
letting us rewrite our <code>liftF</code> to work for any combination of ASTs:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftF[F[_]](implicit I: Ast :&lt;: F) = new Machines[Free[F, ?]] {
    def getTime                  = Free.liftF(I.inj(GetTime()))
    def getManaged               = Free.liftF(I.inj(GetManaged()))
    def getAlive                 = Free.liftF(I.inj(GetAlive()))
    def start(node: MachineNode) = Free.liftF(I.inj(Start(node)))
    def stop(node: MachineNode)  = Free.liftF(I.inj(Stop(node)))
  }
</pre></div>

</figure>

<p>It is nice that <code>F :&lt;: G</code> reads as if our <code>Ast</code> is a member of the complete <code>F</code>
instruction set: this syntax is intentional.</p>

<aside>
  <p>A compiler plugin that automatically produces the <code>scalaz.Free</code> boilerplate
would be a great contribution to the ecosystem! Not only is it painful to write
the boilerplate, but there is the potential for a typo to ruin our day: if two
members of the algebra have the same type signature, we might not notice.</p>

</aside>

<p>Putting it all together, lets say we have a program that we wrote abstracting over <code>Monad</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def program[F[_]: Monad](M: Machines[F], D: Drone[F]): F[Unit] = ...
</pre></div>

</figure>

<p>and we have some existing implementations of <code>Machines</code> and <code>Drone</code>, we can
create interpreters from them:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val MachinesIO: Machines[IO] = ...
  val DroneIO: Drone[IO]       = ...
  
  val M: Machines.Ast ~&gt; IO = Machines.interpreter(MachinesIO)
  val D: Drone.Ast ~&gt; IO    = Drone.interpreter(DroneIO)
</pre></div>

</figure>

<p>and combine them into the larger instruction set using a convenience method from
the <code>NaturalTransformation</code> companion</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object NaturalTransformation {
    def or[F[_], G[_], H[_]](fg: F ~&gt; G, hg: H ~&gt; G): Coproduct[F, H, ?] ~&gt; G = ...
    ...
  }
  
  type Ast[a] = Coproduct[Machines.Ast, Drone.Ast, a]
  
  val interpreter: Ast ~&gt; IO = NaturalTransformation.or(M, D)
</pre></div>

</figure>

<p>Then use it to produce an <code>IO</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  val app: IO[Unit] = program[Free[Ast, ?]](Machines.liftF, Drone.liftF)
                        .foldMap(interpreter)
</pre></div>

</figure>

<p>But we’ve gone in circles! We could have used <code>IO</code> as the context for our
program in the first place and avoided <code>Free</code>. So why did we put ourselves
through all this pain? Here are some examples of where <code>Free</code> might be useful.</p>

<h5 id="leanpub-auto-testing-mocks-and-stubs">
<a class="anchor-link" href="#leanpub-auto-testing-mocks-and-stubs"><i class="fa fa-link"></i></a><span class="section-number">7.5.1.1 </span>Testing: Mocks and Stubs</h5>

<p>It might sound hypocritical to propose that <code>Free</code> can be used to reduce
boilerplate, given how much code we have written. However, there is a tipping
point where the <code>Ast</code> pays for itself when we have many tests that require stub
implementations.</p>

<p>If the <code>.Ast</code> and <code>.liftF</code> is defined for an algebra, we can create <em>partial
interpreters</em></p>

<figure class="code">
<div class="highlight"><pre><code></code>  val M: Machines.Ast ~&gt; Id = stub[Map[MachineNode, Epoch]] {
    case Machines.GetAlive() =&gt; Map.empty
  }
  val D: Drone.Ast ~&gt; Id = stub[Int] {
    case Drone.GetBacklog() =&gt; 1
  }
</pre></div>

</figure>

<p>which can be used to test our <code>program</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  program[Free[Ast, ?]](Machines.liftF, Drone.liftF)
    .foldMap(or(M, D))
    .shouldBe(1)
</pre></div>

</figure>

<p>By using partial functions, and not total functions, we are exposing ourselves
to runtime errors. Many teams are happy to accept this risk in their unit tests
since the test would fail if there is a programmer error.</p>

<p>Arguably we could also achieve the same thing with implementations of our
algebras that implement every method with <code>???</code>, overriding what we need on a
case by case basis.</p>

<aside>
  <p>The library <a href="https://github.com/djspiewak/smock">smock</a> is more powerful, but for the purposes of this short example
we can define <code>stub</code> ourselves using a type inference trick that can be found
all over the Scalaz source code. The reason for <code>Stub</code> being a separate class is
so that we only need to provide the <code>A</code> type parameter, with <code>F</code> and <code>G</code>
inferred from the left hand side of the expression:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object Mocker {
    final class Stub[A] {
      def apply[F[_], G[_]](pf: PartialFunction[F[A], G[A]]): F ~&gt; G = new (F ~&gt; G) {
        def apply[α](fa: F[α]) = pf.asInstanceOf[PartialFunction[F[α], G[α]]](fa)
      }
    }
    def stub[A]: Stub[A] = new Stub[A]
  }
</pre></div>

  </figure>

</aside>

<h5 id="leanpub-auto-monitoring">
<a class="anchor-link" href="#leanpub-auto-monitoring"><i class="fa fa-link"></i></a><span class="section-number">7.5.1.2 </span>Monitoring</h5>

<p>It is typical for server applications to be monitored by runtime agents that
manipulate bytecode to insert profilers and extract various kinds of usage or
performance information.</p>

<p>If our application’s context is <code>Free</code>, we do not need to resort to bytecode
manipulation, we can instead implement a side-effecting monitor as an
interpreter that we have complete control over.</p>

<aside>
  <p>Runtime introspection is one of the few cases that can justify use of a
side-effect. If the monitoring is not visible to the program itself, referential
transparency will still hold. This is also the argument used by teams that use
side-effecting debug logging, and our argument for allowing mutation in the
implementation of <code>Memo</code>.</p>

</aside>

<p>For example, consider using this <code>Ast ~&gt; Ast</code> “agent”</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val Monitor = λ[Demo.Ast ~&gt; Demo.Ast](
    _.run match {
      case \/-(m @ Drone.GetBacklog()) =&gt;
        JmxAbstractFactoryBeanSingletonProviderUtilImpl.count("backlog")
        Coproduct.rightc(m)
      case other =&gt;
        Coproduct(other)
    }
  )
</pre></div>

</figure>

<p>which records method invocations: we would use a vendor-specific routine in real
code. We could also watch for specific messages of interest and log them as a
debugging aid.</p>

<p>We can attach <code>Monitor</code> to our production <code>Free</code> application with</p>

<figure class="code">
<div class="highlight"><pre><code></code>  .mapSuspension(Monitor).foldMap(interpreter)
</pre></div>

</figure>

<p>or combine the natural transformations and run with a single</p>

<figure class="code">
<div class="highlight"><pre><code></code>  .foldMap(Monitor.andThen(interpreter))
</pre></div>

</figure>

<h5 id="leanpub-auto-monkey-patching">
<a class="anchor-link" href="#leanpub-auto-monkey-patching"><i class="fa fa-link"></i></a><span class="section-number">7.5.1.3 </span>Monkey Patching</h5>

<p>As engineers, we are used to requests for bizarre workarounds to be added to the
core logic of the application. We might want to codify such corner cases as
<em>exceptions to the rule</em> and handle them tangentially to our core logic.</p>

<p>For example, suppose we get a memo from accounting telling us</p>

<blockquote>
  <p><em>URGENT: Bob is using node <code>#c0ffee</code> to run the year end. DO NOT STOP THIS
MACHINE!1!</em></p>
</blockquote>

<p>There is no possibility to discuss why Bob shouldn’t be using our machines for
his super-important accounts, so we have to hack our business logic and put out
a release to production as soon as possible.</p>

<p>Our monkey patch can map into a <code>Free</code> structure, allowing us to return a
pre-canned result (<code>Free.pure</code>) instead of scheduling the instruction. We
special case the instruction in a custom natural transformation with its return
value:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val monkey = λ[Machines.Ast ~&gt; Free[Machines.Ast, ?]] {
    case Machines.Stop(MachineNode("#c0ffee")) =&gt; Free.pure(())
    case other                                 =&gt; Free.liftF(other)
  }
</pre></div>

</figure>

<p>eyeball that it works, push it to prod, and set an alarm for next week to remind
us to remove it, and revoke Bob’s access to our servers.</p>

<p>Our unit test could use <code>State</code> as the target context, so we can keep track of
all the nodes we stopped:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type S = Set[MachineNode]
  val M: Machines.Ast ~&gt; State[S, ?] = Mocker.stub[Unit] {
    case Machines.Stop(node) =&gt; State.modify[S](_ + node)
  }
  
  Machines
    .liftF[Machines.Ast]
    .stop(MachineNode("#c0ffee"))
    .foldMap(monkey)
    .foldMap(M)
    .exec(Set.empty)
    .shouldBe(Set.empty)
</pre></div>

</figure>

<p>along with a test that “normal” nodes are not affected.</p>

<p>An advantage of using <code>Free</code> to avoid stopping the <code>#c0ffee</code> nodes is that we
can be sure to catch all the usages instead of having to go through the business
logic and look for all usages of <code>.stop</code>. If our application context is just an
<code>IO</code> we could, of course, implement this logic in the <code>Machines[IO]</code>
implementation but an advantage of using <code>Free</code> is that we don’t need to touch
the existing code and can instead isolate and test this (temporary) behaviour,
without being tied to the <code>IO</code> implementations.</p>

<h4 id="leanpub-auto-freeap-applicative">
<a class="anchor-link" href="#leanpub-auto-freeap-applicative"><i class="fa fa-link"></i></a><span class="section-number">7.5.2 </span><code>FreeAp</code> (<code>Applicative</code>)</h4>

<p>Despite this chapter being called <strong>Advanced Monads</strong>, the takeaway is: <em>we
shouldn’t use monads unless we really <strong>really</strong> have to</em>. In this section, we
will see why <code>FreeAp</code> (free applicative) is preferable to <code>Free</code> monads.</p>

<p><code>FreeAp</code> is defined as the data structure representation of the <code>ap</code> and <code>pure</code>
methods from the <code>Applicative</code> typeclass:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class FreeAp[S[_], A] {
    def hoist[G[_]](f: S ~&gt; G): FreeAp[G,A] = ...
    def foldMap[G[_]: Applicative](f: S ~&gt; G): G[A] = ...
    def monadic: Free[S, A] = ...
    def analyze[M:Monoid](f: F ~&gt; λ[α =&gt; M]): M = ...
    ...
  }
  object FreeAp {
    implicit def applicative[S[_], A]: Applicative[FreeAp[S, A]] = ...
  
    private final case class Pure[S[_], A](a: A) extends FreeAp[S, A]
    private final case class Ap[S[_], A, B](
      value: () =&gt; S[B],
      function: () =&gt; FreeAp[S, B =&gt; A]
    ) extends FreeAp[S, A]
  
    def pure[S[_], A](a: A): FreeAp[S, A] = Pure(a)
    def lift[S[_], A](x: =&gt;S[A]): FreeAp[S, A] = ...
    ...
  }
</pre></div>

</figure>

<p>The methods <code>.hoist</code> and <code>.foldMap</code> are like their <code>Free</code> analogues
<code>.mapSuspension</code> and <code>.foldMap</code>.</p>

<p>As a convenience, we can generate a <code>Free[S, A]</code> from our <code>FreeAp[S, A]</code> with
<code>.monadic</code>. This is especially useful to optimise smaller <code>Applicative</code>
subsystems yet use them as part of a larger <code>Free</code> program.</p>

<p>Like <code>Free</code>, we must create a <code>FreeAp</code> for our ASTs, more boilerplate…</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftA[F[_]](implicit I: Ast :&lt;: F) = new Machines[FreeAp[F, ?]] {
    def getTime = FreeAp.lift(I.inj(GetTime()))
    ...
  }
</pre></div>

</figure>

<h5 id="leanpub-auto-batching-network-calls">
<a class="anchor-link" href="#leanpub-auto-batching-network-calls"><i class="fa fa-link"></i></a><span class="section-number">7.5.2.1 </span>Batching Network Calls</h5>

<p>We opened this chapter with grand claims about performance. Time to deliver.</p>

<p><a href="https://gist.github.com/hellerbarde/2843375#file-latency_humanized-markdown">Philip Stark</a>’s Humanised version of <a href="http://norvig.com/21-days.html#answers">Peter Norvig’s Latency Numbers</a> serve as
motivation for why we should focus on reducing network calls to optimise an
application:</p>

<table>
  <thead>
    <tr>
      <th>Computer</th>
      <th>Human Timescale</th>
      <th>Human Analogy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>L1 cache reference</td>
      <td>0.5 secs</td>
      <td>One heart beat</td>
    </tr>
    <tr>
      <td>Branch mispredict</td>
      <td>5 secs</td>
      <td>Yawn</td>
    </tr>
    <tr>
      <td>L2 cache reference</td>
      <td>7 secs</td>
      <td>Long yawn</td>
    </tr>
    <tr>
      <td>Mutex lock/unlock</td>
      <td>25 secs</td>
      <td>Making a cup of tea</td>
    </tr>
    <tr>
      <td>Main memory reference</td>
      <td>100 secs</td>
      <td>Brushing your teeth</td>
    </tr>
    <tr>
      <td>Compress 1K bytes with Zippy</td>
      <td>50 min</td>
      <td>Scala compiler CI pipeline</td>
    </tr>
    <tr>
      <td>Send 2K bytes over 1Gbps network</td>
      <td>5.5 hr</td>
      <td>Train London to Edinburgh</td>
    </tr>
    <tr>
      <td>SSD random read</td>
      <td>1.7 days</td>
      <td>Weekend</td>
    </tr>
    <tr>
      <td>Read 1MB sequentially from memory</td>
      <td>2.9 days</td>
      <td>Long weekend</td>
    </tr>
    <tr>
      <td>Round trip within same datacenter</td>
      <td>5.8 days</td>
      <td>Long US Vacation</td>
    </tr>
    <tr>
      <td>Read 1MB sequentially from SSD</td>
      <td>11.6 days</td>
      <td>Short EU Holiday</td>
    </tr>
    <tr>
      <td>Disk seek</td>
      <td>16.5 weeks</td>
      <td>Term of university</td>
    </tr>
    <tr>
      <td>Read 1MB sequentially from disk</td>
      <td>7.8 months</td>
      <td>Fully paid maternity in Norway</td>
    </tr>
    <tr>
      <td>Send packet CA-&gt;Netherlands-&gt;CA</td>
      <td>4.8 years</td>
      <td>Government’s term</td>
    </tr>
  </tbody>

</table>

<p>Although <code>Free</code> and <code>FreeAp</code> incur a memory allocation overhead, the equivalent
of 100 seconds in the humanised chart, every time we can turn two sequential
network calls into one batch call, we save nearly 5 years.</p>

<p>When we are in a <code>Applicative</code> context, we can safely optimise our application
without breaking any of the expectations of the original program, and without
cluttering the business logic.</p>

<p>Luckily, our main business logic only requires an <code>Applicative</code>, recall</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class DynAgentsModule[F[_]: Applicative](D: Drone[F], M: Machines[F])
      extends DynAgents[F] {
    def act(world: WorldView): F[WorldView] = ...
    ...
  }
</pre></div>

</figure>

<p>To begin, we create the <code>lift</code> boilerplate for a new <code>Batch</code> algebra</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Batch[F[_]] {
    def start(nodes: NonEmptyList[MachineNode]): F[Unit]
  }
  object Batch {
    sealed abstract class Ast[A]
    final case class Start(nodes: NonEmptyList[MachineNode]) extends Ast[Unit]
  
    def liftA[F[_]](implicit I: Ast :&lt;: F) = new Batch[FreeAp[F, ?]] {
      def start(nodes: NonEmptyList[MachineNode]) = FreeAp.lift(I.inj(Start(nodes)))
    }
  }
</pre></div>

</figure>

<p>and then we will create an instance of <code>DynAgentsModule</code> with <code>FreeAp</code> as the context</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Orig[a] = Coproduct[Machines.Ast, Drone.Ast, a]
  
  val world: WorldView = ...
  val program = new DynAgentsModule(Drone.liftA[Orig], Machines.liftA[Orig])
  val freeap  = program.act(world)
</pre></div>

</figure>

<p>In Chapter 6, we studied the <code>Const</code> data type, which allows us to analyse a
program. It should not be surprising that <code>FreeAp.analyze</code> is implemented in
terms of <code>Const</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class FreeAp[S[_], A] {
    ...
    def analyze[M: Monoid](f: S ~&gt; λ[α =&gt; M]): M =
      foldMap(λ[S ~&gt; Const[M, ?]](x =&gt; Const(f(x)))).getConst
  }
</pre></div>

</figure>

<p>We provide a natural transformation to record all node starts and <code>.analyze</code> our
program to get all the nodes that need to be started:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val gather = λ[Orig ~&gt; λ[α =&gt; IList[MachineNode]]] {
    case Coproduct(-\/(Machines.Start(node))) =&gt; IList.single(node)
    case _                                    =&gt; IList.empty
  }
  val gathered: IList[MachineNode] = freeap.analyze(gather)
</pre></div>

</figure>

<p>The next step is to extend the instruction set from <code>Orig</code> to <code>Extended</code>, which
includes the <code>Batch.Ast</code> and write a <code>FreeAp</code> program that starts all our
<code>gathered</code> nodes in a single network call</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Extended[a] = Coproduct[Batch.Ast, Orig, a]
  def batch(nodes: IList[MachineNode]): FreeAp[Extended, Unit] =
    nodes.toNel match {
      case None        =&gt; FreeAp.pure(())
      case Some(nodes) =&gt; FreeAp.lift(Coproduct.leftc(Batch.Start(nodes)))
    }
</pre></div>

</figure>

<p>We also need to remove all the calls to <code>Machines.Start</code>, which we can do with a natural transformation</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val nostart = λ[Orig ~&gt; FreeAp[Extended, ?]] {
    case Coproduct(-\/(Machines.Start(_))) =&gt; FreeAp.pure(())
    case other                             =&gt; FreeAp.lift(Coproduct.rightc(other))
  }
</pre></div>

</figure>

<p>Now we have two programs, and need to combine them. Recall the <code>*&gt;</code> syntax from
<code>Apply</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  val patched = batch(gathered) *&gt; freeap.foldMap(nostart)
</pre></div>

</figure>

<p>Putting it all together under a single method:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def optimise[A](orig: FreeAp[Orig, A]): FreeAp[Extended, A] =
    (batch(orig.analyze(gather)) *&gt; orig.foldMap(nostart))
</pre></div>

</figure>

<p>That Is it! We <code>.optimise</code> every time we call <code>act</code> in our main loop, which is
just a matter of plumbing.</p>

<h4 id="leanpub-auto-coyoneda-functor">
<a class="anchor-link" href="#leanpub-auto-coyoneda-functor"><i class="fa fa-link"></i></a><span class="section-number">7.5.3 </span><code>Coyoneda</code> (<code>Functor</code>)</h4>

<p>Named after mathematician Nobuo Yoneda, we can freely generate a <code>Functor</code> data
structure for any algebra <code>S[_]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Coyoneda[F[_], A] {
    def run(implicit F: Functor[F]): F[A] = ...
    def trans[G[_]](f: F ~&gt; G): Coyoneda[G, A] = ...
    ...
  }
  object Coyoneda {
    implicit def functor[F[_], A]: Functor[Coyoneda[F, A]] = ...
  
    private final case class Map[F[_], A, B](fa: F[A], f: A =&gt; B) extends Coyoneda[F, A]
    def apply[F[_], A, B](sa: F[A])(f: A =&gt; B) = Map[F, A, B](sa, f)
    def lift[F[_], A](sa: F[A]) = Map[F, A, A](sa, identity)
    ...
  }
</pre></div>

</figure>

<p>and there is also a contravariant version</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class ContravariantCoyoneda[F[_], A] {
    def run(implicit F: Contravariant[F]): F[A] = ...
    def trans[G[_]](f: F ~&gt; G): ContravariantCoyoneda[G, A] = ...
    ...
  }
  object ContravariantCoyoneda {
    implicit def contravariant[F[_], A]: Contravariant[ContravariantCoyoneda[F, A]] = ...
  
    private final case class Contramap[F[_], A, B](fa: F[A], f: B =&gt; A)
      extends ContravariantCoyoneda[F, A]
    def apply[F[_], A, B](sa: F[A])(f: B =&gt; A) = Contramap[F, A, B](sa, f)
    def lift[F[_], A](sa: F[A]) = Contramap[F, A, A](sa, identity)
    ...
  }
</pre></div>

</figure>

<aside>
  <p>The colloquial for <code>Coyoneda</code> is <em>coyo</em> and <code>ContravariantCoyoneda</code> is <em>cocoyo</em>.
Just some Free Fun.</p>

</aside>

<p>The API is somewhat simpler than <code>Free</code> and <code>FreeAp</code>, allowing a natural
transformation with <code>.trans</code> and a <code>.run</code> (taking an actual <code>Functor</code> or
<code>Contravariant</code>, respectively) to escape the free structure.</p>

<p>Coyo and cocoyo can be a useful utility if we want to <code>.map</code> or <code>.contramap</code>
over a type, and we know that we can convert into a data type that has a Functor
but we don’t want to commit to the final data structure too early. For example,
we create a <code>Coyoneda[ISet, ?]</code> (recall <code>ISet</code> does not have a <code>Functor</code>) to use
methods that require a <code>Functor</code>, then convert into <code>IList</code> later on.</p>

<p>If we want to optimise a program with coyo or cocoyo we have to provide the
expected boilerplate for each algebra:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def liftCoyo[F[_]](implicit I: Ast :&lt;: F) = new Machines[Coyoneda[F, ?]] {
    def getTime = Coyoneda.lift(I.inj(GetTime()))
    ...
  }
  def liftCocoyo[F[_]](implicit I: Ast :&lt;: F) = new Machines[ContravariantCoyoneda[F, ?]] {
    def getTime = ContravariantCoyoneda.lift(I.inj(GetTime()))
    ...
  }
</pre></div>

</figure>

<p>An optimisation we get by using <code>Coyoneda</code> is <em>map fusion</em> (and <em>contramap
fusion</em>), which allows us to rewrite</p>

<figure class="code">
<div class="highlight"><pre><code></code>  xs.map(a).map(b).map(c)
</pre></div>

</figure>

<p>into</p>

<figure class="code">
<div class="highlight"><pre><code></code>  xs.map(x =&gt; c(b(a(x))))
</pre></div>

</figure>

<p>avoiding intermediate representations. For example, if <code>xs</code> is a <code>List</code> of a
thousand elements, we save two thousand object allocations because we only map
over the data structure once.</p>

<p>However it is arguably a lot easier to just make this kind of change in the
original function by hand, or to wait for the <a href="https://github.com/scalaz/scalaz-plugin"><code>scalaz-plugin</code></a> project to be
released and automatically perform these sorts of optimisations.</p>

<h4 id="leanpub-auto-extensible-effects">
<a class="anchor-link" href="#leanpub-auto-extensible-effects"><i class="fa fa-link"></i></a><span class="section-number">7.5.4 </span>Extensible Effects</h4>

<p>Programs are just data: free structures help to make this explicit and give us
the ability to rearrange and optimise that data.</p>

<p><code>Free</code> is more special than it appears: it can sequence arbitrary algebras and
typeclasses.</p>

<p>For example, a free structure for <code>MonadState</code> is available. The <code>Ast</code> and
<code>.liftF</code> are more complicated than usual because we have to account for the <code>S</code>
type parameter on <code>MonadState</code>, and the inheritance from <code>Monad</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object MonadState {
    sealed abstract class Ast[S, A]
    final case class Get[S]()     extends Ast[S, S]
    final case class Put[S](s: S) extends Ast[S, Unit]
  
    def liftF[F[_], S](implicit I: Ast[S, ?] :&lt;: F) =
      new MonadState[Free[F, ?], S] with BindRec[Free[F, ?]] {
        def get       = Free.liftF(I.inj(Get[S]()))
        def put(s: S) = Free.liftF(I.inj(Put[S](s)))
  
        val delegate         = Free.freeMonad[F]
        def point[A](a: =&gt;A) = delegate.point(a)
        ...
      }
    ...
  }
</pre></div>

</figure>

<p>This gives us the opportunity to use optimised interpreters. For example, we
could store the <code>S</code> in an atomic field instead of building up a nested <code>StateT</code>
trampoline.</p>

<p>We can create an <code>Ast</code> and <code>.liftF</code> for almost any algebra or typeclass! The
only restriction is that the <code>F[_]</code> does not appear as a parameter to any of the
instructions, i.e. it must be possible for the algebra to have an instance of
<code>Functor</code>. This unfortunately rules out <code>MonadError</code> and <code>Monoid</code>.</p>

<aside>
  <p>The reason why free encodings do not work for all algebras and typeclasses is
quite subtle.</p>

  <p>Consider what happens if we create an Ast for <code>MonadError</code>, with <code>F[_]</code> in
contravariant position, i.e. as a parameter.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  object MonadError {
    sealed abstract class Ast[F[_], E, A]
    final case class RaiseError[F[_], E, A](e: E) extends Ast[F, E, A]
    final case class HandleError[F[_], E, A](fa: F[A], f: E =&gt; F[A]) extends Ast[F, E, A]
  
    def liftF[F[_], E](implicit I: Ast[F, E, ?] :&lt;: F): MonadError[F, E] = ...
    ...
  }
</pre></div>

  </figure>

  <p>When we come to interpret a program that uses <code>MonadError.Ast</code> we must construct
the coproduct of instructions. Say we extend a <code>Drone</code> program:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  type Ast[a] = Coproduct[MonadError.Ast[Ast, String, ?], Drone.Ast, a]
</pre></div>

  </figure>

  <p>This fails to compile because <code>Ast</code> refers to itself!</p>

  <p>Algebras that are not entirely made of covariant functor signatures, i.e. <code>F[_]</code>
in return position, are impossible to interpret because the resulting type of
the program is self-referential. Indeed the name <em>algebra</em> that we have been
using has its roots in <a href="https://en.wikipedia.org/wiki/F-algebra">F-Algebras</a>, where the F is for Functor.</p>

  <p><em>Thanks to Edmund Noble for initiating this discussion.</em></p>

</aside>

<p>As the AST of a free program grows, performance degrades because the interpreter
must match over instruction sets with an <code>O(n)</code> cost. An alternative to
<code>scalaz.Coproduct</code> is <a href="https://github.com/frees-io/iota">iotaz</a>’s encoding, which uses an optimised data structure
to perform <code>O(1)</code> dynamic dispatch (using integers that are assigned to each
coproduct at compiletime).</p>

<p>For historical reasons a free AST for an algebra or typeclass is called <em>Initial
Encoding</em>, and a direct implementation (e.g. with <code>IO</code>) is called <em>Finally
Tagless</em>. Although we have explored interesting ideas with <code>Free</code>, it is
generally accepted that finally tagless is superior. But to use finally tagless
style, we need a high performance effect type that provides all the monad
typeclasses we’ve covered in this chapter. We also still need to be able to run
our <code>Applicative</code> code in parallel. This is exactly what we will cover next.</p>

<h3 id="leanpub-auto-parallel-1">
<a class="anchor-link" href="#leanpub-auto-parallel-1"><i class="fa fa-link"></i></a><span class="section-number">7.6 </span><code>Parallel</code>
</h3>

<p>There are two effectful operations that we almost always want to run in
parallel:</p>

<ol class="numeric">
  <li>
<code>.map</code> over a collection of effects, returning a single effect. This is
achieved by <code>.traverse</code>, which delegates to the effect’s <code>.apply2</code>.</li>
  <li>running a fixed number of effects with the <em>scream operator</em> <code>|@|</code>, and
combining their output, again delegating to <code>.apply2</code>.</li>
</ol>

<p>However, in practice, neither of these operations execute in parallel by
default. The reason is that if our <code>F[_]</code> is implemented by a <code>Monad</code>, then the
derived combinator laws for <code>.apply2</code> must be satisfied, which say</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Bind[F[_]] extends Apply[F] {
    ...
    override def apply2[A, B, C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C): F[C] =
      bind(fa)(a =&gt; map(fb)(b =&gt; f(a, b)))
    ...
  }
</pre></div>

</figure>

<p>In other words, <strong><code>Monad</code> is explicitly forbidden from running effects in
parallel.</strong></p>

<p>However, if we have an <code>F[_]</code> that is <strong>not</strong> monadic, then it may implement
<code>.apply2</code> in parallel. We can use the <code>@@</code> (tag) mechanism to create an instance
of <code>Applicative</code> for <code>F[_] @@ Parallel</code>, which is conveniently assigned to the
type alias <code>Applicative.Par</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Applicative {
    type Par[F[_]] = Applicative[λ[α =&gt; F[α] @@ Tags.Parallel]]
    ...
  }
</pre></div>

</figure>

<p>Monadic programs can then request an implicit <code>Par</code> in addition to their <code>Monad</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_]: Monad: Applicative.Par]: F[Unit] = ...
</pre></div>

</figure>

<p>Scalaz’s <code>Traverse</code> syntax supports parallelism:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit class TraverseSyntax[F[_], A](self: F[A]) {
    ...
    def parTraverse[G[_], B](f: A =&gt; G[B])(
      implicit F: Traverse[F], G: Applicative.Par[G]
    ): G[F[B]] = Tag.unwrap(F.traverse(self)(a =&gt; Tag(f(a))))
  }
</pre></div>

</figure>

<p>If the implicit <code>Applicative.Par[IO]</code> is in scope, we can choose between
sequential and parallel traversal:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val input: IList[String] = ...
  def network(in: String): IO[Int] = ...
  
  input.traverse(network): IO[IList[Int]] // one at a time
  input.parTraverse(network): IO[IList[Int]] // all in parallel
</pre></div>

</figure>

<p>Similarly, we can call <code>.parApply</code> or <code>.parTupled</code> after using scream operators</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val fa: IO[String] = ...
  val fb: IO[String] = ...
  val fc: IO[String] = ...
  
  (fa |@| fb).parTupled: IO[(String, String)]
  
  (fa |@| fb |@| fc).parApply { case (a, b, c) =&gt; a + b + c }: IO[String]
</pre></div>

</figure>

<p>It is worth noting that when we have <code>Applicative</code> programs, such as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_]: Applicative]: F[Unit] = ...
</pre></div>

</figure>

<p>we can use <code>F[A] @@ Parallel</code> as our program’s context and get parallelism as
the default on <code>.traverse</code> and <code>|@|</code>. Converting between the raw and <code>@@
Parallel</code> versions of <code>F[_]</code> must be handled manually in the glue code, which
can be painful. Therefore it is often easier to simply request both forms of
<code>Applicative</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foo[F[_]: Applicative: Applicative.Par]: F[Unit] = ...
</pre></div>

</figure>

<h4 id="leanpub-auto-breaking-the-law">
<a class="anchor-link" href="#leanpub-auto-breaking-the-law"><i class="fa fa-link"></i></a><span class="section-number">7.6.1 </span>Breaking the Law</h4>

<p>We can take a more daring approach to parallelism: opt-out of the law that
<code>.apply2</code> must be sequential for <code>Monad</code>. This is highly controversial, but
works well for the majority of real world applications. we must first audit our
codebase (including third party dependencies) to ensure that nothing is making
use of the <code>.apply2</code> implied law.</p>

<p>We wrap <code>IO</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class MyIO[A](val io: IO[A]) extends AnyVal
</pre></div>

</figure>

<p>and provide our own implementation of <code>Monad</code> which runs <code>.apply2</code> in parallel
by delegating to a <code>@@ Parallel</code> instance</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object MyIO {
    implicit val monad: Monad[MyIO] = new Monad[MyIO] {
      override def apply2[A, B, C](fa: MyIO[A], fb: MyIO[B])(f: (A, B) =&gt; C): MyIO[C] =
        Applicative[IO.Par].apply2(fa.io, fb.io)(f)
      ...
    }
  }
</pre></div>

</figure>

<p>We can now use <code>MyIO</code> as our application’s context instead of <code>IO</code>, and <strong>get
parallelism by default</strong>.</p>

<aside>
  <p>Wrapping an existing type and providing custom typeclass instances is known as
<em>newtyping</em>.</p>

  <p><code>@@</code> and newtyping are complementary: <code>@@</code> allows us to request specific
typeclass variants on our domain model, whereas newtyping allow us to define the
instances on the implementation. Same thing, different insertion points.</p>

  <p>The <code>@newtype</code> macro <a href="https://github.com/estatico/scala-newtype">by Cary Robbins</a> has an optimised runtime representation
(more efficient than <code>extends AnyVal</code>), that makes it easy to delegate
typeclasses that we do not wish to customise. For example, we can customise
<code>Monad</code> but delegate the <code>Plus</code>:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  @newtype class MyIO[A](io: IO[A])
  object MyIO {
    implicit val monad: Monad[MyIO] = ...
    implicit val plus: Plus[MyIO] = derived
  }
</pre></div>

  </figure>

</aside>

<p>For completeness: a naive and inefficient implementation of <code>Applicative.Par</code>
for our toy <code>IO</code> could use <code>Future</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object IO {
    ...
    type Par[a] = IO[a] @@ Parallel
    implicit val ParApplicative = new Applicative[Par] {
      override def apply2[A, B, C](fa: =&gt;Par[A], fb: =&gt;Par[B])(f: (A, B) =&gt; C): Par[C] =
        Tag(
          IO {
            val forked = Future { Tag.unwrap(fa).interpret() }
            val b      = Tag.unwrap(fb).interpret()
            val a      = Await.result(forked, Duration.Inf)
            f(a, b)
          }
        )
  }
</pre></div>

</figure>

<p>and due to <a href="https://github.com/scala/bug/issues/10954">a bug in the Scala compiler</a> that treats all <code>@@</code> instances as
orphans, we must explicitly import the implicit:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import IO.ParApplicative
</pre></div>

</figure>

<p>In the final section of this chapter we will see how Scalaz’s <code>IO</code> is actually
implemented.</p>

<h3 id="leanpub-auto-io">
<a class="anchor-link" href="#leanpub-auto-io"><i class="fa fa-link"></i></a><span class="section-number">7.7 </span><code>IO</code>
</h3>

<p>Scalaz’s <code>IO</code> is the fastest asynchronous programming construct in the Scala
ecosystem: up to 50 times faster than <code>Future</code>. <code>IO</code> is a free data structure
specialised for use as a general effect monad.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IO[E, A] { ... }
  object IO {
    private final class FlatMap         ... extends IO[E, A]
    private final class Point           ... extends IO[E, A]
    private final class Strict          ... extends IO[E, A]
    private final class SyncEffect      ... extends IO[E, A]
    private final class Fail            ... extends IO[E, A]
    private final class AsyncEffect     ... extends IO[E, A]
    ...
  }
</pre></div>

</figure>

<p><code>IO</code> has <strong>two</strong> type parameters: it has a <code>Bifunctor</code> allowing the error type to
be an application specific ADT. But because we are on the JVM, and must interact
with legacy libraries, a convenient type alias is provided that uses exceptions
for the error type:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type Task[A] = IO[Throwable, A]
</pre></div>

</figure>

<aside>
  <p><code>scalaz.ioeffect.IO</code> is a high performance <code>IO</code> by John de Goes. It has a
separate lifecycle to the core Scalaz library and must be manually added to our
<code>build.sbt</code> with</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  libraryDependencies += "org.scalaz" %% "scalaz-ioeffect" % "2.10.1"
</pre></div>

  </figure>

  <p>Do not use the deprecated <code>scalaz-effect</code> and <code>scalaz-concurrency</code> packages.</p>

  <p>Prefer the <code>scalaz.ioeffect</code> variants of all typeclasses and data types.</p>

</aside>

<h4 id="leanpub-auto-creating">
<a class="anchor-link" href="#leanpub-auto-creating"><i class="fa fa-link"></i></a><span class="section-number">7.7.1 </span>Creating</h4>

<p>There are multiple ways to create an <code>IO</code> that cover a variety of eager, lazy,
safe and unsafe code blocks:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object IO {
    // eager evaluation of an existing value
    def now[E, A](a: A): IO[E, A] = ...
    // lazy evaluation of a pure calculation
    def point[E, A](a: =&gt;A): IO[E, A] = ...
    // lazy evaluation of a side-effecting, yet Total, code block
    def sync[E, A](effect: =&gt;A): IO[E, A] = ...
    // lazy evaluation of a side-effecting code block that may fail
    def syncThrowable[A](effect: =&gt;A): IO[Throwable, A] = ...
  
    // create a failed IO
    def fail[E, A](error: E): IO[E, A] = ...
    // asynchronously sleeps for a specific period of time
    def sleep[E](duration: Duration): IO[E, Unit] = ...
    ...
  }
</pre></div>

</figure>

<p>with convenient <code>Task</code> constructors:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Task {
    def apply[A](effect: =&gt;A): Task[A] = IO.syncThrowable(effect)
    def now[A](effect: A): Task[A] = IO.now(effect)
    def fail[A](error: Throwable): Task[A] = IO.fail(error)
    def fromFuture[E, A](io: Task[Future[A]])(ec: ExecutionContext): Task[A] = ...
  }
</pre></div>

</figure>

<p>The most common constructors, by far, when dealing with legacy code are
<code>Task.apply</code> and <code>Task.fromFuture</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val fa: Task[Future[String]] = Task { ... impure code here ... }
  
  Task.fromFuture(fa)(ExecutionContext.global): Task[String]
</pre></div>

</figure>

<p>We cannot pass around raw <code>Future</code>, because it eagerly evaluates, so must always
be constructed inside a safe block.</p>

<p>Note that the <code>ExecutionContext</code> is <strong>not</strong> <code>implicit</code>, contrary to the
convention. Recall that in Scalaz we reserve the <code>implicit</code> keyword for
typeclass derivation, to simplify the language: <code>ExecutionContext</code> is
configuration that must be provided explicitly.</p>

<h4 id="leanpub-auto-running">
<a class="anchor-link" href="#leanpub-auto-running"><i class="fa fa-link"></i></a><span class="section-number">7.7.2 </span>Running</h4>

<p>The <code>IO</code> interpreter is called <code>RTS</code>, for <em>runtime system</em>. Its implementation
is beyond the scope of this book. We will instead focus on the features that
<code>IO</code> provides.</p>

<p><code>IO</code> is just a data structure, and is interpreted <em>at the end of the world</em> by
extending <code>SafeApp</code> and implementing <code>.run</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait SafeApp extends RTS {
  
    sealed trait ExitStatus
    object ExitStatus {
      case class ExitNow(code: Int)                         extends ExitStatus
      case class ExitWhenDone(code: Int, timeout: Duration) extends ExitStatus
      case object DoNotExit                                 extends ExitStatus
    }
  
    def run(args: List[String]): IO[Void, ExitStatus]
  
    final def main(args0: Array[String]): Unit = ... calls run ...
  }
</pre></div>

</figure>

<aside>
  <p><code>Void</code> is a type that has no values, like <code>scala.Nothing</code>. However, the Scala
compiler infers <code>Nothing</code> when it fails to correctly infer a type parameter,
causing confusing error messages, whereas <code>Void</code> will fail fast during
compilation.</p>

  <p>A <code>Void</code> error type means that the effect <strong>cannot fail</strong>, which is to say that we
have handled all errors by this point.</p>

</aside>

<p>If we are integrating with a legacy system and are not in control of the entry
point of our application, we can extend the <code>RTS</code> and gain access to unsafe
methods to evaluate the <code>IO</code> at the entry point to our principled FP code.</p>

<h4 id="leanpub-auto-features">
<a class="anchor-link" href="#leanpub-auto-features"><i class="fa fa-link"></i></a><span class="section-number">7.7.3 </span>Features</h4>

<p><code>IO</code> provides typeclass instances for <code>Bifunctor</code>, <code>MonadError[E, ?]</code>,
<code>BindRec</code>, <code>Plus</code>, <code>MonadPlus</code> (if <code>E</code> forms a <code>Monoid</code>), and an
<code>Applicative[IO.Par[E, ?]]</code>.</p>

<p>In addition to the functionality from the typeclasses, there are implementation
specific methods:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class IO[E, A] {
    // retries an action N times, until success
    def retryN(n: Int): IO[E, A] = ...
    // ... with exponential backoff
    def retryBackoff(n: Int, factor: Double, duration: Duration): IO[E, A] = ...
  
    // repeats an action with a pause between invocations, until it fails
    def repeat[B](interval: Duration): IO[E, B] = ...
  
    // cancel the action if it does not complete within the timeframe
    def timeout(duration: Duration): IO[E, Maybe[A]] = ...
  
    // runs `release` on success or failure.
    // Note that IO[Void, Unit] cannot fail.
    def bracket[B](release: A =&gt; IO[Void, Unit])(use: A =&gt; IO[E, B]): IO[E, B] = ...
    // alternative syntax for bracket
    def ensuring(finalizer: IO[Void, Unit]): IO[E, A] =
    // ignore failure and success, e.g. to ignore the result of a cleanup action
    def ignore: IO[Void, Unit] = ...
  
    // runs two effects in parallel
    def par[B](that: IO[E, B]): IO[E, (A, B)] = ...
    ...
</pre></div>

</figure>

<p>It is possible for an <code>IO</code> to be in a <em>terminated</em> state, which represents work
that is intended to be discarded (it is neither an error nor a success). The
utilities related to termination are:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    // terminate whatever actions are running with the given throwable.
    // bracket / ensuring is honoured.
    def terminate[E, A](t: Throwable): IO[E, A] = ...
  
    // runs two effects in parallel, return the winner and terminate the loser
    def race(that: IO[E, A]): IO[E, A] = ...
  
    // ignores terminations
    def uninterruptibly: IO[E, A] = ...
  ...
</pre></div>

</figure>

<h4 id="leanpub-auto-fiber">
<a class="anchor-link" href="#leanpub-auto-fiber"><i class="fa fa-link"></i></a><span class="section-number">7.7.4 </span><code>Fiber</code>
</h4>

<p>An <code>IO</code> may spawn <em>fibers</em>, a lightweight abstraction over a JVM <code>Thread</code>. We
can <code>.fork</code> an <code>IO</code>, and <code>.supervise</code> any incomplete fibers to ensure that they
are terminated when the <code>IO</code> action completes</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ...
    def fork[E2]: IO[E2, Fiber[E, A]] = ...
    def supervised(error: Throwable): IO[E, A] = ...
  ...
</pre></div>

</figure>

<p>When we have a <code>Fiber</code> we can <code>.join</code> back into the <code>IO</code>, or <code>interrupt</code> the
underlying work.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Fiber[E, A] {
    def join: IO[E, A]
    def interrupt[E2](t: Throwable): IO[E2, Unit]
  }
</pre></div>

</figure>

<p>We can use fibers to achieve a form of optimistic concurrency control. Consider
the case where we have <code>data</code> that we need to analyse, but we also need to
validate it. We can optimistically begin the analysis and cancel the work if the
validation fails, which is performed in parallel.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class BadData(data: Data) extends Throwable with NoStackTrace
  
  for {
    fiber1   &lt;- analysis(data).fork
    fiber2   &lt;- validate(data).fork
    valid    &lt;- fiber2.join
    _        &lt;- if (!valid) fiber1.interrupt(BadData(data))
                else IO.unit
    result   &lt;- fiber1.join
  } yield result
</pre></div>

</figure>

<p>Another usecase for fibers is when we need to perform a <em>fire and forget</em>
action. For example, low priority logging over a network.</p>

<h4 id="leanpub-auto-promise">
<a class="anchor-link" href="#leanpub-auto-promise"><i class="fa fa-link"></i></a><span class="section-number">7.7.5 </span><code>Promise</code>
</h4>

<p>A promise represents an asynchronous variable that can be set exactly once (with
<code>complete</code> or <code>error</code>). An unbounded number of listeners can <code>get</code> the variable.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class Promise[E, A] private (ref: AtomicReference[State[E, A]]) {
    def complete[E2](a: A): IO[E2, Boolean] = ...
    def error[E2](e: E): IO[E2, Boolean] = ...
    def get: IO[E, A] = ...
  
    // interrupts all listeners
    def interrupt[E2](t: Throwable): IO[E2, Boolean] = ...
  }
  object Promise {
    def make[E, A]: IO[E, Promise[E, A]] = ...
  }
</pre></div>

</figure>

<p><code>Promise</code> is not something that we typically use in application code. It is a
building block for high level concurrency frameworks.</p>

<aside>
  <p>When an operation is guaranteed to succeed, the error type <code>E</code> is left as a free
type parameter so that the caller can specify their preference.</p>

</aside>

<h4 id="leanpub-auto-ioref">
<a class="anchor-link" href="#leanpub-auto-ioref"><i class="fa fa-link"></i></a><span class="section-number">7.7.6 </span><code>IORef</code>
</h4>

<p><code>IORef</code> is the <code>IO</code> equivalent of an atomic mutable variable.</p>

<p>We can read the variable and we have a variety of ways to write or update it.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class IORef[A] private (ref: AtomicReference[A]) {
    def read[E]: IO[E, A] = ...
  
    // write with immediate consistency guarantees
    def write[E](a: A): IO[E, Unit] = ...
    // write with eventual consistency guarantees
    def writeLater[E](a: A): IO[E, Unit] = ...
    // return true if an immediate write succeeded, false if not (and abort)
    def tryWrite[E](a: A): IO[E, Boolean] = ...
  
    // atomic primitives for updating the value
    def compareAndSet[E](prev: A, next: A): IO[E, Boolean] = ...
    def modify[E](f: A =&gt; A): IO[E, A] = ...
    def modifyFold[E, B](f: A =&gt; (B, A)): IO[E, B] = ...
  }
  object IORef {
    def apply[E, A](a: A): IO[E, IORef[A]] = ...
  }
</pre></div>

</figure>

<p><code>IORef</code> is another building block and can be used to provide a high performance
<code>MonadState</code>. For example, create a newtype specialised to <code>Task</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class StateTask[A](val io: Task[A]) extends AnyVal
  object StateTask {
    def create[S](initial: S): Task[MonadState[StateTask, S]] =
      for {
        ref &lt;- IORef(initial)
      } yield
        new MonadState[StateTask, S] {
          override def get       = new StateTask(ref.read)
          override def put(s: S) = new StateTask(ref.write(s))
          ...
        }
  }
</pre></div>

</figure>

<p>We can make use of this optimised <code>StateMonad</code> implementation in a <code>SafeApp</code>,
where our <code>.program</code> depends on optimised MTL typeclasses:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object FastState extends SafeApp {
    def program[F[_]](implicit F: MonadState[F, Int]): F[ExitStatus] = ...
  
    def run(@unused args: List[String]): IO[Void, ExitStatus] =
      for {
        stateMonad &lt;- StateTask.create(10)
        output     &lt;- program(stateMonad).io
      } yield output
  }
</pre></div>

</figure>

<p>A more realistic application would take a variety of algebras and typeclasses as
input.</p>

<aside>
  <p>This optimised <code>MonadState</code> is constructed in a way that breaks typeclass
coherence. Two instances having the same types may be managing different state.
It would be prudent to isolate the construction of all such instances to the
application’s entrypoint.</p>

</aside>

<h5 id="leanpub-auto-monadio">
<a class="anchor-link" href="#leanpub-auto-monadio"><i class="fa fa-link"></i></a><span class="section-number">7.7.6.1 </span><code>MonadIO</code>
</h5>

<p>The <code>MonadIO</code> that we previously studied was simplified to hide the <code>E</code>
parameter. The actual typeclass is</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait MonadIO[M[_], E] {
    def liftIO[A](io: IO[E, A])(implicit M: Monad[M]): M[A]
  }
</pre></div>

</figure>

<p>with a minor change to the boilerplate on the companion of our algebra,
accounting for the extra <code>E</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Lookup[F[_]] {
    def look: F[Int]
  }
  object Lookup {
    def liftIO[F[_]: Monad, E](io: Lookup[IO[E, ?]])(implicit M: MonadIO[F, E]) =
      new Lookup[F] {
        def look: F[Int] = M.liftIO(io.look)
      }
    ...
  }
</pre></div>

</figure>

<h3 id="leanpub-auto-summary-5">
<a class="anchor-link" href="#leanpub-auto-summary-5"><i class="fa fa-link"></i></a><span class="section-number">7.8 </span>Summary</h3>

<ol class="numeric">
  <li>The <code>Future</code> is broke, don’t go there.</li>
  <li>Manage stack safety with a <code>Trampoline</code>.</li>
  <li>The Monad Transformer Library (MTL) abstracts over common effects with typeclasses.</li>
  <li>Monad Transformers provide default implementations of the MTL.</li>
  <li>
<code>Free</code> data structures let us analyse, optimise and easily test our programs.</li>
  <li>
<code>IO</code> gives us the ability to implement algebras as effects on the world.</li>
  <li>
<code>IO</code> can perform effects in parallel and is a high performance backbone for any application.</li>
</ol>

<h2 id="leanpub-auto-typeclass-derivation">
<a class="anchor-link" href="#leanpub-auto-typeclass-derivation"><i class="fa fa-link"></i></a><span class="section-number">8. </span>Typeclass Derivation</h2>

<p>Typeclasses provide polymorphic functionality to our applications. But to use a
typeclass we need instances for our business domain objects.</p>

<p>The creation of a typeclass instance from existing instances is known as
<em>typeclass derivation</em> and is the topic of this chapter.</p>

<p>There are four approaches to typeclass derivation:</p>

<ol class="numeric">
  <li>Manual instances for every domain object. This is infeasible for real world
applications as it results in hundreds of lines of boilerplate for every line
of a <code>case class</code>. It is useful only for educational purposes and adhoc
performance optimisations.</li>
  <li>Abstract over the typeclass by an existing Scalaz typeclass. This is the
approach of <code>scalaz-deriving</code>, producing automated tests and derivations for
products and coproducts</li>
  <li>Macros. However, writing a macro for each typeclass requires an advanced and
experienced developer. Fortunately, Jon Pretty’s <a href="https://github.com/propensive/magnolia">Magnolia</a> library abstracts
over hand-rolled macros with a simple API, centralising the complex
interaction with the compiler.</li>
  <li>Write a generic program using the <a href="https://github.com/milessabin/shapeless/">Shapeless</a> library. The <code>implicit</code> mechanism
is a language within the Scala language and can be used to write programs at
the type level.</li>
</ol>

<p>In this chapter we will study increasingly complex typeclasses and their
derivations. We will begin with <code>scalaz-deriving</code> as the most principled
mechanism, repeating some lessons from Chapter 5 “Scalaz Typeclasses”, then
Magnolia (the easiest to use), finishing with Shapeless (the most powerful) for
typeclasses with complex derivation logic.</p>

<h3 id="leanpub-auto-running-examples">
<a class="anchor-link" href="#leanpub-auto-running-examples"><i class="fa fa-link"></i></a><span class="section-number">8.1 </span>Running Examples</h3>

<p>This chapter will show how to define derivations for five specific typeclasses.
Each example exhibits a feature that can be generalised:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Equal[A]  {
    // type parameter is in contravariant (parameter) position
    @op("===") def equal(a1: A, a2: A): Boolean
  }
  
  // for requesting default values of a type when testing
  @typeclass trait Default[A] {
    // type parameter is in covariant (return) position
    def default: String \/ A
  }
  
  @typeclass trait Semigroup[A] {
    // type parameter is in both covariant and contravariant position (invariant)
    @op("|+|") def append(x: A, y: =&gt;A): A
  }
  
  @typeclass trait JsEncoder[T] {
    // type parameter is in contravariant position and needs access to field names
    def toJson(t: T): JsValue
  }
  
  @typeclass trait JsDecoder[T] {
    // type parameter is in covariant position and needs access to field names
    def fromJson(j: JsValue): String \/ T
  }
</pre></div>

</figure>

<aside>
  <p>There is a school of thought that says serialisation formats, such as JSON and
XML, should <strong>not</strong> have typeclass encoders and decoders, because it can lead to
typeclass decoherence (i.e. more than one encoder or decoder may exist for the
same type). The alternative is to use algebras and avoid using the <code>implicit</code>
language feature entirely.</p>

  <p>Although it is possible to apply the techniques in this chapter to either
typeclass or algebra derivation, the latter involves a <strong>lot</strong> more boilerplate.
We therefore consciously choose to restrict our study to encoders and decoders
that are coherent. As we will see later in this chapter, use-site automatic
derivation with Magnolia and Shapeless, combined with limitations of the Scala
compiler’s implicit search, commonly leads to typeclass decoherence.</p>

</aside>

<h3 id="leanpub-auto-scalaz-deriving">
<a class="anchor-link" href="#leanpub-auto-scalaz-deriving"><i class="fa fa-link"></i></a><span class="section-number">8.2 </span><code>scalaz-deriving</code>
</h3>

<p>The <code>scalaz-deriving</code> library is an extension to Scalaz and can be added to a
project’s <code>build.sbt</code> with</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val derivingVersion = "1.0.0"
  libraryDependencies += "org.scalaz" %% "scalaz-deriving" % derivingVersion
</pre></div>

</figure>

<p>providing new typeclasses, shown below in relation to core Scalaz typeclasses:</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 60%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-deriving-base.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<aside>
  <p>In Scalaz 7.3, <code>Applicative</code> and <code>Divisible</code> will inherit from <code>InvariantApplicative</code></p>

</aside>

<p>Before we proceed, here is a quick recap of the core Scalaz typeclasses:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait InvariantFunctor[F[_]] {
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B]
  }
  
  @typeclass trait Contravariant[F[_]] extends InvariantFunctor[F] {
    def contramap[A, B](fa: F[A])(f: B =&gt; A): F[B]
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B] = contramap(fa)(g)
  }
  
  @typeclass trait Divisible[F[_]] extends Contravariant[F] {
    def conquer[A]: F[A]
    def divide2[A, B, C](fa: F[A], fb: F[B])(f: C =&gt; (A, B)): F[C]
    ...
    def divide22[...] = ...
  }
  
  @typeclass trait Functor[F[_]] extends InvariantFunctor[F] {
    def map[A, B](fa: F[A])(f: A =&gt; B): F[B]
    def xmap[A, B](fa: F[A], f: A =&gt; B, g: B =&gt; A): F[B] = map(fa)(f)
  }
  
  @typeclass trait Applicative[F[_]] extends Functor[F] {
    def point[A](a: =&gt;A): F[A]
    def apply2[A,B,C](fa: =&gt;F[A], fb: =&gt;F[B])(f: (A, B) =&gt; C): F[C] = ...
    ...
    def apply12[...]
  }
  
  @typeclass trait Monad[F[_]] extends Functor[F] {
    @op("&gt;&gt;=") def bind[A, B](fa: F[A])(f: A =&gt; F[B]): F[B]
  }
  @typeclass trait MonadError[F[_], E] extends Monad[F] {
    def raiseError[A](e: E): F[A]
    def emap[A, B](fa: F[A])(f: A =&gt; E \/ B): F[B] = ...
    ...
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-dont-repeat-yourself">
<a class="anchor-link" href="#leanpub-auto-dont-repeat-yourself"><i class="fa fa-link"></i></a><span class="section-number">8.2.1 </span>Don’t Repeat Yourself</h4>

<p>The simplest way to derive a typeclass is to reuse one that already exists.</p>

<p>The <code>Equal</code> typeclass has an instance of <code>Contravariant[Equal]</code>, providing
<code>.contramap</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Equal {
    implicit val contravariant = new Contravariant[Equal] {
      def contramap[A, B](fa: Equal[A])(f: B =&gt; A): Equal[B] =
        (b1, b2) =&gt; fa.equal(f(b1), f(b2))
    }
    ...
  }
</pre></div>

</figure>

<p>As users of <code>Equal</code>, we can use <code>.contramap</code> for our single parameter data
types. Recall that typeclass instances go on the data type companions to be in
their implicit scope:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Foo(s: String)
  object Foo {
    implicit val equal: Equal[Foo] = Equal[String].contramap(_.s)
  }
  
  scala&gt; Foo("hello") === Foo("world")
  false
</pre></div>

</figure>

<p>However, not all typeclasses can have an instance of <code>Contravariant</code>. In
particular, typeclasses with type parameters in covariant position may have a
<code>Functor</code> instead:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Default {
    def instance[A](d: =&gt;String \/ A) = new Default[A] { def default = d }
    implicit val string: Default[String] = instance("".right)
  
    implicit val functor: Functor[Default] = new Functor[Default] {
      def map[A, B](fa: Default[A])(f: A =&gt; B): Default[B] = instance(fa.default.map(f))
    }
    ...
  }
</pre></div>

</figure>

<p>We can now derive a <code>Default[Foo]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Foo {
    implicit val default: Default[Foo] = Default[String].map(Foo(_))
    ...
  }
</pre></div>

</figure>

<p>If a typeclass has parameters in both covariant and contravariant position, as
is the case with <code>Semigroup</code>, it may provide an <code>InvariantFunctor</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Semigroup {
    implicit val invariant = new InvariantFunctor[Semigroup] {
      def xmap[A, B](ma: Semigroup[A], f: A =&gt; B, g: B =&gt; A) = new Semigroup[B] {
        def append(x: B, y: =&gt;B): B = f(ma.append(g(x), g(y)))
      }
    }
    ...
  }
</pre></div>

</figure>

<p>and we can call <code>.xmap</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Foo {
    implicit val semigroup: Semigroup[Foo] = Semigroup[String].xmap(Foo(_), _.s)
    ...
  }
</pre></div>

</figure>

<p>Generally, it is simpler to just use <code>.xmap</code> instead of <code>.map</code> or <code>.contramap</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Foo(s: String)
  object Foo {
    implicit val equal: Equal[Foo]         = Equal[String].xmap(Foo(_), _.s)
    implicit val default: Default[Foo]     = Default[String].xmap(Foo(_), _.s)
    implicit val semigroup: Semigroup[Foo] = Semigroup[String].xmap(Foo(_), _.s)
  }
</pre></div>

</figure>

<aside>
  <p>The <code>@xderiving</code> annotation automatically inserts <code>.xmap</code> boilerplate. Add the
following to <code>build.sbt</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  addCompilerPlugin("org.scalaz" %% "deriving-plugin" % derivingVersion)
  libraryDependencies += "org.scalaz" %% "deriving-macro" % derivingVersion % "provided"
</pre></div>

  </figure>

  <p>and use it as</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  @xderiving(Equal, Default, Semigroup)
  final case class Foo(s: String)
</pre></div>

  </figure>

</aside>

<h4 id="leanpub-auto-monaderror">
<a class="anchor-link" href="#leanpub-auto-monaderror"><i class="fa fa-link"></i></a><span class="section-number">8.2.2 </span><code>MonadError</code>
</h4>

<p>Typically things that <em>write</em> from a polymorphic value have a <code>Contravariant</code>,
and things that <em>read</em> into a polymorphic value have a <code>Functor</code>. However, it is
very much expected that reading can fail. For example, if we have a default
<code>String</code> it does not mean that we can simply derive a default <code>String Refined
NonEmpty</code> from it</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import eu.timepit.refined.refineV
  import eu.timepit.refined.api._
  import eu.timepit.refined.collection._
  
  implicit val nes: Default[String Refined NonEmpty] =
    Default[String].map(refineV[NonEmpty](_))
</pre></div>

</figure>

<p>fails to compile with</p>

<figure class="code">
<div class="highlight"><pre><code></code>  [error] default.scala:41:32: polymorphic expression cannot be instantiated to expected type;
  [error]  found   : Either[String, String Refined NonEmpty]
  [error]  required: String Refined NonEmpty
  [error]     Default[String].map(refineV[NonEmpty](_))
  [error]                                          ^
</pre></div>

</figure>

<p>Recall from Chapter 4.1 that <code>refineV</code> returns an <code>Either</code>, as the compiler has
reminded us.</p>

<p>As the typeclass author of <code>Default</code>, we can do better than <code>Functor</code> and
provide a <code>MonadError[Default, String]</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val monad = new MonadError[Default, String] {
    def point[A](a: =&gt;A): Default[A] =
      instance(a.right)
    def bind[A, B](fa: Default[A])(f: A =&gt; Default[B]): Default[B] =
      instance((fa &gt;&gt;= f).default)
    def handleError[A](fa: Default[A])(f: String =&gt; Default[A]): Default[A] =
      instance(fa.default.handleError(e =&gt; f(e).default))
    def raiseError[A](e: String): Default[A] =
      instance(e.left)
  }
</pre></div>

</figure>

<p>Now we have access to <code>.emap</code> syntax and can derive our refined type</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val nes: Default[String Refined NonEmpty] =
    Default[String].emap(refineV[NonEmpty](_).disjunction)
</pre></div>

</figure>

<p>In fact, we can provide a derivation rule for all refined types</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def refined[A: Default, P](
    implicit V: Validate[A, P]
  ): Default[A Refined P] = Default[A].emap(refineV[P](_).disjunction)
</pre></div>

</figure>

<p>where <code>Validate</code> is from the refined library and is required by <code>refineV</code>.</p>

<aside>
  <p>The <code>refined-scalaz</code> extension to <code>refined</code> provides support for automatically
deriving all typeclasses for refined types with the following import</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  import eu.timepit.refined.scalaz._
</pre></div>

  </figure>

  <p>if there is a <code>Contravariant</code> or <code>MonadError[?, String]</code> in the implicit scope.</p>

  <p>However, due to <a href="https://github.com/scala/bug/issues/10753">limitations of the Scala compiler</a> it rarely works in practice
and we must write <code>implicit def refined</code> derivations for each typeclass.</p>

</aside>

<p>Similarly we can use <code>.emap</code> to derive an <code>Int</code> decoder from a <code>Long</code>, with
protection around the non-total <code>.toInt</code> stdlib method.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val long: Default[Long] = instance(0L.right)
  implicit val int: Default[Int] = Default[Long].emap {
    case n if (Int.MinValue &lt;= n &amp;&amp; n &lt;= Int.MaxValue) =&gt; n.toInt.right
    case big =&gt; s"$big does not fit into 32 bits".left
  }
</pre></div>

</figure>

<p>As authors of the <code>Default</code> typeclass, we might want to reconsider our API
design so that it can never fail, e.g. with the following type signature</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Default[A] {
    def default: A
  }
</pre></div>

</figure>

<p>We would not be able to define a <code>MonadError</code>, forcing us to provide instances
that always succeed. This will result in more boilerplate but gains compiletime
safety. However, we will continue with <code>String \/ A</code> as the return type as it is
a more general example.</p>

<h4 id="leanpub-auto-fromiso">
<a class="anchor-link" href="#leanpub-auto-fromiso"><i class="fa fa-link"></i></a><span class="section-number">8.2.3 </span><code>.fromIso</code>
</h4>

<p>All of the typeclasses in Scalaz have a method on their companion with a
signature similar to the following:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Equal {
    def fromIso[F, G: Equal](D: F &lt;=&gt; G): Equal[F] = ...
    ...
  }
  
  object Monad {
    def fromIso[F[_], G[_]: Monad](D: F &lt;~&gt; G): Monad[F] = ...
    ...
  }
</pre></div>

</figure>

<p>These mean that if we have a type <code>F</code>, and a way to convert it into a <code>G</code> that
has an instance, we can call <code>Equal.fromIso</code> to obtain an instance for <code>F</code>.</p>

<p>For example, as typeclass users, if we have a data type <code>Bar</code> we can define an
isomorphism to <code>(String, Int)</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Isomorphism._
  
  final case class Bar(s: String, i: Int)
  object Bar {
    val iso: Bar &lt;=&gt; (String, Int) = IsoSet(b =&gt; (b.s, b.i), t =&gt; Bar(t._1, t._2))
  }
</pre></div>

</figure>

<p>and then derive <code>Equal[Bar]</code> because there is already an <code>Equal</code> for all tuples:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Bar {
    ...
    implicit val equal: Equal[Bar] = Equal.fromIso(iso)
  }
</pre></div>

</figure>

<p>The <code>.fromIso</code> mechanism can also assist us as typeclass authors. Consider
<code>Default</code> which has a core type signature of the form <code>Unit =&gt; F[A]</code>. Our
<code>default</code> method is in fact isomorphic to <code>Kleisli[F, Unit, A]</code>, the <code>ReaderT</code>
monad transformer.</p>

<p>Since <code>Kleisli</code> already provides a <code>MonadError</code> (if <code>F</code> has one), we can derive
<code>MonadError[Default, String]</code> by creating an isomorphism between <code>Default</code> and
<code>Kleisli</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private type Sig[a] = Unit =&gt; String \/ a
  private val iso = Kleisli.iso(
    λ[Sig ~&gt; Default](s =&gt; instance(s(()))),
    λ[Default ~&gt; Sig](d =&gt; _ =&gt; d.default)
  )
  implicit val monad: MonadError[Default, String] = MonadError.fromIso(iso)
</pre></div>

</figure>

<p>giving us the <code>.map</code>, <code>.xmap</code> and <code>.emap</code> that we’ve been making use of so far,
effectively for free.</p>

<h4 id="leanpub-auto-divisible-and-applicative">
<a class="anchor-link" href="#leanpub-auto-divisible-and-applicative"><i class="fa fa-link"></i></a><span class="section-number">8.2.4 </span><code>Divisible</code> and <code>Applicative</code>
</h4>

<p>To derive the <code>Equal</code> for our case class with two parameters, we reused the
instance that Scalaz provides for tuples. But where did the tuple instance come
from?</p>

<p>A more specific typeclass than <code>Contravariant</code> is <code>Divisible</code>. <code>Equal</code> has an
instance:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val divisible = new Divisible[Equal] {
    ...
    def divide[A1, A2, Z](a1: =&gt;Equal[A1], a2: =&gt;Equal[A2])(
      f: Z =&gt; (A1, A2)
    ): Equal[Z] = { (z1, z2) =&gt;
      val (s1, s2) = f(z1)
      val (t1, t2) = f(z2)
      a1.equal(s1, t1) &amp;&amp; a2.equal(s2, t2)
    }
    def conquer[A]: Equal[A] = (_, _) =&gt; true
  }
</pre></div>

</figure>

<aside>
  <p>When implementing <code>Divisible</code> the compiler will require us to provide
<code>.contramap</code>, which we can do directly with an optimised implementation or with
this derived combinator:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  override def contramap[A, B](fa: F[A])(f: B =&gt; A): F[B] =
    divide2(conquer[Unit], fa)(c =&gt; ((), f(c)))
</pre></div>

  </figure>

  <p>This has been added to <code>Divisible</code> in Scalaz 7.3.</p>

</aside>

<p>And from <code>divide2</code>, <code>Divisible</code> is able to build up derivations all the way to
<code>divide22</code>. We can call these methods directly for our data types:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Bar(s: String, i: Int)
  object Bar {
    implicit val equal: Equal[Bar] =
      Divisible[Equal].divide2(Equal[String], Equal[Int])(b =&gt; (b.s, b.i))
  }
</pre></div>

</figure>

<p>The equivalent for type parameters in covariant position is <code>Applicative</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Bar {
    ...
    implicit val default: Default[Bar] =
      Applicative[Default].apply2(Default[String], Default[Int])(Bar(_, _))
  }
</pre></div>

</figure>

<p>But we must be careful that we do not break the typeclass laws when we implement
<code>Divisible</code> or <code>Applicative</code>. In particular, it is easy to break the <em>law of
composition</em> which says that the following two codepaths must yield exactly the
same output</p>

<ul>
  <li><code>divide2(divide2(a1, a2)(dupe), a3)(dupe)</code></li>
  <li><code>divide2(a1, divide2(a2, a3)(dupe))(dupe)</code></li>
  <li>for any <code>dupe: A =&gt; (A, A)</code>
</li>
</ul>

<p>with similar laws for <code>Applicative</code>.</p>

<p>Consider <code>JsEncoder</code> and a proposed instance of <code>Divisible</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  new Divisible[JsEncoder] {
    ...
    def divide[A, B, C](fa: JsEncoder[A], fb: JsEncoder[B])(
      f: C =&gt; (A, B)
    ): JsEncoder[C] = { c =&gt;
      val (a, b) = f(c)
      JsArray(IList(fa.toJson(a), fb.toJson(b)))
    }
  
    def conquer[A]: JsEncoder[A] = _ =&gt; JsNull
  }
</pre></div>

</figure>

<p>On one side of the composition laws, for a <code>String</code> input, we get</p>

<figure class="code">
<div class="highlight"><pre><code></code>  JsArray([JsArray([JsString(hello),JsString(hello)]),JsString(hello)])
</pre></div>

</figure>

<p>and on the other</p>

<figure class="code">
<div class="highlight"><pre><code></code>  JsArray([JsString(hello),JsArray([JsString(hello),JsString(hello)])])
</pre></div>

</figure>

<p>which are different. We could experiment with variations of the <code>divide</code>
implementation, but it will never satisfy the laws for all inputs.</p>

<p>We therefore cannot provide a <code>Divisible[JsEncoder]</code> because it would break the
mathematical laws and invalidates all the assumptions that users of <code>Divisible</code>
rely upon.</p>

<p>To aid in testing laws, Scalaz typeclasses contain the codified versions of
their laws on the typeclass itself. We can write an automated test, asserting
that the law fails, to remind us of this fact:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val D: Divisible[JsEncoder] = ...
  val S: JsEncoder[String] = JsEncoder[String]
  val E: Equal[JsEncoder[String]] = (p1, p2) =&gt; p1.toJson("hello") === p2.toJson("hello")
  assert(!D.divideLaw.composition(S, S, S)(E))
</pre></div>

</figure>

<p>On the other hand, a similar <code>JsDecoder</code> test meets the <code>Applicative</code> composition laws</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Comp(a: String, b: Int)
  object Comp {
    implicit val equal: Equal[Comp] = ...
    implicit val decoder: JsDecoder[Comp] = ...
  }
  
  def composeTest(j: JsValue) = {
    val A: Applicative[JsDecoder] = Applicative[JsDecoder]
    val fa: JsDecoder[Comp] = JsDecoder[Comp]
    val fab: JsDecoder[Comp =&gt; (String, Int)] = A.point(c =&gt; (c.a, c.b))
    val fbc: JsDecoder[((String, Int)) =&gt; (Int, String)] = A.point(_.swap)
    val E: Equal[JsDecoder[(Int, String)]] = (p1, p2) =&gt; p1.fromJson(j) === p2.fromJson(j)
    assert(A.applyLaw.composition(fbc, fab, fa)(E))
  }
</pre></div>

</figure>

<p>for some test data</p>

<figure class="code">
<div class="highlight"><pre><code></code>  composeTest(JsObject(IList("a" -&gt; JsString("hello"), "b" -&gt; JsInteger(1))))
  composeTest(JsNull)
  composeTest(JsObject(IList("a" -&gt; JsString("hello"))))
  composeTest(JsObject(IList("b" -&gt; JsInteger(1))))
</pre></div>

</figure>

<p>Now we are reasonably confident that our derived <code>MonadError</code> is lawful.</p>

<p>However, just because we have a test that passes for a small set of data does
not prove that the laws are satisfied. We must also reason through the
implementation to convince ourselves that it <strong>should</strong> satisfy the laws, and try
to propose corner cases where it could fail.</p>

<p>One way of generating a wide variety of test data is to use the <a href="https://github.com/rickynils/scalacheck">scalacheck</a>
library, which provides an <code>Arbitrary</code> typeclass that integrates with most
testing frameworks to repeat a test with randomly generated data.</p>

<p>The <code>jsonformat</code> library provides an <code>Arbitrary[JsValue]</code> (everybody should
provide an <code>Arbitrary</code> for their ADTs!) allowing us to make use of Scalatest’s
<code>forAll</code> feature:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  forAll(SizeRange(10))((j: JsValue) =&gt; composeTest(j))
</pre></div>

</figure>

<p>This test gives us even more confidence that our typeclass meets the
<code>Applicative</code> composition laws. By checking all the laws on <code>Divisible</code> and
<code>MonadError</code> we also get <strong>a lot</strong> of smoke tests for free.</p>

<aside>
  <p>We must restrict <code>forAll</code> to have a <code>SizeRange</code> of <code>10</code>, which limits both
<code>JsObject</code> and <code>JsArray</code> to a maximum size of 10 elements. This avoids stack
overflows as larger numbers can generate gigantic JSON documents.</p>

</aside>

<h4 id="leanpub-auto-decidable-and-alt">
<a class="anchor-link" href="#leanpub-auto-decidable-and-alt"><i class="fa fa-link"></i></a><span class="section-number">8.2.5 </span><code>Decidable</code> and <code>Alt</code>
</h4>

<p>Where <code>Divisible</code> and <code>Applicative</code> give us typeclass derivation for products
(built from tuples), <code>Decidable</code> and <code>Alt</code> give us the coproducts (built from
nested disjunctions):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait Alt[F[_]] extends Applicative[F] with InvariantAlt[F] {
    def alt[A](a1: =&gt;F[A], a2: =&gt;F[A]): F[A]
  
    def altly1[Z, A1](a1: =&gt;F[A1])(f: A1 =&gt; Z): F[Z] = ...
    def altly2[Z, A1, A2](a1: =&gt;F[A1], a2: =&gt;F[A2])(f: A1 \/ A2 =&gt; Z): F[Z] = ...
    def altly3 ...
    def altly4 ...
    ...
  }
  
  @typeclass trait Decidable[F[_]] extends Divisible[F] with InvariantAlt[F] {
    def choose1[Z, A1](a1: =&gt;F[A1])(f: Z =&gt; A1): F[Z] = ...
    def choose2[Z, A1, A2](a1: =&gt;F[A1], a2: =&gt;F[A2])(f: Z =&gt; A1 \/ A2): F[Z] = ...
    def choose3 ...
    def choose4 ...
    ...
  }
</pre></div>

</figure>

<p>The four core typeclasses have symmetric signatures:</p>

<table>
  <thead>
    <tr>
      <th>Typeclass</th>
      <th>method</th>
      <th>given</th>
      <th>signature</th>
      <th>returns</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>Applicative</code></td>
      <td><code>apply2</code></td>
      <td><code>F[A1], F[A2]</code></td>
      <td><code>(A1, A2) =&gt; Z</code></td>
      <td><code>F[Z]</code></td>
    </tr>
    <tr>
      <td><code>Alt</code></td>
      <td><code>altly2</code></td>
      <td><code>F[A1], F[A2]</code></td>
      <td><code>(A1 \/ A2) =&gt; Z</code></td>
      <td><code>F[Z]</code></td>
    </tr>
    <tr>
      <td><code>Divisible</code></td>
      <td><code>divide2</code></td>
      <td><code>F[A1], F[A2]</code></td>
      <td><code>Z =&gt; (A1, A2)</code></td>
      <td><code>F[Z]</code></td>
    </tr>
    <tr>
      <td><code>Decidable</code></td>
      <td><code>choose2</code></td>
      <td><code>F[A1], F[A2]</code></td>
      <td><code>Z =&gt; (A1 \/ A2)</code></td>
      <td><code>F[Z]</code></td>
    </tr>
  </tbody>

</table>

<p>supporting covariant products; covariant coproducts; contravariant products;
contravariant coproducts.</p>

<p>We can write a <code>Decidable[Equal]</code>, letting us derive <code>Equal</code> for any ADT!</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val decidable = new Decidable[Equal] {
    ...
    def choose2[Z, A1, A2](a1: =&gt;Equal[A1], a2: =&gt;Equal[A2])(
      f: Z =&gt; A1 \/ A2
    ): Equal[Z] = { (z1, z2) =&gt;
      (f(z1), f(z2)) match {
        case (-\/(s), -\/(t)) =&gt; a1.equal(s, t)
        case (\/-(s), \/-(t)) =&gt; a2.equal(s, t)
        case _ =&gt; false
      }
    }
  }
</pre></div>

</figure>

<p>For an ADT</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Darth { def widen: Darth = this }
  final case class Vader(s: String, i: Int)  extends Darth
  final case class JarJar(i: Int, s: String) extends Darth
</pre></div>

</figure>

<p>where the products (<code>Vader</code> and <code>JarJar</code>) have an <code>Equal</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Vader {
    private val g: Vader =&gt; (String, Int) = d =&gt; (d.s, d.i)
    implicit val equal: Equal[Vader] = Divisible[Equal].divide2(Equal[String], Equal[Int])(g)
  }
  object JarJar {
    private val g: JarJar =&gt; (Int, String) = d =&gt; (d.i, d.s)
    implicit val equal: Equal[JarJar] = Divisible[Equal].divide2(Equal[Int], Equal[String])(g)
  }
</pre></div>

</figure>

<p>we can derive the equal for the whole ADT</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Darth {
    private def g(t: Darth): Vader \/ JarJar = t match {
      case p @ Vader(_, _)  =&gt; -\/(p)
      case p @ JarJar(_, _) =&gt; \/-(p)
    }
    implicit val equal: Equal[Darth] = Decidable[Equal].choose2(Equal[Vader], Equal[JarJar])(g)
  }
  
  scala&gt; Vader("hello", 1).widen === JarJar(1, "hello).widen
  false
</pre></div>

</figure>

<aside>
  <p>Scalaz 7.2 does not provide a <code>Decidable[Equal]</code> out of the box, because it was
a late addition.</p>

</aside>

<p>Typeclasses that have an <code>Applicative</code> can be eligible for an <code>Alt</code>. If we want
to use our <code>Kleisli.iso</code> trick, we have to extend <code>IsomorphismMonadError</code> and
mix in <code>Alt</code>. Upgrade our <code>MonadError[Default, String]</code> to have an
<code>Alt[Default]</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private type K[a] = Kleisli[String \/ ?, Unit, a]
  implicit val monad = new IsomorphismMonadError[Default, K, String] with Alt[Default] {
    override val G = MonadError[K, String]
    override val iso = ...
  
    def alt[A](a1: =&gt;Default[A], a2: =&gt;Default[A]): Default[A] = instance(a1.default)
  }
</pre></div>

</figure>

<aside>
  <p>The primitive of <code>Alt</code> is <code>alt</code>, much as the primitive of <code>Applicative</code> is <code>ap</code>,
but it often makes more sense to use <code>altly2</code> and <code>apply2</code> as the primitives
with the following overrides:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  override def ap[A, B](fa: =&gt;F[A])(f: =&gt;F[A =&gt; B]): F[B] =
    apply2(fa, f)((a, abc) =&gt; abc(a))
  
  override def alt[A](a1: =&gt;F[A], a2: =&gt;F[A]): F[A] = altly2(a1, a2) {
    case -\/(a) =&gt; a
    case \/-(a) =&gt; a
  }
</pre></div>

  </figure>

  <p>Just don’t forget to implement <code>apply2</code> and <code>altly2</code> or there will be an
infinite loop at runtime.</p>

</aside>

<p>Letting us derive our <code>Default[Darth]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Darth {
    ...
    private def f(e: Vader \/ JarJar): Darth = e.merge
    implicit val default: Default[Darth] =
      Alt[Default].altly2(Default[Vader], Default[JarJar])(f)
  }
  object Vader {
    ...
    private val f: (String, Int) =&gt; Vader = Vader(_, _)
    implicit val default: Default[Vader] =
      Alt[Default].apply2(Default[String], Default[Int])(f)
  }
  object JarJar {
    ...
    private val f: (Int, String) =&gt; JarJar = JarJar(_, _)
    implicit val default: Default[JarJar] =
      Alt[Default].apply2(Default[Int], Default[String])(f)
  }
  
  scala&gt; Default[Darth].default
  \/-(Vader())
</pre></div>

</figure>

<p>Returning to the <code>scalaz-deriving</code> typeclasses, the invariant parents of <code>Alt</code>
and <code>Decidable</code> are:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait InvariantApplicative[F[_]] extends InvariantFunctor[F] {
    def xproduct0[Z](f: =&gt;Z): F[Z]
    def xproduct1[Z, A1](a1: =&gt;F[A1])(f: A1 =&gt; Z, g: Z =&gt; A1): F[Z] = ...
    def xproduct2 ...
    def xproduct3 ...
    def xproduct4 ...
  }
  
  @typeclass trait InvariantAlt[F[_]] extends InvariantApplicative[F] {
    def xcoproduct1[Z, A1](a1: =&gt;F[A1])(f: A1 =&gt; Z, g: Z =&gt; A1): F[Z] = ...
    def xcoproduct2 ...
    def xcoproduct3 ...
    def xcoproduct4 ...
  }
</pre></div>

</figure>

<p>supporting typeclasses with an <code>InvariantFunctor</code> like <code>Monoid</code> and <code>Semigroup</code>.</p>

<h4 id="leanpub-auto-arbitrary-arity-and-deriving">
<a class="anchor-link" href="#leanpub-auto-arbitrary-arity-and-deriving"><i class="fa fa-link"></i></a><span class="section-number">8.2.6 </span>Arbitrary Arity and <code>@deriving</code>
</h4>

<p>There are two problems with <code>InvariantApplicative</code> and <code>InvariantAlt</code>:</p>

<ol class="numeric">
  <li>they only support products of four fields and coproducts of four entries.</li>
  <li>there is a <strong>lot</strong> of boilerplate on the data type companions.</li>
</ol>

<p>In this section we solve both problems with additional typeclasses introduced by
<code>scalaz-deriving</code></p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 75%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/scalaz-deriving.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>Effectively, our four central typeclasses <code>Applicative</code>, <code>Divisible</code>, <code>Alt</code> and
<code>Decidable</code> all get extended to arbitrary arity using the <a href="https://github.com/frees-io/iota">iotaz</a> library, hence
the <code>z</code> postfix.</p>

<p>The iotaz library has three main types:</p>

<ul>
  <li>
<code>TList</code> which describes arbitrary length chains of types</li>
  <li>
<code>Prod[A &lt;: TList]</code> for products</li>
  <li>
<code>Cop[A &lt;: TList]</code> for coproducts</li>
</ul>

<p>By way of example, a <code>TList</code> representation of <code>Darth</code> from the previous
section is</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import iotaz._, TList._
  
  type DarthT  = Vader  :: JarJar :: TNil
  type VaderT  = String :: Int    :: TNil
  type JarJarT = Int    :: String :: TNil
</pre></div>

</figure>

<p>which can be instantiated:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val vader: Prod[VaderT]    = Prod("hello", 1)
  val jarjar: Prod[JarJarT]  = Prod(1, "hello")
  
  val VaderI = Cop.Inject[Vader, Cop[DarthT]]
  val darth: Cop[DarthT] = VaderI.inj(Vader("hello", 1))
</pre></div>

</figure>

<p>To be able to use the <code>scalaz-deriving</code> API, we need an <code>Isomorphism</code> between
our ADTs and the <code>iotaz</code> generic representation. It is a lot of boilerplate,
we will get to that in a moment:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Darth {
    private type Repr   = Vader :: JarJar :: TNil
    private val VaderI  = Cop.Inject[Vader, Cop[Repr]]
    private val JarJarI = Cop.Inject[JarJar, Cop[Repr]]
    private val iso     = IsoSet(
      {
        case d: Vader  =&gt; VaderI.inj(d)
        case d: JarJar =&gt; JarJarI.inj(d)
      }, {
        case VaderI(d)  =&gt; d
        case JarJarI(d) =&gt; d
      }
    )
    ...
  }
  
  object Vader {
    private type Repr = String :: Int :: TNil
    private val iso   = IsoSet(
      d =&gt; Prod(d.s, d.i),
      p =&gt; Vader(p.head, p.tail.head)
    )
    ...
  }
  
  object JarJar {
    private type Repr = Int :: String :: TNil
    private val iso   = IsoSet(
      d =&gt; Prod(d.i, d.s),
      p =&gt; JarJar(p.head, p.tail.head)
    )
    ...
  }
</pre></div>

</figure>

<p>With that out of the way we can call the <code>Deriving</code> API for <code>Equal</code>, possible
because <code>scalaz-deriving</code> provides an optimised instance of <code>Deriving[Equal]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Darth {
    ...
    implicit val equal: Equal[Darth] = Deriving[Equal].xcoproductz(
      Prod(Need(Equal[Vader]), Need(Equal[JarJar])))(iso.to, iso.from)
  }
  object Vader {
    ...
    implicit val equal: Equal[Vader] = Deriving[Equal].xproductz(
      Prod(Need(Equal[String]), Need(Equal[Int])))(iso.to, iso.from)
  }
  object JarJar {
    ...
    implicit val equal: Equal[JarJar] = Deriving[Equal].xproductz(
      Prod(Need(Equal[Int]), Need(Equal[String])))(iso.to, iso.from)
  }
</pre></div>

</figure>

<aside>
  <p>Typeclasses in the <code>Deriving</code> API are wrapped in <code>Need</code> (recall <code>Name</code> from
Chapter 6), which allows lazy construction, avoiding unnecessary work if the
typeclass is not needed, and avoiding stack overflows for recursive ADTs.</p>

</aside>

<p>To be able to do the same for our <code>Default</code> typeclass, we need to provide an
instance of <code>Deriving[Default]</code>. This is just a case of wrapping our existing
<code>Alt</code> with a helper:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Default {
    ...
    implicit val deriving: Deriving[Default] = ExtendedInvariantAlt(monad)
  }
</pre></div>

</figure>

<p>and then calling it from the companions</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Darth {
    ...
    implicit val default: Default[Darth] = Deriving[Default].xcoproductz(
      Prod(Need(Default[Vader]), Need(Default[JarJar])))(iso.to, iso.from)
  }
  object Vader {
    ...
    implicit val default: Default[Vader] = Deriving[Default].xproductz(
      Prod(Need(Default[String]), Need(Default[Int])))(iso.to, iso.from)
  }
  object JarJar {
    ...
    implicit val default: Default[JarJar] = Deriving[Default].xproductz(
      Prod(Need(Default[Int]), Need(Default[String])))(iso.to, iso.from)
  }
</pre></div>

</figure>

<p>We have solved the problem of arbitrary arity, but we have introduced even more
boilerplate.</p>

<p>The punchline is that the <code>@deriving</code> annotation, which comes from
<code>deriving-plugin</code>, generates all this boilerplate automatically and only needs
to be applied at the top level of an ADT:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(Equal, Default)
  sealed abstract class Darth { def widen: Darth = this }
  final case class Vader(s: String, i: Int)  extends Darth
  final case class JarJar(i: Int, s: String) extends Darth
</pre></div>

</figure>

<p>Also included in <code>scalaz-deriving</code> are instances for <code>Order</code>, <code>Semigroup</code> and
<code>Monoid</code>. Instances of <code>Show</code> and <code>Arbitrary</code> are available by installing the
<code>scalaz-deriving-magnolia</code> and <code>scalaz-deriving-scalacheck</code> extras.</p>

<p>You’re welcome!</p>

<h4 id="leanpub-auto-examples">
<a class="anchor-link" href="#leanpub-auto-examples"><i class="fa fa-link"></i></a><span class="section-number">8.2.7 </span>Examples</h4>

<p>We finish our study of <code>scalaz-deriving</code> with fully worked implementations of
all the example typeclasses. Before we do that we need to know about a new data
type: <code>/~\</code>, aka the <em>snake in the road</em>, for containing two higher kinded
structures that share the same type parameter:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class /~\[A[_], B[_]] {
    type T
    def a: A[T]
    def b: B[T]
  }
  object /~\ {
    type APair[A[_], B[_]]  = A /~\ B
    def unapply[A[_], B[_]](p: A /~\ B): Some[(A[p.T], B[p.T])] = ...
    def apply[A[_], B[_], Z](az: =&gt;A[Z], bz: =&gt;B[Z]): A /~\ B = ...
  }
</pre></div>

</figure>

<p>We typically use this in the context of <code>Id /~\ TC</code> where <code>TC</code> is our typeclass,
meaning that we have a value, and an instance of a typeclass for that value,
without knowing anything about the value.</p>

<p>In addition, all the methods on the <code>Deriving</code> API have implicit evidence of the
form <code>A PairedWith FA</code>, allowing the <code>iotaz</code> library to be able to perform
<code>.zip</code>, <code>.traverse</code>, and other operations on <code>Prod</code> and <code>Cop</code>. We can ignore
these parameters, as we don’t use them directly.</p>

<h5 id="leanpub-auto-equal">
<a class="anchor-link" href="#leanpub-auto-equal"><i class="fa fa-link"></i></a><span class="section-number">8.2.7.1 </span><code>Equal</code>
</h5>

<p>As with <code>Default</code> we could define a regular fixed-arity <code>Decidable</code> and wrap it
with <code>ExtendedInvariantAlt</code> (the simplest approach), but we choose to implement
<code>Decidablez</code> directly for the performance benefit. We make two additional
optimisations:</p>

<ol class="numeric">
  <li>perform instance equality <code>.eq</code> before applying the <code>Equal.equal</code>, allowing
for shortcut equality between identical values.</li>
  <li>
<code>Foldable.all</code> allowing early exit when any comparison is <code>false</code>. e.g. if
the first fields don’t match, we don’t even request the <code>Equal</code> for remaining
values.</li>
</ol>

<figure class="code">
<div class="highlight"><pre><code></code>  new Decidablez[Equal] {
    @inline private final def quick(a: Any, b: Any): Boolean =
      a.asInstanceOf[AnyRef].eq(b.asInstanceOf[AnyRef])
  
    def dividez[Z, A &lt;: TList, FA &lt;: TList](tcs: Prod[FA])(g: Z =&gt; Prod[A])(
      implicit ev: A PairedWith FA
    ): Equal[Z] = (z1, z2) =&gt; (g(z1), g(z2)).zip(tcs).all {
      case (a1, a2) /~\ fa =&gt; quick(a1, a2) || fa.value.equal(a1, a2)
    }
  
    def choosez[Z, A &lt;: TList, FA &lt;: TList](tcs: Prod[FA])(g: Z =&gt; Cop[A])(
      implicit ev: A PairedWith FA
    ): Equal[Z] = (z1, z2) =&gt; (g(z1), g(z2)).zip(tcs) match {
      case -\/(_)               =&gt; false
      case \/-((a1, a2) /~\ fa) =&gt; quick(a1, a2) || fa.value.equal(a1, a2)
    }
  }
</pre></div>

</figure>

<h5 id="leanpub-auto-default">
<a class="anchor-link" href="#leanpub-auto-default"><i class="fa fa-link"></i></a><span class="section-number">8.2.7.2 </span><code>Default</code>
</h5>

<p>Unfortunately, the <code>iotaz</code> API for <code>.traverse</code> (and its analogy, <code>.coptraverse</code>)
requires us to define natural transformations, which have a clunky syntax, even
with the <code>kind-projector</code> plugin.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private type K[a] = Kleisli[String \/ ?, Unit, a]
  new IsomorphismMonadError[Default, K, String] with Altz[Default] {
    type Sig[a] = Unit =&gt; String \/ a
    override val G = MonadError[K, String]
    override val iso = Kleisli.iso(
      λ[Sig ~&gt; Default](s =&gt; instance(s(()))),
      λ[Default ~&gt; Sig](d =&gt; _ =&gt; d.default)
    )
  
    val extract = λ[NameF ~&gt; (String \/ ?)](a =&gt; a.value.default)
    def applyz[Z, A &lt;: TList, FA &lt;: TList](tcs: Prod[FA])(f: Prod[A] =&gt; Z)(
      implicit ev: A PairedWith FA
    ): Default[Z] = instance(tcs.traverse(extract).map(f))
  
    val always = λ[NameF ~&gt; Maybe](a =&gt; a.value.default.toMaybe)
    def altlyz[Z, A &lt;: TList, FA &lt;: TList](tcs: Prod[FA])(f: Cop[A] =&gt; Z)(
      implicit ev: A PairedWith FA
    ): Default[Z] = instance {
      tcs.coptraverse[A, NameF, Id](always).map(f).headMaybe \/&gt; "not found"
    }
  }
</pre></div>

</figure>

<h5 id="leanpub-auto-semigroup">
<a class="anchor-link" href="#leanpub-auto-semigroup"><i class="fa fa-link"></i></a><span class="section-number">8.2.7.3 </span><code>Semigroup</code>
</h5>

<p>It is not possible to define a <code>Semigroup</code> for general coproducts, however it is
possible to define one for general products. We can use the arbitrary arity
<code>InvariantApplicative</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  new InvariantApplicativez[Semigroup] {
    type L[a] = ((a, a), NameF[a])
    val appender = λ[L ~&gt; Id] { case ((a1, a2), fa) =&gt; fa.value.append(a1, a2) }
  
    def xproductz[Z, A &lt;: TList, FA &lt;: TList](tcs: Prod[FA])
                                             (f: Prod[A] =&gt; Z, g: Z =&gt; Prod[A])
                                             (implicit ev: A PairedWith FA) =
      new Semigroup[Z] {
        def append(z1: Z, z2: =&gt;Z): Z = f(tcs.ziptraverse2(g(z1), g(z2), appender))
      }
  }
</pre></div>

</figure>

<h5 id="leanpub-auto-jsencoder-and-jsdecoder">
<a class="anchor-link" href="#leanpub-auto-jsencoder-and-jsdecoder"><i class="fa fa-link"></i></a><span class="section-number">8.2.7.4 </span><code>JsEncoder</code> and <code>JsDecoder</code>
</h5>

<p><code>scalaz-deriving</code> does not provide access to field names so it is not possible
to write a JSON encoder or decoder.</p>

<aside>
  <p>An earlier version of <code>scalaz-deriving</code> supported field names but it was clear
that there was no advantage over using Magnolia, so the support was dropped to
remain focused on typeclasses with lawful <code>Alt</code> and <code>Decidable</code>.</p>

</aside>

<h3 id="leanpub-auto-magnolia">
<a class="anchor-link" href="#leanpub-auto-magnolia"><i class="fa fa-link"></i></a><span class="section-number">8.3 </span>Magnolia</h3>

<p>The Magnolia macro library provides a clean API for writing typeclass
derivations. It is installed with the following <code>build.sbt</code> entry</p>

<figure class="code">
<div class="highlight"><pre><code></code>  libraryDependencies += "com.propensive" %% "magnolia" % "0.10.1"
</pre></div>

</figure>

<p>A typeclass author implements the following members:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import magnolia._
  
  object MyDerivation {
    type Typeclass[A]
  
    def combine[A](ctx: CaseClass[Typeclass, A]): Typeclass[A]
    def dispatch[A](ctx: SealedTrait[Typeclass, A]): Typeclass[A]
  
    def gen[A]: Typeclass[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>The Magnolia API is:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class CaseClass[TC[_], A] {
    def typeName: TypeName
    def construct[B](f: Param[TC, A] =&gt; B): A
    def constructMonadic[F[_]: Monadic, B](f: Param[TC, A] =&gt; F[B]): F[A]
    def parameters: Seq[Param[TC, A]]
    def annotations: Seq[Any]
  }
  
  class SealedTrait[TC[_], A] {
    def typeName: TypeName
    def subtypes: Seq[Subtype[TC, A]]
    def dispatch[B](value: A)(handle: Subtype[TC, A] =&gt; B): B
    def annotations: Seq[Any]
  }
</pre></div>

</figure>

<p>with helpers</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class TypeName(short: String, full: String)
  
  class Param[TC[_], A] {
    type PType
    def label: String
    def index: Int
    def typeclass: TC[PType]
    def dereference(param: A): PType
    def default: Option[PType]
    def annotations: Seq[Any]
  }
  
  class Subtype[TC[_], A] {
    type SType &lt;: A
    def typeName: TypeName
    def index: Int
    def typeclass: TC[SType]
    def cast(a: A): SType
    def annotations: Seq[Any]
  }
</pre></div>

</figure>

<p>The <code>Monadic</code> typeclass, used in <code>constructMonadic</code>, is automatically generated
if our data type has a <code>.map</code> and <code>.flatMap</code> method when we <code>import mercator._</code></p>

<p>It does not make sense to use Magnolia for typeclasses that can be abstracted by
<code>Divisible</code>, <code>Decidable</code>, <code>Applicative</code> or <code>Alt</code>, since those abstractions
provide a lot of extra structure and tests for free. However, Magnolia offers
features that <code>scalaz-deriving</code> cannot provide: access to field names, type
names, annotations and default values.</p>

<h4 id="leanpub-auto-example-json">
<a class="anchor-link" href="#leanpub-auto-example-json"><i class="fa fa-link"></i></a><span class="section-number">8.3.1 </span>Example: JSON</h4>

<p>We have some design choices to make with regards to JSON serialisation:</p>

<ol class="numeric">
  <li>Should we include fields with <code>null</code> values?</li>
  <li>Should decoding treat missing vs <code>null</code> differently?</li>
  <li>How do we encode the name of a coproduct?</li>
  <li>How do we deal with coproducts that are not <code>JsObject</code>?</li>
</ol>

<p>We choose sensible defaults</p>

<ul>
  <li>do not include fields if the value is a <code>JsNull</code>.</li>
  <li>handle missing fields the same as <code>null</code> values.</li>
  <li>use a special field <code>"type"</code> to disambiguate coproducts using the type name.</li>
  <li>put primitive values into a special field <code>"xvalue"</code>.</li>
</ul>

<p>and let the users attach an annotation to coproducts and product fields to
customise their formats:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed class json extends Annotation
  object json {
    final case class nulls()          extends json
    final case class field(f: String) extends json
    final case class hint(f: String)  extends json
  }
</pre></div>

</figure>

<aside>
  <p>Magnolia is not limited to one annotation family. This encoding is so that we
can do a like-for-like comparison with Shapeless in the next section.</p>

</aside>

<p>For example</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @json.field("TYPE")
  sealed abstract class Cost
  final case class Time(s: String) extends Cost
  final case class Money(@json.field("integer") i: Int) extends Cost
</pre></div>

</figure>

<p>Start with a <code>JsDecoder</code> that handles only our sensible defaults:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsMagnoliaEncoder {
    type Typeclass[A] = JsEncoder[A]
  
    def combine[A](ctx: CaseClass[JsEncoder, A]): JsEncoder[A] = { a =&gt;
      val empty = IList.empty[(String, JsValue)]
      val fields = ctx.parameters.foldRight(right) { (p, acc) =&gt;
        p.typeclass.toJson(p.dereference(a)) match {
          case JsNull =&gt; acc
          case value  =&gt; (p.label -&gt; value) :: acc
        }
      }
      JsObject(fields)
    }
  
    def dispatch[A](ctx: SealedTrait[JsEncoder, A]): JsEncoder[A] = a =&gt;
      ctx.dispatch(a) { sub =&gt;
        val hint = "type" -&gt; JsString(sub.typeName.short)
        sub.typeclass.toJson(sub.cast(a)) match {
          case JsObject(fields) =&gt; JsObject(hint :: fields)
          case other            =&gt; JsObject(IList(hint, "xvalue" -&gt; other))
        }
      }
  
    def gen[A]: JsEncoder[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>We can see how the Magnolia API makes it easy to access field names and
typeclasses for each parameter.</p>

<p>Now add support for annotations to handle user preferences. To avoid looking up
the annotations on every encoding, we will cache them in an array. Although field
access to an array is non-total, we are guaranteed that the indices will always
align. Performance is usually the victim in the trade-off between specialisation
and generalisation.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsMagnoliaEncoder {
    type Typeclass[A] = JsEncoder[A]
  
    def combine[A](ctx: CaseClass[JsEncoder, A]): JsEncoder[A] =
      new JsEncoder[A] {
        private val anns = ctx.parameters.map { p =&gt;
          val nulls = p.annotations.collectFirst {
            case json.nulls() =&gt; true
          }.getOrElse(false)
          val field = p.annotations.collectFirst {
            case json.field(name) =&gt; name
          }.getOrElse(p.label)
          (nulls, field)
        }.toArray
  
        def toJson(a: A): JsValue = {
          val empty = IList.empty[(String, JsValue)]
          val fields = ctx.parameters.foldRight(empty) { (p, acc) =&gt;
            val (nulls, field) = anns(p.index)
            p.typeclass.toJson(p.dereference(a)) match {
              case JsNull if !nulls =&gt; acc
              case value            =&gt; (field -&gt; value) :: acc
            }
          }
          JsObject(fields)
        }
      }
  
    def dispatch[A](ctx: SealedTrait[JsEncoder, A]): JsEncoder[A] =
      new JsEncoder[A] {
        private val field = ctx.annotations.collectFirst {
          case json.field(name) =&gt; name
        }.getOrElse("type")
        private val anns = ctx.subtypes.map { s =&gt;
          val hint = s.annotations.collectFirst {
            case json.hint(name) =&gt; field -&gt; JsString(name)
          }.getOrElse(field -&gt; JsString(s.typeName.short))
          val xvalue = s.annotations.collectFirst {
            case json.field(name) =&gt; name
          }.getOrElse("xvalue")
          (hint, xvalue)
        }.toArray
  
        def toJson(a: A): JsValue = ctx.dispatch(a) { sub =&gt;
          val (hint, xvalue) = anns(sub.index)
          sub.typeclass.toJson(sub.cast(a)) match {
            case JsObject(fields) =&gt; JsObject(hint :: fields)
            case other            =&gt; JsObject(hint :: (xvalue -&gt; other) :: IList.empty)
          }
        }
      }
  
    def gen[A]: JsEncoder[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>For the decoder we use <code>.constructMonadic</code> which has a type signature similar to
<code>.traverse</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsMagnoliaDecoder {
    type Typeclass[A] = JsDecoder[A]
  
    def combine[A](ctx: CaseClass[JsDecoder, A]): JsDecoder[A] = {
      case obj @ JsObject(_) =&gt;
        ctx.constructMonadic(
          p =&gt; p.typeclass.fromJson(obj.get(p.label).getOrElse(JsNull))
        )
      case other =&gt; fail("JsObject", other)
    }
  
    def dispatch[A](ctx: SealedTrait[JsDecoder, A]): JsDecoder[A] = {
      case obj @ JsObject(_) =&gt;
        obj.get("type") match {
          case \/-(JsString(hint)) =&gt;
            ctx.subtypes.find(_.typeName.short == hint) match {
              case None =&gt; fail(s"a valid '$hint'", obj)
              case Some(sub) =&gt;
                val value = obj.get("xvalue").getOrElse(obj)
                sub.typeclass.fromJson(value)
            }
          case _ =&gt; fail("JsObject with type", obj)
        }
      case other =&gt; fail("JsObject", other)
    }
  
    def gen[A]: JsDecoder[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>Again, adding support for user preferences and default field values, along with
some optimisations:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsMagnoliaDecoder {
    type Typeclass[A] = JsDecoder[A]
  
    def combine[A](ctx: CaseClass[JsDecoder, A]): JsDecoder[A] =
      new JsDecoder[A] {
        private val nulls = ctx.parameters.map { p =&gt;
          p.annotations.collectFirst {
            case json.nulls() =&gt; true
          }.getOrElse(false)
        }.toArray
  
        private val fieldnames = ctx.parameters.map { p =&gt;
          p.annotations.collectFirst {
            case json.field(name) =&gt; name
          }.getOrElse(p.label)
        }.toArray
  
        def fromJson(j: JsValue): String \/ A = j match {
          case obj @ JsObject(_) =&gt;
            import mercator._
            val lookup = obj.fields.toMap
            ctx.constructMonadic { p =&gt;
              val field = fieldnames(p.index)
              lookup
                .get(field)
                .into {
                  case Maybe.Just(value) =&gt; p.typeclass.fromJson(value)
                  case _ =&gt;
                    p.default match {
                      case Some(default) =&gt; \/-(default)
                      case None if nulls(p.index) =&gt;
                        s"missing field '$field'".left
                      case None =&gt; p.typeclass.fromJson(JsNull)
                    }
                }
            }
          case other =&gt; fail("JsObject", other)
        }
      }
  
    def dispatch[A](ctx: SealedTrait[JsDecoder, A]): JsDecoder[A] =
      new JsDecoder[A] {
        private val subtype = ctx.subtypes.map { s =&gt;
          s.annotations.collectFirst {
            case json.hint(name) =&gt; name
          }.getOrElse(s.typeName.short) -&gt; s
        }.toMap
        private val typehint = ctx.annotations.collectFirst {
          case json.field(name) =&gt; name
        }.getOrElse("type")
        private val xvalues = ctx.subtypes.map { sub =&gt;
          sub.annotations.collectFirst {
            case json.field(name) =&gt; name
          }.getOrElse("xvalue")
        }.toArray
  
        def fromJson(j: JsValue): String \/ A = j match {
          case obj @ JsObject(_) =&gt;
            obj.get(typehint) match {
              case \/-(JsString(h)) =&gt;
                subtype.get(h) match {
                  case None =&gt; fail(s"a valid '$h'", obj)
                  case Some(sub) =&gt;
                    val xvalue = xvalues(sub.index)
                    val value  = obj.get(xvalue).getOrElse(obj)
                    sub.typeclass.fromJson(value)
                }
              case _ =&gt; fail(s"JsObject with '$typehint' field", obj)
            }
          case other =&gt; fail("JsObject", other)
        }
      }
  
    def gen[A]: JsDecoder[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>We call the <code>JsMagnoliaEncoder.gen</code> or <code>JsMagnoliaDecoder.gen</code> method from the
companion of our data types. For example, the Google Maps API</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Value(text: String, value: Int)
  final case class Elements(distance: Value, duration: Value, status: String)
  final case class Rows(elements: List[Elements])
  final case class DistanceMatrix(
    destination_addresses: List[String],
    origin_addresses: List[String],
    rows: List[Rows],
    status: String
  )
  
  object Value {
    implicit val encoder: JsEncoder[Value] = JsMagnoliaEncoder.gen
    implicit val decoder: JsDecoder[Value] = JsMagnoliaDecoder.gen
  }
  object Elements {
    implicit val encoder: JsEncoder[Elements] = JsMagnoliaEncoder.gen
    implicit val decoder: JsDecoder[Elements] = JsMagnoliaDecoder.gen
  }
  object Rows {
    implicit val encoder: JsEncoder[Rows] = JsMagnoliaEncoder.gen
    implicit val decoder: JsDecoder[Rows] = JsMagnoliaDecoder.gen
  }
  object DistanceMatrix {
    implicit val encoder: JsEncoder[DistanceMatrix] = JsMagnoliaEncoder.gen
    implicit val decoder: JsDecoder[DistanceMatrix] = JsMagnoliaDecoder.gen
  }
</pre></div>

</figure>

<p>Thankfully, the <code>@deriving</code> annotation supports Magnolia! If the typeclass
author provides a file <code>deriving.conf</code> with their jar, containing this text</p>

<figure class="code">
<div class="highlight"><pre><code></code>  jsonformat.JsEncoder=jsonformat.JsMagnoliaEncoder.gen
  jsonformat.JsDecoder=jsonformat.JsMagnoliaDecoder.gen
</pre></div>

</figure>

<p>the <code>deriving-macro</code> will call the user-provided method:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(JsEncoder, JsDecoder)
  final case class Value(text: String, value: Int)
  @deriving(JsEncoder, JsDecoder)
  final case class Elements(distance: Value, duration: Value, status: String)
  @deriving(JsEncoder, JsDecoder)
  final case class Rows(elements: List[Elements])
  @deriving(JsEncoder, JsDecoder)
  final case class DistanceMatrix(
    destination_addresses: List[String],
    origin_addresses: List[String],
    rows: List[Rows],
    status: String
  )
</pre></div>

</figure>

<h4 id="leanpub-auto-fully-automatic-derivation">
<a class="anchor-link" href="#leanpub-auto-fully-automatic-derivation"><i class="fa fa-link"></i></a><span class="section-number">8.3.2 </span>Fully Automatic Derivation</h4>

<p>Generating <code>implicit</code> instances on the companion of the data type is
historically known as <em>semi-auto</em> derivation, in contrast to <em>full-auto</em> which
is when the <code>.gen</code> is made <code>implicit</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsMagnoliaEncoder {
    ...
    implicit def gen[A]: JsEncoder[A] = macro Magnolia.gen[A]
  }
  object JsMagnoliaDecoder {
    ...
    implicit def gen[A]: JsDecoder[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<p>Users can import these methods into their scope and get magical derivation at
the point of use</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; final case class Value(text: String, value: Int)
  scala&gt; import JsMagnoliaEncoder.gen
  scala&gt; Value("hello", 1).toJson
  res = JsObject([("text","hello"),("value",1)])
</pre></div>

</figure>

<p>This may sound tempting, as it involves the least amount of typing, but there
are two caveats:</p>

<ol class="numeric">
  <li>the macro is invoked at every use site, i.e. every time we call <code>.toJson</code>.
This slows down compilation and also produces more objects at runtime, which
will impact runtime performance.</li>
  <li>unexpected things may be derived.</li>
</ol>

<p>The first caveat is self evident, but unexpected derivations manifests as
subtle bugs. Consider what would happen for</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(JsEncoder)
  final case class Foo(s: Option[String])
</pre></div>

</figure>

<p>if we forgot to provide an implicit derivation for <code>Option</code>. We might expect a
<code>Foo(Some("hello"))</code> to look like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "s":"hello"
  }
</pre></div>

</figure>

<p>But it would instead be</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "s": {
      "type":"Some",
      "get":"hello"
    }
  }
</pre></div>

</figure>

<p>because Magnolia derived an <code>Option</code> encoder for us.</p>

<p>This is confusing, we would rather have the compiler tell us if we forgot
something. Full auto is therefore not recommended.</p>

<h3 id="leanpub-auto-shapeless">
<a class="anchor-link" href="#leanpub-auto-shapeless"><i class="fa fa-link"></i></a><span class="section-number">8.4 </span>Shapeless</h3>

<p>The <a href="https://github.com/milessabin/shapeless/">Shapeless</a> library is notoriously the most complicated library in Scala. The
reason why it has such a reputation is because it takes the <code>implicit</code> language
feature to the extreme: creating a kind of <em>generic programming</em> language at the
level of the types.</p>

<p>This is not an entirely foreign concept: in Scalaz we try to limit our use of
the <code>implicit</code> language feature to typeclasses, but we sometimes ask the
compiler to provide us with <em>evidence</em> relating types. For example Liskov or
Leibniz relationship (<code>&lt;~&lt;</code> and <code>===</code>), and to <code>Inject</code> a free algebra into a
<code>scalaz.Coproduct</code> of algebras.</p>

<aside>
  <p>It is not necessary to understand Shapeless to be a Functional Programmer. If
this chapter becomes too much, just skip to the next section.</p>

</aside>

<p>To install Shapeless, add the following to <code>build.sbt</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  libraryDependencies += "com.chuusai" %% "shapeless" % "2.3.3"
</pre></div>

</figure>

<p>At the core of Shapeless are the <code>HList</code> and <code>Coproduct</code> data types</p>

<figure class="code">
<div class="highlight"><pre><code></code>  package shapeless
  
  sealed trait HList
  final case class ::[+H, +T &lt;: HList](head: H, tail: T) extends HList
  sealed trait NNil extends HList
  case object HNil extends HNil {
    def ::[H](h: H): H :: HNil = ::(h, this)
  }
  
  sealed trait Coproduct
  sealed trait :+:[+H, +T &lt;: Coproduct] extends Coproduct
  final case class Inl[+H, +T &lt;: Coproduct](head: H) extends :+:[H, T]
  final case class Inr[+H, +T &lt;: Coproduct](tail: T) extends :+:[H, T]
  sealed trait CNil extends Coproduct // no implementations
</pre></div>

</figure>

<p>which are <em>generic</em> representations of products and coproducts, respectively.
The <code>sealed trait HNil</code> is for convenience so we never need to type <code>HNil.type</code>.</p>

<p>Shapeless has a clone of the <code>IsoSet</code> datatype, called <code>Generic</code>, which allows
us to move between an ADT and its generic representation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Generic[T] {
    type Repr
    def to(t: T): Repr
    def from(r: Repr): T
  }
  object Generic {
    type Aux[T, R] = Generic[T] { type Repr = R }
    def apply[T](implicit G: Generic[T]): Aux[T, G.Repr] = G
    implicit def materialize[T, R]: Aux[T, R] = macro ...
  }
</pre></div>

</figure>

<p>Many of the types in Shapeless have a type member (<code>Repr</code>) and an <code>.Aux</code> type
alias on their companion that makes the second type visible. This allows us to
request the <code>Generic[Foo]</code> for a type <code>Foo</code> without having to provide the
generic representation, which is generated by a macro.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import shapeless._
  scala&gt; final case class Foo(a: String, b: Long)
         Generic[Foo].to(Foo("hello", 13L))
  res: String :: Long :: HNil = hello :: 13 :: HNil
  
  scala&gt; Generic[Foo].from("hello" :: 13L :: HNil)
  res: Foo = Foo(hello,13)
  
  scala&gt; sealed abstract class Bar
         case object Irish extends Bar
         case object English extends Bar
  
  scala&gt; Generic[Bar].to(Irish)
  res: English.type :+: Irish.type :+: CNil.type = Inl(Irish)
  
  scala&gt; Generic[Bar].from(Inl(Irish))
  res: Bar = Irish
</pre></div>

</figure>

<p>There is a complementary <code>LabelledGeneric</code> that includes the field names</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; import shapeless._, labelled._
  scala&gt; final case class Foo(a: String, b: Long)
  
  scala&gt; LabelledGeneric[Foo].to(Foo("hello", 13L))
  res: String with KeyTag[Symbol with Tagged[String("a")], String] ::
       Long   with KeyTag[Symbol with Tagged[String("b")],   Long] ::
       HNil =
       hello :: 13 :: HNil
  
  scala&gt; sealed abstract class Bar
         case object Irish extends Bar
         case object English extends Bar
  
  scala&gt; LabelledGeneric[Bar].to(Irish)
  res: Irish.type   with KeyTag[Symbol with Tagged[String("Irish")],     Irish.type] :+:
       English.type with KeyTag[Symbol with Tagged[String("English")], English.type] :+:
       CNil.type =
       Inl(Irish)
</pre></div>

</figure>

<p>Note that the <strong>value</strong> of a <code>LabelledGeneric</code> representation is the same as the
<code>Generic</code> representation: field names only exist in the type and are erased at
runtime.</p>

<p>We never need to type <code>KeyTag</code> manually, we use the type alias:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type FieldType[K, +V] = V with KeyTag[K, V]
</pre></div>

</figure>

<p>If we want to access the field name from a <code>FieldType[K, A]</code>, we ask for
implicit evidence <code>Witness.Aux[K]</code>, which allows us to access the value of <code>K</code>
at runtime.</p>

<p>Superficially, this is all we need to know about Shapeless to be able to derive
a typeclass. However, things get increasingly complex, so we will proceed with
increasingly complex examples.</p>

<h4 id="leanpub-auto-example-equal">
<a class="anchor-link" href="#leanpub-auto-example-equal"><i class="fa fa-link"></i></a><span class="section-number">8.4.1 </span>Example: Equal</h4>

<p>A typical pattern to follow is to extend the typeclass that we wish to derive,
and put the Shapeless code on its companion. This gives us an implicit scope
that the compiler can search without requiring complex imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait DerivedEqual[A] extends Equal[A]
  object DerivedEqual {
    ...
  }
</pre></div>

</figure>

<p>The entry point to a Shapeless derivation is a method, <code>gen</code>, requiring two type
parameters: the <code>A</code> that we are deriving and the <code>R</code> for its generic
representation. We then ask for the <code>Generic.Aux[A, R]</code>, relating <code>A</code> to <code>R</code>,
and an instance of the <code>Derived</code> typeclass for the <code>R</code>. We begin with this
signature and simple implementation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import shapeless._
  
  object DerivedEqual {
    def gen[A, R: DerivedEqual](implicit G: Generic.Aux[A, R]): Equal[A] =
      (a1, a2) =&gt; Equal[R].equal(G.to(a1), G.to(a2))
  }
</pre></div>

</figure>

<p>We’ve reduced the problem to providing an implicit <code>Equal[R]</code> for an <code>R</code> that is
the <code>Generic</code> representation of <code>A</code>. First consider products, where <code>R &lt;:
HList</code>. This is the signature we want to implement:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def hcons[H: Equal, T &lt;: HList: DerivedEqual]: DerivedEqual[H :: T]
</pre></div>

</figure>

<p>because if we can implement it for a head and a tail, the compiler will be able
to recurse on this method until it reaches the end of the list. Where we will
need to provide an instance for the empty <code>HNil</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def hnil: DerivedEqual[HNil]
</pre></div>

</figure>

<p>We implement these methods</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def hcons[H: Equal, T &lt;: HList: DerivedEqual]: DerivedEqual[H :: T] =
    (h1, h2) =&gt; Equal[H].equal(h1.head, h2.head) &amp;&amp; Equal[T].equal(h1.tail, h2.tail)
  
  implicit val hnil: DerivedEqual[HNil] = (_, _) =&gt; true
</pre></div>

</figure>

<p>and for coproducts we want to implement these signatures</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def ccons[H: Equal, T &lt;: Coproduct: DerivedEqual]: DerivedEqual[H :+: T]
  implicit def cnil: DerivedEqual[CNil]
</pre></div>

</figure>

<aside>
  <p>Scalaz and Shapeless share many type names, when mixing them we often need to
exclude certain elements from the import, e.g.</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  import scalaz.{ Coproduct =&gt; _, :+: =&gt; _, _ }, Scalaz._
  import shapeless._
</pre></div>

  </figure>

</aside>

<p><code>.cnil</code> will never be called for a typeclass like <code>Equal</code> with type parameters
only in contravariant position, but the compiler doesn’t know that so we have to
provide a stub:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val cnil: DerivedEqual[CNil] = (_, _) =&gt; sys.error("impossible")
</pre></div>

</figure>

<p>For the coproduct case we can only compare two things if they align, which is
when they are both <code>Inl</code> or <code>Inr</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit def ccons[H: Equal, T &lt;: Coproduct: DerivedEqual]: DerivedEqual[H :+: T] = {
    case (Inl(c1), Inl(c2)) =&gt; Equal[H].equal(c1, c2)
    case (Inr(c1), Inr(c2)) =&gt; Equal[T].equal(c1, c2)
    case _                  =&gt; false
  }
</pre></div>

</figure>

<p>It is noteworthy that our methods align with the concept of <code>conquer</code> (<code>hnil</code>),
<code>divide2</code> (<code>hlist</code>) and <code>alt2</code> (<code>coproduct</code>)! However, we don’t get any of the
advantages of implementing <code>Decidable</code>, as now we must start from scratch when
writing tests for this code.</p>

<p>So let’s test this thing with a simple ADT</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class Foo
  final case class Bar(s: String)          extends Foo
  final case class Faz(b: Boolean, i: Int) extends Foo
  final case object Baz                    extends Foo
</pre></div>

</figure>

<p>We need to provide instances on the companions:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Foo {
    implicit val equal: Equal[Foo] = DerivedEqual.gen
  }
  object Bar {
    implicit val equal: Equal[Bar] = DerivedEqual.gen
  }
  object Faz {
    implicit val equal: Equal[Faz] = DerivedEqual.gen
  }
  final case object Baz extends Foo {
    implicit val equal: Equal[Baz.type] = DerivedEqual.gen
  }
</pre></div>

</figure>

<p>But it doesn’t compile</p>

<figure class="code">
<div class="highlight"><pre><code></code>  [error] shapeless.scala:41:38: ambiguous implicit values:
  [error]  both value hnil in object DerivedEqual of type =&gt; DerivedEqual[HNil]
  [error]  and value cnil in object DerivedEqual of type =&gt; DerivedEqual[CNil]
  [error]  match expected type DerivedEqual[R]
  [error]     : Equal[Baz.type] = DerivedEqual.gen
  [error]                                      ^
</pre></div>

</figure>

<p>Welcome to Shapeless compilation errors!</p>

<p>The problem, which is not at all evident from the error, is that the compiler is
unable to work out what <code>R</code> is, and gets caught thinking it is something else.
We need to provide the explicit type parameters when calling <code>gen</code>, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val equal: Equal[Baz.type] = DerivedEqual.gen[Baz.type, HNil]
</pre></div>

</figure>

<p>or we can use the <code>Generic</code> macro to help us and let the compiler infer the generic representation</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case object Baz extends Foo {
    implicit val generic                = Generic[Baz.type]
    implicit val equal: Equal[Baz.type] = DerivedEqual.gen[Baz.type, generic.Repr]
  }
  ...
</pre></div>

</figure>

<aside>
  <p>At this point, ignore any red squigglies and only trust the compiler. This is
the point where Shapeless departs from IDE support.</p>

</aside>

<p>The reason why this fixes the problem is because the type signature</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def gen[A, R: DerivedEqual](implicit G: Generic.Aux[A, R]): Equal[A]
</pre></div>

</figure>

<p>desugars into</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def gen[A, R](implicit R: DerivedEqual[R], G: Generic.Aux[A, R]): Equal[A]
</pre></div>

</figure>

<p>The Scala compiler solves type constraints left to right, so it finds many
different solutions to <code>DerivedEqual[R]</code> before constraining it with the
<code>Generic.Aux[A, R]</code>. Another way to solve this is to not use context bounds.</p>

<aside>
  <p>Rather than present the fully working version, we feel it is important to show
when obvious code fails, such is the reality of Shapeless. Another thing we
could have reasonably done here is to have <code>sealed</code> the <code>DerivedEqual</code> trait so
that only derived versions are valid. But <code>sealed trait</code> is not compatible with
SAM types! Living at the razor’s edge, expect to get cut.</p>

</aside>

<p>With this in mind, we no longer need the <code>implicit val generic</code> or the explicit
type parameters on the call to <code>.gen</code>. We can wire up <code>@deriving</code> by adding an
entry in <code>deriving.conf</code> (assuming we want to override the <code>scalaz-deriving</code>
implementation)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  scalaz.Equal=fommil.DerivedEqual.gen
</pre></div>

</figure>

<p>and write</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(Equal) sealed abstract class Foo
  @deriving(Equal) final case class Bar(s: String)          extends Foo
  @deriving(Equal) final case class Faz(b: Boolean, i: Int) extends Foo
  @deriving(Equal) final case object Baz
</pre></div>

</figure>

<p>But replacing the <code>scalaz-deriving</code> version means that compile times get slower.
This is because the compiler is solving <code>N</code> implicit searches for each product
of <code>N</code> fields or coproduct of <code>N</code> products, whereas <code>scalaz-deriving</code> and
Magnolia do not.</p>

<p>Note that when using <code>scalaz-deriving</code> or Magnolia we can put the <code>@deriving</code> on
just the top member of an ADT, but for Shapeless we must add it to all entries.</p>

<p>However, this implementation still has a bug: it fails for recursive types <strong>at runtime</strong>, e.g.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(Equal) sealed trait ATree
  @deriving(Equal) final case class Leaf(value: String)               extends ATree
  @deriving(Equal) final case class Branch(left: ATree, right: ATree) extends ATree
</pre></div>

</figure>

<figure class="code">
<div class="highlight"><pre><code></code>  scala&gt; val leaf1: Leaf    = Leaf("hello")
         val leaf2: Leaf    = Leaf("goodbye")
         val branch: Branch = Branch(leaf1, leaf2)
         val tree1: ATree   = Branch(leaf1, branch)
         val tree2: ATree   = Branch(leaf2, branch)
  
  scala&gt; assert(tree1 /== tree2)
  [error] java.lang.NullPointerException
  [error] at DerivedEqual$.shapes$DerivedEqual$$$anonfun$hcons$1(shapeless.scala:16)
          ...
</pre></div>

</figure>

<p>The reason why this happens is because <code>Equal[Tree]</code> depends on the
<code>Equal[Branch]</code>, which depends on the <code>Equal[Tree]</code>. Recursion and BANG!
It must be loaded lazily, not eagerly.</p>

<p>Both <code>scalaz-deriving</code> and Magnolia deal with lazy automatically, but in
Shapeless it is the responsibility of the typeclass author.</p>

<p>The macro types <code>Cached</code>, <code>Strict</code> and <code>Lazy</code> modify the compiler’s type
inference behaviour allowing us to achieve the laziness we require. The pattern
to follow is to use <code>Cached[Strict[_]]</code> on the entry point and <code>Lazy[_]</code> around
the <code>H</code> instances.</p>

<p>It is best to depart from context bounds and SAM types entirely at this point:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait DerivedEqual[A] extends Equal[A]
  object DerivedEqual {
    def gen[A, R](
      implicit G: Generic.Aux[A, R],
      R: Cached[Strict[DerivedEqual[R]]]
    ): Equal[A] = new Equal[A] {
      def equal(a1: A, a2: A) =
        quick(a1, a2) || R.value.value.equal(G.to(a1), G.to(a2))
    }
  
    implicit def hcons[H, T &lt;: HList](
      implicit H: Lazy[Equal[H]],
      T: DerivedEqual[T]
    ): DerivedEqual[H :: T] = new DerivedEqual[H :: T] {
      def equal(ht1: H :: T, ht2: H :: T) =
        (quick(ht1.head, ht2.head) || H.value.equal(ht1.head, ht2.head)) &amp;&amp;
          T.equal(ht1.tail, ht2.tail)
    }
  
    implicit val hnil: DerivedEqual[HNil] = new DerivedEqual[HNil] {
      def equal(@unused h1: HNil, @unused h2: HNil) = true
    }
  
    implicit def ccons[H, T &lt;: Coproduct](
      implicit H: Lazy[Equal[H]],
      T: DerivedEqual[T]
    ): DerivedEqual[H :+: T] = new DerivedEqual[H :+: T] {
      def equal(ht1: H :+: T, ht2: H :+: T) = (ht1, ht2) match {
        case (Inl(c1), Inl(c2)) =&gt; quick(c1, c2) || H.value.equal(c1, c2)
        case (Inr(c1), Inr(c2)) =&gt; T.equal(c1, c2)
        case _                  =&gt; false
      }
    }
  
    implicit val cnil: DerivedEqual[CNil] = new DerivedEqual[CNil] {
      def equal(@unused c1: CNil, @unused c2: CNil) = sys.error("impossible")
    }
  
    @inline private final def quick(a: Any, b: Any): Boolean =
      a.asInstanceOf[AnyRef].eq(b.asInstanceOf[AnyRef])
  }
</pre></div>

</figure>

<p>While we were at it, we optimised using the <code>quick</code> shortcut from
<code>scalaz-deriving</code>.</p>

<p>We can now call</p>

<figure class="code">
<div class="highlight"><pre><code></code>  assert(tree1 /== tree2)
</pre></div>

</figure>

<p>without a runtime exception.</p>

<h4 id="leanpub-auto-example-default">
<a class="anchor-link" href="#leanpub-auto-example-default"><i class="fa fa-link"></i></a><span class="section-number">8.4.2 </span>Example: <code>Default</code>
</h4>

<p>There are no new snares in the implementation of a typeclass with a type
parameter in covariant position. Here we create <code>HList</code> and <code>Coproduct</code> values,
and must provide a value for the <code>CNil</code> case as it corresponds to the case where
no coproduct is able to provide a value.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait DerivedDefault[A] extends Default[A]
  object DerivedDefault {
    def gen[A, R](
      implicit G: Generic.Aux[A, R],
      R: Cached[Strict[DerivedDefault[R]]]
    ): Default[A] = new Default[A] {
      def default = R.value.value.default.map(G.from)
    }
  
    implicit def hcons[H, T &lt;: HList](
      implicit H: Lazy[Default[H]],
      T: DerivedDefault[T]
    ): DerivedDefault[H :: T] = new DerivedDefault[H :: T] {
      def default =
        for {
          head &lt;- H.value.default
          tail &lt;- T.default
        } yield head :: tail
    }
  
    implicit val hnil: DerivedDefault[HNil] = new DerivedDefault[HNil] {
      def default = HNil.right
    }
  
    implicit def ccons[H, T &lt;: Coproduct](
      implicit H: Lazy[Default[H]],
      T: DerivedDefault[T]
    ): DerivedDefault[H :+: T] = new DerivedDefault[H :+: T] {
      def default = H.value.default.map(Inl(_)).orElse(T.default.map(Inr(_)))
    }
  
    implicit val cnil: DerivedDefault[CNil] = new DerivedDefault[CNil] {
      def default = "not a valid coproduct".left
    }
  }
</pre></div>

</figure>

<p>Much as we could draw an analogy between <code>Equal</code> and <code>Decidable</code>, we can see the
relationship to <code>Alt</code> in <code>.point</code> (<code>hnil</code>), <code>.apply2</code> (<code>.hcons</code>) and <code>.altly2</code>
(<code>.ccons</code>).</p>

<p>There is little to be learned from an example like <code>Semigroup</code>, so we will skip
to encoders and decoders.</p>

<h4 id="leanpub-auto-example-jsencoder">
<a class="anchor-link" href="#leanpub-auto-example-jsencoder"><i class="fa fa-link"></i></a><span class="section-number">8.4.3 </span>Example: <code>JsEncoder</code>
</h4>

<p>To be able to reproduce our Magnolia JSON encoder, we must be able to access:</p>

<ol class="numeric">
  <li>field names and class names</li>
  <li>annotations for user preferences</li>
  <li>default values on a <code>case class</code>
</li>
</ol>

<p>We will begin by creating an encoder that handles only the sensible defaults.</p>

<p>To get field names, we use <code>LabelledGeneric</code> instead of <code>Generic</code>, and when
defining the type of the head element, use <code>FieldType[K, H]</code> instead of just
<code>H</code>. A <code>Witness.Aux[K]</code> provides the value of the field name at runtime.</p>

<p>All of our methods are going to return <code>JsObject</code>, so rather than returning a
<code>JsValue</code> we can specialise and create <code>DerivedJsEncoder</code> that has a different
type signature to <code>JsEncoder</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import shapeless._, labelled._
  
  sealed trait DerivedJsEncoder[R] {
    def toJsFields(r: R): IList[(String, JsValue)]
  }
  object DerivedJsEncoder {
    def gen[A, R](
      implicit G: LabelledGeneric.Aux[A, R],
      R: Cached[Strict[DerivedJsEncoder[R]]]
    ): JsEncoder[A] = new JsEncoder[A] {
      def toJson(a: A) = JsObject(R.value.value.toJsFields(G.to(a)))
    }
  
    implicit def hcons[K &lt;: Symbol, H, T &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[T]
    ): DerivedJsEncoder[FieldType[K, H] :: T] =
      new DerivedJsEncoder[A, FieldType[K, H] :: T] {
        private val field = K.value.name
        def toJsFields(ht: FieldType[K, H] :: T) =
          ht match {
            case head :: tail =&gt;
              val rest = T.toJsFields(tail)
              H.value.toJson(head) match {
                case JsNull =&gt; rest
                case value  =&gt; (field -&gt; value) :: rest
              }
          }
      }
  
    implicit val hnil: DerivedJsEncoder[HNil] =
      new DerivedJsEncoder[HNil] {
        def toJsFields(h: HNil) = IList.empty
      }
  
    implicit def ccons[K &lt;: Symbol, H, T &lt;: Coproduct](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[T]
    ): DerivedJsEncoder[FieldType[K, H] :+: T] =
      new DerivedJsEncoder[FieldType[K, H] :+: T] {
        private val hint = ("type" -&gt; JsString(K.value.name))
        def toJsFields(ht: FieldType[K, H] :+: T) = ht match {
          case Inl(head) =&gt;
            H.value.toJson(head) match {
              case JsObject(fields) =&gt; hint :: fields
              case v                =&gt; IList.single("xvalue" -&gt; v)
            }
  
          case Inr(tail) =&gt; T.toJsFields(tail)
        }
      }
  
    implicit val cnil: DerivedJsEncoder[CNil] =
      new DerivedJsEncoder[CNil] {
        def toJsFields(c: CNil) = sys.error("impossible")
      }
  
  }
</pre></div>

</figure>

<aside>
  <p>A pattern has emerged in many Shapeless derivation libraries that introduce
“hints” with a default <code>implicit</code></p>

  <figure class="code">
<div class="highlight"><pre><code></code>  trait ProductHint[A] {
    def nulls(field: String): Boolean
    def fieldname(field: String): String
  }
  object ProductHint {
    implicit def default[A]: ProductHint[A] = new ProductHint[A] {
      def nulls(field: String)     = false
      def fieldname(field: String) = field
    }
  }
</pre></div>

  </figure>

  <p>Users are supposed to provide a custom instance of <code>ProductHint</code> on their
companions or package objects. This is a <strong>terrible idea</strong> that relies on fragile
implicit ordering and is a source of typeclass decoherence: if we derive a
<code>JsEncoder[Foo]</code>, we will get a different result depending on which
<code>ProductHint[Foo]</code> is in scope. It is best avoided.</p>

</aside>

<p>Shapeless selects codepaths at compiletime based on the presence of annotations,
which can lead to more optimised code, at the expense of code repetition. This
means that the number of annotations we are dealing with, and their subtypes,
must be manageable or we can find ourselves writing 10x the amount of code. We
change our three annotations into one containing all the customisation
parameters:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  case class json(
    nulls: Boolean,
    field: Option[String],
    hint: Option[String]
  ) extends Annotation
</pre></div>

</figure>

<p>All users of the annotation must provide all three values since default values
and convenience methods are not available to annotation constructors. We can
write custom extractors so we don’t have to change our Magnolia code</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object json {
    object nulls {
      def unapply(j: json): Boolean = j.nulls
    }
    object field {
      def unapply(j: json): Option[String] = j.field
    }
    object hint {
      def unapply(j: json): Option[String] = j.hint
    }
  }
</pre></div>

</figure>

<p>We can request <code>Annotation[json, A]</code> for a <code>case class</code> or <code>sealed trait</code> to get access to the annotation, but we must write an <code>hcons</code> and a <code>ccons</code>
 dealing with both cases because the evidence will not be generated if 
the annotation is not present. We therefore have to introduce a lower 
priority implicit scope and put the “no annotation” evidence there.</p>

<p>We can also request <code>Annotations.Aux[json, A, J]</code> evidence to obtain an <code>HList</code>
of the <code>json</code> annotation for type <code>A</code>. Again, we must provide <code>hcons</code> and
<code>ccons</code> dealing with the case where there is and is not an annotation.</p>

<p>To support this one annotation, we must write four times as much code as before!</p>

<p>Lets start by rewriting the <code>JsEncoder</code>, only handling user code that doesn’t
have any annotations. Now any code that uses the <code>@json</code> will fail to compile,
which is a good safety net.</p>

<p>We must add an <code>A</code> and <code>J</code> type to the <code>DerivedJsEncoder</code> and thread through the
annotations on its <code>.toJsObject</code> method. Our <code>.hcons</code> and <code>.ccons</code> evidence now
provides instances for <code>DerivedJsEncoder</code> with a <code>None.type</code> annotation and we
move them to a lower priority so that we can deal with <code>Annotation[json, A]</code> in
the higher priority.</p>

<p>Note that the evidence for <code>J</code> is listed before <code>R</code>. This is important, since
the compiler must first fix the type of <code>J</code> before it can solve for <code>R</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait DerivedJsEncoder[A, R, J &lt;: HList] {
    def toJsFields(r: R, anns: J): IList[(String, JsValue)]
  }
  object DerivedJsEncoder extends DerivedJsEncoder1 {
    def gen[A, R, J &lt;: HList](
      implicit
      G: LabelledGeneric.Aux[A, R],
      J: Annotations.Aux[json, A, J],
      R: Cached[Strict[DerivedJsEncoder[A, R, J]]]
    ): JsEncoder[A] = new JsEncoder[A] {
      def toJson(a: A) = JsObject(R.value.value.toJsFields(G.to(a), J()))
    }
  
    implicit def hnil[A]: DerivedJsEncoder[A, HNil, HNil] =
      new DerivedJsEncoder[A, HNil, HNil] {
        def toJsFields(h: HNil, a: HNil) = IList.empty
      }
  
    implicit def cnil[A]: DerivedJsEncoder[A, CNil, HNil] =
      new DerivedJsEncoder[A, CNil, HNil] {
        def toJsFields(c: CNil, a: HNil) = sys.error("impossible")
      }
  }
  private[jsonformat] trait DerivedJsEncoder1 {
    implicit def hcons[A, K &lt;: Symbol, H, T &lt;: HList, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :: T, None.type :: J] =
      new DerivedJsEncoder[A, FieldType[K, H] :: T, None.type :: J] {
        private val field = K.value.name
        def toJsFields(ht: FieldType[K, H] :: T, anns: None.type :: J) =
          ht match {
            case head :: tail =&gt;
              val rest = T.toJsFields(tail, anns.tail)
              H.value.toJson(head) match {
                case JsNull =&gt; rest
                case value  =&gt; (field -&gt; value) :: rest
              }
          }
      }
  
    implicit def ccons[A, K &lt;: Symbol, H, T &lt;: Coproduct, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :+: T, None.type :: J] =
      new DerivedJsEncoder[A, FieldType[K, H] :+: T, None.type :: J] {
        private val hint = ("type" -&gt; JsString(K.value.name))
        def toJsFields(ht: FieldType[K, H] :+: T, anns: None.type :: J) =
          ht match {
            case Inl(head) =&gt;
              H.value.toJson(head) match {
                case JsObject(fields) =&gt; hint :: fields
                case v                =&gt; IList.single("xvalue" -&gt; v)
              }
            case Inr(tail) =&gt; T.toJsFields(tail, anns.tail)
          }
      }
  }
</pre></div>

</figure>

<p>Now we can add the type signatures for the six new methods, covering all the
possibilities of where the annotation can be. Note that we only support <strong>one</strong>
annotation in each position. If the user provides multiple annotations, anything
after the first will be silently ignored.</p>

<p>We’re now running out of names for things, so we will arbitrarily call it
<code>Annotated</code> when there is an annotation on the <code>A</code>, and <code>Custom</code> when there is
an annotation on a field:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object DerivedJsEncoder extends DerivedJsEncoder1 {
    ...
    implicit def hconsAnnotated[A, K &lt;: Symbol, H, T &lt;: HList, J &lt;: HList](
      implicit
      A: Annotation[json, A],
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :: T, None.type :: J]
  
    implicit def cconsAnnotated[A, K &lt;: Symbol, H, T &lt;: Coproduct, J &lt;: HList](
      implicit
      A: Annotation[json, A],
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :+: T, None.type :: J]
  
    implicit def hconsAnnotatedCustom[A, K &lt;: Symbol, H, T &lt;: HList, J &lt;: HList](
      implicit
      A: Annotation[json, A],
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :: T, Some[json] :: J]
  
    implicit def cconsAnnotatedCustom[A, K &lt;: Symbol, H, T &lt;: Coproduct, J &lt;: HList](
      implicit
      A: Annotation[json, A],
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :+: T, Some[json] :: J]
  }
  private[jsonformat] trait DerivedJsEncoder1 {
    ...
    implicit def hconsCustom[A, K &lt;: Symbol, H, T &lt;: HList, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :: T, Some[json] :: J] = ???
  
    implicit def cconsCustom[A, K &lt;: Symbol, H, T &lt;: Coproduct, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H] :+: T, Some[json] :: J]
  }
</pre></div>

</figure>

<p>We don’t actually need <code>.hconsAnnotated</code> or <code>.hconsAnnotatedCustom</code> for
anything, since an annotation on a <code>case class</code> does not mean anything to the
encoding of that product, it is only used in <code>.cconsAnnotated*</code>. We can therefore
delete two methods.</p>

<p><code>.cconsAnnotated</code> and <code>.cconsAnnotatedCustom</code> can be defined as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  new DerivedJsEncoder[A, FieldType[K, H] :+: T, None.type :: J] {
    private val hint = A().field.getOrElse("type") -&gt; JsString(K.value.name)
    def toJsFields(ht: FieldType[K, H] :+: T, anns: None.type :: J) = ht match {
      case Inl(head) =&gt;
        H.value.toJson(head) match {
          case JsObject(fields) =&gt; hint :: fields
          case v                =&gt; IList.single("xvalue" -&gt; v)
        }
      case Inr(tail) =&gt; T.toJsFields(tail, anns.tail)
    }
  }
</pre></div>

</figure>

<p>and</p>

<figure class="code">
<div class="highlight"><pre><code></code>  new DerivedJsEncoder[A, FieldType[K, H] :+: T, Some[json] :: J] {
    private val hintfield = A().field.getOrElse("type")
    def toJsFields(ht: FieldType[K, H] :+: T, anns: Some[json] :: J) = ht match {
      case Inl(head) =&gt;
        val ann = anns.head.get
        H.value.toJson(head) match {
          case JsObject(fields) =&gt;
            val hint = (hintfield -&gt; JsString(ann.hint.getOrElse(K.value.name)))
            hint :: fields
          case v =&gt;
            val xvalue = ann.field.getOrElse("xvalue")
            IList.single(xvalue -&gt; v)
        }
      case Inr(tail) =&gt; T.toJsFields(tail, anns.tail)
    }
  }
</pre></div>

</figure>

<p>The use of <code>.head</code> and <code>.get</code> may be concerned but recall that the types here
are <code>::</code> and <code>Some</code> meaning that these methods are total and safe to use.</p>

<p><code>.hconsCustom</code> and <code>.cconsCustom</code> are written</p>

<figure class="code">
<div class="highlight"><pre><code></code>  new DerivedJsEncoder[A, FieldType[K, H] :: T, Some[json] :: J] {
    def toJsFields(ht: FieldType[K, H] :: T, anns: Some[json] :: J) = ht match {
      case head :: tail =&gt;
        val ann  = anns.head.get
        val next = T.toJsFields(tail, anns.tail)
        H.value.toJson(head) match {
          case JsNull if !ann.nulls =&gt; next
          case value =&gt;
            val field = ann.field.getOrElse(K.value.name)
            (field -&gt; value) :: next
        }
    }
  }
</pre></div>

</figure>

<p>and</p>

<figure class="code">
<div class="highlight"><pre><code></code>  new DerivedJsEncoder[A, FieldType[K, H] :+: T, Some[json] :: J] {
    def toJsFields(ht: FieldType[K, H] :+: T, anns: Some[json] :: J) = ht match {
      case Inl(head) =&gt;
        val ann = anns.head.get
        H.value.toJson(head) match {
          case JsObject(fields) =&gt;
            val hint = ("type" -&gt; JsString(ann.hint.getOrElse(K.value.name)))
            hint :: fields
          case v =&gt;
            val xvalue = ann.field.getOrElse("xvalue")
            IList.single(xvalue -&gt; v)
        }
      case Inr(tail) =&gt; T.toJsFields(tail, anns.tail)
    }
  }
</pre></div>

</figure>

<p>Obviously, there is a lot of boilerplate, but looking closely one can see that
each method is implemented as efficiently as possible with the information it
has available: codepaths are selected at compiletime rather than runtime.</p>

<p>The performance obsessed may be able to refactor this code so all annotation
information is available in advance, rather than injected via the <code>.toJsFields</code>
method, with another layer of indirection. For absolute performance, we could
also treat each customisation as a separate annotation, but that would multiply
the amount of code we’ve written yet again, with additional cost to compilation
time on downstream users. Such optimisations are beyond the scope of this book,
but they are possible and people do them: the ability to shift work from runtime
to compiletime is one of the most appealing things about generic programming.</p>

<p>One more caveat that we need to be aware of: <a href="https://github.com/milessabin/shapeless/issues/309"><code>LabelledGeneric</code> is not compatible
with <code>scalaz.@@</code></a>, but there is a workaround. Say we want to effectively ignore
tags so we add the following derivation rules to the companions of our encoder
and decoder</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object JsEncoder {
    ...
    implicit def tagged[A: JsEncoder, Z]: JsEncoder[A @@ Z] =
      JsEncoder[A].contramap(Tag.unwrap)
  }
  object JsDecoder {
    ...
    implicit def tagged[A: JsDecoder, Z]: JsDecoder[A @@ Z] =
      JsDecoder[A].map(Tag(_))
  }
</pre></div>

</figure>

<p>We would then expect to be able to derive a <code>JsDecoder</code> for something like our
<code>TradeTemplate</code> from Chapter 5</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class TradeTemplate(
    otc: Option[Boolean] @@ Tags.Last
  )
  object TradeTemplate {
    implicit val encoder: JsEncoder[TradeTemplate] = DerivedJsEncoder.gen
  }
</pre></div>

</figure>

<p>But we instead get a compiler error</p>

<figure class="code">
<div class="highlight"><pre><code></code>  [error] could not find implicit value for parameter G: LabelledGeneric.Aux[A,R]
  [error]   implicit val encoder: JsEncoder[TradeTemplate] = DerivedJsEncoder.gen
  [error]                                                                     ^
</pre></div>

</figure>

<p>The error message is as helpful as always. The workaround is to introduce evidence for <code>H @@ Z</code> on the lower priority implicit scope, and then just call the code that the compiler should have found in the first place:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object DerivedJsEncoder extends DerivedJsEncoder1 with DerivedJsEncoder2 {
    ...
  }
  private[jsonformat] trait DerivedJsEncoder2 {
    this: DerivedJsEncoder.type =&gt;
  
    // WORKAROUND https://github.com/milessabin/shapeless/issues/309
    implicit def hconsTagged[A, K &lt;: Symbol, H, Z, T &lt;: HList, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H @@ Z]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H @@ Z] :: T, None.type :: J] = hcons(K, H, T)
  
    implicit def hconsCustomTagged[A, K &lt;: Symbol, H, Z, T &lt;: HList, J &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsEncoder[H @@ Z]],
      T: DerivedJsEncoder[A, T, J]
    ): DerivedJsEncoder[A, FieldType[K, H @@ Z] :: T, Some[json] :: J] = hconsCustom(K, H, T)
  }
</pre></div>

</figure>

<p>Thankfully, we only need to consider products, since coproducts cannot be tagged.</p>

<h4 id="leanpub-auto-jsdecoder">
<a class="anchor-link" href="#leanpub-auto-jsdecoder"><i class="fa fa-link"></i></a><span class="section-number">8.4.4 </span><code>JsDecoder</code>
</h4>

<p>The decoding side is much as we can expect based on previous examples. We can
construct an instance of a <code>FieldType[K, H]</code> with the helper <code>field[K](h: H)</code>.
Supporting only the sensible defaults means we write:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait DerivedJsDecoder[A] {
    def fromJsObject(j: JsObject): String \/ A
  }
  object DerivedJsDecoder {
    def gen[A, R](
      implicit G: LabelledGeneric.Aux[A, R],
      R: Cached[Strict[DerivedJsDecoder[R]]]
    ): JsDecoder[A] = new JsDecoder[A] {
      def fromJson(j: JsValue) = j match {
        case o @ JsObject(_) =&gt; R.value.value.fromJsObject(o).map(G.from)
        case other           =&gt; fail("JsObject", other)
      }
    }
  
    implicit def hcons[K &lt;: Symbol, H, T &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsDecoder[H]],
      T: DerivedJsDecoder[T]
    ): DerivedJsDecoder[FieldType[K, H] :: T] =
      new DerivedJsDecoder[FieldType[K, H] :: T] {
        private val fieldname = K.value.name
        def fromJsObject(j: JsObject) = {
          val value = j.get(fieldname).getOrElse(JsNull)
          for {
            head  &lt;- H.value.fromJson(value)
            tail  &lt;- T.fromJsObject(j)
          } yield field[K](head) :: tail
        }
      }
  
    implicit val hnil: DerivedJsDecoder[HNil] = new DerivedJsDecoder[HNil] {
      private val nil               = HNil.right[String]
      def fromJsObject(j: JsObject) = nil
    }
  
    implicit def ccons[K &lt;: Symbol, H, T &lt;: Coproduct](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsDecoder[H]],
      T: DerivedJsDecoder[T]
    ): DerivedJsDecoder[FieldType[K, H] :+: T] =
      new DerivedJsDecoder[FieldType[K, H] :+: T] {
        private val hint = ("type" -&gt; JsString(K.value.name))
        def fromJsObject(j: JsObject) =
          if (j.fields.element(hint)) {
            j.get("xvalue")
              .into {
                case \/-(xvalue) =&gt; H.value.fromJson(xvalue)
                case -\/(_)      =&gt; H.value.fromJson(j)
              }
              .map(h =&gt; Inl(field[K](h)))
          } else
            T.fromJsObject(j).map(Inr(_))
      }
  
    implicit val cnil: DerivedJsDecoder[CNil] = new DerivedJsDecoder[CNil] {
      def fromJsObject(j: JsObject) = fail(s"JsObject with 'type' field", j)
    }
  }
</pre></div>

</figure>

<p>Adding user preferences via annotations follows the same route as
<code>DerivedJsEncoder</code> and is mechanical, so left as an exercise to the reader.</p>

<p>One final thing is missing: <code>case class</code> default values. We can request evidence
but a big problem is that we can no longer use the same derivation mechanism for
products and coproducts: the evidence is never created for coproducts.</p>

<p>The solution is quite drastic. We must split our <code>DerivedJsDecoder</code> into
<code>DerivedCoproductJsDecoder</code> and <code>DerivedProductJsDecoder</code>. We will focus our
attention on the <code>DerivedProductJsDecoder</code>, and while we are at it we will
use a <code>Map</code> for faster field lookup:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed trait DerivedProductJsDecoder[A, R, J &lt;: HList, D &lt;: HList] {
    private[jsonformat] def fromJsObject(
      j: Map[String, JsValue],
      anns: J,
      defaults: D
    ): String \/ R
  }
</pre></div>

</figure>

<p>We can request evidence of default values with <code>Default.Aux[A, D]</code> and duplicate
all the methods to deal with the case where we do and do not have a default
value. However, Shapeless is merciful (for once) and provides
<code>Default.AsOptions.Aux[A, D]</code> letting us handle defaults at runtime.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object DerivedProductJsDecoder {
    def gen[A, R, J &lt;: HList, D &lt;: HList](
      implicit G: LabelledGeneric.Aux[A, R],
      J: Annotations.Aux[json, A, J],
      D: Default.AsOptions.Aux[A, D],
      R: Cached[Strict[DerivedProductJsDecoder[A, R, J, D]]]
    ): JsDecoder[A] = new JsDecoder[A] {
      def fromJson(j: JsValue) = j match {
        case o @ JsObject(_) =&gt;
          R.value.value.fromJsObject(o.fields.toMap, J(), D()).map(G.from)
        case other =&gt; fail("JsObject", other)
      }
    }
    ...
  }
</pre></div>

</figure>

<p>We must move the <code>.hcons</code> and <code>.hnil</code> methods onto the companion of the new
sealed typeclass, which can handle default values</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object DerivedProductJsDecoder {
    ...
      implicit def hnil[A]: DerivedProductJsDecoder[A, HNil, HNil, HNil] =
      new DerivedProductJsDecoder[A, HNil, HNil, HNil] {
        private val nil = HNil.right[String]
        def fromJsObject(j: StringyMap[JsValue], a: HNil, defaults: HNil) = nil
      }
  
    implicit def hcons[A, K &lt;: Symbol, H, T &lt;: HList, J &lt;: HList, D &lt;: HList](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsDecoder[H]],
      T: DerivedProductJsDecoder[A, T, J, D]
    ): DerivedProductJsDecoder[A, FieldType[K, H] :: T, None.type :: J, Option[H] :: D] =
      new DerivedProductJsDecoder[A, FieldType[K, H] :: T, None.type :: J, Option[H] :: D] {
        private val fieldname = K.value.name
        def fromJsObject(
          j: StringyMap[JsValue],
          anns: None.type :: J,
          defaults: Option[H] :: D
        ) =
          for {
            head &lt;- j.get(fieldname) match {
                     case Maybe.Just(v) =&gt; H.value.fromJson(v)
                     case _ =&gt;
                       defaults.head match {
                         case Some(default) =&gt; \/-(default)
                         case None          =&gt; H.value.fromJson(JsNull)
                       }
                   }
            tail &lt;- T.fromJsObject(j, anns.tail, defaults.tail)
          } yield field[K](head) :: tail
      }
    ...
  }
</pre></div>

</figure>

<p>We can no longer use <code>@deriving</code> for products and coproducts: there can only be
one entry in the <code>deriving.conf</code> file.</p>

<p>Oh, and don’t forget to add <code>@@</code> support</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object DerivedProductJsDecoder extends DerivedProductJsDecoder1 {
    ...
  }
  private[jsonformat] trait DerivedProductJsDecoder2 {
    this: DerivedProductJsDecoder.type =&gt;
  
    implicit def hconsTagged[
      A, K &lt;: Symbol, H, Z, T &lt;: HList, J &lt;: HList, D &lt;: HList
    ](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsDecoder[H @@ Z]],
      T: DerivedProductJsDecoder[A, T, J, D]
    ): DerivedProductJsDecoder[
      A,
      FieldType[K, H @@ Z] :: T,
      None.type :: J,
      Option[H @@ Z] :: D
    ] = hcons(K, H, T)
  
    implicit def hconsCustomTagged[
      A, K &lt;: Symbol, H, Z, T &lt;: HList, J &lt;: HList, D &lt;: HList
    ](
      implicit
      K: Witness.Aux[K],
      H: Lazy[JsDecoder[H @@ Z]],
      T: DerivedProductJsDecoder[A, T, J, D]
    ): DerivedProductJsDecoder[
      A,
      FieldType[K, H @@ Z] :: T,
      Some[json] :: J,
      Option[H @@ Z] :: D
    ] = hconsCustomTagged(K, H, T)
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-complicated-derivations">
<a class="anchor-link" href="#leanpub-auto-complicated-derivations"><i class="fa fa-link"></i></a><span class="section-number">8.4.5 </span>Complicated Derivations</h4>

<p>Shapeless allows for a lot more kinds of derivations than are possible with
<code>scalaz-deriving</code> or Magnolia. As an example of an encoder / decoder that are
not possible with Magnolia, consider this XML model from <a href="https://github.com/scalaz/scalaz-deriving/tree/master/examples/xmlformat"><code>xmlformat</code></a></p>

<figure class="code">
<div class="highlight"><pre><code></code>  @deriving(Equal, Show, Arbitrary)
  sealed abstract class XNode
  
  @deriving(Equal, Show, Arbitrary)
  final case class XTag(
    name: String,
    attrs: IList[XAttr],
    children: IList[XTag],
    body: Maybe[XString]
  )
  
  @deriving(Equal, Show, Arbitrary)
  final case class XAttr(name: String, value: XString)
  
  @deriving(Show)
  @xderiving(Equal, Monoid, Arbitrary)
  final case class XChildren(tree: IList[XTag]) extends XNode
  
  @deriving(Show)
  @xderiving(Equal, Semigroup, Arbitrary)
  final case class XString(text: String) extends XNode
</pre></div>

</figure>

<p>Given the nature of XML it makes sense to have separate encoder / decoder pairs
for <code>XChildren</code> and <code>XString</code> content. We could provide a derivation for the
<code>XChildren</code> with Shapeless but we want to special case fields based on the kind
of typeclass they have, as well as <code>Option</code> fields. We could even require that
fields are annotated with their encoded name. In addition, when decoding we wish
to have different strategies for handling XML element bodies, which can be
multipart, depending on if our type has a <code>Semigroup</code>, <code>Monoid</code> or neither.</p>

<aside>
  <p>Many developers believe XML is simply a more verbose form of JSON, with angle
brackets instead of curlies. However, an attempt to write a round trip converter
between <code>XNode</code> and <code>JsValue</code> should convince us that JSON and XML are different
species, with conversions only possible on a case-by-case basis.</p>

</aside>

<h4 id="leanpub-auto-example-urlquerywriter">
<a class="anchor-link" href="#leanpub-auto-example-urlquerywriter"><i class="fa fa-link"></i></a><span class="section-number">8.4.6 </span>Example: <code>UrlQueryWriter</code>
</h4>

<p>Along similar lines as <code>xmlformat</code>, our <code>drone-dynamic-agents</code> application could
benefit from a typeclass derivation of the <code>UrlQueryWriter</code> typeclass, which is
built out of <code>UrlEncodedWriter</code> instances for each field entry. It does not
support coproducts:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait UrlQueryWriter[A] {
    def toUrlQuery(a: A): UrlQuery
  }
  trait DerivedUrlQueryWriter[T] extends UrlQueryWriter[T]
  object DerivedUrlQueryWriter {
    def gen[T, Repr](
      implicit
      G: LabelledGeneric.Aux[T, Repr],
      CR: Cached[Strict[DerivedUrlQueryWriter[Repr]]]
    ): UrlQueryWriter[T] = { t =&gt;
      CR.value.value.toUrlQuery(G.to(t))
    }
  
    implicit val hnil: DerivedUrlQueryWriter[HNil] = { _ =&gt;
      UrlQuery(IList.empty)
    }
    implicit def hcons[Key &lt;: Symbol, A, Remaining &lt;: HList](
      implicit Key: Witness.Aux[Key],
      LV: Lazy[UrlEncodedWriter[A]],
      DR: DerivedUrlQueryWriter[Remaining]
    ): DerivedUrlQueryWriter[FieldType[Key, A] :: Remaining] = {
      case head :: tail =&gt;
        val first =
          Key.value.name -&gt; URLDecoder.decode(LV.value.toUrlEncoded(head).value, "UTF-8")
        val rest = DR.toUrlQuery(tail)
        UrlQuery(first :: rest.params)
    }
  }
</pre></div>

</figure>

<p>It is reasonable to ask if these 30 lines are actually an improvement over the 8
lines for the 2 manual instances our application needs: a decision to be taken
on a case by case basis.</p>

<p>For completeness, the <code>UrlEncodedWriter</code> derivation can be written with Magnolia</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object UrlEncodedWriterMagnolia {
    type Typeclass[a] = UrlEncodedWriter[a]
    def combine[A](ctx: CaseClass[UrlEncodedWriter, A]) = a =&gt;
      Refined.unsafeApply(ctx.parameters.map { p =&gt;
        p.label + "=" + p.typeclass.toUrlEncoded(p.dereference(a))
      }.toList.intercalate("&amp;"))
    def gen[A]: UrlEncodedWriter[A] = macro Magnolia.gen[A]
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-the-dark-side-of-derivation">
<a class="anchor-link" href="#leanpub-auto-the-dark-side-of-derivation"><i class="fa fa-link"></i></a><span class="section-number">8.4.7 </span>The Dark Side of Derivation</h4>

<blockquote>
  <p>“Beware fully automatic derivation. Anger, fear, aggression; the dark side of
the derivation are they. Easily they flow, quick to join you in a fight. If once
you start down the dark path, forever will it dominate your compiler, consume
you it will.”</p>

  <p>― an ancient Shapeless master</p>
</blockquote>

<p>In addition to all the warnings about fully automatic derivation that were
mentioned for Magnolia, Shapeless is <strong>much</strong> worse. Not only is fully automatic
Shapeless derivation <a href="https://www.scala-lang.org/blog/2018/06/04/scalac-profiling.html">the most common cause of slow compiles</a>, it is also a
painful source of typeclass coherence bugs.</p>

<p>Fully automatic derivation is when the <code>def gen</code> are <code>implicit</code> such that a call
will recurse for all entries in the ADT. Because of the way that implicit scopes
work, an imported <code>implicit def</code> will have a higher priority than custom
instances on companions, creating a source of typeclass decoherence. For
example, consider this code if our <code>.gen</code> were implicit</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import DerivedJsEncoder._
  
  @xderiving(JsEncoder)
  final case class Foo(s: String)
  final case class Bar(foo: Foo)
</pre></div>

</figure>

<p>We might expect the full-auto encoded form of <code>Bar("hello")</code> to look like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "foo":"hello"
  }
</pre></div>

</figure>

<p>because we have used <code>xderiving</code> for <code>Foo</code>. But it can instead be</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {
    "foo": {
      "s":"hello"
    }
  }
</pre></div>

</figure>

<p>Worse yet is when implicit methods are added to the companion of the typeclass,
meaning that the typeclass is always derived at the point of use and users are
unable opt out.</p>

<p>Fundamentally, when writing generic programs, implicits can be ignored by the
compiler depending on scope, meaning that we lose the compiletime safety that
was our motivation for programming at the type level in the first place!</p>

<p>Everything is much simpler in the light side, where <code>implicit</code> is only used for
coherent, globally unique, typeclasses. Fear of boilerplate is the path to the
dark side. Fear leads to anger. Anger leads to hate. Hate leads to suffering.</p>

<h3 id="leanpub-auto-performance-1">
<a class="anchor-link" href="#leanpub-auto-performance-1"><i class="fa fa-link"></i></a><span class="section-number">8.5 </span>Performance</h3>

<p>There is no silver bullet when it comes to typeclass derivation. An axis to
consider is performance: both at compiletime and runtime.</p>

<h5 id="leanpub-auto-compile-times">
<a class="anchor-link" href="#leanpub-auto-compile-times"><i class="fa fa-link"></i></a><span class="section-number">8.5.0.1 </span>Compile Times</h5>

<p>When it comes to compilation times, Shapeless is the outlier. It is not uncommon
to see a small project expand from a one second compile to a one minute compile.
To investigate compilation issues, we can profile our applications with the
<code>scalac-profiling</code> plugin</p>

<figure class="code">
<div class="highlight"><pre><code></code>  addCompilerPlugin("ch.epfl.scala" %% "scalac-profiling" % "1.0.0")
  scalacOptions ++= Seq("-Ystatistics:typer", "-P:scalac-profiling:no-profiledb")
</pre></div>

</figure>

<p>It produces output that can generate a <em>flame graph</em>.</p>

<p>For a typical Shapeless derivation, we get a lively chart</p>


<div class="figure-wrapper center">
  <figure class="image" style="width: 90%;">
    <img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/implicit-flamegraph-jsonformat-jmh.png" alt="" style="width: 100%;">
    <figcaption></figcaption>
  </figure>
</div>


<p>almost the entire compile time is spent in implicit resolution. Note that this
also includes compiling the <code>scalaz-deriving</code>, Magnolia and manual instances,
but the Shapeless computations dominate.</p>

<p>And this is when it works. If there is a problem with a shapeless derivation,
the compiler can get stuck in an infinite loop and must be killed.</p>

<h5 id="leanpub-auto-runtime-performance">
<a class="anchor-link" href="#leanpub-auto-runtime-performance"><i class="fa fa-link"></i></a><span class="section-number">8.5.0.2 </span>Runtime Performance</h5>

<p>If we move to runtime performance, the answer is always <em>it depends</em>.</p>

<p>Assuming that the derivation logic has been written in an efficient way, it is
only possible to know which is faster through experimentation.</p>

<p>The <code>jsonformat</code> library uses the <a href="http://openjdk.java.net/projects/code-tools/jmh/">Java Microbenchmark Harness (JMH)</a> on models
that map to GeoJSON, Google Maps, and Twitter, contributed by Andriy
Plokhotnyuk. There are three tests per model:</p>

<ul>
  <li>encoding the <code>ADT</code> to a <code>JsValue</code>
</li>
  <li>a successful decoding of the same <code>JsValue</code> back into an ADT</li>
  <li>a failure decoding of a <code>JsValue</code> with a data error</li>
</ul>

<p>applied to the following implementations:</p>

<ul>
  <li>Magnolia</li>
  <li>Shapeless</li>
  <li>manually written</li>
</ul>

<p>with the equivalent optimisations in each. The results are in operations per
second (higher is better), on a powerful desktop computer, using a single
thread:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; jsonformat/jmh:run -i 5 -wi 5 -f1 -t1 -w1 -r1 .*encode*
  Benchmark                                 Mode  Cnt       Score      Error  Units
  
  GeoJSONBenchmarks.encodeMagnolia         thrpt    5   70527.223 ±  546.991  ops/s
  GeoJSONBenchmarks.encodeShapeless        thrpt    5   65925.215 ±  309.623  ops/s
  GeoJSONBenchmarks.encodeManual           thrpt    5   96435.691 ±  334.652  ops/s
  
  GoogleMapsAPIBenchmarks.encodeMagnolia   thrpt    5   73107.747 ±  439.803  ops/s
  GoogleMapsAPIBenchmarks.encodeShapeless  thrpt    5   53867.845 ±  510.888  ops/s
  GoogleMapsAPIBenchmarks.encodeManual     thrpt    5  127608.402 ± 1584.038  ops/s
  
  TwitterAPIBenchmarks.encodeMagnolia      thrpt    5  133425.164 ± 1281.331  ops/s
  TwitterAPIBenchmarks.encodeShapeless     thrpt    5   84233.065 ±  352.611  ops/s
  TwitterAPIBenchmarks.encodeManual        thrpt    5  281606.574 ± 1975.873  ops/s
</pre></div>

</figure>

<p>We see that the manual implementations are in the lead, followed by Magnolia,
with Shapeless from 30% to 70% the performance of the manual instances. Now for
decoding</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; jsonformat/jmh:run -i 5 -wi 5 -f1 -t1 -w1 -r1 .*decode.*Success
  Benchmark                                        Mode  Cnt       Score      Error  Units
  
  GeoJSONBenchmarks.decodeMagnoliaSuccess         thrpt    5   40850.270 ±  201.457  ops/s
  GeoJSONBenchmarks.decodeShapelessSuccess        thrpt    5   41173.199 ±  373.048  ops/s
  GeoJSONBenchmarks.decodeManualSuccess           thrpt    5  110961.246 ±  468.384  ops/s
  
  GoogleMapsAPIBenchmarks.decodeMagnoliaSuccess   thrpt    5   44577.796 ±  457.861  ops/s
  GoogleMapsAPIBenchmarks.decodeShapelessSuccess  thrpt    5   31649.792 ±  861.169  ops/s
  GoogleMapsAPIBenchmarks.decodeManualSuccess     thrpt    5   56250.913 ±  394.105  ops/s
  
  TwitterAPIBenchmarks.decodeMagnoliaSuccess      thrpt    5   55868.832 ± 1106.543  ops/s
  TwitterAPIBenchmarks.decodeShapelessSuccess     thrpt    5   47711.161 ±  356.911  ops/s
  TwitterAPIBenchmarks.decodeManualSuccess        thrpt    5   71962.394 ±  465.752  ops/s
</pre></div>

</figure>

<p>This is a tighter race for second place, with Shapeless and Magnolia keeping
pace. Finally, decoding from a <code>JsValue</code> that contains invalid data (in an
intentionally awkward position)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; jsonformat/jmh:run -i 5 -wi 5 -f1 -t1 -w1 -r1 .*decode.*Error
  Benchmark                                      Mode  Cnt        Score       Error  Units
  
  GeoJSONBenchmarks.decodeMagnoliaError         thrpt    5   981094.831 ± 11051.370  ops/s
  GeoJSONBenchmarks.decodeShapelessError        thrpt    5   816704.635 ±  9781.467  ops/s
  GeoJSONBenchmarks.decodeManualError           thrpt    5   586733.762 ±  6389.296  ops/s
  
  GoogleMapsAPIBenchmarks.decodeMagnoliaError   thrpt    5  1288888.446 ± 11091.080  ops/s
  GoogleMapsAPIBenchmarks.decodeShapelessError  thrpt    5  1010145.363 ±  9448.110  ops/s
  GoogleMapsAPIBenchmarks.decodeManualError     thrpt    5  1417662.720 ±  1197.283  ops/s
  
  TwitterAPIBenchmarks.decodeMagnoliaError      thrpt    5   128704.299 ±   832.122  ops/s
  TwitterAPIBenchmarks.decodeShapelessError     thrpt    5   109715.865 ±   826.488  ops/s
  TwitterAPIBenchmarks.decodeManualError        thrpt    5   148814.730 ±  1105.316  ops/s
</pre></div>

</figure>

<p>Just when we thought we were seeing a pattern, both Magnolia and Shapeless win
the race when decoding invalid GeoJSON data, but manual instances win the Google
Maps and Twitter challenges.</p>

<p>We want to include <code>scalaz-deriving</code> in the comparison, so we compare an
equivalent implementation of <code>Equal</code>, tested on two values that contain the same
contents (<code>True</code>) and two values that contain slightly different contents
(<code>False</code>)</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; jsonformat/jmh:run -i 5 -wi 5 -f1 -t1 -w1 -r1 .*equal*
  Benchmark                                     Mode  Cnt        Score       Error  Units
  
  GeoJSONBenchmarks.equalScalazTrue            thrpt    5   276851.493 ±  1776.428  ops/s
  GeoJSONBenchmarks.equalMagnoliaTrue          thrpt    5    93106.945 ±  1051.062  ops/s
  GeoJSONBenchmarks.equalShapelessTrue         thrpt    5   266633.522 ±  4972.167  ops/s
  GeoJSONBenchmarks.equalManualTrue            thrpt    5   599219.169 ±  8331.308  ops/s
  
  GoogleMapsAPIBenchmarks.equalScalazTrue      thrpt    5    35442.577 ±   281.597  ops/s
  GoogleMapsAPIBenchmarks.equalMagnoliaTrue    thrpt    5    91016.557 ±   688.308  ops/s
  GoogleMapsAPIBenchmarks.equalShapelessTrue   thrpt    5   107245.505 ±   468.427  ops/s
  GoogleMapsAPIBenchmarks.equalManualTrue      thrpt    5   302247.760 ±  1927.858  ops/s
  
  TwitterAPIBenchmarks.equalScalazTrue         thrpt    5    99066.013 ±  1125.422  ops/s
  TwitterAPIBenchmarks.equalMagnoliaTrue       thrpt    5   236289.706 ±  3182.664  ops/s
  TwitterAPIBenchmarks.equalShapelessTrue      thrpt    5   251578.931 ±  2430.738  ops/s
  TwitterAPIBenchmarks.equalManualTrue         thrpt    5   865845.158 ±  6339.379  ops/s
</pre></div>

</figure>

<p>As expected, the manual instances are far ahead of the crowd, with Shapeless
mostly leading the automatic derivations. <code>scalaz-deriving</code> makes a great effort
for GeoJSON but falls far behind in both the Google Maps and Twitter tests. The
<code>False</code> tests are more of the same:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; jsonformat/jmh:run -i 5 -wi 5 -f1 -t1 -w1 -r1 .*equal*
  Benchmark                                     Mode  Cnt        Score       Error  Units
  
  GeoJSONBenchmarks.equalScalazFalse           thrpt    5    89552.875 ±   821.791  ops/s
  GeoJSONBenchmarks.equalMagnoliaFalse         thrpt    5    86044.021 ±  7790.350  ops/s
  GeoJSONBenchmarks.equalShapelessFalse        thrpt    5   262979.062 ±  3310.750  ops/s
  GeoJSONBenchmarks.equalManualFalse           thrpt    5   599989.203 ± 23727.672  ops/s
  
  GoogleMapsAPIBenchmarks.equalScalazFalse     thrpt    5    35970.818 ±   288.609  ops/s
  GoogleMapsAPIBenchmarks.equalMagnoliaFalse   thrpt    5    82381.975 ±   625.407  ops/s
  GoogleMapsAPIBenchmarks.equalShapelessFalse  thrpt    5   110721.122 ±   579.331  ops/s
  GoogleMapsAPIBenchmarks.equalManualFalse     thrpt    5   303588.815 ±  2562.747  ops/s
  
  TwitterAPIBenchmarks.equalScalazFalse        thrpt    5   193930.568 ±  1176.421  ops/s
  TwitterAPIBenchmarks.equalMagnoliaFalse      thrpt    5   429764.654 ± 11944.057  ops/s
  TwitterAPIBenchmarks.equalShapelessFalse     thrpt    5   494510.588 ±  1455.647  ops/s
  TwitterAPIBenchmarks.equalManualFalse        thrpt    5  1631964.531 ± 13110.291  ops/s
</pre></div>

</figure>

<p>The runtime performance of <code>scalaz-deriving</code>, Magnolia and Shapeless is usually
good enough. We should be realistic: we are not writing applications that need to
be able to encode more than 130,000 values to JSON, per second, on a single
core, on the JVM. If that is a problem, look into C++.</p>

<p>It is unlikely that derived instances will be an application’s bottleneck. Even
if it is, there is the manually written escape hatch, which is more powerful and
therefore more dangerous: it is easy to introduce typos, bugs, and even
performance regressions by accident when writing a manual instance.</p>

<p>In conclusion: hokey derivations and ancient macros are no match for a good hand
written instance at your side, kid.</p>

<aside>
  <p>We could spend a lifetime with the <a href="https://github.com/jvm-profiling-tools/async-profiler"><code>async-profiler</code></a> investigating CPU and object
allocation flame graphs to make any of these implementations faster. For
example, there are some optimisations in the actual <code>jsonformat</code> codebase not
reproduced here, such as a more optimised <code>JsObject</code> field lookup, and inclusion
of <code>.xmap</code>, <code>.map</code> and <code>.contramap</code> on the relevant typeclasses, but it is fair
to say that the codebase primarily focuses on readability over optimisation and
still achieves incredible performance.</p>

</aside>

<h3 id="leanpub-auto-summary-6">
<a class="anchor-link" href="#leanpub-auto-summary-6"><i class="fa fa-link"></i></a><span class="section-number">8.6 </span>Summary</h3>

<p>When deciding on a technology to use for typeclass derivation, this feature
chart may help:</p>

<table>
  <thead>
    <tr>
      <th>Feature</th>
      <th>Scalaz</th>
      <th>Magnolia</th>
      <th>Shapeless</th>
      <th>Manual</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>@deriving</code></td>
      <td>yes</td>
      <td>yes</td>
      <td>yes</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Laws</td>
      <td>yes</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Fast compiles</td>
      <td>yes</td>
      <td>yes</td>
      <td>&nbsp;</td>
      <td>yes</td>
    </tr>
    <tr>
      <td>Field names</td>
      <td>&nbsp;</td>
      <td>yes</td>
      <td>yes</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Annotations</td>
      <td>&nbsp;</td>
      <td>yes</td>
      <td>partially</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Default values</td>
      <td>&nbsp;</td>
      <td>yes</td>
      <td>with caveats</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Complicated</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>painfully so</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>Performance</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td>hold my beer</td>
    </tr>
  </tbody>

</table>

<p>Prefer <code>scalaz-deriving</code> if possible, using Magnolia for encoders / decoders or
if performance is a larger concern, escalating to Shapeless for complicated
derivations only if compilation times are not a concern.</p>

<p>Manual instances are always an escape hatch for special cases and to achieve the
ultimate performance. Avoid introducing typo bugs with manual instances by using
a code generation tool.</p>

<h2 id="leanpub-auto-wiring-up-the-application">
<a class="anchor-link" href="#leanpub-auto-wiring-up-the-application"><i class="fa fa-link"></i></a><span class="section-number">9. </span>Wiring up the Application</h2>

<p>To finish, we will apply what we have learnt to wire up the example application,
and implement an HTTP client and server using the <a href="https://http4s.org/">http4s</a> pure FP library.</p>

<p>The source code to the <code>drone-dynamic-agents</code> application is available along
with the book’s source code at <code>https://github.com/fommil/fpmortals</code> under the
<code>examples</code> folder. It is not necessary to be at a computer to read this chapter,
but many readers may prefer to explore the codebase in addition to this text.</p>

<p>Some parts of the application have been left unimplemented, as an exercise to
the reader. See the <code>README</code> for further instructions.</p>

<h3 id="leanpub-auto-overview">
<a class="anchor-link" href="#leanpub-auto-overview"><i class="fa fa-link"></i></a><span class="section-number">9.1 </span>Overview</h3>

<p>Our main application only requires an implementation of the <code>DynAgents</code> algebra.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait DynAgents[F[_]] {
    def initial: F[WorldView]
    def update(old: WorldView): F[WorldView]
    def act(world: WorldView): F[WorldView]
  }
</pre></div>

</figure>

<p>We have an implementation already, <code>DynAgentsModule</code>, which requires
implementations of the <code>Drone</code> and <code>Machines</code> algebras, which require a
<code>JsonClient</code>, <code>LocalClock</code> and OAuth2 algebras, etc, etc, etc.</p>

<p>It is helpful to get a complete picture of all the algebras, modules and
interpreters of the application. This is the layout of the source code:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  ├── dda
  │   ├── algebra.scala
  │   ├── DynAgents.scala
  │   ├── main.scala
  │   └── interpreters
  │       ├── DroneModule.scala
  │       └── GoogleMachinesModule.scala
  ├── http
  │   ├── JsonClient.scala
  │   ├── OAuth2JsonClient.scala
  │   ├── encoding
  │   │   ├── UrlEncoded.scala
  │   │   ├── UrlEncodedWriter.scala
  │   │   ├── UrlQuery.scala
  │   │   └── UrlQueryWriter.scala
  │   ├── oauth2
  │   │   ├── Access.scala
  │   │   ├── Auth.scala
  │   │   ├── Refresh.scala
  │   │   └── interpreters
  │   │       └── BlazeUserInteraction.scala
  │   └── interpreters
  │       └── BlazeJsonClient.scala
  ├── os
  │   └── Browser.scala
  └── time
      ├── Epoch.scala
      ├── LocalClock.scala
      └── Sleep.scala
</pre></div>

</figure>

<p>The signatures of all the algebras can be summarised as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  trait Sleep[F[_]] {
    def sleep(time: FiniteDuration): F[Unit]
  }
  
  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
  
  trait JsonClient[F[_]] {
    def get[A: JsDecoder](
      uri: String Refined Url,
      headers: IList[(String, String)]
    ): F[A]
  
    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String)]
    ): F[A]
  }
  
  trait Auth[F[_]] {
    def authenticate: F[CodeToken]
  }
  trait Access[F[_]] {
    def access(code: CodeToken): F[(RefreshToken, BearerToken)]
  }
  trait Refresh[F[_]] {
    def bearer(refresh: RefreshToken): F[BearerToken]
  }
  trait OAuth2JsonClient[F[_]] {
    // same methods as JsonClient, but doing OAuth2 transparently
  }
  
  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
  
  trait Drone[F[_]] {
    def getBacklog: F[Int]
    def getAgents: F[Int]
  }
  
  trait Machines[F[_]] {
    def getTime: F[Epoch]
    def getManaged: F[NonEmptyList[MachineNode]]
    def getAlive: F[MachineNode ==&gt;&gt; Epoch]
    def start(node: MachineNode): F[Unit]
    def stop(node: MachineNode): F[Unit]
  }
</pre></div>

</figure>

<p>Note that some signatures from previous chapters have been refactored to use
Scalaz data types, now that we know why they are superior to the stdlib.</p>

<p>The data types are:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @xderiving(Order, Arbitrary)
  final case class Epoch(millis: Long) extends AnyVal
  
  @deriving(Order, Show)
  final case class MachineNode(id: String)
  
  @deriving(Equal, Show)
  final case class CodeToken(token: String, redirect_uri: String Refined Url)
  
  @xderiving(Equal, Show, ConfigReader)
  final case class RefreshToken(token: String) extends AnyVal
  
  @deriving(Equal, Show, ConfigReader)
  final case class BearerToken(token: String, expires: Epoch)
  
  @deriving(ConfigReader)
  final case class OAuth2Config(token: RefreshToken, server: ServerConfig)
  
  @deriving(ConfigReader)
  final case class AppConfig(drone: BearerToken, machines: OAuth2Config)
  
  @xderiving(UrlEncodedWriter)
  final case class UrlQuery(params: IList[(String, String)]) extends AnyVal
</pre></div>

</figure>

<p>and the typeclasses are</p>

<figure class="code">
<div class="highlight"><pre><code></code>  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
  @typeclass trait UrlQueryWriter[A] {
    def toUrlQuery(a: A): UrlQuery
  }
</pre></div>

</figure>

<p>We derive useful typeclasses using <code>scalaz-deriving</code> and Magnolia. The
<code>ConfigReader</code> typeclass is from the <code>pureconfig</code> library and is used to read
runtime configuration from HOCON property files.</p>

<p>And without going into the detail of how to implement the algebras, we need to
know the dependency graph of our <code>DynAgentsModule</code>.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class DynAgentsModule[F[_]: Applicative](
    D: Drone[F],
    M: Machines[F]
  ) extends DynAgents[F] { ... }
  
  final class DroneModule[F[_]](
    H: OAuth2JsonClient[F]
  ) extends Drone[F] { ... }
  
  final class GoogleMachinesModule[F[_]](
    H: OAuth2JsonClient[F]
  ) extends Machines[F] { ... }
</pre></div>

</figure>

<p>There are two modules implementing <code>OAuth2JsonClient</code>, one that will use the OAuth2 <code>Refresh</code> algebra (for Google) and another that reuses a non-expiring <code>BearerToken</code> (for Drone).</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class OAuth2JsonClientModule[F[_]](
    token: RefreshToken
  )(
    H: JsonClient[F],
    T: LocalClock[F],
    A: Refresh[F]
  )(
    implicit F: MonadState[F, BearerToken]
  ) extends OAuth2JsonClient[F] { ... }
  
  final class BearerJsonClientModule[F[_]: Monad](
    bearer: BearerToken
  )(
    H: JsonClient[F]
  ) extends OAuth2JsonClient[F] { ... }
</pre></div>

</figure>

<p>So far we have seen requirements for <code>F</code> to have an <code>Applicative[F]</code>, <code>Monad[F]</code>
and <code>MonadState[F, BearerToken]</code>. All of these requirements can be satisfied by
using <code>StateT[Task, BearerToken, ?]</code> as our application’s context.</p>

<p>However, some of our algebras only have one interpreter, using <code>Task</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class LocalClockTask extends LocalClock[Task] { ... }
  final class SleepTask extends Sleep[Task] { ... }
</pre></div>

</figure>

<p>But recall that our algebras can provide a <code>liftM</code> on their companion, see
Chapter 7.4 on the Monad Transformer Library, allowing us to lift a
<code>LocalClock[Task]</code> into our desired <code>StateT[Task, BearerToken, ?]</code> context, and
everything is consistent.</p>

<p>Unfortunately, that is not the end of the story. Things get more complicated
when we go to the next layer. Our <code>JsonClient</code> has an interpreter using a
different context</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class BlazeJsonClient[F[_]](H: Client[Task])(
    implicit
    F: MonadError[F, JsonClient.Error],
    I: MonadIO[F, Throwable]
  ) extends JsonClient[F] { ... }
  object BlazeJsonClient {
    def apply[F[_]](
      implicit
      F: MonadError[F, JsonClient.Error],
      I: MonadIO[F, Throwable]
    ): Task[JsonClient[F]] = ...
  }
</pre></div>

</figure>

<p>Note that the <code>BlazeJsonClient</code> constructor returns a <code>Task[JsonClient[F]]</code>, not
a <code>JsonClient[F]</code>. This is because the act of creating the client is effectful:
mutable connection pools are created and managed internally by http4s.</p>

<aside>
  <p><code>OAuth2JsonClientModule</code> requires a <code>MonadState</code> and <code>BlazeJsonClient</code> requires
<code>MonadError</code> and <code>MonadIO</code>. Our application’s context will now likely be the
combination of both:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  StateT[EitherT[Task, JsonClient.Error, ?], BearerToken, ?]
</pre></div>

  </figure>

  <p>A monad stack. Monad stacks automatically provide appropriate instances of
<code>MonadState</code> and <code>MonadError</code> when nested, so we don’t need to think about it.
If we had hard-coded the implementation in the interpreter, and returned an
<code>EitherT[Task, Error, ?]</code> from <code>BlazeJsonClient</code>, it would make it a lot harder
to instantiate.</p>

</aside>

<p>We must not forget that we need to provide a <code>RefreshToken</code> for
<code>GoogleMachinesModule</code>. We could ask the user to do all the legwork, but we are
nice and provide a separate one-shot application that uses the <code>Auth</code> and
<code>Access</code> algebras. The <code>AuthModule</code> and <code>AccessModule</code> implementations bring in
additional dependencies, but thankfully no change to the application’s <code>F[_]</code>
context.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class AuthModule[F[_]: Monad](
    config: ServerConfig
  )(
    I: UserInteraction[F]
  ) extends Auth[F] { ... }
  
  final class AccessModule[F[_]: Monad](
    config: ServerConfig
  )(
    H: JsonClient[F],
    T: LocalClock[F]
  ) extends Access[F] { ... }
  
  final class BlazeUserInteraction private (
    pserver: Promise[Void, Server[Task]],
    ptoken: Promise[Void, String]
  ) extends UserInteraction[Task] { ... }
  object BlazeUserInteraction {
    def apply(): Task[BlazeUserInteraction] = ...
  }
</pre></div>

</figure>

<p>The interpreter for <code>UserInteraction</code> is the most complex part of our codebase:
it starts an HTTP server, sends the user to visit a webpage in their browser,
captures a callback in the server, and then returns the result while safely
shutting down the web server.</p>

<p>Rather than using a <code>StateT</code> to manage this state, we use a <code>Promise</code> primitive
(from <code>ioeffect</code>). We should always use <code>Promise</code> (or <code>IORef</code>) instead of a
<code>StateT</code> when we are writing an <code>IO</code> interpreter since it allows us to contain
the abstraction. If we were to use a <code>StateT</code>, not only would it have a
performance impact on the entire application, but it would also leak internal
state management to the main application, which would become responsible for
providing the initial value. We also couldn’t use <code>StateT</code> in this scenario
because we need “wait for” semantics that are only provided by <code>Promise</code>.</p>

<h3 id="leanpub-auto-main">
<a class="anchor-link" href="#leanpub-auto-main"><i class="fa fa-link"></i></a><span class="section-number">9.2 </span><code>Main</code>
</h3>

<p>The ugliest part of FP is making sure that monads are all aligned and this tends
to happen in the <code>Main</code> entrypoint.</p>

<p>Our main loop is</p>

<figure class="code">
<div class="highlight"><pre><code></code>  state = initial()
  while True:
    state = update(state)
    state = act(state)
</pre></div>

</figure>

<p>and the good news is that the actual code will look like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    old     &lt;- F.get
    updated &lt;- A.update(old)
    changed &lt;- A.act(updated)
    _       &lt;- F.put(changed)
    _       &lt;- S.sleep(10.seconds)
  } yield ()
</pre></div>

</figure>

<p>where <code>F</code> holds the state of the world in a <code>MonadState[F, WorldView]</code>. We can
put this into a method called <code>.step</code> and repeat it forever by calling
<code>.step[F].forever[Unit]</code>.</p>

<p>There are two approaches we can take, and we will explore both. The first, and
simplest, is to construct one monad stack that all algebras are compatible with.
Everything gets a <code>.liftM</code> added to it to lift it into the larger stack.</p>

<p>The code we want to write for the one-shot authentication mode is</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def auth(name: String): Task[Unit] = {
    for {
      config    &lt;- readConfig[ServerConfig](name + ".server")
      ui        &lt;- BlazeUserInteraction()
      auth      = new AuthModule(config)(ui)
      codetoken &lt;- auth.authenticate
      client    &lt;- BlazeJsonClient
      clock     = new LocalClockTask
      access    = new AccessModule(config)(client, clock)
      token     &lt;- access.access(codetoken)
      _         &lt;- putStrLn(s"got token: $token")
    } yield ()
  }.run
</pre></div>

</figure>

<p>where <code>.readConfig</code> and <code>.putStrLn</code> are library calls. We can think of them as
<code>Task</code> interpreters of algebras that read the application’s runtime
configuration and print a string to the screen.</p>

<p>But this code does not compile, for two reasons. Firstly, we need to consider
what our monad stack is going to be. The <code>BlazeJsonClient</code> constructor returns a
<code>Task</code> but the <code>JsonClient</code> methods require a <code>MonadError[...,
JsonClient.Error]</code>. This can be provided by <code>EitherT</code>. We can therefore
construct the common monad stack for the entire <code>for</code> comprehension as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type H[a] = EitherT[Task, JsonClient.Error, a]
</pre></div>

</figure>

<p>Unfortunately this means we must <code>.liftM</code> everything that returns a <code>Task</code>,
which adds quite a lot of boilerplate. Unfortunately, the <code>.liftM</code> method does
not take a type of shape <code>H[_]</code>, it takes a type of shape <code>H[_[_], _]</code>, so we
need to create a type alias to help out the compiler:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  type HT[f[_], a] = EitherT[f, JsonClient.Error, a]
  type H[a]        = HT[Task, a]
</pre></div>

</figure>

<p>we can now call <code>.liftM[HT]</code> when we receive a <code>Task</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    config    &lt;- readConfig[ServerConfig](name + ".server").liftM[HT]
    ui        &lt;- BlazeUserInteraction().liftM[HT]
    auth      = new AuthModule(config)(ui)
    codetoken &lt;- auth.authenticate.liftM[HT]
    client    &lt;- BlazeJsonClient[H].liftM[HT]
    clock     = new LocalClockTask
    access    = new AccessModule(config)(client, clock)
    token     &lt;- access.access(codetoken)
    _         &lt;- putStrLn(s"got token: $token").liftM[HT]
  } yield ()
</pre></div>

</figure>

<p>But this still doesn’t compile, because <code>clock</code> is a <code>LocalClock[Task]</code> and <code>AccessModule</code> requires a <code>LocalClock[H]</code>. We simply add the necessary <code>.liftM</code> boilerplate to the companion of <code>LocalClock</code> and can then lift the entire algebra</p>

<figure class="code">
<div class="highlight"><pre><code></code>  clock     = LocalClock.liftM[Task, HT](new LocalClockTask)
</pre></div>

</figure>

<p>and now everything compiles!</p>

<p>The second approach to wiring up an application is more complex, but necessary
when there are conflicts in the monad stack, such as we need in our main loop.
If we perform an analysis we find that the following are needed:</p>

<ul>
  <li>
<code>MonadError[F, JsonClient.Error]</code> for uses of the <code>JsonClient</code>
</li>
  <li>
<code>MonadState[F, BearerToken]</code> for uses of the <code>OAuth2JsonClient</code>
</li>
  <li>
<code>MonadState[F, WorldView]</code> for our main loop</li>
</ul>

<p>Unfortunately, the two <code>MonadState</code> requirements are in conflict. We could
construct a data type that captures all the state of the program, but that is a
leaky abstraction. Instead, we nest our <code>for</code> comprehensions and provide state
where it is needed.</p>

<p>We now need to think about three layers, which we will call <code>F</code>, <code>G</code>, <code>H</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  type HT[f[_], a] = EitherT[f, JsonClient.Error, a]
  type GT[f[_], a] = StateT[f, BearerToken, a]
  type FT[f[_], a] = StateT[f, WorldView, a]
  
  type H[a]        = HT[Task, a]
  type G[a]        = GT[H, a]
  type F[a]        = FT[G, a]
</pre></div>

</figure>

<p>Now some bad news about <code>.liftM</code>… it only works for one layer at a time. If we
have a <code>Task[A]</code> and we want an <code>F[A]</code>, we have to go through each step and type
<code>ta.liftM[HT].liftM[GT].liftM[FT]</code>. Likewise, when lifting algebras we have to
call <code>liftM</code> multiple times. To get a <code>Sleep[F]</code>, we have to type</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val S: Sleep[F] = {
    import Sleep.liftM
    liftM(liftM(liftM(new SleepTask)))
  }
</pre></div>

</figure>

<p>and to get a <code>LocalClock[G]</code> we do two lifts</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val T: LocalClock[G] = {
    import LocalClock.liftM
    liftM(liftM(new LocalClockTask))
  }
</pre></div>

</figure>

<p>The main application then becomes</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def agents(bearer: BearerToken): Task[Unit] = {
    ...
    for {
      config &lt;- readConfig[AppConfig]
      blaze  &lt;- BlazeJsonClient[G]
      _ &lt;- {
        val bearerClient = new BearerJsonClientModule(bearer)(blaze)
        val drone        = new DroneModule(bearerClient)
        val refresh      = new RefreshModule(config.machines.server)(blaze, T)
        val oauthClient =
          new OAuth2JsonClientModule(config.machines.token)(blaze, T, refresh)
        val machines = new GoogleMachinesModule(oauthClient)
        val agents   = new DynAgentsModule(drone, machines)
        for {
          start &lt;- agents.initial
          _ &lt;- {
            val fagents = DynAgents.liftM[G, FT](agents)
            step(fagents, S).forever[Unit]
          }.run(start)
        } yield ()
      }.eval(bearer).run
    } yield ()
  }
</pre></div>

</figure>

<p>where the outer loop is using <code>Task</code>, the middle loop is using <code>G</code>, and the
inner loop is using <code>F</code>.</p>

<p>The calls to <code>.run(start)</code> and <code>.eval(bearer)</code> are where we provide the initial
state for the <code>StateT</code> parts of our application. The <code>.run</code> is to reveal the
<code>EitherT</code> error.</p>

<p>We can call these two application entry points from our <code>SafeApp</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  object Main extends SafeApp {
    def run(args: List[String]): IO[Void, ExitStatus] = {
      if (args.contains("--machines")) auth("machines")
      else agents(BearerToken("&lt;invalid&gt;", Epoch(0)))
    }.attempt[Void].map {
      case \/-(_)   =&gt; ExitStatus.ExitNow(0)
      case -\/(err) =&gt; ExitStatus.ExitNow(1)
    }
  }
</pre></div>

</figure>

<p>and then run it!</p>

<figure class="code">
<div class="highlight"><pre><code></code>  &gt; runMain fommil.dda.Main --machines
  [info] Running (fork) fommil.dda.Main --machines
  ...
  [info] Service bound to address /127.0.0.1:46687
  ...
  [info] Created new window in existing browser session.
  ...
  [info] Headers(Host: localhost:46687, Connection: keep-alive, User-Agent: Mozilla/5.0 ...)
  ...
  [info] POST https://www.googleapis.com/oauth2/v4/token
  ...
  [info] got token: "&lt;elided&gt;"
</pre></div>

</figure>

<p>Yay!</p>

<h3 id="leanpub-auto-blaze">
<a class="anchor-link" href="#leanpub-auto-blaze"><i class="fa fa-link"></i></a><span class="section-number">9.3 </span>Blaze</h3>

<p>We implement the HTTP client and server with the third party library <code>http4s</code>.
The interpreters for their client and server algebras are called <em>Blaze</em>.</p>

<p>We need the following dependencies</p>

<figure class="code">
<div class="highlight"><pre><code></code>  val http4sVersion = "0.18.16"
  libraryDependencies ++= Seq(
    "org.http4s"            %% "http4s-dsl"          % http4sVersion,
    "org.http4s"            %% "http4s-blaze-server" % http4sVersion,
    "org.http4s"            %% "http4s-blaze-client" % http4sVersion
  )
</pre></div>

</figure>

<h4 id="leanpub-auto-blazejsonclient">
<a class="anchor-link" href="#leanpub-auto-blazejsonclient"><i class="fa fa-link"></i></a><span class="section-number">9.3.1 </span><code>BlazeJsonClient</code>
</h4>

<p>We will need some imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import org.http4s
  import org.http4s.{ EntityEncoder, MediaType }
  import org.http4s.headers.`Content-Type`
  import org.http4s.client.Client
  import org.http4s.client.blaze.{ BlazeClientConfig, Http1Client }
</pre></div>

</figure>

<p>The <code>Client</code> module can be summarised as</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class Client[F[_]](
    val shutdown: F[Unit]
  )(implicit F: MonadError[F, Throwable]) {
    def fetch[A](req: Request[F])(f: Response[F] =&gt; F[A]): F[A] = ...
    ...
  }
</pre></div>

</figure>

<p>where <code>Request</code> and <code>Response</code> are data types:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Request[F[_]](
    method: Method
    uri: Uri,
    headers: Headers,
    body: EntityBody[F]
  ) {
    def withBody[A](a: A)
                   (implicit F: Monad[F], A: EntityEncoder[F, A]): F[Request[F]] = ...
    ...
  }
  
  final case class Response[F[_]](
    status: Status,
    headers: Headers,
    body: EntityBody[F]
  )
</pre></div>

</figure>

<p>made of</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final case class Headers(headers: List[Header])
  final case class Header(name: String, value: String)
  
  final case class Uri( ... )
  object Uri {
    // not total, only use if `s` is guaranteed to be a URL
    def unsafeFromString(s: String): Uri = ...
    ...
  }
  
  final case class Status(code: Int) {
    def isSuccess: Boolean = ...
    ...
  }
  
  type EntityBody[F[_]] = fs2.Stream[F, Byte]
</pre></div>

</figure>

<p>The <code>EntityBody</code> type is an alias to <code>Stream</code> from the <a href="https://github.com/functional-streams-for-scala/fs2"><code>fs2</code></a> library. The
<code>Stream</code> data type can be thought of as an effectful, lazy, pull-based stream of
data. It is implemented as a <code>Free</code> monad with exception catching and
interruption. <code>Stream</code> takes two type parameters: an effect type and a content
type, and has an efficient internal representation for batching the data. For
example, although we are using <code>Stream[F, Byte]</code>, it is actually wrapping the
raw <code>Array[Byte]</code> that arrives over the network.</p>

<p>We need to convert our header and URL representations into the versions required
by http4s:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def convert(headers: IList[(String, String)]): http4s.Headers =
    http4s.Headers(
      headers.foldRight(List[http4s.Header]()) {
        case ((key, value), acc) =&gt; http4s.Header(key, value) :: acc
      }
    )
  
  def convert(uri: String Refined Url): http4s.Uri =
    http4s.Uri.unsafeFromString(uri.value) // we already validated our String
</pre></div>

</figure>

<p>Both our <code>.get</code> and <code>.post</code> methods require a conversion from the http4s
<code>Response</code> type into an <code>A</code>. We can factor this out into a single function,
<code>.handler</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  import JsonClient.Error
  
  final class BlazeJsonClient[F[_]] private (H: Client[Task])(
    implicit
    F: MonadError[F, Error],
    I: MonadIO[F, Throwable]
  ) extends JsonClient[F] {
    ...
    def handler[A: JsDecoder](resp: http4s.Response[Task]): Task[Error \/ A] = {
      if (!resp.status.isSuccess)
        Task.now(JsonClient.ServerError(resp.status.code).left)
      else
        for {
          text &lt;- resp.body.through(fs2.text.utf8Decode).compile.foldMonoid
          res = JsParser(text)
            .flatMap(_.as[A])
            .leftMap(JsonClient.DecodingError(_))
        } yield res
    }
  }
</pre></div>

</figure>

<p>The <code>.through(fs2.text.utf8Decode)</code> is to convert a <code>Stream[Task, Byte]</code> into a
<code>Stream[Task, String]</code>, with <code>.compile.foldMonoid</code> interpreting it with our
<code>Task</code> and combining all the parts using the <code>Monoid[String]</code>, giving us a
<code>Task[String]</code>.</p>

<p>We then parse the string as JSON and use the <code>JsDecoder[A]</code> to create the
required output.</p>

<p>This is our implementation of <code>.get</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  def get[A: JsDecoder](
    uri: String Refined Url,
    headers: IList[(String, String)]
  ): F[A] =
    I.liftIO(
        H.fetch(
          http4s.Request[Task](
            uri = convert(uri),
            headers = convert(headers)
          )
        )(handler[A])
      )
      .emap(identity)
</pre></div>

</figure>

<p><code>.get</code> is all plumbing: we convert our input types into the <code>http4s.Request</code>,
then call <code>.fetch</code> on the <code>Client</code> with our <code>handler</code>. This gives us back a
<code>Task[Error \/ A]</code>, but we need to return a <code>F[A]</code>. Therefore we use the
<code>MonadIO.liftIO</code> to create a <code>F[Error \/ A]</code> and then <code>.emap</code> to push the error
into the <code>F</code>.</p>

<p>Unfortunately, if we try to compile this code it will fail. The error will look
something like</p>

<figure class="code">
<div class="highlight"><pre><code></code>  [error] BlazeJsonClient.scala:95:64: could not find implicit value for parameter
  [error]  F: cats.effect.Sync[scalaz.ioeffect.Task]
</pre></div>

</figure>

<p>Basically, something about a missing cat.</p>

<p>The reason for this failure is that http4s is using a different core FP library,
not Scalaz. Thankfully, <code>scalaz-ioeffect</code> provides a compatibility layer and the
<a href="https://github.com/djspiewak/shims">shims</a> project provides seamless (until it isn’t) implicit conversions. We can
get our code to compile with these dependencies:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  libraryDependencies ++= Seq(
    "com.codecommit" %% "shims"                % "1.4.0",
    "org.scalaz"     %% "scalaz-ioeffect-cats" % "2.10.1"
  )
</pre></div>

</figure>

<p>and these imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import shims._
  import scalaz.ioeffect.catz._
</pre></div>

</figure>

<p>The implementation of <code>.post</code> is similar but we must also provide an instance of</p>

<figure class="code">
<div class="highlight"><pre><code></code>  EntityEncoder[Task, String Refined UrlEncoded]
</pre></div>

</figure>

<p>Thankfully, the <code>EntityEncoder</code> typeclass provides conveniences to let us derive
one from the existing <code>String</code> encoder</p>

<figure class="code">
<div class="highlight"><pre><code></code>  implicit val encoder: EntityEncoder[Task, String Refined UrlEncoded] =
    EntityEncoder[Task, String]
      .contramap[String Refined UrlEncoded](_.value)
      .withContentType(
        `Content-Type`(MediaType.`application/x-www-form-urlencoded`)
      )
</pre></div>

</figure>

<p>The only difference between <code>.get</code> and <code>.post</code> is the way we construct our <code>http4s.Request</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  http4s.Request[Task](
    method = http4s.Method.POST,
    uri = convert(uri),
    headers = convert(headers)
  )
  .withBody(payload.toUrlEncoded)
</pre></div>

</figure>

<p>and the final piece is the constructor, which is a case of calling <code>Http1Client</code>
with a configuration object</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object BlazeJsonClient {
    def apply[F[_]](
      implicit
      F: MonadError[F, JsonClient.Error],
      I: MonadIO[F, Throwable]
    ): Task[JsonClient[F]] =
      Http1Client(BlazeClientConfig.defaultConfig).map(new BlazeJsonClient(_))
  }
</pre></div>

</figure>

<h4 id="leanpub-auto-blazeuserinteraction">
<a class="anchor-link" href="#leanpub-auto-blazeuserinteraction"><i class="fa fa-link"></i></a><span class="section-number">9.3.2 </span><code>BlazeUserInteraction</code>
</h4>

<p>We need to spin up an HTTP server, which is a lot easier than it sounds. First,
the imports</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import org.http4s._
  import org.http4s.dsl._
  import org.http4s.server.Server
  import org.http4s.server.blaze._
</pre></div>

</figure>

<p>We need to create a <code>dsl</code> for our effect type, which we then import</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private val dsl = new Http4sDsl[Task] {}
  import dsl._
</pre></div>

</figure>

<p>Now we can use the <a href="https://http4s.org/v0.18/dsl/">http4s dsl</a> to create HTTP endpoints. Rather than describe
everything that can be done, we will simply implement the endpoint which is
similar to any of other HTTP DSLs</p>

<figure class="code">
<div class="highlight"><pre><code></code>  private object Code extends QueryParamDecoderMatcher[String]("code")
  private val service: HttpService[Task] = HttpService[Task] {
    case GET -&gt; Root :? Code(code) =&gt; ...
  }
</pre></div>

</figure>

<p>The return type of each pattern match is a <code>Task[Response[Task]]</code>. In our
implementation we want to take the <code>code</code> and put it into the <code>ptoken</code> promise:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  final class BlazeUserInteraction private (
    pserver: Promise[Throwable, Server[Task]],
    ptoken: Promise[Throwable, String]
  ) extends UserInteraction[Task] {
    ...
    private val service: HttpService[Task] = HttpService[Task] {
      case GET -&gt; Root :? Code(code) =&gt;
        ptoken.complete(code) &gt;&gt; Ok(
          "That seems to have worked, go back to the console."
        )
    }
    ...
  }
</pre></div>

</figure>

<p>but the definition of our services routes is not enough, we need to launch a
server, which we do with <code>BlazeBuilder</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  private val launch: Task[Server[Task]] =
    BlazeBuilder[Task].bindHttp(0, "localhost").mountService(service, "/").start
</pre></div>

</figure>

<p>Binding to port <code>0</code> makes the operating system assign an ephemeral port. We can
discover which port it is actually running on by querying the <code>server.address</code>
field.</p>

<p>Our implementation of the <code>.start</code> and <code>.stop</code> methods is now straightforward</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def start: Task[String Refined Url] =
    for {
      server  &lt;- launch
      updated &lt;- pserver.complete(server)
      _ &lt;- if (updated) Task.unit
           else server.shutdown *&gt; fail("server was already running")
    } yield mkUrl(server)
  
  def stop: Task[CodeToken] =
    for {
      server &lt;- pserver.get
      token  &lt;- ptoken.get
      _      &lt;- IO.sleep(1.second) *&gt; server.shutdown
    } yield CodeToken(token, mkUrl(server))
  
  private def mkUrl(s: Server[Task]): String Refined Url = {
    val port = s.address.getPort
    Refined.unsafeApply(s"http://localhost:${port}/")
  }
  private def fail[A](s: String): String =
    Task.fail(new IOException(s) with NoStackTrace)
</pre></div>

</figure>

<p>The <code>1.second</code> sleep is necessary to avoid shutting down the server before the
response is sent back to the browser. IO doesn’t mess around when it comes to
concurrency performance!</p>

<p>Finally, to create a <code>BlazeUserInteraction</code>, we just need the two uninitialised
promises</p>

<figure class="code">
<div class="highlight"><pre><code></code>  object BlazeUserInteraction {
    def apply(): Task[BlazeUserInteraction] = {
      for {
        p1 &lt;- Promise.make[Void, Server[Task]].widenError[Throwable]
        p2 &lt;- Promise.make[Void, String].widenError[Throwable]
      } yield new BlazeUserInteraction(p1, p2)
    }
  }
</pre></div>

</figure>

<p>We could use <code>IO[Void, ?]</code> instead, but since the rest of our application is
using <code>Task</code> (i.e. <code>IO[Throwable, ?]</code>), we <code>.widenError</code> to avoid introducing
any boilerplate that would distract us.</p>

<h3 id="leanpub-auto-thank-you">
<a class="anchor-link" href="#leanpub-auto-thank-you"><i class="fa fa-link"></i></a><span class="section-number">9.4 </span>Thank You</h3>

<p>And that is it! Congratulations on reaching the end.</p>

<p>If you learnt something from this book, then please tell your friends. This book
does not have a marketing department, so word of mouth is the only way that
readers find out about it.</p>

<p>Get involved with Scalaz by joining the <a href="https://gitter.im/scalaz/scalaz">gitter chat room</a>. From there you can ask
for advice, help newcomers (you’re an expert now), and contribute to the next
release.</p>



<h2 id="leanpub-auto-typeclass-cheatsheet">
<a class="anchor-link" href="#leanpub-auto-typeclass-cheatsheet"><i class="fa fa-link"></i></a>Typeclass Cheatsheet</h2>

<table>
  <thead>
    <tr>
      <th>Typeclass</th>
      <th>Method</th>
      <th>From</th>
      <th>Given</th>
      <th>To</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>InvariantFunctor</code></td>
      <td><code>xmap</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; B, B =&gt; A</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td><code>Contravariant</code></td>
      <td><code>contramap</code></td>
      <td><code>F[A]</code></td>
      <td><code>B =&gt; A</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td><code>Functor</code></td>
      <td><code>map</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; B</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td><code>Apply</code></td>
      <td>
<code>ap</code> / <code>&lt;*&gt;</code>
</td>
      <td><code>F[A]</code></td>
      <td><code>F[A =&gt; B]</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>apply2</code></td>
      <td><code>F[A], F[B]</code></td>
      <td><code>(A, B) =&gt; C</code></td>
      <td><code>F[C]</code></td>
    </tr>
    <tr>
      <td><code>Alt</code></td>
      <td><code>altly2</code></td>
      <td><code>F[A], F[B]</code></td>
      <td><code>(A \/ B) =&gt; C</code></td>
      <td><code>F[C]</code></td>
    </tr>
    <tr>
      <td><code>Divide</code></td>
      <td><code>divide2</code></td>
      <td><code>F[A], F[B]</code></td>
      <td><code>C =&gt; (A, B)</code></td>
      <td><code>F[C]</code></td>
    </tr>
    <tr>
      <td><code>Decidable</code></td>
      <td><code>choose2</code></td>
      <td><code>F[A], F[B]</code></td>
      <td><code>C =&gt; (A \/ B)</code></td>
      <td><code>F[C]</code></td>
    </tr>
    <tr>
      <td><code>Bind</code></td>
      <td>
<code>bind</code> / <code>&gt;&gt;=</code>
</td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; F[B]</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>join</code></td>
      <td><code>F[F[A]]</code></td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Cobind</code></td>
      <td><code>cobind</code></td>
      <td><code>F[A]</code></td>
      <td><code>F[A] =&gt; B</code></td>
      <td><code>F[B]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>cojoin</code></td>
      <td><code>F[A]</code></td>
      <td>&nbsp;</td>
      <td><code>F[F[A]]</code></td>
    </tr>
    <tr>
      <td><code>Applicative</code></td>
      <td><code>point</code></td>
      <td><code>A</code></td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Divisible</code></td>
      <td><code>conquer</code></td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Comonad</code></td>
      <td><code>copoint</code></td>
      <td><code>F[A]</code></td>
      <td>&nbsp;</td>
      <td><code>A</code></td>
    </tr>
    <tr>
      <td><code>Semigroup</code></td>
      <td><code>append</code></td>
      <td><code>A, A</code></td>
      <td>&nbsp;</td>
      <td><code>A</code></td>
    </tr>
    <tr>
      <td><code>Plus</code></td>
      <td>
<code>plus</code> / <code>&lt;+&gt;</code>
</td>
      <td><code>F[A], F[A]</code></td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>MonadPlus</code></td>
      <td><code>withFilter</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; Boolean</code></td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Align</code></td>
      <td><code>align</code></td>
      <td><code>F[A], F[B]</code></td>
      <td>&nbsp;</td>
      <td><code>F[A \&amp;/ B]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>merge</code></td>
      <td><code>F[A], F[A]</code></td>
      <td>&nbsp;</td>
      <td><code>F[A]</code></td>
    </tr>
    <tr>
      <td><code>Zip</code></td>
      <td><code>zip</code></td>
      <td><code>F[A], F[B]</code></td>
      <td>&nbsp;</td>
      <td><code>F[(A, B)]</code></td>
    </tr>
    <tr>
      <td><code>Unzip</code></td>
      <td><code>unzip</code></td>
      <td><code>F[(A, B)]</code></td>
      <td>&nbsp;</td>
      <td><code>(F[A], F[B])</code></td>
    </tr>
    <tr>
      <td><code>Cozip</code></td>
      <td><code>cozip</code></td>
      <td><code>F[A \/ B]</code></td>
      <td>&nbsp;</td>
      <td><code>F[A] \/ F[B]</code></td>
    </tr>
    <tr>
      <td><code>Foldable</code></td>
      <td><code>foldMap</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; B</code></td>
      <td><code>B</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>foldMapM</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; G[B]</code></td>
      <td><code>G[B]</code></td>
    </tr>
    <tr>
      <td><code>Traverse</code></td>
      <td><code>traverse</code></td>
      <td><code>F[A]</code></td>
      <td><code>A =&gt; G[B]</code></td>
      <td><code>G[F[B]]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>sequence</code></td>
      <td><code>F[G[A]]</code></td>
      <td>&nbsp;</td>
      <td><code>G[F[A]]</code></td>
    </tr>
    <tr>
      <td><code>Equal</code></td>
      <td>
<code>equal</code> / <code>===</code>
</td>
      <td><code>A, A</code></td>
      <td>&nbsp;</td>
      <td><code>Boolean</code></td>
    </tr>
    <tr>
      <td><code>Show</code></td>
      <td><code>shows</code></td>
      <td><code>A</code></td>
      <td>&nbsp;</td>
      <td><code>String</code></td>
    </tr>
    <tr>
      <td><code>Bifunctor</code></td>
      <td><code>bimap</code></td>
      <td><code>F[A, B]</code></td>
      <td><code>A =&gt; C, B =&gt; D</code></td>
      <td><code>F[C, D]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>leftMap</code></td>
      <td><code>F[A, B]</code></td>
      <td><code>A =&gt; C</code></td>
      <td><code>F[C, B]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>rightMap</code></td>
      <td><code>F[A, B]</code></td>
      <td><code>B =&gt; C</code></td>
      <td><code>F[A, C]</code></td>
    </tr>
    <tr>
      <td><code>Bifoldable</code></td>
      <td><code>bifoldMap</code></td>
      <td><code>F[A, B]</code></td>
      <td><code>A =&gt; C, B =&gt; C</code></td>
      <td><code>C</code></td>
    </tr>
    <tr>
      <td>(with <code>MonadPlus</code>)</td>
      <td><code>separate</code></td>
      <td><code>F[G[A, B]]</code></td>
      <td>&nbsp;</td>
      <td><code>(F[A], F[B])</code></td>
    </tr>
    <tr>
      <td><code>Bitraverse</code></td>
      <td><code>bitraverse</code></td>
      <td><code>F[A, B]</code></td>
      <td><code>A =&gt; G[C], B =&gt; G[D]</code></td>
      <td><code>G[F[C, D]]</code></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td><code>bisequence</code></td>
      <td><code>F[G[A], G[B]]</code></td>
      <td>&nbsp;</td>
      <td><code>G[F[A, B]]</code></td>
    </tr>
  </tbody>

</table>

<h2 id="leanpub-auto-haskell">
<a class="anchor-link" href="#leanpub-auto-haskell"><i class="fa fa-link"></i></a>Haskell</h2>

<p>Scalaz documentation often cites libraries or papers written in the Haskell
programming language. In this short chapter, we will learn enough Haskell to be
able to understand the source material, and to attend Haskell talks at
functional programming conferences.</p>

<h3 id="leanpub-auto-data-2">
<a class="anchor-link" href="#leanpub-auto-data-2"><i class="fa fa-link"></i></a>Data</h3>

<p>Haskell has a very clean syntax for ADTs. This is a linked list structure:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  data List a = Nil | Cons a (List a)
</pre></div>

</figure>

<p><code>List</code> is a <em>type constructor</em>, <code>a</code> is the <em>type parameter</em>, <code>|</code> separates the
<em>data constructors</em>, which are: <code>Nil</code> the empty list and a <code>Cons</code> cell. <code>Cons</code>
takes two parameters, which are separated by whitespace: no commas and no
parameter brackets.</p>

<p>There is no subtyping in Haskell, so there is no such thing as the <code>Nil</code> type or
the <code>Cons</code> type: both construct a <code>List</code>.</p>

<p>Roughly translated to Scala:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  sealed abstract class List[A]
  object Nil {
    def apply[A]: List[A] = ...
    def unapply[A](as: List[A]): Option[Unit] = ...
  }
  object Cons {
    def apply[A](head: A, tail: List[A]): List[A] = ...
    def unapply[A](as: List[A]): Option[(A, List[A])] = ...
  }
</pre></div>

</figure>

<p>i.e. the type constructor is like <code>sealed abstract class</code>, and each data
constructor is <code>.apply</code> / <code>.unapply</code>. Note that Scala does not perform
exhaustive pattern matches on this encoding, which is why Scalaz does not use
it.</p>

<p>We can use infix, a nicer definition might use the symbol <code>:.</code> instead of <code>Cons</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  data List t = Nil | t :. List t
  infixr 5 :.
</pre></div>

</figure>

<p>where we specify a <em>fixity</em>, which can be <code>infix</code>, <code>infixl</code> or <code>infixr</code> for no,
left, and right associativity, respectively. A number from 0 (loose) to 9
(tight) specifies precedence. We can now create a list of integers by typing</p>

<figure class="code">
<div class="highlight"><pre><code></code>  1 :. 2 :. Nil
</pre></div>

</figure>

<p>Haskell already comes with a linked list, which is so fundamental to functional
programming that it gets language-level square bracket syntax <code>[a]</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  data [] a = [] | a : [a]
  infixr 5 :
</pre></div>

</figure>

<p>and a convenient multi-argument value constructor: <code>[1, 2, 3]</code> instead of <code>1 :
2 : 3 : []</code>.</p>

<p>Ultimately our ADTs need to hold primitive values. The most common primitive
data types are:</p>

<ul>
  <li>
<code>Char</code> a unicode character</li>
  <li>
<code>Text</code> for blocks of unicode text</li>
  <li>
<code>Int</code> a machine dependent, fixed precision signed integer</li>
  <li>
<code>Word</code> an unsigned <code>Int</code>, and fixed size <code>Word8</code> / <code>Word16</code> / <code>Word32</code> / <code>Word64</code>
</li>
  <li>
<code>Float</code> / <code>Double</code> IEEE single and double precision numbers</li>
  <li>
<code>Integer</code> / <code>Natural</code> arbitrary precision signed / non-negative integers</li>
  <li>
<code>(,)</code> tuples, from 0 (also known as <em>unit</em>) to 62 fields</li>
  <li>
<code>IO</code> the inspiration for Scalaz’s <code>IO</code>, implemented in the runtime.</li>
</ul>

<p>with honorary mentions for</p>

<figure class="code">
<div class="highlight"><pre><code></code>  data Bool       = True | False
  data Maybe a    = Nothing | Just a
  data Either a b = Left a  | Right b
  data Ordering   = LT | EQ | GT
</pre></div>

</figure>

<p>Like Scala, Haskell has type aliases: an alias or its expanded form can be used
interchangeably. For legacy reasons, <code>String</code> is defined as a linked list of
<code>Char</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  type String = [Char]
</pre></div>

</figure>

<p>which is very inefficient and we always want to use <code>Text</code> instead.</p>

<p>Finally we can define field names on ADTs using <em>record syntax</em>, which means we
contain the data constructors in curly brackets and use double colon <em>type
annotations</em> to indicate the types</p>

<figure class="code">
<div class="highlight"><pre><code></code>  -- raw ADT
  data Resource = Human Int String
  data Company  = Company String [Resource]
  
  -- with record syntax
  data Resource = Human
                  { serial    :: Int
                  , humanName :: String
                  }
  data Company  = Company
                  { companyName :: String
                  , employees   :: [Resource]
                  }
</pre></div>

</figure>

<p>Note that the <code>Human</code> data constructor and <code>Resource</code> type do not have the same
name. Record syntax generates the equivalent of a field accessor and a copy
method.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  -- construct
  adam = Human 0 Adam
  -- field access
  serial adam
  -- copy
  eve = adam { humanName = "Eve" }
</pre></div>

</figure>

<p>A more efficient alternative to single field <code>data</code> definitions is to use a
<code>newtype</code>, which has no runtime overhead:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  newtype Alpha = Alpha { underlying :: Double }
</pre></div>

</figure>

<p>equivalent to <code>extends AnyVal</code> but without the caveats.</p>

<aside>
  <p>A limitation of Haskell’s record syntax is that a field name cannot be used in
different data types. However, we can workaround this by enabling a <code>LANGUAGE</code>
extension, allowing us to use <code>name</code> in both <code>Human</code> and <code>Company</code>:</p>

  <figure class="code">
<div class="highlight"><pre><code></code>  {-# LANGUAGE DuplicateRecordFields #-}
  
  data Resource = Human
                  { serial :: Int
                  , name   :: String
                  }
  data Company  = Company
                  { name      :: String
                  , employees :: [Resource]
                  }
</pre></div>

  </figure>

  <p>There are a lot of language extensions and it is not uncommon to have 20 or more
in a small project. Haskell is extremely conservative and new language features
are opt-in for a long period of time before they can be accepted into the
language standard.</p>

</aside>

<h3 id="leanpub-auto-functions">
<a class="anchor-link" href="#leanpub-auto-functions"><i class="fa fa-link"></i></a>Functions</h3>

<p>Although not necessary, it is good practice to explicitly write the type
signature of a function: its name followed by its type. For example <code>foldl</code>
specialised for a linked list</p>

<figure class="code">
<div class="highlight"><pre><code></code>  foldl :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b
</pre></div>

</figure>

<p>All functions are <em>curried</em> in Haskell, each parameter is separated by a <code>-&gt;</code>
and the final type is the return type. This is equivalent to the following Scala
signature:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  def foldLeft[A, B](f: (B, A) =&gt; B)(b: B)(as: List[A]): B
</pre></div>

</figure>

<p>Some observations:</p>

<ul>
  <li>there is no keyword</li>
  <li>there is no need to declare the types that are introduced</li>
  <li>there is no need to name the parameters</li>
</ul>

<p>which makes for terse code.</p>

<p>Infix functions are defined in parentheses and need a fixity definition:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (++) :: [a] -&gt; [a] -&gt; [a]
  infixr 5 ++
</pre></div>

</figure>

<p>Regular functions can be called in infix position by surrounding their name with
backticks. The following are equivalent:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  a `foo` b
  foo a b
</pre></div>

</figure>

<p>An infix function can be called like a regular function if we keep it surrounded
by brackets, and can be curried on either the left or the right, often giving
different semantics:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  invert = (1.0 /)
  half   = (/ 2.0)
</pre></div>

</figure>

<p>Functions are typically written with the most general parameter first, to enable
maximum reuse of the curried forms.</p>

<p>The definition of a function may use pattern matching, with one line per case.
This is where we may name the parameters, using the data constructors to extract
parameters much like a Scala <code>case</code> clause:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
  fmap f (Just a) = Just (f a)
  fmap _ Nothing  = Nothing
</pre></div>

</figure>

<p>Underscores are a placeholder for ignored parameters and function names can be
in infix position:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (&lt;+&gt;) :: Maybe a -&gt; Maybe a -&gt; Maybe a
  Just a &lt;+&gt; _      = Just a
  Empty  &lt;+&gt; Just a = Just a
  Empty  &lt;+&gt; Empty  = Empty
</pre></div>

</figure>

<p>We can define anonymous lambda functions with a backslash, which looks like the
Greek letter λ. The following are equivalent:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (*)
  (\a1 -&gt; \a2 -&gt; a1 * a2)
  (\a1 a2     -&gt; a1 * a2)
</pre></div>

</figure>

<p>Pattern matched Haskell functions are just syntax sugar for nested lambda
functions. Consider a simple function that creates a tuple when given three
inputs:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  tuple :: a -&gt; b -&gt; c -&gt; (a, b, c)
</pre></div>

</figure>

<p>The implementation</p>

<figure class="code">
<div class="highlight"><pre><code></code>  tuple a b c = (a, b, c)
</pre></div>

</figure>

<p>desugars into</p>

<figure class="code">
<div class="highlight"><pre><code></code>  tuple = \a -&gt; \b -&gt; \c -&gt; (a, b, c)
</pre></div>

</figure>

<p>In the body of a function we can create local value bindings with <code>let</code> or
<code>where</code> clauses. The following are equivalent definitions of <code>map</code> for a linked
list (an apostrophe is a valid identifier name):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  map :: (a -&gt; b) -&gt; [a] -&gt; [b]
  
  -- explicit
  map f as = foldr map' [] as
             where map' a bs = f a : bs
  
  -- terser, making use of currying
  map f    = foldr map' []
             where map' a = (f a :)
  
  -- let binding
  map f    = let map' a = (f a :)
             in foldr map' []
  
  -- actual implementation
  map _ []       = []
  map f (x : xs) = f x : map f xs
</pre></div>

</figure>

<p><code>if</code> / <code>then</code> / <code>else</code> are keywords for conditional statements:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
  filter _ [] = []
  filter f (head : tail) = if f head
                           then head : filter f tail
                           else filter f tail
</pre></div>

</figure>

<p>An alternative style is to use <em>case guards</em></p>

<figure class="code">
<div class="highlight"><pre><code></code>  filter f (head : tail) | f head    = head : filter f tail
                         | otherwise = filter f tail
</pre></div>

</figure>

<p>Pattern matching on any term is with <code>case ... of</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  unfoldr :: (a -&gt; Maybe (b, a)) -&gt; a -&gt; [b]
  unfoldr f b = case f b of
                  Just (b', a') -&gt; b' : unfoldr f a'
                  Nothing       -&gt; []
</pre></div>

</figure>

<p>Guards can be used within matches. For example, say we want to special case
zeros:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  unfoldrInt :: (a -&gt; Maybe (Int, a)) -&gt; a -&gt; [Int]
  unfoldrInt f b = case f b of
                     Just (i, a') | i == 0    -&gt; unfoldrInt f a'
                                  | otherwise -&gt; i : unfoldrInt f a'
                     Nothing                  -&gt; []
</pre></div>

</figure>

<p>Finally, two functions that are worth noting are <code>($)</code> and <code>(.)</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  -- application operator
  ($) :: (a -&gt; b) -&gt; a -&gt; b
  infixr 0
  
  -- function composition
  (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
  infixr 9
</pre></div>

</figure>

<p>Both of these functions are stylistic alternatives to nested parentheses.</p>

<p>The following are equivalent:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  Just (f a)
  Just $ f a
</pre></div>

</figure>

<p>as are</p>

<figure class="code">
<div class="highlight"><pre><code></code>  putStrLn (show (1 + 1))
  putStrLn $ show $ 1 + 1
</pre></div>

</figure>

<p>There is a tendency to prefer function composition with <code>.</code> instead of multiple
<code>$</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  (putStrLn . show) $ 1 + 1
</pre></div>

</figure>

<h3 id="leanpub-auto-typeclasses">
<a class="anchor-link" href="#leanpub-auto-typeclasses"><i class="fa fa-link"></i></a>Typeclasses</h3>

<p>To define a typeclass we use the <code>class</code> keyword, followed by the name of the
typeclass, its type parameter, then the required members in a <code>where</code> clause.</p>

<p>If there are dependencies between typeclasses, i.e. <code>Applicative</code> requires a
<code>Functor</code> to exist, we call this a <em>constraint</em> and use <code>=&gt;</code> notation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class Functor f where
    (&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b
    infixl 4 &lt;$&gt;
  
  class Functor f =&gt; Applicative f where
    pure  :: a -&gt; f a
    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b
    infixl 4 &lt;*&gt;
  
  class Applicative f =&gt; Monad f where
    (=&lt;&lt;) :: (a -&gt; f b) -&gt; f a -&gt; f b
    infixr 1 =&lt;&lt;
</pre></div>

</figure>

<p>We provide an implementation of a typeclass with the <code>instance</code> keyword. If we
wish to repeat the type signature on instance functions, useful for clarity, we
must enable the <code>InstanceSigs</code> language extension.</p>

<figure class="code">
<div class="highlight"><pre><code></code>  {-# LANGUAGE InstanceSigs #-}
  
  data List a = Nil | a :. List a
  
  -- defined elsewhere
  (++) :: List a -&gt; List a -&gt; List a
  map :: (a -&gt; b) -&gt; List a -&gt; List b
  flatMap :: (a -&gt; List b) -&gt; List a -&gt; List b
  foldLeft :: (b -&gt; a -&gt; b) -&gt; b -&gt; List a -&gt; b
  
  instance Functor List where
    (&lt;$&gt;) :: (a -&gt; b) -&gt; List a -&gt; List b
    f &lt;$&gt; as = map f as
  
  instance Applicative List where
    pure a = a :. Nil
  
    Nil &lt;*&gt; _  = Nil
    fs  &lt;*&gt; as = foldLeft (++) Nil $ (&lt;$&gt; as) &lt;$&gt; fs
  
  instance Monad List where
    f =&lt;&lt; list = flatMap f list
</pre></div>

</figure>

<p>If we have a typeclass constraint in a function, we use the same <code>=&gt;</code> notation.
For example we can define something similar to Scalaz’s <code>Apply.apply2</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  apply2 :: Applicative f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c
  apply2 f fa fb = f &lt;$&gt; fa &lt;*&gt; fb
</pre></div>

</figure>

<p>Since we have introduced <code>Monad</code>, it is a good time to introduce <code>do</code> notation,
which was the inspiration for Scala’s <code>for</code> comprehensions:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  do
    a &lt;- f
    b &lt;- g
    c &lt;- h
    pure (a, b, c)
</pre></div>

</figure>

<p>desugars to</p>

<figure class="code">
<div class="highlight"><pre><code></code>  f &gt;&gt;= \a -&gt;
    g &gt;&gt;= \b -&gt;
      h &gt;&gt;= \c -&gt;
        pure (a, b, c)
</pre></div>

</figure>

<p>where <code>&gt;&gt;=</code> is <code>=&lt;&lt;</code> with parameters flipped</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (&gt;&gt;=) :: Monad f =&gt; f a -&gt; (a -&gt; f b) -&gt; f b
  (&gt;&gt;=) = flip (=&lt;&lt;)
  infixl 1 &gt;&gt;=
  
  -- from the stdlib
  flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</pre></div>

</figure>

<p>Unlike Scala, we do not need to bind unit values, or provide a <code>yield</code> if we are
returning <code>()</code>. For example</p>

<figure class="code">
<div class="highlight"><pre><code></code>  for {
    _ &lt;- putStr("hello")
    _ &lt;- putStr(" world")
  } yield ()
</pre></div>

</figure>

<p>translates to</p>

<figure class="code">
<div class="highlight"><pre><code></code>  do putStr "hello"
     putStr " world"
</pre></div>

</figure>

<p>Non-monadic values can be bound with the <code>let</code> keyword:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  nameReturn :: IO String
  nameReturn = do putStr "What is your first name? "
                  first &lt;- getLine
                  putStr "And your last name? "
                  last  &lt;- getLine
                  let full = first ++ " " ++ last
                  putStrLn ("Pleased to meet you, " ++ full ++ "!")
                  pure full
</pre></div>

</figure>

<p>Finally, Haskell has typeclass derivation with the <code>deriving</code> keyword, the
inspiration for <code>@scalaz.deriving</code>. Defining the derivation rules is an advanced
topic, but it is easy to derive a typeclass for an ADT:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  data List a = Nil | a :. List a
                deriving (Eq, Ord)
</pre></div>

</figure>

<h3 id="leanpub-auto-algebras">
<a class="anchor-link" href="#leanpub-auto-algebras"><i class="fa fa-link"></i></a>Algebras</h3>

<p>In Scala, typeclasses and algebras are both defined as a <code>trait</code> interface.
Typeclasses are injected by the <code>implicit</code> feature and algebras are passed as
explicit parameters. There is no language-level support in Haskell for algebras:
they are just data!</p>

<p>Consider the simple <code>Console</code> algebra from the introduction. We can rewrite it
into Haskell as a <em>record of functions</em>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  data Console m = Console
                    { println :: Text -&gt; m ()
                    , readln  :: m Text
                    }
</pre></div>

</figure>

<p>with business logic using a <code>Monad</code> constraint</p>

<figure class="code">
<div class="highlight"><pre><code></code>  echo :: (Monad m) =&gt; Console m -&gt; m ()
  echo c = do line &lt;- readln c
              println c line
</pre></div>

</figure>

<p>A production implementation of <code>Console</code> would likely have type <code>Console IO</code>.
The Scalaz <code>liftIO</code> function is inspired by a Haskell function of the same name
and can lift <code>Console IO</code> into any Advanced Monad stack.</p>

<p>Two additional language extensions make the business logic even cleaner. For
example, <code>RecordWildCards</code> allows us to import all the fields of a data type by
using <code>{..}</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  echo :: (Monad m) =&gt; Console m -&gt; m ()
  echo Console{..} = do line &lt;- readln
                        println line
</pre></div>

</figure>

<p><code>NamedFieldPuns</code> requires each imported field to be listed explicitly, which is
more boilerplate but makes the code easier to read:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  echo :: (Monad m) =&gt; Console m -&gt; m ()
  echo Console{readln, println} = do line &lt;- readln
                                     println line
</pre></div>

</figure>

<p>Whereas in Scala this encoding may be called <em>Finally Tagless</em>, in Haskell it is
known as MTL style. Without going into details, some Scala developers didn’t
understand a research paper about the performance benefits of <a href="http://okmij.org/ftp/tagless-final/index.html#tagless-final">Generalised ADTs
in Haskell</a>.</p>

<p>An alternative to MTL style are <em>Extensible Effects</em>, also known as <a href="http://okmij.org/ftp/Haskell/extensible/more.pdf">Free Monad
style</a>.</p>

<h3 id="leanpub-auto-modules">
<a class="anchor-link" href="#leanpub-auto-modules"><i class="fa fa-link"></i></a>Modules</h3>

<p>Haskell source code is arranged into hierarchical modules with the restriction
that all contents of a <code>module</code> must live in a single file. The top of a file
declares the <code>module</code> name</p>

<figure class="code">
<div class="highlight"><pre><code></code>  module Silly.Tree where
</pre></div>

</figure>

<p>A convention is to use directories on disk to organise the code, so this file
would go into <code>Silly/Tree.hs</code>.</p>

<p>By default all symbols in the file are exported but we can choose to export
specific members, for example the <code>Tree</code> type and data constructors, and a
<code>fringe</code> function, omitting <code>sapling</code>:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  module Silly.Tree (Tree(..), fringe) where
  
  data Tree a = Leaf a | Branch (Tree a) (Tree a)
  
  fringe :: Tree a -&gt; [a]
  fringe (Leaf x)            = [x]
  fringe (Branch left right) = fringe left ++ fringe right
  
  sapling :: Tree String
  sapling = Leaf ""
</pre></div>

</figure>

<p>Interestingly, we can export symbols that are imported into the module, allowing
library authors to package up their entire API into a single module, regardless
of how it is implemented.</p>

<p>In a different file we can import all the exported members from <code>Silly.Tree</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Silly.Tree
</pre></div>

</figure>

<p>which is roughly equivalent to Scala’s <code>import silly.tree._</code> syntax. If we want
to restrict the symbols that we import we can provide an explicit list in
parentheses after the import</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Silly.Tree (Tree, fringe)
</pre></div>

</figure>

<p>Here we only import the <code>Tree</code> type constructor (not the data constructors) and
the <code>fringe</code> function. If we want to import all the data constructors (and
pattern matchers) we can use <code>Tree(..)</code>. If we only want to import the <code>Branch</code>
constructor we can list it explicitly:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Silly.Tree (Tree(Branch), fringe)
</pre></div>

</figure>

<p>If we have a name collision on a symbol we can use a <code>qualified</code> import, with an
optional list of symbols to import</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import qualified Silly.Tree (fringe)
</pre></div>

</figure>

<p>and now to call the <code>fringe</code> function we have to type <code>Silly.Tree.fringe</code>
instead of just <code>fringe</code>. We can change the name of the module when importing it</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import qualified Silly.Tree as T
</pre></div>

</figure>

<p>The <code>fringe</code> function is now accessed by <code>T.fringe</code>.</p>

<p>Alternatively, rather than select what we want to import, we can choose what
<strong>not</strong> to import</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Silly.Tree hiding (fringe)
</pre></div>

</figure>

<p>By default the <code>Prelude</code> module is implicitly imported but if we add an explicit
import from the <code>Prelude</code> module, only our version is used. We can use this
technique to hide unsafe legacy functions</p>

<figure class="code">
<div class="highlight"><pre><code></code>  import Prelude hiding ((!!), head)
</pre></div>

</figure>

<p>or use a custom prelude and disable the default prelude with the
<code>NoImplicitPrelude</code> language extension.</p>

<h3 id="leanpub-auto-evaluation-1">
<a class="anchor-link" href="#leanpub-auto-evaluation-1"><i class="fa fa-link"></i></a>Evaluation</h3>

<p>Haskell compiles to native code, there is no virtual machine, but there is a
garbage collector. A fundamental aspect of the runtime is that all parameters
are <strong>lazily evaluated</strong> by default. Haskell treats all terms as a promise to
provide a value when needed, called a <em>thunk</em>. Thunks get reduced only as much
as necessary to proceed, no more.</p>

<p>A huge advantage of lazy evaluation is that it is much harder to trigger a stack
overflow! A disadvantage is that there is an overhead compared to strict
evaluation, which is why Haskell allows us to opt in to strict evaluation on a
per parameter basis.</p>

<p>Haskell is also nuanced about what strict evaluation means: a term is said to be
in <em>weak head normal-form</em> (WHNF) if the outermost code blocks cannot be reduced
further, and <em>normal form</em> if the term is fully evaluated. Scala’s default
evaluation strategy roughly corresponds to normal form.</p>

<p>For example, these terms are normal form:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  42
  (2, "foo")
  \x -&gt; x + 1
</pre></div>

</figure>

<p>whereas these are not in normal form (they can be reduced further):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  1 + 2            -- reduces to 3
  (\x -&gt; x + 1) 2  -- reduces to 3
  "foo" ++ "bar"   -- reduces to "foobar"
  (1 + 1, "foo")   -- reduces to (2, "foo")
</pre></div>

</figure>

<p>The following terms are in WHNF because the outer code cannot be reduced further
(even though the inner parts can be):</p>

<figure class="code">
<div class="highlight"><pre><code></code>  (1 + 1, "foo")
  \x -&gt; 2 + 2
  'f' : ("oo" ++ "bar")
</pre></div>

</figure>

<p>and the following are not in WHNF</p>

<figure class="code">
<div class="highlight"><pre><code></code>  1 + 1              -- reduces to 2
  (\x y -&gt; x + y) 2  -- reduces to \y -&gt; 2 + y
  "foo" ++ "bar"     -- reduces to "foobar"
</pre></div>

</figure>

<p>The default evaluation strategy is to perform no reductions when passing a term
as a parameter. Language level support allows us to request WHNF for any term
with <code>($!)</code></p>

<figure class="code">
<div class="highlight"><pre><code></code>  -- evaluates `a` to WHNF, then calls the function with that value
  ($!) :: (a -&gt; b) -&gt; a -&gt; b
  infixr 0
</pre></div>

</figure>

<p>We can use an exclamation mark <code>!</code> on <code>data</code> parameters</p>

<figure class="code">
<div class="highlight"><pre><code></code>  data StrictList t = StrictNil | !t :. !(StrictList t)
  
  data Employee = Employee
                    { name :: !Text
                    , age :: !Int
                    }
</pre></div>

</figure>

<p>The <code>StrictData</code> language extension enables strict parameters for all data in
the module.</p>

<p>Another extension, <code>BangPatterns</code>, allows <code>!</code> to be used on the arguments of
functions. The <code>Strict</code> language extension makes all functions and data
parameters in the module strict by default.</p>

<p>Going to the extreme we can use <code>($!!)</code> and the <code>NFData</code> typeclass for normal
form evaluation:</p>

<figure class="code">
<div class="highlight"><pre><code></code>  class NFData a where
    rnf :: a -&gt; ()
  
  ($!!) :: (NFData a) =&gt; (a -&gt; b) -&gt; a -&gt; b
</pre></div>

</figure>

<p>which is subject to the availability of an <code>NFData</code> instance.</p>

<p>The cost of strictness is that Haskell behaves like any other strict language
and may perform unnecessary work. Opting in to strictness must therefore be done
with great care, and only for measured performance improvements. If in doubt, be
lazy and stick with the defaults.</p>

<aside>
  <p>There is a big gotcha with lazy evaluation: if an I/O action is performed that
populates a lazy data structure, the action will be performed when the data
structure is evaluated, which can fail in unexpected parts of the code and
outside of the resource handling logic. To avoid this gotcha, only read into
strict data structures when performing I/O.</p>

  <p>Thankfully this gotcha only affects developers writing low-level I/O code. Third
party libraries such as <code>pipes-safe</code> and <code>conduits</code> provide safe abstractions
for the typical Haskeller. Most raw byte and <code>Text</code> primitives are strict, with
<code>Lazy</code> variants.</p>

</aside>

<h3 id="leanpub-auto-next-steps">
<a class="anchor-link" href="#leanpub-auto-next-steps"><i class="fa fa-link"></i></a>Next Steps</h3>

<p>Haskell is a faster, safer and simpler language than Scala and has proven itself
in industry. Consider taking the <a href="https://github.com/data61/fp-course">data61 course on functional programming</a>, and
ask questions in the <code>#qfpl</code> chat room on <code>freenode.net</code>.</p>

<p>Some additional learning materials are:</p>

<ul>
  <li>
<a href="http://www.cs.nott.ac.uk/~pszgmh/pih.html">Programming in Haskell</a> to learn Haskell from first principles.</li>
  <li>
<a href="http://shop.oreilly.com/product/0636920026365.do">Parallel and Concurrent Programming in Haskell</a> and <a href="http://dev.stephendiehl.com/hask/#data-kinds">What I Wish I Knew When
Learning Haskell</a> for intermediate wisdom.</li>
  <li>
<a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/">Glasgow Haskell Compiler User Guide</a> and <a href="https://wiki.haskell.org/">HaskellWiki</a> for the cold hard facts.</li>
  <li>
<a href="https://eta-lang.org/">Eta</a>, i.e. Haskell for the JVM.</li>
</ul>

<p>If you enjoy using Haskell and understand the value that it would bring to your
business, then tell your managers! That way, the small percentage of managers
who commission Haskell projects will be able to attract functional programming
talent from the many teams who do not, and everybody will be happy.</p>

<h2 id="leanpub-auto-third-party-licenses">
<a class="anchor-link" href="#leanpub-auto-third-party-licenses"><i class="fa fa-link"></i></a>Third Party Licenses</h2>

<p>Some of the source code in this book has been copied from free / libre
software projects. The license of those projects require that the
following texts are distributed with the source that is presented in
this book.</p>

<h3 id="leanpub-auto-scala-license">
<a class="anchor-link" href="#leanpub-auto-scala-license"><i class="fa fa-link"></i></a>Scala License</h3>

<figure class="code">
<div class="highlight"><pre><code></code>  Copyright (c) 2002-2017 EPFL
  Copyright (c) 2011-2017 Lightbend, Inc.
  
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without modification,
  are permitted provided that the following conditions are met:
  
    * Redistributions of source code must retain the above copyright notice,
      this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice,
      this list of conditions and the following disclaimer in the documentation
      and/or other materials provided with the distribution.
    * Neither the name of the EPFL nor the names of its contributors
      may be used to endorse or promote products derived from this software
      without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre></div>

</figure>

<h3 id="leanpub-auto-scalaz-license">
<a class="anchor-link" href="#leanpub-auto-scalaz-license"><i class="fa fa-link"></i></a>Scalaz License</h3>

<figure class="code">
<div class="highlight"><pre><code></code>  Copyright (c) 2009-2014 Tony Morris, Runar Bjarnason, Tom Adams,
                          Kristian Domagala, Brad Clow, Ricky Clarkson,
                          Paul Chiusano, Trygve Laugstøl, Nick Partridge,
                          Jason Zaugg
  All rights reserved.
  
  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:
  
  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.
  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.
  3. Neither the name of the copyright holder nor the names of
     its contributors may be used to endorse or promote products derived from
     this software without specific prior written permission.
  
  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</pre></div>

</figure>

</div>


</section>
</div>

</div>
<footer class="footer">
<div class="container--medium">
<h1 class="footer-logo">
<a href="https://leanpub.com/"><img src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/logo-white-96-67-2x-9bfee74570449b60febfe179fb06c1eb.png" alt="Logo white 96 67 2x">
</a></h1>
<div class="footer-links">
<ul class="footer-list">
<li>
<h5 class="footer-list-title">About</h5>
</li>
<li><a href="https://leanpub.com/about">About Leanpub</a></li>
<li><a href="https://medium.com/@leanpub">Blog</a></li>
<li><a href="https://leanpub.com/team">Team</a></li>
<li><a href="https://leanpub.com/contact">Contact</a></li>
<li><a href="https://leanpub.com/press">Press</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Authors</h5>
</li>
<li><a href="https://leanpub.com/authors">Why Leanpub</a></li>
<li><a href="https://leanpub.com/testimonials">Testimonials</a></li>
<li><a href="https://leanpub.com/grandfathering">Grandfathering</a></li>
<li><a href="https://leanpub.com/freemium">Freemium</a></li>
<li><a href="https://leanpub.com/manifesto">Manifesto</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Author Support</h5>
</li>
<li><a href="https://leanpub.com/manual/read">The Leanpub Manual</a></li>
<li><a href="http://help.leanpub.com/author-help">Author Help Center</a></li>
<li><a href="https://community.leanpub.com/c/authors">Leanpub Authors Forum</a></li>
<li><a href="https://leanpub.com/markua/read">The Markua Manual</a></li>
<li><a href="https://leanpub.com/leanpubflavouredmarkdownmanual/read">The Leanpub Flavoured Markdown Manual</a></li>
<li><a href="https://leanpub.com/help/supported_languages">Supported Languages</a></li>
<li><a href="https://leanpub.com/help/api">API Docs</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">More</h5>
</li>
<li><a href="https://leanpub.com/newsletters">Newsletters</a></li>
<li><a href="https://leanpub.com/podcasts/frontmatter">Frontmatter Podcast</a></li>
<li><a href="https://leanpub.com/podcasts/backmatter">Backmatter Podcast</a></li>
<li><a href="https://leanpub.com/redeem">Redeem a Token</a></li>
<li><a href="http://help.leanpub.com/reader-help">Reader Help</a></li>
<li><a href="https://leanpub.com/causes">Causes</a></li>
</ul>
<ul class="footer-list">
<li>
<h5 class="footer-list-title">Legal</h5>
</li>
<li><a href="https://leanpub.com/terms">Terms of Service</a></li>
<li><a href="https://leanpub.com/takedown">Copyright Policy</a></li>
<li><a href="https://leanpub.com/privacy">Privacy Policy</a></li>
</ul>
</div>
<p class="footer-copyright">
Leanpub is copyright © 2010-2019 <a href="http://ruboss.com/">Ruboss Technology Corp.</a> All rights reserved.
</p>
</div>
</footer>

<div id="react-modal"></div>

</div>
<div class="cookies-banner alert alert--info" style="display: none">
  Leanpub requires cookies in order to provide you the best experience.
  <a class="dismiss link">Dismiss</a>
</div>

<script type="text/javascript">
  window.addEventListener('load', function() {
    var shouldShowCookies = document.cookie.indexOf('should_show_cookies') !== -1

    if (shouldShowCookies) {
      var banner = document.querySelector('.cookies-banner')
      // IE < 9 check
      if (banner.style.removeProperty) {
        banner.style.removeProperty('display');
      } else {
        banner.style.removeAttribute('display');
      }
      document.querySelector('.cookies-banner').classList.add('shown')
      // Note that we have to use vanilla JS here because ujs (remote links) code doesn't live in the react app, and i don't
      // want to have to write this shit twice.
      document.querySelector('.cookies-banner .dismiss').addEventListener('click', function() {
        document.querySelector('.cookies-banner').remove()
        var xhr = new XMLHttpRequest()
        xhr.open("POST", "/api/v1/accepted_terms/dismiss_cookies", true);
        xhr.send()
      })
    }
  })
</script>


<script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/application-ee3cbde9ceb7581c5e24cdabbe1b82c7.js"></script>
<!-- Twitter universal website tag code -->
<script>
!function(e,t,n,s,u,a){e.twq||(s=e.twq=function(){s.exe?s.exe.apply(s,arguments):s.queue.push(arguments);
},s.version='1.1',s.queue=[],u=t.createElement(n),u.async=!0,u.src='//static.ads-twitter.com/uwt.js',
a=t.getElementsByTagName(n)[0],a.parentNode.insertBefore(u,a))}(window,document,'script');
// Insert Twitter Pixel ID and Standard Event data below
twq('init','nw0pa');
twq('track','PageView');
</script>
<!-- End Twitter universal website tag code -->

<script>
  $('.scroll-wrapper').on('scroll', function(e) {
    if (e.target.scrollTop > 10) {
      $('.read-online-slidable').addClass('scrolled')
      $('#scroll-wrapper').addClass('read-online-scrolled')
    } else {
      $('.read-online-slidable').removeClass('scrolled')
      $('#scroll-wrapper').removeClass('read-online-scrolled')
    }
  })
  
  $('#read-online .toggle-sidebar').on('click', function(e) {
    $('#read-online').toggleClass('sidebar-hidden')
  })
  
  if (window.innerWidth <= 768) {
    $('#read-online').toggleClass('sidebar-hidden')
  }
</script>

<script type="text/javascript">
  window.__menu_data__ = null
</script>

<div><div class="grecaptcha-badge" data-style="bottomright" style="width: 256px; height: 60px; display: block; transition: right 0.3s ease 0s; position: fixed; bottom: 14px; right: -186px; box-shadow: gray 0px 0px 5px;"><div class="grecaptcha-logo"><iframe src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/anchor.html" role="presentation" name="a-f3wyrh66q4q8" scrolling="no" sandbox="allow-forms allow-popups allow-same-origin allow-scripts allow-top-navigation allow-modals allow-popups-to-escape-sandbox allow-storage-access-by-user-activation" width="256" height="60" frameborder="0"></iframe></div><div class="grecaptcha-error"></div><textarea id="g-recaptcha-response-100000" name="g-recaptcha-response" class="g-recaptcha-response" style="width: 250px; height: 40px; border: 1px solid rgb(193, 193, 193); margin: 10px 25px; padding: 0px; resize: none; display: none;"></textarea></div></div><div style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px none; margin: 0px;"><div id="MathJax_Font_Test" style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; padding: 0px; border: 0px none; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-size-adjust: none; font-family: MathJax_Size4, sans-serif;"></div></div><script src="Read%20Functional%20Programming%20for%20Mortals%20|%20Leanpub_files/adsct.js" type="text/javascript"></script></body></html>