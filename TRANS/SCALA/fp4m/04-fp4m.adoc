include::header.adoc[]

4. Дані та функціональність
===========================

В OOP ми звикли думати про дані та функціональність разом: ієрархії класів несуть методи, і трейти можуть вимагати, щоб існували поля даних. Поліморфізм часу виконання об'єкту є терміном відношення “є різновидом”, що вимагає, щоб класи наслідували від загальних інтерфейсів. Це може викликати плутанину при зростанні обсягу коду. Прості типи даних стають прихованими за сотнями рядків методів, міксіни трейтів потерпають від помилок порядку ініціалізації, та тестування / мокінг дуже пов'язаних компонент стає жахом.

FP приймає інший підхід, визначаючи дані та функціональність окремо. В цій главі ми розглянемо основи типів даних, та переваги обмеження себе до підмножини мови Scala. Ми також дослідимо типокласи як спосіб досягти поліморфізм часу компіляції: думати про функціональність структури даних в термінах відношення “має”, скоріше, ніж “є різновидом”.

4.1 Дані
--------
Фундаментальні будівельні блоки типів даних є:

* `final case class`, також відомі як продукти
* `sealed abstract class`, також відомі як ко-продукти
* `case object` та значення `Int`, `Double`, `String` (тощо) без методів або полів, крім параметрів конструктора. Ми обираємо абстрактні класи замість трейтів, щоб отримати кращу бінарну сумісність, та щоб перешкоджати міксуванню трейтів.

Колективна назва для продуктів, ко-продуктів та значень є _Алгебраїчні типи даних_ (Algebraic Data Type, ADT).

Ми компонуємо типи даних з логічної алгебри `AND` та `XOR` (виключне `OR`): продукт містить кожний тип, з яких він складається, але ко-продукт може бути тільки один. For example
[source,scala]
----
product: ABC = a AND b AND c
coproduct: XYZ = x XOR y XOR z
----
записане в Scala
[source,scala]
----
  // значення
  case object A
  type B = String
  type C = Int
  
  // продукт
  final case class ABC(a: A.type, b: B, c: C)
  
  // ко-продукт
  sealed abstract class XYZ
  case object X extends XYZ
  case object Y extends XYZ
  final case class Z(b: B) extends XYZ
----
4.1.1 Рекурсівні ADT
~~~~~~~~~~~~~~~~~~~~
Коли ADT посилається на себе, ми називаємо це Рекурсивним алгебраїчним типом даних (Recursive Algebraic Data Type).

`scalaz.IList`, безпечна альтернатива до `stdlib` `List`, є рекурсивною, оскікльи `ICons` містить посилання на `IList.`:
[source,scala]
----
  sealed abstract class IList[A]
  final case class INil[A]() extends IList[A]
  final case class ICons[A](head: A, tail: IList[A]) extends IList[A]
----
4.1.2 Функції на ADT
~~~~~~~~~~~~~~~~~~~~
ADT може містити чисті функції:
[source,scala]
----
  final case class UserConfiguration(accepts: Int => Boolean)
----
Але ADT, що мають функції, ідуть з деякими особистостями, бо вони не ідеально транслюються на JVM. Наприклад, старий `Serializable`, `hashCode`, `equals` та `toString` не поводяться так, як дехто може логічно очікувати.

Нажаль, `Serializable` використовується в популярних фреймворках, не зважаючи на значно кращі альтернативи. Загальна пастка є забути, що  `Serializable` може спробувати селіалізувати ціле замикання функції, що може зламати промисловий сервер. Подібна специфіка стосується старих Java класів, таких як `Throwable`, що може нести посилання на довільні об'єкти.

Ми будемо досліджувати альтернативи до старих методів, коли ми дискутуватимемо бібліотеку `Scalaz` в наступній главі, ціною втрати взаємодії з деяким старим кодом Java та Scala.

4.1.3 Вичерпність
~~~~~~~~~~~~~~~~~
Важливо, що ми використовуємо закоркований абстрактний клас, не просто абстрактний клас, коли визначаємо тип даних. Закоркування класу означає, що всі підтипи мають бути визначені в тому ж файлі, дозволяючи компілятору знати щодо них в вичерпному співпадінні шаблонів, та в макросах, що запобігають шаблонному коду. Тобто:
[source,scala]
----
  scala> sealed abstract class Foo
         final case class Bar(flag: Boolean) extends Foo
         final case object Baz extends Foo
  
  scala> def thing(foo: Foo) = foo match {
           case Bar(_) => true
         }
  <console>:14: error: match may not be exhaustive.
  It would fail on the following input: Baz
         def thing(foo: Foo) = foo match {
                               ^
----
Це показує розробнику, що вони зламають речі, якщо вони додають новий продукт до коду. Ми використовуємо `-Xfatal-warnings`, інакше це тільки попередження.

Однак компілятор не буде виконувати перевірку вичерпності, якщо клас не закоркований, або якщо стоять захисники, тобто:
[source,scala]
----
  scala> def thing(foo: Foo) = foo match {
           case Bar(flag) if flag => true
         }
  
  scala> thing(Baz)
  scala.MatchError: Baz (of class Baz$)
    at .thing(<console>:15)
----
Щоб залишатись в безпеці не використовуйте захисників на закоркованих типах.

Флаг `-Xstrict-patmat-analysis` був запропонований як покращення мови для виконання додаткових перевірок співпадіння шаблонів.

4.1.4 Альтернативні продукти та ко-продукти
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Іншою формою продукта є тапл, що як непомічений фінальний кейс клас.

`(A.type, B, C)` еквівалентне до `ABC` в прикладі вище, але краще використовувати фінальний кейс клас як частини ADT, оскільки брак імен ускладнює справи, і кейс клас має значно кращу продуктивність для примітивних значень.

Інша форма ко-продукта утворюється, коли ми вкладаємо типи `Either`. Тобто:
[source,scala]
----
  Either[X.type, Either[Y.type, Z]]
----
еквівалентне до закоркованого абстрактного класу `XYZ`. Ясніший синтаксис для визначення вкладених типів `Either` є створення псевдониму типу, що завершується на двокрапку, дозволяючи інфіксну нотацію з правою асоціацією:
[source,scala]
----
  type |:[L,R] = Either[L, R]
  
  X.type |: Y.type |: Z
----
Це корисно для створення анонімних ко-продуктів, коли ми не можемо покласти всі реалізації в той самий джерельний файл.
[source,scala]
----
  type Accepted = String |: Long |: Boolean
----
І ще один альтернативний ко-продукт є створення власного закоркованого абстрактного класу з фінальним кейс класом, що просто огортає бажаний тип:
[source,scala]
----
  sealed abstract class Accepted
  final case class AcceptedString(value: String) extends Accepted
  final case class AcceptedLong(value: Long) extends Accepted
  final case class AcceptedBoolean(value: Boolean) extends Accepted
----
Порівняння шаблонів на ціх формах ко-продуктів може бути тендітним, ось чому були досліджені _Union Types_ в `Dotty`, компіляторі Scala наступного покоління. Макроси, такі як `totalitarian` та `iotaz` існують як альтернативні шляхи кодування анонімних ко-продуктів.

4.1.5 Подача інформації
~~~~~~~~~~~~~~~~~~~~~~~
Окрім функції контейнера для потрібної бізнес інформації, типи даних можуть використовуватись для кодування обмежень. Наприклад,
[source,scala]
----
  final case class NonEmptyList[A](head: A, tail: IList[A])
----
ніколи не може бути порожнім. Це робить `scalaz.NonEmptyList` корисним типом даних, що містить ту саму інформацію, що і `IList`.

Продуктові типи часто містять типи, що значно більш загальні, ніж дозволено. В традиційному OOP це може бути оброблене за допомогою валідації вводу через припущення:
[source,scala]
----
  final case class Person(name: String, age: Int) {
    require(name.nonEmpty && age > 0) // руйнує загальність, не робіть цього!
  }
----
Замість цього ми можемо використовувати тип даних `Either` щоб провадити `Right[Person]` для валідних примірників, та захиститись від просування навалідних примірників. Зауважте, що конструктор приватний:
[source,scala]
----
  final case class Person private(name: String, age: Int)
  object Person {
    def apply(name: String, age: Int): Either[String, Person] = {
      if (name.nonEmpty && age > 0) Right(new Person(name, age))
      else Left(s"bad input: $name, $age")
    }
  }
  
  def welcome(person: Person): String =
    s"${person.name} you look wonderful at ${person.age}!"
  
  for {
    person <- Person("", -1)
  } yield welcome(person)
----
4.1.5.1 Очищені типи даних
~~~~~~~~~~~~~~~~~~~~~~~~~~
Чіткий спосіб обмежити значення загального типу можливо за допомогою бібліотеки `refined`, провадячи сюїту обмежень до вмісту даних. Щоб встановити `refined`, додайте наступне до `build.sbt`:
[source,scala]
----
  libraryDependencies += "eu.timepit" %% "refined-scalaz" % "0.9.2"
----
та наступні імпорти:
[source,scala]
----
  import eu.timepit.refined
  import refined.api.Refined
----
`Refined` дозволяє визначити `Person` використовуючи створені на льоту очищені типи, щоб захопити вимоги в точності, записуючи `A Refined B`.

Всі типи з двома параметрами можуть бути записані інфіксно в Scala. Наприклад, `Either[String, Int]` є те саме, що `String Either Int`. За домовленостю `Refined` записується інфіксно, оскільки `A Refined B` можна прочитати як “`A`, що відповідає вимогам, визначеним в `B`”.
[source,scala]
----
  import refined.numeric.Positive
  import refined.collection.NonEmpty
  
  final case class Person(
    name: String Refined NonEmpty,
    age: Int Refined Positive
  )
----
Підлегле значення можна отримати за допомогою `.value`. Ми можемо конструювати значення від час виконання з використанням `.refineV`, повертаючи `Either`:
[source,scala]
----
  scala> import refined.refineV
  scala> refineV[NonEmpty]("")
  Left(Predicate isEmpty() did not fail.)
  
  scala> refineV[NonEmpty]("Sam")
  Right(Sam)
----
Якщо ми додамо наступний імпорт:
[source,scala]
----
  import refined.auto._
----
ми можемо конструювати валідні значення під час компіляції, та отримати помилку, якщо надамо значення, що не відповідає вимогам:
[source,scala]
----
  scala> val sam: String Refined NonEmpty = "Sam"
  Sam
  
  scala> val empty: String Refined NonEmpty = ""
  <console>:21: error: Predicate isEmpty() did not fail.
----
Можливо захопити більш складні вимоги, наприклад, ми можемо використовувати вбудоване правило `MaxSize` з наступними імпортами:
[source,scala]
----
  import refined.W
  import refined.boolean.And
  import refined.collection.MaxSize
----
захоплюючі вимогу, що `String` має бути одночасно непорожнім та мати максимальний розмір 10 символів:
[source,scala]
----
  type Name = NonEmpty And MaxSize[W.`10`.T]
  
  final case class Person(
    name: String Refined Name,
    age: Int Refined Positive
  )
----
Нотація `W` є скороченим для “witness” (_засвідчити_). Цей синтаксис буде значно простіший в Scala 2.13, що має підтримку для літеральних типів:
[source,scala]
----
  type Name = NonEmpty And MaxSize[10]
----
Просто визначити визначення власних вимог, що не охоплені бібліотекою  `refined`. Наприклад, в `drone-dynamaic-agents` нам знадобиться спосіб переконатись, що `String` містить `application/x-www-form-urlencoded`. Ми можемо створити правило `Refined`, використовуючи бібліотеку регулярних виразів Java:
[source,scala]
----
  sealed abstract class UrlEncoded
  object UrlEncoded {
    private[this] val valid: Pattern =
      Pattern.compile("\\A(\\p{Alnum}++|[-.*_+=&]++|%\\p{XDigit}{2})*\\z")
  
    implicit def urlValidate: Validate.Plain[String, UrlEncoded] =
      Validate.fromPredicate(
        s => valid.matcher(s).find(),
        identity,
        new UrlEncoded {}
      )
  }
----
4.1.6 Поділяти просто
~~~~~~~~~~~~~~~~~~~~~
Не провадячи жодної функціональності, ADT можуть мати мінімальний набір залежностей. Це робить простим їх публікацію та поділення з іншими розробниками. Через використання простої мови моделювання даних, стає можливим взаємодія з між-галужевими командами, такими як DBA, розробники UI та бізнес аналітики, використовуючи справжній код замість рукописного документу в якості джерела істини.

Більше того, інструментарій може бути написаний більш просто для продукування або споживання схем від інших мов програмування та дротових протоколів.

4.1.7 Підрахунок складності
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Складність типу даних є підрахунок значень, що можуть існувати. Гарний тип даних має найменьшу кількість складності, якій потрібен для утримання інформації, що має передаватись, і не більше.

Значення мають вбудовану складність:

`Unit` має одне значення (чому він і називається “одиничний”)
`Boolean` має два значення
`Int` має 4,294,967,295 значень
`String` ефективно має безліч значень

Щоб знайти складність продкуту ми перемножуємо складність кожної частини.

(`Boolean`, `Boolean`) має 4 значення (2*2)
(`Boolean`, `Boolean`, `Boolean`) має 8 значень (2*2*2)

Щоб знайти складність ко-продукту, ми додаємо складність кожної частини.

(`Boolean` |: `Boolean`) має 4 значення (2+2)
(`Boolean` |: `Boolean` |: `Boolean`) має 6 значень (2+2+2)

Щоб знайти складність ADT з параметром типу, помножте кожну частину на складність параметру типу:

`Option[Boolean]` має 3 значення, `Some[Boolean]` та `None` (2+1)

В FP функції повні та мають повертати значення для кожного вводу, не `Exception`. Мінімізація складності входів та виходів є кращим способом досягти загальності. Як правило великого пальця, це знак поганої розробки функції, якщо складність поверненного значення функції більша, ніж складність продукту вхідних значень: це джерело ентропії.

Складність загальної функції є число можливих функцій, що можуть задовільнити сигнатурі типу: вихід в ступіні вводу.

`Unit => Boolean` має складність 2
`Boolean => Boolean` має складність 4
'Option[Boolean] => Option[Boolean]' має складність 27
`Boolean => Int` має складність квантіліон на секстіліон.
`Int => Boolean` має таку складність, що якщо всі реалізації мали б порядковий номер, кожний мав би 4Гб в довжину.

В реальності `Int => Boolean` буде дечим простим, як `isOdd`, `isEven` або розріжений `BitSet`. Ця функція, коли використовується в ADT, краще може бути замінена на ко-продукт, який маркує обмежену множину функцій, що є релевантними.

Коли складність є “безкінечність на вході, безкінечність на виході”, нам треба ввести обмежувальні типи даних та валідацію ближче до точки входу за допомогою `Refined` з попереднього розділу.

Здантість порахувати складність сигнатури типу має одне інше практичне застосування: ми можемо знайти простіші сигнатури типів за допомогою алгебри вищої школи! Щоб перейти від сигнатури типу до її алгебри складності, просто замініть:
[source,scala]
----
Either[A, B] на a + b
(A, B) на a * b
A => B на b ^ a
----
зробіть деякі перестановки, та конвертуйте назад. Наприклад, скажімо, ми розробили фреймворк що базується на зворотніх викликах, і ми поставили себе в ситуацію, коли ми створили наступну сигнатуру типу:
[source,scala]
----
  (A => C) => ((B => C) => C)
----
Ми можемо конвертувати та переставити її так:
[source,scala]
----
  (c ^ (c ^ b)) ^ (c ^ a)
  = c ^ ((c ^ b) * (c ^ a))
  = c ^ (c ^ (a + b))
----
потім конвертувати назад до типів та отримати:
[source,scala]
----
  (Either[A, B] => C) => C
----
що значно простіше: ми тільки просимо користувачів нашого фреймфорку провадити `Either[A, B] => C`.

Той самий хід думок може бути використаний для перевірки, що:
[source,scala]
----
  A => B => C
----
еквівалентне до
[source,scala]
----
  (A, B) => C
----
що також відоме як _карування_.

4.1.8 Обирайте ко-продукти замість продуктів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Архітепічне моделювання проблем, що постає здебільшо коли існують взаємно виключні параметри конфігурації `a`, `b` та `c`. Продукт `(a: Boolean, b: Boolean, c: Boolean)` має складність 8, тоді як ко-продукт
[source,scala]
----
  sealed abstract class Config
  object Config {
    case object A extends Config
    case object B extends Config
    case object C extends Config
  }
має складність 3. Краще моделювати ці параметри конфігурації як ко-продукт, ніж дозволити існування п'яти невалідних станів.

Складність типу даних також має вплив на тестування. Практично неможливо тестувати кожний можливий вхід до функції, але просто тестувати примірник значень за допомогою фреймворка тестування властивостей `Scalacheck`. Якщо випадковий примірник типу даних має низьку вірорідність бути валідним, це знак, що дані змодельовані некоректно.

4.1.9 Оптимізації
~~~~~~~~~~~~~~~~~
Велика перевага від використання спрощеної підмножини мови Scala для представлення типів даних в тому, що інструментарій може оптимізувати репрезентацію байткоду JVM.

Наприклад, ми можемо запакувати поля `Boolean` та `Option` в `Array[Byte]`, кешувати значення, запам'ятати `hashCode`, оптимізувати `equals`, використовувати твердження `@switch` при порівнянні шаблонів, та багато іншого.

Ці оптимізації неможливо застосувати для ієрархій класів OOP, що можуть керувати станом, закидати виключення або провадити adhoc реалізції методів.

4.2 Функціональність
--------------------
Чисті функції типово визначаються як методи на об'єкті.
[source,scala]
----
  package object math {
    def sin(x: Double): Double = java.lang.Math.sin(x)
    ...
  }
  
  math.sin(1.0)
----
Однак буде незручним використовувати методи об'єкта, оскільки це читається зсередини-назовні, не зліва направо. На додаток функція на об'єкті краде простір імен. Якщо ми визначимо `sin(t: T)` будь-де ще, ми отримаємо помилку невизначенності посилання. Це та сама проблема, що і статичні методи в Java vs методів классу.

Різновид розробників, що складють методи в трейт, та вимагають від користувачів міксувати їх за допомогою шаблону кекса, прямують прямо до пекла. Це дає витік внутрішніх деталей реалізації до публічних API,заплутує байткод, робить двоїчну сумісність в основному неможливою, та засмучує  автодоповнювач IDE.

З можливістю мови щодо неявних класів (також відомою як методологія або синтаксис розширення), та невеликим шаблоном ми можемо отримати знайомий стиль:
[source,scala]
----
  scala> implicit class DoubleOps(x: Double) {
           def sin: Double = math.sin(x)
         }
  
  scala> (1.0).sin
  res: Double = 0.8414709848078965
----
Часто краще просто пропустити визначення об'єкта, та перейти прямо до неявного класу, утримуючи шаблонний код на мінімумі:
[source,scala]
----
  implicit class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
----
неявний клас є синтаксичним цукром до неявного перетворення:
[source,scala]
----
  implicit def DoubleOps(x: Double): DoubleOps = new DoubleOps(x)
  class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
----
Що, нажаль, має вартість під час виконання: кожний раз, коли викликається метод розширення, посередник `DoubleOps` буде конструюватись та потів відкидатись геть. Це може докластись до тиску на GC в гарячих точках.

Існує трохи більш балаклива форма неявних класів, що уникає розміщення, і, таким чином, більш бажана:
[source,scala]
----
  implicit final class DoubleOps(private val x: Double) extends AnyVal {
    def sin: Double = java.lang.Math.sin(x)
  }
----
4.2.1 Поліморфні функції
~~~~~~~~~~~~~~~~~~~~~~~~
Більш загальний різновид функцій є поліморфні функції, що живуть в _типокласах_. Типоклас є трейт, що:

* не збурігає стан
* має параметр типу
* має щонайменьше один абстрактний метод (примітивні комбінатори)
* може містити узагальнені методи (похідні комбінатори)
* може розширювати інший типоклас

Є тільки одна реалізація типокласу для любого даного параметру типу, властивість, відома під назвою когерентність типокласу. Типокласи  виглядають напрочуд подібно до алгебраїчних інтерфейсів, але алгебри не обов'язково мають бути когерентними.

Когенентність типокласів в основному відноситься до узгодженості, і узгодженість дає нам впевненість для використання неявних параметрів. Може бути складним продумувати код, що виконується по різному на неявних імпортах в полі зору. Когерентність типокласів насправді каже, що імпорти не повинні впливати на поведінку коду.

Додатково, когерентність типокласів дозволяє нам глобально кешувати неявні під час виконання, та зберігати розміщення пам'яті, отримуючи покращення продуктивності від зменшеного тиску на збирача сміття.

Типокласи використовуються в Scala `stdlib`. Ми дослідимо спрощену версію `scala.math.Numeric` для демонстрації принципу:
[source,scala]
----
  trait Ordering[T] {
    def compare(x: T, y: T): Int
  
    def lt(x: T, y: T): Boolean = compare(x, y) < 0
    def gt(x: T, y: T): Boolean = compare(x, y) > 0
  }
  
  trait Numeric[T] extends Ordering[T] {
    def plus(x: T, y: T): T
    def times(x: T, y: T): T
    def negate(x: T): T
    def zero: T
  
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
----
Ми можмо бачити всі ключові властивості типокласу в дії:

* немає стану
* `Ordering` та `Numeric` мають параметр типу `T`
* `Ordering` має абстрактне `compare`, та `Numeric` має абстрактні `plus`, `times`, `negate` та `zero`
* `Ordering` визначає узагальнені `lt` та `gt` базовані на `compare`, `Numeric` визначає `abs` в термінах `lt`, `negate` та `zero`.
* `Numeric` розширює `Ordering`

Тепер ми можемо писати функції для типів, що “має” типоклас `Numeric`:
[source,scala]
----
  def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {
    import N._
    times(negate(abs(t)), t)
  }
----
Ми більше не залежимо від ієрархії OOP від наших вхідних типів, тобто, ми не вимагаємо, щоб наш вхід “був” `Numeric`, що є критично важливим, якщо ми бажаємо підтримати клас третіх сторін, який ми не можемо перевизначити.

Інша перевага типокласів в тому, що асоціація функціональності до даних відбувається під час компіляції, на відміну від рантайм динамічної диспечерізації OOP.

Наприклад, хоча клас `List` може мати лише одну реалізацію метода, метод типокласу дозволяє нам мати різні реалізації в залежності від вмісту `List`, і, таким чином, перекласти навантаження на час компіляції, замість залишати його на рантайм.

4.2.2 Синтаксис
~~~~~~~~~~~~~~~
Синтаксис для написання `signOfTheTimes` є заплутаним, існують деякі речі, які ми можемо зробити, щоб розчистити його.

Нижні користувачі будуть краще бачити наш метод, як використовуючий межі контексту, оскільки сигнатура ясно читається як “приймає `T`, що має `Numeric`”
[source,scala]
----
  def signOfTheTimes[T: Numeric](t: T): T = ...
----
але тепер ми маємо будь-де використовувати `implicitly[Numeric[T]]`. Через визначення шаблонного коду на компанйоні типокласу:
[source,scala]
----
  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  }
----
ми можемо отримати неявне з меньшим шумом
[source,scala]
----
  def signOfTheTimes[T: Numeric](t: T): T = {
    val N = Numeric[T]
    import N._
    times(negate(abs(t)), t)
  }
----
Але це все ще гірше для нас, як для реалізаторів. Ми маємо синтаксичну проблему статичних методів зсередини-назовні vs методів класів. Ми маємо справу з цім через введення `ops` на компанйоні типокласу:
[source,scala]
----
  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  
    object ops {
      implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {
        def +(o: T): T = N.plus(t, o)
        def *(o: T): T = N.times(t, o)
        def unary_-: T = N.negate(t)
        def abs: T = N.abs(t)
  
        // дублікація з Ordering.ops
        def <(o: T): T = N.lt(t, o)
        def >(o: T): T = N.gt(t, o)
      }
    }
  }
----
Зауважте, `-x` розширюється до `x.unary_-` через компіляторний синтаксичний синтаксис, через що ми визначаємо `unary_-` як метод розширення. Тепер ми можемо записати значно ясніше:
[source,scala]
----
  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
----
Гарна новина в тому, що нам ніколи не треба писати цей код, оскільки `Simulacrum` провадить макро анотацію `@typeclass`, що автоматично генерує `apply` та `ops`. Він навіть дозволяє нам визначити альтернативні імена (звичайно символічні) для загальних методів. Загалом:
[source,scala]
----
  import simulacrum._
  
  @typeclass trait Ordering[T] {
    def compare(x: T, y: T): Int
    @op("<") def lt(x: T, y: T): Boolean = compare(x, y) < 0
    @op(">") def gt(x: T, y: T): Boolean = compare(x, y) > 0
  }
  
  @typeclass trait Numeric[T] extends Ordering[T] {
    @op("+") def plus(x: T, y: T): T
    @op("*") def times(x: T, y: T): T
    @op("unary_-") def negate(x: T): T
    def zero: T
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
  
  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
----
Тепер коли є власний символічний `@op`, він має вимовлятись як ім'я метода. Тобто, `<` вимовляється “меньше ніж”, не “ліва кутова дужка”.

4.2.3 Примірники
~~~~~~~~~~~~~~~~
Примірники `Numeric` (що також є примірниками `Ordering`) визначаються як `implicit val`, що розширює типоклас, та може провадити оптимізовану реалізації для узагальнених методів:
[source,scala]
----
  implicit val NumericDouble: Numeric[Double] = new Numeric[Double] {
    def plus(x: Double, y: Double): Double = x + y
    def times(x: Double, y: Double): Double = x * y
    def negate(x: Double): Double = -x
    def zero: Double = 0.0
    def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)
  
    // оптимізовано
    override def lt(x: Double, y: Double): Boolean = x < y
    override def gt(x: Double, y: Double): Boolean = x > y
    override def abs(x: Double): Double = java.lang.Math.abs(x)
  }
----
Хоча ми тут використовуємо `+`, `*`, `unary_-`, `<` та `>`, що є `ops` (і може бути безкінечний цикл!), ці методи вже існують на `Double`. Методи класів завжди використовуються з перевагою над методами розширення. Зрозуміло, що компілятор Scala виконує особливу обробку примітивів, та конвертує ці методи до сирих байткод інструкцій `dadd`, `dmul`, `dcmpl` та `dcmpg`, відповідно.

Ми також можемо реалізувати `Numeric` для Java класу `BigDecimal` (уникайте `scala.BigDecimal`, він фундаментально хибний)
[source,scala]
----
  import java.math.{ BigDecimal => BD }
  
  implicit val NumericBD: Numeric[BD] = new Numeric[BD] {
    def plus(x: BD, y: BD): BD = x.add(y)
    def times(x: BD, y: BD): BD = x.multiply(y)
    def negate(x: BD): BD = x.negate
    def zero: BD = BD.ZERO
    def compare(x: BD, y: BD): Int = x.compareTo(y)
  }
----
Ви можете створити нашу власну структуру даних для комплексних чисел:
[source,scala]
---- 
  final case class Complex[T](r: T, i: T)
----
Та наслідувати `Numeric[Complex[T]]`, якщо існує `Numeric[T]`. Оскільки ці примірники залежать від параметру типа, це `def`, не `val`.
[source,scala]
----
  implicit def numericComplex[T: Numeric]: Numeric[Complex[T]] =
    new Numeric[Complex[T]] {
      type CT = Complex[T]
      def plus(x: CT, y: CT): CT = Complex(x.r + y.r, x.i + y.i)
      def times(x: CT, y: CT): CT =
        Complex(x.r * y.r + (-x.i * y.i), x.r * y.i + x.i * y.r)
      def negate(x: CT): CT = Complex(-x.r, -x.i)
      def zero: CT = Complex(Numeric[T].zero, Numeric[T].zero)
      def compare(x: CT, y: CT): Int = {
        val real = (Numeric[T].compare(x.r, y.r))
        if (real != 0) real
        else Numeric[T].compare(x.i, y.i)
      }
    }
----
Спостережливий читач може зауважити, що `abs` взагалі не те, що може очікувати математик. Коректне повернуте значення для `abs` має бути `T`, не `Complex[T]`.

`scala.math.Numeric` намагається робити дуже багато, і не узагальнує за межами дійсних чисел. Це гарний урок того, що меньші, гарно визначені типокласи часто кращі, ніж монолітні колекції дуже специфічних можливостей.

4.2.4 Розрішення неявних
~~~~~~~~~~~~~~~~~~~~~~~~
Ми гарно обсудили неявні: цей розділ призначений для прояснення, що таке неявні, та як вони роблять.

Коли метод запитує, щоб в полі зору викликаючого знаходився унікальний примірник певного типу, неявні параметри є особливим синтаксисом для примірників типокласів. Неявні параметри є ясним шляхом конфігурації потоку через застосування.

В цьому прикладі `foo` потребує, щоб для `A` були доступні примірники типокласів `Numeric` та `Typeable`, так само, як неявний об'єкт `Handler`, що приймає два параметри типів
[source,scala]
----
  def foo[A: Numeric: Typeable](implicit A: Handler[String, A]) = ...
----
Неявне перетворення відбувається коли існує `implicit def`. Один такий випадок неявного перетворення є використання методології розширення. Коли компілятор розрішує виклик метода, він спочатку перевіряє, чи метод існує для типу, потім для предків (Java-подібні правила). Якщо він не зможе знайти співпадіння, він буде шукати неявне поле зору для перетворень до інших типів, потім шукає серед методів на ціх типах.

Інше використання для неявних перетворень є похідні типокласи. В попередньому розділі ми написали неявний `def`, що походить від `Numeric[Complex[T]]`, якщо `Numeric[T]` існує в неявному полі зору. Можливо зціпити разом декілька `implicit def` (включаючи рекурсію), що є базисом типованого програмування, дозволяючи виконання обчислень під час компіляціїї, замість рантайму.

Клей, що зліплює неявні параметри (отримувачі) з неявними перетвореннями (провайдерами) є розрішення неявних.

Зпочатку шукається звичане поле зору змінної, по порядку:

* локальне поле зору, включаючи локальні імпорти (тобто блок або метод)
* зовнішнє поле зору, включаючи імпорти в цій області (тобто члени в класі)
* предки (тобто члени в суер класі)
* поточний об'єкт пакаунку
* об'єкти батьківських пакунків (коли використовуються вкладені пакунки)
* імпорти файлу

Якщо пошук співпадіння схибить, шукається особливе поле зору, що виглядає неявні примірники в компанйоні типу, його об'єкті пакунку, зовнішні об'єкти (якщо вкладені), та потім повторюється для предків. Це виконується в тому ж порядку для:

* даного типу параметра
* очікуваного параметру типу
* параметру типу (якщо такий існує)

Якщо знайдено два співпадаючих неявних в тій самій фазі розрішення неявного, закидається помилка неявного.

Implicits are often defined on a trait, which is then extended by an object. This is to try and control the priority of an implicit relative to another more specific one, to avoid ambiguous implicits.

The Scala Language Specification is rather vague for corner cases, and the compiler implementation is the de facto standard. There are some rules of thumb that we will use throughout this book, e.g. prefer implicit val over implicit object despite the temptation of less typing. It is a quirk of implicit resolution that implicit object on companion objects are not treated the same as implicit val.

Implicit resolution falls short when there is a hierarchy of typeclasses, like Ordering and Numeric. If we write a function that takes an implicit Ordering, and we call it for a primitive type which has an instance of Numeric defined on the Numeric companion, the compiler will fail to find it.

Implicit resolution is particularly hit-or-miss if type aliases are used where the shape of the implicit parameters are changed. For example an implicit parameter using an alias such as type Values[A] = List[Option[A]] will probably fail to find implicits defined as raw List[Option[A]] because the shape is changed from a thing of things of A to a thing of A.

4.3 Modelling OAuth2
We will finish this chapter with a practical example of data modelling and typeclass derivation, combined with algebra / module design from the previous chapter.

In our drone-dynamic-agents application, we must communicate with Drone and Google Cloud using JSON over REST. Both services use OAuth2 for authentication. There are many ways to interpret OAuth2, but we will focus on the version that works for Google Cloud (the Drone version is even simpler).

4.3.1 Description
Every Google Cloud application needs to have an OAuth 2.0 Client Key set up at

  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
Obtaining a Client ID and a Client secret.

The application can then obtain a one time code by making the user perform an Authorization Request in their browser (yes, really, in their browser). We need to make this page open in the browser:

  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&\
    prompt=consent&\
    response_type=code&\
    scope={SCOPE}&\
    access_type=offline&\
    client_id={CLIENT_ID}
The code is delivered to the {CALLBACK_URI} in a GET request. To capture it in our application, we need to have a web server listening on localhost.

Once we have the code, we can perform an Access Token Request:

  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&\
    redirect_uri={CALLBACK_URI}&\
    client_id={CLIENT_ID}&\
    client_secret={CLIENT_SECRET}&\
    scope={SCOPE}&\
    grant_type=authorization_code
which gives a JSON response payload

  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }
Bearer tokens typically expire after an hour, and can be refreshed by sending an HTTP request with any valid refresh token:

  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&
    grant_type=refresh_token&
    refresh_token={REFRESH_TOKEN}&
    client_id={CLIENT_ID}
responding with

  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }
All userland requests to the server should include the header

  Authorization: Bearer BEARER_TOKEN
after substituting the actual BEARER_TOKEN.

Google expires all but the most recent 50 bearer tokens, so the expiry times are just guidance. The refresh tokens persist between sessions and can be expired manually by the user. We can therefore have a one-time setup application to obtain the refresh token and then include the refresh token as configuration for the user’s install of the headless server.

Drone doesn’t implement the /auth endpoint, or the refresh, and simply provides a BEARER_TOKEN through their user interface.

4.3.2 Data
The first step is to model the data needed for OAuth2. We create an ADT with fields having exactly the same name as required by the OAuth2 server. We will use String and Long for brevity, but we could use refined types if they leak into our business models.

  import refined.api.Refined
  import refined.string.Url
  
  final case class AuthRequest(
    redirect_uri: String Refined Url,
    scope: String,
    client_id: String,
    prompt: String = "consent",
    response_type: String = "code",
    access_type: String = "offline"
  )
  final case class AccessRequest(
    code: String,
    redirect_uri: String Refined Url,
    client_id: String,
    client_secret: String,
    scope: String = "",
    grant_type: String = "authorization_code"
  )
  final case class AccessResponse(
    access_token: String,
    token_type: String,
    expires_in: Long,
    refresh_token: String
  )
  final case class RefreshRequest(
    client_secret: String,
    refresh_token: String,
    client_id: String,
    grant_type: String = "refresh_token"
  )
  final case class RefreshResponse(
    access_token: String,
    token_type: String,
    expires_in: Long
  )
Avoid using java.net.URL at all costs: it uses DNS to resolve the hostname part when performing toString, equals or hashCode.

Apart from being insane, and very very slow, these methods can throw I/O exceptions (are not pure), and can change depending on the network configuration (are not deterministic).

The refined type String Refined Url allows us to perform equality checks based on the String and we can safely construct a URL only if it is needed by a legacy API.

That said, in high performance code we would prefer to skip java.net.URL entirely and use a third party URL parser such as jurl, because even the safe parts of java.net.* are extremely slow at scale.

4.3.3 Functionality
We need to marshal the data classes we defined in the previous section into JSON, URLs and POST-encoded forms. Since this requires polymorphism, we will need typeclasses.

jsonformat is a simple JSON library that we will study in more detail in a later chapter, as it has been written with principled FP and ease of readability as its primary design objectives. It consists of a JSON AST and encoder / decoder typeclasses:

  package jsonformat
  
  sealed abstract class JsValue
  final case object JsNull                                    extends JsValue
  final case class JsObject(fields: IList[(String, JsValue)]) extends JsValue
  final case class JsArray(elements: IList[JsValue])          extends JsValue
  final case class JsBoolean(value: Boolean)                  extends JsValue
  final case class JsString(value: String)                    extends JsValue
  final case class JsDouble(value: Double)                    extends JsValue
  final case class JsInteger(value: Long)                     extends JsValue
  
  @typeclass trait JsEncoder[A] {
    def toJson(obj: A): JsValue
  }
  
  @typeclass trait JsDecoder[A] {
    def fromJson(json: JsValue): String \/ A
  }
\/ is Scalaz’s Either and has a .flatMap. We can use it in for comprehensions, whereas stdlib Either does not support .flatMap prior to Scala 2.12. It is spoken as disjunction, or angry rabbit.

scala.Either was contributed to the Scala standard library by the creator of Scalaz, Tony Morris, in 2007. \/ was created when unsafe methods were added to Either.

We need instances of JsDecoder[AccessResponse] and JsDecoder[RefreshResponse]. We can do this by making use of a helper function:

  implicit class JsValueOps(j: JsValue) {
    def getAs[A: JsDecoder](key: String): String \/ A = ...
  }
We put the instances on the companions of our data types, so that they are always in the implicit scope:

  import jsonformat._, JsDecoder.ops._
  
  object AccessResponse {
    implicit val json: JsDecoder[AccessResponse] = j =>
      for {
        acc <- j.getAs[String]("access_token")
        tpe <- j.getAs[String]("token_type")
        exp <- j.getAs[Long]("expires_in")
        ref <- j.getAs[String]("refresh_token")
      } yield AccessResponse(acc, tpe, exp, ref)
  }
  
  object RefreshResponse {
    implicit val json: JsDecoder[RefreshResponse] = j =>
      for {
        acc <- j.getAs[String]("access_token")
        tpe <- j.getAs[String]("token_type")
        exp <- j.getAs[Long]("expires_in")
      } yield RefreshResponse(acc, tpe, exp)
  }
We can then parse a string into an AccessResponse or a RefreshResponse

  scala> import jsonformat._, JsDecoder.ops._
  scala> val json = JsParser("""
                       {
                         "access_token": "BEARER_TOKEN",
                         "token_type": "Bearer",
                         "expires_in": 3600,
                         "refresh_token": "REFRESH_TOKEN"
                       }
                       """)
  
  scala> json.map(_.as[AccessResponse])
  AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
We need to write our own typeclasses for URL and POST encoding. The following is a reasonable design:

  // URL query key=value pairs, in un-encoded form.
  final case class UrlQuery(params: List[(String, String)])
  
  @typeclass trait UrlQueryWriter[A] {
    def toUrlQuery(a: A): UrlQuery
  }
  
  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
We need to provide typeclass instances for basic types:

  import java.net.URLEncoder
  
  object UrlEncodedWriter {
    implicit val encoded: UrlEncodedWriter[String Refined UrlEncoded] = identity
  
    implicit val string: UrlEncodedWriter[String] =
      (s => Refined.unsafeApply(URLEncoder.encode(s, "UTF-8")))
  
    implicit val url: UrlEncodedWriter[String Refined Url] =
      (s => s.value.toUrlEncoded)
  
    implicit val long: UrlEncodedWriter[Long] =
      (s => Refined.unsafeApply(s.toString))
  
    implicit def ilist[K: UrlEncodedWriter, V: UrlEncodedWriter]
      : UrlEncodedWriter[IList[(K, V)]] = { m =>
      val raw = m.map {
        case (k, v) => k.toUrlEncoded.value + "=" + v.toUrlEncoded.value
      }.intercalate("&")
      Refined.unsafeApply(raw) // by deduction
    }
  
  }
We use Refined.unsafeApply when we can logically deduce that the contents of the string are already url encoded, bypassing any further checks.

ilist is an example of simple typeclass derivation, much as we derived Numeric[Complex] from the underlying numeric representation. The .intercalate method is like .mkString but more general.

UrlEncodedWriter is making use of the Single Abstract Method (SAM types) Scala language feature. The full form of the above is

  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
When the Scala compiler expects a class (which has a single abstract method) but receives a lambda, it fills in the boilerplate automatically.

Prior to SAM types, a common pattern was to define a method named instance on the typeclass companion

  def instance[T](f: T => String): UrlEncodedWriter[T] =
    new UrlEncodedWriter[T] {
      override def toUrlEncoded(t: T): String = f(t)
    }
allowing for

  implicit val string: UrlEncodedWriter[String] = instance { s => ... }
This pattern is still used in code that must support older versions of Scala, or for typeclasses instances that need to provide more than one method.

Note that there are a lot of bugs around SAM types, as they do not interact with all the language features. Revert to the non-SAM variant if there are any strange compiler crashes.

In a dedicated chapter on Typeclass Derivation we will calculate instances of UrlQueryWriter automatically, as well as clean up what we have already written, but for now we will write the boilerplate for the types we wish to convert:

  import UrlEncodedWriter.ops._
  object AuthRequest {
    implicit val query: UrlQueryWriter[AuthRequest] = { a =>
      UrlQuery(List(
        ("redirect_uri"  -> a.redirect_uri.value),
        ("scope"         -> a.scope),
        ("client_id"     -> a.client_id),
        ("prompt"        -> a.prompt),
        ("response_type" -> a.response_type),
        ("access_type"   -> a.access_type))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =>
      IList(
        "code"          -> a.code.toUrlEncoded,
        "redirect_uri"  -> a.redirect_uri.toUrlEncoded,
        "client_id"     -> a.client_id.toUrlEncoded,
        "client_secret" -> a.client_secret.toUrlEncoded,
        "scope"         -> a.scope.toUrlEncoded,
        "grant_type"    -> a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =>
      IList(
        "client_secret" -> r.client_secret.toUrlEncoded,
        "refresh_token" -> r.refresh_token.toUrlEncoded,
        "client_id"     -> r.client_id.toUrlEncoded,
        "grant_type"    -> r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
4.3.4 Module
That concludes the data and functionality modelling required to implement OAuth2. Recall from the previous chapter that we define components that need to interact with the world as algebras, and we define business logic in a module, so it can be thoroughly tested.

We define our dependency algebras, and use context bounds to show that our responses must have a JsDecoder and our POST payload must have a UrlEncodedWriter:

  trait JsonClient[F[_]] {
    def get[A: JsDecoder](
      uri: String Refined Url,
      headers: IList[(String, String)]
    ): F[A]
  
    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String] = IList.empty
    ): F[A]
  }
Note that we only define the happy path in the JsonClient API. We will get around to error handling in a later chapter.

Obtaining a CodeToken from the Google OAuth2 server involves

starting an HTTP server on the local machine, and obtaining its port number.
making the user open a web page in their browser, which allows them to log in with their Google credentials and authorise the application, with a redirect back to the local machine.
capturing the code, informing the user of next steps, and closing the HTTP server.
We can model this with three methods on a UserInteraction algebra.

  final case class CodeToken(token: String, redirect_uri: String Refined Url)
  
  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
It almost sounds easy when put like that.

We also need an algebra to abstract over the local system time

  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
And introduce data types that we will use in the refresh logic

  final case class ServerConfig(
    auth: String Refined Url,
    access: String Refined Url,
    refresh: String Refined Url,
    scope: String,
    clientId: String,
    clientSecret: String
  )
  final case class RefreshToken(token: String)
  final case class BearerToken(token: String, expires: Epoch)
Now we can write an OAuth2 client module:

  import http.encoding.UrlQueryWriter.ops._
  
  class OAuth2Client[F[_]: Monad](
    config: ServerConfig
  )(
    user: UserInteraction[F],
    client: JsonClient[F],
    clock: LocalClock[F]
  ) {
    def authenticate: F[CodeToken] =
      for {
        callback <- user.start
        params   = AuthRequest(callback, config.scope, config.clientId)
        _        <- user.open(params.toUrlQuery.forUrl(config.auth))
        code     <- user.stop
      } yield code
  
    def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
      for {
        request <- AccessRequest(code.token,
                                 code.redirect_uri,
                                 config.clientId,
                                 config.clientSecret).pure[F]
        msg     <- client.post[AccessRequest, AccessResponse](
                     config.access, request)
        time    <- clock.now
        expires = time + msg.expires_in.seconds
        refresh = RefreshToken(msg.refresh_token)
        bearer  = BearerToken(msg.access_token, expires)
      } yield (refresh, bearer)
  
    def bearer(refresh: RefreshToken): F[BearerToken] =
      for {
        request <- RefreshRequest(config.clientSecret,
                                  refresh.token,
                                  config.clientId).pure[F]
        msg     <- client.post[RefreshRequest, RefreshResponse](
                     config.refresh, request)
        time    <- clock.now
        expires = time + msg.expires_in.seconds
        bearer  = BearerToken(msg.access_token, expires)
      } yield bearer
  }
4.4 Summary
algebraic data types (ADTs) are defined as products (final case class) and coproducts (sealed abstract class).
Refined types enforce constraints on values.
concrete functions can be defined in an implicit class to maintain left-to-right flow.
polymorphic functions are defined in typeclasses. Functionality is provided via “has a” context bounds, rather than “is a” class hierarchies.
typeclass instances are implementations of a typeclass.
@simulacrum.typeclass generates .ops on the companion, providing convenient syntax for typeclass functions.
typeclass derivation is compiletime composition of typeclass instances.
