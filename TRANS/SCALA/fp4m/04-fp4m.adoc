include::header.adoc[]

4. Дані та функціональність
===========================

В OOP ми звикли думати про дані та функціональність разом: ієрархії класів несуть методи, і трейти можуть вимагати, щоб існували поля даних. Поліморфізм часу виконання об'єкту є терміном відношення “є різновидом”, що вимагає, щоб класи наслідували від загальних інтерфейсів. Це може викликати плутанину при зростанні обсягу коду. Прості типи даних стають прихованими за сотнями рядків методів, міксіни трейтів потерпають від помилок порядку ініціалізації, та тестування / мокінг дуже пов'язаних компонент стає жахом.

FP приймає інший підхід, визначаючи дані та функціональність окремо. В цій главі ми розглянемо основи типів даних, та переваги обмеження себе до підмножини мови Scala. Ми також дослідимо типокласи як спосіб досягти поліморфізм часу компіляції: думати про функціональність структури даних в термінах відношення “має”, скоріше, ніж “є різновидом”.

4.1 Дані
--------
Фундаментальні будівельні блоки типів даних є:

* `final case class`, також відомі як продукти
* `sealed abstract class`, також відомі як ко-продукти
* `case object` та значення `Int`, `Double`, `String` (тощо) без методів або полів, крім параметрів конструктора. Ми обираємо абстрактні класи замість трейтів, щоб отримати кращу бінарну сумісність, та щоб перешкоджати міксуванню трейтів.

Колективна назва для продуктів, ко-продуктів та значень є _Алгебраїчні типи даних_ (Algebraic Data Type, ADT).

Ми компонуємо типи даних з логічної алгебри `AND` та `XOR` (виключне `OR`): продукт містить кожний тип, з яких він складається, але ко-продукт може бути тільки один. For example
[source,scala]
----
product: ABC = a AND b AND c
coproduct: XYZ = x XOR y XOR z
----
записане в Scala
[source,scala]
----
  // значення
  case object A
  type B = String
  type C = Int
  
  // продукт
  final case class ABC(a: A.type, b: B, c: C)
  
  // ко-продукт
  sealed abstract class XYZ
  case object X extends XYZ
  case object Y extends XYZ
  final case class Z(b: B) extends XYZ
----
4.1.1 Рекурсівні ADT
~~~~~~~~~~~~~~~~~~~~
Коли ADT посилається на себе, ми називаємо це Рекурсивним алгебраїчним типом даних (Recursive Algebraic Data Type).

`scalaz.IList`, безпечна альтернатива до `stdlib` `List`, є рекурсивною, оскікльи `ICons` містить посилання на `IList.`:
[source,scala]
----
  sealed abstract class IList[A]
  final case class INil[A]() extends IList[A]
  final case class ICons[A](head: A, tail: IList[A]) extends IList[A]
----
4.1.2 Функції на ADT
~~~~~~~~~~~~~~~~~~~~
ADT може містити чисті функції:
[source,scala]
----
  final case class UserConfiguration(accepts: Int => Boolean)
----
Але ADT, що мають функції, ідуть з деякими особистостями, бо вони не ідеально транслюються на JVM. Наприклад, старий `Serializable`, `hashCode`, `equals` та `toString` не поводяться так, як дехто може логічно очікувати.

Нажаль, `Serializable` використовується в популярних фреймворках, не зважаючи на значно кращі альтернативи. Загальна пастка є забути, що  `Serializable` може спробувати селіалізувати ціле замикання функції, що може зламати промисловий сервер. Подібна специфіка стосується старих Java класів, таких як `Throwable`, що може нести посилання на довільні об'єкти.

Ми будемо досліджувати альтернативи до старих методів, коли ми дискутуватимемо бібліотеку `Scalaz` в наступній главі, ціною втрати взаємодії з деяким старим кодом Java та Scala.

4.1.3 Вичерпність
~~~~~~~~~~~~~~~~~
Важливо, що ми використовуємо закоркований абстрактний клас, не просто абстрактний клас, коли визначаємо тип даних. Закоркування класу означає, що всі підтипи мають бути визначені в тому ж файлі, дозволяючи компілятору знати щодо них в вичерпному співпадінні шаблонів, та в макросах, що запобігають шаблонному коду. Тобто:
[source,scala]
----
  scala> sealed abstract class Foo
         final case class Bar(flag: Boolean) extends Foo
         final case object Baz extends Foo
  
  scala> def thing(foo: Foo) = foo match {
           case Bar(_) => true
         }
  <console>:14: error: match may not be exhaustive.
  It would fail on the following input: Baz
         def thing(foo: Foo) = foo match {
                               ^
----
Це показує розробнику, що вони зламають речі, якщо вони додають новий продукт до коду. Ми використовуємо `-Xfatal-warnings`, інакше це тільки попередження.

Однак компілятор не буде виконувати перевірку вичерпності, якщо клас не закоркований, або якщо стоять захисники, тобто:
[source,scala]
----
  scala> def thing(foo: Foo) = foo match {
           case Bar(flag) if flag => true
         }
  
  scala> thing(Baz)
  scala.MatchError: Baz (of class Baz$)
    at .thing(<console>:15)
----
Щоб залишатись в безпеці не використовуйте захисників на закоркованих типах.

Флаг `-Xstrict-patmat-analysis` був запропонований як покращення мови для виконання додаткових перевірок співпадіння шаблонів.

4.1.4 Альтернативні продукти та ко-продукти
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Іншою формою продукта є тапл, що як непомічений фінальний кейс клас.

`(A.type, B, C)` еквівалентне до `ABC` в прикладі вище, але краще використовувати фінальний кейс клас як частини ADT, оскільки брак імен ускладнює справи, і кейс клас має значно кращу продуктивність для примітивних значень.

Інша форма ко-продукта утворюється, коли ми вкладаємо типи `Either`. Тобто:
[source,scala]
----
  Either[X.type, Either[Y.type, Z]]
----
еквівалентне до закоркованого абстрактного класу `XYZ`. Ясніший синтаксис для визначення вкладених типів `Either` є створення псевдониму типу, що завершується на двокрапку, дозволяючи інфіксну нотацію з правою асоціацією:
[source,scala]
----
  type |:[L,R] = Either[L, R]
  
  X.type |: Y.type |: Z
----
Це корисно для створення анонімних ко-продуктів, коли ми не можемо покласти всі реалізації в той самий джерельний файл.
[source,scala]
----
  type Accepted = String |: Long |: Boolean
----
І ще один альтернативний ко-продукт є створення власного закоркованого абстрактного класу з фінальним кейс класом, що просто огортає бажаний тип:
[source,scala]
----
  sealed abstract class Accepted
  final case class AcceptedString(value: String) extends Accepted
  final case class AcceptedLong(value: Long) extends Accepted
  final case class AcceptedBoolean(value: Boolean) extends Accepted
----
Порівняння шаблонів на ціх формах ко-продуктів може бути тендітним, ось чому були досліджені _Union Types_ в `Dotty`, компіляторі Scala наступного покоління. Макроси, такі як `totalitarian` та `iotaz` існують як альтернативні шляхи кодування анонімних ко-продуктів.

4.1.5 Подача інформації
~~~~~~~~~~~~~~~~~~~~~~~
Окрім функції контейнера для потрібної бізнес інформації, типи даних можуть використовуватись для кодування обмежень. Наприклад,
[source,scala]
----
  final case class NonEmptyList[A](head: A, tail: IList[A])
----
ніколи не може бути порожнім. Це робить `scalaz.NonEmptyList` корисним типом даних, що містить ту саму інформацію, що і `IList`.

Продуктові типи часто містять типи, що значно більш загальні, ніж дозволено. В традиційному OOP це може бути оброблене за допомогою валідації вводу через припущення:
[source,scala]
----
  final case class Person(name: String, age: Int) {
    require(name.nonEmpty && age > 0) // руйнує загальність, не робіть цього!
  }
----
Замість цього ми можемо використовувати тип даних `Either` щоб провадити `Right[Person]` для валідних примірників, та захиститись від просування навалідних примірників. Зауважте, що конструктор приватний:
[source,scala]
----
  final case class Person private(name: String, age: Int)
  object Person {
    def apply(name: String, age: Int): Either[String, Person] = {
      if (name.nonEmpty && age > 0) Right(new Person(name, age))
      else Left(s"bad input: $name, $age")
    }
  }
  
  def welcome(person: Person): String =
    s"${person.name} you look wonderful at ${person.age}!"
  
  for {
    person <- Person("", -1)
  } yield welcome(person)
----
4.1.5.1 Очищені типи даних
~~~~~~~~~~~~~~~~~~~~~~~~~~
Чіткий спосіб обмежити значення загального типу можливо за допомогою бібліотеки `refined`, провадячи сюїту обмежень до вмісту даних. Щоб встановити `refined`, додайте наступне до `build.sbt`:
[source,scala]
----
  libraryDependencies += "eu.timepit" %% "refined-scalaz" % "0.9.2"
----
та наступні імпорти:
[source,scala]
----
  import eu.timepit.refined
  import refined.api.Refined
----
`Refined` дозволяє визначити `Person` використовуючи створені на льоту очищені типи, щоб захопити вимоги в точності, записуючи `A Refined B`.

Всі типи з двома параметрами можуть бути записані інфіксно в Scala. Наприклад, `Either[String, Int]` є те саме, що `String Either Int`. За домовленостю `Refined` записується інфіксно, оскільки `A Refined B` можна прочитати як “`A`, що відповідає вимогам, визначеним в `B`”.
[source,scala]
----
  import refined.numeric.Positive
  import refined.collection.NonEmpty
  
  final case class Person(
    name: String Refined NonEmpty,
    age: Int Refined Positive
  )
----
Підлегле значення можна отримати за допомогою `.value`. Ми можемо конструювати значення від час виконання з використанням `.refineV`, повертаючи `Either`:
[source,scala]
----
  scala> import refined.refineV
  scala> refineV[NonEmpty]("")
  Left(Predicate isEmpty() did not fail.)
  
  scala> refineV[NonEmpty]("Sam")
  Right(Sam)
----
Якщо ми додамо наступний імпорт:
[source,scala]
----
  import refined.auto._
----
ми можемо конструювати валідні значення під час компіляції, та отримати помилку, якщо надамо значення, що не відповідає вимогам:
[source,scala]
----
  scala> val sam: String Refined NonEmpty = "Sam"
  Sam
  
  scala> val empty: String Refined NonEmpty = ""
  <console>:21: error: Predicate isEmpty() did not fail.
----
Можливо захопити більш складні вимоги, наприклад, ми можемо використовувати вбудоване правило `MaxSize` з наступними імпортами:
[source,scala]
----
  import refined.W
  import refined.boolean.And
  import refined.collection.MaxSize
----
захоплюючі вимогу, що `String` має бути одночасно непорожнім та мати максимальний розмір 10 символів:
[source,scala]
----
  type Name = NonEmpty And MaxSize[W.`10`.T]
  
  final case class Person(
    name: String Refined Name,
    age: Int Refined Positive
  )
----
Нотація `W` є скороченим для “witness” (_засвідчити_). Цей синтаксис буде значно простіший в Scala 2.13, що має підтримку для літеральних типів:
[source,scala]
----
  type Name = NonEmpty And MaxSize[10]
----
Просто визначити визначення власних вимог, що не охоплені бібліотекою  `refined`. Наприклад, в `drone-dynamaic-agents` нам знадобиться спосіб переконатись, що `String` містить `application/x-www-form-urlencoded`. Ми можемо створити правило `Refined`, використовуючи бібліотеку регулярних виразів Java:
[source,scala]
----
  sealed abstract class UrlEncoded
  object UrlEncoded {
    private[this] val valid: Pattern =
      Pattern.compile("\\A(\\p{Alnum}++|[-.*_+=&]++|%\\p{XDigit}{2})*\\z")
  
    implicit def urlValidate: Validate.Plain[String, UrlEncoded] =
      Validate.fromPredicate(
        s => valid.matcher(s).find(),
        identity,
        new UrlEncoded {}
      )
  }
----
4.1.6 Поділяти просто
~~~~~~~~~~~~~~~~~~~~~
Не провадячи жодної функціональності, ADT можуть мати мінімальний набір залежностей. Це робить простим їх публікацію та поділення з іншими розробниками. Через використання простої мови моделювання даних, стає можливим взаємодія з між-галужевими командами, такими як DBA, розробники UI та бізнес аналітики, використовуючи справжній код замість рукописного документу в якості джерела істини.

Більше того, інструментарій може бути написаний більш просто для продукування або споживання схем від інших мов програмування та дротових протоколів.

4.1.7 Підрахунок складності
~~~~~~~~~~~~~~~~~~~~~~~~~~~
Складність типу даних є підрахунок значень, що можуть існувати. Гарний тип даних має найменьшу кількість складності, якій потрібен для утримання інформації, що має передаватись, і не більше.

Значення мають вбудовану складність:

`Unit` має одне значення (чому він і називається “одиничний”)
`Boolean` має два значення
`Int` має 4,294,967,295 значень
`String` ефективно має безліч значень

Щоб знайти складність продкуту ми перемножуємо складність кожної частини.

(`Boolean`, `Boolean`) має 4 значення (2*2)
(`Boolean`, `Boolean`, `Boolean`) має 8 значень (2*2*2)

Щоб знайти складність ко-продукту, ми додаємо складність кожної частини.

(`Boolean` |: `Boolean`) має 4 значення (2+2)
(`Boolean` |: `Boolean` |: `Boolean`) має 6 значень (2+2+2)

Щоб знайти складність ADT з параметром типу, помножте кожну частину на складність параметру типу:

`Option[Boolean]` має 3 значення, `Some[Boolean]` та `None` (2+1)

В FP функції повні та мають повертати значення для кожного вводу, не `Exception`. Мінімізація складності входів та виходів є кращим способом досягти загальності. Як правило великого пальця, це знак поганої розробки функції, якщо складність поверненного значення функції більша, ніж складність продукту вхідних значень: це джерело ентропії.

Складність загальної функції є число можливих функцій, що можуть задовільнити сигнатурі типу: вихід в ступіні вводу.

`Unit => Boolean` має складність 2
`Boolean => Boolean` має складність 4
'Option[Boolean] => Option[Boolean]' має складність 27
`Boolean => Int` має складність квантіліон на секстіліон.
`Int => Boolean` має таку складність, що якщо всі реалізації мали б порядковий номер, кожний мав би 4Гб в довжину.

В реальності `Int => Boolean` буде дечим простим, як `isOdd`, `isEven` або розріжений `BitSet`. Ця функція, коли використовується в ADT, краще може бути замінена на ко-продукт, який маркує обмежену множину функцій, що є релевантними.

Коли складність є “безкінечність на вході, безкінечність на виході”, нам треба ввести обмежувальні типи даних та валідацію ближче до точки входу за допомогою `Refined` з попереднього розділу.

Здантість порахувати складність сигнатури типу має одне інше практичне застосування: ми можемо знайти простіші сигнатури типів за допомогою алгебри вищої школи! Щоб перейти від сигнатури типу до її алгебри складності, просто замініть:
[source,scala]
----
Either[A, B] на a + b
(A, B) на a * b
A => B на b ^ a
----
зробіть деякі перестановки, та конвертуйте назад. Наприклад, скажімо, ми розробили фреймворк що базується на зворотніх викликах, і ми поставили себе в ситуацію, коли ми створили наступну сигнатуру типу:
[source,scala]
----
  (A => C) => ((B => C) => C)
----
Ми можемо конвертувати та переставити її так:
[source,scala]
----
  (c ^ (c ^ b)) ^ (c ^ a)
  = c ^ ((c ^ b) * (c ^ a))
  = c ^ (c ^ (a + b))
----
потім конвертувати назад до типів та отримати:
[source,scala]
----
  (Either[A, B] => C) => C
----
що значно простіше: ми тільки просимо користувачів нашого фреймфорку провадити `Either[A, B] => C`.

Той самий хід думок може бути використаний для перевірки, що:
[source,scala]
----
  A => B => C
----
еквівалентне до
[source,scala]
----
  (A, B) => C
----
що також відоме як _карування_.

4.1.8 Обирайте ко-продукти замість продуктів
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Архітепічне моделювання проблем, що постає здебільшо коли існують взаємно виключні параметри конфігурації `a`, `b` та `c`. Продукт `(a: Boolean, b: Boolean, c: Boolean)` має складність 8, тоді як ко-продукт
[source,scala]
----
  sealed abstract class Config
  object Config {
    case object A extends Config
    case object B extends Config
    case object C extends Config
  }
має складність 3. Краще моделювати ці параметри конфігурації як ко-продукт, ніж дозволити існування п'яти невалідних станів.

Складність типу даних також має вплив на тестування. Практично неможливо тестувати кожний можливий вхід до функції, але просто тестувати примірник значень за допомогою фреймворка тестування властивостей `Scalacheck`. Якщо випадковий примірник типу даних має низьку вірорідність бути валідним, це знак, що дані змодельовані некоректно.

4.1.9 Оптимізації
~~~~~~~~~~~~~~~~~
Велика перевага від використання спрощеної підмножини мови Scala для представлення типів даних в тому, що інструментарій може оптимізувати репрезентацію байткоду JVM.

Наприклад, ми можемо запакувати поля `Boolean` та `Option` в `Array[Byte]`, кешувати значення, запам'ятати `hashCode`, оптимізувати `equals`, використовувати твердження `@switch` при порівнянні шаблонів, та багато іншого.

Ці оптимізації неможливо застосувати для ієрархій класів OOP, що можуть керувати станом, закидати виключення або провадити adhoc реалізції методів.

4.2 Функціональність
--------------------
Чисті функції типово визначаються як методи на об'єкті.
[source,scala]
----
  package object math {
    def sin(x: Double): Double = java.lang.Math.sin(x)
    ...
  }
  
  math.sin(1.0)
----
Однак буде незручним використовувати методи об'єкта, оскільки це читається зсередини-назовні, не зліва направо. На додаток функція на об'єкті краде простір імен. Якщо ми визначимо `sin(t: T)` будь-де ще, ми отримаємо помилку невизначенності посилання. Це та сама проблема, що і статичні методи в Java vs методів классу.

Різновид розробників, що складють методи в трейт, та вимагають від користувачів міксувати їх за допомогою шаблону кекса, прямують прямо до пекла. Це дає витік внутрішніх деталей реалізації до публічних API,заплутує байткод, робить двоїчну сумісність в основному неможливою, та засмучує  автодоповнювач IDE.

З можливістю мови щодо неявних класів (також відомою як методологія або синтаксис розширення), та невеликим шаблоном ми можемо отримати знайомий стиль:
[source,scala]
----
  scala> implicit class DoubleOps(x: Double) {
           def sin: Double = math.sin(x)
         }
  
  scala> (1.0).sin
  res: Double = 0.8414709848078965
----
Часто краще просто пропустити визначення об'єкта, та перейти прямо до неявного класу, утримуючи шаблонний код на мінімумі:
[source,scala]
----
  implicit class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
----
неявний клас є синтаксичним цукром до неявного перетворення:
[source,scala]
----
  implicit def DoubleOps(x: Double): DoubleOps = new DoubleOps(x)
  class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
----
Що, нажаль, має вартість під час виконання: кожний раз, коли викликається метод розширення, посередник `DoubleOps` буде конструюватись та потів відкидатись геть. Це може докластись до тиску на GC в гарячих точках.

Існує трохи більш балаклива форма неявних класів, що уникає розміщення, і, таким чином, більш бажана:
[source,scala]
----
  implicit final class DoubleOps(private val x: Double) extends AnyVal {
    def sin: Double = java.lang.Math.sin(x)
  }
----
4.2.1 Поліморфні функції
~~~~~~~~~~~~~~~~~~~~~~~~
Більш загальний різновид функцій є поліморфні функції, що живуть в _типокласах_. Типоклас є трейт, що:

* не збурігає стан
* має параметр типу
* має щонайменьше один абстрактний метод (примітивні комбінатори)
* може містити узагальнені методи (похідні комбінатори)
* може розширювати інший типоклас

Є тільки одна реалізація типокласу для любого даного параметру типу, властивість, відома під назвою когерентність типокласу. Типокласи  виглядають напрочуд подібно до алгебраїчних інтерфейсів, але алгебри не обов'язково мають бути когерентними.

Когенентність типокласів в основному відноситься до узгодженості, і узгодженість дає нам впевненість для використання неявних параметрів. Може бути складним продумувати код, що виконується по різному на неявних імпортах в полі зору. Когерентність типокласів насправді каже, що імпорти не повинні впливати на поведінку коду.

Додатково, когерентність типокласів дозволяє нам глобально кешувати неявні під час виконання, та зберігати розміщення пам'яті, отримуючи покращення продуктивності від зменшеного тиску на збирача сміття.

Типокласи використовуються в Scala `stdlib`. Ми дослідимо спрощену версію `scala.math.Numeric` для демонстрації принципу:
[source,scala]
----
  trait Ordering[T] {
    def compare(x: T, y: T): Int
  
    def lt(x: T, y: T): Boolean = compare(x, y) < 0
    def gt(x: T, y: T): Boolean = compare(x, y) > 0
  }
  
  trait Numeric[T] extends Ordering[T] {
    def plus(x: T, y: T): T
    def times(x: T, y: T): T
    def negate(x: T): T
    def zero: T
  
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
----
Ми можмо бачити всі ключові властивості типокласу в дії:

* немає стану
* `Ordering` та `Numeric` мають параметр типу `T`
* `Ordering` має абстрактне `compare`, та `Numeric` має абстрактні `plus`, `times`, `negate` та `zero`
* `Ordering` визначає узагальнені `lt` та `gt` базовані на `compare`, `Numeric` визначає `abs` в термінах `lt`, `negate` та `zero`.
* `Numeric` розширює `Ordering`

Тепер ми можемо писати функції для типів, що “має” типоклас `Numeric`:
[source,scala]
----
  def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {
    import N._
    times(negate(abs(t)), t)
  }
----
Ми більше не залежимо від ієрархії OOP від наших вхідних типів, тобто, ми не вимагаємо, щоб наш вхід “був” `Numeric`, що є критично важливим, якщо ми бажаємо підтримати клас третіх сторін, який ми не можемо перевизначити.

Інша перевага типокласів в тому, що асоціація функціональності до даних відбувається під час компіляції, на відміну від рантайм динамічної диспечерізації OOP.

Наприклад, хоча клас `List` може мати лише одну реалізацію метода, метод типокласу дозволяє нам мати різні реалізації в залежності від вмісту `List`, і, таким чином, перекласти навантаження на час компіляції, замість залишати його на рантайм.

4.2.2 Синтаксис
~~~~~~~~~~~~~~~
Синтаксис для написання `signOfTheTimes` є заплутаним, існують деякі речі, які ми можемо зробити, щоб розчистити його.

Нижні користувачі будуть краще бачити наш метод, як використовуючий межі контексту, оскільки сигнатура ясно читається як “приймає `T`, що має `Numeric`”
[source,scala]
----
  def signOfTheTimes[T: Numeric](t: T): T = ...
----
але тепер ми маємо будь-де використовувати `implicitly[Numeric[T]]`. Через визначення шаблонного коду на компанйоні типокласу:
[source,scala]
----
  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  }
----
ми можемо отримати неявне з меньшим шумом
[source,scala]
----
  def signOfTheTimes[T: Numeric](t: T): T = {
    val N = Numeric[T]
    import N._
    times(negate(abs(t)), t)
  }
----
Але це все ще гірше для нас, як для реалізаторів. Ми маємо синтаксичну проблему статичних методів зсередини-назовні vs методів класів. Ми маємо справу з цім через введення `ops` на компанйоні типокласу:
[source,scala]
----
  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  
    object ops {
      implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {
        def +(o: T): T = N.plus(t, o)
        def *(o: T): T = N.times(t, o)
        def unary_-: T = N.negate(t)
        def abs: T = N.abs(t)
  
        // дублікація з Ordering.ops
        def <(o: T): T = N.lt(t, o)
        def >(o: T): T = N.gt(t, o)
      }
    }
  }
----
Зауважте, `-x` розширюється до `x.unary_-` через компіляторний синтаксичний синтаксис, через що ми визначаємо `unary_-` як метод розширення. Тепер ми можемо записати значно ясніше:
[source,scala]
----
  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
----
Гарна новина в тому, що нам ніколи не треба писати цей код, оскільки `Simulacrum` провадить макро анотацію `@typeclass`, що автоматично генерує `apply` та `ops`. Він навіть дозволяє нам визначити альтернативні імена (звичайно символічні) для загальних методів. Загалом:
[source,scala]
----
  import simulacrum._
  
  @typeclass trait Ordering[T] {
    def compare(x: T, y: T): Int
    @op("<") def lt(x: T, y: T): Boolean = compare(x, y) < 0
    @op(">") def gt(x: T, y: T): Boolean = compare(x, y) > 0
  }
  
  @typeclass trait Numeric[T] extends Ordering[T] {
    @op("+") def plus(x: T, y: T): T
    @op("*") def times(x: T, y: T): T
    @op("unary_-") def negate(x: T): T
    def zero: T
    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
  
  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
----
Тепер коли є власний символічний `@op`, він має вимовлятись як ім'я метода. Тобто, `<` вимовляється “меньше ніж”, не “ліва кутова дужка”.

4.2.3 Примірники
~~~~~~~~~~~~~~~~
Примірники `Numeric` (що також є примірниками `Ordering`) визначаються як `implicit val`, що розширює типоклас, та може провадити оптимізовану реалізації для узагальнених методів:
[source,scala]
----
  implicit val NumericDouble: Numeric[Double] = new Numeric[Double] {
    def plus(x: Double, y: Double): Double = x + y
    def times(x: Double, y: Double): Double = x * y
    def negate(x: Double): Double = -x
    def zero: Double = 0.0
    def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)
  
    // оптимізовано
    override def lt(x: Double, y: Double): Boolean = x < y
    override def gt(x: Double, y: Double): Boolean = x > y
    override def abs(x: Double): Double = java.lang.Math.abs(x)
  }
----
Хоча ми тут використовуємо `+`, `*`, `unary_-`, `<` та `>`, що є `ops` (і може бути безкінечний цикл!), ці методи вже існують на `Double`. Методи класів завжди використовуються з перевагою над методами розширення. Зрозуміло, що компілятор Scala виконує особливу обробку примітивів, та конвертує ці методи до сирих байткод інструкцій `dadd`, `dmul`, `dcmpl` та `dcmpg`, відповідно.

Ми також можемо реалізувати `Numeric` для Java класу `BigDecimal` (уникайте `scala.BigDecimal`, він фундаментально хибний)
[source,scala]
----
  import java.math.{ BigDecimal => BD }
  
  implicit val NumericBD: Numeric[BD] = new Numeric[BD] {
    def plus(x: BD, y: BD): BD = x.add(y)
    def times(x: BD, y: BD): BD = x.multiply(y)
    def negate(x: BD): BD = x.negate
    def zero: BD = BD.ZERO
    def compare(x: BD, y: BD): Int = x.compareTo(y)
  }
----
Ви можете створити нашу власну структуру даних для комплексних чисел:
[source,scala]
---- 
  final case class Complex[T](r: T, i: T)
----
Та наслідувати `Numeric[Complex[T]]`, якщо існує `Numeric[T]`. Оскільки ці примірники залежать від параметру типа, це `def`, не `val`.
[source,scala]
----
  implicit def numericComplex[T: Numeric]: Numeric[Complex[T]] =
    new Numeric[Complex[T]] {
      type CT = Complex[T]
      def plus(x: CT, y: CT): CT = Complex(x.r + y.r, x.i + y.i)
      def times(x: CT, y: CT): CT =
        Complex(x.r * y.r + (-x.i * y.i), x.r * y.i + x.i * y.r)
      def negate(x: CT): CT = Complex(-x.r, -x.i)
      def zero: CT = Complex(Numeric[T].zero, Numeric[T].zero)
      def compare(x: CT, y: CT): Int = {
        val real = (Numeric[T].compare(x.r, y.r))
        if (real != 0) real
        else Numeric[T].compare(x.i, y.i)
      }
    }
----
Спостережливий читач може зауважити, що `abs` взагалі не те, що може очікувати математик. Коректне повернуте значення для `abs` має бути `T`, не `Complex[T]`.

`scala.math.Numeric` намагається робити дуже багато, і не узагальнує за межами дійсних чисел. Це гарний урок того, що меньші, гарно визначені типокласи часто кращі, ніж монолітні колекції дуже специфічних можливостей.

4.2.4 Розрішення неявних
~~~~~~~~~~~~~~~~~~~~~~~~
Ми гарно обсудили неявні: цей розділ призначений для прояснення, що таке неявні, та як вони роблять.

Коли метод запитує, щоб в полі зору викликаючого знаходився унікальний примірник певного типу, неявні параметри є особливим синтаксисом для примірників типокласів. Неявні параметри є ясним шляхом конфігурації потоку через застосування.

В цьому прикладі `foo` потребує, щоб для `A` були доступні примірники типокласів `Numeric` та `Typeable`, так само, як неявний об'єкт `Handler`, що приймає два параметри типів
[source,scala]
----
  def foo[A: Numeric: Typeable](implicit A: Handler[String, A]) = ...
----
Неявне перетворення відбувається коли існує `implicit def`. Один такий випадок неявного перетворення є використання методології розширення. Коли компілятор розрішує виклик метода, він спочатку перевіряє, чи метод існує для типу, потім для предків (Java-подібні правила). Якщо він не зможе знайти співпадіння, він буде шукати неявне поле зору для перетворень до інших типів, потім шукає серед методів на ціх типах.

Інше використання для неявних перетворень є похідні типокласи. В попередньому розділі ми написали неявний `def`, що походить від `Numeric[Complex[T]]`, якщо `Numeric[T]` існує в неявному полі зору. Можливо зціпити разом декілька `implicit def` (включаючи рекурсію), що є базисом типованого програмування, дозволяючи виконання обчислень під час компіляціїї, замість рантайму.

Клей, що зліплює неявні параметри (отримувачі) з неявними перетвореннями (провайдерами) є розрішення неявних.

Зпочатку шукається звичане поле зору змінної, по порядку:

* локальне поле зору, включаючи локальні імпорти (тобто блок або метод)
* зовнішнє поле зору, включаючи імпорти в цій області (тобто члени в класі)
* предки (тобто члени в суер класі)
* поточний об'єкт пакаунку
* об'єкти батьківських пакунків (коли використовуються вкладені пакунки)
* імпорти файлу

Якщо пошук співпадіння схибить, шукається особливе поле зору, що виглядає неявні примірники в компанйоні типу, його об'єкті пакунку, зовнішні об'єкти (якщо вкладені), та потім повторюється для предків. Це виконується в тому ж порядку для:

* даного типу параметра
* очікуваного типу параметра
* параметру типу (якщо такий існує)

Якщо знайдено два співпадаючих неявних в тій самій фазі розрішення неявного, закидається помилка неявного.

Неявні часто визначаються на трейтах, що потім розширюються об'єктами. Це робиться для проби та контролю приоритетів неявного відносно іншого, більш специфічного, щоб уникнути невизначені неявні.

Специфікація Scala Language Specification досить невизначена щодо крайніх випадків, та реалізація компілятора є стандартом де факто. Існують деякі правила великого пальця, що ми будемо використовувати в цій книзі, тобто обирати `implicit val` замість `implicit object`, не зважаючи на спокусу меньшого друку. Є особливість розрішення неявних, що `implicit object` на об'єкті компанйоні не трактується так само, що і `implicit val`.

Розрішення неявних не праціє, коли є ієрархія типокласів, як `Ordering` та `Numeric`. Якщо ми пишемо функцію, що приймає неявне `Ordering`, і ми викликаємо її для примітивного типа, що має примірник `Numeric`, визначене на компанйоні `Numeric`, компілятор не зможе знайти його.

Розрішення неявних частково є процес пан-або-пропав, якщо використовуються псевдоними типів, де форма неявних параметрів змінюється. Наприклад, приклад неявного параметра з використанням псевдонима, як `type Values[A] = List[Option[A]]`, можливо схибить знайти неявні, визначені як сирі `List[Option[A]]`, оскільки форма змінюється з речі речей типу `A` на річ типу `A`.

4.3 Моделювання OAuth2
----------------------
Ми завершемо цю главу практичним прикладом моделювання даних та походження типокласів, в комбінації з розробкою алгебри / модуля з попередньої глави.

В нашому застосуванні дрон-динамічний-агент, ви маєте комунікувати з Drone та Google Cloud, використовуючи JSON над REST. Обоє сервіси використовують OAuth2 для аутентифікацією. Існує багато шляхів інтерпретувати OAuth2, але ми будемо фокусуватись на версії, що робить для Google Cloud (версія для Drone навіть простіша).

4.3.1 Опис
~~~~~~~~~~
Кожне застосування Google Cloud потребує мати OAuth 2.0 Client Key, встановлений за адресою:
----
  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
----
Отримання Client ID та Client secret.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Після цього застосування може отримати одноразовий код, через виконання користувачем Authorization Request в їх браузері (так, насправді, в їх браузері). Нам треба відкрити цю сторінку в браузері:
----
  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&\
    prompt=consent&\
    response_type=code&\
    scope={SCOPE}&\
    access_type=offline&\
    client_id={CLIENT_ID}
----
Код доставляється до `{CALLBACK_URI}` в вигляді запиту `GET`. Якщо захопити його в нашому застосуванні, нам треба мати веб сервер, що слухатиме на `localhost`.

Коли ми маємо код, ми можемо виконати Access Token Request:
----
  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&\
    redirect_uri={CALLBACK_URI}&\
    client_id={CLIENT_ID}&\
    client_secret={CLIENT_SECRET}&\
    scope={SCOPE}&\
    grant_type=authorization_code
----
що дає відповідь з корисним навантаженням JSON
----
  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }
----
Токени `Bearer` (на пред'явника) прострочений після години, та може бути оновлений через надсилання HTTP запиту з любим валідним токеном оновлення:
----
  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&
    grant_type=refresh_token&
    refresh_token={REFRESH_TOKEN}&
    client_id={CLIENT_ID}
----
з відповіддю
----
  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }
----
Всі запити користувацького простору до сервера мають включати заголовок
----
  Authorization: Bearer BEARER_TOKEN
----
після підставки справжнього BEARER_TOKEN.

Google прострочує всі, крім останніх 50 токенів на пред'явника, так що час прострочення є тільки приблизним. Оновлені токени зберігаються між сессіями, та можуть бути прострочені користувачем вручну. Таким чином ми можемо одноразове налаштування застосування для отримання оновлень токенів, та потім включати токен оновлення як конфігурацію для встановлення користувацького сервера.

Drone не реалізує ендпоінт `/auth`, або `refresh`, та просто провадить `BEARER_TOKEN` через їх користувацькій інтерфейс.

4.3.2 Дані
~~~~~~~~~~
Перший крок є моделювання даних, потрібних для OAuth2. Ми створимо  ADT з полями, що мають точно ті самі назви, які потрібні для OAuth2 сервера. Ми будемо використовувати `String` та `Long` для краткості, але ми можемо використовувати очищені типи, якщо вони підпадають під нашу бізнес модель.
[source,scala]
----
  import refined.api.Refined
  import refined.string.Url
  
  final case class AuthRequest(
    redirect_uri: String Refined Url,
    scope: String,
    client_id: String,
    prompt: String = "consent",
    response_type: String = "code",
    access_type: String = "offline"
  )
  final case class AccessRequest(
    code: String,
    redirect_uri: String Refined Url,
    client_id: String,
    client_secret: String,
    scope: String = "",
    grant_type: String = "authorization_code"
  )
  final case class AccessResponse(
    access_token: String,
    token_type: String,
    expires_in: Long,
    refresh_token: String
  )
  final case class RefreshRequest(
    client_secret: String,
    refresh_token: String,
    client_id: String,
    grant_type: String = "refresh_token"
  )
  final case class RefreshResponse(
    access_token: String,
    token_type: String,
    expires_in: Long
  )
----
Уникайте використання `java.net.URL` за любу ціну: він використовує DNS для розрішення частини `hostname` для виконання `toString`, `equals` або `hashCode`.

Окрім того, що це безумство, і дуже-дуже повільно, ці методи можуть закидати I/O виключення (вони не чисті), та можуть змінюватись, в залежності від мережевої конфігурації (недетерміновано).

Покращений тип `String Refined Url` дозволяє нам виконувати перевірки рівності, базуючись на `String`, та ми можемо безпечно сконструювати URL, тільки якщо нам треба старий API.

Кажучи це, в високо продуктивному коді ми можемо обрати повністю виключити `java.net.URL`, та використовувати URL парсер третьої сторони, такий як `jurl`, оскільки навіть безпечні частини `java.net.*` вкрай повільні при маштабуванні.

4.3.3 Функціональність
~~~~~~~~~~~~~~~~~~~~~~
Нам треба маршалити класи даних, що ми визначили в попередньому розділі в JSON, URL та POST-кодовані форми. Оскільки це потребує поліморфізму, вам будуть потрібні типокласи.

`jsonformat` є простою JSON бібліотекою, яку більш детально ми вивчимо в наступній главі, бо вона була написано на принципах FP, та простота читання в якості головної цілі розробки. Вона складається з JSON AST та типокласів кодування / декодування:
[source,scala]
----
  package jsonformat
  
  sealed abstract class JsValue
  final case object JsNull                                    extends JsValue
  final case class JsObject(fields: IList[(String, JsValue)]) extends JsValue
  final case class JsArray(elements: IList[JsValue])          extends JsValue
  final case class JsBoolean(value: Boolean)                  extends JsValue
  final case class JsString(value: String)                    extends JsValue
  final case class JsDouble(value: Double)                    extends JsValue
  final case class JsInteger(value: Long)                     extends JsValue
  
  @typeclass trait JsEncoder[A] {
    def toJson(obj: A): JsValue
  }
  
  @typeclass trait JsDecoder[A] {
    def fromJson(json: JsValue): String \/ A
  }
----
`\/` є Scalaz `Either` та має `.flatMap`. Ми можете використовувати її в `for` розширеннях, тоді як `stdlib` `Either` не підтримує `.flatMap` до Scala 2.12. Воно читається як діз'юкція, або злий заєць.

`scala.Either` було додано до стандартної бібліотеки Scala  створювачем Scalaz, Tony Morris, в 2007-му році. `\/` було створено, коли до `Either` були додані небезпечні методи.

Нам знадобляться примірники `JsDecoder[AccessResponse]` та `JsDecoder[RefreshResponse]`. Ми можемо зробити це через використання допоміжної функції:
[source,scala]
----
  implicit class JsValueOps(j: JsValue) {
    def getAs[A: JsDecoder](key: String): String \/ A = ...
  }
----
Ми покладемо примірники до компанйонів наших типів даних, так що вони завжди будуть в неявному полі зору:
[source,scala]
----
  import jsonformat._, JsDecoder.ops._
  
  object AccessResponse {
    implicit val json: JsDecoder[AccessResponse] = j =>
      for {
        acc <- j.getAs[String]("access_token")
        tpe <- j.getAs[String]("token_type")
        exp <- j.getAs[Long]("expires_in")
        ref <- j.getAs[String]("refresh_token")
      } yield AccessResponse(acc, tpe, exp, ref)
  }
  
  object RefreshResponse {
    implicit val json: JsDecoder[RefreshResponse] = j =>
      for {
        acc <- j.getAs[String]("access_token")
        tpe <- j.getAs[String]("token_type")
        exp <- j.getAs[Long]("expires_in")
      } yield RefreshResponse(acc, tpe, exp)
  }
----
Тепер ми можемо розбирати рядки в `AccessResponse` або `RefreshResponse`:
[source,scala]
----
  scala> import jsonformat._, JsDecoder.ops._
  scala> val json = JsParser("""
                       {
                         "access_token": "BEARER_TOKEN",
                         "token_type": "Bearer",
                         "expires_in": 3600,
                         "refresh_token": "REFRESH_TOKEN"
                       }
                       """)
  
  scala> json.map(_.as[AccessResponse])
  AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
----
Нам треба написати наші власні типокласи для кодувань `URL` та `POST`. Наступне є прийнятним варіантом:
[source,scala]
----
  // пари запиту URL key=value в закодованій формі.
  final case class UrlQuery(params: List[(String, String)])
  
  @typeclass trait UrlQueryWriter[A] {
    def toUrlQuery(a: A): UrlQuery
  }
  
  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
----
Нам треба запровадити примірники типокласів для базових типів:
[source,scala]
----
  import java.net.URLEncoder
  
  object UrlEncodedWriter {
    implicit val encoded: UrlEncodedWriter[String Refined UrlEncoded] = identity
  
    implicit val string: UrlEncodedWriter[String] =
      (s => Refined.unsafeApply(URLEncoder.encode(s, "UTF-8")))
  
    implicit val url: UrlEncodedWriter[String Refined Url] =
      (s => s.value.toUrlEncoded)
  
    implicit val long: UrlEncodedWriter[Long] =
      (s => Refined.unsafeApply(s.toString))
  
    implicit def ilist[K: UrlEncodedWriter, V: UrlEncodedWriter]
      : UrlEncodedWriter[IList[(K, V)]] = { m =>
      val raw = m.map {
        case (k, v) => k.toUrlEncoded.value + "=" + v.toUrlEncoded.value
      }.intercalate("&")
      Refined.unsafeApply(raw) // by deduction
    }
  
  }
----
Ми використали `Refined.unsafeApply` коли ми можемо логічно вивести, що вміст рядка вже закодований як `url` кодування, пропускаючи любі подальші перевірки.

`ilist` є приклад простого походження типокласів, здебільшого як ми продукували `Numeric[Complex]` від підлеглої числової репрезентації. Метод `.intercalate` подібний до `.mkString`, але більше загальний.

`UrlEncodedWriter` використовує можливість мови Scala - Single Abstract Method (SAM типи). Повна форма вище наступна:
[source,scala]
----
  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
----
Коли компілятор Scala очікує клас (що має єдиний абстрактний метод), але отримує лямбду, він заповнює шаблонний код автоматично.

До SAM типів загальним шаблоном було визначати метод з назвою `instance` на компанйоні типокласу:
[source,scala]
----
  def instance[T](f: T => String): UrlEncodedWriter[T] =
    new UrlEncodedWriter[T] {
      override def toUrlEncoded(t: T): String = f(t)
    }
----
що дозволяє робити
[source,scala]
----
  implicit val string: UrlEncodedWriter[String] = instance { s => ... }
----
Цей шаблон все ще використовується в коді, що має підтримувати старіші версії Scala, або для примірників типокласів, що мають провадити більше ніж один метод.

Зауважте, що існує багато помилок коло SAM типів, через що вони не взаємодіють з усіма можливістями мови. Підкатіться до не-SAM варіанту, якщо трапляються дивні падіння компілятора.

В окремій главі Походження типокласів ми будемо обчислювати примірники `UrlQueryWriter` автоматично, так само, як очищати те, що вже написане, але натепер ми будемо писати шаблонний код для типів, які ми бажаємо перетворити:
[source,scala]
----
  import UrlEncodedWriter.ops._
  object AuthRequest {
    implicit val query: UrlQueryWriter[AuthRequest] = { a =>
      UrlQuery(List(
        ("redirect_uri"  -> a.redirect_uri.value),
        ("scope"         -> a.scope),
        ("client_id"     -> a.client_id),
        ("prompt"        -> a.prompt),
        ("response_type" -> a.response_type),
        ("access_type"   -> a.access_type))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =>
      IList(
        "code"          -> a.code.toUrlEncoded,
        "redirect_uri"  -> a.redirect_uri.toUrlEncoded,
        "client_id"     -> a.client_id.toUrlEncoded,
        "client_secret" -> a.client_secret.toUrlEncoded,
        "scope"         -> a.scope.toUrlEncoded,
        "grant_type"    -> a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =>
      IList(
        "client_secret" -> r.client_secret.toUrlEncoded,
        "refresh_token" -> r.refresh_token.toUrlEncoded,
        "client_id"     -> r.client_id.toUrlEncoded,
        "grant_type"    -> r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
----
4.3.4 Модуль
~~~~~~~~~~~~
Це складає моделювання даних та функціональності, потрібною для реалізації OAuth2. Згадайте з попередньої глави, що ми визначили компоненти, що треба для взаємодії зі світом як алгебри, та ми визначаємо бізнес логіку в модулі, так що вона може бути докладно протестована.

Ми визначаємо наші залежні алгебри, та ми використовуємо обмеження контексту, щоб показати, що наші відповіді повинні мати `JsDecoder`, та вміст нашого `POST` повинно мати `UrlEncodedWriter`:
[source,scala]
----
  trait JsonClient[F[_]] {
    def get[A: JsDecoder](
      uri: String Refined Url,
      headers: IList[(String, String)]
    ): F[A]
  
    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String] = IList.empty
    ): F[A]
  }
----
Зауважте, що ми визначаємо тільки щасливий шлях в JsonClient API. Ми будемо розглядати обробку помилок в наступній главі.

Отримання `CodeToken` від сервера Google OAuth2 включає запуск HTTP сервера на локальній машині, та отримання його номеру порта. Користувач відкриває веб сторінку в своєму браузері, що дозволяє війти з Google паролем та авторизувати застосування, з редиректом знову на локальну машину. Код захоплюється, інформуючи користува щодо подальших кроків, та закриття HTTP сервера. Ми можемо змоделювати це трьома методами в алгебрі `UserInteraction`.
[source,scala]
----
  final case class CodeToken(token: String, redirect_uri: String Refined Url)
  
  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
----
Це вигладає майже просто, якщо дивитись на це таким чином.

Нам також потрібна алгебра для абстрагування над локальним системним часом:
[source,scala]
----
  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
----
Також введемо типи даних, що ми будемо використовувати в логиці оновлення:
[source,scala]
----
  final case class ServerConfig(
    auth: String Refined Url,
    access: String Refined Url,
    refresh: String Refined Url,
    scope: String,
    clientId: String,
    clientSecret: String
  )
  final case class RefreshToken(token: String)
  final case class BearerToken(token: String, expires: Epoch)
----
Тепер ми можемо написати модуль клієнта OAuth2:
[source,scala]
----
  import http.encoding.UrlQueryWriter.ops._
  
  class OAuth2Client[F[_]: Monad](
    config: ServerConfig
  )(
    user: UserInteraction[F],
    client: JsonClient[F],
    clock: LocalClock[F]
  ) {
    def authenticate: F[CodeToken] =
      for {
        callback <- user.start
        params   = AuthRequest(callback, config.scope, config.clientId)
        _        <- user.open(params.toUrlQuery.forUrl(config.auth))
        code     <- user.stop
      } yield code
  
    def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
      for {
        request <- AccessRequest(code.token,
                                 code.redirect_uri,
                                 config.clientId,
                                 config.clientSecret).pure[F]
        msg     <- client.post[AccessRequest, AccessResponse](
                     config.access, request)
        time    <- clock.now
        expires = time + msg.expires_in.seconds
        refresh = RefreshToken(msg.refresh_token)
        bearer  = BearerToken(msg.access_token, expires)
      } yield (refresh, bearer)
  
    def bearer(refresh: RefreshToken): F[BearerToken] =
      for {
        request <- RefreshRequest(config.clientSecret,
                                  refresh.token,
                                  config.clientId).pure[F]
        msg     <- client.post[RefreshRequest, RefreshResponse](
                     config.refresh, request)
        time    <- clock.now
        expires = time + msg.expires_in.seconds
        bearer  = BearerToken(msg.access_token, expires)
      } yield bearer
  }
----
4.4 Підсумок
------------
* Алгебраїчні типи даних (ADT) визначені як продукти (фінальні кейс класи) та ко-продукти (закорковані абстрактні класи).

* Очищені типи накладають обмеження на значення.

* Суцільні функції можуть бути визначені в неявному класі для керуванням потоку зліва-направо.

* Поліморфічні функції визначені в типокласах. Функціональність реалізується через обмеження контексту “має деякий”, скоріше ніж ієрархіями класів “є різновидом”.

* Примірники типокласів є реалізаціями типокласів.

* `@simulacrum.typeclass` генерує `.ops` на компаньйоні, провадячи зручний синтаксис для функцій типокласів.

* Походження типокласів є композиція часу компіляції примірників типокласів.
