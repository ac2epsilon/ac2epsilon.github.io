<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>4. Дані та функціональність</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>4. Дані та функціональність</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>В OOP ми звикли думати про дані та функціональність разом: ієрархії класів несуть методи, і трейти можуть вимагати, щоб існували поля даних. Поліморфізм часу виконання об'єкту є терміном відношення “є різновидом”, що вимагає, щоб класи наслідували від загальних інтерфейсів. Це може викликати плутанину при зростанні обсягу коду. Прості типи даних стають прихованими за сотнями рядків методів, міксіни трейтів потерпають від помилок порядку ініціалізації, та тестування / мокінг дуже пов'язаних компонент стає жахом.</p></div>
<div class="paragraph"><p>FP приймає інший підхід, визначаючи дані та функціональність окремо. В цій главі ми розглянемо основи типів даних, та переваги обмеження себе до підмножини мови Scala. Ми також дослідимо типокласи як спосіб досягти поліморфізм часу компіляції: думати про функціональність структури даних в термінах відношення “має”, скоріше, ніж “є різновидом”.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_1_">4.1 Дані</h2>
<div class="sectionbody">
<div class="paragraph"><p>Фундаментальні будівельні блоки типів даних є:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>final case class</code>, також відомі як продукти
</p>
</li>
<li>
<p>
<code>sealed abstract class</code>, також відомі як ко-продукти
</p>
</li>
<li>
<p>
<code>case object</code> та значення <code>Int</code>, <code>Double</code>, <code>String</code> (тощо) без методів або полів, крім параметрів конструктора. Ми обираємо абстрактні класи замість трейтів, щоб отримати кращу бінарну сумісність, та щоб перешкоджати міксуванню трейтів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Колективна назва для продуктів, ко-продуктів та значень є _Алгебраїчні типи даних_ (Algebraic Data Type, ADT).</p></div>
<div class="paragraph"><p>Ми компонуємо типи даних з логічної алгебри <code>AND</code> та <code>XOR</code> (виключне <code>OR</code>): продукт містить кожний тип, з яких він складається, але ко-продукт може бути тільки один. For example</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">product</span><span class="k">:</span> <span class="kt">ABC</span> <span class="o">=</span> <span class="n">a</span> <span class="nc">AND</span> <span class="n">b</span> <span class="nc">AND</span> <span class="n">c</span>
<span class="n">coproduct</span><span class="k">:</span> <span class="kt">XYZ</span> <span class="o">=</span> <span class="n">x</span> <span class="nc">XOR</span> <span class="n">y</span> <span class="nc">XOR</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>записане в Scala</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="c1">// значення</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">A</span>
  <span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">type</span> <span class="kt">C</span> <span class="o">=</span> <span class="nc">Int</span>

  <span class="c1">// продукт</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ABC</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A.</span><span class="k">type</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>

  <span class="c1">// ко-продукт</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">X</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Y</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Z</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">XYZ</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_4_1_1__adt">4.1.1 Рекурсівні ADT</h3>
<div class="paragraph"><p>Коли ADT посилається на себе, ми називаємо це Рекурсивним алгебраїчним типом даних (Recursive Algebraic Data Type).</p></div>
<div class="paragraph"><p><code>scalaz.IList</code>, безпечна альтернатива до <code>stdlib</code> <code>List</code>, є рекурсивною, оскікльи <code>ICons</code> містить посилання на <code>IList.</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">INil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ICons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_2___adt">4.1.2 Функції на ADT</h3>
<div class="paragraph"><p>ADT може містити чисті функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserConfiguration</span><span class="o">(</span><span class="n">accepts</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але ADT, що мають функції, ідуть з деякими особистостями, бо вони не ідеально транслюються на JVM. Наприклад, старий <code>Serializable</code>, <code>hashCode</code>, <code>equals</code> та <code>toString</code> не поводяться так, як дехто може логічно очікувати.</p></div>
<div class="paragraph"><p>Нажаль, <code>Serializable</code> використовується в популярних фреймворках, не зважаючи на значно кращі альтернативи. Загальна пастка є забути, що  <code>Serializable</code> може спробувати селіалізувати ціле замикання функції, що може зламати промисловий сервер. Подібна специфіка стосується старих Java класів, таких як <code>Throwable</code>, що може нести посилання на довільні об'єкти.</p></div>
<div class="paragraph"><p>Ми будемо досліджувати альтернативи до старих методів, коли ми дискутуватимемо бібліотеку <code>Scalaz</code> в наступній главі, ціною втрати взаємодії з деяким старим кодом Java та Scala.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_3_">4.1.3 Вичерпність</h3>
<div class="paragraph"><p>Важливо, що ми використовуємо закоркований абстрактний клас, не просто абстрактний клас, коли визначаємо тип даних. Закоркування класу означає, що всі підтипи мають бути визначені в тому ж файлі, дозволяючи компілятору знати щодо них в вичерпному співпадінні шаблонів, та в макросах, що запобігають шаблонному коду. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Baz</span> <span class="k">extends</span> <span class="nc">Foo</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>
  <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
  <span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">Baz</span>
         <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
                               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це показує розробнику, що вони зламають речі, якщо вони додають новий продукт до коду. Ми використовуємо <code>-Xfatal-warnings</code>, інакше це тільки попередження.</p></div>
<div class="paragraph"><p>Однак компілятор не буде виконувати перевірку вичерпності, якщо клас не закоркований, або якщо стоять захисники, тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="k">if</span> <span class="n">flag</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">thing</span><span class="o">(</span><span class="nc">Baz</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">.</span><span class="nc">MatchError</span><span class="k">:</span> <span class="kt">Baz</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">Baz$</span><span class="o">)</span>
    <span class="kt">at</span> <span class="kt">.thing</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">15</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб залишатись в безпеці не використовуйте захисників на закоркованих типах.</p></div>
<div class="paragraph"><p>Флаг <code>-Xstrict-patmat-analysis</code> був запропонований як покращення мови для виконання додаткових перевірок співпадіння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_4_____">4.1.4 Альтернативні продукти та ко-продукти</h3>
<div class="paragraph"><p>Іншою формою продукта є тапл, що як непомічений фінальний кейс клас.</p></div>
<div class="paragraph"><p><code>(A.type, B, C)</code> еквівалентне до <code>ABC</code> в прикладі вище, але краще використовувати фінальний кейс клас як частини ADT, оскільки брак імен ускладнює справи, і кейс клас має значно кращу продуктивність для примітивних значень.</p></div>
<div class="paragraph"><p>Інша форма ко-продукта утворюється, коли ми вкладаємо типи <code>Either</code>. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nc">Either</span><span class="o">[</span><span class="kt">X.</span><span class="k">type</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">Y.</span><span class="k">type</span>, <span class="kt">Z</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до закоркованого абстрактного класу <code>XYZ</code>. Ясніший синтаксис для визначення вкладених типів <code>Either</code> є створення псевдониму типу, що завершується на двокрапку, дозволяючи інфіксну нотацію з правою асоціацією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">|:</span><span class="o">[</span><span class="kt">L</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">]</span>

  <span class="n">X</span><span class="o">.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Y.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Z</span>
</pre></div></div></div>
<div class="paragraph"><p>Це корисно для створення анонімних ко-продуктів, коли ми не можемо покласти всі реалізації в той самий джерельний файл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Accepted</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">|:</span> <span class="nc">Long</span> <span class="o">|:</span> <span class="nc">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>І ще один альтернативний ко-продукт є створення власного закоркованого абстрактного класу з фінальним кейс класом, що просто огортає бажаний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedLong</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів на ціх формах ко-продуктів може бути тендітним, ось чому були досліджені <em>Union Types</em> в <code>Dotty</code>, компіляторі Scala наступного покоління. Макроси, такі як <code>totalitarian</code> та <code>iotaz</code> існують як альтернативні шляхи кодування анонімних ко-продуктів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_5__">4.1.5 Подача інформації</h3>
<div class="paragraph"><p>Окрім функції контейнера для потрібної бізнес інформації, типи даних можуть використовуватись для кодування обмежень. Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">NonEmptyList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</pre></div></div></div>
<div class="paragraph"><p>ніколи не може бути порожнім. Це робить <code>scalaz.NonEmptyList</code> корисним типом даних, що містить ту саму інформацію, що і <code>IList</code>.</p></div>
<div class="paragraph"><p>Продуктові типи часто містять типи, що значно більш загальні, ніж дозволено. В традиційному OOP це може бути оброблене за допомогою валідації вводу через припущення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// руйнує загальність, не робіть цього!</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього ми можемо використовувати тип даних <code>Either</code> щоб провадити <code>Right[Person]</code> для валідних примірників, та захиститись від просування навалідних примірників. Зауважте, що конструктор приватний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span> <span class="k">private</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Right</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">))</span>
      <span class="k">else</span> <span class="nc">Left</span><span class="o">(</span><span class="s">s&quot;bad input: </span><span class="si">$name</span><span class="s">, </span><span class="si">$age</span><span class="s">&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">welcome</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="s">s&quot;</span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> you look wonderful at </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s">!&quot;</span>

  <span class="k">for</span> <span class="o">{</span>
    <span class="n">person</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">welcome</span><span class="o">(</span><span class="n">person</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_5_1___">4.1.5.1 Очищені типи даних</h3>
<div class="paragraph"><p>Чіткий спосіб обмежити значення загального типу можливо за допомогою бібліотеки <code>refined</code>, провадячи сюїту обмежень до вмісту даних. Щоб встановити <code>refined</code>, додайте наступне до <code>build.sbt</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;eu.timepit&quot;</span> <span class="o">%%</span> <span class="s">&quot;refined-scalaz&quot;</span> <span class="o">%</span> <span class="s">&quot;0.9.2&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>та наступні імпорти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">eu.timepit.refined</span>
  <span class="k">import</span> <span class="nn">refined.api.Refined</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Refined</code> дозволяє визначити <code>Person</code> використовуючи створені на льоту очищені типи, щоб захопити вимоги в точності, записуючи <code>A Refined B</code>.</p></div>
<div class="paragraph"><p>Всі типи з двома параметрами можуть бути записані інфіксно в Scala. Наприклад, <code>Either[String, Int]</code> є те саме, що <code>String Either Int</code>. За домовленостю <code>Refined</code> записується інфіксно, оскільки <code>A Refined B</code> можна прочитати як “<code>A</code>, що відповідає вимогам, визначеним в `B`”.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.numeric.Positive</span>
  <span class="k">import</span> <span class="nn">refined.collection.NonEmpty</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span>
    <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span><span class="o">,</span>
    <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">Positive</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Підлегле значення можна отримати за допомогою <code>.value</code>. Ми можемо конструювати значення від час виконання з використанням <code>.refineV</code>, повертаючи <code>Either</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">refined.refineV</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">refineV</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">](</span><span class="s">&quot;&quot;</span><span class="o">)</span>
  <span class="nc">Left</span><span class="o">(</span><span class="nc">Predicate</span> <span class="n">isEmpty</span><span class="o">()</span> <span class="n">did</span> <span class="n">not</span> <span class="n">fail</span><span class="o">.)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">refineV</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">](</span><span class="s">&quot;Sam&quot;</span><span class="o">)</span>
  <span class="nc">Right</span><span class="o">(</span><span class="nc">Sam</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми додамо наступний імпорт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.auto._</span>
</pre></div></div></div>
<div class="paragraph"><p>ми можемо конструювати валідні значення під час компіляції, та отримати помилку, якщо надамо значення, що не відповідає вимогам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sam</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span> <span class="o">=</span> <span class="s">&quot;Sam&quot;</span>
  <span class="nc">Sam</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
  <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Predicate</span> <span class="kt">isEmpty</span><span class="o">()</span> <span class="kt">did</span> <span class="kt">not</span> <span class="kt">fail.</span>
</pre></div></div></div>
<div class="paragraph"><p>Можливо захопити більш складні вимоги, наприклад, ми можемо використовувати вбудоване правило <code>MaxSize</code> з наступними імпортами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.W</span>
  <span class="k">import</span> <span class="nn">refined.boolean.And</span>
  <span class="k">import</span> <span class="nn">refined.collection.MaxSize</span>
</pre></div></div></div>
<div class="paragraph"><p>захоплюючі вимогу, що <code>String</code> має бути одночасно непорожнім та мати максимальний розмір 10 символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Name</span> <span class="o">=</span> <span class="nc">NonEmpty</span> <span class="nc">And</span> <span class="nc">MaxSize</span><span class="o">[</span><span class="kt">W.`10`.T</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span>
    <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Name</span><span class="o">,</span>
    <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">Positive</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нотація <code>W</code> є скороченим для “witness” (<em>засвідчити</em>). Цей синтаксис буде значно простіший в Scala 2.13, що має підтримку для літеральних типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Name</span> <span class="o">=</span> <span class="nc">NonEmpty</span> <span class="nc">And</span> <span class="nc">MaxSize</span><span class="o">[</span><span class="err">10</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Просто визначити визначення власних вимог, що не охоплені бібліотекою  <code>refined</code>. Наприклад, в <code>drone-dynamaic-agents</code> нам знадобиться спосіб переконатись, що <code>String</code> містить <code>application/x-www-form-urlencoded</code>. Ми можемо створити правило <code>Refined</code>, використовуючи бібліотеку регулярних виразів Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">UrlEncoded</span>
  <span class="k">object</span> <span class="nc">UrlEncoded</span> <span class="o">{</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">Pattern</span> <span class="o">=</span>
      <span class="nc">Pattern</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="s">&quot;\\A(\\p{Alnum}++|[-.*_+=&amp;]++|%\\p{XDigit}{2})*\\z&quot;</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="n">urlValidate</span><span class="k">:</span> <span class="kt">Validate.Plain</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">UrlEncoded</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Validate</span><span class="o">.</span><span class="n">fromPredicate</span><span class="o">(</span>
        <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">matcher</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">find</span><span class="o">(),</span>
        <span class="n">identity</span><span class="o">,</span>
        <span class="k">new</span> <span class="nc">UrlEncoded</span> <span class="o">{}</span>
      <span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_6__">4.1.6 Поділяти просто</h3>
<div class="paragraph"><p>Не провадячи жодної функціональності, ADT можуть мати мінімальний набір залежностей. Це робить простим їх публікацію та поділення з іншими розробниками. Через використання простої мови моделювання даних, стає можливим взаємодія з між-галужевими командами, такими як DBA, розробники UI та бізнес аналітики, використовуючи справжній код замість рукописного документу в якості джерела істини.</p></div>
<div class="paragraph"><p>Більше того, інструментарій може бути написаний більш просто для продукування або споживання схем від інших мов програмування та дротових протоколів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_7__">4.1.7 Підрахунок складності</h3>
<div class="paragraph"><p>Складність типу даних є підрахунок значень, що можуть існувати. Гарний тип даних має найменьшу кількість складності, якій потрібен для утримання інформації, що має передаватись, і не більше.</p></div>
<div class="paragraph"><p>Значення мають вбудовану складність:</p></div>
<div class="paragraph"><p><code>Unit</code> має одне значення (чому він і називається “одиничний”)
<code>Boolean</code> має два значення
<code>Int</code> має 4,294,967,295 значень
<code>String</code> ефективно має безліч значень</p></div>
<div class="paragraph"><p>Щоб знайти складність продкуту ми перемножуємо складність кожної частини.</p></div>
<div class="paragraph"><p>(<code>Boolean</code>, <code>Boolean</code>) має 4 значення (2*2)
(<code>Boolean</code>, <code>Boolean</code>, <code>Boolean</code>) має 8 значень (2*2*2)</p></div>
<div class="paragraph"><p>Щоб знайти складність ко-продукту, ми додаємо складність кожної частини.</p></div>
<div class="paragraph"><p>(<code>Boolean</code> |: <code>Boolean</code>) має 4 значення (2+2)
(<code>Boolean</code> |: <code>Boolean</code> |: <code>Boolean</code>) має 6 значень (2+2+2)</p></div>
<div class="paragraph"><p>Щоб знайти складність ADT з параметром типу, помножте кожну частину на складність параметру типу:</p></div>
<div class="paragraph"><p><code>Option[Boolean]</code> має 3 значення, <code>Some[Boolean]</code> та <code>None</code> (2+1)</p></div>
<div class="paragraph"><p>В FP функції повні та мають повертати значення для кожного вводу, не <code>Exception</code>. Мінімізація складності входів та виходів є кращим способом досягти загальності. Як правило великого пальця, це знак поганої розробки функції, якщо складність поверненного значення функції більша, ніж складність продукту вхідних значень: це джерело ентропії.</p></div>
<div class="paragraph"><p>Складність загальної функції є число можливих функцій, що можуть задовільнити сигнатурі типу: вихід в ступіні вводу.</p></div>
<div class="paragraph"><p><code>Unit =&gt; Boolean</code> має складність 2
<code>Boolean =&gt; Boolean</code> має складність 4
<em>Option[Boolean] &#8658; Option[Boolean]</em> має складність 27
<code>Boolean =&gt; Int</code> має складність квантіліон на секстіліон.
<code>Int =&gt; Boolean</code> має таку складність, що якщо всі реалізації мали б порядковий номер, кожний мав би 4Гб в довжину.</p></div>
<div class="paragraph"><p>В реальності <code>Int =&gt; Boolean</code> буде дечим простим, як <code>isOdd</code>, <code>isEven</code> або розріжений <code>BitSet</code>. Ця функція, коли використовується в ADT, краще може бути замінена на ко-продукт, який маркує обмежену множину функцій, що є релевантними.</p></div>
<div class="paragraph"><p>Коли складність є “безкінечність на вході, безкінечність на виході”, нам треба ввести обмежувальні типи даних та валідацію ближче до точки входу за допомогою <code>Refined</code> з попереднього розділу.</p></div>
<div class="paragraph"><p>Здантість порахувати складність сигнатури типу має одне інше практичне застосування: ми можемо знайти простіші сигнатури типів за допомогою алгебри вищої школи! Щоб перейти від сигнатури типу до її алгебри складності, просто замініть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="n">на</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span> <span class="n">на</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="n">на</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>зробіть деякі перестановки, та конвертуйте назад. Наприклад, скажімо, ми розробили фреймворк що базується на зворотніх викликах, і ми поставили себе в ситуацію, коли ми створили наступну сигнатуру типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">((</span><span class="n">B</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо конвертувати та переставити її так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">b</span><span class="o">))</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">a</span><span class="o">)</span>
  <span class="k">=</span> <span class="n">c</span> <span class="o">^</span> <span class="o">((</span><span class="n">c</span> <span class="o">^</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">a</span><span class="o">))</span>
  <span class="k">=</span> <span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>потім конвертувати назад до типів та отримати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>що значно простіше: ми тільки просимо користувачів нашого фреймфорку провадити <code>Either[A, B] =&gt; C</code>.</p></div>
<div class="paragraph"><p>Той самий хід думок може бути використаний для перевірки, що:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>що також відоме як <em>карування</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_8_____">4.1.8 Обирайте ко-продукти замість продуктів</h3>
<div class="paragraph"><p>Архітепічне моделювання проблем, що постає здебільшо коли існують взаємно виключні параметри конфігурації <code>a</code>, <code>b</code> та <code>c</code>. Продукт <code>(a: Boolean, b: Boolean, c: Boolean)</code> має складність 8, тоді як ко-продукт</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Config</span>
  <span class="k">object</span> <span class="nc">Config</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Config</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nc">Config</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">C</span> <span class="k">extends</span> <span class="nc">Config</span>
  <span class="o">}</span>
<span class="n">має</span> <span class="n">складність</span> <span class="mf">3.</span> <span class="n">Краще</span> <span class="n">моделювати</span> <span class="n">ці</span> <span class="n">параметри</span> <span class="n">конфігурації</span> <span class="n">як</span> <span class="n">ко</span><span class="o">-</span><span class="n">продукт</span><span class="o">,</span> <span class="n">ніж</span> <span class="n">дозволити</span> <span class="n">існування</span> <span class="n">п</span><span class=" -Symbol">&#39;яти</span> <span class="n">невалідних</span> <span class="n">станів</span><span class="o">.</span>

<span class="n">Складність</span> <span class="n">типу</span> <span class="n">даних</span> <span class="n">також</span> <span class="n">має</span> <span class="n">вплив</span> <span class="n">на</span> <span class="n">тестування</span><span class="o">.</span> <span class="n">Практично</span> <span class="n">неможливо</span> <span class="n">тестувати</span> <span class="n">кожний</span> <span class="n">можливий</span> <span class="n">вхід</span> <span class="n">до</span> <span class="n">функції</span><span class="o">,</span> <span class="n">але</span> <span class="n">просто</span> <span class="n">тестувати</span> <span class="n">примірник</span> <span class="n">значень</span> <span class="n">за</span> <span class="n">допомогою</span> <span class="n">фреймворка</span> <span class="n">тестування</span> <span class="n">властивостей</span> <span class="n">`Scalacheck`</span><span class="o">.</span> <span class="n">Якщо</span> <span class="n">випадковий</span> <span class="n">примірник</span> <span class="n">типу</span> <span class="n">даних</span> <span class="n">має</span> <span class="n">низьку</span> <span class="n">вірорідність</span> <span class="n">бути</span> <span class="n">валідним</span><span class="o">,</span> <span class="n">це</span> <span class="n">знак</span><span class="o">,</span> <span class="n">що</span> <span class="n">дані</span> <span class="n">змодельовані</span> <span class="n">некоректно</span><span class="o">.</span>

<span class="mf">4.1</span><span class="o">.</span><span class="mi">9</span> <span class="n">Оптимізації</span>
<span class="o">~~~~~~~~~~~~~~~~~</span>
<span class="n">Велика</span> <span class="n">перевага</span> <span class="n">від</span> <span class="n">використання</span> <span class="n">спрощеної</span> <span class="n">підмножини</span> <span class="n">мови</span> <span class="nc">Scala</span> <span class="n">для</span> <span class="n">представлення</span> <span class="n">типів</span> <span class="n">даних</span> <span class="n">в</span> <span class="n">тому</span><span class="o">,</span> <span class="n">що</span> <span class="n">інструментарій</span> <span class="n">може</span> <span class="n">оптимізувати</span> <span class="n">репрезентацію</span> <span class="n">байткоду</span> <span class="nc">JVM</span><span class="o">.</span>

<span class="n">Наприклад</span><span class="o">,</span> <span class="n">ми</span> <span class="n">можемо</span> <span class="n">запакувати</span> <span class="n">поля</span> <span class="n">`Boolean`</span> <span class="n">та</span> <span class="n">`Option`</span> <span class="n">в</span> <span class="n">`Array[Byte]`</span><span class="o">,</span> <span class="n">кешувати</span> <span class="n">значення</span><span class="o">,</span> <span class="n">запам</span><span class=" -Symbol">&#39;ятати</span> <span class="n">`hashCode`</span><span class="o">,</span> <span class="n">оптимізувати</span> <span class="n">`equals`</span><span class="o">,</span> <span class="n">використовувати</span> <span class="n">твердження</span> <span class="n">`@switch`</span> <span class="n">при</span> <span class="n">порівнянні</span> <span class="n">шаблонів</span><span class="o">,</span> <span class="n">та</span> <span class="n">багато</span> <span class="n">іншого</span><span class="o">.</span>

<span class="n">Ці</span> <span class="n">оптимізації</span> <span class="n">неможливо</span> <span class="n">застосувати</span> <span class="n">для</span> <span class="n">ієрархій</span> <span class="n">класів</span> <span class="nc">OOP</span><span class="o">,</span> <span class="n">що</span> <span class="n">можуть</span> <span class="n">керувати</span> <span class="n">станом</span><span class="o">,</span> <span class="n">закидати</span> <span class="n">виключення</span> <span class="n">або</span> <span class="n">провадити</span> <span class="n">adhoc</span> <span class="n">реалізції</span> <span class="n">методів</span><span class="o">.</span>

<span class="mf">4.2</span> <span class="n">Функціональність</span>
</pre></div></div></div>
<div class="paragraph"><p>Чисті функції типово визначаються як методи на об'єкті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">package</span> <span class="nn">object</span> <span class="n">math</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак буде незручним використовувати методи об'єкта, оскільки це читається зсередини-назовні, не зліва направо. На додаток функція на об'єкті краде простір імен. Якщо ми визначимо <code>sin(t: T)</code> будь-де ще, ми отримаємо помилку невизначенності посилання. Це та сама проблема, що і статичні методи в Java vs методів классу.</p></div>
<div class="paragraph"><p>Різновид розробників, що складють методи в трейт, та вимагають від користувачів міксувати їх за допомогою шаблону кекса, прямують прямо до пекла. Це дає витік внутрішніх деталей реалізації до публічних API,заплутує байткод, робить двоїчну сумісність в основному неможливою, та засмучує  автодоповнювач IDE.</p></div>
<div class="paragraph"><p>З можливістю мови щодо неявних класів (також відомою як методологія або синтаксис розширення), та невеликим шаблоном ми можемо отримати знайомий стиль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
         <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mf">1.0</span><span class="o">).</span><span class="n">sin</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.8414709848078965</span>
</pre></div></div></div>
<div class="paragraph"><p>Часто краще просто пропустити визначення об'єкта, та перейти прямо до неявного класу, утримуючи шаблонний код на мінімумі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>неявний клас є синтаксичним цукром до неявного перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">DoubleOps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Що, нажаль, має вартість під час виконання: кожний раз, коли викликається метод розширення, посередник <code>DoubleOps</code> буде конструюватись та потів відкидатись геть. Це може докластись до тиску на GC в гарячих точках.</p></div>
<div class="paragraph"><p>Існує трохи більш балаклива форма неявних класів, що уникає розміщення, і, таким чином, більш бажана:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_2_1__">4.2.1 Поліморфні функції</h3>
<div class="paragraph"><p>Більш загальний різновид функцій є поліморфні функції, що живуть в _типокласах_. Типоклас є трейт, що:</p></div>
<div class="ulist"><ul>
<li>
<p>
не збурігає стан
</p>
</li>
<li>
<p>
має параметр типу
</p>
</li>
<li>
<p>
має щонайменьше один абстрактний метод (примітивні комбінатори)
</p>
</li>
<li>
<p>
може містити узагальнені методи (похідні комбінатори)
</p>
</li>
<li>
<p>
може розширювати інший типоклас
</p>
</li>
</ul></div>
<div class="paragraph"><p>Є тільки одна реалізація типокласу для любого даного параметру типу, властивість, відома під назвою когерентність типокласу. Типокласи  виглядають напрочуд подібно до алгебраїчних інтерфейсів, але алгебри не обов'язково мають бути когерентними.</p></div>
<div class="paragraph"><p>Когенентність типокласів в основному відноситься до узгодженості, і узгодженість дає нам впевненість для використання неявних параметрів. Може бути складним продумувати код, що виконується по різному на неявних імпортах в полі зору. Когерентність типокласів насправді каже, що імпорти не повинні впливати на поведінку коду.</p></div>
<div class="paragraph"><p>Додатково, когерентність типокласів дозволяє нам глобально кешувати неявні під час виконання, та зберігати розміщення пам'яті, отримуючи покращення продуктивності від зменшеного тиску на збирача сміття.</p></div>
<div class="paragraph"><p>Типокласи використовуються в Scala <code>stdlib</code>. Ми дослідимо спрощену версію <code>scala.math.Numeric</code> для демонстрації принципу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

    <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="o">}</span>

  <span class="k">trait</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">T</span>

    <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">zero</span><span class="o">))</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можмо бачити всі ключові властивості типокласу в дії:</p></div>
<div class="ulist"><ul>
<li>
<p>
немає стану
</p>
</li>
<li>
<p>
<code>Ordering</code> та <code>Numeric</code> мають параметр типу <code>T</code>
</p>
</li>
<li>
<p>
<code>Ordering</code> має абстрактне <code>compare</code>, та <code>Numeric</code> має абстрактні <code>plus</code>, <code>times</code>, <code>negate</code> та <code>zero</code>
</p>
</li>
<li>
<p>
<code>Ordering</code> визначає узагальнені <code>lt</code> та <code>gt</code> базовані на <code>compare</code>, <code>Numeric</code> визначає <code>abs</code> в термінах <code>lt</code>, <code>negate</code> та <code>zero</code>.
</p>
</li>
<li>
<p>
<code>Numeric</code> розширює <code>Ordering</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Тепер ми можемо писати функції для типів, що “має” типоклас <code>Numeric</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">N</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">N._</span>
    <span class="n">times</span><span class="o">(</span><span class="n">negate</span><span class="o">(</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)),</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми більше не залежимо від ієрархії OOP від наших вхідних типів, тобто, ми не вимагаємо, щоб наш вхід “був” <code>Numeric</code>, що є критично важливим, якщо ми бажаємо підтримати клас третіх сторін, який ми не можемо перевизначити.</p></div>
<div class="paragraph"><p>Інша перевага типокласів в тому, що асоціація функціональності до даних відбувається під час компіляції, на відміну від рантайм динамічної диспечерізації OOP.</p></div>
<div class="paragraph"><p>Наприклад, хоча клас <code>List</code> може мати лише одну реалізацію метода, метод типокласу дозволяє нам мати різні реалізації в залежності від вмісту <code>List</code>, і, таким чином, перекласти навантаження на час компіляції, замість залишати його на рантайм.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_2_">4.2.2 Синтаксис</h3>
<div class="paragraph"><p>Синтаксис для написання <code>signOfTheTimes</code> є заплутаним, існують деякі речі, які ми можемо зробити, щоб розчистити його.</p></div>
<div class="paragraph"><p>Нижні користувачі будуть краще бачити наш метод, як використовуючий межі контексту, оскільки сигнатура ясно читається як “приймає <code>T</code>, що має `Numeric`”</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>але тепер ми маємо будь-де використовувати <code>implicitly[Numeric[T]]</code>. Через визначення шаблонного коду на компанйоні типокласу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">Numeric</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">numeric</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">numeric</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>ми можемо отримати неявне з меньшим шумом</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">import</span> <span class="nn">N._</span>
    <span class="n">times</span><span class="o">(</span><span class="n">negate</span><span class="o">(</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)),</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але це все ще гірше для нас, як для реалізаторів. Ми маємо синтаксичну проблему статичних методів зсередини-назовні vs методів класів. Ми маємо справу з цім через введення <code>ops</code> на компанйоні типокласу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">Numeric</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">numeric</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">numeric</span>

    <span class="k">object</span> <span class="nc">ops</span> <span class="o">{</span>
      <span class="k">implicit</span> <span class="k">class</span> <span class="nc">NumericOps</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">N</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
        <span class="k">def</span> <span class="o">+(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="o">*(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">times</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="n">unary_-:</span> <span class="n">T</span> <span class="k">=</span> <span class="n">N</span><span class="o">.</span><span class="n">negate</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
        <span class="k">def</span> <span class="n">abs</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

        <span class="c1">// дублікація з Ordering.ops</span>
        <span class="k">def</span> <span class="o">&lt;(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">lt</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="o">&gt;(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, <code>-x</code> розширюється до <code>x.unary_-</code> через компіляторний синтаксичний синтаксис, через що ми визначаємо <code>unary_-</code> як метод розширення. Тепер ми можемо записати значно ясніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">Numeric.ops._</span>
  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">-(</span><span class="n">t</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span> <span class="o">*</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарна новина в тому, що нам ніколи не треба писати цей код, оскільки <code>Simulacrum</code> провадить макро анотацію <code>@typeclass</code>, що автоматично генерує <code>apply</code> та <code>ops</code>. Він навіть дозволяє нам визначити альтернативні імена (звичайно символічні) для загальних методів. Загалом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">simulacrum._</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;unary_-&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">zero</span><span class="o">))</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="o">}</span>

  <span class="k">import</span> <span class="nn">Numeric.ops._</span>
  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">-(</span><span class="n">t</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span> <span class="o">*</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер коли є власний символічний <code>@op</code>, він має вимовлятись як ім'я метода. Тобто, <code>&lt;</code> вимовляється “меньше ніж”, не “ліва кутова дужка”.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_3_">4.2.3 Примірники</h3>
<div class="paragraph"><p>Примірники <code>Numeric</code> (що також є примірниками <code>Ordering</code>) визначаються як <code>implicit val</code>, що розширює типоклас, та може провадити оптимізовану реалізації для узагальнених методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">NumericDouble</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Double</span><span class="o">.</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

    <span class="c1">// оптимізовано</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча ми тут використовуємо <code>+</code>, <code>*</code>, <code>unary_-</code>, <code>&lt;</code> та <code>&gt;</code>, що є <code>ops</code> (і може бути безкінечний цикл!), ці методи вже існують на <code>Double</code>. Методи класів завжди використовуються з перевагою над методами розширення. Зрозуміло, що компілятор Scala виконує особливу обробку примітивів, та конвертує ці методи до сирих байткод інструкцій <code>dadd</code>, <code>dmul</code>, <code>dcmpl</code> та <code>dcmpg</code>, відповідно.</p></div>
<div class="paragraph"><p>Ми також можемо реалізувати <code>Numeric</code> для Java класу <code>BigDecimal</code> (уникайте <code>scala.BigDecimal</code>, він фундаментально хибний)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">java.math.</span><span class="o">{</span> <span class="nc">BigDecimal</span> <span class="k">=&gt;</span> <span class="nc">BD</span> <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">NumericBD</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">BD</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">BD</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">negate</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="nc">BD</span><span class="o">.</span><span class="nc">ZERO</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити нашу власну структуру даних для комплексних чисел:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та наслідувати <code>Numeric[Complex[T]]</code>, якщо існує <code>Numeric[T]</code>. Оскільки ці примірники залежать від параметру типа, це <code>def</code>, не <code>val</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericComplex</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">]</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">type</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span>
        <span class="nc">Complex</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="o">(-</span><span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">),</span> <span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(-</span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(</span><span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">zero</span><span class="o">,</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">real</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">))</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">real</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">real</span>
        <span class="k">else</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">i</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Спостережливий читач може зауважити, що <code>abs</code> взагалі не те, що може очікувати математик. Коректне повернуте значення для <code>abs</code> має бути <code>T</code>, не <code>Complex[T]</code>.</p></div>
<div class="paragraph"><p><code>scala.math.Numeric</code> намагається робити дуже багато, і не узагальнує за межами дійсних чисел. Це гарний урок того, що меньші, гарно визначені типокласи часто кращі, ніж монолітні колекції дуже специфічних можливостей.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_4__">4.2.4 Розрішення неявних</h3>
<div class="paragraph"><p>Ми гарно обсудили неявні: цей розділ призначений для прояснення, що таке неявні, та як вони роблять.</p></div>
<div class="paragraph"><p>Коли метод запитує, щоб в полі зору викликаючого знаходився унікальний примірник певного типу, неявні параметри є особливим синтаксисом для примірників типокласів. Неявні параметри є ясним шляхом конфігурації потоку через застосування.</p></div>
<div class="paragraph"><p>В цьому прикладі <code>foo</code> потребує, щоб для <code>A</code> були доступні примірники типокласів <code>Numeric</code> та <code>Typeable</code>, так само, як неявний об'єкт <code>Handler</code>, що приймає два параметри типів</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Numeric:</span> <span class="kt">Typeable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Handler</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Неявне перетворення відбувається коли існує <code>implicit def</code>. Один такий випадок неявного перетворення є використання методології розширення. Коли компілятор розрішує виклик метода, він спочатку перевіряє, чи метод існує для типу, потім для предків (Java-подібні правила). Якщо він не зможе знайти співпадіння, він буде шукати неявне поле зору для перетворень до інших типів, потім шукає серед методів на ціх типах.</p></div>
<div class="paragraph"><p>Інше використання для неявних перетворень є похідні типокласи. В попередньому розділі ми написали неявний <code>def</code>, що походить від <code>Numeric[Complex[T]]</code>, якщо <code>Numeric[T]</code> існує в неявному полі зору. Можливо зціпити разом декілька <code>implicit def</code> (включаючи рекурсію), що є базисом типованого програмування, дозволяючи виконання обчислень під час компіляціїї, замість рантайму.</p></div>
<div class="paragraph"><p>Клей, що зліплює неявні параметри (отримувачі) з неявними перетвореннями (провайдерами) є розрішення неявних.</p></div>
<div class="paragraph"><p>Зпочатку шукається звичане поле зору змінної, по порядку:</p></div>
<div class="ulist"><ul>
<li>
<p>
локальне поле зору, включаючи локальні імпорти (тобто блок або метод)
</p>
</li>
<li>
<p>
зовнішнє поле зору, включаючи імпорти в цій області (тобто члени в класі)
</p>
</li>
<li>
<p>
предки (тобто члени в суер класі)
</p>
</li>
<li>
<p>
поточний об'єкт пакаунку
</p>
</li>
<li>
<p>
об'єкти батьківських пакунків (коли використовуються вкладені пакунки)
</p>
</li>
<li>
<p>
імпорти файлу
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо пошук співпадіння схибить, шукається особливе поле зору, що виглядає неявні примірники в компанйоні типу, його об'єкті пакунку, зовнішні об'єкти (якщо вкладені), та потім повторюється для предків. Це виконується в тому ж порядку для:</p></div>
<div class="ulist"><ul>
<li>
<p>
даного типу параметра
</p>
</li>
<li>
<p>
очікуваного типу параметра
</p>
</li>
<li>
<p>
параметру типу (якщо такий існує)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо знайдено два співпадаючих неявних в тій самій фазі розрішення неявного, закидається помилка неявного.</p></div>
<div class="paragraph"><p>Неявні часто визначаються на трейтах, що потім розширюються об'єктами. Це робиться для проби та контролю приоритетів неявного відносно іншого, більш специфічного, щоб уникнути невизначені неявні.</p></div>
<div class="paragraph"><p>Специфікація Scala Language Specification досить невизначена щодо крайніх випадків, та реалізація компілятора є стандартом де факто. Існують деякі правила великого пальця, що ми будемо використовувати в цій книзі, тобто обирати <code>implicit val</code> замість <code>implicit object</code>, не зважаючи на спокусу меньшого друку. Є особливість розрішення неявних, що <code>implicit object</code> на об'єкті компанйоні не трактується так само, що і <code>implicit val</code>.</p></div>
<div class="paragraph"><p>Розрішення неявних не праціє, коли є ієрархія типокласів, як <code>Ordering</code> та <code>Numeric</code>. Якщо ми пишемо функцію, що приймає неявне <code>Ordering</code>, і ми викликаємо її для примітивного типа, що має примірник <code>Numeric</code>, визначене на компанйоні <code>Numeric</code>, компілятор не зможе знайти його.</p></div>
<div class="paragraph"><p>Розрішення неявних частково є процес пан-або-пропав, якщо використовуються псевдоними типів, де форма неявних параметрів змінюється. Наприклад, приклад неявного параметра з використанням псевдонима, як <code>type Values[A] = List[Option[A]]</code>, можливо схибить знайти неявні, визначені як сирі <code>List[Option[A]]</code>, оскільки форма змінюється з речі речей типу <code>A</code> на річ типу <code>A</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_3__oauth2">4.3 Моделювання OAuth2</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ми завершемо цю главу практичним прикладом моделювання даних та походження типокласів, в комбінації з розробкою алгебри / модуля з попередньої глави.</p></div>
<div class="paragraph"><p>В нашому застосуванні дрон-динамічний-агент, ви маєте комунікувати з Drone та Google Cloud, використовуючи JSON над REST. Обоє сервіси використовують OAuth2 для аутентифікацією. Існує багато шляхів інтерпретувати OAuth2, але ми будемо фокусуватись на версії, що робить для Google Cloud (версія для Drone навіть простіша).</p></div>
<div class="sect2">
<h3 id="_4_3_1_">4.3.1 Опис</h3>
<div class="paragraph"><p>Кожне застосування Google Cloud потребує мати OAuth 2.0 Client Key, встановлений за адресою:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="__client_id__client_secret">Отримання Client ID та Client secret.</h3>
<div class="paragraph"><p>Після цього застосування може отримати одноразовий код, через виконання користувачем Authorization Request в їх браузері (так, насправді, в їх браузері). Нам треба відкрити цю сторінку в браузері:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&amp;\
    prompt=consent&amp;\
    response_type=code&amp;\
    scope={SCOPE}&amp;\
    access_type=offline&amp;\
    client_id={CLIENT_ID}</code></pre>
</div></div>
<div class="paragraph"><p>Код доставляється до <code>{CALLBACK_URI}</code> в вигляді запиту <code>GET</code>. Якщо захопити його в нашому застосуванні, нам треба мати веб сервер, що слухатиме на <code>localhost</code>.</p></div>
<div class="paragraph"><p>Коли ми маємо код, ми можемо виконати Access Token Request:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&amp;\
    redirect_uri={CALLBACK_URI}&amp;\
    client_id={CLIENT_ID}&amp;\
    client_secret={CLIENT_SECRET}&amp;\
    scope={SCOPE}&amp;\
    grant_type=authorization_code</code></pre>
</div></div>
<div class="paragraph"><p>що дає відповідь з корисним навантаженням JSON</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }</code></pre>
</div></div>
<div class="paragraph"><p>Токени <code>Bearer</code> (на пред'явника) прострочений після години, та може бути оновлений через надсилання HTTP запиту з любим валідним токеном оновлення:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&amp;
    grant_type=refresh_token&amp;
    refresh_token={REFRESH_TOKEN}&amp;
    client_id={CLIENT_ID}</code></pre>
</div></div>
<div class="paragraph"><p>з відповіддю</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }</code></pre>
</div></div>
<div class="paragraph"><p>Всі запити користувацького простору до сервера мають включати заголовок</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  Authorization: Bearer BEARER_TOKEN</code></pre>
</div></div>
<div class="paragraph"><p>після підставки справжнього BEARER_TOKEN.</p></div>
<div class="paragraph"><p>Google прострочує всі, крім останніх 50 токенів на пред'явника, так що час прострочення є тільки приблизним. Оновлені токени зберігаються між сессіями, та можуть бути прострочені користувачем вручну. Таким чином ми можемо одноразове налаштування застосування для отримання оновлень токенів, та потім включати токен оновлення як конфігурацію для встановлення користувацького сервера.</p></div>
<div class="paragraph"><p>Drone не реалізує ендпоінт <code>/auth</code>, або <code>refresh</code>, та просто провадить <code>BEARER_TOKEN</code> через їх користувацькій інтерфейс.</p></div>
</div>
<div class="sect2">
<h3 id="_4_3_2_">4.3.2 Дані</h3>
<div class="paragraph"><p>Перший крок є моделювання даних, потрібних для OAuth2. Ми створимо  ADT з полями, що мають точно ті самі назви, які потрібні для OAuth2 сервера. Ми будемо використовувати <code>String</code> та <code>Long</code> для краткості, але ми можемо використовувати очищені типи, якщо вони підпадають під нашу бізнес модель.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.api.Refined</span>
  <span class="k">import</span> <span class="nn">refined.string.Url</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AuthRequest</span><span class="o">(</span>
    <span class="n">redirect_uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
    <span class="n">scope</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">client_id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">prompt</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;consent&quot;</span><span class="o">,</span>
    <span class="n">response_type</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;code&quot;</span><span class="o">,</span>
    <span class="n">access_type</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;offline&quot;</span>
  <span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AccessRequest</span><span class="o">(</span>
    <span class="n">code</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">redirect_uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
    <span class="n">client_id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">client_secret</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">scope</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="o">,</span>
    <span class="n">grant_type</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;authorization_code&quot;</span>
  <span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AccessResponse</span><span class="o">(</span>
    <span class="n">access_token</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">token_type</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">expires_in</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span>
    <span class="n">refresh_token</span><span class="k">:</span> <span class="kt">String</span>
  <span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">RefreshRequest</span><span class="o">(</span>
    <span class="n">client_secret</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">refresh_token</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">client_id</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">grant_type</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">&quot;refresh_token&quot;</span>
  <span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">RefreshResponse</span><span class="o">(</span>
    <span class="n">access_token</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">token_type</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">expires_in</span><span class="k">:</span> <span class="kt">Long</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Уникайте використання <code>java.net.URL</code> за любу ціну: він використовує DNS для розрішення частини <code>hostname</code> для виконання <code>toString</code>, <code>equals</code> або <code>hashCode</code>.</p></div>
<div class="paragraph"><p>Окрім того, що це безумство, і дуже-дуже повільно, ці методи можуть закидати I/O виключення (вони не чисті), та можуть змінюватись, в залежності від мережевої конфігурації (недетерміновано).</p></div>
<div class="paragraph"><p>Покращений тип <code>String Refined Url</code> дозволяє нам виконувати перевірки рівності, базуючись на <code>String</code>, та ми можемо безпечно сконструювати URL, тільки якщо нам треба старий API.</p></div>
<div class="paragraph"><p>Кажучи це, в високо продуктивному коді ми можемо обрати повністю виключити <code>java.net.URL</code>, та використовувати URL парсер третьої сторони, такий як <code>jurl</code>, оскільки навіть безпечні частини <code>java.net.*</code> вкрай повільні при маштабуванні.</p></div>
</div>
<div class="sect2">
<h3 id="_4_3_3_">4.3.3 Функціональність</h3>
<div class="paragraph"><p>Нам треба маршалити класи даних, що ми визначили в попередньому розділі в JSON, URL та POST-кодовані форми. Оскільки це потребує поліморфізму, вам будуть потрібні типокласи.</p></div>
<div class="paragraph"><p><code>jsonformat</code> є простою JSON бібліотекою, яку більш детально ми вивчимо в наступній главі, бо вона була написано на принципах FP, та простота читання в якості головної цілі розробки. Вона складається з JSON AST та типокласів кодування / декодування:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">package</span> <span class="nn">jsonformat</span>

  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">JsNull</span>                                    <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsObject</span><span class="o">(</span><span class="n">fields</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">JsValue</span><span class="o">)])</span> <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsArray</span><span class="o">(</span><span class="n">elements</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">JsValue</span><span class="o">])</span>          <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span>                  <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>                    <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsDouble</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span>                    <span class="k">extends</span> <span class="nc">JsValue</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">JsInteger</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span>                     <span class="k">extends</span> <span class="nc">JsValue</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">JsEncoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">toJson</span><span class="o">(</span><span class="n">obj</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">JsValue</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">JsDecoder</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">fromJson</span><span class="o">(</span><span class="n">json</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">A</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p><code>\/</code> є Scalaz <code>Either</code> та має <code>.flatMap</code>. Ми можете використовувати її в <code>for</code> розширеннях, тоді як <code>stdlib</code> <code>Either</code> не підтримує <code>.flatMap</code> до Scala 2.12. Воно читається як діз'юкція, або злий заєць.</p></div>
<div class="paragraph"><p><code>scala.Either</code> було додано до стандартної бібліотеки Scala  створювачем Scalaz, Tony Morris, в 2007-му році. <code>\/</code> було створено, коли до <code>Either</code> були додані небезпечні методи.</p></div>
<div class="paragraph"><p>Нам знадобляться примірники <code>JsDecoder[AccessResponse]</code> та <code>JsDecoder[RefreshResponse]</code>. Ми можемо зробити це через використання допоміжної функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">JsValueOps</span><span class="o">(</span><span class="n">j</span><span class="k">:</span> <span class="kt">JsValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">getAs</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">JsDecoder</span><span class="o">](</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">\/</span> <span class="kt">A</span> <span class="o">=</span> <span class="o">...</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми покладемо примірники до компанйонів наших типів даних, так що вони завжди будуть в неявному полі зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">jsonformat._</span><span class="o">,</span> <span class="nc">JsDecoder</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="k">_</span>

  <span class="k">object</span> <span class="nc">AccessResponse</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">json</span><span class="k">:</span> <span class="kt">JsDecoder</span><span class="o">[</span><span class="kt">AccessResponse</span><span class="o">]</span> <span class="k">=</span> <span class="n">j</span> <span class="k">=&gt;</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">acc</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;access_token&quot;</span><span class="o">)</span>
        <span class="n">tpe</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;token_type&quot;</span><span class="o">)</span>
        <span class="n">exp</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">Long</span><span class="o">](</span><span class="s">&quot;expires_in&quot;</span><span class="o">)</span>
        <span class="n">ref</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;refresh_token&quot;</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="nc">AccessResponse</span><span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="n">exp</span><span class="o">,</span> <span class="n">ref</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">object</span> <span class="nc">RefreshResponse</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">json</span><span class="k">:</span> <span class="kt">JsDecoder</span><span class="o">[</span><span class="kt">RefreshResponse</span><span class="o">]</span> <span class="k">=</span> <span class="n">j</span> <span class="k">=&gt;</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">acc</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;access_token&quot;</span><span class="o">)</span>
        <span class="n">tpe</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="s">&quot;token_type&quot;</span><span class="o">)</span>
        <span class="n">exp</span> <span class="k">&lt;-</span> <span class="n">j</span><span class="o">.</span><span class="n">getAs</span><span class="o">[</span><span class="kt">Long</span><span class="o">](</span><span class="s">&quot;expires_in&quot;</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="nc">RefreshResponse</span><span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">tpe</span><span class="o">,</span> <span class="n">exp</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми можемо розбирати рядки в <code>AccessResponse</code> або <code>RefreshResponse</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">jsonformat._</span><span class="o">,</span> <span class="nc">JsDecoder</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="k">_</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">json</span> <span class="k">=</span> <span class="nc">JsParser</span><span class="o">(</span><span class="s">&quot;&quot;&quot;</span>
<span class="s">                       {</span>
<span class="s">                         &quot;access_token&quot;: &quot;BEARER_TOKEN&quot;,</span>
<span class="s">                         &quot;token_type&quot;: &quot;Bearer&quot;,</span>
<span class="s">                         &quot;expires_in&quot;: 3600,</span>
<span class="s">                         &quot;refresh_token&quot;: &quot;REFRESH_TOKEN&quot;</span>
<span class="s">                       }</span>
<span class="s">                       &quot;&quot;&quot;</span><span class="o">)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">json</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">as</span><span class="o">[</span><span class="kt">AccessResponse</span><span class="o">])</span>
  <span class="nc">AccessResponse</span><span class="o">(</span><span class="nc">BEARER_TOKEN</span><span class="o">,</span><span class="nc">Bearer</span><span class="o">,</span><span class="mi">3600</span><span class="o">,</span><span class="nc">REFRESH_TOKEN</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам треба написати наші власні типокласи для кодувань <code>URL</code> та <code>POST</code>. Наступне є прийнятним варіантом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="c1">// пари запиту URL key=value в закодованій формі.</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UrlQuery</span><span class="o">(</span><span class="n">params</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)])</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">UrlQueryWriter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">toUrlQuery</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">UrlQuery</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">UrlEncodedWriter</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">toUrlEncoded</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">UrlEncoded</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Нам треба запровадити примірники типокласів для базових типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">java.net.URLEncoder</span>

  <span class="k">object</span> <span class="nc">UrlEncodedWriter</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">encoded</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">UrlEncoded</span><span class="o">]</span> <span class="k">=</span> <span class="n">identity</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">string</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">Refined</span><span class="o">.</span><span class="n">unsafeApply</span><span class="o">(</span><span class="nc">URLEncoder</span><span class="o">.</span><span class="n">encode</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="s">&quot;UTF-8&quot;</span><span class="o">)))</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">url</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">long</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">Long</span><span class="o">]</span> <span class="k">=</span>
      <span class="o">(</span><span class="n">s</span> <span class="k">=&gt;</span> <span class="nc">Refined</span><span class="o">.</span><span class="n">unsafeApply</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="n">ilist</span><span class="o">[</span><span class="kt">K:</span> <span class="kt">UrlEncodedWriter</span>, <span class="kt">V:</span> <span class="kt">UrlEncodedWriter</span><span class="o">]</span>
      <span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">IList</span><span class="o">[(</span><span class="kt">K</span>, <span class="kt">V</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">raw</span> <span class="k">=</span> <span class="n">m</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span>
        <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">k</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="s">&quot;=&quot;</span> <span class="o">+</span> <span class="n">v</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">.</span><span class="n">value</span>
      <span class="o">}.</span><span class="n">intercalate</span><span class="o">(</span><span class="s">&quot;&amp;&quot;</span><span class="o">)</span>
      <span class="nc">Refined</span><span class="o">.</span><span class="n">unsafeApply</span><span class="o">(</span><span class="n">raw</span><span class="o">)</span> <span class="c1">// by deduction</span>
    <span class="o">}</span>

  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми використали <code>Refined.unsafeApply</code> коли ми можемо логічно вивести, що вміст рядка вже закодований як <code>url</code> кодування, пропускаючи любі подальші перевірки.</p></div>
<div class="paragraph"><p><code>ilist</code> є приклад простого походження типокласів, здебільшого як ми продукували <code>Numeric[Complex]</code> від підлеглої числової репрезентації. Метод <code>.intercalate</code> подібний до <code>.mkString</code>, але більше загальний.</p></div>
<div class="paragraph"><p><code>UrlEncodedWriter</code> використовує можливість мови Scala - Single Abstract Method (SAM типи). Повна форма вище наступна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">string</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">toUrlEncoded</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли компілятор Scala очікує клас (що має єдиний абстрактний метод), але отримує лямбду, він заповнює шаблонний код автоматично.</p></div>
<div class="paragraph"><p>До SAM типів загальним шаблоном було визначати метод з назвою <code>instance</code> на компанйоні типокласу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">instance</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">UrlEncodedWriter</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">toUrlEncoded</span><span class="o">(</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">f</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>що дозволяє робити</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">string</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="n">instance</span> <span class="o">{</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей шаблон все ще використовується в коді, що має підтримувати старіші версії Scala, або для примірників типокласів, що мають провадити більше ніж один метод.</p></div>
<div class="paragraph"><p>Зауважте, що існує багато помилок коло SAM типів, через що вони не взаємодіють з усіма можливістями мови. Підкатіться до не-SAM варіанту, якщо трапляються дивні падіння компілятора.</p></div>
<div class="paragraph"><p>В окремій главі Походження типокласів ми будемо обчислювати примірники <code>UrlQueryWriter</code> автоматично, так само, як очищати те, що вже написане, але натепер ми будемо писати шаблонний код для типів, які ми бажаємо перетворити:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">UrlEncodedWriter.ops._</span>
  <span class="k">object</span> <span class="nc">AuthRequest</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">query</span><span class="k">:</span> <span class="kt">UrlQueryWriter</span><span class="o">[</span><span class="kt">AuthRequest</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
      <span class="nc">UrlQuery</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span>
        <span class="o">(</span><span class="s">&quot;redirect_uri&quot;</span>  <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">redirect_uri</span><span class="o">.</span><span class="n">value</span><span class="o">),</span>
        <span class="o">(</span><span class="s">&quot;scope&quot;</span>         <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">scope</span><span class="o">),</span>
        <span class="o">(</span><span class="s">&quot;client_id&quot;</span>     <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">client_id</span><span class="o">),</span>
        <span class="o">(</span><span class="s">&quot;prompt&quot;</span>        <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">prompt</span><span class="o">),</span>
        <span class="o">(</span><span class="s">&quot;response_type&quot;</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">response_type</span><span class="o">),</span>
        <span class="o">(</span><span class="s">&quot;access_type&quot;</span>   <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">access_type</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">object</span> <span class="nc">AccessRequest</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">encoded</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">AccessRequest</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">a</span> <span class="k">=&gt;</span>
      <span class="nc">IList</span><span class="o">(</span>
        <span class="s">&quot;code&quot;</span>          <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;redirect_uri&quot;</span>  <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">redirect_uri</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;client_id&quot;</span>     <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">client_id</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;client_secret&quot;</span> <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">client_secret</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;scope&quot;</span>         <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">scope</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;grant_type&quot;</span>    <span class="o">-&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">grant_type</span><span class="o">.</span><span class="n">toUrlEncoded</span>
      <span class="o">).</span><span class="n">toUrlEncoded</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">object</span> <span class="nc">RefreshRequest</span> <span class="o">{</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">encoded</span><span class="k">:</span> <span class="kt">UrlEncodedWriter</span><span class="o">[</span><span class="kt">RefreshRequest</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span> <span class="n">r</span> <span class="k">=&gt;</span>
      <span class="nc">IList</span><span class="o">(</span>
        <span class="s">&quot;client_secret&quot;</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">client_secret</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;refresh_token&quot;</span> <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">refresh_token</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;client_id&quot;</span>     <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">client_id</span><span class="o">.</span><span class="n">toUrlEncoded</span><span class="o">,</span>
        <span class="s">&quot;grant_type&quot;</span>    <span class="o">-&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">grant_type</span><span class="o">.</span><span class="n">toUrlEncoded</span>
      <span class="o">).</span><span class="n">toUrlEncoded</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_3_4_">4.3.4 Модуль</h3>
<div class="paragraph"><p>Це складає моделювання даних та функціональності, потрібною для реалізації OAuth2. Згадайте з попередньої глави, що ми визначили компоненти, що треба для взаємодії зі світом як алгебри, та ми визначаємо бізнес логіку в модулі, так що вона може бути докладно протестована.</p></div>
<div class="paragraph"><p>Ми визначаємо наші залежні алгебри, та ми використовуємо обмеження контексту, щоб показати, що наші відповіді повинні мати <code>JsDecoder</code>, та вміст нашого <code>POST</code> повинно мати <code>UrlEncodedWriter</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">JsonClient</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">get</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">JsDecoder</span><span class="o">](</span>
      <span class="n">uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
      <span class="n">headers</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span>
    <span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>

    <span class="k">def</span> <span class="n">post</span><span class="o">[</span><span class="kt">P:</span> <span class="kt">UrlEncodedWriter</span>, <span class="kt">A:</span> <span class="kt">JsDecoder</span><span class="o">](</span>
      <span class="n">uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
      <span class="n">payload</span><span class="k">:</span> <span class="kt">P</span><span class="o">,</span>
      <span class="n">headers</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="kt">=</span> <span class="kt">IList.empty</span>
    <span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що ми визначаємо тільки щасливий шлях в JsonClient API. Ми будемо розглядати обробку помилок в наступній главі.</p></div>
<div class="paragraph"><p>Отримання <code>CodeToken</code> від сервера Google OAuth2 включає запуск HTTP сервера на локальній машині, та отримання його номеру порта. Користувач відкриває веб сторінку в своєму браузері, що дозволяє війти з Google паролем та авторизувати застосування, з редиректом знову на локальну машину. Код захоплюється, інформуючи користува щодо подальших кроків, та закриття HTTP сервера. Ми можемо змоделювати це трьома методами в алгебрі <code>UserInteraction</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">CodeToken</span><span class="o">(</span><span class="n">token</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">redirect_uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">)</span>

  <span class="k">trait</span> <span class="nc">UserInteraction</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">start</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">open</span><span class="o">(</span><span class="n">uri</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Unit</span><span class="o">]</span>
    <span class="k">def</span> <span class="n">stop</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">CodeToken</span><span class="o">]</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це вигладає майже просто, якщо дивитись на це таким чином.</p></div>
<div class="paragraph"><p>Нам також потрібна алгебра для абстрагування над локальним системним часом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">LocalClock</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">now</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">Epoch</span><span class="o">]</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Також введемо типи даних, що ми будемо використовувати в логиці оновлення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ServerConfig</span><span class="o">(</span>
    <span class="n">auth</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
    <span class="n">access</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
    <span class="n">refresh</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Url</span><span class="o">,</span>
    <span class="n">scope</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">clientId</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">clientSecret</span><span class="k">:</span> <span class="kt">String</span>
  <span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">RefreshToken</span><span class="o">(</span><span class="n">token</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">BearerToken</span><span class="o">(</span><span class="n">token</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">expires</span><span class="k">:</span> <span class="kt">Epoch</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер ми можемо написати модуль клієнта OAuth2:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">http.encoding.UrlQueryWriter.ops._</span>

  <span class="k">class</span> <span class="nc">OAuth2Client</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span><span class="kt">:</span> <span class="kt">Monad</span><span class="o">](</span>
    <span class="n">config</span><span class="k">:</span> <span class="kt">ServerConfig</span>
  <span class="o">)(</span>
    <span class="n">user</span><span class="k">:</span> <span class="kt">UserInteraction</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span>
    <span class="n">client</span><span class="k">:</span> <span class="kt">JsonClient</span><span class="o">[</span><span class="kt">F</span><span class="o">],</span>
    <span class="n">clock</span><span class="k">:</span> <span class="kt">LocalClock</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
  <span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">authenticate</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">CodeToken</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">callback</span> <span class="k">&lt;-</span> <span class="n">user</span><span class="o">.</span><span class="n">start</span>
        <span class="n">params</span>   <span class="k">=</span> <span class="nc">AuthRequest</span><span class="o">(</span><span class="n">callback</span><span class="o">,</span> <span class="n">config</span><span class="o">.</span><span class="n">scope</span><span class="o">,</span> <span class="n">config</span><span class="o">.</span><span class="n">clientId</span><span class="o">)</span>
        <span class="k">_</span>        <span class="k">&lt;-</span> <span class="n">user</span><span class="o">.</span><span class="n">open</span><span class="o">(</span><span class="n">params</span><span class="o">.</span><span class="n">toUrlQuery</span><span class="o">.</span><span class="n">forUrl</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">auth</span><span class="o">))</span>
        <span class="n">code</span>     <span class="k">&lt;-</span> <span class="n">user</span><span class="o">.</span><span class="n">stop</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">code</span>

    <span class="k">def</span> <span class="n">access</span><span class="o">(</span><span class="n">code</span><span class="k">:</span> <span class="kt">CodeToken</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[(</span><span class="kt">RefreshToken</span>, <span class="kt">BearerToken</span><span class="o">)]</span> <span class="k">=</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">request</span> <span class="k">&lt;-</span> <span class="nc">AccessRequest</span><span class="o">(</span><span class="n">code</span><span class="o">.</span><span class="n">token</span><span class="o">,</span>
                                 <span class="n">code</span><span class="o">.</span><span class="n">redirect_uri</span><span class="o">,</span>
                                 <span class="n">config</span><span class="o">.</span><span class="n">clientId</span><span class="o">,</span>
                                 <span class="n">config</span><span class="o">.</span><span class="n">clientSecret</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
        <span class="n">msg</span>     <span class="k">&lt;-</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">[</span><span class="kt">AccessRequest</span>, <span class="kt">AccessResponse</span><span class="o">](</span>
                     <span class="n">config</span><span class="o">.</span><span class="n">access</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
        <span class="n">time</span>    <span class="k">&lt;-</span> <span class="n">clock</span><span class="o">.</span><span class="n">now</span>
        <span class="n">expires</span> <span class="k">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="n">expires_in</span><span class="o">.</span><span class="n">seconds</span>
        <span class="n">refresh</span> <span class="k">=</span> <span class="nc">RefreshToken</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">refresh_token</span><span class="o">)</span>
        <span class="n">bearer</span>  <span class="k">=</span> <span class="nc">BearerToken</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">access_token</span><span class="o">,</span> <span class="n">expires</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="o">(</span><span class="n">refresh</span><span class="o">,</span> <span class="n">bearer</span><span class="o">)</span>

    <span class="k">def</span> <span class="n">bearer</span><span class="o">(</span><span class="n">refresh</span><span class="k">:</span> <span class="kt">RefreshToken</span><span class="o">)</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">BearerToken</span><span class="o">]</span> <span class="k">=</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">request</span> <span class="k">&lt;-</span> <span class="nc">RefreshRequest</span><span class="o">(</span><span class="n">config</span><span class="o">.</span><span class="n">clientSecret</span><span class="o">,</span>
                                  <span class="n">refresh</span><span class="o">.</span><span class="n">token</span><span class="o">,</span>
                                  <span class="n">config</span><span class="o">.</span><span class="n">clientId</span><span class="o">).</span><span class="n">pure</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>
        <span class="n">msg</span>     <span class="k">&lt;-</span> <span class="n">client</span><span class="o">.</span><span class="n">post</span><span class="o">[</span><span class="kt">RefreshRequest</span>, <span class="kt">RefreshResponse</span><span class="o">](</span>
                     <span class="n">config</span><span class="o">.</span><span class="n">refresh</span><span class="o">,</span> <span class="n">request</span><span class="o">)</span>
        <span class="n">time</span>    <span class="k">&lt;-</span> <span class="n">clock</span><span class="o">.</span><span class="n">now</span>
        <span class="n">expires</span> <span class="k">=</span> <span class="n">time</span> <span class="o">+</span> <span class="n">msg</span><span class="o">.</span><span class="n">expires_in</span><span class="o">.</span><span class="n">seconds</span>
        <span class="n">bearer</span>  <span class="k">=</span> <span class="nc">BearerToken</span><span class="o">(</span><span class="n">msg</span><span class="o">.</span><span class="n">access_token</span><span class="o">,</span> <span class="n">expires</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">bearer</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_4_4_">4.4 Підсумок</h2>
<div class="sectionbody">
<div class="ulist"><ul>
<li>
<p>
Алгебраїчні типи даних (ADT) визначені як продукти (фінальні кейс класи) та ко-продукти (закорковані абстрактні класи).
</p>
</li>
<li>
<p>
Очищені типи накладають обмеження на значення.
</p>
</li>
<li>
<p>
Суцільні функції можуть бути визначені в неявному класі для керуванням потоку зліва-направо.
</p>
</li>
<li>
<p>
Поліморфічні функції визначені в типокласах. Функціональність реалізується через обмеження контексту “має деякий”, скоріше ніж ієрархіями класів “є різновидом”.
</p>
</li>
<li>
<p>
Примірники типокласів є реалізаціями типокласів.
</p>
</li>
<li>
<p>
<code>@simulacrum.typeclass</code> генерує <code>.ops</code> на компаньйоні, провадячи зручний синтаксис для функцій типокласів.
</p>
</li>
<li>
<p>
Походження типокласів є композиція часу компіляції примірників типокласів.
</p>
</li>
</ul></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-16 03:52:57 EEST
</div>
</div>
</body>
</html>
