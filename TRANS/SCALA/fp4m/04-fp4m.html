<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>4. Дані та функціональність</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>4. Дані та функціональність</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>В OOP ми звикли думати про дані та функціональність разом: ієрархії класів несуть методи, і трейти можуть вимагати, щоб існували поля даних. Поліморфізм часу виконання об'єкту є терміном відношення “є різновидом”, що вимагає, щоб класи наслідували від загальних інтерфейсів. Це може викликати плутанину при зростанні обсягу коду. Прості типи даних стають прихованими за сотнями рядків методів, міксіни трейтів потерпають від помилок порядку ініціалізації, та тестування / мокінг дуже пов'язаних компонент стає жахом.</p></div>
<div class="paragraph"><p>FP приймає інший підхід, визначаючи дані та функціональність окремо. В цій главі ми розглянемо основи типів даних, та переваги обмеження себе до підмножини мови Scala. Ми також дослідимо типокласи як спосіб досягти поліморфізм часу компіляції: думати про функціональність структури даних в термінах відношення “має”, скоріше, ніж “є різновидом”.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_1_">4.1 Дані</h2>
<div class="sectionbody">
<div class="paragraph"><p>Фундаментальні будівельні блоки типів даних є:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>final case class</code>, також відомі як продукти
</p>
</li>
<li>
<p>
<code>sealed abstract class</code>, також відомі як ко-продукти
</p>
</li>
<li>
<p>
<code>case object</code> та значення <code>Int</code>, <code>Double</code>, <code>String</code> (тощо) без методів або полів, крім параметрів конструктора. Ми обираємо абстрактні класи замість трейтів, щоб отримати кращу бінарну сумісність, та щоб перешкоджати міксуванню трейтів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Колективна назва для продуктів, ко-продуктів та значень є _Алгебраїчні типи даних_ (Algebraic Data Type, ADT).</p></div>
<div class="paragraph"><p>Ми компонуємо типи даних з логічної алгебри <code>AND</code> та <code>XOR</code> (виключне <code>OR</code>): продукт містить кожний тип, з яких він складається, але ко-продукт може бути тільки один. For example</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">product</span><span class="k">:</span> <span class="kt">ABC</span> <span class="o">=</span> <span class="n">a</span> <span class="nc">AND</span> <span class="n">b</span> <span class="nc">AND</span> <span class="n">c</span>
<span class="n">coproduct</span><span class="k">:</span> <span class="kt">XYZ</span> <span class="o">=</span> <span class="n">x</span> <span class="nc">XOR</span> <span class="n">y</span> <span class="nc">XOR</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>записане в Scala</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="c1">// значення</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">A</span>
  <span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">type</span> <span class="kt">C</span> <span class="o">=</span> <span class="nc">Int</span>

  <span class="c1">// продукт</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ABC</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A.</span><span class="k">type</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>

  <span class="c1">// ко-продукт</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">X</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Y</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Z</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">XYZ</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_4_1_1__adt">4.1.1 Рекурсівні ADT</h3>
<div class="paragraph"><p>Коли ADT посилається на себе, ми називаємо це Рекурсивним алгебраїчним типом даних (Recursive Algebraic Data Type).</p></div>
<div class="paragraph"><p><code>scalaz.IList</code>, безпечна альтернатива до <code>stdlib</code> <code>List</code>, є рекурсивною, оскікльи <code>ICons</code> містить посилання на <code>IList.</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">INil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ICons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_2___adt">4.1.2 Функції на ADT</h3>
<div class="paragraph"><p>ADT може містити чисті функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserConfiguration</span><span class="o">(</span><span class="n">accepts</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але ADT, що мають функції, ідуть з деякими особистостями, бо вони не ідеально транслюються на JVM. Наприклад, старий <code>Serializable</code>, <code>hashCode</code>, <code>equals</code> та <code>toString</code> не поводяться так, як дехто може логічно очікувати.</p></div>
<div class="paragraph"><p>Нажаль, <code>Serializable</code> використовується в популярних фреймворках, не зважаючи на значно кращі альтернативи. Загальна пастка є забути, що  <code>Serializable</code> може спробувати селіалізувати ціле замикання функції, що може зламати промисловий сервер. Подібна специфіка стосується старих Java класів, таких як <code>Throwable</code>, що може нести посилання на довільні об'єкти.</p></div>
<div class="paragraph"><p>Ми будемо досліджувати альтернативи до старих методів, коли ми дискутуватимемо бібліотеку <code>Scalaz</code> в наступній главі, ціною втрати взаємодії з деяким старим кодом Java та Scala.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_3_">4.1.3 Вичерпність</h3>
<div class="paragraph"><p>Важливо, що ми використовуємо закоркований абстрактний клас, не просто абстрактний клас, коли визначаємо тип даних. Закоркування класу означає, що всі підтипи мають бути визначені в тому ж файлі, дозволяючи компілятору знати щодо них в вичерпному співпадінні шаблонів, та в макросах, що запобігають шаблонному коду. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Baz</span> <span class="k">extends</span> <span class="nc">Foo</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>
  <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
  <span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">Baz</span>
         <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
                               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це показує розробнику, що вони зламають речі, якщо вони додають новий продукт до коду. Ми використовуємо <code>-Xfatal-warnings</code>, інакше це тільки попередження.</p></div>
<div class="paragraph"><p>Однак компілятор не буде виконувати перевірку вичерпності, якщо клас не закоркований, або якщо стоять захисники, тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="k">if</span> <span class="n">flag</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">thing</span><span class="o">(</span><span class="nc">Baz</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">.</span><span class="nc">MatchError</span><span class="k">:</span> <span class="kt">Baz</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">Baz$</span><span class="o">)</span>
    <span class="kt">at</span> <span class="kt">.thing</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">15</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб залишатись в безпеці не використовуйте захисників на закоркованих типах.</p></div>
<div class="paragraph"><p>Флаг <code>-Xstrict-patmat-analysis</code> був запропонований як покращення мови для виконання додаткових перевірок співпадіння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_4_____">4.1.4 Альтернативні продукти та ко-продукти</h3>
<div class="paragraph"><p>Іншою формою продукта є тапл, що як непомічений фінальний кейс клас.</p></div>
<div class="paragraph"><p><code>(A.type, B, C)</code> еквівалентне до <code>ABC</code> в прикладі вище, але краще використовувати фінальний кейс клас як частини ADT, оскільки брак імен ускладнює справи, і кейс клас має значно кращу продуктивність для примітивних значень.</p></div>
<div class="paragraph"><p>Інша форма ко-продукта утворюється, коли ми вкладаємо типи <code>Either</code>. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nc">Either</span><span class="o">[</span><span class="kt">X.</span><span class="k">type</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">Y.</span><span class="k">type</span>, <span class="kt">Z</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до закоркованого абстрактного класу <code>XYZ</code>. Ясніший синтаксис для визначення вкладених типів <code>Either</code> є створення псевдониму типу, що завершується на двокрапку, дозволяючи інфіксну нотацію з правою асоціацією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">|:</span><span class="o">[</span><span class="kt">L</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">]</span>

  <span class="n">X</span><span class="o">.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Y.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Z</span>
</pre></div></div></div>
<div class="paragraph"><p>Це корисно для створення анонімних ко-продуктів, коли ми не можемо покласти всі реалізації в той самий джерельний файл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Accepted</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">|:</span> <span class="nc">Long</span> <span class="o">|:</span> <span class="nc">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>І ще один альтернативний ко-продукт є створення власного закоркованого абстрактного класу з фінальним кейс класом, що просто огортає бажаний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedLong</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів на ціх формах ко-продуктів може бути тендітним, ось чому були досліджені <em>Union Types</em> в <code>Dotty</code>, компіляторі Scala наступного покоління. Макроси, такі як <code>totalitarian</code> та <code>iotaz</code> існують як альтернативні шляхи кодування анонімних ко-продуктів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_5__">4.1.5 Подача інформації</h3>
<div class="paragraph"><p>Besides being a container for necessary business information, data types can be used to encode constraints. For example,</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class NonEmptyList[A](head: A, tail: IList[A])
can never be empty. This makes scalaz.NonEmptyList a useful data type despite containing the same information as IList.</code></pre>
</div></div>
<div class="paragraph"><p>Product types often contain types that are far more general than is allowed. In traditional OOP this would be handled with input validation through assertions:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class Person(name: String, age: Int) {
    require(name.nonEmpty &amp;&amp; age &gt; 0) // breaks Totality, don't do this!
  }
Instead, we can use the Either data type to provide Right[Person] for valid instances and protect invalid instances from propagating. Note that the constructor is private:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>final case class Person private(name: String, age: Int)
object Person {
  def apply(name: String, age: Int): Either[String, Person] = {
    if (name.nonEmpty &amp;&amp; age &gt; 0) Right(new Person(name, age))
    else Left(s"bad input: $name, $age")
  }
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def welcome(person: Person): String =
  s"${person.name} you look wonderful at ${person.age}!"</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  for {
    person &lt;- Person("", -1)
  } yield welcome(person)
4.1.5.1 Refined Data Types
A clean way to restrict the values of a general type is with the refined library, providing a suite of restrictions to the contents of data. To install refined, add the following to build.sbt</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  libraryDependencies += "eu.timepit" %% "refined-scalaz" % "0.9.2"
and the following imports</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  import eu.timepit.refined
  import refined.api.Refined
Refined allows us to define Person using adhoc refined types to capture requirements exactly, written A Refined B.</code></pre>
</div></div>
<div class="paragraph"><p>All types with two parameters can be written infix in Scala. For example, Either[String, Int] is the same as String Either Int. It is conventional for Refined to be written infix since A Refined B can be read as “an A that meets the requirements defined in B”.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>import refined.numeric.Positive
import refined.collection.NonEmpty</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class Person(
    name: String Refined NonEmpty,
    age: Int Refined Positive
  )
The underlying value can be obtained with .value. We can construct a value at runtime using .refineV, returning an Either</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; import refined.refineV
scala&gt; refineV[NonEmpty]("")
Left(Predicate isEmpty() did not fail.)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; refineV[NonEmpty]("Sam")
  Right(Sam)
If we add the following import</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  import refined.auto._
we can construct valid values at compiletime and get an error if the provided value does not meet the requirements</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; val sam: String Refined NonEmpty = "Sam"
Sam</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; val empty: String Refined NonEmpty = ""
  &lt;console&gt;:21: error: Predicate isEmpty() did not fail.
More complex requirements can be captured, for example we can use the built-in rule MaxSize with the following imports</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  import refined.W
  import refined.boolean.And
  import refined.collection.MaxSize
capturing the requirement that the String must be both non-empty and have a maximum size of 10 characters:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>type Name = NonEmpty And MaxSize[W.`10`.T]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class Person(
    name: String Refined Name,
    age: Int Refined Positive
  )
The W notation is short for “witness”. This syntax will be much simpler in Scala 2.13, which has support for literal types:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  type Name = NonEmpty And MaxSize[10]
It is easy to define custom requirements that are not covered by the refined library. For example in drone-dynamaic-agents we will need a way of ensuring that a String contains application/x-www-form-urlencoded content. We can create a Refined rule using the Java regular expression library:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed abstract class UrlEncoded
object UrlEncoded {
  private[this] val valid: Pattern =
    Pattern.compile("\\A(\\p{Alnum}++|[-.*_+=&amp;]++|%\\p{XDigit}{2})*\\z")</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    implicit def urlValidate: Validate.Plain[String, UrlEncoded] =
      Validate.fromPredicate(
        s =&gt; valid.matcher(s).find(),
        identity,
        new UrlEncoded {}
      )
  }
4.1.6 Simple to Share
By not providing any functionality, ADTs can have a minimal set of dependencies. This makes them easy to publish and share with other developers. By using a simple data modelling language, it makes it possible to interact with cross-discipline teams, such as DBAs, UI developers and business analysts, using the actual code instead of a hand written document as the source of truth.</code></pre>
</div></div>
<div class="paragraph"><p>Furthermore, tooling can be more easily written to produce or consume schemas from other programming languages and wire protocols.</p></div>
<div class="paragraph"><p>4.1.7 Counting Complexity
The complexity of a data type is the count of values that can exist. A good data type has the least amount of complexity it needs to hold the information it conveys, and no more.</p></div>
<div class="paragraph"><p>Values have a built-in complexity:</p></div>
<div class="paragraph"><p>Unit has one value (why it is called “unit”)
Boolean has two values
Int has 4,294,967,295 values
String has effectively infinite values
To find the complexity of a product, we multiply the complexity of each part.</p></div>
<div class="paragraph"><p>(Boolean, Boolean) has 4 values (2*2)
(Boolean, Boolean, Boolean) has 8 values (2*2*2)
To find the complexity of a coproduct, we add the complexity of each part.</p></div>
<div class="paragraph"><p>(Boolean |: Boolean) has 4 values (2+2)
(Boolean |: Boolean |: Boolean) has 6 values (2+2+2)
To find the complexity of a ADT with a type parameter, multiply each part by the complexity of the type parameter:</p></div>
<div class="paragraph"><p>Option[Boolean] has 3 values, Some[Boolean] and None (2+1)
In FP, functions are total and must return an value for every input, no Exception. Minimising the complexity of inputs and outputs is the best way to achieve totality. As a rule of thumb, it is a sign of a badly designed function when the complexity of a function’s return value is larger than the product of its inputs: it is a source of entropy.</p></div>
<div class="paragraph"><p>The complexity of a total function is the number of possible functions that can satisfy the type signature: the output to the power of the input.</p></div>
<div class="paragraph"><p>Unit &#8658; Boolean has complexity 2
Boolean &#8658; Boolean has complexity 4
Option[Boolean] &#8658; Option[Boolean] has complexity 27
Boolean &#8658; Int is a mere quintillion going on a sextillion.
Int &#8658; Boolean is so big that if all implementations were assigned a unique number, each would require 4 gigabytes to represent.
In reality, Int &#8658; Boolean will be something simple like isOdd, isEven or a sparse BitSet. This function, when used in an ADT, could be better replaced with a coproduct labelling the limited set of functions that are relevant.</p></div>
<div class="paragraph"><p>When our complexity is “infinity in, infinity out” we should introduce restrictive data types and validation closer to the point of input with Refined from the previous section.</p></div>
<div class="paragraph"><p>The ability to count the complexity of a type signature has one other practical application: we can find simpler type signatures with High School algebra! To go from a type signature to its algebra of complexity, simply replace</p></div>
<div class="paragraph"><p>Either[A, B] with a + b
(A, B) with a * b
A &#8658; B with b ^ a
do some rearranging, and convert back. For example, say we’ve designed a framework based on callbacks and we’ve managed to work ourselves into the situation where we have created this type signature:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  (A =&gt; C) =&gt; ((B =&gt; C) =&gt; C)
We can convert and rearrange</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  (c ^ (c ^ b)) ^ (c ^ a)
  = c ^ ((c ^ b) * (c ^ a))
  = c ^ (c ^ (a + b))
then convert back to types and get</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  (Either[A, B] =&gt; C) =&gt; C
which is much simpler: we only need to ask the users of our framework to provide a Either[A, B] =&gt; C.</code></pre>
</div></div>
<div class="paragraph"><p>The same line of reasoning can be used to prove that</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  A =&gt; B =&gt; C
is equivalent to</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  (A, B) =&gt; C
also known as Currying.</code></pre>
</div></div>
<div class="paragraph"><p>4.1.8 Prefer Coproduct over Product
An archetypal modelling problem that comes up a lot is when there are mutually exclusive configuration parameters a, b and c. The product (a: Boolean, b: Boolean, c: Boolean) has complexity 8 whereas the coproduct</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  sealed abstract class Config
  object Config {
    case object A extends Config
    case object B extends Config
    case object C extends Config
  }
has a complexity of 3. It is better to model these configuration parameters as a coproduct rather than allowing 5 invalid states to exist.</code></pre>
</div></div>
<div class="paragraph"><p>The complexity of a data type also has implications on testing. It is practically impossible to test every possible input to a function, but it is easy to test a sample of values with the Scalacheck property testing framework. If a random sample of a data type has a low probability of being valid, it is a sign that the data is modelled incorrectly.</p></div>
<div class="paragraph"><p>4.1.9 Optimisations
A big advantage of using a simplified subset of the Scala language to represent data types is that tooling can optimise the JVM bytecode representation.</p></div>
<div class="paragraph"><p>For example, we could pack Boolean and Option fields into an Array[Byte], cache values, memoise hashCode, optimise equals, use @switch statements when pattern matching, and much more.</p></div>
<div class="paragraph"><p>These optimisations are not applicable to OOP class hierarchies that may be managing state, throwing exceptions, or providing adhoc method implementations.</p></div>
<div class="paragraph"><p>4.2 Functionality
Pure functions are typically defined as methods on an object.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>package object math {
  def sin(x: Double): Double = java.lang.Math.sin(x)
  ...
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  math.sin(1.0)
However, it can be clunky to use object methods since it reads inside-out, not left to right. In addition, a function on an object steals the namespace. If we were to define sin(t: T) somewhere else we get ambiguous reference errors. This is the same problem as Java’s static methods vs class methods.</code></pre>
</div></div>
<div class="paragraph"><p>The sort of developer who puts methods on a trait, requiring users to mix it with the cake pattern, is going straight to hell. It leaks internal implementation detail to public APIs, bloats bytecode, makes binary compatibility basically impossible, and confuses IDE autocompleters.</p></div>
<div class="paragraph"><p>With the implicit class language feature (also known as extension methodology or syntax), and a little boilerplate, we can get the familiar style:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; implicit class DoubleOps(x: Double) {
         def sin: Double = math.sin(x)
       }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; (1.0).sin
  res: Double = 0.8414709848078965
Often it is best to just skip the object definition and go straight for an implicit class, keeping boilerplate to a minimum:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
implicit class is syntax sugar for an implicit conversion:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit def DoubleOps(x: Double): DoubleOps = new DoubleOps(x)
  class DoubleOps(x: Double) {
    def sin: Double = java.lang.Math.sin(x)
  }
Which unfortunately has a runtime cost: each time the extension method is called, an intermediate DoubleOps will be constructed and then thrown away. This can contribute to GC pressure in hotspots.</code></pre>
</div></div>
<div class="paragraph"><p>There is a slightly more verbose form of implicit class that avoids the allocation and is therefore preferred:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit final class DoubleOps(private val x: Double) extends AnyVal {
    def sin: Double = java.lang.Math.sin(x)
  }
4.2.1 Polymorphic Functions
The more common kind of function is a polymorphic function, which lives in a typeclass. A typeclass is a trait that:</code></pre>
</div></div>
<div class="paragraph"><p>holds no state
has a type parameter
has at least one abstract method (primitive combinators)
may contain generalised methods (derived combinators)
may extend other typeclasses
There can only be one implementation of a typeclass for any given type parameter, a property known as typeclass coherence. Typeclasses look superficially similar to algebraic interfaces from the previous chapter, but algebras do not have to be coherent.</p></div>
<div class="paragraph"><p>Typeclass coherence is primarily about consistency, and the consistency gives us the confidence to use implicit parameters. It would be difficult to reason about code that performs differently depending on the implicit imports that are in scope. Typeclass coherence effectively says that imports should not impact the behaviour of the code.</p></div>
<div class="paragraph"><p>Additionally, typeclass coherence allows us to globally cache implicits at runtime and save memory allocations, gaining performance improvements from reduced pressure on the garbage collector.</p></div>
<div class="paragraph"><p>Typeclasses are used in the Scala stdlib. We will explore a simplified version of scala.math.Numeric to demonstrate the principle:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>trait Ordering[T] {
  def compare(x: T, y: T): Int</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def lt(x: T, y: T): Boolean = compare(x, y) &lt; 0
  def gt(x: T, y: T): Boolean = compare(x, y) &gt; 0
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>trait Numeric[T] extends Ordering[T] {
  def plus(x: T, y: T): T
  def times(x: T, y: T): T
  def negate(x: T): T
  def zero: T</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    def abs(x: T): T = if (lt(x, zero)) negate(x) else x
  }
We can see all the key features of a typeclass in action:</code></pre>
</div></div>
<div class="paragraph"><p>there is no state
Ordering and Numeric have type parameter T
Ordering has abstract compare and Numeric has abstract plus, times, negate and zero
Ordering defines generalised lt and gt based on compare, Numeric defines abs in terms of lt, negate and zero.
Numeric extends Ordering
We can now write functions for types that “have a” Numeric typeclass:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def signOfTheTimes[T](t: T)(implicit N: Numeric[T]): T = {
    import N._
    times(negate(abs(t)), t)
  }
We are no longer dependent on the OOP hierarchy of our input types, i.e. we don’t demand that our input “is a” Numeric, which is vitally important if we want to support a third party class that we cannot redefine.</code></pre>
</div></div>
<div class="paragraph"><p>Another advantage of typeclasses is that the association of functionality to data is at compiletime, as opposed to OOP runtime dynamic dispatch.</p></div>
<div class="paragraph"><p>For example, whereas the List class can only have one implementation of a method, a typeclass method allows us to have a different implementation depending on the List contents and therefore offload work to compiletime instead of leaving it to runtime.</p></div>
<div class="paragraph"><p>4.2.2 Syntax
The syntax for writing signOfTheTimes is clunky, there are some things we can do to clean it up.</p></div>
<div class="paragraph"><p>Downstream users will prefer to see our method use context bounds, since the signature reads cleanly as “takes a T that has a Numeric”</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def signOfTheTimes[T: Numeric](t: T): T = ...
but now we have to use implicitly[Numeric[T]] everywhere. By defining boilerplate on the companion of the typeclass</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  object Numeric {
    def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric
  }
we can obtain the implicit with less noise</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  def signOfTheTimes[T: Numeric](t: T): T = {
    val N = Numeric[T]
    import N._
    times(negate(abs(t)), t)
  }
But it is still worse for us as the implementors. We have the syntactic problem of inside-out static methods vs class methods. We deal with this by introducing ops on the typeclass companion:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object Numeric {
  def apply[T](implicit numeric: Numeric[T]): Numeric[T] = numeric</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object ops {
  implicit class NumericOps[T](t: T)(implicit N: Numeric[T]) {
    def +(o: T): T = N.plus(t, o)
    def *(o: T): T = N.times(t, o)
    def unary_-: T = N.negate(t)
    def abs: T = N.abs(t)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>        // duplicated from Ordering.ops
        def &lt;(o: T): T = N.lt(t, o)
        def &gt;(o: T): T = N.gt(t, o)
      }
    }
  }
Note that -x is expanded into x.unary_- by the compiler’s syntax sugar, which is why we define unary_- as an extension method. We can now write the much cleaner:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
The good news is that we never need to write this boilerplate because Simulacrum provides a @typeclass macro annotation that automatically generates the apply and ops. It even allows us to define alternative (usually symbolic) names for common methods. In full:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import simulacrum._</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Ordering[T] {
  def compare(x: T, y: T): Int
  @op("&lt;") def lt(x: T, y: T): Boolean = compare(x, y) &lt; 0
  @op("&gt;") def gt(x: T, y: T): Boolean = compare(x, y) &gt; 0
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait Numeric[T] extends Ordering[T] {
  @op("+") def plus(x: T, y: T): T
  @op("*") def times(x: T, y: T): T
  @op("unary_-") def negate(x: T): T
  def zero: T
  def abs(x: T): T = if (lt(x, zero)) negate(x) else x
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  import Numeric.ops._
  def signOfTheTimes[T: Numeric](t: T): T = -(t.abs) * t
When there is a custom symbolic @op, it can be pronounced like its method name. e.g. &lt; is pronounced “less than”, not “left angle bracket”.</code></pre>
</div></div>
<div class="paragraph"><p>4.2.3 Instances
Instances of Numeric (which are also instances of Ordering) are defined as an implicit val that extends the typeclass, and can provide optimised implementations for the generalised methods:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val NumericDouble: Numeric[Double] = new Numeric[Double] {
  def plus(x: Double, y: Double): Double = x + y
  def times(x: Double, y: Double): Double = x * y
  def negate(x: Double): Double = -x
  def zero: Double = 0.0
  def compare(x: Double, y: Double): Int = java.lang.Double.compare(x, y)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    // optimised
    override def lt(x: Double, y: Double): Boolean = x &lt; y
    override def gt(x: Double, y: Double): Boolean = x &gt; y
    override def abs(x: Double): Double = java.lang.Math.abs(x)
  }
Although we are using +, *, unary_-, &lt; and &gt; here, which are the ops (and could be an infinite loop!), these methods exist already on Double. Class methods are always used in preference to extension methods. Indeed, the Scala compiler performs special handling of primitives and converts these method calls into raw dadd, dmul, dcmpl and dcmpg bytecode instructions, respectively.</code></pre>
</div></div>
<div class="paragraph"><p>We can also implement Numeric for Java’s BigDecimal class (avoid scala.BigDecimal, it is fundamentally broken)</p></div>
<div class="literalblock">
<div class="content">
<pre><code>import java.math.{ BigDecimal =&gt; BD }</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit val NumericBD: Numeric[BD] = new Numeric[BD] {
    def plus(x: BD, y: BD): BD = x.add(y)
    def times(x: BD, y: BD): BD = x.multiply(y)
    def negate(x: BD): BD = x.negate
    def zero: BD = BD.ZERO
    def compare(x: BD, y: BD): Int = x.compareTo(y)
  }
We could create our own data structure for complex numbers:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class Complex[T](r: T, i: T)
And derive a Numeric[Complex[T]] if Numeric[T] exists. Since these instances depend on the type parameter, it is a def, not a val.</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit def numericComplex[T: Numeric]: Numeric[Complex[T]] =
    new Numeric[Complex[T]] {
      type CT = Complex[T]
      def plus(x: CT, y: CT): CT = Complex(x.r + y.r, x.i + y.i)
      def times(x: CT, y: CT): CT =
        Complex(x.r * y.r + (-x.i * y.i), x.r * y.i + x.i * y.r)
      def negate(x: CT): CT = Complex(-x.r, -x.i)
      def zero: CT = Complex(Numeric[T].zero, Numeric[T].zero)
      def compare(x: CT, y: CT): Int = {
        val real = (Numeric[T].compare(x.r, y.r))
        if (real != 0) real
        else Numeric[T].compare(x.i, y.i)
      }
    }
The observant reader may notice that abs is not at all what a mathematician would expect. The correct return value for abs should be T, not Complex[T].</code></pre>
</div></div>
<div class="paragraph"><p>scala.math.Numeric tries to do too much and does not generalise beyond real numbers. This is a good lesson that smaller, well defined, typeclasses are often better than a monolithic collection of overly specific features.</p></div>
<div class="paragraph"><p>4.2.4 Implicit Resolution
We’ve discussed implicits a lot: this section is to clarify what implicits are and how they work.</p></div>
<div class="paragraph"><p>Implicit parameters are when a method requests that a unique instance of a particular type is in the implicit scope of the caller, with special syntax for typeclass instances. Implicit parameters are a clean way to thread configuration through an application.</p></div>
<div class="paragraph"><p>In this example, foo requires that typeclass instances of Numeric and Typeable are available for A, as well as an implicit Handler object that takes two type parameters</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def foo[A: Numeric: Typeable](implicit A: Handler[String, A]) = ...
Implicit conversion is when an implicit def exists. One such use of implicit conversions is to enable extension methodology. When the compiler is resolving a call to a method, it first checks if the method exists on the type, then its ancestors (Java-like rules). If it fails to find a match, it will search the implicit scope for conversions to other types, then search for methods on those types.</code></pre>
</div></div>
<div class="paragraph"><p>Another use for implicit conversions is typeclass derivation. In the previous section we wrote an implicit def that derived a Numeric[Complex[T]] if a Numeric[T] is in the implicit scope. It is possible to chain together many implicit def (including recursively) which is the basis of typeful programming, allowing for computations to be performed at compiletime rather than runtime.</p></div>
<div class="paragraph"><p>The glue that combines implicit parameters (receivers) with implicit conversion (providers) is implicit resolution.</p></div>
<div class="paragraph"><p>First, the normal variable scope is searched for implicits, in order:</p></div>
<div class="paragraph"><p>local scope, including scoped imports (e.g. the block or method)
outer scope, including scoped imports (e.g. members in the class)
ancestors (e.g. members in the super class)
the current package object
ancestor package objects (when using nested packages)
the file’s imports
If that fails to find a match, the special scope is searched, which looks for implicit instances inside a type’s companion, its package object, outer objects (if nested), and then repeated for ancestors. This is performed, in order, for the:</p></div>
<div class="paragraph"><p>given parameter type
expected parameter type
type parameter (if there is one)
If two matching implicits are found in the same phase of implicit resolution, an ambiguous implicit error is raised.</p></div>
<div class="paragraph"><p>Implicits are often defined on a trait, which is then extended by an object. This is to try and control the priority of an implicit relative to another more specific one, to avoid ambiguous implicits.</p></div>
<div class="paragraph"><p>The Scala Language Specification is rather vague for corner cases, and the compiler implementation is the de facto standard. There are some rules of thumb that we will use throughout this book, e.g. prefer implicit val over implicit object despite the temptation of less typing. It is a quirk of implicit resolution that implicit object on companion objects are not treated the same as implicit val.</p></div>
<div class="paragraph"><p>Implicit resolution falls short when there is a hierarchy of typeclasses, like Ordering and Numeric. If we write a function that takes an implicit Ordering, and we call it for a primitive type which has an instance of Numeric defined on the Numeric companion, the compiler will fail to find it.</p></div>
<div class="paragraph"><p>Implicit resolution is particularly hit-or-miss if type aliases are used where the shape of the implicit parameters are changed. For example an implicit parameter using an alias such as type Values[A] = List[Option[A]] will probably fail to find implicits defined as raw List[Option[A]] because the shape is changed from a thing of things of A to a thing of A.</p></div>
<div class="paragraph"><p>4.3 Modelling OAuth2
We will finish this chapter with a practical example of data modelling and typeclass derivation, combined with algebra / module design from the previous chapter.</p></div>
<div class="paragraph"><p>In our drone-dynamic-agents application, we must communicate with Drone and Google Cloud using JSON over REST. Both services use OAuth2 for authentication. There are many ways to interpret OAuth2, but we will focus on the version that works for Google Cloud (the Drone version is even simpler).</p></div>
<div class="paragraph"><p>4.3.1 Description
Every Google Cloud application needs to have an OAuth 2.0 Client Key set up at</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
Obtaining a Client ID and a Client secret.</code></pre>
</div></div>
<div class="paragraph"><p>The application can then obtain a one time code by making the user perform an Authorization Request in their browser (yes, really, in their browser). We need to make this page open in the browser:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&amp;\
    prompt=consent&amp;\
    response_type=code&amp;\
    scope={SCOPE}&amp;\
    access_type=offline&amp;\
    client_id={CLIENT_ID}
The code is delivered to the {CALLBACK_URI} in a GET request. To capture it in our application, we need to have a web server listening on localhost.</code></pre>
</div></div>
<div class="paragraph"><p>Once we have the code, we can perform an Access Token Request:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&amp;\
    redirect_uri={CALLBACK_URI}&amp;\
    client_id={CLIENT_ID}&amp;\
    client_secret={CLIENT_SECRET}&amp;\
    scope={SCOPE}&amp;\
    grant_type=authorization_code
which gives a JSON response payload</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }
Bearer tokens typically expire after an hour, and can be refreshed by sending an HTTP request with any valid refresh token:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&amp;
    grant_type=refresh_token&amp;
    refresh_token={REFRESH_TOKEN}&amp;
    client_id={CLIENT_ID}
responding with</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }
All userland requests to the server should include the header</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  Authorization: Bearer BEARER_TOKEN
after substituting the actual BEARER_TOKEN.</code></pre>
</div></div>
<div class="paragraph"><p>Google expires all but the most recent 50 bearer tokens, so the expiry times are just guidance. The refresh tokens persist between sessions and can be expired manually by the user. We can therefore have a one-time setup application to obtain the refresh token and then include the refresh token as configuration for the user’s install of the headless server.</p></div>
<div class="paragraph"><p>Drone doesn’t implement the /auth endpoint, or the refresh, and simply provides a BEARER_TOKEN through their user interface.</p></div>
<div class="paragraph"><p>4.3.2 Data
The first step is to model the data needed for OAuth2. We create an ADT with fields having exactly the same name as required by the OAuth2 server. We will use String and Long for brevity, but we could use refined types if they leak into our business models.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>import refined.api.Refined
import refined.string.Url</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class AuthRequest(
    redirect_uri: String Refined Url,
    scope: String,
    client_id: String,
    prompt: String = "consent",
    response_type: String = "code",
    access_type: String = "offline"
  )
  final case class AccessRequest(
    code: String,
    redirect_uri: String Refined Url,
    client_id: String,
    client_secret: String,
    scope: String = "",
    grant_type: String = "authorization_code"
  )
  final case class AccessResponse(
    access_token: String,
    token_type: String,
    expires_in: Long,
    refresh_token: String
  )
  final case class RefreshRequest(
    client_secret: String,
    refresh_token: String,
    client_id: String,
    grant_type: String = "refresh_token"
  )
  final case class RefreshResponse(
    access_token: String,
    token_type: String,
    expires_in: Long
  )
Avoid using java.net.URL at all costs: it uses DNS to resolve the hostname part when performing toString, equals or hashCode.</code></pre>
</div></div>
<div class="paragraph"><p>Apart from being insane, and very very slow, these methods can throw I/O exceptions (are not pure), and can change depending on the network configuration (are not deterministic).</p></div>
<div class="paragraph"><p>The refined type String Refined Url allows us to perform equality checks based on the String and we can safely construct a URL only if it is needed by a legacy API.</p></div>
<div class="paragraph"><p>That said, in high performance code we would prefer to skip java.net.URL entirely and use a third party URL parser such as jurl, because even the safe parts of java.net.* are extremely slow at scale.</p></div>
<div class="paragraph"><p>4.3.3 Functionality
We need to marshal the data classes we defined in the previous section into JSON, URLs and POST-encoded forms. Since this requires polymorphism, we will need typeclasses.</p></div>
<div class="paragraph"><p>jsonformat is a simple JSON library that we will study in more detail in a later chapter, as it has been written with principled FP and ease of readability as its primary design objectives. It consists of a JSON AST and encoder / decoder typeclasses:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>package jsonformat</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed abstract class JsValue
final case object JsNull                                    extends JsValue
final case class JsObject(fields: IList[(String, JsValue)]) extends JsValue
final case class JsArray(elements: IList[JsValue])          extends JsValue
final case class JsBoolean(value: Boolean)                  extends JsValue
final case class JsString(value: String)                    extends JsValue
final case class JsDouble(value: Double)                    extends JsValue
final case class JsInteger(value: Long)                     extends JsValue</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait JsEncoder[A] {
  def toJson(obj: A): JsValue
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  @typeclass trait JsDecoder[A] {
    def fromJson(json: JsValue): String \/ A
  }
\/ is Scalaz’s Either and has a .flatMap. We can use it in for comprehensions, whereas stdlib Either does not support .flatMap prior to Scala 2.12. It is spoken as disjunction, or angry rabbit.</code></pre>
</div></div>
<div class="paragraph"><p>scala.Either was contributed to the Scala standard library by the creator of Scalaz, Tony Morris, in 2007. \/ was created when unsafe methods were added to Either.</p></div>
<div class="paragraph"><p>We need instances of JsDecoder[AccessResponse] and JsDecoder[RefreshResponse]. We can do this by making use of a helper function:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit class JsValueOps(j: JsValue) {
    def getAs[A: JsDecoder](key: String): String \/ A = ...
  }
We put the instances on the companions of our data types, so that they are always in the implicit scope:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import jsonformat._, JsDecoder.ops._</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object AccessResponse {
  implicit val json: JsDecoder[AccessResponse] = j =&gt;
    for {
      acc &lt;- j.getAs[String]("access_token")
      tpe &lt;- j.getAs[String]("token_type")
      exp &lt;- j.getAs[Long]("expires_in")
      ref &lt;- j.getAs[String]("refresh_token")
    } yield AccessResponse(acc, tpe, exp, ref)
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  object RefreshResponse {
    implicit val json: JsDecoder[RefreshResponse] = j =&gt;
      for {
        acc &lt;- j.getAs[String]("access_token")
        tpe &lt;- j.getAs[String]("token_type")
        exp &lt;- j.getAs[Long]("expires_in")
      } yield RefreshResponse(acc, tpe, exp)
  }
We can then parse a string into an AccessResponse or a RefreshResponse</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; import jsonformat._, JsDecoder.ops._
scala&gt; val json = JsParser("""
                     {
                       "access_token": "BEARER_TOKEN",
                       "token_type": "Bearer",
                       "expires_in": 3600,
                       "refresh_token": "REFRESH_TOKEN"
                     }
                     """)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; json.map(_.as[AccessResponse])
  AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
We need to write our own typeclasses for URL and POST encoding. The following is a reasonable design:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// URL query key=value pairs, in un-encoded form.
final case class UrlQuery(params: List[(String, String)])</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait UrlQueryWriter[A] {
  def toUrlQuery(a: A): UrlQuery
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
We need to provide typeclass instances for basic types:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import java.net.URLEncoder</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object UrlEncodedWriter {
  implicit val encoded: UrlEncodedWriter[String Refined UrlEncoded] = identity</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val string: UrlEncodedWriter[String] =
  (s =&gt; Refined.unsafeApply(URLEncoder.encode(s, "UTF-8")))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val url: UrlEncodedWriter[String Refined Url] =
  (s =&gt; s.value.toUrlEncoded)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val long: UrlEncodedWriter[Long] =
  (s =&gt; Refined.unsafeApply(s.toString))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit def ilist[K: UrlEncodedWriter, V: UrlEncodedWriter]
  : UrlEncodedWriter[IList[(K, V)]] = { m =&gt;
  val raw = m.map {
    case (k, v) =&gt; k.toUrlEncoded.value + "=" + v.toUrlEncoded.value
  }.intercalate("&amp;")
  Refined.unsafeApply(raw) // by deduction
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  }
We use Refined.unsafeApply when we can logically deduce that the contents of the string are already url encoded, bypassing any further checks.</code></pre>
</div></div>
<div class="paragraph"><p>ilist is an example of simple typeclass derivation, much as we derived Numeric[Complex] from the underlying numeric representation. The .intercalate method is like .mkString but more general.</p></div>
<div class="paragraph"><p>UrlEncodedWriter is making use of the Single Abstract Method (SAM types) Scala language feature. The full form of the above is</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
When the Scala compiler expects a class (which has a single abstract method) but receives a lambda, it fills in the boilerplate automatically.</code></pre>
</div></div>
<div class="paragraph"><p>Prior to SAM types, a common pattern was to define a method named instance on the typeclass companion</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def instance[T](f: T =&gt; String): UrlEncodedWriter[T] =
    new UrlEncodedWriter[T] {
      override def toUrlEncoded(t: T): String = f(t)
    }
allowing for</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit val string: UrlEncodedWriter[String] = instance { s =&gt; ... }
This pattern is still used in code that must support older versions of Scala, or for typeclasses instances that need to provide more than one method.</code></pre>
</div></div>
<div class="paragraph"><p>Note that there are a lot of bugs around SAM types, as they do not interact with all the language features. Revert to the non-SAM variant if there are any strange compiler crashes.</p></div>
<div class="paragraph"><p>In a dedicated chapter on Typeclass Derivation we will calculate instances of UrlQueryWriter automatically, as well as clean up what we have already written, but for now we will write the boilerplate for the types we wish to convert:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  import UrlEncodedWriter.ops._
  object AuthRequest {
    implicit val query: UrlQueryWriter[AuthRequest] = { a =&gt;
      UrlQuery(List(
        ("redirect_uri"  -&gt; a.redirect_uri.value),
        ("scope"         -&gt; a.scope),
        ("client_id"     -&gt; a.client_id),
        ("prompt"        -&gt; a.prompt),
        ("response_type" -&gt; a.response_type),
        ("access_type"   -&gt; a.access_type))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =&gt;
      IList(
        "code"          -&gt; a.code.toUrlEncoded,
        "redirect_uri"  -&gt; a.redirect_uri.toUrlEncoded,
        "client_id"     -&gt; a.client_id.toUrlEncoded,
        "client_secret" -&gt; a.client_secret.toUrlEncoded,
        "scope"         -&gt; a.scope.toUrlEncoded,
        "grant_type"    -&gt; a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =&gt;
      IList(
        "client_secret" -&gt; r.client_secret.toUrlEncoded,
        "refresh_token" -&gt; r.refresh_token.toUrlEncoded,
        "client_id"     -&gt; r.client_id.toUrlEncoded,
        "grant_type"    -&gt; r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
4.3.4 Module
That concludes the data and functionality modelling required to implement OAuth2. Recall from the previous chapter that we define components that need to interact with the world as algebras, and we define business logic in a module, so it can be thoroughly tested.</code></pre>
</div></div>
<div class="paragraph"><p>We define our dependency algebras, and use context bounds to show that our responses must have a JsDecoder and our POST payload must have a UrlEncodedWriter:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>trait JsonClient[F[_]] {
  def get[A: JsDecoder](
    uri: String Refined Url,
    headers: IList[(String, String)]
  ): F[A]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String] = IList.empty
    ): F[A]
  }
Note that we only define the happy path in the JsonClient API. We will get around to error handling in a later chapter.</code></pre>
</div></div>
<div class="paragraph"><p>Obtaining a CodeToken from the Google OAuth2 server involves</p></div>
<div class="paragraph"><p>starting an HTTP server on the local machine, and obtaining its port number.
making the user open a web page in their browser, which allows them to log in with their Google credentials and authorise the application, with a redirect back to the local machine.
capturing the code, informing the user of next steps, and closing the HTTP server.
We can model this with three methods on a UserInteraction algebra.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>final case class CodeToken(token: String, redirect_uri: String Refined Url)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
It almost sounds easy when put like that.</code></pre>
</div></div>
<div class="paragraph"><p>We also need an algebra to abstract over the local system time</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
And introduce data types that we will use in the refresh logic</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class ServerConfig(
    auth: String Refined Url,
    access: String Refined Url,
    refresh: String Refined Url,
    scope: String,
    clientId: String,
    clientSecret: String
  )
  final case class RefreshToken(token: String)
  final case class BearerToken(token: String, expires: Epoch)
Now we can write an OAuth2 client module:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import http.encoding.UrlQueryWriter.ops._</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>class OAuth2Client[F[_]: Monad](
  config: ServerConfig
)(
  user: UserInteraction[F],
  client: JsonClient[F],
  clock: LocalClock[F]
) {
  def authenticate: F[CodeToken] =
    for {
      callback &lt;- user.start
      params   = AuthRequest(callback, config.scope, config.clientId)
      _        &lt;- user.open(params.toUrlQuery.forUrl(config.auth))
      code     &lt;- user.stop
    } yield code</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
  for {
    request &lt;- AccessRequest(code.token,
                             code.redirect_uri,
                             config.clientId,
                             config.clientSecret).pure[F]
    msg     &lt;- client.post[AccessRequest, AccessResponse](
                 config.access, request)
    time    &lt;- clock.now
    expires = time + msg.expires_in.seconds
    refresh = RefreshToken(msg.refresh_token)
    bearer  = BearerToken(msg.access_token, expires)
  } yield (refresh, bearer)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    def bearer(refresh: RefreshToken): F[BearerToken] =
      for {
        request &lt;- RefreshRequest(config.clientSecret,
                                  refresh.token,
                                  config.clientId).pure[F]
        msg     &lt;- client.post[RefreshRequest, RefreshResponse](
                     config.refresh, request)
        time    &lt;- clock.now
        expires = time + msg.expires_in.seconds
        bearer  = BearerToken(msg.access_token, expires)
      } yield bearer
  }
4.4 Summary
algebraic data types (ADTs) are defined as products (final case class) and coproducts (sealed abstract class).
Refined types enforce constraints on values.
concrete functions can be defined in an implicit class to maintain left-to-right flow.
polymorphic functions are defined in typeclasses. Functionality is provided via “has a” context bounds, rather than “is a” class hierarchies.
typeclass instances are implementations of a typeclass.
@simulacrum.typeclass generates .ops on the companion, providing convenient syntax for typeclass functions.
typeclass derivation is compiletime composition of typeclass instances.</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-08 00:18:36 EEST
</div>
</div>
</body>
</html>
