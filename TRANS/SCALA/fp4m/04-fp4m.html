<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title>4. Дані та функціональність</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
<h1>4. Дані та функціональність</h1>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>В OOP ми звикли думати про дані та функціональність разом: ієрархії класів несуть методи, і трейти можуть вимагати, щоб існували поля даних. Поліморфізм часу виконання об'єкту є терміном відношення “є різновидом”, що вимагає, щоб класи наслідували від загальних інтерфейсів. Це може викликати плутанину при зростанні обсягу коду. Прості типи даних стають прихованими за сотнями рядків методів, міксіни трейтів потерпають від помилок порядку ініціалізації, та тестування / мокінг дуже пов'язаних компонент стає жахом.</p></div>
<div class="paragraph"><p>FP приймає інший підхід, визначаючи дані та функціональність окремо. В цій главі ми розглянемо основи типів даних, та переваги обмеження себе до підмножини мови Scala. Ми також дослідимо типокласи як спосіб досягти поліморфізм часу компіляції: думати про функціональність структури даних в термінах відношення “має”, скоріше, ніж “є різновидом”.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_4_1_">4.1 Дані</h2>
<div class="sectionbody">
<div class="paragraph"><p>Фундаментальні будівельні блоки типів даних є:</p></div>
<div class="ulist"><ul>
<li>
<p>
<code>final case class</code>, також відомі як продукти
</p>
</li>
<li>
<p>
<code>sealed abstract class</code>, також відомі як ко-продукти
</p>
</li>
<li>
<p>
<code>case object</code> та значення <code>Int</code>, <code>Double</code>, <code>String</code> (тощо) без методів або полів, крім параметрів конструктора. Ми обираємо абстрактні класи замість трейтів, щоб отримати кращу бінарну сумісність, та щоб перешкоджати міксуванню трейтів.
</p>
</li>
</ul></div>
<div class="paragraph"><p>Колективна назва для продуктів, ко-продуктів та значень є _Алгебраїчні типи даних_ (Algebraic Data Type, ADT).</p></div>
<div class="paragraph"><p>Ми компонуємо типи даних з логічної алгебри <code>AND</code> та <code>XOR</code> (виключне <code>OR</code>): продукт містить кожний тип, з яких він складається, але ко-продукт може бути тільки один. For example</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">product</span><span class="k">:</span> <span class="kt">ABC</span> <span class="o">=</span> <span class="n">a</span> <span class="nc">AND</span> <span class="n">b</span> <span class="nc">AND</span> <span class="n">c</span>
<span class="n">coproduct</span><span class="k">:</span> <span class="kt">XYZ</span> <span class="o">=</span> <span class="n">x</span> <span class="nc">XOR</span> <span class="n">y</span> <span class="nc">XOR</span> <span class="n">z</span>
</pre></div></div></div>
<div class="paragraph"><p>записане в Scala</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="c1">// значення</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">A</span>
  <span class="k">type</span> <span class="kt">B</span> <span class="o">=</span> <span class="nc">String</span>
  <span class="k">type</span> <span class="kt">C</span> <span class="o">=</span> <span class="nc">Int</span>

  <span class="c1">// продукт</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ABC</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">A.</span><span class="k">type</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">C</span><span class="o">)</span>

  <span class="c1">// ко-продукт</span>
  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">X</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">case</span> <span class="k">object</span> <span class="nc">Y</span> <span class="k">extends</span> <span class="nc">XYZ</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Z</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">XYZ</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="_4_1_1__adt">4.1.1 Рекурсівні ADT</h3>
<div class="paragraph"><p>Коли ADT посилається на себе, ми називаємо це Рекурсивним алгебраїчним типом даних (Recursive Algebraic Data Type).</p></div>
<div class="paragraph"><p><code>scalaz.IList</code>, безпечна альтернатива до <code>stdlib</code> <code>List</code>, є рекурсивною, оскікльи <code>ICons</code> містить посилання на <code>IList.</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="nc">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">INil</span><span class="o">[</span><span class="kt">A</span><span class="o">]()</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ICons</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_2___adt">4.1.2 Функції на ADT</h3>
<div class="paragraph"><p>ADT може містити чисті функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">UserConfiguration</span><span class="o">(</span><span class="n">accepts</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Але ADT, що мають функції, ідуть з деякими особистостями, бо вони не ідеально транслюються на JVM. Наприклад, старий <code>Serializable</code>, <code>hashCode</code>, <code>equals</code> та <code>toString</code> не поводяться так, як дехто може логічно очікувати.</p></div>
<div class="paragraph"><p>Нажаль, <code>Serializable</code> використовується в популярних фреймворках, не зважаючи на значно кращі альтернативи. Загальна пастка є забути, що  <code>Serializable</code> може спробувати селіалізувати ціле замикання функції, що може зламати промисловий сервер. Подібна специфіка стосується старих Java класів, таких як <code>Throwable</code>, що може нести посилання на довільні об'єкти.</p></div>
<div class="paragraph"><p>Ми будемо досліджувати альтернативи до старих методів, коли ми дискутуватимемо бібліотеку <code>Scalaz</code> в наступній главі, ціною втрати взаємодії з деяким старим кодом Java та Scala.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_3_">4.1.3 Вичерпність</h3>
<div class="paragraph"><p>Важливо, що ми використовуємо закоркований абстрактний клас, не просто абстрактний клас, коли визначаємо тип даних. Закоркування класу означає, що всі підтипи мають бути визначені в тому ж файлі, дозволяючи компілятору знати щодо них в вичерпному співпадінні шаблонів, та в макросах, що запобігають шаблонному коду. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Foo</span>
         <span class="k">final</span> <span class="k">case</span> <span class="k">object</span> <span class="nc">Baz</span> <span class="k">extends</span> <span class="nc">Foo</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>
  <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">match</span> <span class="kt">may</span> <span class="kt">not</span> <span class="kt">be</span> <span class="kt">exhaustive.</span>
  <span class="kt">It</span> <span class="kt">would</span> <span class="kt">fail</span> <span class="kt">on</span> <span class="kt">the</span> <span class="kt">following</span> <span class="kt">input:</span> <span class="kt">Baz</span>
         <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
                               <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це показує розробнику, що вони зламають речі, якщо вони додають новий продукт до коду. Ми використовуємо <code>-Xfatal-warnings</code>, інакше це тільки попередження.</p></div>
<div class="paragraph"><p>Однак компілятор не буде виконувати перевірку вичерпності, якщо клас не закоркований, або якщо стоять захисники, тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">thing</span><span class="o">(</span><span class="n">foo</span><span class="k">:</span> <span class="kt">Foo</span><span class="o">)</span> <span class="k">=</span> <span class="n">foo</span> <span class="k">match</span> <span class="o">{</span>
           <span class="k">case</span> <span class="nc">Bar</span><span class="o">(</span><span class="n">flag</span><span class="o">)</span> <span class="k">if</span> <span class="n">flag</span> <span class="k">=&gt;</span> <span class="kc">true</span>
         <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">thing</span><span class="o">(</span><span class="nc">Baz</span><span class="o">)</span>
  <span class="n">scala</span><span class="o">.</span><span class="nc">MatchError</span><span class="k">:</span> <span class="kt">Baz</span> <span class="o">(</span><span class="kt">of</span> <span class="kt">class</span> <span class="kt">Baz$</span><span class="o">)</span>
    <span class="kt">at</span> <span class="kt">.thing</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">15</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб залишатись в безпеці не використовуйте захисників на закоркованих типах.</p></div>
<div class="paragraph"><p>Флаг <code>-Xstrict-patmat-analysis</code> був запропонований як покращення мови для виконання додаткових перевірок співпадіння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_4_____">4.1.4 Альтернативні продукти та ко-продукти</h3>
<div class="paragraph"><p>Іншою формою продукта є тапл, що як непомічений фінальний кейс клас.</p></div>
<div class="paragraph"><p><code>(A.type, B, C)</code> еквівалентне до <code>ABC</code> в прикладі вище, але краще використовувати фінальний кейс клас як частини ADT, оскільки брак імен ускладнює справи, і кейс клас має значно кращу продуктивність для примітивних значень.</p></div>
<div class="paragraph"><p>Інша форма ко-продукта утворюється, коли ми вкладаємо типи <code>Either</code>. Тобто:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="nc">Either</span><span class="o">[</span><span class="kt">X.</span><span class="k">type</span>, <span class="kt">Either</span><span class="o">[</span><span class="kt">Y.</span><span class="k">type</span>, <span class="kt">Z</span><span class="o">]]</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до закоркованого абстрактного класу <code>XYZ</code>. Ясніший синтаксис для визначення вкладених типів <code>Either</code> є створення псевдониму типу, що завершується на двокрапку, дозволяючи інфіксну нотацію з правою асоціацією:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">|:</span><span class="o">[</span><span class="kt">L</span>,<span class="kt">R</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Either</span><span class="o">[</span><span class="kt">L</span>, <span class="kt">R</span><span class="o">]</span>

  <span class="n">X</span><span class="o">.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Y.</span><span class="k">type</span> <span class="kt">|:</span> <span class="kt">Z</span>
</pre></div></div></div>
<div class="paragraph"><p>Це корисно для створення анонімних ко-продуктів, коли ми не можемо покласти всі реалізації в той самий джерельний файл.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Accepted</span> <span class="o">=</span> <span class="nc">String</span> <span class="o">|:</span> <span class="nc">Long</span> <span class="o">|:</span> <span class="nc">Boolean</span>
</pre></div></div></div>
<div class="paragraph"><p>І ще один альтернативний ко-продукт є створення власного закоркованого абстрактного класу з фінальним кейс класом, що просто огортає бажаний тип:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedString</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedLong</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">AcceptedBoolean</span><span class="o">(</span><span class="n">value</span><span class="k">:</span> <span class="kt">Boolean</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Accepted</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів на ціх формах ко-продуктів може бути тендітним, ось чому були досліджені <em>Union Types</em> в <code>Dotty</code>, компіляторі Scala наступного покоління. Макроси, такі як <code>totalitarian</code> та <code>iotaz</code> існують як альтернативні шляхи кодування анонімних ко-продуктів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_5__">4.1.5 Подача інформації</h3>
<div class="paragraph"><p>Окрім функції контейнера для потрібної бізнес інформації, типи даних можуть використовуватись для кодування обмежень. Наприклад,</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">NonEmptyList</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">A</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">IList</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span>
</pre></div></div></div>
<div class="paragraph"><p>ніколи не може бути порожнім. Це робить <code>scalaz.NonEmptyList</code> корисним типом даних, що містить ту саму інформацію, що і <code>IList</code>.</p></div>
<div class="paragraph"><p>Продуктові типи часто містять типи, що значно більш загальні, ніж дозволено. В традиційному OOP це може бути оброблене за допомогою валідації вводу через припущення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="c1">// руйнує загальність, не робіть цього!</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Замість цього ми можемо використовувати тип даних <code>Either</code> щоб провадити <code>Right[Person]</code> для валідних примірників, та захиститись від просування навалідних примірників. Зауважте, що конструктор приватний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span> <span class="k">private</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">object</span> <span class="nc">Person</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Either</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Person</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">name</span><span class="o">.</span><span class="n">nonEmpty</span> <span class="o">&amp;&amp;</span> <span class="n">age</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="nc">Right</span><span class="o">(</span><span class="k">new</span> <span class="nc">Person</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">age</span><span class="o">))</span>
      <span class="k">else</span> <span class="nc">Left</span><span class="o">(</span><span class="s">s&quot;bad input: </span><span class="si">$name</span><span class="s">, </span><span class="si">$age</span><span class="s">&quot;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">welcome</span><span class="o">(</span><span class="n">person</span><span class="k">:</span> <span class="kt">Person</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="s">s&quot;</span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s"> you look wonderful at </span><span class="si">${</span><span class="n">person</span><span class="o">.</span><span class="n">age</span><span class="si">}</span><span class="s">!&quot;</span>

  <span class="k">for</span> <span class="o">{</span>
    <span class="n">person</span> <span class="k">&lt;-</span> <span class="nc">Person</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
  <span class="o">}</span> <span class="k">yield</span> <span class="n">welcome</span><span class="o">(</span><span class="n">person</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_5_1___">4.1.5.1 Очищені типи даних</h3>
<div class="paragraph"><p>Чіткий спосіб обмежити значення загального типу можливо за допомогою бібліотеки <code>refined</code>, провадячи сюїту обмежень до вмісту даних. Щоб встановити <code>refined</code>, додайте наступне до <code>build.sbt</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;eu.timepit&quot;</span> <span class="o">%%</span> <span class="s">&quot;refined-scalaz&quot;</span> <span class="o">%</span> <span class="s">&quot;0.9.2&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>та наступні імпорти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">eu.timepit.refined</span>
  <span class="k">import</span> <span class="nn">refined.api.Refined</span>
</pre></div></div></div>
<div class="paragraph"><p><code>Refined</code> дозволяє визначити <code>Person</code> використовуючи створені на льоту очищені типи, щоб захопити вимоги в точності, записуючи <code>A Refined B</code>.</p></div>
<div class="paragraph"><p>Всі типи з двома параметрами можуть бути записані інфіксно в Scala. Наприклад, <code>Either[String, Int]</code> є те саме, що <code>String Either Int</code>. За домовленостю <code>Refined</code> записується інфіксно, оскільки <code>A Refined B</code> можна прочитати як “<code>A</code>, що відповідає вимогам, визначеним в `B`”.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.numeric.Positive</span>
  <span class="k">import</span> <span class="nn">refined.collection.NonEmpty</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span>
    <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span><span class="o">,</span>
    <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">Positive</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Підлегле значення можна отримати за допомогою <code>.value</code>. Ми можемо конструювати значення від час виконання з використанням <code>.refineV</code>, повертаючи <code>Either</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">refined.refineV</span>
  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">refineV</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">](</span><span class="s">&quot;&quot;</span><span class="o">)</span>
  <span class="nc">Left</span><span class="o">(</span><span class="nc">Predicate</span> <span class="n">isEmpty</span><span class="o">()</span> <span class="n">did</span> <span class="n">not</span> <span class="n">fail</span><span class="o">.)</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="n">refineV</span><span class="o">[</span><span class="kt">NonEmpty</span><span class="o">](</span><span class="s">&quot;Sam&quot;</span><span class="o">)</span>
  <span class="nc">Right</span><span class="o">(</span><span class="nc">Sam</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ми додамо наступний імпорт:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.auto._</span>
</pre></div></div></div>
<div class="paragraph"><p>ми можемо конструювати валідні значення під час компіляції, та отримати помилку, якщо надамо значення, що не відповідає вимогам:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">sam</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span> <span class="o">=</span> <span class="s">&quot;Sam&quot;</span>
  <span class="nc">Sam</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">empty</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">NonEmpty</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
  <span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Predicate</span> <span class="kt">isEmpty</span><span class="o">()</span> <span class="kt">did</span> <span class="kt">not</span> <span class="kt">fail.</span>
</pre></div></div></div>
<div class="paragraph"><p>Можливо захопити більш складні вимоги, наприклад, ми можемо використовувати вбудоване правило <code>MaxSize</code> з наступними імпортами:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">refined.W</span>
  <span class="k">import</span> <span class="nn">refined.boolean.And</span>
  <span class="k">import</span> <span class="nn">refined.collection.MaxSize</span>
</pre></div></div></div>
<div class="paragraph"><p>захоплюючі вимогу, що <code>String</code> має бути одночасно непорожнім та мати максимальний розмір 10 символів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Name</span> <span class="o">=</span> <span class="nc">NonEmpty</span> <span class="nc">And</span> <span class="nc">MaxSize</span><span class="o">[</span><span class="kt">W.`10`.T</span><span class="o">]</span>

  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Person</span><span class="o">(</span>
    <span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">Refined</span> <span class="kt">Name</span><span class="o">,</span>
    <span class="n">age</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">Positive</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Нотація <code>W</code> є скороченим для “witness” (<em>засвідчити</em>). Цей синтаксис буде значно простіший в Scala 2.13, що має підтримку для літеральних типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">type</span> <span class="kt">Name</span> <span class="o">=</span> <span class="nc">NonEmpty</span> <span class="nc">And</span> <span class="nc">MaxSize</span><span class="o">[</span><span class="err">10</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Просто визначити визначення власних вимог, що не охоплені бібліотекою  <code>refined</code>. Наприклад, в <code>drone-dynamaic-agents</code> нам знадобиться спосіб переконатись, що <code>String</code> містить <code>application/x-www-form-urlencoded</code>. Ми можемо створити правило <code>Refined</code>, використовуючи бібліотеку регулярних виразів Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">UrlEncoded</span>
  <span class="k">object</span> <span class="nc">UrlEncoded</span> <span class="o">{</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">val</span> <span class="n">valid</span><span class="k">:</span> <span class="kt">Pattern</span> <span class="o">=</span>
      <span class="nc">Pattern</span><span class="o">.</span><span class="n">compile</span><span class="o">(</span><span class="s">&quot;\\A(\\p{Alnum}++|[-.*_+=&amp;]++|%\\p{XDigit}{2})*\\z&quot;</span><span class="o">)</span>

    <span class="k">implicit</span> <span class="k">def</span> <span class="n">urlValidate</span><span class="k">:</span> <span class="kt">Validate.Plain</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">UrlEncoded</span><span class="o">]</span> <span class="k">=</span>
      <span class="nc">Validate</span><span class="o">.</span><span class="n">fromPredicate</span><span class="o">(</span>
        <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">valid</span><span class="o">.</span><span class="n">matcher</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">find</span><span class="o">(),</span>
        <span class="n">identity</span><span class="o">,</span>
        <span class="k">new</span> <span class="nc">UrlEncoded</span> <span class="o">{}</span>
      <span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_1_6__">4.1.6 Поділяти просто</h3>
<div class="paragraph"><p>Не провадячи жодної функціональності, ADT можуть мати мінімальний набір залежностей. Це робить простим їх публікацію та поділення з іншими розробниками. Через використання простої мови моделювання даних, стає можливим взаємодія з між-галужевими командами, такими як DBA, розробники UI та бізнес аналітики, використовуючи справжній код замість рукописного документу в якості джерела істини.</p></div>
<div class="paragraph"><p>Більше того, інструментарій може бути написаний більш просто для продукування або споживання схем від інших мов програмування та дротових протоколів.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_7__">4.1.7 Підрахунок складності</h3>
<div class="paragraph"><p>Складність типу даних є підрахунок значень, що можуть існувати. Гарний тип даних має найменьшу кількість складності, якій потрібен для утримання інформації, що має передаватись, і не більше.</p></div>
<div class="paragraph"><p>Значення мають вбудовану складність:</p></div>
<div class="paragraph"><p><code>Unit</code> має одне значення (чому він і називається “одиничний”)
<code>Boolean</code> має два значення
<code>Int</code> має 4,294,967,295 значень
<code>String</code> ефективно має безліч значень</p></div>
<div class="paragraph"><p>Щоб знайти складність продкуту ми перемножуємо складність кожної частини.</p></div>
<div class="paragraph"><p>(<code>Boolean</code>, <code>Boolean</code>) має 4 значення (2*2)
(<code>Boolean</code>, <code>Boolean</code>, <code>Boolean</code>) має 8 значень (2*2*2)</p></div>
<div class="paragraph"><p>Щоб знайти складність ко-продукту, ми додаємо складність кожної частини.</p></div>
<div class="paragraph"><p>(<code>Boolean</code> |: <code>Boolean</code>) має 4 значення (2+2)
(<code>Boolean</code> |: <code>Boolean</code> |: <code>Boolean</code>) має 6 значень (2+2+2)</p></div>
<div class="paragraph"><p>Щоб знайти складність ADT з параметром типу, помножте кожну частину на складність параметру типу:</p></div>
<div class="paragraph"><p><code>Option[Boolean]</code> має 3 значення, <code>Some[Boolean]</code> та <code>None</code> (2+1)</p></div>
<div class="paragraph"><p>В FP функції повні та мають повертати значення для кожного вводу, не <code>Exception</code>. Мінімізація складності входів та виходів є кращим способом досягти загальності. Як правило великого пальця, це знак поганої розробки функції, якщо складність поверненного значення функції більша, ніж складність продукту вхідних значень: це джерело ентропії.</p></div>
<div class="paragraph"><p>Складність загальної функції є число можливих функцій, що можуть задовільнити сигнатурі типу: вихід в ступіні вводу.</p></div>
<div class="paragraph"><p><code>Unit =&gt; Boolean</code> має складність 2
<code>Boolean =&gt; Boolean</code> має складність 4
<em>Option[Boolean] &#8658; Option[Boolean]</em> має складність 27
<code>Boolean =&gt; Int</code> має складність квантіліон на секстіліон.
<code>Int =&gt; Boolean</code> має таку складність, що якщо всі реалізації мали б порядковий номер, кожний мав би 4Гб в довжину.</p></div>
<div class="paragraph"><p>В реальності <code>Int =&gt; Boolean</code> буде дечим простим, як <code>isOdd</code>, <code>isEven</code> або розріжений <code>BitSet</code>. Ця функція, коли використовується в ADT, краще може бути замінена на ко-продукт, який маркує обмежену множину функцій, що є релевантними.</p></div>
<div class="paragraph"><p>Коли складність є “безкінечність на вході, безкінечність на виході”, нам треба ввести обмежувальні типи даних та валідацію ближче до точки входу за допомогою <code>Refined</code> з попереднього розділу.</p></div>
<div class="paragraph"><p>Здантість порахувати складність сигнатури типу має одне інше практичне застосування: ми можемо знайти простіші сигнатури типів за допомогою алгебри вищої школи! Щоб перейти від сигнатури типу до її алгебри складності, просто замініть:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="n">на</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
<span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span> <span class="n">на</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
<span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="n">на</span> <span class="n">b</span> <span class="o">^</span> <span class="n">a</span>
</pre></div></div></div>
<div class="paragraph"><p>зробіть деякі перестановки, та конвертуйте назад. Наприклад, скажімо, ми розробили фреймворк що базується на зворотніх викликах, і ми поставили себе в ситуацію, коли ми створили наступну сигнатуру типу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">A</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">((</span><span class="n">B</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можемо конвертувати та переставити її так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">b</span><span class="o">))</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">a</span><span class="o">)</span>
  <span class="k">=</span> <span class="n">c</span> <span class="o">^</span> <span class="o">((</span><span class="n">c</span> <span class="o">^</span> <span class="n">b</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="n">a</span><span class="o">))</span>
  <span class="k">=</span> <span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">c</span> <span class="o">^</span> <span class="o">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>потім конвертувати назад до типів та отримати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="nc">Either</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">C</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>що значно простіше: ми тільки просимо користувачів нашого фреймфорку провадити <code>Either[A, B] =&gt; C</code>.</p></div>
<div class="paragraph"><p>Той самий хід думок може бути використаний для перевірки, що:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">B</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>еквівалентне до</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">B</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">C</span>
</pre></div></div></div>
<div class="paragraph"><p>що також відоме як <em>карування</em>.</p></div>
</div>
<div class="sect2">
<h3 id="_4_1_8_____">4.1.8 Обирайте ко-продукти замість продуктів</h3>
<div class="paragraph"><p>Архітепічне моделювання проблем, що постає здебільшо коли існують взаємно виключні параметри конфігурації <code>a</code>, <code>b</code> та <code>c</code>. Продукт <code>(a: Boolean, b: Boolean, c: Boolean)</code> має складність 8, тоді як ко-продукт</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Config</span>
  <span class="k">object</span> <span class="nc">Config</span> <span class="o">{</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Config</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">B</span> <span class="k">extends</span> <span class="nc">Config</span>
    <span class="k">case</span> <span class="k">object</span> <span class="nc">C</span> <span class="k">extends</span> <span class="nc">Config</span>
  <span class="o">}</span>
<span class="n">має</span> <span class="n">складність</span> <span class="mf">3.</span> <span class="n">Краще</span> <span class="n">моделювати</span> <span class="n">ці</span> <span class="n">параметри</span> <span class="n">конфігурації</span> <span class="n">як</span> <span class="n">ко</span><span class="o">-</span><span class="n">продукт</span><span class="o">,</span> <span class="n">ніж</span> <span class="n">дозволити</span> <span class="n">існування</span> <span class="n">п</span><span class=" -Symbol">&#39;яти</span> <span class="n">невалідних</span> <span class="n">станів</span><span class="o">.</span>

<span class="n">Складність</span> <span class="n">типу</span> <span class="n">даних</span> <span class="n">також</span> <span class="n">має</span> <span class="n">вплив</span> <span class="n">на</span> <span class="n">тестування</span><span class="o">.</span> <span class="n">Практично</span> <span class="n">неможливо</span> <span class="n">тестувати</span> <span class="n">кожний</span> <span class="n">можливий</span> <span class="n">вхід</span> <span class="n">до</span> <span class="n">функції</span><span class="o">,</span> <span class="n">але</span> <span class="n">просто</span> <span class="n">тестувати</span> <span class="n">примірник</span> <span class="n">значень</span> <span class="n">за</span> <span class="n">допомогою</span> <span class="n">фреймворка</span> <span class="n">тестування</span> <span class="n">властивостей</span> <span class="n">`Scalacheck`</span><span class="o">.</span> <span class="n">Якщо</span> <span class="n">випадковий</span> <span class="n">примірник</span> <span class="n">типу</span> <span class="n">даних</span> <span class="n">має</span> <span class="n">низьку</span> <span class="n">вірорідність</span> <span class="n">бути</span> <span class="n">валідним</span><span class="o">,</span> <span class="n">це</span> <span class="n">знак</span><span class="o">,</span> <span class="n">що</span> <span class="n">дані</span> <span class="n">змодельовані</span> <span class="n">некоректно</span><span class="o">.</span>

<span class="mf">4.1</span><span class="o">.</span><span class="mi">9</span> <span class="n">Оптимізації</span>
<span class="o">~~~~~~~~~~~~~~~~~</span>
<span class="n">Велика</span> <span class="n">перевага</span> <span class="n">від</span> <span class="n">використання</span> <span class="n">спрощеної</span> <span class="n">підмножини</span> <span class="n">мови</span> <span class="nc">Scala</span> <span class="n">для</span> <span class="n">представлення</span> <span class="n">типів</span> <span class="n">даних</span> <span class="n">в</span> <span class="n">тому</span><span class="o">,</span> <span class="n">що</span> <span class="n">інструментарій</span> <span class="n">може</span> <span class="n">оптимізувати</span> <span class="n">репрезентацію</span> <span class="n">байткоду</span> <span class="nc">JVM</span><span class="o">.</span>

<span class="n">Наприклад</span><span class="o">,</span> <span class="n">ми</span> <span class="n">можемо</span> <span class="n">запакувати</span> <span class="n">поля</span> <span class="n">`Boolean`</span> <span class="n">та</span> <span class="n">`Option`</span> <span class="n">в</span> <span class="n">`Array[Byte]`</span><span class="o">,</span> <span class="n">кешувати</span> <span class="n">значення</span><span class="o">,</span> <span class="n">запам</span><span class=" -Symbol">&#39;ятати</span> <span class="n">`hashCode`</span><span class="o">,</span> <span class="n">оптимізувати</span> <span class="n">`equals`</span><span class="o">,</span> <span class="n">використовувати</span> <span class="n">твердження</span> <span class="n">`@switch`</span> <span class="n">при</span> <span class="n">порівнянні</span> <span class="n">шаблонів</span><span class="o">,</span> <span class="n">та</span> <span class="n">багато</span> <span class="n">іншого</span><span class="o">.</span>

<span class="n">Ці</span> <span class="n">оптимізації</span> <span class="n">неможливо</span> <span class="n">застосувати</span> <span class="n">для</span> <span class="n">ієрархій</span> <span class="n">класів</span> <span class="nc">OOP</span><span class="o">,</span> <span class="n">що</span> <span class="n">можуть</span> <span class="n">керувати</span> <span class="n">станом</span><span class="o">,</span> <span class="n">закидати</span> <span class="n">виключення</span> <span class="n">або</span> <span class="n">провадити</span> <span class="n">adhoc</span> <span class="n">реалізції</span> <span class="n">методів</span><span class="o">.</span>

<span class="mf">4.2</span> <span class="n">Функціональність</span>
</pre></div></div></div>
<div class="paragraph"><p>Чисті функції типово визначаються як методи на об'єкті.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">package</span> <span class="nn">object</span> <span class="n">math</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак буде незручним використовувати методи об'єкта, оскільки це читається зсередини-назовні, не зліва направо. На додаток функція на об'єкті краде простір імен. Якщо ми визначимо <code>sin(t: T)</code> будь-де ще, ми отримаємо помилку невизначенності посилання. Це та сама проблема, що і статичні методи в Java vs методів классу.</p></div>
<div class="paragraph"><p>Різновид розробників, що складють методи в трейт, та вимагають від користувачів міксувати їх за допомогою шаблону кекса, прямують прямо до пекла. Це дає витік внутрішніх деталей реалізації до публічних API,заплутує байткод, робить двоїчну сумісність в основному неможливою, та засмучує  автодоповнювач IDE.</p></div>
<div class="paragraph"><p>З можливістю мови щодо неявних класів (також відомою як методологія або синтаксис розширення), та невеликим шаблоном ми можемо отримати знайомий стиль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="n">scala</span><span class="o">&gt;</span> <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
           <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
         <span class="o">}</span>

  <span class="n">scala</span><span class="o">&gt;</span> <span class="o">(</span><span class="mf">1.0</span><span class="o">).</span><span class="n">sin</span>
  <span class="n">res</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.8414709848078965</span>
</pre></div></div></div>
<div class="paragraph"><p>Часто краще просто пропустити визначення об'єкта, та перейти прямо до неявного класу, утримуючи шаблонний код на мінімумі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>неявний клас є синтаксичним цукром до неявного перетворення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">DoubleOps</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Що, нажаль, має вартість під час виконання: кожний раз, коли викликається метод розширення, посередник <code>DoubleOps</code> буде конструюватись та потів відкидатись геть. Це може докластись до тиску на GC в гарячих точках.</p></div>
<div class="paragraph"><p>Існує трохи більш балаклива форма неявних класів, що уникає розміщення, і, таким чином, більш бажана:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">final</span> <span class="k">class</span> <span class="nc">DoubleOps</span><span class="o">(</span><span class="k">private</span> <span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">sin</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">sin</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_4_2_1__">4.2.1 Поліморфні функції</h3>
<div class="paragraph"><p>Більш загальний різновид функцій є поліморфні функції, що живуть в _типокласах_. Типоклас є трейт, що:</p></div>
<div class="ulist"><ul>
<li>
<p>
не збурігає стан
</p>
</li>
<li>
<p>
має параметр типу
</p>
</li>
<li>
<p>
має щонайменьше один абстрактний метод (примітивні комбінатори)
</p>
</li>
<li>
<p>
може містити узагальнені методи (похідні комбінатори)
</p>
</li>
<li>
<p>
може розширювати інший типоклас
</p>
</li>
</ul></div>
<div class="paragraph"><p>Є тільки одна реалізація типокласу для любого даного параметру типу, властивість, відома під назвою когерентність типокласу. Типокласи  виглядають напрочуд подібно до алгебраїчних інтерфейсів, але алгебри не обов'язково мають бути когерентними.</p></div>
<div class="paragraph"><p>Когенентність типокласів в основному відноситься до узгодженості, і узгодженість дає нам впевненість для використання неявних параметрів. Може бути складним продумувати код, що виконується по різному на неявних імпортах в полі зору. Когерентність типокласів насправді каже, що імпорти не повинні впливати на поведінку коду.</p></div>
<div class="paragraph"><p>Додатково, когерентність типокласів дозволяє нам глобально кешувати неявні під час виконання, та зберігати розміщення пам'яті, отримуючи покращення продуктивності від зменшеного тиску на збирача сміття.</p></div>
<div class="paragraph"><p>Типокласи використовуються в Scala <code>stdlib</code>. Ми дослідимо спрощену версію <code>scala.math.Numeric</code> для демонстрації принципу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">trait</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>

    <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="o">}</span>

  <span class="k">trait</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">T</span>

    <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">zero</span><span class="o">))</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми можмо бачити всі ключові властивості типокласу в дії:</p></div>
<div class="ulist"><ul>
<li>
<p>
немає стану
</p>
</li>
<li>
<p>
<code>Ordering</code> та <code>Numeric</code> мають параметр типу <code>T</code>
</p>
</li>
<li>
<p>
<code>Ordering</code> має абстрактне <code>compare</code>, та <code>Numeric</code> має абстрактні <code>plus</code>, <code>times</code>, <code>negate</code> та <code>zero</code>
</p>
</li>
<li>
<p>
<code>Ordering</code> визначає узагальнені <code>lt</code> та <code>gt</code> базовані на <code>compare</code>, <code>Numeric</code> визначає <code>abs</code> в термінах <code>lt</code>, <code>negate</code> та <code>zero</code>.
</p>
</li>
<li>
<p>
<code>Numeric</code> розширює <code>Ordering</code>
</p>
</li>
</ul></div>
<div class="paragraph"><p>Тепер ми можемо писати функції для типів, що “має” типоклас <code>Numeric</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">N</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">N._</span>
    <span class="n">times</span><span class="o">(</span><span class="n">negate</span><span class="o">(</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)),</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ми більше не залежимо від ієрархії OOP від наших вхідних типів, тобто, ми не вимагаємо, щоб наш вхід “був” <code>Numeric</code>, що є критично важливим, якщо ми бажаємо підтримати клас третіх сторін, який ми не можемо перевизначити.</p></div>
<div class="paragraph"><p>Інша перевага типокласів в тому, що асоціація функціональності до даних відбувається під час компіляції, на відміну від рантайм динамічної диспечерізації OOP.</p></div>
<div class="paragraph"><p>Наприклад, хоча клас <code>List</code> може мати лише одну реалізацію метода, метод типокласу дозволяє нам мати різні реалізації в залежності від вмісту <code>List</code>, і, таким чином, перекласти навантаження на час компіляції, замість залишати його на рантайм.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_2_">4.2.2 Синтаксис</h3>
<div class="paragraph"><p>Синтаксис для написання <code>signOfTheTimes</code> є заплутаним, існують деякі речі, які ми можемо зробити, щоб розчистити його.</p></div>
<div class="paragraph"><p>Нижні користувачі будуть краще бачити наш метод, як використовуючий межі контексту, оскільки сигнатура ясно читається як “приймає <code>T</code>, що має `Numeric`”</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>але тепер ми маємо будь-де використовувати <code>implicitly[Numeric[T]]</code>. Через визначення шаблонного коду на компанйоні типокласу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">Numeric</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">numeric</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">numeric</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>ми можемо отримати неявне з меньшим шумом</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="k">import</span> <span class="nn">N._</span>
    <span class="n">times</span><span class="o">(</span><span class="n">negate</span><span class="o">(</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)),</span> <span class="n">t</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Але це все ще гірше для нас, як для реалізаторів. Ми маємо синтаксичну проблему статичних методів зсередини-назовні vs методів класів. Ми маємо справу з цім через введення <code>ops</code> на компанйоні типокласу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">object</span> <span class="nc">Numeric</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="k">implicit</span> <span class="n">numeric</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">numeric</span>

    <span class="k">object</span> <span class="nc">ops</span> <span class="o">{</span>
      <span class="k">implicit</span> <span class="k">class</span> <span class="nc">NumericOps</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">N</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
        <span class="k">def</span> <span class="o">+(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">plus</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="o">*(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">times</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="n">unary_-:</span> <span class="n">T</span> <span class="k">=</span> <span class="n">N</span><span class="o">.</span><span class="n">negate</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>
        <span class="k">def</span> <span class="n">abs</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">abs</span><span class="o">(</span><span class="n">t</span><span class="o">)</span>

        <span class="c1">// дублікація з Ordering.ops</span>
        <span class="k">def</span> <span class="o">&lt;(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">lt</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
        <span class="k">def</span> <span class="o">&gt;(</span><span class="n">o</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">N</span><span class="o">.</span><span class="n">gt</span><span class="o">(</span><span class="n">t</span><span class="o">,</span> <span class="n">o</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, <code>-x</code> розширюється до <code>x.unary_-</code> через компіляторний синтаксичний синтаксис, через що ми визначаємо <code>unary_-</code> як метод розширення. Тепер ми можемо записати значно ясніше:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">Numeric.ops._</span>
  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">-(</span><span class="n">t</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span> <span class="o">*</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Гарна новина в тому, що нам ніколи не треба писати цей код, оскільки <code>Simulacrum</code> провадить макро анотацію <code>@typeclass</code>, що автоматично генерує <code>apply</code> та <code>ops</code>. Він навіть дозволяє нам визначити альтернативні імена (звичайно символічні) для загальних методів. Загалом:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">simulacrum._</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;&gt;&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="o">}</span>

  <span class="nd">@typeclass</span> <span class="k">trait</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Ordering</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="nd">@op</span><span class="o">(</span><span class="s">&quot;unary_-&quot;</span><span class="o">)</span> <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">T</span>
    <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">zero</span><span class="o">))</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">else</span> <span class="n">x</span>
  <span class="o">}</span>

  <span class="k">import</span> <span class="nn">Numeric.ops._</span>
  <span class="k">def</span> <span class="n">signOfTheTimes</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">](</span><span class="n">t</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">-(</span><span class="n">t</span><span class="o">.</span><span class="n">abs</span><span class="o">)</span> <span class="o">*</span> <span class="n">t</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер коли є власний символічний <code>@op</code>, він має вимовлятись як ім'я метода. Тобто, <code>&lt;</code> вимовляється “меньше ніж”, не “ліва кутова дужка”.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_3_">4.2.3 Примірники</h3>
<div class="paragraph"><p>Примірники <code>Numeric</code> (що також є примірниками <code>Ordering</code>) визначаються як <code>implicit val</code>, що розширює типоклас, та може провадити оптимізовану реалізації для узагальнених методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">NumericDouble</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="n">x</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Double</span><span class="o">.</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>

    <span class="c1">// оптимізовано</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">lt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">gt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span>
    <span class="k">override</span> <span class="k">def</span> <span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="nc">Math</span><span class="o">.</span><span class="n">abs</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Хоча ми тут використовуємо <code>+</code>, <code>*</code>, <code>unary_-</code>, <code>&lt;</code> та <code>&gt;</code>, що є <code>ops</code> (і може бути безкінечний цикл!), ці методи вже існують на <code>Double</code>. Методи класів завжди використовуються з перевагою над методами розширення. Зрозуміло, що компілятор Scala виконує особливу обробку примітивів, та конвертує ці методи до сирих байткод інструкцій <code>dadd</code>, <code>dmul</code>, <code>dcmpl</code> та <code>dcmpg</code>, відповідно.</p></div>
<div class="paragraph"><p>Ми також можемо реалізувати <code>Numeric</code> для Java класу <code>BigDecimal</code> (уникайте <code>scala.BigDecimal</code>, він фундаментально хибний)</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">import</span> <span class="nn">java.math.</span><span class="o">{</span> <span class="nc">BigDecimal</span> <span class="k">=&gt;</span> <span class="nc">BD</span> <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">val</span> <span class="nc">NumericBD</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">BD</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">BD</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">multiply</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">negate</span>
    <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">BD</span> <span class="o">=</span> <span class="nc">BD</span><span class="o">.</span><span class="nc">ZERO</span>
    <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">BD</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">BD</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">compareTo</span><span class="o">(</span><span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете створити нашу власну структуру даних для комплексних чисел:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">r</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">i</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Та наслідувати <code>Numeric[Complex[T]]</code>, якщо існує <code>Numeric[T]</code>. Оскільки ці примірники залежать від параметру типа, це <code>def</code>, не <code>val</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">numericComplex</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">Numeric</span><span class="o">]</span><span class="k">:</span> <span class="kt">Numeric</span><span class="o">[</span><span class="kt">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">type</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
      <span class="k">def</span> <span class="n">plus</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">times</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span>
        <span class="nc">Complex</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span> <span class="o">+</span> <span class="o">(-</span><span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">),</span> <span class="n">x</span><span class="o">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">i</span> <span class="o">*</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(-</span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="o">-</span><span class="n">x</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">zero</span><span class="k">:</span> <span class="kt">CT</span> <span class="o">=</span> <span class="nc">Complex</span><span class="o">(</span><span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">zero</span><span class="o">,</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">zero</span><span class="o">)</span>
      <span class="k">def</span> <span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">CT</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">CT</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
        <span class="k">val</span> <span class="n">real</span> <span class="k">=</span> <span class="o">(</span><span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">r</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="n">r</span><span class="o">))</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">real</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">real</span>
        <span class="k">else</span> <span class="nc">Numeric</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">compare</span><span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">i</span><span class="o">,</span> <span class="n">y</span><span class="o">.</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Спостережливий читач може зауважити, що <code>abs</code> взагалі не те, що може очікувати математик. Коректне повернуте значення для <code>abs</code> має бути <code>T</code>, не <code>Complex[T]</code>.</p></div>
<div class="paragraph"><p><code>scala.math.Numeric</code> намагається робити дуже багато, і не узагальнує за межами дійсних чисел. Це гарний урок того, що меньші, гарно визначені типокласи часто кращі, ніж монолітні колекції дуже специфічних можливостей.</p></div>
</div>
<div class="sect2">
<h3 id="_4_2_4__">4.2.4 Розрішення неявних</h3>
<div class="paragraph"><p>Ми гарно обсудили неявні: цей розділ призначений для прояснення, що таке неявні, та як вони роблять.</p></div>
<div class="paragraph"><p>Коли метод запитує, щоб в полі зору викликаючого знаходився унікальний примірник певного типу, неявні параметри є особливим синтаксисом для примірників типокласів. Неявні параметри є ясним шляхом конфігурації потоку через застосування.</p></div>
<div class="paragraph"><p>В цьому прикладі <code>foo</code> потребує, щоб для <code>A</code> були доступні примірники типокласів <code>Numeric</code> та <code>Typeable</code>, так само, як неявний об'єкт <code>Handler</code>, що приймає два параметри типів</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span>  <span class="k">def</span> <span class="n">foo</span><span class="o">[</span><span class="kt">A:</span> <span class="kt">Numeric:</span> <span class="kt">Typeable</span><span class="o">](</span><span class="k">implicit</span> <span class="n">A</span><span class="k">:</span> <span class="kt">Handler</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">A</span><span class="o">])</span> <span class="k">=</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Неявне перетворення відбувається коли існує <code>implicit def</code>. Один такий випадок неявного перетворення є використання методології розширення. Коли компілятор розрішує виклик метода, він спочатку перевіряє, чи метод існує для типу, потім для предків (Java-подібні правила). Якщо він не зможе знайти співпадіння, він буде шукати неявне поле зору для перетворень до інших типів, потім шукає серед методів на ціх типах.</p></div>
<div class="paragraph"><p>Інше використання для неявних перетворень є похідні типокласи. В попередньому розділі ми написали неявний <code>def</code>, що походить від <code>Numeric[Complex[T]]</code>, якщо <code>Numeric[T]</code> існує в неявному полі зору. Можливо зціпити разом декілька <code>implicit def</code> (включаючи рекурсію), що є базисом типованого програмування, дозволяючи виконання обчислень під час компіляціїї, замість рантайму.</p></div>
<div class="paragraph"><p>Клей, що зліплює неявні параметри (отримувачі) з неявними перетвореннями (провайдерами) є розрішення неявних.</p></div>
<div class="paragraph"><p>Зпочатку шукається звичане поле зору змінної, по порядку:</p></div>
<div class="ulist"><ul>
<li>
<p>
локальне поле зору, включаючи локальні імпорти (тобто блок або метод)
</p>
</li>
<li>
<p>
зовнішнє поле зору, включаючи імпорти в цій області (тобто члени в класі)
</p>
</li>
<li>
<p>
предки (тобто члени в суер класі)
</p>
</li>
<li>
<p>
поточний об'єкт пакаунку
</p>
</li>
<li>
<p>
об'єкти батьківських пакунків (коли використовуються вкладені пакунки)
</p>
</li>
<li>
<p>
імпорти файлу
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо пошук співпадіння схибить, шукається особливе поле зору, що виглядає неявні примірники в компанйоні типу, його об'єкті пакунку, зовнішні об'єкти (якщо вкладені), та потім повторюється для предків. Це виконується в тому ж порядку для:</p></div>
<div class="ulist"><ul>
<li>
<p>
даного типу параметра
</p>
</li>
<li>
<p>
очікуваного параметру типу
</p>
</li>
<li>
<p>
параметру типу (якщо такий існує)
</p>
</li>
</ul></div>
<div class="paragraph"><p>Якщо знайдено два співпадаючих неявних в тій самій фазі розрішення неявного, закидається помилка неявного.</p></div>
<div class="paragraph"><p>Implicits are often defined on a trait, which is then extended by an object. This is to try and control the priority of an implicit relative to another more specific one, to avoid ambiguous implicits.</p></div>
<div class="paragraph"><p>The Scala Language Specification is rather vague for corner cases, and the compiler implementation is the de facto standard. There are some rules of thumb that we will use throughout this book, e.g. prefer implicit val over implicit object despite the temptation of less typing. It is a quirk of implicit resolution that implicit object on companion objects are not treated the same as implicit val.</p></div>
<div class="paragraph"><p>Implicit resolution falls short when there is a hierarchy of typeclasses, like Ordering and Numeric. If we write a function that takes an implicit Ordering, and we call it for a primitive type which has an instance of Numeric defined on the Numeric companion, the compiler will fail to find it.</p></div>
<div class="paragraph"><p>Implicit resolution is particularly hit-or-miss if type aliases are used where the shape of the implicit parameters are changed. For example an implicit parameter using an alias such as type Values[A] = List[Option[A]] will probably fail to find implicits defined as raw List[Option[A]] because the shape is changed from a thing of things of A to a thing of A.</p></div>
<div class="paragraph"><p>4.3 Modelling OAuth2
We will finish this chapter with a practical example of data modelling and typeclass derivation, combined with algebra / module design from the previous chapter.</p></div>
<div class="paragraph"><p>In our drone-dynamic-agents application, we must communicate with Drone and Google Cloud using JSON over REST. Both services use OAuth2 for authentication. There are many ways to interpret OAuth2, but we will focus on the version that works for Google Cloud (the Drone version is even simpler).</p></div>
<div class="paragraph"><p>4.3.1 Description
Every Google Cloud application needs to have an OAuth 2.0 Client Key set up at</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  https://console.developers.google.com/apis/credentials?project={PROJECT_ID}
Obtaining a Client ID and a Client secret.</code></pre>
</div></div>
<div class="paragraph"><p>The application can then obtain a one time code by making the user perform an Authorization Request in their browser (yes, really, in their browser). We need to make this page open in the browser:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  https://accounts.google.com/o/oauth2/v2/auth?\
    redirect_uri={CALLBACK_URI}&amp;\
    prompt=consent&amp;\
    response_type=code&amp;\
    scope={SCOPE}&amp;\
    access_type=offline&amp;\
    client_id={CLIENT_ID}
The code is delivered to the {CALLBACK_URI} in a GET request. To capture it in our application, we need to have a web server listening on localhost.</code></pre>
</div></div>
<div class="paragraph"><p>Once we have the code, we can perform an Access Token Request:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  code={CODE}&amp;\
    redirect_uri={CALLBACK_URI}&amp;\
    client_id={CLIENT_ID}&amp;\
    client_secret={CLIENT_SECRET}&amp;\
    scope={SCOPE}&amp;\
    grant_type=authorization_code
which gives a JSON response payload</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600,
    "refresh_token": "REFRESH_TOKEN"
  }
Bearer tokens typically expire after an hour, and can be refreshed by sending an HTTP request with any valid refresh token:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  POST /oauth2/v4/token HTTP/1.1
  Host: www.googleapis.com
  Content-length: {CONTENT_LENGTH}
  content-type: application/x-www-form-urlencoded
  user-agent: google-oauth-playground
  client_secret={CLIENT_SECRET}&amp;
    grant_type=refresh_token&amp;
    refresh_token={REFRESH_TOKEN}&amp;
    client_id={CLIENT_ID}
responding with</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  {
    "access_token": "BEARER_TOKEN",
    "token_type": "Bearer",
    "expires_in": 3600
  }
All userland requests to the server should include the header</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  Authorization: Bearer BEARER_TOKEN
after substituting the actual BEARER_TOKEN.</code></pre>
</div></div>
<div class="paragraph"><p>Google expires all but the most recent 50 bearer tokens, so the expiry times are just guidance. The refresh tokens persist between sessions and can be expired manually by the user. We can therefore have a one-time setup application to obtain the refresh token and then include the refresh token as configuration for the user’s install of the headless server.</p></div>
<div class="paragraph"><p>Drone doesn’t implement the /auth endpoint, or the refresh, and simply provides a BEARER_TOKEN through their user interface.</p></div>
<div class="paragraph"><p>4.3.2 Data
The first step is to model the data needed for OAuth2. We create an ADT with fields having exactly the same name as required by the OAuth2 server. We will use String and Long for brevity, but we could use refined types if they leak into our business models.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>import refined.api.Refined
import refined.string.Url</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class AuthRequest(
    redirect_uri: String Refined Url,
    scope: String,
    client_id: String,
    prompt: String = "consent",
    response_type: String = "code",
    access_type: String = "offline"
  )
  final case class AccessRequest(
    code: String,
    redirect_uri: String Refined Url,
    client_id: String,
    client_secret: String,
    scope: String = "",
    grant_type: String = "authorization_code"
  )
  final case class AccessResponse(
    access_token: String,
    token_type: String,
    expires_in: Long,
    refresh_token: String
  )
  final case class RefreshRequest(
    client_secret: String,
    refresh_token: String,
    client_id: String,
    grant_type: String = "refresh_token"
  )
  final case class RefreshResponse(
    access_token: String,
    token_type: String,
    expires_in: Long
  )
Avoid using java.net.URL at all costs: it uses DNS to resolve the hostname part when performing toString, equals or hashCode.</code></pre>
</div></div>
<div class="paragraph"><p>Apart from being insane, and very very slow, these methods can throw I/O exceptions (are not pure), and can change depending on the network configuration (are not deterministic).</p></div>
<div class="paragraph"><p>The refined type String Refined Url allows us to perform equality checks based on the String and we can safely construct a URL only if it is needed by a legacy API.</p></div>
<div class="paragraph"><p>That said, in high performance code we would prefer to skip java.net.URL entirely and use a third party URL parser such as jurl, because even the safe parts of java.net.* are extremely slow at scale.</p></div>
<div class="paragraph"><p>4.3.3 Functionality
We need to marshal the data classes we defined in the previous section into JSON, URLs and POST-encoded forms. Since this requires polymorphism, we will need typeclasses.</p></div>
<div class="paragraph"><p>jsonformat is a simple JSON library that we will study in more detail in a later chapter, as it has been written with principled FP and ease of readability as its primary design objectives. It consists of a JSON AST and encoder / decoder typeclasses:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>package jsonformat</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>sealed abstract class JsValue
final case object JsNull                                    extends JsValue
final case class JsObject(fields: IList[(String, JsValue)]) extends JsValue
final case class JsArray(elements: IList[JsValue])          extends JsValue
final case class JsBoolean(value: Boolean)                  extends JsValue
final case class JsString(value: String)                    extends JsValue
final case class JsDouble(value: Double)                    extends JsValue
final case class JsInteger(value: Long)                     extends JsValue</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait JsEncoder[A] {
  def toJson(obj: A): JsValue
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  @typeclass trait JsDecoder[A] {
    def fromJson(json: JsValue): String \/ A
  }
\/ is Scalaz’s Either and has a .flatMap. We can use it in for comprehensions, whereas stdlib Either does not support .flatMap prior to Scala 2.12. It is spoken as disjunction, or angry rabbit.</code></pre>
</div></div>
<div class="paragraph"><p>scala.Either was contributed to the Scala standard library by the creator of Scalaz, Tony Morris, in 2007. \/ was created when unsafe methods were added to Either.</p></div>
<div class="paragraph"><p>We need instances of JsDecoder[AccessResponse] and JsDecoder[RefreshResponse]. We can do this by making use of a helper function:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit class JsValueOps(j: JsValue) {
    def getAs[A: JsDecoder](key: String): String \/ A = ...
  }
We put the instances on the companions of our data types, so that they are always in the implicit scope:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import jsonformat._, JsDecoder.ops._</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object AccessResponse {
  implicit val json: JsDecoder[AccessResponse] = j =&gt;
    for {
      acc &lt;- j.getAs[String]("access_token")
      tpe &lt;- j.getAs[String]("token_type")
      exp &lt;- j.getAs[Long]("expires_in")
      ref &lt;- j.getAs[String]("refresh_token")
    } yield AccessResponse(acc, tpe, exp, ref)
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  object RefreshResponse {
    implicit val json: JsDecoder[RefreshResponse] = j =&gt;
      for {
        acc &lt;- j.getAs[String]("access_token")
        tpe &lt;- j.getAs[String]("token_type")
        exp &lt;- j.getAs[Long]("expires_in")
      } yield RefreshResponse(acc, tpe, exp)
  }
We can then parse a string into an AccessResponse or a RefreshResponse</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>scala&gt; import jsonformat._, JsDecoder.ops._
scala&gt; val json = JsParser("""
                     {
                       "access_token": "BEARER_TOKEN",
                       "token_type": "Bearer",
                       "expires_in": 3600,
                       "refresh_token": "REFRESH_TOKEN"
                     }
                     """)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  scala&gt; json.map(_.as[AccessResponse])
  AccessResponse(BEARER_TOKEN,Bearer,3600,REFRESH_TOKEN)
We need to write our own typeclasses for URL and POST encoding. The following is a reasonable design:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>// URL query key=value pairs, in un-encoded form.
final case class UrlQuery(params: List[(String, String)])</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>@typeclass trait UrlQueryWriter[A] {
  def toUrlQuery(a: A): UrlQuery
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  @typeclass trait UrlEncodedWriter[A] {
    def toUrlEncoded(a: A): String Refined UrlEncoded
  }
We need to provide typeclass instances for basic types:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import java.net.URLEncoder</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>object UrlEncodedWriter {
  implicit val encoded: UrlEncodedWriter[String Refined UrlEncoded] = identity</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val string: UrlEncodedWriter[String] =
  (s =&gt; Refined.unsafeApply(URLEncoder.encode(s, "UTF-8")))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val url: UrlEncodedWriter[String Refined Url] =
  (s =&gt; s.value.toUrlEncoded)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit val long: UrlEncodedWriter[Long] =
  (s =&gt; Refined.unsafeApply(s.toString))</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>implicit def ilist[K: UrlEncodedWriter, V: UrlEncodedWriter]
  : UrlEncodedWriter[IList[(K, V)]] = { m =&gt;
  val raw = m.map {
    case (k, v) =&gt; k.toUrlEncoded.value + "=" + v.toUrlEncoded.value
  }.intercalate("&amp;")
  Refined.unsafeApply(raw) // by deduction
}</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  }
We use Refined.unsafeApply when we can logically deduce that the contents of the string are already url encoded, bypassing any further checks.</code></pre>
</div></div>
<div class="paragraph"><p>ilist is an example of simple typeclass derivation, much as we derived Numeric[Complex] from the underlying numeric representation. The .intercalate method is like .mkString but more general.</p></div>
<div class="paragraph"><p>UrlEncodedWriter is making use of the Single Abstract Method (SAM types) Scala language feature. The full form of the above is</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit val string: UrlEncodedWriter[String] =
    new UrlEncodedWriter[String] {
      override def toUrlEncoded(s: String): String = ...
    }
When the Scala compiler expects a class (which has a single abstract method) but receives a lambda, it fills in the boilerplate automatically.</code></pre>
</div></div>
<div class="paragraph"><p>Prior to SAM types, a common pattern was to define a method named instance on the typeclass companion</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  def instance[T](f: T =&gt; String): UrlEncodedWriter[T] =
    new UrlEncodedWriter[T] {
      override def toUrlEncoded(t: T): String = f(t)
    }
allowing for</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  implicit val string: UrlEncodedWriter[String] = instance { s =&gt; ... }
This pattern is still used in code that must support older versions of Scala, or for typeclasses instances that need to provide more than one method.</code></pre>
</div></div>
<div class="paragraph"><p>Note that there are a lot of bugs around SAM types, as they do not interact with all the language features. Revert to the non-SAM variant if there are any strange compiler crashes.</p></div>
<div class="paragraph"><p>In a dedicated chapter on Typeclass Derivation we will calculate instances of UrlQueryWriter automatically, as well as clean up what we have already written, but for now we will write the boilerplate for the types we wish to convert:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  import UrlEncodedWriter.ops._
  object AuthRequest {
    implicit val query: UrlQueryWriter[AuthRequest] = { a =&gt;
      UrlQuery(List(
        ("redirect_uri"  -&gt; a.redirect_uri.value),
        ("scope"         -&gt; a.scope),
        ("client_id"     -&gt; a.client_id),
        ("prompt"        -&gt; a.prompt),
        ("response_type" -&gt; a.response_type),
        ("access_type"   -&gt; a.access_type))
    }
  }
  object AccessRequest {
    implicit val encoded: UrlEncodedWriter[AccessRequest] = { a =&gt;
      IList(
        "code"          -&gt; a.code.toUrlEncoded,
        "redirect_uri"  -&gt; a.redirect_uri.toUrlEncoded,
        "client_id"     -&gt; a.client_id.toUrlEncoded,
        "client_secret" -&gt; a.client_secret.toUrlEncoded,
        "scope"         -&gt; a.scope.toUrlEncoded,
        "grant_type"    -&gt; a.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
  object RefreshRequest {
    implicit val encoded: UrlEncodedWriter[RefreshRequest] = { r =&gt;
      IList(
        "client_secret" -&gt; r.client_secret.toUrlEncoded,
        "refresh_token" -&gt; r.refresh_token.toUrlEncoded,
        "client_id"     -&gt; r.client_id.toUrlEncoded,
        "grant_type"    -&gt; r.grant_type.toUrlEncoded
      ).toUrlEncoded
    }
  }
4.3.4 Module
That concludes the data and functionality modelling required to implement OAuth2. Recall from the previous chapter that we define components that need to interact with the world as algebras, and we define business logic in a module, so it can be thoroughly tested.</code></pre>
</div></div>
<div class="paragraph"><p>We define our dependency algebras, and use context bounds to show that our responses must have a JsDecoder and our POST payload must have a UrlEncodedWriter:</p></div>
<div class="literalblock">
<div class="content">
<pre><code>trait JsonClient[F[_]] {
  def get[A: JsDecoder](
    uri: String Refined Url,
    headers: IList[(String, String)]
  ): F[A]</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    def post[P: UrlEncodedWriter, A: JsDecoder](
      uri: String Refined Url,
      payload: P,
      headers: IList[(String, String] = IList.empty
    ): F[A]
  }
Note that we only define the happy path in the JsonClient API. We will get around to error handling in a later chapter.</code></pre>
</div></div>
<div class="paragraph"><p>Obtaining a CodeToken from the Google OAuth2 server involves</p></div>
<div class="paragraph"><p>starting an HTTP server on the local machine, and obtaining its port number.
making the user open a web page in their browser, which allows them to log in with their Google credentials and authorise the application, with a redirect back to the local machine.
capturing the code, informing the user of next steps, and closing the HTTP server.
We can model this with three methods on a UserInteraction algebra.</p></div>
<div class="literalblock">
<div class="content">
<pre><code>final case class CodeToken(token: String, redirect_uri: String Refined Url)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  trait UserInteraction[F[_]] {
    def start: F[String Refined Url]
    def open(uri: String Refined Url): F[Unit]
    def stop: F[CodeToken]
  }
It almost sounds easy when put like that.</code></pre>
</div></div>
<div class="paragraph"><p>We also need an algebra to abstract over the local system time</p></div>
<div class="literalblock">
<div class="content">
<pre><code>  trait LocalClock[F[_]] {
    def now: F[Epoch]
  }
And introduce data types that we will use in the refresh logic</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>  final case class ServerConfig(
    auth: String Refined Url,
    access: String Refined Url,
    refresh: String Refined Url,
    scope: String,
    clientId: String,
    clientSecret: String
  )
  final case class RefreshToken(token: String)
  final case class BearerToken(token: String, expires: Epoch)
Now we can write an OAuth2 client module:</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>import http.encoding.UrlQueryWriter.ops._</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>class OAuth2Client[F[_]: Monad](
  config: ServerConfig
)(
  user: UserInteraction[F],
  client: JsonClient[F],
  clock: LocalClock[F]
) {
  def authenticate: F[CodeToken] =
    for {
      callback &lt;- user.start
      params   = AuthRequest(callback, config.scope, config.clientId)
      _        &lt;- user.open(params.toUrlQuery.forUrl(config.auth))
      code     &lt;- user.stop
    } yield code</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>def access(code: CodeToken): F[(RefreshToken, BearerToken)] =
  for {
    request &lt;- AccessRequest(code.token,
                             code.redirect_uri,
                             config.clientId,
                             config.clientSecret).pure[F]
    msg     &lt;- client.post[AccessRequest, AccessResponse](
                 config.access, request)
    time    &lt;- clock.now
    expires = time + msg.expires_in.seconds
    refresh = RefreshToken(msg.refresh_token)
    bearer  = BearerToken(msg.access_token, expires)
  } yield (refresh, bearer)</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>    def bearer(refresh: RefreshToken): F[BearerToken] =
      for {
        request &lt;- RefreshRequest(config.clientSecret,
                                  refresh.token,
                                  config.clientId).pure[F]
        msg     &lt;- client.post[RefreshRequest, RefreshResponse](
                     config.refresh, request)
        time    &lt;- clock.now
        expires = time + msg.expires_in.seconds
        bearer  = BearerToken(msg.access_token, expires)
      } yield bearer
  }
4.4 Summary
algebraic data types (ADTs) are defined as products (final case class) and coproducts (sealed abstract class).
Refined types enforce constraints on values.
concrete functions can be defined in an implicit class to maintain left-to-right flow.
polymorphic functions are defined in typeclasses. Functionality is provided via “has a” context bounds, rather than “is a” class hierarchies.
typeclass instances are implementations of a typeclass.
@simulacrum.typeclass generates .ops on the companion, providing convenient syntax for typeclass functions.
typeclass derivation is compiletime composition of typeclass instances.</code></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-07-16 01:27:23 EEST
</div>
</div>
</body>
</html>
