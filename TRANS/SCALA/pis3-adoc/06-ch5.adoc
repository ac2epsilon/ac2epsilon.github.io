:ascii-ids:
:doctype: book
:source-highlighter: pygments
:icons: font

Глава 5
---------

Базові типи і операції
======================

Тепер, коли ви побачили класи і об'єкти в дії, настав гарний час подивитись на базові типи та операції Scala більш глибоко. Якщо ви знайомі з Java, ви будете раді узнати, що базові типи і операції  Java мають те саме значення в Scala. Однак є деякі цікаві розбіжності, що роблять цю главу варту прочитання, навіть якщо ви досвідчений Java розробник. Оскільки деякі аспекти Scala, розглянуті в цій главі в основі ти самі, що і в Java, ми вставили зауваження, що ці частини Java розробники можуть пропустити.

В цій главі ви отримаєте огляд базових класів Scala, включаючи  `String` та типи значень, `Int`, `Long`, `Short`, `Byte`, `Float`, `Double`, `Char`, та `Boolean`. Ви вивчите операції, що ви можете виконувати з ціма типами, включаючи те, як робить преоритетність операторів в виразах Scala. Ви також вивчите, як неявні перетворення можуть "збагатити" варіанти ціх базових типів, даючи додаткові операції, крім тих, що підтримуються в Java.

5.1 Деякі базові типи
---------------------
Декілька фундаментальних типів Scala, разом и диапазонами знічень ціх типів, яки вони можуть приймати, показані в Таблиці 5.1. Загалом типи `Byte`, `Short`, `Int`, `Long` та `Char` називаються інтегральними типами. Інтегральні типи разом з `Float` та `Double` називаються числовими типами. 

[caption="Таблиця: "]
.Деякі базові типи
[cols="1,5",options="header"]
|===
^| Базовий тип ^| Диапазон

^| Byte    
| 8-бітне ціле зі знаком (від -2^7^ до 2^7^ - 1, включно)

^| Short   
| 16-бітне ціле зі знаком (від -2^15^ до 2^15^ - 1, включно)

^| Int     
| 32-бітне ціле зі знаком (від -2^31^ до 2^31^ - 1, включно)

^| Long    
| 64-бітне ціле зі знаком (від -2^63^ до 2^63^ - 1, включно)

^| Char    
| 16-бітний беззнаковий символ Unicode (від 0 до 2^16^ - 1, включно)

^| String  
| послідовність Char

^| Float   
| 32-бітне IEEE 754 з плаваючою крапкою одинарна точність

^| Double  
| 64-бітне IEEE 754 з плаваючою крапкою подвійна
 
^| Boolean 
| true або false
|===

Всі крім `String`, що знаходиться в пакунку `java.lang`, всі типи, показані в Таблиці 5.1 є членами пакунку `scala`.footnote:[Пакунки, що були коротко описані на Кроці 1 в Главі 2, будуть розглянуті глибоко в Главі 13.] Наприклад, повне ім'я `Int` є `scala.Int`. Однак беручи, що всі члени з пакунку `scala` та `java.lang` автоматично імпортуються в кожний джерельний файл Scala, ви можете використовувати самі прості імена (тобто імена як Boolean, Char, або String) будь-де.

Допитливі Java розробники зауважать, базові типи Scala мають ті самі диапазони, що і відповідні типи в Java. Це дозволяє компілятору  Scala трансформувати примірники значень Scala, такі як `Int` або `Double`, до примітивних типів Java в спродукованому байткоді.

5.2 Літерали
------------
Всі базові типи, перелічені в Таблиці 5.1 можуть бути записані як літерали. Літерал - це шлях написати стале значення прямо в коді.

Швидкий шлях для Java програмістів
----------------------------------
Синтаксис більшосі літералів, показаних в цьому розділі, є саме таким, як і в Java, так що якщо ви майстер Java, ви можете безпечно пропустити більшість цього розділу. Деякі розбіжності з описаних тут ви можете прочитати щодо Scala літералів для сирих рядків та символів, а також про інтерполяцію рядків. Також Scala не підтримує восьмиричні літерали; цілі літерали, що починаються з нуля, такі як  031, не будуть компілюватись.

Цілі літерали
~~~~~~~~~~~~~
Цілі літерали для типів `Int`, `Long`, `Short`, `Byte` ідуть в двох форматах: десятичному та шістнадцятиричному. Від того, з чого починається літерал, залежить основа числа. Якщо число починається з 0x або 0X, це шістнадцятирічне (основа 16), та може містити цифри від 0 до 9, так само як літери в верхньому або нижньому реєстрі від A до F. Ось деякі приклади:
[source,scala]
----
scala> val hex = 0x5
hex: Int = 5

scala> val hex2 = 0x00FF
hex2: Int = 255

scala> val magic = 0xcafebabe
magic: Int = -889275714
----
Зауважте, що оболонка Scala завжди друкує цілі значення по основі 10, не важливо, якою формою літерала ви ініціалізували її. Таким чином, інтерпретатор відображує значення змінної `hex2`, що ви ініціалізували літералом `0x00FF` як десятичне `255`. (Звичайно, ви не маєте вірити нам на слово. Гарний спосіб почати відчувати мову є спробувати твердження в інтерпретаторі по мірі читання цієї глави.) Якщо число починається з не-нульової цифри, воно десяткове (основа
10). Наприклад:
[source,scala]
----
scala> val dec1 = 31
dec1: Int = 31

scala> val dec2 = 255
dec2: Int = 255

scala> val dec3 = 20
dec3: Int = 20
----
Якщо цілий літерал закінчується на L або l, це `Long`; інакше це `Int`. Деякі приклади `Long` літералів:
[source,scala]
----
scala> val prog = 0XCAFEBABEL
prog: Long = 3405691582scala> val tower = 35L
tower: Long = 35

scala> val of = 31l
of: Long = 31
----
Якщо `Int` літерал присвоюється змінній `Short` або `Byte`, литерал розглядається як би він був `Short` або `Byte`, доки значення літерала в валідному диапазоні. Наприклад:
[source,scala]
----
scala> val little: Short = 367
little: Short = 367

scala> val littler: Byte = 38
littler: Byte = 38
----

Літерали з плаваючою крапкою
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Літерали з плаваючою крапкою складаються з десятичних цифр, опціонально містять десятичну крапку, опціонально далі іде E або e та експонента. Деякі приклади літералів з плаваючою крапкою:
[source,scala]
----
scala> val big = 1.2345
big: Double = 1.2345

scala> val bigger = 1.2345e1
bigger: Double = 12.345

scala> val biggerStill = 123E45
biggerStill: Double = 1.23E47
----
Зауважте, що частина експоненти означає ступінь десяти, на яку домножається інша частина. Таким чином 1.2345e1 є 1.2345 разів по 10^1^, що є 12.345. Якщо літерал з плаваючою крапкою завершується на F або f, це `Float`; інакше це `Double`. Опціонально, літерал з плаваючою крапкою `Double` може завершуватись на D або d. Деякі приклади літералів `Float`:
[source,scala]
----
scala> val little = 1.2345F
little: Float = 1.2345

scala> val littleBigger = 3e5f
littleBigger: Float = 300000.0
----
Це останнє значення, виражене як `Double` може приймати такі (ті інші) форми:
[source,scala]
----
scala> val anotherDouble = 3e5
anotherDouble: Double = 300000.0

scala> val yetAnother = 3e5D
yetAnother: Double = 300000.0
----
Символі літерали
~~~~~~~~~~~~~~~~
Символьні літерали складаються з Unicode символа між поодинокими лапками, такі як:
[source,scala]
----
scala> val a = 'A' a: Char = A
---- 
На додаток до провадження явного символа між поодинокими лапками, ви можете сказати символ, використовуючи кодову точку Unicode. Щоб зробити це, запишіть \u, за якими чотири шіснадцятиричних цифри кодовою точки:
[source,scala]
----
scala> val d = '\u0041'
d: Char = A

scala> val f = '\u0044'
f: Char = D
----
Фактично, такі Unicode символи можуть з'являтись будь-де в програмі Scala. Наприклад, ви можете також написати ідентифікатор таким чином:
[source,scala]
----
scala> val B\u0041\u0044 = 1
BAD: Int = 1
----
Цей ідентифікатор розглядається як ідентичний до BAD, результат двох Unicode символів в коді вище. Загалом це погана ідея називати ідентифікатори таким чином, оскільки їх важко читати. Скоріше цей синтаксис призначений щоб дозволити джерельним файлам Scala, що містять не-ASCII Unicode символи бути представленими в ASCII.

Нарешті, існують також декілька літералів, представлених спеціалними ескейп виключеннями, показаними в Таблиці 5.2. Наприклад:
[source,scala]
----
scala> val backslash = '\\'
backslash: Char = \
----

[caption="Таблиця 5.2: "]
Специальні символи, ескейп послідовності
[cols="1^,5^",options="header"]
|===
| Літерал | Значення
| \n | перевод рядка (\u000A)
| \b | сторно (\u0008)
| \t | табуляція (\u0009)
| \f | нова сторінка (\u000C)
| \r | повернення каретки (\u000D)
| \" | подвійні лапки (\u0022)
| \' | поодинокі лапки (\u0027)
| \\ | зворотня коса (\u005C)
|===

Рядкові літерали
~~~~~~~~~~~~~~~~
Рядкові літерали складаються з символів в подвійних лапках:
[source,scala]
----
scala> val hello = "hello"
hello: String = hello
----
Стнтаксис символів в дужках той самий, як і в символьних літералах. Наприклад:
[source,scala]
----
scala> val escapes = "\\\"\'"
escapes: String = \"'
----
Оскільки цей синтаксис незручний для рядків, що містять багато ескейп послідовностей, або рядків, що перетинають багато рядків,  Scala включає особливий синтаксис для сирих рядків. Ви починаєте та завершуєте сирий рядок трьома подвійними лапками поспіль ("""). Внутрішність сирого рядка може містити любі символи, будь-що, включаючи нові рядки, лапки, спеціальні символи, за винятком, зрозуміло, тьох подвійних лапок повпіль. Наприклад, наступна програма друкує повідомлення використовуючи сирий рядок:
[source,scala]
----
println("""Welcome to Ultamix 3000.
           Type "HELP" for help.""")
----
Однак виконання цього кода не продукує саме те, що задумане:
----
Welcome to Ultamix 3000.
           Type "HELP" for help.
----
Проблема в тому, що початкові проміжки в другому рядку включені в рядок! Щоб допомогти в цій загальній ситуації, ви можете викликати для рядків stripMargin. Щоб використати цей метод, покладіть символ роздільника (|) спереду кожного рядка, та потім викличте  `stripMargin` для цілого рядка:
[source,scala]
----
println("""|Welcome to Ultamix 3000.
           |Type "HELP" for help.""".stripMargin)
----
Тепер код поводиться як задумано:
----
Welcome to Ultamix 3000.
Type "HELP" for help.
----

Символьні літерали
~~~~~~~~~~~~~~~~~~
Символьний літерал записується `'ident`, де `ident` може бути любим ідентифікатором з літер та цифр. Такі літерали відображуються на примірники передвизначеного класу `scala.Symbol`. Зокрема, літерал `'cymbal` буде розширений компілятором до виклику метода фабрики: `Symbol("cymbal")`. Символьні літерали типово використовуються в ситуаціях, де ви можете використовувати ідентифікатор в динамічно типизованих мовах. Наприклад, ви можете побажати визначити метод, що оновлює запис в базі даних:
[source,scala]
----
scala> def updateRecordByName(r: Symbol, value: Any) = {
// code goes here
}
updateRecordByName: (Symbol,Any)Unit
----
Метод приймає в якості параметра символ, що вказує ім'я поля запису,в яке траба внести зміни. В динамічно типизованих ви можете визвати цю операцію, передаючи в метод недекларований ідентифікатор поля, але в Scala це не буде компілюватись:
[source,scala]
----
scala> updateRecordByName(favoriteAlbum, "OK Computer")
<console>:6: error: not found: value favoriteAlbum
updateRecordByName(favoriteAlbum, "OK Computer")
^
----
Замість цього, і майже так стисло, ви можете передати символьний літерал: 
[source,scala]
----
scala> updateRecordByName('favoriteAlbum, "OK Computer")
----
З символом ви можете робити не дуже багато чого, крім з'ясувати його ім'я:
[source,scala]
----
scala> val s = 'aSymbol
s: Symbol = 'aSymbol

scala> val nm = s.name
nm: String = aSymbol
----
Інша річ, що варта уваги, це те, що символи інтерновані. Якщо ви пишете той самий літерал двічі, обоє вирази будуть посилатись на той самий об'єкт `Symbol`.

Логічні літерали
~~~~~~~~~~~~~~~~
Тип Boolean має два літерала, `true` та `false`:
[source,scala]
----
scala> val bool = true
bool: Boolean = true

scala> val fool = false
fool: Boolean = false
----
Це все щодо цього. Тепер ви буквально експерт в Scala.footnote:[фігурально кажучи]

5.3 Інтерполяція рядків
-----------------------
Scala включає гнучкий механізм для інтерполяції рядків, що дозполяє вам вбудовувати вирази в рядкові літерали. Її найбільш загальний випадок викорстання є провадження стислої та читабельної альтернативи до конкатенації рядків. Ось приклад:
[source,scala]
----
val name = "reader"
println(s"Hello, $name!")
----
Вираз `s"Hello, $name!"` є обробляємий рядковий літерал. Оскільки літера `s` безпосередньо передує відкриваючим лапкам, Scala скала буде використовувати інтерполяцію рядка `s` для обробки літерала. Цей `s` інтерполятор буде обчислювати кожний вбудований вираз, викликаючи `toString` для кожного результата, та замінює вбудовані вирази в літералі на ці результати. Таким чином, `s"Hello, $name!"` дає `"Hello, reader!"`, той самий результат, що і `"Hello, " + name + "!"`.

Ви можете покласти любий вираз після знаку долара ($) в оброблюваний рядковий літерал. Для одно-змінних виразів, ви часто можете ім'я змінної після знаку долару. Scala буде інтерпретувати всі символи до першого не-ідентифікаторного символа як вираз. Якщо вираз включає не-ідентифікаторні символи, ви маєте покласли його в фігурні дужки, з відкриваючою дужкою прямо за знаком долара. Ось приклад:
[source,scala]
----
scala> s"The answer is ${6 * 7}."
res0: String = The answer is 42.
----
Scala провадить два інші інтерполятора по замовчанню: `raw` та `f`. Інтерпретатор рядків `raw` поводиться як `s`, за винятком того, що він не розпізнає сивольні літерали ескейп послідовності (такі як показані в Таблиці 5.2). Наприклад, наступне твердження друкує чотири зворотні косі, не дві:
[source,scala]
----
println(raw"No\\\\escape!") // prints: No\\\\escape!
----
Інтерполятор рядка `f` дозволяє вам додати вам інструкції форматування в стилі `printf` для вбудованих виразів. Ви покладаєте інструкції після виразу, починаючи зі знака відсотків (%), використовуючи синтаксис, заданий в `java.util.Formatter`. Наприклад, ось як ви можете форматувати число pi
[source,scala]
----
scala> f"${math.Pi}%.5f"
res1: String = 3.14159
----
Якщо ви не провадите інструкцій форматування для вбудованого виразу, рядковий інтерпретатор `f` буде по замовчанню вважати `%s`, що означає, що буде підставлено значення `toString`, так само як інтерпретатор рядків `s`. Наприклад:
[source,scala]
----
scala> val pi = "Pi"
pi: String = Pi

scala> f"$pi is approximately ${math.Pi}%.8f."
res2: String = Pi is approximately 3.14159265.
----
В Scala інтерполяція рядків реалізована через переписування кода під час компіляції. Компілятор буде трактувати любий вираз, що складається з ідентифікатора, безпосередньо за яким іде подвійни лапки рядкового літералу, є виразом інтерполятора рядка. Інтерпретатори рядків `s`, `f`, та `raw` реалізовані через цей загальний механізм. Бібліотеки та користувачі можуть визначати інші інтерполятори рядків для інших цілей.

5.4 Оператори та методи
-----------------------
Scala провадить потужний набір операторів для своїх базових типів. Як згадувалось в попередніх главах, ці операції насправді є милим синтаксисом для звичайних викликів методів. Наприклад, `1 + 2` насправді означає те саме, що `1.+(2)`. Іншими словами, клас `Int` містить метод `+`, що приймає `Int` та повертає результат `Int`. Цей метод `+ викликається, коли ви додаєте два `Int`:
[source,scala]
----
scala> val sum = 1 + 2
sum: Int = 3
// Scala invokes 1.+(2)
----
Щоб переконатись в цьому, ви можете написати вираз явно як виклик метода:
[source,scala]
----
scala> val sumMore = 1.+(2)
sumMore: Int = 3
----
Фактично, `Int` містить декілка перевантажених методів `+`, що приймають різні типів параметрів.footnote:[3] For example, Int has another method, also named +, that takes and returns a Long. If you add a Longto an Int, this alternate + method will be invoked, as in:
[source,scala]
----
scala> val longSum = 1 + 2L
longSum: Long = 3
// Scala invokes 1.+(2L)
----
Символ `+` є оператором — інфіксним оператором, якщо бути точнішим. Операторна нотація не обмежена до методів, як `+`, що виглядають як оператори в інших мовах. Ви можете використовувати любий метод в операторній натації. Наприклад, клас `String` має метод `indexOf`, що приймає один параметр `Char`. Метод `indexOf` шукає рядок на перше співпадіння вказаного символа, та повертає його індекс, або `-1`, якщо вона не знайшла символ. Ви можете використовувати `indexOf` як оператор, ось так:
[source,scala]
----
scala> val s = "Hello, world!"
s: String = Hello, world!

scala> s indexOf 'o'
res0: Int = 4
// Scala invokes s.indexOf('o')
----
На додаток, `String` пропонує перевантажений метод `indexOf`, що приймає два параметри, символ, що треба шукати, та індекс, з якого починати. (Інший метод `indexOf`, показаний попередньо, починає з індексу 0, початку `String`.) Навіть якщо цей метод `indexOf` приймає два аргументи, ви можете використовувати його в операторній нотації. Але коли ви викликаєте метод, що приймає декілька аргументів використовуючи операторну нотацію, ви маєте поклачти ці аргументи в дужках. Наприклад, ось як ви використовуєте цей інший `indexOf` як оператор (продовжуючи попередній приклад):
[source,scala]
----
scala> s indexOf ('o', 5) // Scala invokes s.indexOf('o', 5)
res1: Int = 8
----
Любий метод може бути оператором
--------------------------------
В Scala оператори не є особливим мовним синтаксисом; любий метод може бути оператором. Що робить метод оператором, це те, як ви використовуєте його. Коли ви пишете `s.indexOf('o')`, `indexOf` не є оператором. Але коли ви пишете `s indexOf 'o'`, `indexOf` є оператором, оскільки ви використовуєте його в операторній нотації.

Досі ви бачили приклади інфіксної операторної нотації, що означає, що викликаємий метод сидить між об'єктом і параметром (або параметрами), які ви бажаєте передати в метод, як в `7 + 2`. Scala також має дві інші операторні нотації: префіксну та постфіксну. В префіксній нотації ви кладете метод перед об'єктом, на якому ви викликаєте метод (наприклад, `-` в `-7`). В постфіксній нотації ви кладете метод після об'єкта (наприклад, `toLong` в `7 toLong`).

Для контрасту до інфіксної нотації, де оператори мають два операнди, один зліва та інший зправа, префіксні та постфіксні оператори є унарними: вони приймають тільки один операнд. В префіксній нотації операнд іде зправа від операнда. Деякі приклади префіксних операторів є `-2.0`, `!found`, та `~0xFF`. Як і з інфіксними операторами, ці префіксні оператори є скороченнями до виклику методів. Однак в цьому випадку ім'я метода має `unary_` перед символом оператора. Наприклад, Scala буде трансформувати вираз `-2.0` в виклик метода `(2.0).unary_-`. Ви можете продемонструвати це собі, набравши виклик метода обоє, через операторну нотацію та явно:
[source,scala]
----
scala> -2.0
res2: Double = -2.0
// Scala invokes (2.0).unary_-

scala> (2.0).unary_-
res3: Double = -2.0
----
Єдині ідентифікатори, що можуть бути викортстані як префіксні оператори, є `\+`, `-`, `!`, та `~`. Таким чином, якщо ви визначите метод на ім'я `unary_!`, ви можете викликати цей метод на значенні або змінній відповідного типу, використавши префіксну операторну нотацію, таку як `!p`. Але якщо ви визначите метод `unary_*`, ви не будете в змозі використовувати префіксну операторну нотацію, бо `*` не є одним з чотирьох ідентифікаторів, що можуть використовуватись в префіксних операторах. Ви можете викликати метод звичайно, як `inp.unary_*`, але якщо ви спробуєте визвати його через `*p`, Scala буде розбирати його, якби ви записали `*.p`, що, можливо, не те, що ви мали на увазі!footnote:[Однак не все втрачено. Існує вкрай слабкий шанс, що ваша програма з *p може компілюватись як C++.]

Постфіксні оператори є методи, що не приймають аргументів, коли вони викликаються без крапки та дужок. В Scala ви можете відкинути пусті дужки на виклику метода. Домовленість полягає в тому, що ви залишаєте дужки, якщо метод має побічні ефекти, як в println(), але ви можете не вживати їх, якщо метод не має побічних ефектів, як в `toLowerCase` викликане на `String`:
[source,scala]
----
scala> val s = "Hello, world!"
s: String = Hello, world!

scala> s.toLowerCase
res4: String = hello, world!
----
В цьому останньому випадку метода, що не потребує аргументів, ви можете альтернативно відкинути крапку, і використовувати постфіксну операторну нотацію:
[source,scala]
----
scala> s toLowerCase
res5: String = hello, world!
----
В цьому випадку `toLowerCase` використовується як постфіксний оператор на операнді `s`.

Таким чином, щоб побачити, які оператори ви можете використовувати з базовими типами Scala, все що вам дійсно треба зробити, це подивитись на методи, задекларовані в класах типу в документації Scala API. Зважаючи, що це Scala туторіал, однак, ми надамо вам швидкий тур по більшості з ціх методів в наступних декільках розділах.

Швидкий шлях для Java програмістів
----------------------------------
Багато аспектів Scala, описані в залишку цієї глави, такі ж самі, що і в Java. Якщо ви практикуючий Java гуру в розквиті, ви можете безпечно пропустити все до Розділу 5.8, що описує як Scala відрізняється від Java в сфері еквівалентності об'єктів.

5.5 Арифметичні оператори
-------------------------
Ви можете викликати арифметичні методи через інфіксну операторну нотацію для додавання (+), віднімання (-), множення (*), ділення (/), та залишку (%) на любих числових типах. Ось деякі приклади:
[source,scala]
----
scala> 1.2 + 2.3
res6: Double = 3.5

scala> 3 - 1
res7: Int = 2

scala> 'b' - 'a'
res8: Int = 1

scala> 2L * 3L
res9: Long = 6

scala> 11 / 4
res10: Int = 2

scala> 11 % 4
res11: Int = 3

scala> 11.0f / 4.0f
res12: Float = 2.75

scala> 11.0 % 4.0
res13: Double = 3.0
----
Коли обоє, лівий та правий операнди є інтегральними типами (`Int`, `Long`, `Byte`, `Short`, `Char`), оператор `/` буде казати вам цілу частину від ділення, без залишку. Оператор `%` вказує залишок від цілого ділення.

Залишок з плаваючою крапкою, що ви отримаєте за допомогою `%` не є тим, що визначений в стандарті IEEE 754. Залишок IEEE 754 використовує округлююче ділення, не відсікаюче ділення, при обчисленні залишка, так що повністю інше від операції цілого залишку. Якщо ви дійсно бажаєте залишок IEEE 754, ви можете викликати `IEEEremainder` зі `scala.math`, як тут:
[source,scala]
----
scala> math.IEEEremainder(11.0, 4.0)
res14: Double = -1.0
----
Числові типи також пропонують унарний префіксний оператор `+` (метод `unary_+`) та `-` (метод `unary_-`), що дає вам вказати, чи є літеральне число позитивним або негативним (додатним або від'ємним), як в `-3` або `+4.0`. Якщо ви не вказуєте унарний `+` або `-`, літеральне число розглядається як позитивне. Унарний `+` існує виключно для симетрії з `-`, але не має ефекту. Унарний `-` може також використовуватись для обернення змінної. Ось деякі приклади:
[source,scala]
----
scala> val neg = 1 + -3
neg: Int = -2

scala> val y = +3
y: Int = 3

scala> -neg
res15: Int = 2
----

5.6 Відносні та логічні операції
--------------------------------
Ви можете порівняти числові типи за допомогою відносних методів: більше ніж (>), менше ніж (<), більше або рівне (>=), менше або рівне (<=), що дають результат типу Boolean. На додаток ви можете використати унарний оператор `!` (метод `unary_!`), щоб інвертувати значення Boolean. Ось декілька прикладів:
[source,scala]
----
scala> 1 > 2
res16: Boolean = false

scala> 1 < 2
res17: Boolean = true

scala> 1.0 <= 1.0
res18: Boolean = true

scala> 3.5f >= 3.6f
res19: Boolean = false

scala> 'a' >= 'A'
res20: Boolean = true

scala> val untrue = !true
untrue: Boolean = false
----
Логічні методи, ТА (`&&` та `&`), АБО (`||` та `|`), приймають `Boolean` операнди в інфіксній нотації, та видають Boolean результат. Наприклад:
[source,scala]
----
scala> val toBe = true
toBe: Boolean = true

scala> val question = toBe || !toBe
question: Boolean = true

scala> val paradox = toBe && !toBe
paradox: Boolean = false
-----
Операції `&&` та `||` короткого обчислення, як в Java: вирази, побудовані з ціх операторів, обчислюються так далеко, як треба для визначення результату. Іншими словами, права частина виразів `&&` та `||` не буде обчислюватись, якщо ліва визначає результат. Наприклад, як ліва сторона виразу ТА буде обчислена як `false`, результат виразу буде обчислений як `false`, так що права частина не буде обчислена. Подібно,якщо ліва частина виразу АБО обчисляється до `true`, результат виразу буде однозначно `true`, так що права сторона не буде обчислюватись.
[source,scala]
----
scala> def salt() = { println("salt"); false }
salt: ()Boolean

scala> def pepper() = { println("pepper"); true }
pepper: ()Boolean

scala> pepper() && salt()
pepper
salt
res21: Boolean = false

scala> salt() && pepper()
salt
res22: Boolean = false
----
В першому виразі викликаються `pepper` та `salt`, але в другому викликається тільки `salt`. Припускаючи, що `salt` повертає `false`, немає потреби викликати `pepper`. Якщо ви бажаєте обчислити праву сторону в любому випадку, використовуйте оператори `&` та `|`. Метод `&` виконує логічне ТА, `|` логічне АБО, але не скорочено, як `&&` та `||`. Ось приклад:
[source,scala]
----
scala> salt() & pepper()
salt
pepper
res23: Boolean = falseNote
----
Ви можете зацікавитись, як може працювати, якщо оператори всього лише методи. Звичайно всі аргументи обчислюються перед входом в метод, так що як метод уникає обчислення свого второго аргумента? Відповідь полягає в тому, що всі методи Scala мають можливість відкладати обчислення своїх аргументів, або навіть відмовлятись обчислювати їх взагалі. Можливість називається параметри за-ім'ям, та обговорюється в Розділі 9.5.

5.7 Побітові операції
---------------------
Scala дозволяє вам виконувати операції з окремими бітами цілих типів за допомогою декількох побітових методів. Оператори настіпні: побітне ТА (&), побітне АБО (|), побітне XOR (!АБО) (\^).footnote:[ Метод побітне XOR виконує ексклюзивне АБО на операторах. Ідентичні біти дають 0. Різні біти дають 1. Таким чином, 0011 ^ 0101 дає 0110.]Унарний побітовий оператор (`~`, метод `unary_~`) інвертує кожний біт свого операнда. Наприклад:
[source,scala]
----
scala> 1 & 2
res24: Int = 0

scala> 1 | 2
res25: Int = 3

scala> 1 ^ 3
res26: Int = 2

scala> ~1
res27: Int = -2
----
Перший вираз, `1 & 2`, побітно перевіряє біти в 1 (0001) та 2 (0010), що дає 0 (0000). Другий вираз, `1 | 2`, побітно складає біти тих же операндів, даючи 3 (0011). Третій вираз, `1 ^ 3`, побітно виконує   xor для 1 (0001) та 3 (0011), даючи 2 (0010). Заключний вираз, `~1`, інвертує кожний біт в 1 (0001), даючи -2, що в бінарній формі виглядає як 11111111111111111111111111111110.

Цілі типи Scala також пропонують три методи зсуву: зсув вліво (<<), зсув вправо (>>), та беззнаковий зсув вправо (>>>). Методи зсува, коли використовуються в інфіксній операторні нотації, зсувають ціле значення лівого операнда на кількість біт, заданих правим оператором. Зсув вправо та беззнаковий зсув вліво заповнюють нові біти нулями. Зсув вправо заповнює ліві біти знаковим (старшим) бітом. Ось декілька прикладів:
[source,scala]
----
scala> -1 >> 31
res28: Int = -1

scala> -1 >>> 31
res29: Int = 1

scala> 1 << 2
res30: Int = 4
----
-1 в двійниковій системі є 11111111111111111111111111111111. В першому прикладі, -1 >> 31, -1 зсувається вправо на 31 позицій. Оскільки `Int` складається з 32 біт, ця операція ефективно рухає самий лівий біт, доки він не стане самий правий.footnote:[Самий лівий біт цілого типу є бітом знаку. Якщо самий лівий біт 1, число від'ємне. Якщо 0 число додатнє.] Наш метод >> заповнює одиницями при зсуві вправо, оскільки лівий біт -1 є 1, результат ідентичний до оригіналу лівого операну, 32 біти одиниць, або -1. В другому прикладі -1 >>> 31, самий лівий біт знову зсувається в саму праву позицію, але на цей раз заповнюється нулями. Результат на цей раз буде двоїчне 00000000000000000000000000000001, або 1. В фінальному прикладі, 1 << 2, лівий операнд, 1, зсувається вліво на ді позиції, даючи бінарне 00000000000000000000000000000100, або 4.

5.8 Еквівалентність об'єктів
----------------------------
Якщо ви бажаєте порівняти два об'єкти на еквівалентність, ви можете використовувати або `==` або його інверсію `!=`. Ось декілька простих прикладів:
[source,scala]
----
scala> 1 == 2
res31: Boolean = false

scala> 1 != 2
res32: Boolean = true

scala> 2 == 2
res33: Boolean = true
----
Ці операції насправді застосовуються для всіх об'єктів, не тільки для базових типів. Так що ви можете, наприклад, застосувати `==` для порівняння списків:
[source,scala]
----
scala> List(1, 2, 3) == List(1, 2, 3)
res34: Boolean = true

scala> List(1, 2, 3) == List(4, 5, 6)
res35: Boolean = false
----
Ідучи далі, ви можете порівняти два об'єкта, що мають різні типи:
[source,scala]
----
scala> 1 == 1.0
res36: Boolean = true

scala> List(1, 2, 3) == "hello"
res37: Boolean = false
----
Ви навіть можете порівняти з `null`, або з чимось, що може бути `null`. Виключення не спрацює:
[source,scala]
----
scala> List(1, 2, 3) == null
res38: Boolean = false

scala> null == List(1, 2, 3)
res39: Boolean = false
----
Як ви бачите, `==` було майстерно зроблене, так що ви отримаєте в більшості випадків тілкьи ту еквівалентність, яку побажаєте. Це досягається дуже простим правилом: спочатку перевіряється ліва сторона щодо `null`. Якщо це не `null`, викликається метод `equals`. Оскільки `equals` є методом, точне порівняння, що ви отримаєте, залежить від типу лівого аргументу. Оскільки перевірка на `null` автоматична, ви не повинні перевіряти самостійно.footnote:[Автоматична перевірка не дивиться на праву частину, але любий адекватний метод `equals` повинен повертати `false`, якщо аргумент є `null`.]Цей різновид порівняння видасть `true` на різних об'єктах, доки їх вміст той самий, та їх методи `equals` написані на основі їх вмісту. Наприклад, ось порівняння між двома рядками, що мають ті самі п'ять літер:
[source,scala]
----
scala> ("he" + "llo") == "hello"
res40: Boolean = true
----
Як == в Scala відрізняється від Java
------------------------------------
В Java ви можете використовувати `==` для порівняння обох, примітивних та типів посилань. На примітивних типах Java `==` перевіряє еквівалентінсть значень, як в Scala. На типах посилань, однак, Java `==` порівнює еквівалентність посилань, що означає, що дві змінні посилаються на той самий об'єкт в купі JVM. Scala також провадить здатність порівняти еквівалентність посилань, під ім'ям `eq`. Однак `eq` та його протилежність, `ne`, застосовується тільки для об'єктів. що напряму відзеркалюються на Java об'єкти. Повні деталі щодо `eq` та `ne` надаються в Розділі 11.1 та 11.2. Також дивіться Главу 30 щодо того, як писати гарний метод `equals`.

5.9 Преоритети та асоціативність операторів
-------------------------------------------
Преоритет операторів визначає, яка частина виразу обчислюється перед іншими частинами. Наприклад, вираз `2 + 2 * 7` обчислюється до `16`, не `28`, оскільки оператор `*` має вищий преоритет, ніж оператор `+`. Таким чином, частина множення обчислюється перед частиною додавання. Ви можете, звичайно, використати дужки для прояснення порядку обчислення, або щоб перекрити преоритети. Наприклад, якщо ви дійсно бажаєте отримати результат виразу вище 28, ви можете записати вираз таким чином:
[source,scala]
----
(2 + 2) * 7
----
Беручи до уваги, що Scala не має операторів як таких, а тільки спосіб використовувати методи в операторній нотації, ви можете здивуватись, як роблять преоритети операцій. Scala визначає преоритет базуючись на першому символі методів, використаних в операторній нотації (є одне виключення з цього правила, що буде продискутоване на наступних сторінках). Якщо ім'я метода починається з `*`, наприклад, він буде мати вищий преоритет, ніж метод, що починається з `+`. Таким чином, `2 + 2 * 7` буде еквівалентне до `2 + (2 * 7)`. Подібно, `a +++ b *** c` (в якому `a`, `b`, та 'c' є змінні, а `+++` та `***` є методи) буде обчислене як `a +++ (b *** c)`, оскікльки метод `***` має вищий преоритет, ніж метод `+++`.

[caption="Таблиця 5.3: "]
.Преоритети операцій
[cols="1,1,1,1"]
|===
||(всі спеціальні символи)||
||* / %||
||+ -||
||:||
||= !||
||< >||
||& ^||
||\|||
||(всі літери)||
||(всі оператори присвоєння)||
|===

Таблиця 5.3 показує преоритети, надані першим літерам метода в порярдку зменшення преоритету, де символи на одному рядку мають один преоритет. Чим вище символ в цій таблиці, тим вищий преоритет методів, що починаються з цього символа. Ось приклад, що ілюструє вплив преоритетів:
[source,scala]
----
scala> 2 << 2 + 2
res41: Int = 32
----
Метод `<<` починається з символа `<`, що стоїть нижче в Таблиці 5.3, ніж символ `+`, що є першим та єдиним символом метода `+`. Таким чином, `<<` буде мати нижчий преоритет, ніж `+`, і вираз буде обчислений починаючи з метода `+`, потім метода `<<`, як в `2 << (2 + 2)`. `2 + 2` є `4`, за нашими підрахунками, та `2 << 4` дає `32`. Якщо ми поміняємо оператори, ви отримаєте інший результат:
[source,scala]
----
scala> 2 + 2 << 2
res42: Int = 16
----
Оскільки перші символи такі самі, що в попередньому прикладі, методи будуть викликані в тому самому порядку. Спочатку буде викликаний метод `+`, потім метод `<<`. Так що `2 + 2` знову дасть 4, та `4 << 2` є `16`.

Одне виключення з правила преоритетів, до якого ми посилались раніше, стосується  операторів присвоєння, що завершуються на знак рівності. Якщо оператор закінчується на знак рівності(=), і це не один з операторів порівняння: `>=`, `==`, або `!=`, тоді преоритет оператора такий самий, як в простого присвоєння (=). Тобто, він меньший ніж преоритет любого іншого оператора. Наприклад: 
[source,scala]
----
x *= y + 1 
----
значить те саме, що і:
[source,scala]
----
x *= (y + 1)
----
оскільки `*=` класифікується як оператор присвоєння, чий преоритет нижчий, ніж `+`, навіть незважаючи, що перший символ оператора `*`, що мало б підказувати преоритет, вищий за `+`.

Коли декілька операторів з однаковим преоритеттом стоять поряд в виразі, асоциативність операторів визначає групування. Асоциативність операторів в Scala визначається останнімсимволом. Як зазначалось в Главі 3, любий метод, що завершується на симол `:` викликається не своєму правому операнді. Методи, що завершуються на любий інший символ, роблять навпаки: вони викликаються на своєму лівому операнді, передаючи правий операнд. 

Так що `a * b` дає `a.*(b)`, але `a:::b` дає `b.:::(a)`.

Оданк неважливо, яку асоциативніть має оператор, його операнди завжди використовуються зліва направо. Так що якщо `a` є виразом, що не тільки просте посилання на незмінне значення, тоді `a:::b` більш точно трактується як в наступному блоці:
[source,scala]
----
{ val x = a; b.:::(x) }
----
В цьому блоці `a` все одне обчислюється раніше за `b`, та потім результат передається до метода `b.:::`.

Це правило асоціативності також відіграє роль, коли декілька оператоорів з однаковим преоритетом стоять поряд. Якщо метод завершується на `:`, вони групуються зліва направо. Наприклад, `a:::b:::c` трактується як `a:::(b:::c)`. Але `a * b * c`, для контрасту, трактується як `(a * b) * c`. Преоритетність операторів я частиною мови Scala. Вам не треба лякатись використовувати її. Тим не менш, є гарним стилем використовувати дужки для прояснення, які операції ідуть за якими в виразі. Можливо, єдині преоритети, на які ви можете дійсно розраховувати, що інші програмісти мають знати без підглядання, це мультиплікативні оператори: `*`, `/`, та `%`, мають преоритет над аддитивними, `+` та `-`. Так що навіть якщо `a + b << c` дає бажаний вами результат без дужок, додаткова ясність, яку дасть запис `(a + b) << c`, може зменшити частоту, з якою ваш колега буде використовувати ваше ім'я в операторній нотації, наприклад, вигукуючи в розпачі "`bills !*&\^%~ code!`".footnote:[Тепер в маєте бути в змозі зрозуміти, що маючи цей код, компілятор Scala буде викликати (bills.!*&\^%~(code)).!().]

5.10 Багаті огортки
-------------------
Ви можете викликати значно більше методів на базових типах Scala, ніж показано в Таблиці 5.4. Ці методи доступні через неявні перетворення, прийом, що буде описаний в деталях в Главі 21. Все що вам покі що треба знати, це що для кожного базового типу, описаного в цій главі, також існує "багата огортка", що провадить декілька додаткових методів. Таким чином, щоб подивитись всі доступні методи для базового типу, вам слід дивитись документацію API по багатій огортці для базового типу. Ці класи перелічені в Таблиці 5.5.

[caption="Таблиця 5.4: "]
.Деякі багаті операції
[cols="1,1",options="header"]
|===
^| Код ^| Результат

a|
[source,scala]
----
0 max 5
----
| 5

a|
[source,scala]
----
0 min 5
----
| 0

a|
[source,scala]
----
-2.7 abs
----
| 2.7

a|
[source,scala]
----
-2.7 round
----
| -3L

a|
[source,scala]
----
1.5 isInfinity
----
| false

a|
[source,scala]
----
(1.0 / 0) isInfinity
----
| true

a|
[source,scala]
----
4 to 6
----
| Range(4, 5, 6)

a|
[source,scala]
----
"bob" capitalize
----
| "Bob"

a|
[source,scala]
----
"robert" drop 2
----
| "bert"
|===

[caption="Таблиця 5.5: "]
.Багаті типи огортки
[cols="1^,1^",options="header"]
|===
| Базовий тип | Багата огортка
| Byte | scala.runtime.RichByte
| Short | scala.runtime.RichShort
| Int | scala.runtime.RichInt 
| Long | scala.runtime.RichLong
| Char | scala.runtime.RichChar
| Float | scala.runtime.RichFloat
| Double | scala.runtime.RichDouble 
| Boolean | scala.runtime.RichBoolean
| String | scala.collection.immutable.StringOps
|===

5.11 Висновок
-------------
Головний висновок з цієї глави в тому, що операції в Scala є викликами методів, та що для базових типів Scala існують неявні перетворення до збагачених типів, що додають це більше корисних методів. В наступній главі ми покажемо, що це значить розробляти об'єкти в функціональному стилі, що дає нові реалізації операторів, які ви бачили в цій главі.
