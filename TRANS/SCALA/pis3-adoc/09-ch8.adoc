include::headers.adoc[]

Глава 8
-------

Функції та замикання
====================

Коли програма стає більшою, вам треба якийсь спосіб поділити її на меньші, більш керовані частини. Щоб поділити поток керування, Scala пропонує підхід, знайомий всім досвідченим програмістам: поділення коду на функції. Фактично, Scala пропонує декілька способів визначити фінкції, які не присутні в Java. Крім методів, що є функціями, що є членами деякого об'єкту, також є функції, що вкладені в функції, функціональні літерали, та функціональні значення. Ця глава бере вас в тур по всім цім різновидам функцій в Scala.

8.1 Методи
----------
Найбільш загальний спосіб визначити функцію є член деякого об'єкта; така функція називається методом. Наприклад, Лістинг 8.1 показує два методи, що разом читають файл з заданим ім'ям, та друкують всі рядки, чия довжина перевищує задану довжину. Кожний надрукований рядок має префікс з імені файлу, де він з'являєтья.
[source,scala]
----
import scala.io.Source

object LongLines {

  def processFile(filename: String, width: Int) = {
    val source = Source.fromFile(filename)
    for (line <- source.getLines())
      processLine(filename, width, line)
  }

  private def processLine(filename: String,
      width: Int, line: String) = {
    if (line.length > width)
      println(filename + ": " + line.trim)
  }
}
----
Лістинг 8.1 - `LongLines` з приватним методом `processLine`.

Метод `processFile` приймає ім'я файлу та ширину як параметри. Він створює об'єкт `Source` з файла, в генераторі виразу `for`, викликає `getLines` на `source`. Як зазначається на Кроці 12 в Главі 3, `getLines` повертає ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи символ нового рядка. Вираз `for` обробляє кожний з ціх рядків, викликаючи допоміжний метод `processLine`. Метод `processLine` приймає три параметри: ім'я файлу, ширину та рядок. Він перевіряє, чи довжина рядка більша, ніж задана довжина, і якщо це так, друкує ім'я файла, дві крапки та рядок.

Щоб використовувати `LongLines` з командного рядка, ми створимо застосування, що очікує довжину рядка в якості свого першого аргументу командного рядка, та інтерпретує подальші аргументи як імена файлів:footnote:[І цій книжці ми зазвичай не будемо перевіряти аргументи командного рядка на валідність в застосування-прикладах, обоє, щоб зберігти дерева, та зменшити шаблонний код, що може затьмарити важливий код приклада. Компромісом є те, що замість продукувати корисне повідомлення про помилку, коли отриманий поганий ввід, наше приклад застосування буде закидати виключення.]
[source,scala]
----
object FindLongLines {
  def main(args: Array[String]) = {
    val width = args(0).toInt
    for (arg <- args.drop(1))
      LongLines.processFile(arg, width)
  }
}
----
Ось як ви використовуєте це застосування для пошуку рядків в `LongLines.scala`, що понад 45 символів в довжину (такий тільки один):
----
$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) = {
----
Доки все це дуже подібне до того, що ми робити в любій об'єктно-орієнтовній мові. Однак концепція функції в  Scala є більш загальною, ніж метод. Інші шляхи Scala для вираженян функцій будуть пояснені в наступних розділах.

8.2 Локальні функції
--------------------
Конструкція метода `processFile` в попередньму розділі демонструє важливий принцип розробки в стилі функціонального програмування: програми мають бути розкладені на багато малих функцій, кожна з яких робить добре визначене завдання. Окремі функції часто досить малі. Перевага цього стилю в тому, що він дає програмісту багато будівельних блоків, що можуть бути гнучко скомпоновані для виконання більш складних речей. Кожний будівельний блок має бути досить простим, щоб бути індивідуально зрозумілим.

Одна проблема з цім підходом в тому, що всі імена допоміжних функцій можуть заповнити простір імен програми. В інтерпретаторі це невелика проблема, але коли функції запаковані в повторно використовувані класи та об'єкти, бажано приховати допоміжні функції від клієнтів класу. Вони часто не мають сенсу окремо, та ви часто бажаєте зберігти досить гнучкості видалити допомжіну функцію, якщо потім перепишете клас в інший спосіб.

В Java ваш головний інструмент для цієї цілі є приватний метод. Підхід приватних методів робить в Scala також, як демонструє Лістинг 8.1, але Scala пропонує додатковий підхід: ви можете визначити функцію всередині іншої функції. Так само, як локальні змінні, такі локальні функції видимі тільки в своєму оточуючому блоці. Ось приклад:
[source,scala]
----
def processFile(filename: String, width: Int) = {

  def processLine(filename: String,
      width: Int, line: String) = {
    if (line.length > width)
      println(filename + ": " + line.trim)
  }

  val source = Source.fromFile(filename)
  for (line <- source.getLines()) {
    processLine(filename, width, line)
  }
}
----
В цьому прикладі ми зробили рефакторинг оригінальної версії `LongLines`, показаної в Лістингу 8.1, трансформуючи приватний метод `processLine` в локальну функцію `processFile`. Щоб зробити це, ми видалили модифікатор `private`, який може бути застосований (і тілько коли потрібно) тільки для методів, та поклали визначення `processLine` всередину визначення `processFile`. Як локальна функція, `processLine` в полі зору `processFile`, але недоступна ззовні. Однак тепер, коли `processLine` визначена всередині `processFile`, стає можливим ще одне покращення. Зауважте, як `filename` та `width` передаються незмінними до допоміжної функції? Це не є необхідним, бо локальні функції можуть отримувати доступ до параметрів оточуючої їх функції. Ви можете просто використовувати параметри зовнішньої функції `processLine`, як показане в Лістингу 8.2.
[source,scala]
----
import scala.io.Source

object LongLines {
  def processFile(filename: String, width: Int) = {

    def processLine(line: String) = {
      if (line.length > width)
        println(filename + ": " + line.trim)
    }

    val source = Source.fromFile(filename)
    for (line <- source.getLines())
      processLine(line)
  }
}
----
Лістинг 8.2 - `LongLines` з локальною функцією `processLine`.

Простіше, чи не так? Це використання параметрів оточуючою функції є загальним та корисним прикладом загального вкладання, яке провадить Scala. Вкладання та поле зору, описані в Розділі 7.7, стосуються всіх конструкцій Scala, включаючи функції. Це простий принцип, але дуже потужний, особливо в мові з першокласними функціями.

8.3 Першокласні функції
-----------------------
Scala має першокласні функції. Не тільки вона визначає функції та викликає їх, але ви можете писати функції як неіменовані літерали, та потім передавати їх як значення. Ми ввели функціональні літерали в Главі 2, та показані в базовому синтаксисі на Малюнку 2.2.

Функціональний літерал компілюється в клас, екземпляр якого створюється під час виконання, що і є значенням функції.footnote:[Кожне функціональне значення є примірником деякого класу, що розширює один з `FunctionNtraits` в пакунку `scala`, такий як `Function0` для функцій без параметрів, `Function1` для функцій з одним параметром, і так далі. Кожний трейт `FunctionN` має метод `apply`, що використовується для виклику функції.] Таким чином, різниця між функціональними літералами і значеннями в тому, що функціональні літерали існують в джерельному коді, тоді як значення функцій існують як об'єкт під час виконання. Різниця в основному така, як між класами (джерельний код) та об'єктами (час виконання).

Ось простий приклад функціонального літерала, що додає одиницю до числа:
[source,scala]
----
(x: Int) => x + 1
----
`=>` означає, що ця функція конвертує річ зліва (любе ціле `x`) на річ зправа `(x + 1)`. Так що ця функція конвертує любе ціле `x` на `x + 1`. Значення функцій є об'єктами, так що ви можете зберігати їх в змінних, якщо бажаєте. Вони також функції, так що ви можете викликати їх, використовуючи звичайну нотацію виклику функцій з дужками. Ось приклад того і іншого:
[source,scala]
----
scala> var increase = (x: Int) => x + 1
increase: Int => Int = <function1>

scala> increase(10)
res0: Int = 11
----
Оскільки в цьому прикладі `increase` є `var`, пізніше ви можете присвоїти їй інше функціональне значення.
[source,scala]
----
scala> increase = (x: Int) => x + 9999
increase: Int => Int = <function1>

scala> increase(10)
res1: Int = 10009
----
Якщо ви бажаєте більше ніж одне твердження в функціональному літералі, оточіть його тіло в фігурні дужки, та покладіть твердження по одному на рядок, таким чином формуючи блок. Так само, як в методі, коли обчислюється функціональний літерал всі твердження будуть обчислені, та буде повернуте значення з функції, що відповідає обчисленню останнього виразу.
[source,scala]
----
scala> increase = (x: Int) => {
  println("We")
  println("are")
  println("here!")
  x + 1
}

increase: Int => Int = <function1>
scala> increase(10)
We
are
here!
res2: Int = 11
----
Тепер ви бачили всі принаддя функціональних літералів та функціональних значень. Багато Scala бібліотек дають вам можливіть використовувати їх. Наприклад, метод `foreach` доступний для всіх колекцій.footnote:[Метод `foreach` визначений в трейті `Traversable`, це загальний супертрейт для `List`, `Set`, `Array`, та `Map`. Дивіться Главу 17 щодо деталей.] Він приймає функцію як аргумент, та викликає цю функцію для кожного елемента. Ось як він може використовуватись для друку всіх елементів списка:
[source,scala]
----
scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala> someNumbers.foreach((x: Int) => println(x))
-11
-10
-5
0
5
10
----
Як інший приклад, типи колекцій мають метод `filter`. Цей метод відбирає елементи колекції, що проходять наданий користувачем тест. Цей тест надається використовуючи функцію. Наприклад, функція `function (x: Int) => x > 0` може використовуватись для фільтрації. Ця функція відзеркалює додатні цілі на `true`, та всі інші на `false`. Ось як використовувати її з фільтром:
[source,scala]
----
scala> someNumbers.filter((x: Int) => x > 0)
res4: List[Int] = List(5, 10)
----
Методи, як `foreach` та `filter` описані далі в цій книжці. Глава 16 каже про їх використання в класі `List`. Глава 17 обговорює їх використання з іншими типами колекцій.

8.4 Короткі форми функціональних літералів
------------------------------------------
Scala провадить декілька шляхів для відкидання надлишкової інформації, та написання функціональних літералів більш скорочено. Придивіться краще до ціх можливостей, оскільки вони дозволяють вам видалити безлад з вашого кода.

Один шлях зробити функціональні літерали більш короткими, це відкинути типи парамертів. Такім чином, попередній приклад з `filter` може бути записаний таким чином:
[source,scala]
----
scala> someNumbers.filter((x) => x > 0)
res5: List[Int] = List(5, 10)
----
Компілятор Scala знає, що `x` має бути цілим, оскільки він бачить, що ви безпосередньо фикористовуєте функцію для фільтрації списку цілих (на який посилається `someNumbers`). Це називається цільовий тип, оскільки цільове використання виразу (в цьому випадку аргумент до `someNumbers.filter()`) може впливати на тип цього виразу (в цьому випадку для визначення типу параметра `x`). Точні деталі цільової типізації не є важливі. Ви можете просто почати написання функціонального літералу без типу аргументу, та якщо компілятор збентежений додайте тип. З часом ви набудете відчуття, в яких ситуаціях компілятор може або не може вирішити загадку.

Другий шлях видалити непотрібні символи, це прибрати дужки коло параметра, чий тип виведений. В попередньому прикладі дужки коло `x` непотрібні:
[source,scala]
----
scala> someNumbers.filter(x => x > 0)
res6: List[Int] = List(5, 10)
----
8.5 Синтаксис замінника
-----------------------
Щоб зробити функціональний функціонал ще більш стислим, ви можете використовувати підкреслення для одного або більше параметрів, доки кожний параметр з'являється тільки один раз в функціональному літералі. Наприклад, `_ > 0` є дуже коротка нотація для функції, що перевіряє, чи значення більше за нуль:
[source,scala]
----
scala> someNumbers.filter(_ > 0)
res7: List[Int] = List(5, 10)
----
Ви можете думати про підкреслення як про "порожнє місце" в виразі, що треба "заповнити". Пусте місце буде заповнене аргументом функції, кожний раз, коли функція викликається. Наприклад, приймаючи, що `someNumbers` було тут ініціалізоване як `valueList(-11, -10, -5, 0, 5, 10)`, метод `filter` буде замінювати порожнє місце в `_ > 0` спочатку на `-11`, як в `-11 > 0`, потім на `-10`, як в `-10 > 0`, потім на `-5`, як в `- 5 > 0`, і так далі, до кінця `List`. Таким чином, функція `literal _ > 0`, еквівалентна до трохи більш балакучої `x => x > 0`, як продемонстроване тут:
[source,scala]
----
scala> someNumbers.filter(x => x > 0)
res8: List[Int] = List(5, 10)
----
Іноді, коли ви використовуєте підкреслення як замінники для параметрів, компілятор може не мати досить інформації, щоб вивести відсутні типи параметрів. Наприклад, уявімо, що ви пишете окреме  `_ + _`:
[source,scala]
----
scala> val f = _ + _
<console>:7: error: missing parameter type for expanded
function ((x$1, x$2) => x$1.$plus(x$2))
       val f = _ + _
               ^
----
In such cases, you can specify the types using a colon, like this:
[source,scala]
----
scala> val f = (_: Int) + (_: Int)
f: (Int, Int) => Int = <function2>

scala> f(5, 10)
res9: Int = 15
----
Зауважте, що `_ + _` розширюється до літерала для функції, що приймає два параметри. Ось чому ви можете писати цю коротку форму, тільки якщо кожний параметр з'являється в функціональному літералі рівно один раз. Декілька підкреслень означають декілька параметрі, не повторне використання одного параметра. Перше підкреслення представляє перший параметр, друге підкреслення - другий параметр, третє підкреслення третій параметр, і так далі.

8.6 Частково застосовані функції
--------------------------------
Хоча попередні приклади замінюють підкреслення на окремі параметри, ви також можете замітити цілий список параметрів на підкреслення. Наприклад, скоріше, ніж писати `println(_)`, ви можете написати `println _`. Ось приклад:
[source,scala]
----
someNumbers.foreach(println _)
----
Scala розглядає цю коротку форму так, якби ми написали наступне:
[source,scala]
----
someNumbers.foreach(x => println(x))
----
Таким чином, підкреслення в цьому випадку не є замінником для одного параметру. Це замінник для цілого списку параметрів. Пам'ятайте, що вам треба залишити один проміжок між ім'ям функції та підкресленням; інакше компілятор буде думати, що ви посилаєтесь на інший символ, як, наприклад, мето на ім'я `println_`, що навряд чи існує.

Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи любі необхідні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад, маючи наступну функцію:
[source,scala]
----
scala> def sum(a: Int, b: Int, c: Int) = a + b + c
sum: (a: Int, b: Int, c: Int)Int
----
Ви можете застосувати функцію `sum` до аргументів `1`, `2`, та `3` ось так:
[source,scala]
----
scala> sum(1, 2, 3)
res10: Int = 6
----
ЧАстково застосована функція є вираз, до якого ви не застосували всі аргументи, потрібні для функції. Замість цього ви надаєте деякі, або жодних з потрібних аргументів. Наприклад, щоб створити вираз частково застосованої функції, що включає `sum`, якій ви не надаєте жодної з трьох потрібних аргументів, ви просто ставите підкреслення після `sum`. Результуюча функція потім може бути збережена в змінній. Ось приклад:
[source,scala]
----
scala> val a = sum _
a: (Int, Int, Int) => Int = <function3>
----
Маючи цей код, компілятор Scala створює примірник функції, що приймає три цілі параметри, відсутні в виразі частково застосованої функції `sum _`, та присвоює посилання на значення цієї нової функції до змінної `a`. Потім ви застосовуєте три аргументи до значення цієї нової функції, яка в свою чергу викликає `sum`, передаючи ті самі три параметри:
[source,scala]
----
scala> a(1, 2, 3)
res11: Int = 6
----
Ось що тільки но тут відбулось: змінна на ім'я `a` посилається на об'єкт з функціональним значенням. Це функціональне значення є примірником класу, згенерованого автоматично компілятором Scala з `sum _`, вираза частково застосованої функції. Згенерований компілятором клас має метод `apply`, що приймає три аргументи.footnote:[Згенерований клас розширює трейт `Function3`, що декларує метод `apply` з трьома аргументами.] Метод `apply` згенерованого класу приймає три аргументи, оскільки рівно стільки аргументів не вистачає в виразі `sum _`. Компілтор Scala транслює вираз `a(1, 2, 3)` на виклик меетода значення `apply`, передаючи три аргументи, `1`, `2`, та `3`. Таким чином, `a(1, 2, 3)` є скороченням для:
[source,scala]
----
scala> a.apply(1, 2, 3)
res12: Int = 6
----
Цей метод `apply`, визначений в автоматично згенерованому класі компілятором Scala з виразу `sum _`, просто пересилає ці три невистачаючі параметри до `sum`, та повертає результат. В цьому випадку, `apply` викликає `sum(1, 2, 3)`, та повертає те, що повертає `sum`, наразі `6`. Інший спосіб думати про цей різновид виразів, в яких підкреслення використовується для представлення цілого списку параметрів, як про шлях перетворити `def` в функціональне значення. Наприклад, якщо ви маєте локальну функцію, таку як `sum(a: Int, b: Int, c: Int): Int`, ви можете "огорнути" її в функціональне значення, чий метод `apply` матиме той самий список параметрів та типи результата. Потім ви застосовуєте `apply` цього функціонального значення до деяких аргументів, який, в свою чергу, застосовує `sum` до тих самих аргументів, та повертає повернутий результат. Хоча ви не можете присвоїти метод або вкладену функцію до змінної, або передати її як аргумент до іншої функції, ви можете робити ці речі, якщо ви огорнете метод або вкладену функцію в функціональне значення, поставивши підкреслення після її імені.

Тепер, хоча `sum _` безумовно частково застосована функція, в такий спосіб вам може не виглядати очевидним, чому вона названа саме так. Вона має це ім'я, оскільки ви не застосовуєте цю функцію до всіх аргументів. В випадку `sum _`, ви не застосували її до жодного її аргументу. Але ви також можете виразити частково застосовану функцію, надавши тільки деякі з потрібних аргументів. Ось приклад:
[source,scala]
----
scala> val b = sum(1, _: Int, 3)
b: Int => Int = <function1>
----
In this case, you've supplied the first and last argument to sum, but not the middle argument. Since only one argument is missing, the Scala compiler generates a new function class whoseapply method takes one argument. When invoked with that one argument, this generated function's apply method invokes sum, passing in 1, the argument passed to the function, and 3. Here are some examples:
[source,scala]
----
scala> b(2)
res13: Int = 6
----
In this case, b.apply invoked sum(1, 2, 3).
[source,scala]
----
scala> b(5)
res14: Int = 9
----
And in this case, b.apply invoked sum(1, 5, 3).
If you are writing a partially applied function expression in which you leave off all parameters, such
as println _ or sum _, you can express it more concisely by leaving off the underscore if a function is
required at that point in the code. For example, instead of printing out each of the numbers
in someNumbers (defined here) like this:
someNumbers.foreach(println _)
You could just write:
someNumbers.foreach(println)
This last form is allowed only in places where a function is required, such as the invocation
offoreach in this example. The compiler knows a function is required in this case,
becauseforeach requires that a function be passed as an argument. In situations where a function is not
required, attempting to use this form will cause a compilation error. Here's an example:
scala> val c = sum
<console>:8: error: missing arguments for method sum;
follow this method with `_' if you want to treat it as a
partially applied function
val c = sum
^
scala> val d = sum _d: (Int, Int, Int) => Int = <function3>
scala> d(10, 20, 30)
res14: Int = 60
8.7 CLOSURES
So far in this chapter, all the examples of function literals have referred only to passed parameters. For
example, in (x: Int) => x > 0, the only variable used in the function body, x > 0, is x, which is defined
as a parameter to the function. You can, however, refer to variables defined elsewhere:
(x: Int) => x + more
// how much more?
This function adds "more" to its argument, but what is more? From the point of view of this
function, more is a free variable because the function literal does not itself give a meaning to it.
The x variable, by contrast, is a bound variable because it does have a meaning in the context of the
function: it is defined as the function's lone parameter, an Int. If you try using this function literal by
itself, without any more defined in its scope, the compiler will complain:
scala> (x: Int) => x + more
<console>:8: error: not found: value more
(x: Int) => x + more
^
WHY THE TRAILING UNDERSCORE?
Scala's syntax for partially applied functions highlights a difference in the design trade-offs of Scala
and classical functional languages, such as Haskell or ML. In these languages, partially applied
functions are considered the normal case. Furthermore, these languages have a fairly strict static type
system that will usually highlight every error with partial applications that you can make. Scala bears a
much closer relation to imperative languages, such as Java, where a method that's not applied to all its
arguments is considered an error. Furthermore, the object-oriented tradition of subtyping and a
universal root type accepts some programs that would be considered erroneous in classical functional
languages.
For instance, say you mistook the drop(n: Int) method of List for tail(), and therefore forgot you need to
pass a number to drop. You might write, "println(drop)". Had Scala adopted the classical functional
tradition that partially applied functions are OK everywhere, this code would type check. However, you
might be surprised to find out that the output printed by this println statement would always
be <function>! What would have happened is that the expression drop would have been treated as a
function object. Because println takes objects of any type, this would have compiled OK, but it would
have given an unexpected result.
To avoid situations like this, Scala normally requires you to specify function arguments that are left out
explicitly, even if the indication is as simple as a `_'. Scala allows you to leave off even the _ only when
a function type is expected.On the other hand, the same function literal will work fine so long as there is something available
named more:
scala> var more = 1
more: Int = 1
scala> val addMore = (x: Int) => x + more
addMore: Int => Int = <function1>
scala> addMore(10)
res16: Int = 11
The function value (the object) that's created at runtime from this function literal is called aclosure. The
name arises from the act of "closing" the function literal by "capturing" the bindings of its free
variables. A function literal with no free variables, such as (x: Int) => x + 1, is called a closed term,
where a term is a bit of source code. Thus a function value created at runtime from this function literal
is not a closure in the strictest sense, because (x: Int) => x + 1is already closed as written. But any
function literal with free variables, such as(x: Int) => x + more, is an open term. Therefore, any
function value created at runtime from(x: Int) => x + more will, by definition, require that a binding for
its free variable, more, be captured. The resulting function value, which will contain a reference to the
captured morevariable, is called a closure because the function value is the end product of the act of
closing the open term, (x: Int) => x + more.
This example brings up a question: What happens if more changes after the closure is created? In Scala,
the answer is that the closure sees the change. For example:
scala> more = 9999
more: Int = 9999
scala> addMore(10)
res17: Int = 10009
Intuitively, Scala's closures capture variables themselves, not the value to which variables refer.footnote:[By contrast, Java's inner classes do not allow you to access modifiable variables in surrounding scopes at all, so there is no difference between capturing a variable and capturing its currently held value.] As
the previous example shows, the closure created for (x: Int) => x + more sees the change to more made
outside the closure. The same is true in the opposite direction. Changes made by a closure to a captured
variable are visible outside the closure. Here's an example:
scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala> var sum = 0
sum: Int = 0
scala> someNumbers.foreach(sum +=
scala> sum
res19: Int = -11
_)This example uses a roundabout way to sum the numbers in a List. Variable sum is in a surrounding
scope from the function literal sum += _, which adds numbers to sum. Even though it is the closure
modifying sum at runtime, the resulting total, -11, is still visible outside the closure.
What if a closure accesses some variable that has several different copies as the program runs? For
example, what if a closure uses a local variable of some function, and the function is invoked many
times? Which instance of that variable gets used at each access?
Only one answer is consistent with the rest of the language: the instance used is the one that was active
at the time the closure was created. For example, here is a function that creates and returns "increase"
closures:
def makeIncreaser(more: Int) = (x: Int) => x + more
Each time this function is called it will create a new closure. Each closure will access the morevariable
that was active when the closure was created.
scala> val inc1 = makeIncreaser(1)
inc1: Int => Int = <function1>
scala> val inc9999 = makeIncreaser(9999)
inc9999: Int => Int = <function1>
When you call makeIncreaser(1), a closure is created and returned that captures the value 1 as the
binding for more. Similarly, when you call makeIncreaser(9999), a closure that captures the
value 9999 for more is returned. When you apply these closures to arguments (in this case, there's just
one argument, x, which must be passed in), the result that comes back depends on how more was
defined when the closure was created:
scala> inc1(10)
res20: Int = 11
scala> inc9999(10)
res21: Int = 10009
It makes no difference that the more in this case is a parameter to a method call that has already
returned. The Scala compiler rearranges things in cases like these so that the captured parameter lives
out on the heap, instead of the stack, and thus can outlive themethod call that created it. This
rearrangement is all taken care of automatically, so you don't have to worry about it. Capture any
variable you like: val, var, or parameter.
8.8 SPECIAL FUNCTION CALL FORMS
Most functions and function calls you encounter will be as you have seen so far in this chapter. The
function will have a fixed number of parameters, the call will have an equal number of arguments, and
the arguments will be specified in the same order and number as the parameters.Since function calls are so central to programming in Scala, however, a few special forms of function
definitions and function calls have been added to the language to address some special needs. Scala
supports repeated parameters, named arguments, and default arguments.
Repeated parameters
Scala allows you to indicate that the last parameter to a function may be repeated. This allows clients to
pass variable length argument lists to the function. To denote a repeated parameter, place an asterisk
after the type of the parameter. For example:
scala> def echo(args: String*) =
for (arg <- args) println(arg)
echo: (args: String*)Unit
Defined this way, echo can be called with zero to many String arguments:
scala> echo()
scala> echo("one")
one
scala> echo("hello", "world!")
hello
world!
Inside the function, the type of the repeated parameter is an Array of the declared type of the parameter.
Thus, the type of args inside the echo function, which is declared as type "String*" is
actually Array[String]. Nevertheless, if you have an array of the appropriate type, and you attempt to
pass it as a repeated parameter, you'll get a compiler error:
scala> val arr = Array("What's", "up", "doc?")
arr: Array[String] = Array(What's, up, doc?)
scala> echo(arr)
<console>:10: error: type mismatch;
found
: Array[String]
required: String
echo(arr)
^
To accomplish this, you'll need to append the array argument with a colon and an _* symbol,like this:
scala> echo(arr: _*)
What's
up
doc?
This notation tells the compiler to pass each element of arr as its own argument to echo, rather than all
of it as a single argument.Named arguments
In a normal function call, the arguments in the call are matched one by one in the order of the
parameters of the called function:
scala> def speed(distance: Float, time: Float): Float =
distance / time
speed: (distance: Float, time: Float)Float
scala> speed(100, 10)
res27: Float = 10.0
In this call, the 100 is matched to distance and the 10 to time. The 100 and 10 are matched in the same
order as the formal parameters are listed.
Named arguments allow you to pass arguments to a function in a different order. The syntax is simply
that each argument is preceded by a parameter name and an equals sign. For example, the following
call to speed is equivalent to speed(100,10):
scala> speed(distance = 100, time = 10)
res28: Float = 10.0
Called with named arguments, the arguments can be reversed without changing the meaning:
scala> speed(time = 10, distance = 100)
res29: Float = 10.0
It is also possible to mix positional and named arguments. In that case, the positional arguments come
first. Named arguments are most frequently used in combination with default parameter values.
Default parameter values
Scala lets you specify default values for function parameters. The argument for such a parameter can
optionally be omitted from a function call, in which case the corresponding argument will be filled in
with the default.
An example is shown in Listing 8.3. Function printTime has one parameter, out, and it has a default
value of Console.out.
def printTime(out: java.io.PrintStream = Console.out) =
out.println("time = " + System.currentTimeMillis())
Listing 8.3 - A parameter with a default value.
If you call the function as printTime(), thus specifying no argument to be used for out, then outwill be
set to its default value of Console.out. You could also call the function with an explicit output stream.
For example, you could send logging to the standard error output by calling the function
as printTime(Console.err).
Default parameters are especially helpful when used in combination with named parameters. In Listing
8.4, function printTime2 has two optional parameters. The out parameter has a default of Console.out,
and the divisor parameter has a default value of 1.def printTime2(out: java.io.PrintStream = Console.out,
divisor: Int = 1) =
out.println("time = " + System.currentTimeMillis()/divisor)
Listing 8.4 - A function with two parameters that have defaults.
Function printTime2 can be called as printTime2() to have both parameters filled in with their default
values. Using named arguments, however, either one of the parameters can be specified while leaving
the other as the default. To specify the output stream, call it like this:
printTime2(out = Console.err)
To specify the time divisor, call it like this:
printTime2(divisor = 1000)
8.9 TAIL RECURSION
In Section 7.2, we mentioned that to transform a while loop that updates vars into a more functional
style that uses only vals, you may sometimes need to use recursion. Here's an example of a recursive
function that approximates a value by repeatedly improving a guess until it is good enough:
def approximate(guess: Double): Double =
if (isGoodEnough(guess)) guess
else approximate(improve(guess))
A function like this is often used in search problems, with appropriate implementations
forisGoodEnough and improve. If you want the approximate function to run faster, you might be
tempted to write it with a while loop to try and speed it up, like this:
def approximateLoop(initialGuess: Double): Double = {
var guess = initialGuess
while (!isGoodEnough(guess))
guess = improve(guess)
guess
}
Which of the two versions of approximate is preferable? In terms of brevity and var avoidance, the
first, functional one wins. But is the imperative approach perhaps more efficient? In fact, if we measure
execution times, it turns out that they are almost exactly the same!
This might seem surprising because a recursive call looks much more "expansive" than a simple jump
from the end of a loop to its beginning. However, in the case of approximate above, the Scala compiler
is able to apply an important optimization. Note that the recursive call is the last thing that happens in
the evaluation of function approximate's body. Functions likeapproximate, which call themselves as
their last action, are called tail recursive. The Scala compiler detects tail recursion and replaces it with
a jump back to the beginning of the function, after updating the function parameters with the new
values.The moral is that you should not shy away from using recursive algorithms to solve your problem.
Often, a recursive solution is more elegant and concise than a loop-based one. If the solution is tail
recursive, there won't be any runtime overhead to be paid.
Tracing tail-recursive functions
A tail-recursive function will not build a new stack frame for each call; all calls will execute in a single
frame. This may surprise a programmer inspecting a stack trace of a program that failed. For example,
this function calls itself some number of times then throws an exception:
def boom(x: Int): Int =
if (x == 0) throw new Exception("boom!")
else boom(x - 1) + 1
This function is not tail recursive, because it performs an increment operation after the recursive call.
You'll get what you expect when you run it:
scala> boom(3)
java.lang.Exception: boom!
at .boom(<console>:5)
at .boom(<console>:6)
at .boom(<console>:6)
at .boom(<console>:6)
at .<init>(<console>:6)
...
TAIL CALL OPTIMIZATION
The compiled code for approximate is essentially the same as the compiled code forapproximateLoop.
Both functions compile down to the same thirteen instructions of Java bytecodes. If you look through
the bytecodes generated by the Scala compiler for the tail recursive method, approximate, you'll see
that although both isGoodEnough and improveare invoked in the body of the method, approximate is
not. The Scala compiler optimized away the recursive call:
public double approximate(double);
Code:
0:
aload_0
1:
astore_3
2:
aload_0
3:
dload_1
4:
invokevirtual
#24; //Method isGoodEnough:(D)Z
7:
ifeq
12
10: dload_1
11: dreturn
12: aload_0
13: dload_1
14: invokevirtual
#27; //Method improve:(D)D
17: dstore_1
18: goto
2
If you now modify boom so that it does become tail recursive:
def bang(x: Int): Int =if (x == 0) throw new Exception("bang!")
else bang(x - 1)
You'll get:
scala> bang(5)
java.lang.Exception: bang!
at .bang(<console>:5)
at .<init>(<console>:6) ...
This time, you see only a single stack frame for bang. You might think that bang crashed before it
called itself, but this is not the case. If you think you might be confused by tail-call optimizations when
looking at a stack trace, you can turn them off by giving the following argument to the scala shell or to
the scalac compiler:
-g:notailcalls
With that option specified, you will get a longer stack trace:
scala> bang(5)
java.lang.Exception: bang!
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .<init>(<console>:6) ...
Limits of tail recursion
The use of tail recursion in Scala is fairly limited because the JVM instruction set makes implementing
more advanced forms of tail recursion very difficult. Scala only optimizes directly recursive calls back
to the same function making the call. If the recursion is indirect, as in the following example of two
mutually recursive functions, no optimization is possible:
def isEven(x: Int): Boolean =
if (x == 0) true else isOdd(x - 1)
def isOdd(x: Int): Boolean =
if (x == 0) false else isEven(x - 1)
You also won't get a tail-call optimization if the final call goes to a function value. Consider for
instance the following recursive code:
val funValue = nestedFun _
def nestedFun(x: Int) : Unit = {
if (x != 0) { println(x); funValue(x - 1) }
}
The funValue variable refers to a function value that essentially wraps a call to nestedFun. When you
apply the function value to an argument, it turns around and applies nestedFun to that same argument,
and returns the result. Therefore, you might hope the Scala compiler would perform a tail-calloptimization, but in this case it would not. Tail-call optimization is limited to situations where a method
or nested function calls itself directly as its last operation, without going through a function value or
some other intermediary. (If you don't fully understand tail recursion yet, see Section 8.9).
8.10 CONCLUSION
This chapter has given you a grand tour of functions in Scala. In addition to methods, Scala provides
local functions, function literals, and function values. In addition to normal function calls, Scala
provides partially applied functions and functions with repeated parameters. When possible, function
calls are implemented as optimized tail calls, and thus many nice-looking recursive functions run just
as quickly as hand-optimized versions that use whileloops. The next chapter will build on these
foundations and show how Scala's rich support for functions helps you abstract over control.
