include::headers.adoc[]

Глава 8
-------

Функції та замикання
====================

Коли програма стає більшою, вам треба якийсь спосіб поділити її на меньші, більш керовані частини. Щоб поділити поток керування, Scala пропонує підхід, знайомий всім досвідченим програмістам: поділення коду на функції. Фактично, Scala пропонує декілька способів визначити фінкції, які не присутні в Java. Крім методів, що є функціями, що є членами деякого об'єкту, також є функції, що вкладені в функції, функціональні літерали, та функціональні значення. Ця глава бере вас в тур по всім цім різновидам функцій в Scala.

8.1 Методи
----------
Найбільш загальний спосіб визначити функцію є член деякого об'єкта; така функція називається методом. Наприклад, Лістинг 8.1 показує два методи, що разом читають файл з заданим ім'ям, та друкують всі рядки, чия довжина перевищує задану довжину. Кожний надрукований рядок має префікс з імені файлу, де він з'являєтья.
[source,scala]
----
import scala.io.Source

object LongLines {

  def processFile(filename: String, width: Int) = {
    val source = Source.fromFile(filename)
    for (line <- source.getLines())
      processLine(filename, width, line)
  }

  private def processLine(filename: String,
      width: Int, line: String) = {
    if (line.length > width)
      println(filename + ": " + line.trim)
  }
}
----
Лістинг 8.1 - `LongLines` з приватним методом `processLine`.

Метод `processFile` приймає ім'я файлу та ширину як параметри. Він створює об'єкт `Source` з файла, в генераторі виразу `for`, викликає `getLines` на `source`. Як зазначається на Кроці 12 в Главі 3, `getLines` повертає ітератор, що провадить один рядок з файла на кожній ітерації, виключаючи символ нового рядка. Вираз `for` обробляє кожний з ціх рядків, викликаючи допоміжний метод `processLine`. Метод `processLine` приймає три параметри: ім'я файлу, ширину та рядок. Він перевіряє, чи довжина рядка більша, ніж задана довжина, і якщо це так, друкує ім'я файла, дві крапки та рядок.

Щоб використовувати `LongLines` з командного рядка, ми створимо застосування, що очікує довжину рядка в якості свого першого аргументу командного рядка, та інтерпретує подальші аргументи як імена файлів:footnote:[І цій книжці ми зазвичай не будемо перевіряти аргументи командного рядка на валідність в застосування-прикладах, обоє, щоб зберігти дерева, та зменшити шаблонний код, що може затьмарити важливий код приклада. Компромісом є те, що замість продукувати корисне повідомлення про помилку, коли отриманий поганий ввід, наше приклад застосування буде закидати виключення.]
[source,scala]
----
object FindLongLines {
  def main(args: Array[String]) = {
    val width = args(0).toInt
    for (arg <- args.drop(1))
      LongLines.processFile(arg, width)
  }
}
----
Ось як ви використовуєте це застосування для пошуку рядків в `LongLines.scala`, що понад 45 символів в довжину (такий тільки один):
----
$ scala FindLongLines 45 LongLines.scala
LongLines.scala: def processFile(filename: String, width: Int) = {
----
Доки все це дуже подібне до того, що ми робити в любій об'єктно-орієнтовній мові. Однак концепція функції в  Scala є більш загальною, ніж метод. Інші шляхи Scala для вираженян функцій будуть пояснені в наступних розділах.

8.2 Локальні функції
--------------------
Конструкція метода `processFile` в попередньму розділі демонструє важливий принцип розробки в стилі функціонального програмування: програми мають бути розкладені на багато малих функцій, кожна з яких робить добре визначене завдання. Окремі функції часто досить малі. Перевага цього стилю в тому, що він дає програмісту багато будівельних блоків, що можуть бути гнучко скомпоновані для виконання більш складних речей. Кожний будівельний блок має бути досить простим, щоб бути індивідуально зрозумілим.

Одна проблема з цім підходом в тому, що всі імена допоміжних функцій можуть заповнити простір імен програми. В інтерпретаторі це невелика проблема, але коли функції запаковані в повторно використовувані класи та об'єкти, бажано приховати допоміжні функції від клієнтів класу. Вони часто не мають сенсу окремо, та ви часто бажаєте зберігти досить гнучкості видалити допомжіну функцію, якщо потім перепишете клас в інший спосіб.

В Java ваш головний інструмент для цієї цілі є приватний метод. Підхід приватних методів робить в Scala також, як демонструє Лістинг 8.1, але Scala пропонує додатковий підхід: ви можете визначити функцію всередині іншої функції. Так само, як локальні змінні, такі локальні функції видимі тільки в своєму оточуючому блоці. Ось приклад:
[source,scala]
----
def processFile(filename: String, width: Int) = {

  def processLine(filename: String,
      width: Int, line: String) = {
    if (line.length > width)
      println(filename + ": " + line.trim)
  }

  val source = Source.fromFile(filename)
  for (line <- source.getLines()) {
    processLine(filename, width, line)
  }
}
----
В цьому прикладі ми зробили рефакторинг оригінальної версії `LongLines`, показаної в Лістингу 8.1, трансформуючи приватний метод `processLine` в локальну функцію `processFile`. Щоб зробити це, ми видалили модифікатор `private`, який може бути застосований (і тілько коли потрібно) тільки для методів, та поклали визначення `processLine` всередину визначення `processFile`. Як локальна функція, `processLine` в полі зору `processFile`, але недоступна ззовні. Однак тепер, коли `processLine` визначена всередині `processFile`, стає можливим ще одне покращення. Зауважте, як `filename` та `width` передаються незмінними до допоміжної функції? Це не є необхідним, бо локальні функції можуть отримувати доступ до параметрів оточуючої їх функції. Ви можете просто використовувати параметри зовнішньої функції `processLine`, як показане в Лістингу 8.2.
[source,scala]
----
import scala.io.Source

object LongLines {
  def processFile(filename: String, width: Int) = {

    def processLine(line: String) = {
      if (line.length > width)
        println(filename + ": " + line.trim)
    }

    val source = Source.fromFile(filename)
    for (line <- source.getLines())
      processLine(line)
  }
}
----
Лістинг 8.2 - `LongLines` з локальною функцією `processLine`.

Простіше, чи не так? Це використання параметрів оточуючою функції є загальним та корисним прикладом загального вкладання, яке провадить Scala. Вкладання та поле зору, описані в Розділі 7.7, стосуються всіх конструкцій Scala, включаючи функції. Це простий принцип, але дуже потужний, особливо в мові з першокласними функціями.

8.3 Першокласні функції
-----------------------
Scala має першокласні функції. Не тільки вона визначає функції та викликає їх, але ви можете писати функції як неіменовані літерали, та потім передавати їх як значення. Ми ввели функціональні літерали в Главі 2, та показані в базовому синтаксисі на Малюнку 2.2.

Функціональний літерал компілюється в клас, екземпляр якого створюється під час виконання, що і є значенням функції.footnote:[Кожне функціональне значення є примірником деякого класу, що розширює один з `FunctionNtraits` в пакунку `scala`, такий як `Function0` для функцій без параметрів, `Function1` для функцій з одним параметром, і так далі. Кожний трейт `FunctionN` має метод `apply`, що використовується для виклику функції.] Таким чином, різниця між функціональними літералами і значеннями в тому, що функціональні літерали існують в джерельному коді, тоді як значення функцій існують як об'єкт під час виконання. Різниця в основному така, як між класами (джерельний код) та об'єктами (час виконання).

Ось простий приклад функціонального літерала, що додає одиницю до числа:
[source,scala]
----
(x: Int) => x + 1
----
`=>` означає, що ця функція конвертує річ зліва (любе ціле `x`) на річ зправа `(x + 1)`. Так що ця функція конвертує любе ціле `x` на `x + 1`. Значення функцій є об'єктами, так що ви можете зберігати їх в змінних, якщо бажаєте. Вони також функції, так що ви можете викликати їх, використовуючи звичайну нотацію виклику функцій з дужками. Ось приклад того і іншого:
[source,scala]
----
scala> var increase = (x: Int) => x + 1
increase: Int => Int = <function1>

scala> increase(10)
res0: Int = 11
----
Оскільки в цьому прикладі `increase` є `var`, пізніше ви можете присвоїти їй інше функціональне значення.
[source,scala]
----
scala> increase = (x: Int) => x + 9999
increase: Int => Int = <function1>

scala> increase(10)
res1: Int = 10009
----
Якщо ви бажаєте більше ніж одне твердження в функціональному літералі, оточіть його тіло в фігурні дужки, та покладіть твердження по одному на рядок, таким чином формуючи блок. Так само, як в методі, коли обчислюється функціональний літерал всі твердження будуть обчислені, та буде повернуте значення з функції, що відповідає обчисленню останнього виразу.
[source,scala]
----
scala> increase = (x: Int) => {
  println("We")
  println("are")
  println("here!")
  x + 1
}

increase: Int => Int = <function1>
scala> increase(10)
We
are
here!
res2: Int = 11
----
Тепер ви бачили всі принаддя функціональних літералів та функціональних значень. Багато Scala бібліотек дають вам можливіть використовувати їх. Наприклад, метод `foreach` доступний для всіх колекцій.footnote:[Метод `foreach` визначений в трейті `Traversable`, це загальний супертрейт для `List`, `Set`, `Array`, та `Map`. Дивіться Главу 17 щодо деталей.] Він приймає функцію як аргумент, та викликає цю функцію для кожного елемента. Ось як він може використовуватись для друку всіх елементів списка:
[source,scala]
----
scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)
scala> someNumbers.foreach((x: Int) => println(x))
-11
-10
-5
0
5
10
----
Як інший приклад, типи колекцій мають метод `filter`. Цей метод відбирає елементи колекції, що проходять наданий користувачем тест. Цей тест надається використовуючи функцію. Наприклад, функція `function (x: Int) => x > 0` може використовуватись для фільтрації. Ця функція відзеркалює додатні цілі на `true`, та всі інші на `false`. Ось як використовувати її з фільтром:
[source,scala]
----
scala> someNumbers.filter((x: Int) => x > 0)
res4: List[Int] = List(5, 10)
----
Методи, як `foreach` та `filter` описані далі в цій книжці. Глава 16 каже про їх використання в класі `List`. Глава 17 обговорює їх використання з іншими типами колекцій.

8.4 Короткі форми функціональних літералів
------------------------------------------
Scala провадить декілька шляхів для відкидання надлишкової інформації, та написання функціональних літералів більш скорочено. Придивіться краще до ціх можливостей, оскільки вони дозволяють вам видалити безлад з вашого кода.

Один шлях зробити функціональні літерали більш короткими, це відкинути типи парамертів. Такім чином, попередній приклад з `filter` може бути записаний таким чином:
[source,scala]
----
scala> someNumbers.filter((x) => x > 0)
res5: List[Int] = List(5, 10)
----
Компілятор Scala знає, що `x` має бути цілим, оскільки він бачить, що ви безпосередньо фикористовуєте функцію для фільтрації списку цілих (на який посилається `someNumbers`). Це називається цільовий тип, оскільки цільове використання виразу (в цьому випадку аргумент до `someNumbers.filter()`) може впливати на тип цього виразу (в цьому випадку для визначення типу параметра `x`). Точні деталі цільової типізації не є важливі. Ви можете просто почати написання функціонального літералу без типу аргументу, та якщо компілятор збентежений додайте тип. З часом ви набудете відчуття, в яких ситуаціях компілятор може або не може вирішити загадку.

Другий шлях видалити непотрібні символи, це прибрати дужки коло параметра, чий тип виведений. В попередньому прикладі дужки коло `x` непотрібні:
[source,scala]
----
scala> someNumbers.filter(x => x > 0)
res6: List[Int] = List(5, 10)
----
8.5 Синтаксис замінника
-----------------------
Щоб зробити функціональний функціонал ще більш стислим, ви можете використовувати підкреслення для одного або більше параметрів, доки кожний параметр з'являється тільки один раз в функціональному літералі. Наприклад, `_ > 0` є дуже коротка нотація для функції, що перевіряє, чи значення більше за нуль:
[source,scala]
----
scala> someNumbers.filter(_ > 0)
res7: List[Int] = List(5, 10)
----
Ви можете думати про підкреслення як про "порожнє місце" в виразі, що треба "заповнити". Пусте місце буде заповнене аргументом функції, кожний раз, коли функція викликається. Наприклад, приймаючи, що `someNumbers` було тут ініціалізоване як `valueList(-11, -10, -5, 0, 5, 10)`, метод `filter` буде замінювати порожнє місце в `_ > 0` спочатку на `-11`, як в `-11 > 0`, потім на `-10`, як в `-10 > 0`, потім на `-5`, як в `- 5 > 0`, і так далі, до кінця `List`. Таким чином, функція `literal _ > 0`, еквівалентна до трохи більш балакучої `x => x > 0`, як продемонстроване тут:
[source,scala]
----
scala> someNumbers.filter(x => x > 0)
res8: List[Int] = List(5, 10)
----
Іноді, коли ви використовуєте підкреслення як замінники для параметрів, компілятор може не мати досить інформації, щоб вивести відсутні типи параметрів. Наприклад, уявімо, що ви пишете окреме  `_ + _`:
[source,scala]
----
scala> val f = _ + _
<console>:7: error: missing parameter type for expanded
function ((x$1, x$2) => x$1.$plus(x$2))
       val f = _ + _
               ^
----
In such cases, you can specify the types using a colon, like this:
[source,scala]
----
scala> val f = (_: Int) + (_: Int)
f: (Int, Int) => Int = <function2>

scala> f(5, 10)
res9: Int = 15
----
Зауважте, що `_ + _` розширюється до літерала для функції, що приймає два параметри. Ось чому ви можете писати цю коротку форму, тільки якщо кожний параметр з'являється в функціональному літералі рівно один раз. Декілька підкреслень означають декілька параметрі, не повторне використання одного параметра. Перше підкреслення представляє перший параметр, друге підкреслення - другий параметр, третє підкреслення третій параметр, і так далі.

8.6 Частково застосовані функції
--------------------------------
Хоча попередні приклади замінюють підкреслення на окремі параметри, ви також можете замітити цілий список параметрів на підкреслення. Наприклад, скоріше, ніж писати `println(_)`, ви можете написати `println _`. Ось приклад:
[source,scala]
----
someNumbers.foreach(println _)
----
Scala розглядає цю коротку форму так, якби ми написали наступне:
[source,scala]
----
someNumbers.foreach(x => println(x))
----
Таким чином, підкреслення в цьому випадку не є замінником для одного параметру. Це замінник для цілого списку параметрів. Пам'ятайте, що вам треба залишити один проміжок між ім'ям функції та підкресленням; інакше компілятор буде думати, що ви посилаєтесь на інший символ, як, наприклад, мето на ім'я `println_`, що навряд чи існує.

Коли ви використовуєте підкреслення в цей спосіб, ви пишете частково застосовану функцію. В Scala, коли ви викликаєте функцію, передаючи любі необхідні аргументи, ви застосовуєте цю функцію до аргументів. Наприклад, маючи наступну функцію:
[source,scala]
----
scala> def sum(a: Int, b: Int, c: Int) = a + b + c
sum: (a: Int, b: Int, c: Int)Int
----
Ви можете застосувати функцію `sum` до аргументів `1`, `2`, та `3` ось так:
[source,scala]
----
scala> sum(1, 2, 3)
res10: Int = 6
----
ЧАстково застосована функція є вираз, до якого ви не застосували всі аргументи, потрібні для функції. Замість цього ви надаєте деякі, або жодних з потрібних аргументів. Наприклад, щоб створити вираз частково застосованої функції, що включає `sum`, якій ви не надаєте жодної з трьох потрібних аргументів, ви просто ставите підкреслення після `sum`. Результуюча функція потім може бути збережена в змінній. Ось приклад:
[source,scala]
----
scala> val a = sum _
a: (Int, Int, Int) => Int = <function3>
----
Маючи цей код, компілятор Scala створює примірник функції, що приймає три цілі параметри, відсутні в виразі частково застосованої функції `sum _`, та присвоює посилання на значення цієї нової функції до змінної `a`. Потім ви застосовуєте три аргументи до значення цієї нової функції, яка в свою чергу викликає `sum`, передаючи ті самі три параметри:
[source,scala]
----
scala> a(1, 2, 3)
res11: Int = 6
----
Ось що тільки но тут відбулось: змінна на ім'я `a` посилається на об'єкт з функціональним значенням. Це функціональне значення є примірником класу, згенерованого автоматично компілятором Scala з `sum _`, вираза частково застосованої функції. Згенерований компілятором клас має метод `apply`, що приймає три аргументи.footnote:[Згенерований клас розширює трейт `Function3`, що декларує метод `apply` з трьома аргументами.] Метод `apply` згенерованого класу приймає три аргументи, оскільки рівно стільки аргументів не вистачає в виразі `sum _`. Компілтор Scala транслює вираз `a(1, 2, 3)` на виклик меетода значення `apply`, передаючи три аргументи, `1`, `2`, та `3`. Таким чином, `a(1, 2, 3)` є скороченням для:
[source,scala]
----
scala> a.apply(1, 2, 3)
res12: Int = 6
----
Цей метод `apply`, визначений в автоматично згенерованому класі компілятором Scala з виразу `sum _`, просто пересилає ці три невистачаючі параметри до `sum`, та повертає результат. В цьому випадку, `apply` викликає `sum(1, 2, 3)`, та повертає те, що повертає `sum`, наразі `6`. Інший спосіб думати про цей різновид виразів, в яких підкреслення використовується для представлення цілого списку параметрів, як про шлях перетворити `def` в функціональне значення. Наприклад, якщо ви маєте локальну функцію, таку як `sum(a: Int, b: Int, c: Int): Int`, ви можете "огорнути" її в функціональне значення, чий метод `apply` матиме той самий список параметрів та типи результата. Потім ви застосовуєте `apply` цього функціонального значення до деяких аргументів, який, в свою чергу, застосовує `sum` до тих самих аргументів, та повертає повернутий результат. Хоча ви не можете присвоїти метод або вкладену функцію до змінної, або передати її як аргумент до іншої функції, ви можете робити ці речі, якщо ви огорнете метод або вкладену функцію в функціональне значення, поставивши підкреслення після її імені.

Тепер, хоча `sum _` безумовно частково застосована функція, в такий спосіб вам може не виглядати очевидним, чому вона названа саме так. Вона має це ім'я, оскільки ви не застосовуєте цю функцію до всіх аргументів. В випадку `sum _`, ви не застосували її до жодного аргументу. Але ви також можете виразити частково застосовану функцію, надавши тільки деякі з потрібних аргументів. Ось приклад:
[source,scala]
----
scala> val b = sum(1, _: Int, 3)
b: Int => Int = <function1>
----
В цьому випадку ви надали перший та останній аргумент до `sum`, але не до середнього аргументу. Оскікльки один аргумент відсутній, компілятор Scala генерує функціональний клас, чий метод `apply` приймає один аргумент. Коли викликаний з одним аргументом, метод `apply` цієї згенерованої функції викликає `sum`, передаючи `1`, аргумент, переданий до функції, та `3`. Ось деякі приклади:
[source,scala]
----
scala> b(2)
res13: Int = 6
----
В цьому випадку `b.apply` викликає `sum(1, 2, 3)`.
[source,scala]
----
scala> b(5)
res14: Int = 9
----
І в цьому випадку `b.apply` викликає `sum(1, 5, 3)`.

Якщо ви пишете частково застосовану функцію, в якій ви залишаєте всі параметри, таку як `println _` або `sum _`, ви можете виразити її більш стисло, відкинувши підкреслення, коли функція потрібна в цьому місці в коді. Наприклад, замість друкувати кожне число в `someNumbers` (визначена тут) ось так:
[source,scala]
----
someNumbers.foreach(println _)
----
Ви можете просто записати:
[source,scala]
----
someNumbers.foreach(println)
----
Ця остання форма дозволяється тільки в місціх, де потрібна функція, таких, як виклик  `foreach` в цьому прикладі. В цьому випадку компілятор знає що потрібна функція, оскільки `foreach` вимагає, щоб в якості аргумента була передана функція. В ситуаціях, коли функція не вимагається, спроба використати цю форму спричинить помилку компіляції. Ось приклад:
[source,scala]
----
scala> val c = sum
<console>:8: error: missing arguments for method sum;
follow this method with `_' if you want to treat it as a
partially applied function
       val c = sum
               ^

scala> val d = sum _
d: (Int, Int, Int) => Int = <function3>

scala> d(10, 20, 30)
res14: Int = 60
----

8.7 Замикання
-------------
Докі в цій главі всі приклади функціональних літералів посилались тільки для переданих параметрів. Наприклад, в `(x: Int) => x > 0`, єдиною змінною, що використовується в тілі функції, `x > 0`, `x`, що визначається як параметр функції. Однак ви можете посилатись на змінні, визначені деінде:
[source,scala]
----
(x: Int) => x + more // наскільки much?
----
Ця функція додає `more` до свого аргументу, але що таке `more`? З точки зору цієї функції, `more` є _вільна змінна_, оскільки сам функціональний літерал сам по собі не надає їй значення. На відміну, змінна `x` є _прив'язаною змінною_, оскільки вона має значення в контексті функції: вона визначена як єдиний параметр функції, `Int`. Якщо ви спробуєте використати цей функціональний літера сам по собі, без деякого `more`, визначеного в полі зору, компілятор буде скаржитись:
[source,scala]
----
scala> (x: Int) => x + more
<console>:8: error: not found: value more
               (x: Int) => x + more
                               ^
----

Чому завершуюче підкреслення?
-----------------------------
Синтаксис Scala для частково застосованих функцій підкреслює різницю між компромісами дизайну Scala, та класичних функціональних мов, таких як `Haskell` або `ML`. В ціх мовах, частково застосовані функції розглядаються як звичайний випадок. Більше того, ці мови мають досить сувору статичну систему типів, що зазвичай буде підкреслювати кожну помилку з частковим застосуванням, що ви можете зробити. Scala дотримується значно блищого відношення до імперативних мов, таких як Java, де метод, що не застосовується до всіх своїх аргументів розглядається як помилка. Більше того, об'єктно-орієнтовні традиції субтипізації і універсального кореневого типу приймає деякі програми, що мали б розглядатись як помилкові в класичних функціональних мовах.

Наприклад, скажімо, ви переплутали метод `drop(n: Int)` в `List` з `tail()`, і, таким чином, забули, що вам треба передати число до `drop`. Ви можете записати `println(drop)`. Коли б Scala приймала класичну функціональну традицію, що частково застосовані функції гарні будь-де, цей код пройшов би перевірку типів. Однак ви можете бути здивовані знайти, що результат, який буде друкувати це твердження `println`, буде завжди `<function>`! Що відбуєеться, це те, що вираз `drop` буде трактуватись як функціональний об'єкт. Оскільки  `println` приймає об'єкти любого типу, це буде компілюватись OK, але це матиме непередбачуваний результат.

Щоб уникати ситуацій як така, Scala звичайно потребує, щоб ви вказували аргументи функцій, що зщалишились, явно, навіть якщо вони вказані так просто, як символом `_`. Scala дозволяє вам відкинути `_` тільки коли очікується функціональний тип. З іншого боку, той же функціональний літерал буде робити добре, доки доступне дещо на ім'я `more`:
[source,scala]
----
scala> var more = 1
more: Int = 1

scala> val addMore = (x: Int) => x + more
addMore: Int => Int = <function1>

scala> addMore(10)
res16: Int = 11
----
Функціональне значення (об'єкт), що створений під час виконання з цього функціонального літерала, називається _замиканням_. Назва походить з дії "замикання" функціонального літерала, через "захоплення" прив'язок його вільних змінних. Функціональний літерал без вільних змінних, такий як `(x: Int) => x + 1`, називається _замкненим термом_, де _терм_ це фрагмент джерельного коду. Таким чином, функціональне значення, створене під час виконання з цього функціонального літерала не є замиканням в суворішому сенсі, оскікльи `(x: Int) => x + 1` вже замкнений як є написаний. Але кожний функціональний літерал з вільними змінними, як `(x: Int) => x + more`, є _відкритим термом_. Таким чином, любе функціональне значення, створене під час виконання з `(x: Int) => x + more` буде, по визначення, потребувати, щоб прив'язка до вільної змінної  `more` була захоплена. Отримане функціональне значення, що буде містити посилання на захоплену змінну `more`, називається замиканням, оскільки значення функції є кінцевим продуктом дії замикання відкритого терму `(x: Int) => x + more`.

This example brings up a question: What happens if more changes after the closure is created? In Scala, the answer is that the closure sees the change. For example:
[source,scala]
----
scala> more = 9999
more: Int = 9999

scala> addMore(10)
res17: Int = 10009
----
Інтуітивно, замикання Scala захоплюють самі змінні, не значення, на які посилаються змінні.footnote:[На відміну, внутрішні класи Java взагалі не дозволяють вам отримувати доступ до непостійних змінних в оточуючому полі зору, так що немає різниці між захопленням змінної, та захопленням її поточного значення.] Як показує попередній приклад, замикання, створене для `(x: Int) => x + more` бачить зміни в `more`, зроблені за межами замикання. Те саме вірно в зворотньому напрямку. Зміни, зроблені в замиканні до захопленої змінної, видимі за межами замикання. Ось приклад:
[source,scala]
----
scala> val someNumbers = List(-11, -10, -5, 0, 5, 10)
someNumbers: List[Int] = List(-11, -10, -5, 0, 5, 10)

scala> var sum = 0
sum: Int = 0

scala> someNumbers.foreach(sum += _)

scala> sum
res19: Int = -11
----
Цей приклад використовує обхідний шлях до підрахунку суми чисел в `List`. Змінна `sum` знаходиться в оточуючому полі зору відносно функціонального літерала `sum += _`, що додає числа до `sum`. Навіть зважаючи, що це замикання модифікує `sum` під час виконання, результуючий загал, `-11`, все ще видимий за межами замикання.

Що буде, якщо замикання має доступ до деякої змінної, що має декілька різних копій по мірі роботи програми? Наприклад, якщо замикання використовує локальну змінну деякої функції, та функція викликається декілька раз? ЯКий примірник цієї змінної буде використовуватись при кожному доступі?

Тільки одна відповідь узгоджена з залишком мови: використовується той примірник, що був активний під час створення замикання. Наприклад, ось функція, що створює та повертає замикання "збільшити":
[source,scala]
----
def makeIncreaser(more: Int) = (x: Int) => x + more
----
Кожний раз, коли викликається ця функція, вона буде створювати нове замикання. Кожне замикання буде отримувати доступ до змінної `more`, що була активною під час створення змінної.
[source,scala]
----
scala> val inc1 = makeIncreaser(1)
inc1: Int => Int = <function1>

scala> val inc9999 = makeIncreaser(9999)
inc9999: Int => Int = <function1>
----
Коли ви викликаєте `makeIncreaser(1)`, створюється та повертається замикання, що захоплює значення `1` як прив'язку для `more`. Подібним чином, коли ви викликаєте `makeIncreaser(9999)`, повертається замикання, що захоплює значення `9999` для `more`. Коли ви застосовуєте ці замикання для аргументів (в цьому випадку є тільки один аргумент, `x`, що має бути переданий), результат, що повертається, залежить від того, як було визначене `more` при створенні замикання:
[source,scala]
----
scala> inc1(10)
res20: Int = 11

scala> inc9999(10)
res21: Int = 10009
----
Немає різниці, що `more` в цьому випадку є параметром до виклику метода, який вже завершився. Компілятор Scala переставляє речі в випадках як цей, так що захоплений параметр живе в кіпі, замість стеку, і, таким чином, може пережити виклик метода, що створює його. Ця перестановка турботливо виконується автоматично, так що вам не треба про це турбуватись. Обчислюйте любу змінну, яку побажаєте: `val`, `var`, або параметр.

8.8 Спеціальні форми виклику функцій
------------------------------------
Більшість функцій та викликів функцій, які вам трапляться, будуть такі, які ви вже бачили в цій главі. Функція буде мати фіксоване число параметрів, виклик буде мати так же число аргументів, та аргументи будуть вказані в такому ж порядку та числі, що і параметри.

Одонак, оскільки виклики функцій є такими центральними для програмування в Scala, були додані декілька особливих форм визначення та викликів функцій, що націлені на вирішення особливих потреб. Scala підтримує повторювані параметри, іменовані аргументи та значення по замовчанню.

Repeated parameters
~~~~~~~~~~~~~~~~~~~
Scala дозволяє вам вказати, що вписок параметрів до функції може бути повторений. Це дозволяє клієнтам передати до функції список аргументів змінної довжини. Щоб позначити повторюваний параметр, поставьте зірочку після типу параметру. Наприклад:
[source,scala]
----
scala> def echo(args: String*) =
for (arg <- args) println(arg)
echo: (args: String*)Unit
----
Визначений таким чином, `echo` може бути викликаний з нулем або багатьма аргументів `String`:
[source,scala]
----
scala> echo()

scala> echo("one")
one

scala> echo("hello", "world!")
hello
world!
----
Всередині функції тип повторюваного параметру є `Array` декларованого типу параметру. Таким чином, тип `args` всередині функції `echo`, що декларований як тип `String*` насправді є `Array[String]`. Тим не менш, якщо ви маєте масив відповідного типу, ви можете спробувати передати його як повторюваний параметр, але отримаєте помилку компіляції:
[source,scala]
----
scala> val arr = Array("What's", "up", "doc?")
arr: Array[String] = Array(What's, up, doc?)

scala> echo(arr)
<console>:10: error: type mismatch;
found    : Array[String]
required : String
              echo(arr)
              ^
----
Щоб досягти цього, вам треба додати аргумент масиву з двокрапкою, та символ `_*`, ось так:
[source,scala]
----
scala> echo(arr: _*)
What's
up
doc?
----
ЦЯ нотація каже компілятору передати кожний елемент `arr` як окремий аргумент, ніж всі разом як один аргумент.

Іменовані аргументи
~~~~~~~~~~~~~~~~~~~
В звичайному виклику функції аргументи в виклику співпадають один до одного в порядку параметрів викликаної функції:
[source,scala]
----
scala> def speed(distance: Float, time: Float): Float =
         distance / time
speed: (distance: Float, time: Float)Float

scala> speed(100, 10)
res27: Float = 10.0
----
В цьому виклику `100` відповідає до `distance`, та `10` до `time`. `100` та `10` співпадають в тому ж порядку, в якому перелічені формальні параметри.

Іменовані аргументи дозволяють передати вам аргументи в функцію в іншому порядку. Синтаксис просто полягає в тому, що перед кожним аргументом стоіть ім'я параметру та знак рівності. Наприклад, наступний виклик до `speed` еквівалентний до `speed(100,10)`:
[source,scala]
----
scala> speed(distance = 100, time = 10)
res28: Float = 10.0
----
Called with named arguments, the arguments can be reversed without changing the meaning:
----
scala> speed(time = 10, distance = 100)
res29: Float = 10.0
----
Також можливо змішувати позиційні та іменовані аргументи. В цьому випадку позщиційні аргументи ідуть першими. Іменовані аргументи найбільш часто використовуються в комбінації зі заначеннями параметрів по замовчанню.

Значення параметрів по замовчанню
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scala дозволяє вам вказувати значення по замовчанню для параметрів функцій. Аргумент для кожного такого параметру може бути опціонально пропущений в виклику функції, та в такому випадку відповідний аргумент буде заповнений значенням по замовчанню.

Приклад показаний в Лістингу 8.3. Функція `printTime` маж один параметр, `out`, і він має значення по замовчанню `Console.out`.
[source,scala]
----
def printTime(out: java.io.PrintStream = `Console.out`) =
  out.println("time = " + System.currentTimeMillis())
----
Listing 8.3 - Параметр зі значенням по замовчанню.

Якщо ви викличете функцію як `printTime()`, таким чином не вказуючи аргумента, що буде вказувати на пристрій виводу `out`, тоді `out` буде встановлений в його значення по замовчанню, `Console.out`. Ви можете також викликати функцію з явним потоком виводу. Наприклад, ви можете надіслати журналювання до стандарного виводу помилок, викликавши функцію як `printTime(Console.err)`. Параметри по замовчанню особливо корисні, коли використовуються в комбінації з іменованими параметрами. В Лістигу 8.4 функція `printTime2` має два опціональні параметри. Параметр `out` має по замовчанню значення `Console.out`, та параметр `divisor` має значення по замовчанню `1`.
[source,scala]
----
def printTime2(out: java.io.PrintStream = Console.out,
               divisor: Int = 1) =
out.println("time = " + System.currentTimeMillis()/divisor)
----
Лістинг 8.4 - Функція з двома параметрами, що мають значення по замовчанню.

Функція `printTime2` може бути викликана як `printTime2()` щоб мати обоє свої параметри заповненими їх значеннями по замовчанню. Однак через іменовані аргументи один з параметрів може бути заданий, коли інший буде встановлений по замовчанню. Щоб вказати вихідний потік, викличте функцію таким чином:
[source,scala]
----
printTime2(out = Console.err)
----
Щоб задати дільник часу, викличте його так:
[source,scala]
----
printTime2(divisor = 1000)
----
8.9 Хвостова рекурсія
---------------------
В розділі 7.2 ми згадували, що для трансформації цикла `while`, що оновлює `var`, на більш функціональний стиль, що використовує тільки `val`, ви можете іноді потребувати використання рекурсії. Ось приклад рекурсивоної функції, що апроксимує значення, постійно покращуючи здогадку, доки вона не стане досить гарною:
[source,scala]
----
def approximate(guess: Double): Double =
  if (isGoodEnough(guess)) guess
  else approximate(improve(guess))
----
Функція як ця часто використовується в проблемах пошуку, з відповідними реалізаціями `isGoodEnough` та `improve`. Якщо ви бажаєте, щоб функція `approximate` виконувались скоріше, ви можете підпасти в спокусу написати цикл `while`, що спробувати пришвидшити її, ось так:
[source,scala]
----
def approximateLoop(initialGuess: Double): Double = {
  var guess = initialGuess
  while (!isGoodEnough(guess))
    guess = improve(guess)
  guess
}
----
Яка з двох версій `approximate` переважає? В термінах краткості та уникнення `var` перша, функціональна, перемагає. Але імперативний підхід, можливо, більш ефективний? Фактично, якщо заміряти час виконання, з'ясується, що вони майже ідеально однакові!

Це може виглядати несподіванкою, оскільки рекурсивний виклик виглядає значно більш "коштовним", чи простий стрибок з кінця циклу на початок. Однак в випадку `approximate` вище компілятор Scala здатний застосувати важливу оптимізацію. Зверніть увагу, що рекурсивний виклик є останєю річчю, що трапляється в обчисленні тіла функції `approximate`. Функції як `approximate`, що викликають себе як свою останню дію, називаються хвостово рекурсивними. Компілятор Scala детектує хвостову рекурсію, та замінює його на стрибок назад, на початок функції, після оновлення параметрів функції новими значеннями.

Мораль цього в том, що ви не повинні цураитсь використання рекурсивних алгоритмів для вирішення ваших проблем. Часто рекурсивне рішення є більш елегантним та стислим, ніж базований на циклі. Як рішення має хвостову рекурсію, не виникне ніякого навантаження часу виконання, що треба сплачувати.

Трасування функцій з хвостовою рекурсією
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Функція з хвостовою рекорсією не буде будувати новий фрейм стека для кожного виклика; всі виклики будуть викликатись в одному фреймі. Це може бути несподіванкою для програмістів, коли вони переглядатимуть трасу стеку програми, що схибила. Наприклад, ця функція викликає сама себе деяке число разів, та потім закидає виключення:
[source,scala]
----
def boom(x: Int): Int =
  if (x == 0) throw new Exception("boom!")
  else boom(x - 1) + 1
----
Ця функція не має хвостової рекурсії, оскільки вона виконує операцію інкремента після рекурсивного виклику. Ви отримаєте те що очікували, якщо запустите цю програму:
[source,scala]
----
scala> boom(3)
java.lang.Exception: boom!
at .boom(<console>:5)
at .boom(<console>:6)
at .boom(<console>:6)
at .boom(<console>:6)
at .<init>(<console>:6)
...

Оптимізаця хвостової рекурсії
-----------------------------
Скомпільований код для `approximate` в основному є те саме, що і скомпільований код для `approximateLoop`. Обоє функції компілюються до тих самих тринадцяти інструкцій байткоду Java. Якщо ви подивитесь на байткод, згенерований компілятором Scala для метода з хвостовою рекурсією, `approximate`, ви побачите, що хоча обоє, `isGoodEnough` та `improveare` викликаються в тілі метода, `approximate` - ні. Компілятор Scala оптимізував геть рекурсивний виклик:
[source,scala]
----
public double approximate(double);
  Code:
  0:    aload_0
  1:    astore_3
  2:    aload_0
  3:    dload_1
  4:    invokevirtual #24; //Method isGoodEnough:(D)Z
  7:    ifeq  12
  10:   dload_1
  11:   dreturn
  12:   aload_0
  13:   dload_1 
  14:   invokevirtual #27; //Method improve:(D)D
  17:   dstore_1
  18:   goto 2
----
Якщо ви тепер модифікуєте `boom`, так, щоб вона тепер стала хвостово рекурсивною:
[source,scala]
----
def bang(x: Int): Int =if (x == 0) throw new Exception("bang!")
  else bang(x - 1)
----
Ви отримаєте:
[source,scala]
----
scala> bang(5)
java.lang.Exception: bang!
at .bang(<console>:5)
at .<init>(<console>:6) ...
----
НА цей раз ви бачите тільки один фрейм стеку для `bang`. Ви можете думати, що `bang` впала до того, як викликати себе, але це не той випадок. Якщо ви думаєте, що ви можете бути збентежені через хвостовою оптимізацією, коли переглядаєте на трасу стеку, ви можете відключити її, надавши наступний аргумент до оболонки `scala` або компілятору `scalac`: 
----
-g:notailcalls 
----
Коли вказана ця опція ви знову отримаєте довшу трасу стеку:
[source,scala]
----
scala> bang(5)
java.lang.Exception: bang!
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .bang(<console>:5)
at .<init>(<console>:6) ...
----
Обмеження хвостової рекурсії
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Використання хвостової рекурсії в Scala є досить обмеженої, оскільки набір інструкцій JVM робить реалізацію більш розвинених форм хвостової рекурсії дуже складною. Scala тільки оптимізує прямі рекурсивні виклики назад, до тої самої функції, що робить виклики. Якщо рекурсія непряма, оптимізація неможлива:
[source,scala]
----
def isEven(x: Int): Boolean =
  if (x == 0) true else isOdd(x - 1)

def isOdd(x: Int): Boolean =
  if (x == 0) false else isEven(x - 1)
----
Ви також не отримаєте хвостову оптимізацію, якщо фінальний виклик іде до функціонального значення. Розгляньте наприклад наступний рекурсивний код:
[source,scala]
----
val funValue = nestedFun _
def nestedFun(x: Int) : Unit = {
  if (x != 0) { println(x); funValue(x - 1) }
}
----
Значення змінної `funValue` посилається на функціональне значення, що в основному огортає виклик до `nestedFun`. Коли ви застосовуєте функціональне значення до аргументу, він робить свій хід, застосовує `nestedFun` до того самого аргументу, та повертає результат. Таким чином, ви маєте надію, що компілятор Scala буде робити хвостову оптимізацію, але в цьому випадку цього не буде. Оптимізація хвостового виклику обмежена до ситуацій, коли метод або вкладена функція викликає себе напряму в якості своєї останньої операції, без проходженню через функціональне значення, або деякий інший посередник. (Якщо ви досі не повністю розумієте хвостову рекурсію, дивіться Розділ 8.9).

8.10 Висновок
-------------
Ця глава надала вам гранд тур по функціях в Scala. На додаток до методів, Scala провадить локальні функції, функціональні літерали та функціональні значення. На додаток до нормальних функціональних викликів Scala провадить частково застосовані функції, та функції з повторюваними параметрами. Коли можливо, функціональні виклики реалізовані як оптимізовані хвостові виклики, і, таким чином, багато гарно виглядаючих рекурсивних функцій роблять так само швидко, як і оптимізовані вручну версії, що використовують цикли `while`. Наступна глава буде будуватись на ціх засадах, та покаже, як багата підтримка функцій в Scala допомагає вам абстрогуватись над керуванням.
