include::headers.adoc[]

Глава 20
--------

Абстрактні члени
================

Член класа або трейта є абстрактним, якщо член не має повного визначення в класі. Абстрактні члени призначені бути реалізованими в субкласах класа, в якому вони визначені. Ця ідея знаходиться в багатьох об'єктно-рієнтованих мовах. Наприклад, Java дозволяє вам декларувани абстрактні методи. Scala також дозволяє вам декларувати такі методи, як ви бачили в Розділі 10.2. Але Scala іде далі, і реалізує ідею в своїй повній загальності: крім методів, ви можете декларувати абстрактні поля, та навіть абстрактні типи, як члени класів та трейтів.

В цій главі ми опишемо всі типи абстрактних членів: `val`, `var`, методи та типи. По ходу ми обсудимо наперед-ініціалізовані поля, ліниві `val`, шлях-залежні типи та енумерації.

20.1 Швидкий тур для абстрактних членів
----------------------------------------
Наступний трейт декларує по одному з кожного типу абстрактних членів: абстрактний тип (`T`), метод (`transform`), `val` (`initial`), та `var` (`current`):
[source,scala]
----
trait Abstract {
  type T
  def transform(x: T): T
  val initial: T
  var current: T
}
----
Суцільна реалізація `Abstract` потребує заповнення визначень для кожного з його абстрактних членів. Ось приклад реалізації, що провадить ці визначення:
[source,scala]
----
class Concrete extends Abstract {
  type T = String
  def transform(x: String) = x + x
  val initial = "hi"
  var current = initial
}
----
Реалізація надає певне значення типу на ім'я `T`, через його визначення як псевдониму до типу `String`. Операція `transform` конкатенує наданий рядок з собою, та значення `initial` та `current` обоє встановлені в `"hi"`.

Цей приклад надає вам грубу першу ідею щодо типів абстрактних членів, що існують в Scala. Залишок глави буде презентувати деталі, та пояснювати, для чого гарні нові форми абстрактних членів, так само, як і типи членів взагалі.

20.2 Члени типів
----------------
Як ви можете бачити з приклада в попередньому розділі, термін _абстрактний тип_ в Scala означає тип, декларований (за допомогою ключового слова `type`) як член класу або трейта, без вказання визначення. Класи самі можуть бути абстрактними, та трейти по визначенню абстрактні, але на жодний з них не посилаються як на абстрактні типи в Scala. Абстрактний тип в Scala завжди є членом деякого класу або трейта, як тип `T` в трейті `Abstract`.

Ви можете думати про не-абстрактні (або _суцільні_) члени типів, як тип `T` в класі `Concrete`, як шлях для визначення нового визначення, або псевдоним, для типу. Наприклад, в класі `Concrete`, типу `String` наданий псевдоним `T`. Як результат, будь-де, де з'являється `T` в визначенні класа `Concrete`, це означає `String`. Це включає параметр і типи результатів для `transform`, `initial` та `current`, які згадують `T`, коли вони декларовані в супертрейті `Abstract`. Таким чином, коли клас `Concrete` реалізує ці методи, ці `T` інтерпретуються щоб означати `String`.

Одна з причин для використання члена типу є визначення коротких, описових псевдонимів для типів, чиє дійсне ім'я більш балакуче, або менш очевидне за значенням, ніж псевдоним. Такі члени типів можуть допомогти прояснити код класа або трейта. Інше головне використання членів типа є декларація абстрактних типів, що мають бути визначені в субкласах. Це використання, що було продемонстроване в попередньому розділі, буде детально описане в цій главі.

20.3 Абстрактні val
-------------------
Абстрактна декларація `val` має таку форму:
[source,scala]
----
val initial: String
----
Вона надає ім'я та тип для `val`, але не його значення. Це значення має бути запровадження через суцільне визначення `val` в субкласі. Наприклад, клас `Concrete` реалізує `val` з використанням:
[source,scala]
----
val initial = "hi"
----
Ви використовуєте абстрактну декларацію `val` в класі, коли ви не знаєте коректного значення в класі, але ви знаєте, що змінна буде мати незмінне значення для кожного примірника класа. 

Абстрактна декларація `val` повторює декларацію абстрактного безпараметричного метода, декларованого таким чином:
[source,scala]
----
def initial: String
----
Клієнтській код може посилатись на обох, `val` та метод, в точно той самий спосіб (тобто, `obj.initial`). Однак, якщо `initial` є абстрактна `val`, клієнту гарантовано, що `obj.initial` буде давати те саме значення кожний раз, коли на нього посилаються. Якщо `initial` буде абстрактний метод, ця гарантія не виконується, оскільки в цьому випадку `initial` може бути реалізований суцільним методом, що повертає різне значення при кожному виклику.

Іншими словами, абстрактний `val` обмежує свою легальну реалізацію: люба реалізація може бути визначенням `val`; це не може бути `var` або `def`. З іншого боку, абстрактні декларації методів можуть бути реалізовані на вибір, як визначення суцільного метода, або як суцільне визначення `val`. Беручи абстрактний клас `Fruit`, показаний в Лістингу 20.1, клас `Apple` буде легальною реалізацією субкласа, але клас `BadApple` ні.
[source,scala]
----
abstract class Fruit {
  val v: String // v означає value
  def m: String // m означає method
}

abstract class Apple extends Fruit {
  val v: String
  val m: String // OK перекривати def за допомогою val
}

abstract class BadApple extends Fruit {
  def v: String // ПОМИЛКА: не можна перекривати val за допомогою def
  def m: String
}
----
Лістинг 20.1 - Перекриття абстрактного `val` та безпараметрного метода.

20.4 Абстрактні var
-------------------
Подібно до абстрактного `val`, абстрактний `var` декларує лише ім'я і тип, але не початкове значення. Наприклад, Лістинг 20.2 показує трейт `AbstractTime`, що декларує дві абстрактні змінні на ім'я `hour` та `minute`:
[source,scala]
----
trait AbstractTime {
  var hour: Int
  var minute: Int
}
----
Лістинг 20.2 - Декларація абстрактних `var`.

Яке значення має визначення абстрактних `var`, як `hour` та `minute`?Ви бачили в Розділі 18.2, що `var`, задекларовані як члени класів ідуть обладнані методвами геттера та сеттера. Це дотримується також і для абстрактних методів. Якщо ви, наприклад, декларуєте абстрактний `var` на ім'я `hour`, ви неявно декларуєте абстрактний метод геттера, `hour`, та абстрактний метод сеттера, `hour_=`. Немає переприсвоюваного поля, що треба визначати — він надійде в субкласах, що визначають суцільну реалізацію абстрактного `var`. Наприклад, визначення `AbstractTime`, показане в Лістингу 20.2, в точності еквівалентна до визначення, показаній в Лістингу 20.3.
[source,scala]
----
trait AbstractTime {
  def hour: Int // геттер для hour
  def hour_=(x: Int) // сеттер для hour
  def minute: Int // геттер для minute
  def minute_=(x: Int) // сеттер для minute
}
----
Лістинг 20.3 - Як абстрактні `var` розширюються в геттери та сеттери.

20.5 Ініціалізація абстрактних val
----------------------------------
Абстрактні `val` іноді грають роль, аналогічну до параметрів суперкласу: вони дозволяють вам провадити деталі в субкласі, що відсутні в суперкласі. Це зокрема важливо для трейтів, оскільки трейти не мають конструктора, до якого ви можете передати параметри. Так що звичайна нотація параметризації трейтів робить через абстрактні `val`, що реалізовані в субкласах.

Як приклад, розглянемо переформулювання класу `Rational` з Глави 6, як показано на Лістингу 6.5, в вигляді трейта:
[source,scala]
----
trait RationalTrait {
  val numerArg: Int
  val denomArg: Int
}
----
Клас `Rational` з Глави 6 має два параметри: `n` для чисельника раціонального числа, та `d` для займенника. Наданий тут трейт `RationalTrait` визначає замість цього абстрактні `val`: `numerArg` та `denomArg`. Щоб створити суцільний примірник цього трейту, вам треба реалізувати визначення `val`. Ось приклад:
[source,scala]
----
new RationalTrait {
  val numerArg = 1
  val denomArg = 2
}
----
Тут ключове слово `new` з'являється перед іменем трейта, `RationalTrait`, за яким слідує тіло класа в фігурних дужках. Цей вираз дає примірник анонімного класу, що міксує трейт, та визначений в тілі. Цей окремий примірник анонімного класу має ефект, аналогічний створенню примірника `new Rational(1, 2)`.

Однак аналогія недосконала. Існує тонка різниця щодо порядку, в якому ініціалізуються вирази. Коли ви пишете:
[source,scala]
----
new Rational(expr1, expr2)
----
два вирази, `expr1` та `expr2`, обчислюються перед тим, як буде ініціалізований клас `Rational`, так що значення `expr1` та `expr2` доступні для ініціалізації класу `Rational`.

Для трейтів ситуація протилежна. Коли ви пишете:
[source,scala]
----
new RationalTrait {
  val numerArg = expr1
  val denomArg = expr2
}
----
вирази `expr1` та `expr2` обчислюються як частина ініціалізації анонімного класу, але анонімний клас ініціалізується _після_  `RationalTrait`. Так що значення `numerArg` та `denomArg` не доступні впродовж ініціалізації `RationalTrait` (більш точно, вибір любого зі значень буде давати значення по замовчанню для типу `Int`, `0`). Для визначення наданого вище `RationalTrait` це не проблема, оскільки ініціалізація трейта на використовує значення значень `numerArg` або `denomArg`. Однак це стає проблемою в варіанті `RationalTrait`, показаному в Лістингу 20.4, що визначає нормалізовані чисельник та займенник.
[source,scala]
----
trait RationalTrait {
  val numerArg: Int
  val denomArg: Int
  require(denomArg != 0)
  private val g = gcd(numerArg, denomArg)
  val numer = numerArg / g
  val denom = denomArg / g
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
  override def toString = numer + "/" + denom
}
----
Лістинг 20.4 - Трейт, що використовує свої абстрактні `val`.

Якщо ви спробуєте створити примірник цього трейту з деякими виразами чисельника та займенника, що не є простими літералами, ви отримаєте виключення:
[source,scala]
----
scala> val x = 2
x: Int = 2

scala> new RationalTrait {
          val numerArg = 1 * x
          val denomArg = 2 * x  
        }
java.lang.IllegalArgumentException: requirement failed
at scala.Predef$.require(Predef.scala:207)
at RationalTrait$class.$init$(<console>:10)
... 28 elided
----
В цьому прикладі виключення буде закинено через те, що `denomArg` все ще має значення по замовчанню, `0`, коли клас `RationalTrait` було ініціалізовано, що спричиняє збій при виклику `require`.

Цей приклад демонструє, що порядок ініціалізації не той самий для параметрів класів та абстрактних полів. Аргумент параметру класа обчислюється до того, як воно передається в клнструктор класу (за винятком коли параметр є за-ім'ям). Для контрасту, реалізація визначення `val` в субкласі обчислюється тільки після того, як суперклас був ініціалізований.

Тепер, коли ви розумієте, чому абстрактні `val` поводяться інакше, ніж параметри, гарно буде знати, що ми можемо з цім робити. Чи можливо визначити `RationalTrait`, що може бути ініціалізований надійно, без старху помилок через неініціалізовані поля? Фактично, Scala пропонує альтернативні рішення до цієї проблеми, пре-ініціалізовані поля та ліниві `val`. Вони представлені і залишку цього розділу.

Пре-ініціалізовані поля
~~~~~~~~~~~~~~~~~~~~~~~
Перше рішення, пре-ініціалізовані поля, дозволяє вам ініціалізувати поле субкласа перед тим, як буде викликано субклас. Щоб зробити це, просто покладіть визначення поля в фігурних дужках перед викликом конструктора суперкласа. Як приклад, Лістинг 20.5 показує іншу спробу створити примірник `RationalTrait`. Як ви бачите з приклада, розділ ініціалізації іде перед зазначенням супертрейта  `RationalTrait`. Обоє розділені `with`.
[source,scala]
----
scala> new {
  val numerArg = 1 * x
  val denomArg = 2 * x
} with RationalTrait
res1: RationalTrait = 1/2
----
Лістинг 20.5 - Пре-ініціалізовані поля в виразі анонімного класу.

Пре-ініціалізовані поля не обмежуються до анонімних класів; вони можуть також застосовуватись в об'єктах або іменованих субкласах. Два приклада показані в Лістингах 20.6 та 20.7. Як ви можете бачити з ціх прикладів, розділ пре-ініціалізації кожний раз іде після ключового слова `extends` визначеного об'єкта або класа. Клас `RationalClass`, показаний в Лістингу 20.7, надає приклад загальної схеми того, як параметри класів можуть бути зроблені доступними для ініціалізації супертрейта.
[source,scala]
----
object twoThirds extends {
  val numerArg = 2
  val denomArg = 3
} with RationalTrait
----
Лістинг 20.6 - Пре-ініціалізовані поля в визначенні об'єкта.
[source,scala]
----
class RationalClass(n: Int, d: Int) extends {
  val numerArg = n
  val denomArg = d
} with RationalTrait {
  def + (that: RationalClass) = new RationalClass(
    numer * that.denom + that.numer * denom,
    denom * that.denom
  )
}
----
Лістинг 20.7 - Пре-ініціалізовані поля в визначенні класу.

Оскільки пре-ініціалізовані поля є ініціалізовані перед викликом конструктора суперкласа, їх ініціалізатори не можуть посилатись на об'єкт, що наразі конструюється. Відповідно, якщо такий ініалізатор посилається на `this`, посилання іде на об'єкт, що містить клас або об'єкт, який конструюється, не на самий створюваний об'єкт.

Ось приклад:
[source,scala]
----
scala> new {
  val numerArg = 1
  val denomArg = this.numerArg * 2
} with RationalTrait
<console>:11: error: value numerArg is not a member of object
$iw
                val denomArg = this.numerArg * 2
                                    ^
----
Приклад не компілюється, оскільки посилання `this.numerArg` шукає  `numerArgfield` в об'єкті, що містить `new` (що в цьому випадку є синтетичним об'єктом на ім'я `$iw`, в який інтерпретатор покладає поля, що вводить користувач). Ще раз, пре-ініціалізовані поля поводяться в цьому відношенні як аргументи конструктора класа.

Ліниві `val`
~~~~~~~~~~~~
Ви можете використовувати пре-ініціалізовані поля для точної симуляції поведінки ініціалізації аргументів конструкторів класу. Однак іноді ви можете обрати дозволити системі самій з'ясувати, які речі мають бути ініціалізовані. Це може бути досягнуто через створення ваших визначень `val` як `lazy`. Якщо перед `val` поставити модифікатор `lazy`, вираз ініціалізації в правій стороні буде обчислений тільки перший раз, коли використовується `val`.

Наприклад, визначимо об'єкт `Demo` з `val` наступним чином:
[source,scala]
----
scala> object Demo {
  val x = { println("initializing x"); "done" }
}
defined object Demo
----
Тепер, спочатку посилаємось на `Demo`, потвм на `Demo.x`:
[source,scala]
----
scala> Demo
initializing x
res3: Demo.type = Demo$@2129a843

scala> Demo.x
res4: String = done
----
Як ви можете бачити, коли ви використовуєте `Demo`, його поле `x` стає ініціалізованим. Ініціалізація `x` формує частину ініціалізації `Demo`. Ситуація змінюється, якщо ви визначите поле `x` як `lazy`:
[source,scala]
----
scala> object Demo {
  lazy val x = { println("initializing x"); "done" }
}
defined object Demo

scala> Demo
res5: Demo.type = Demo$@5b1769c

scala> Demo.x
initializing x
res6: String = done
----
Тепер ініціалізація `Demo` не включає ініціалізацію `x`. Ініціалізація `x` буде відкладена, доки `x` не буде ініціалізоване перший раз. Це подібно до ситуації, коли `x` визначена як безпараметричний метод з використанням `def`. Однак, на відміну від `def`, `lazy val` ніколи не визначається більше ніж один раз. Фактично, після першого обчислення `lazy val` результат обчислення зберігається, щоб бути використаний, якщо та сама `val` буде використовуватись декілька разів.

Дивлячись на цей приклад, здається, що об'єкти як `Demo` самі поводяться як `lazy val`, в тому, що вони ініціалізуються на вимогу, коли вони використовуються перший раз. Це коректно. Фактично, визначення об'єкта може розглядатись як скорочення для визначення `lazy val` з анонімним класом, що описує вміст об'єкту.

Використавуя `lazy val`, ви можете переформулювати `RationalTrait`, як показано в Лістингу 20.8. В новому визначенні трейта всі суцільні поля визначені як ліниві. Інша зміна з точки зору попереднього визначення `RationalTrait`, показаного на Лістингу 20.4, в тому, що твердження `require` було переміщено з тіла трейта до ініціалізатора приватного поля, `g`, що обчислює найбільший загальний дільник `numerArg` та `denomArg`. З ціма змінними нема нічого, що треба зробити при ініціалізації `LazyRationalTrait`; весь код ініціалізації тепер є частиною правої сторони `lazy val`. Таким чином, є безпечним ініціалізувати абстрактні поля `LazyRationalTrait` після того, як клас визначений.
[source,scala]
----
trait LazyRationalTrait {
  val numerArg: Int
  val denomArg: Int
  lazy val numer = numerArg / g
  lazy val denom = denomArg / g
  override def toString = numer + "/" + denom
  private lazy val g = {
    require(denomArg != 0)
    gcd(numerArg, denomArg)
  }
  private def gcd(a: Int, b: Int): Int =
    if (b == 0) a else gcd(b, a % b)
}
----
Лістинг 20.8 - Ініціалізація трейта за допомогою лінивих змінних.

Ось приклад:
[source,scala]
----
scala> val x = 2
x: Int = 2

scala> new LazyRationalTrait {
         val numerArg = 1 * x
         val denomArg = 2 * x
       }
res7: LazyRationalTrait = 1/2
----
Попередня ініціалізація непотрібна. Буде повчальним прослідити послідовність ініціалізації, що призведе до того, що рядок `1/2` буде надрукований кодом вище:

1. Свіжий примірник `LazyRationalTrait` буде створений, та код ініціалізації `LazyRationalTrait` виконується. Цей код ініціалізації порожній; жодне з полів `LazyRationalTrait` досі не ініціалізований.
2. Далі виконується первинний конструктор анонімного субкласу, визначеного виразом `new`. Це включає ініціалізацію `numerArg` значенням 2, та `denomArg` значенням 4.
3. Далі викликається метод `toString` на конструйованому інтерпретатором об'єкті, так що результуюче значення може бути роздруковане.
4. Далі в перший раз відбувається доступ до поля `numer` з метода `toString` в трейті `LazyRationalTrait`, так що її ініціалатор обчислюється.
5. Ініціалізатор `numer` отримує доступ до приватного поля `g`, так що наступним ініціалізується `g`. Це обчислення отримує доступ до `numerArg` та `denomArg`, що були визначені на Кроці 2.
6. Далі метод `toString` отримує доступ до значення `denom`, що спричинить обчислення `denom`. Обчислення `denom` отримує доступ до `denomArg` та `g`. Ініціалізатор поля `g` не переобчислюється, оскільки він вже був обчислений на Кроці 5.
7. Нарешті, конструюється та друкується результуючий рядок `"1/2"`. 

Зауважте, що визначення `g` текстуально іде після визначення `numer` та `denom` в класі `LazyRationalTrait`. Тим не менше, оскільки всі ці значення ліниві, `g` стає ініціалізованим перед тим, як ініціалізація `numer` та `denom` буде завершеною.

Це показує важливу властивість лінивих змінних: текстуальний порядок їх визначення не має значення, оскільки значення ініціалізуються на вимогу. Таким чином, ліниві змінні вивільняють вам як програміста від роздумів, як вистроїти визначення `val`, щоб переконатись, що все визначено, коли це треба.

Однак ця перевага дотримується тільки доти, доки ініціалізація лінивих змінних ані не призводить до побічних ефектів, ані не залежить від них. В присутності побічних ефектів порядок ініцалізації починає ставати важливим. І потім може стати досить складним відстежити, в якому порядку виконується код ініціалізації, як демонструє попередній приклад. Так що ліниві змінні є ідеальним доповненням до функціональних об'єктів, де порядок ініціалізації не має значення, доки все стає при нагоді ініціалізованим. Вони менш підходять для коду, що є здебільшого імперативним.

Ліниві функціональні мови
~~~~~~~~~~~~~~~~~~~~~~~~~
Scala жодним чином не є першою мовою, що чудово відповідає лінивим визначеням та функціональному коду. Фактично є категорія "лінивих функціональних мов програмування", в яких кожне значення та парамент ініціалізуються ліниво. Найбільш відомий член цього класу мов є Haskell [SPJ02].

20.6 Абстрактні типи
--------------------
На початку цієї глави ви бачили `type T`, декларацію абстрактного типу. Залишок цієї глави дискутує, що означають такі декларації абстрактних типів, та для чого вони добрі. Як всі інши абстрактні декларації, декларації абстрактних типів є замінниками для чогось, що буде визначено суцільним в субкласах. В цьому випадку це тип, що буде визначений десь далі в ієрархії типів. Так що тип `T` вище посилається на тип, що досі невідомий в точці, де він визначений. Різні субкласи можуть провадити різні реалізації для `T`.

Ось гарно відомий приклад, де абстрактні типи виглядають природними. Уявімо, що ми отримали завдання змоделювати істівні звички тварин. Ви можете почати з класу `Food` та класу `Animal` за методом `eat`:
[source,scala]
----
class Food
abstract class Animal {
  def eat(food: Food)
}
----
Потім ви можете спробувати спеціалізувати ці два класа, до класу `Cows`, що їсть `Grass`:
[source,scala]
----
class Grass extends Food
class Cow extends Animal {
  override def eat(food: Grass) = {} // Це не компілюєтья
}
----
Однак якщо ви спробуєте компілювати ці нові класи, ви отримаєте наступну помилку компіляції:
[source,scala]
----
BuggyAnimals.scala:7: error: class Cow needs to be
abstract, since method eat in class Animal of type
    (Food)Unit is not defined
class Cow extends Animal {
      ^
BuggyAnimals.scala:8: error: method eat overrides nothing
  override def eat(food: Grass) = {}
               ^
----
Що тут відбувається, ще те, що метод `eat` класу `Cow` не перекриває метод `eat` в класі `Animal`, оскікльи його тип параметру інший: це  `Grass` в класі `Cow` vs. `Food` в класі `Animal`.

Деякі люди заперечують, що така система типів сувора без необхідності в відмові цім класам. Вони кажуть, що повинно бути OK спеціалізувати параметр метода в субкласі. Однак, якщо класам дозволити бути написаними таким чином, дуже швидко ви можете опинитись в небезпечній ситуації. Наприклад, наступний скрипт буде проходити перевірку типів:
[source,scala]
----
class Food
abstract class Animal {
  def eat(food: Food)
}
class Grass extends Food
class Cow extends Animal {
  override def eat(food: Grass) = {} // Це не буде компілюватись,
}                                    // але якщо б могло,...
class Fish extends Food
  val bessy: Animal = new Cow
  bessy eat (new Fish)               // ...ви б могли кормити корів рибою.
----
Програма могла б компілюватись, якщо обмеження були б послаблені, оскільки `Cows` є `Animals`, та `Animals` мають метод `eat`, що приймає любий різновид `Food`, включаючи `Fish`. Але напевно корові не буде гарно, якщо вона поїсть риби! Що вам треба замість цього, це застосувати якесь більш точне моделювання. `Animals` їдять `Food`, але який різновид `Food` їсть кожний `Animal`, залежить від самого `Animal`. Це може бути гарно виражено за допомогою абстрактного типу, як показано в Лістингу 20.9:
[source,scala]
----
class Food
abstract class Animal {
  type SuitableFood <: Food
  def eat(food: SuitableFood)
}
----
Лістинг 20.9 - Моделювання підходящої їжи через абстрактний тип.

З новим визначенням класу, `Animal` може їсти тільки іжу, що їй підходить. Яка їжа є підходящою не може бути визначено на рівні класу `Animal`. Ось чому `SuitableFood` змодельований як абстрактний клас. Тип має верхню межу, `Food`, що виражається як вираз `<: Food`. Це означає, що любий суцільний примірник `SuitableFood` (в субкласі `Animal`) має бути субкласом `Food`. Наприклад, ви не можете створити примірник `SuitableFood` за допомогою класу `IOException`.

З визначеним `Animal` ви тепер можете переходити до корів, як показано в Лістингу 20.10. Клас `Cow` ладнає свій `SuitableFood` до `Grass`, а також визначає суцільний метод `eat` для цього різновиду їжі.
[source,scala]
----
class Grass extends Food
class Cow extends Animal {
  type SuitableFood = Grass
  override def eat(food: Grass) = {}
}
----
Лістинг 20.10 - Реалізація абстрактного типу в субкласі.

Ці нові визначення класів компілюються без помилок. Якщо ви спробуєте виконати контрприклад "корови-що-їдять-рибу" з новими визначеннями класів, ви будете отримувати наступну помилку компіляції:
[source,scala]
----
scala> class Fish extends Food
defined class Fish

scala> val bessy: Animal = new Cow
bessy: Animal = Cow@1515d8a6

scala> bessy eat (new Fish)
<console>:14: error: type mismatch;
  found   : Fish
  required: bessy.SuitableFood
              bessy eat (new Fish)
                         ^
----
20.7 Шляхо-залежні типи
-----------------------
Знову поглянемо на останнє повідомлення про помилку. Що цікавє, це те, який тип потребує метод `eat`: `bessy.SuitableFood`. Цей тип містить посилання на об'єкт, `bessy`, за яким іде поле типу об'єкту, `SuitableFood`. Це показує, що об'єкти в Scala може мати типи в якості членів. Значення `bessy.SuitableFood` є "тип `SuitableFood`, що є членом об'єкту, на який посилаєтья `bessy`" або, альтернативно, тип їжі, що підходить для `bessy`.

Тип як `bessy.SuitableFood` називається шляхо-залежним типом. Слово "шлях" тут означає посилання на об'єкт. Це може бути простим іменем, таке як `bessy`, або довший шлях доступу, такий як `farm.barn.bessy`, де кожний з `farm`, `barn`, та `bessy` є змінними (або іменами об'єктів синглтонів), що посилаються на об'єкти.

Як підказує термін "шляхо-залежний тип", тип залежить від шляху; загалом, різні шляхи дають різні типи. Наприклад, скажімо, ви визначили класи `DogFood` та `Dog`, ось так:
[source,scala]
----
class DogFood extends Food
class Dog extends Animal {
  type SuitableFood = DogFood
  override def eat(food: DogFood) = {}
}
----
Якщо ви спробуєте погодувати собаку їжею, що підходить для корови, ваш код не буде компілюватись:
[source,scala]
----
scala> val bessy = new Cow
bessy: Cow = Cow@713e7e09

scala> val lassie = new Dog
lassie: Dog = Dog@6eaf2c57

scala> lassie eat (new bessy.SuitableFood)
<console>:16: error: type mismatch;
found   : Grass
required: DogFood
             lassie eat (new bessy.SuitableFood)
                         ^
----                         
Проблема тут в тому, що тип об'єкта `SuitableFood`, переданого до метода `eat`, `bessy.SuitableFood`, несумісний з типом параметра `eat`, `lassie.SuitableFood`.

Випадок може бути іншим для двох `Dog`. Оскікльи тип `Dog` `SuitableFood` визначений бути псевдонімом для класу `DogFood`, типи  `SuitableFood` для двох `Dog` є фактично ті самі. Як результат, примірник `Dog` на ім'я `lassie` насправді може їсти підходящц їжу іншого примірника `Dog` (який ми назвемо `bootsie`):
[source,scala]
----
scala> val bootsie = new Dog
bootsie: Dog = Dog@13a7c48c

scala> lassie eat (new bootsie.SuitableFood)
----
Шляхо-залежнийA тип копіює синтаксис для типу внутрішнього класу в Java, але є важлива відмінність: шляхо-залежний тип називає зовнішній клас. Типи внутрішніх класів в стилі Java також можуть бути виражені в Scala, але вони записуються інакше. Розглянемо ці два класи, `Outer` та `Inner`:
[source,scala]
----
class Outer {
  class Inner
}
----
В Scala внутрішній клас адресується з використанням виразу `Outer#Inner` замість `Outer.Inner` в Java. Синтаксис `.` зарезервований для об'єктів. Наприклад, уявімо, що ви створили два об'єкти типу `Outer`, ось так:
[source,scala]
----
val o1 = new Outer
val o2 = new Outer
----
Тут `o1.Inner` та `o2.Inner` є два шляхо-залежні типи (і вони різні типи). Обоє з ціх типів відповідають до (є субтипами до) більш загального типу `Outer#Inner`, що представляє клас `Inner` з довільним зовнішнім об'єктом типу `Outer`. Для контрасту, тип `o1.Inner` посилається на клас `Inner` зі специфічним зовнішнім об'єктом (на який посилається `o1`). Подібним чином, тип `o2.Inner` посилається на клас `Inner` з іншим, специфічним зовнішнім об'єктом (на який посилається o2).

В Scala, як і в Java, примірники внутрішнього класу містять посилання на оточуючий примірник зовнішнього класа. Це дозволяє внутрішньому класу, наприклад, отримувати доступ до членів свого зовнішнього класу. Таки чином, ви не зможете створити внутрішній клас, в деякий спосіб не указавши примірник зовнішнього класу. Один спосіб зробити це є створити внутрішній клас всередині зовнішнього класу. В цьому випадку буде використаний поточний примірник зовнішнього класу (на який вказує `this`).

Інший шлях є використати шляхо-залежний тип. Наприклад, оскікльи тип `o1.Inner` іменує специфічний зовнішній об'єкт, ви можете створити його примірник:
[source,scala]
----
scala> new o1.Inner
res11: o1.Inner = Outer$Inner@1ae1e03f
----
Результуючий інутрішній об'єкт буде містити посилання на на свій зовнішній об'єкт, на який посилається o1. Для контрасту, оскільки тип `Outer#Inner` не іменує жодний специфічний примірник `Outer`, ви не можете створити його примірник:
[source,scala]
----
scala> new Outer#Inner
<console>:9: error: Outer is not a legal prefix for a
constructor
              new Outer#Inner
                        ^
----
20.8 Уточнені типи
------------------
Коли клас наслідує від іншого, кажуть, що перший клас є _номінальним_ субтипом іншого. Це _номінальний_ субтип, бо кожний тип має _ім'я_, і імена явно декларовані як такі, що вають відношення субтипізації. Scala додатково підтримує _структурну_ субтипізацію, коли ви маєте відношення субтипізації, просто тому що два типи мають сумісні члени. Щоб отримати структурну субтипізацію в Scala, використовуйте уточнення типів Scala.

Номінальна типізація звичайно є більш зручною, так що вам слідує зпочатку спробувати номінальні типи в кожній новій розробці. Ім'я є простим коротким ідентифікатором, і, таким чином, більш стислі, ніж явний перелік членів типів. Більше того, структурна субтипізація часто більш гнучка, ніж ви бажаєте. Віджет може `draw()`, та ковбой заходу також може `draw()`, але вони насправді не замінюють один одного. Ви будете переважно обирати отримання помилки компіляції, якщо ви спробуєте замінити ковбоя на віджет.

Тим не менш, структурна субтипізація має власні переваги. Одна з них в тому, що іноді немає більше ніякого типу, ніж перелік членів. Наприклад, уявімо, що ви бажаєте визначити клас `Pasture`, що може містити тварин, що їдять траву. Одна з опцій буде визначити трейт `AnimalThatEatsGrass`, та міксувати його в кожний клас, який це стосується. Однак це може бути балакучим. Клас `Cow` вже був визначений як тварина, та що їсть траву, і тепер він має додатково бути визначений також як тварина-що-їсть-траву. Замість визначення `AnimalThatEatsGrass` ви можете використовувати уточнюючий тип. Просто запишіть базовий тип, `Animal`, за яким слідує послідовність членів в фігурних дужках. Члени в фігурних дужках далі специфікують — або, якщо бажаєте, уточнюють — типи членів від базового класу. Ось як ви записуєте тип "тварина, що їсть траву":
[source,scala]
----
Animal { type SuitableFood = Grass }
----
Маючи цей тип, тепер ви можете записати клас пасовиська таким чином:
[source,scala]
----
class Pasture {
  var animals: List[Animal { type SuitableFood = Grass }] = Nil
// ...
}
----
20.9 Енумератори 
----------------
Цікаве застосування для шляхо-залежних типів знаходиться в Scala підтримці енумераторів. Деякі інші мови, включаючи Java та C#, мають енумератори як вбудовані конструкції мови, що визначають нові типи. Scala не потребує особливого синтаксису для енумераторів. Замість цього існує клас в стандадртній бібліотеці, `scala.Enumeration`.

Щоб створити нову енумерацію ви визначаєте об'єкт, що розширює цей клас, як в наступному прикладі, що визначає новий енумератор `Colors`:
[source,scala]
----
object Color extends Enumeration {
  val Red = Value
  val Green = Value
  val Blue = Value
}
----
Scala дозволяє вам скоротити декілька послідовних визначень `val` або `var` з тою самою правою стороною. Еквівалентно до попереднього ви можете записати:
[source,scala]
----
object Color extends Enumeration {
  val Red, Green, Blue = Value
}
----
Цей об'єкт провадить три значення: `Color.Red`, `Color.Green`, та 'Color.Blue'. Ви також можете імпортувати все з `Color`:
[source,scala]
----
import Color._
----
та потім тільки використовувати `Red`, `Green`, та `Blue`. Але який буде тип ціх значень? `Enumeration` визначає внутрішній клас на ім'я `Value`, та так само названий безпараметричний метод `Value` повертає свіжий примірник цього класу. Іншими словами, значення, таке як `Color.Red` має тип `Color.Value`; `Color.Value` є типом для всіх значень енумератора, визначених в об'єкті `Color`. Це шляхо-залежний тип, де `Color` є шляхом, та `Value` є залежним типом. Що важливо щодо цього, це те, що це повністю новий тип, відмінний від всіх інших типів.

Зокрема, якщо ви визначите іншу енумерацію, як:
[source,scala]
----
object Direction extends Enumeration {
  val North, East, South, West = Value
}
----
тоді `Direction.Value` буде відмінне від `Color.Value`, оскільки два типи відрізняються в частині шляху.

В Scala клас `Enumeration` також пропонує багато інших можливостей, які можна знайти в дизайні енумераторів в інших мовах. Ви можете асоціювати імена зі значеннями енумерації, використовуючи різні перевантажені варіанти метода `Value`:
[source,scala]
----
object Direction extends Enumeration {
  val North = Value("North")
  val East = Value("East")
  val South = Value("South")
  val West = Value("West")
}
----
Ви можете ітерувати по значенням енумерації через множину, що повертає метод `values` енумерації:
[source,scala]
----
scala> for (d <- Direction.values) print(d + " ")
North East South West
----
Значення енумерації нумеруються від `0`, і ви можете знайти номер значення енумерації через його метод `id`:
[source,scala]
----
scala> Direction.East.id
res14: Int = 1
----
Також можливо піти іншим шляхом, від не-від'ємного цілого до значення, що має цей номер в якості `id` в енумерації:
[source,scala]
----
scala> Direction(1)
res15: Direction.Value = East
----
Цього має бути достатньо, щоб почати робити з енумераціями. Ви можете знайти додаткову інформацію в коментарях Scaladoc до класу `scala.Enumeration`.

20.10 Лабораторна робота: валюта
--------------------------------
Залишок цієї глави презентує лабораторну роботу, що пояснює, як абстрактні типи можуть бути використані в Scala. Завданням буде розробити клас `Currency`. Типовий примірник `Currency` буде представляти кількість грошей в доларах, євро, ієнах або в якійсь іншій валюті. Повинно бути можливим виконувати деяку арифметику з валютами. Наприклад, ви можете бути в змозі додавати дві суми в тій самій валюті. Або ви повинні бути в змозі помножити суму в валюті на коефіціент, що представляє відсотковий рівень.
 
Ці роздуми призводять до наступного першого дизайну класу валюти:
[source,scala]
----
// Перший (невдалий) дизайн класу Currency
abstract class Currency {
  val amount: Long
  def designation: String
  override def toString = amount + " " + designation
  def + (that: Currency): Currency = ...
  def * (x: Double): Currency = ...
}
----
Сума `amount` валюти є часло в одиницях валюти, яку вона представляє. Це поле типу `Long`, так що можуть бути представлені дуже великі суми, такі як капіталізація ринку Google або Apple. Тут це залишено абстрактним, очікуючи визначення коли субклас казатиме про конкретні об'єми грошей. Поле `designation` для валюти є рядок, що ідентифікує валюту. Метод `toString` класу `Currency` вказує суму та позначення. Він буде видавати результати в такому вигляді:
----
79 USD
11000 Yen
99 Euro
----
Нарешті, є метод `+` для додавання валюти, та `*` для множення валюти на число з плаваючою крапкою. Ви можете створити суцільне значення валюти, через надання конкретних значень суми та назви валюти, ось так:
[source,scala]
----
new Currency {
  val amount = 79L
  def designation = "USD"
}
----
Цей дизайн буде OK, якщо все, що ми бажаємо, це єдина валюта, як тільки долар або тільки євро. Але він схибить, якщо нам буде треба мати справу з декількома валютами. Уявімо, що ви модулюєте долари та єаро як два субкласи до класу валюти:
[source,scala]
----
abstract class Dollar extends Currency {
  def designation = "USD"
}

abstract class Euro extends Currency {
  def designation = "Euro"
}
----
На перший погляд це виглядає розумним. Але це дасть нам змогу додавати долари до євро. Результат такого додавання має бути типу `Currency`. Але це буде цікава валюта, що складається з суміші євро та доларів. Що ми бажаємо замість цього, є більш специфікована версія метода `+`. Коли реалізується клас `Dollar`, віе має брати аргументи `Dollar`, та видавати результат `Dollar`; коли реалізується клас `Euro`, він повинен брати аргументи `Euro`, та видавати результат `Euro`. Так що тип результату метода додавання буде змінюватись, в залежності від того, в якому класі він знаходиться. Тим не менш, ви бажаєте написати метод додавання тільки один раз, та не кожного разу, коли визначаєте нову валюту.

В Scala існує простий прийом, що порається з подібними ситуаціями. Якщо дещо невідоме в точці, де визначається клас, зробіть це абстрактним в класі. Це стосується до обох, значень та типів. В випадку валют, точний тип аргументів та результату метода складання невідомий, так що це гарний кандидат на абстрактний тип.

Це може привести до наступного скетчу класа `AbstractCurrency`:
[source,scala]
----
// Другий (все ще недосконалий) дизайн класу Currency
abstract class AbstractCurrency {
  type Currency <: AbstractCurrency
  val amount: Long
  def designation: String}
  override def toString = amount + " " + designation
  def + (that: Currency): Currency = ...
  def * (x: Double): Currency = ...
----
Єдина різниця з попередньою ситуацією в тому, що тепер клас називається `AbstractCurrency`, і що він містить абстрактний тип `Currency`, що презентує реальну валюту. Кожний суцільний субклас `AbstractCurrency` буде потребувати полагодження `Currencytype`, щоб він посилався на сам суцільний субклас, таким чином "затягуючи петлю".

Наприклад, ось нова версія класу `Dollar`, що тепер розширює клас `AbstractCurrency`:
[source,scala]
----
abstract class Dollar extends AbstractCurrency {
  type Currency = Dollar
  def designation = "USD"
}
----
Цей дизайн робить, але він все ще не ідеальний. Одна проблема ховається за крапками, що вказують на відсутні визначення методів `+` та `*` в класі `AbstractCurrency`. Зокрема, як має додавання бути реалізоване в цьому класі? Досить просто обчислити коректну суму нової валюти, як `this.amount + that.amount`, але як ви будете конвертувати суму в валюту правильного типу?

Ви можете спробувати щось таке:
[source,scala]
----
def + (that: Currency): Currency = new Currency {
  val amount = this.amount + that.amount
}
----
Однак це не буде компілюватись:
[source,scala]
----
error: class type required
  def + (that: Currency): Currency = new Currency {
                                         ^
----
Одне з обмежень трактування Scala абстрактніх типів в тому, що вона ніколи не буде створювати примірник абстрактного типу, ані матиме абстрактний тип як супертип іншого класу.footnote:[Є деяке обіцяюче останнє дослідження в віртуальних класах, що може дозволити це, але віртуальні класи наразі не підтримуються в Scala.] Так що компілятор буде відхиляти код в прикладі, що намагається створити примірник `Currency`.

Однак ви можете обійти це обмеження, використовуючи метод фабрики. Замість створення примірника абстрактного класу напряму, декларуйте абстрактний метод, що робить це. Потім, коли абстрактний клас зафіксований як деякий суцільний тип, вам також треба надати суцільну реалізацію матода фабрики. Для класу `AbstractCurrency` це може виглядати наступним чином:
[source,scala]
----
abstract class AbstractCurrency {
  type Currency <: AbstractCurrency // абстрактний тип
  def make(amount: Long): Currency  // метод фабрики
...
// залишок класу
}
----
Дизайн як цей можна зробити робочим, але він виглядає скоріше підозрілим. Чому класти метод фабрики всередину класу `AbstractCurrency`? Це виглядає сумнівно з двох причин. Перше, якщо ви маєте якусь суму валюти (скажімо, один долар), ви також тримаєте в своїх руках можливість зрбити більше в тій же валюті, використовуючи код як цей:
[source,scala]
----
myDollar.make(100) // тут ще одна сотня!
----
В епоху кольорового копіювання це може бути привабливим сценарієм, але, сподіваюсь, не тим, який ви б могли робити довго, не бувши спійманим. Друга проблема з цім кодом в тому, що ви можете зробити більше об'єктів `Currency`, якщо ви вже маєте посилання на об'єкт `Currency`. Але як ви отримаєте перший об'єкт даної `Currency`? Вам знадобиться інший метод, що робить ту саму роботу, що і `make`. Так що ви маєте випадок дублікації коду, що є певним знаком, що ваш код завонявся.

Рішення, звичайно, є перемістити абстрактний тип та метод фабрики за межі класу `AbstractCurrency`. Вам треба створити інший клас, що містить клас `AbstractCurrency`, тип `Currency`, та методо фабрики `make`.

Ми будемо називати це `CurrencyZone`:
[source,scala]
----
abstract class CurrencyZone {
  type Currency <: AbstractCurrency
  def make(x: Long): Currency

  abstract class AbstractCurrency {
    val amount: Long
    def designation: String
    override def toString = amount + " " + designation
    def + (that: Currency): Currency =
      make(this.amount + that.amount)
    def * (x: Double): Currency =
      make((this.amount * x).toLong)
  }
}
----
Приклад суцільного `CurrencyZone` є `US`, що може бути визначено так:
[source,scala]
----
object US extends CurrencyZone {
  abstract class Dollar extends AbstractCurrency {
    def designation = "USD"
  }
  type Currency = Dollar
  def make(x: Long) = new Dollar { val amount = x }
}
----
Тут `US` є об'єктом, що розширює `CurrencyZone`. Він визначає клас `Dollar`, що є субкласом `AbstractCurrency`. Так що тип грошей в цій зоні є `US.Dollar`. Об'єкт `US` також фіксує тип `Currency` як псевдонім для `Dollar`, та він надає реалізацію метода фабрики `make`, що повертає суму в доларах.

Це робочий дизайн. Залишилось додати лише декілька покращень. Перше покращення стосується субодиниць. Досі кожна валюта обчислювалась в єдиних одиницях: долари, євро, або ієни. Однак більшість валют мають субодиниці: наприклад, в US це долари та центи. Найбільш прямолінійний шлях моделювати центи є мати поле `amount` в `US.Currency`, що представляє центи замість доларів. Для конвертації назад до доларів є корисним ввести поле `CurrencyUnit` в клас `CurrencyZone`, що містить суму в одній стандартній одиниці цієї валюти:
[source,scala]  
----
class CurrencyZone {
...
  val CurrencyUnit: Currency
}
----
Як показано в Лістингу 20.11, об'єкт `US` може визначати кількості в `Cent`, `Dollar`, та `CurrencyUnit`. Це визначення є таке саме, як попереднє визначення об'єкта `US`, за винятком того, що воно додає три нові поля. Поле `Cent` представляє суму в 1 `US.Currency`. Це об'єкт, аналогічний до монеті в один цент. Поле `Dollar` представляє суму в 100 `US.Currency`. Так що об'єкт `US` тепер визначає ім'я `Dollar` в два способи. Тип `Dollar` (визначаний абстрактним інутрішнім класом на ім'я `Dollar`) представляє дженерік ім'я `Currency`, валідної в валютній зоні `US`. Для контрасту, значення `Dollar` (на яке посилається поле `val` на ім'я `Dollar`) представляє окремий US долар, подібно до однодоларового чеку. Третє визначення поля `CurrencyUnit` задає факт, що стандартна одиниця валюти в US зоні є `Dollar` (тобто, значення `Dollar`, на яке посилається поле, не тип `Dollar`).

Метод `toString` в класі `Currency` також потребує бути адаптованим, щоб приймати до уваги субодиниці. Наприклад, сума десяти доларів і двадцяти трьох центів має друкуватись як десятичне число: 10.23 USD. 

Щоб досягти цього, ви повинні реалізовати метод `Currency` `toString` таким чином:
[source,scala]
----
override def toString =
  ((amount.toDouble / CurrencyUnit.amount.toDouble)
  formatted ("%." + decimals(CurrencyUnit.amount) + "f")
  + " " + designation)
----
Тут `formatted` є методом, що Scala робить доступним для декількох класів, включачи `Double`.footnote:[Scala використовує багаті огортки, описані в Розділі 5.10, щоб зробити форматування можливим.] Метод `formatted` повертає рядок, що є результатом форматування оригінального рядка, на якому було викликано `formatted`, відповідно до рядка формату, переданого як правий операнд метода `formatted`. Синтаксис рядка формату, переданого в `formatted`, той самий, що і для Java метода `String.format`.
[source,scala]
----
object US extends CurrencyZone {
  abstract class Dollar extends AbstractCurrency {
    def designation = "USD"
  }
  type Currency = Dollar
  def make(cents: Long) = new Dollar {
    val amount = cents
  }
  val Cent = make(1)
  val Dollar = make(100)
  val CurrencyUnit = Dollar
}
----
Лістинг 20.11 - Валютна зона `US`.

Наприклад, рядок формату `%.2f` форматує число з двома десятичними цифрами. Рядок формату, використаний в показаному `toString` складається з виклику метода `decimals` на `CurrencyUnit.amount`. Цей метод повертає число десятичних знаків в десятичній ступіні мінус один. Наприклад, `decimals(10)` є `1`, `decimals(100)` є `2`, і так далі. Метод `decimals` реалізований через просту рекурсію:
[source,scala]
----
private def decimals(n: Long): Int =
  if (n == 1) 0 else 1 + decimals(n / 10)
----
Лістинг 20.12 показує деякі інші валютні зони. Як інше покращення ви можете додати до моделі можливість конвертації валют. Зпершу, вам треба написати о'бєкт `Converter`, що містить допустимі курси обміну між валютами, як показано в Лістингу 20.13. Потім ви можете додати метод конвертації, `from`, до класу `Currency`, що конвертує з наданої валюти в поточну валюту об'єкту `Currency`:
[source,scala]
----
def from(other: CurrencyZone#AbstractCurrency): Currency =
  make(math.round(
  other.amount.toDouble * Converter.exchangeRate
  (other.designation)(this.designation)))
----
Метод `from` приймає довільну валюту як аргумент. Це виражається в типи його формального параметру, `CurrencyZone#AbstractCurrency`, що вказує, що аргумент, переданий як `other`, має бути типу `AbstractCurrency` в якійсь, невідомій `CurrencyZone`. Він продукує свій результат чеерз множення суми в іншій валюті на курс обміну між іншою та поточною валютою.footnote:[Доречі, якщо ви думаєте ви отримали погані справи з японською ієною, курси обміну конвертують валюти на основі своїх сум `CurrencyZone`. Таким чином, 1.211 є курс обміну між US центами та японськіми ієнами.]
[source,scala]
----
object Europe extends CurrencyZone {
  abstract class Euro extends AbstractCurrency {
    def designation = "EUR"
  }
  type Currency = Euro
  def make(cents: Long) = new Euro {
    val amount = cents
  }
  val Cent = make(1)
  val Euro = make(100)
  val CurrencyUnit = Euro
}

object Japan extends CurrencyZone {
  abstract class Yen extends AbstractCurrency {
    def designation = "JPY"
  }
  type Currency = Yen
  def make(yen: Long) = new Yen {
    val amount = yen
  }
  val Yen = make(1)
  val CurrencyUnit = Yen
}
----
Лістинг 20.12 - Валютні зони для Європи та Японії.
[source,scala]
----
object Converter {
  var exchangeRate = Map(
    "USD" -> Map("USD" -> 1.0   , "EUR" -> 0.7596,
                 "JPY" -> 1.211 , "CHF" -> 1.223),
    "EUR" -> Map("USD" -> 1.316 , "EUR" -> 1.0,
                 "JPY" -> 1.594 , "CHF" -> 1.623),
    "JPY" -> Map("USD" -> 0.8257, "EUR" -> 0.6272,
                 "JPY" -> 1.0   , "CHF" -> 1.018),
    "CHF" -> Map("USD" -> 0.8108, "EUR" -> 0.6160,
                 "JPY" -> 0.982 , "CHF" -> 1.0 )
}
----
Лістинг 20.13 - Об'єкт конвертора з мапою курсів обміну.
[source,scala]
----
abstract class CurrencyZone {

  type Currency <: AbstractCurrency
  def make(x: Long): Currency

  abstract class AbstractCurrency {
    val amount: Long
    def designation: String

    def + (that: Currency): Currency =
      make(this.amount + that.amount)
    def * (x: Double): Currency =
      make((this.amount * x).toLong)
    def - (that: Currency): Currency =
      make(this.amount - that.amount)
    def / (that: Double) =
      make((this.amount / that).toLong)
    def / (that: Currency) =
      this.amount.toDouble / that.amount

    def from(other: CurrencyZone#AbstractCurrency): Currency =
        make(math.round(
        other.amount.toDouble * Converter.exchangeRate
        (other.designation)(this.designation)))

    private def decimals(n: Long): Int =
      if (n == 1) 0 else 1 + decimals(n / 10)

    override def toString =
      ((amount.toDouble / CurrencyUnit.amount.toDouble)
       formatted ("%." + decimals(CurrencyUnit.amount) + "f")
       + " " + designation)
  }
  val CurrencyUnit: Currency
}
----
Лістинг 20.14 - Повний код класу `CurrencyZone`.

Фінальна версія класу `CurrencyZone` показана на Лістингу 20.14. Ви можете протестувати клас в командній оболонці Scala. Ми будемо вважати, що клас `CurrencyZone` та всі суцільні об'єкти `CurrencyZone` визначені в пакунку `org.stairwaybook.currencies`. Перший крок є імпортувати  `org.stairwaybook.currencies._` в командну оболонку. Потім ви можете зробити деякі конвертації валют:
[source,scala]
----
scala> Japan.Yen from US.Dollar * 100
res16: Japan.Currency = 12110 JPY

scala> Europe.Euro from res16
res17: Europe.Currency = 75.95 EUR

scala> US.Dollar from res17
res18: US.Currency = 99.95 USD
----
Факт, що ви отримали майже ті самі суми після трьох конвертацій каже нам, що це досить гарні обмінні курси! Ви також можете пододавати значення в тій самій валюті:
[source,scala]
----
scala> US.Dollar * 100 + res18
res19: US.Currency = 199.95 USD
----
З іншого боку, ви не можете додавати суми в різних валютах:
[source,scala]
----
scala> US.Dollar + Europe.Euro
<console>:12: error: type mismatch;
found   : Europe.Euro
required: US.Currency
    (which expands to) US.Dollar
              US.Dollar + Europe.Euro
                                 ^
----
Через запобігання додавань двох значень в різних одиницях (в цьому випадку валют), абстракція типів робить свою роботу. Це утримує нас від виконання безглуздих обчислень. Збої коректної конвертації між різними одиницями може виглядати як тривіальні баги, але вони призводили до багатьох серйозних системних відмов. Як приклад можна навести аварію космічного корабля Mars Climate Orbiter 23 вересня 1999го року, що сталась через те, що одна інженерна команда використовувала метричні одиниці, тоді як інша використовувала англійські одиниці. Якщо одиниці були б закодовані в той же спосіб, що і валюти в цьому розділі, ця помилка була б детектована простим запуском компілятора. Замість цього це спричинило аварію орбітального корабля після майже десятимісячної подорожі.

20.11 Висновок
--------------
Scala пропонує систематичну і дуже загальну підтримку для об'єктно-орієнтовних абстракцій. Вона дозволяє вам абстрагувати не тільки методи, але також значення, змінні і типи. Ця глава показала, як отримати переваги від абстрактних членів. Вони підтримують простий, але ефективний принцип для структурування систем: коли ви розробляєте клас, робіть все, що доки невідоме, як абстрактний член. Потім система типів буде рухати розробку вашої моделі, так само, як ви бачили в лабораторій роботі про валюту. Не має значення, чи невідомим є тип, метод, змінна або значення. В Scala все це може бути визначено абстрактно.
 