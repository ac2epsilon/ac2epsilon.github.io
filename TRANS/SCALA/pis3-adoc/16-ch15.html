<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__15">Глава 15</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____">Кейс класи та порівняння шаблонів</h1>
<div class="paragraph"><p>Ця глава вводить <em>кейс класи</em> та <em>порівняння шаблонів</em>, споріднені конструкції, що підтримують вас коли ви пишете регулярні, не-інкапсульовані структури даних. Ці дві конструкції зокрема корисні для дерево-подібних рекурсивних даних.</p></div>
<div class="paragraph"><p>Якщо ви до цього програмували на функціональній мові, тоді ви, можливо, розпізнали порівняння шаблонів. Але кейс класи будуть новими для вас. Кейс класи це шлях Scala, щоб дозволити порівняння шаблонів на об'єктах, не потребуючи великої кількості кліше. Загалом, все що вам треба робити, це додати одне ключове слово case до кожного класу, що би бажаємо зробити придатним для порівняння.</p></div>
<div class="paragraph"><p>Ця глава починається з простого прикладу кейс класу та порівняння шаблонів. Потім вона проходить по всіх підтримуваних шаблонах, каже про роль закоркованих класів, дискутує тип <code>Option</code>, та показує деякі не-очевидні місця в мові, де використовується порівняння шаблонів. Нарешті, показаний більший, більш реалістичний приклад порівняння шаблонів.</p></div>
<div class="sect1">
<h2 id="_15_1__">15.1 Простий приклад</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перед зануренням в усі правила та нюанси порівняння шаблонів, варто подивитись на простий приклад, щоб зрозуміти головну ідею. Скажімо, вам треба написати бібліотеку, що маніпулює арифметичними виразами, можливо як частину домен-специфічної мови, яку ви розробляєте.</p></div>
<div class="paragraph"><p>Перший крок подолання цієї проблеми є визначення вхідних даних. Щоб утримувати речі простими, ми сконцентруємось на арифметичних виразах, що складаються зі змінних, чисел, та одно- і дво-місних операціях. Це виражається через ієрархію Scala класів, показану в Лістингу 15.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.1 - Визначення кейс класів.</p></div>
<div class="paragraph"><p>Ієрархія включає абстрактний базовий клас <code>Expr</code> з чотирма субкласами, по одному для кожного типу виразу, що розглядається.<span class="footnote"><br />[Замість абстрактного класу, ми також можемо обрати змоделювати корінь ієрархії класів як трейт. Моделювання його як абстрактного класу може бути трохі більш ефективним.]<br /></span> Тіла всіх п'яти класів порожні. Як зазначалось раніше, в Scala ви можете відкинути фігурні дужки коло порожніх класів, якщо бажаєте, та що <code>class C</code> те саме, що і <code>class C {}</code>.</p></div>
<div class="sect2">
<h3 id="__">Кейс класи</h3>
<div class="paragraph"><p>Інша варта уваги річ щодо декларацій на Лістингу 15.1 є те, що кожний клас має модифікатор <code>case</code>. Класи з таким модифікатором називаються кейс класами. Використання модифікатора змушує Scala компілятор додати деякі синтаксичні зручності до вашого класу.</p></div>
<div class="paragraph"><p>Перше, він додає метод фабрику з ім'ям класу. Це означає, наприклад, що ви можете писати <code>Var("x")</code> для конструювання об'єкту <code>Var</code>, замість трохи довшого <code>new Var("x")</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">Var</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи фабрик зокрема гарні, коли ви вкладаєте їх. Оскільки не існує шумлячих ключових слів <code>new</code>, розкиданих по коду, ви можете збагнути структуру вираза з одного погляду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">op</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">v</span><span class="o">)</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Друга синтаксична зручність в тому, що всі ці аргументи в списку параметрів кейс класів неявно отримують префікс <code>val</code>, так що вони обробляються як поля:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">left</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Третє, компілятор додає "природні" реалізації методів <code>toString</code>, <code>hashCode</code> та <code>equals</code> до вашого класу. Вони будуть друкувати, хешувати, та порівнювати цілі дерева, що складається з вашого класу, та (рекурсивно), всіх його аргументів. Оскільки <code>==</code> в Scala завжди делегує до <code>equals</code>, це означає, що елементи кейс класів завжди порівнюються структурно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
<span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, компілятор додає метод <code>copy</code> до вашого класу, щоб робити модифіковані копії. Цей метод корисний для створення нових примірників класу, що такі самі, як і інший, за винятком того, що один або два аргументи відрізняються. Метод робить через використання іменованих та параметрів за замовчанням (дивіться Розділ 8.8). Ви вказуєте зміни, що ви б хотіли зробити, використовуючи іменовані параметри. Для любих параметрів, які ви не вказуєте, буде використано значення зі старого об'єкту. Як приклад, ось як ви можете зробити операцію, таку саму як <code>op</code>, за винятком того, що оператор змінений:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">operator</span> <span class="k">=</span> <span class="s">&quot;-&quot;</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(-,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі ці домовленості додають великі зручності за малу ціну. Ви мали написати лише модифікатор <code>case</code>, та ваші класи і об'єкти стають трохи більшими. Вони більші, оскільки згенеровані додаткові методи та додані неявні поля для кожного параметру конструктора. Однак найбільша вигода від кейс класів є те, що вони підтримують порівняння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Порівняння шаблонів</h3>
<div class="paragraph"><p>Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених типів. Є багато можливих правил спрощення. Наступні три правила служать тільки для ілюстрації
:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span>  <span class="c1">// Подвійна зміна знаку</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Додавання нуля</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Множення на одинницю</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи порівняння шаблонів, ці правила можуть розгядатись майже так, якби вони формували основу функції спрощення в Scala, як показано на Лістингу 15.2. Функція <code>simplifyTop</code>, може використовуватись таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))))</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>  <span class="c1">// Подвійна зміна знаку</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Додавання нуля</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Множення на одинницю</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.2 - Функція <code>simplifyTop</code>, що робить порівняння шаблонів.</p></div>
<div class="paragraph"><p>Права сторона <code>simplifyTop</code> складається з вираза <code>match</code>. <code>match</code> відповідає до <code>switch</code> в Java, але він записаний після вираза селектора. Іншими словами, це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="o">(</span><span class="n">selector</span><span class="o">)</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів включає послідовність альтернатив, кожне починається з ключового слова <code>case</code>. Кожна альтернатива включає шаблон, та один або більше виразів, що будуть обчислені, якщо шаблон співпадає. Символ стрілки <code>=&gt;</code> відділяє шаблон від виразів.</p></div>
<div class="paragraph"><p>Вираз <code>match</code> обчислюється через спробу кожного з шаблонів по порядку, як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що стоїть за стрілкою, обирається та виконується.</p></div>
<div class="paragraph"><p><em>Шаблон константи</em> як <code>"+"</code> або <code>1</code> співпадає зі значеннями, що дорівнюють константі з точки зору <code>==</code>.</p></div>
<div class="paragraph"><p><em>Шаблон змінної</em> як <code>e</code> співпадає з любим значенням. Змінна після цього посилається на це значення в правій частині твердження <code>case</code>. В цьому прикладі зауважте, що перші три альтернативи обчислюються до <code>e</code>, змінної, що прив'язана в асоційованому шаблоні. Підстановочний шаблон <code>_</code> також співпадає з кожним значенням, але він не вводить ім'я змінної, що посилається на це значення. В Лістингу 15.2 зауважте, як <code>match</code> закінчується на випадок за замовчаню, що нічого не робить з виразом. Замість цього, він просто має результат <code>expr</code>, вираз, якій порівнюється.</p></div>
<div class="paragraph"><p><em>Шаблон конструктора</em> виглядає <code>UnOp("-", e)</code>. Цей шаблон співпадає з усіма значеннями типу <code>UnOpwhose</code>, чий перший аргумент співпадає з <code>"-"</code>, та чий другий аргумент співпадає з <code>e</code>. Зауважте, що аргументи до конструктора самі є шаблонами. Це дозволяє вам писати глибокі шаблони, використовуючи стислу нотацію.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Уявіть реалізцію тієї самої функціональності з використанням дизайну шаблону візитора!<span class="footnote"><br />[Gamma, et. al., Design Patterns [Gam95]]<br /></span>Майже так само незручно, уявіть його реалізацію як довгої послідовності тверджень <code>if</code>, перевірок та перетворень типів.</p></div>
</div>
<div class="sect2">
<h3 id="__code_match_code__code_switch_code">Порівняння <code>match</code> та <code>switch</code></h3>
<div class="paragraph"><p>Вирази <code>match</code> можуть розглядатись як узагальнення <code>switch</code> в стилі Java. Перемикачі в стилі Java можуть бути природно виражені як вирази <code>match</code>, де кожний шаблон є константою, та останній шаблон може бути підстановочним (що презентує випадок <code>default</code> в <code>switch</code>).</p></div>
<div class="paragraph"><p>Однак існує три відмінності, що треба мати на увазі: перше - <code>match</code> є виразом в Scala (тобто, він завжди повертає значення). Друге, вирази альтернатив в Scala ніколи не "провалюються" в наступний випадок. Третє, як жодний з шаблонів не співпадає, закидається виключення <code>MatchError</code>. Це означає, що ви завжди маєте переконатись, що покриті всі випадки, навіть якщо це означає додавання випадку за замовчанням, якій нічого не робить.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.3 - Шаблон <code>match</code> з порожнім випадком <code>"default"</code>.</p></div>
<div class="paragraph"><p>Лістинг 15.3 показує приклад. Другий випадок є необхідним, оскільки без нього вираз <code>match</code> буде викликати <code>MatchError</code> для кожного аргументу <code>expr</code>, що не є <code>BinOp</code>. В цьому прикладі для другого випадка немає коду, так що при виконанні випадка нічого не виконується. В любому випадку результат є одиничне значенню <code>()</code>, що також є результатом всього виразу <code>match</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_2__">15.2 Різновиди шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад показує декілька типів шаблонів в швидкій послідовності. Тепер затратимо хвилину, та детально поглянемо на кожний шаблон.</p></div>
<div class="paragraph"><p>Синтаксис шаблонів простий, так що не турбуйтесь щодо цього дуже сильно. Всі шаблони виглядають точно так, як відповідні вирази. Наприклад, маючи ієрархію з Лістингу 15.1, шаблон <code>Var(x)</code> співпадає з любим виразом змінної, пов'язуючи <code>x</code> з ім'ям змінної. Використовуючи вираз <code>Var(x)</code> — точно такий же синтаксис — перестворює еквівалентний об'єкт, вважаючи, що <code>x</code> вже прикріалений до імені змінної. Оскільки синтаксис шаблонів такий прозорий, головна річ, на яку варто звертати увагу, це тільки те, які шаблони взагалі можливі.</p></div>
<div class="sect2">
<h3 id="___3">Підстановочні шаблони</h3>
<div class="paragraph"><p>Підстановочний шаблон (<code>_</code>) співпадає взагалі з любим об'єктом. Ми вже бачили, як це використовується по замовчанню, в альтернативі спіймати-всіє:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// обробляє випадок за замовчанням</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Підстановки можуть також бути використані для ігнорування частини об'єкта, яка нас не цікавить. Наприклад, попередній приклад насправді не переймається, які елементи є в двомісній операції; він тільки перевіряє, чи це є це двомісною операцією, чи ні. Таким чином, код так само може використовувати підстановочний шаблон для елементів <code>BinOp</code>, як показано в Лістингу 15.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;It&#39;s something else&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.4 - Порівняння шаблонів з підстановочними шаблонами.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Шаблони констант</h3>
<div class="paragraph"><p>Шаблон константи співпадає тільки сам з собою. В якості константи може бути використаний любий літерал. Наприклад, <code>5</code>, <code>true</code>, <code>"hello"</code> всі є шаблонами константами. Також в якості константи може використовуватись любий val або об'єкт синглтон. Наприклад, об'єкт синглтон <code>Nil</code> є шаблоном, що співпадає тільки з порожнім списком. Лістинг 15.5 показує деякі приклади шаблонів констант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="s">&quot;five&quot;</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="s">&quot;truth&quot;</span>
  <span class="k">case</span> <span class="s">&quot;hello&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;hi!&quot;</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">&quot;the empty list&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;something else&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.5 - Порівняння шаблонів з шаблонами константами.</p></div>
<div class="paragraph"><p>Ось як порівняння шаблонів, показане в Лістингу 15.5, виглядає в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">five</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">truth</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">the</span> <span class="n">empty</span> <span class="n">list</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">something</span> <span class="k">else</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___5">Шаблони змінні</h3>
<div class="paragraph"><p>Шаблон змінна співпадає з любим об'єктом, так само як підстановка. Але на відміну від підстановки, Scala прив'язує змінну до цього об'єкту. Потім ви можете використовувати цю змінну, щоб діяти на цьому об'єкті. Наприклад, Лістинг 15.6 показує порівняння шаблонів, що має особливий випадок для нуля, та випадок за замовчанням для всіх інших значень. Випадок за замовченням використовує шаблон змінної, яка надає ім'я значенню, не важливо що це є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="s">&quot;zero&quot;</span>
  <span class="k">case</span> <span class="n">somethingElse</span> <span class="k">=&gt;</span> <span class="s">&quot;not zero: &quot;</span> <span class="o">+</span> <span class="n">somethingElse</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.6 - Порівняння шаблонів з шаблоном змінної.</p></div>
</div>
<div class="sect2">
<h3 id="___">Змінна або константа?</h3>
<div class="paragraph"><p>Шаблони констант можуть мати символічні імена. Ви вже бачили це, коли ми використовували  <code>Nil</code> як шаблон. Ось пов'язаний приклад, де порівняння шаблонів задіє константи <code>E</code>(2.71828&#8230;) та <code>Pi</code> (3.14159&#8230;):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Pi</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="nc">Pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, <code>E</code> не дорівнює <code>Pi</code>, так що варіант "дивна математика" не використовується.</p></div>
<div class="paragraph"><p>Як компілятор Scala знає, що <code>Pi</code> є константою, імпортаваною з <code>scala.math</code>, а не змінна, що сама складає значення селектора? Scala використовує просте лексичне правило для вирішення неоднозначностей: просте ім'я, що починається з літери в нижньому реєстрі приймається як змінна шаблона; Всі інші посилання розглядаються як константи. Щоб побачити різницю, створіть псевдоним в нижньому реєстрі для <code>pi</code>, та спробуте виконати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="nc">Pi</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.141592653589793</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
<span class="o">}</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">strange</span> <span class="n">math</span><span class="o">?</span> <span class="nc">Pi</span> <span class="k">=</span> <span class="mf">2.718281828459045</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут компілятор навіть взагалі не дозволить вам додати випадок за замовчанням. Оскільки  <code>pi</code> є шаблоном змінної, вона буде співпадати з усіма входами, так що за нею жодний <code>case</code> не буде досяжний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
<span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви все ще можете використовувати ім'я в нижньому реєстрі для шаблогів констант, якщо вам так треба, але використовуючи один або два трюки. Перше, якщо константа є полем деякого об'єкта, ви можете поставити перед нею кваліфікатор. Наприклад, <code>pi</code> буде шаблоном змінної, але <code>this.pi</code> або <code>obj.pi</code> будуть константами, навіть якщо вони починаються з літер в нижньому реєстрі. Якщо це не робить (скажімо, тому що <code>pi</code> є локальною змінною), альтернативно ви можете оточити ім'я змінної в зворотні дефіси. Наприклад,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`pi`</code></pre>
</div></div>
<div class="paragraph"><p>знову буде інтерпретовано як константа, не як змінна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`pi`</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис з дефісами для ідентифікаторів використовуються в Scala для двох різних призначень, щоб допомогти вам кодувати у ваш спосіб за незвичних обставин. Тут ви бачили, як це використовується для трактування ідентифікатора в нижньому реєстрі як константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили, що це також може бути використано для трактування ключового слова як звичайного ідентифікатора, тобто, коли ви пишете</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Thread.`yield`()</code></pre>
</div></div>
<div class="paragraph"><p><code>yield</code> буде розглядатись як ідентифікатор, не як ключове слово.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Шаблони конструктори</h3>
<div class="paragraph"><p>Конструктори є те, де порівняння шаблонів стає дійсно потужним. Шаблоне конструктора виглядє як <code>BinOp("+", e, Number(0))</code>. Це складається з імені (<code>BinOp</code>), та потім з декількох шаблонів в дужках: <code>"+"</code>, <code>e</code> та <code>Number(0)</code>. Вважаючи, що ім'я означає кейс клас, такий шаблон означає, що спочатку перевіряється, що об'єкт є членом названого кейс класу, та потім перевіряє, що параметри конструктора об'єкта співпадають з наданими додатковими шаблонами.</p></div>
<div class="paragraph"><p>Ці додаткові шаблони означають, що шаблони Scala підтримують <em>глибоке порівняння</em>. Такі шаблони не тільки перевіряють наданий об'єкт високого рівня, але також вміст цього об'єкту щодо подальших шаблонів. Оскільки додаткові шаблони самі можуть бути шаблонами конструкторів, ви можете використовувати їх для перевірки довільної глибини вкладених об'єктів. Наприклад, шаблон, показаний в Лістингу 15.7, перевіряє, що об'єкт вищого рівня є <code>BinOp</code>, що його третій параметр конструктора є <code>Number</code>, та що значення поля цього числа є <code>0</code>. Цей шаблон довжиною в один рядок перевіряє на три рівня в глибину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;a deep match&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.7 - Порівняння шаблонів з шаблоном конструктора.</p></div>
</div>
<div class="sect2">
<h3 id="___7">Шаблони послідовностей</h3>
<div class="paragraph"><p>Ви можете порівнювати з типами послідовностей, як <code>List</code> або <code>Array</code>, так само, як ви порівнюєте з кейс класами. Використовується той самий синтаксис, але тепер ви можете вказати число елементів в шаблоні. Лістинг 15.8 показує шаблон, що перевіряє в пошуках три-елементних списків, що починаються з нуля.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="o">=&gt;}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.8 - Шаблон послідовності фіксованої довжини.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте порівняти з послідовністю, не вказуючи наскільки довгі вони є, ви можете вказати <code>_*</code> як останній елемент шаблону. Цей цікаво-виглядаючий шаблон співпадає з любим числом елементів в послідовності, включаючи нуль елементів. Лістинг 15.9 показує приклад, що співпадає з любим списком, що починається з нуля, не важливо які вони за довжиною.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.9 - Шаблон послідовності довільної довжини.</p></div>
</div>
<div class="sect2">
<h3 id="___8">Шаблони таплів</h3>
<div class="paragraph"><p>Ви можете також порівнювати з таплами. Шаблон як <code>(a, b, c)</code> співпадає з довільним 3-таплом. Приклад показаний в Лістингу 15.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">tupleDemo</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;matched &quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.10 - Порівняння шаблонів з шаблоном тапла.</p></div>
<div class="paragraph"><p>Якщо ви завантажите в інтерпретатор метод <code>tupleDemo</code>, показаний в Лістингу 15.10, та передасте до нього тапл з трьох елементів, ви побачите:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">tupleDemo</span><span class="o">((</span><span class="s">&quot;a &quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;-tuple&quot;</span><span class="o">))</span>
<span class="n">matched</span> <span class="n">a</span> <span class="mi">3</span><span class="o">-</span><span class="n">tuple</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___9">Шаблони типів</h3>
<div class="paragraph"><p>Ви можете використовувати <em>шаблон типу</em> як зручну заміну для перевірки типу та приведення типів. Лістинг 15.11 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.11 - Порівняння шаблонів з шаблоном типу.</p></div>
<div class="paragraph"><p>Ось декілька прикладів виконання <code>generalSize</code> в інтерпретаторі Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;b&#39;</span><span class="o">))</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>generalSize</code> повертає розмір або довжину об'єктів різних типів. Його аргумент має тип <code>Any</code>, так що він може мати любе значення. Якщо аргументом є <code>String</code>, метод повертає довжину рядка. Шаблон <code>s: String</code> є шаблоном типу; він співпадає з кожним (не-null) примірником <code>String</code>. Шаблон змінної <code>s</code> після співпадіння посилається на цей рядок.</p></div>
<div class="paragraph"><p>Зауважте, що навіть якщо <code>s</code> та <code>x</code> посилаються на те саме значення, типом <code>x</code> є <code>Any</code>, тоді як типом <code>s</code> є <code>String</code>. Так що ви можете записати <code>s.length</code> в виразі альтернативи, що відповідає шаблону, але ви не можете написати <code>x.length</code>, оскільки тип <code>Any</code> не має члена <code>length</code>. Еквівалентний, але більш довготривалий шлях досягти такий самий ефект порівняння з шаблоном типу, включає перевірку типу, за яким слідує перетворення типу. Scala використовує інший синтаксис для цього, ніж Java. Скажімо, щоб протестувати, чи вираз <code>expr</code> має тип <code>String</code>, ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб привести той самий вираз до типу <code>String</code>, ви використовуєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи перевірку та приведення типів, ви можете переписати перший <code>case</code> попереднього виразу <code>match</code>, як показано в Лістингу 15.12.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="n">s</span><span class="o">.</span><span class="n">length</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.12 - Використання <code>isInstanceOf</code> та <code>asInstanceOf</code> (слабкий стиль).</p></div>
<div class="paragraph"><p>Оператори <code>isInstanceOf</code> та <code>asInstanceOf</code> розглядаються як передвизначені методи класу <code>Any</code>, що приймає параметр типу в прямокутних дужках. Фактично, <code>x.asInstanceOf[String]</code> є особливим випадком виклику метода з явним параметром типу <code>String</code>.</p></div>
<div class="paragraph"><p>Як ви, сподіваємось, вже зауважили, написання перевірки та приведення типів є скоріше балакучим в  Scala. Це зроблене навмисно, оскільки ця практика не заохочується. Звичайно ви зробите краще, якщо використаєте порівняння шаблонів з шаблоном типу. Це зокрема вірно, якщо вам треба зробити одночасно перевірку та приведення типу, оскільки обидві операції можна закатати в одне порівняння шаблону.</p></div>
<div class="paragraph"><p>Другий <code>case</code> виразу <code>match</code> в Лістингу 15.11 містить шаблон типу <code>m: Map[_, _]</code>. Цей шаблон співпадає з любим значенням, що є <code>Map</code> деякого довільного типу ключа та значення, да встановлює <code>m</code> як посилання на цю мапу. Таким чином, <code>m.size</code> гарно типізоване і повертає розмір мапи. Підкреслення в шаблоні типу, <span class="footnote"><br />[В шаблоні типу <code>m: Map[_, _]</code>, частина <code>Map[_, _]</code> називається шаблоном типу.]<br /></span> є подібними до замінників в інших шаблонах. Ви також можете використовувати замість цього змінні типів (в нижньому реєстрі).</p></div>
</div>
<div class="sect2">
<h3 id="___10">Затирання типів</h3>
<div class="paragraph"><p>Чи ви можете також перевірити мапу щодо певних типів елементів? Це може стати в нагоді, скажімо, для перевірки, чи певне значення є мапа з типу <code>Int</code> до типу <code>Int</code>. Давайте спробуємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">non-variable</span> <span class="k">type</span> <span class="kt">argument</span> <span class="kt">Int</span> <span class="kt">in</span> <span class="k">type</span>
<span class="kt">pattern</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="o">(</span><span class="n">the</span>
<span class="n">underlying</span> <span class="n">of</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">])</span> <span class="n">is</span> <span class="n">unchecked</span> <span class="n">since</span> <span class="n">it</span> <span class="n">is</span>
<span class="n">eliminated</span> <span class="n">by</span> <span class="n">erasure</span>
<span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala використовує модель затирання дженериків, так само як робить Java. Це означає, що під час виконання немає інформації щодо типів аргументів. Відповідно немає шляху визначити під час виконання, чи об'єкт <code>Map</code> був створений з двома аргументами <code>Int</code>, скоріше, ніж з двома аргументами інших типів. Все, що може зробити система, це визначити, що значення є Map з довільними типами параметрів. Ви можете перевірити цю поведінку, через застосування <code>isIntIntMap</code> до аргументів різних примірників класу <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;abc&quot;</span><span class="o">))</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше застосування повертає <code>true</code>, що виглядає коректним, але друге застосування також повертає <code>true</code>, що може бути сюрпризом. Щоб попередити вас щодо можливої не-інтуітивної поведінки в рантаймі, компілятор видає попередження, як таке, що ви бачили перед цім.</p></div>
<div class="paragraph"><p>Одне виключення до правила затирання є масиви, тому що вони обробляються окремо в Java, так само як в Scala. Тип елементів масива зберігається зі значенням масиву, так що ви можете порівнювати шаблони завдяки цьому.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">&quot;yes&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;no&quot;</span>
<span class="o">}</span>
<span class="n">isStringArray</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Any</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">as</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">as</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">as</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">yes</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ai</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">ai</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">ai</span><span class="o">)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____2">Прив'язування змінних</h3>
<div class="paragraph"><p>На додаток до окремих шаблонів змінних, ви також можете додати змінну до любого іншого шаблону. Ви просто пишете ім'я змінної, знак <code>@</code>, та потім шаблон. Це дає вам шаблон з прив'язуванням змінної, що означає, що шаблон порівнюється як звичайно, і якщо співпадіння успішне, встановлює змінну в співпадаючий об'єкт, так само, як при звичайному шаблоні змінної.</p></div>
<div class="paragraph"><p>Як приклад, Лістинг 15.13 показує порівняння шаблонів, що шукає операцію абсолютного значення, яке застосоване два рази поспіль. Такі вирази можуть бути спрощені, щоб брати абсолютне значення тільки один раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="n">e</span> <span class="k">@</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.13 - Шаблон з прив'язуванням змінної (через знак @).</p></div>
<div class="paragraph"><p>Приклад, показаний в Лістингу 15.13, включає шаблон  прив'язування змінної, з <code>e</code> в якості змінної, та <code>UnOp("abs", _)</code> в якості шаблону. Якщо співпадіння цілого шаблону буде успішним, тоді частина, що співпадає з <code>UnOp("abs", _)</code>, буде доступна як змінна <code>e</code>. Результатом <code>case</code> є сама <code>e</code>, оскільки <code>e</code> має те саме значення, що і <code>expr</code>, але меньше на одну операцію абсолютного значення.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_3__">15.3 Захисники шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді синтаксичне порівняння шаблонів не є достатеьо точним. Скажімо, наприклад, ви має завдання сформулювати правило спрощення, що представляє вирази суми з двома однаковими операндами, такі як <code>e + e</code>, як множення на два (тобто, <code>e * 2</code>). В мові дерев <code>Expr</code> вираз як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>може бути трансформована цім правилом до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете спробувати виразити це правило таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">x</span> <span class="kt">is</span> <span class="kt">already</span> <span class="kt">defined</span> <span class="kt">as</span> <span class="kt">value</span> <span class="kt">x</span>
<span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
                   <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це схибить, оскільки Scala обмежує шаблони до лінійності: змінна шаблона може з'являтись в шаблоні тільки один раз. Однак, ви можете пере-формулювати <code>match</code> за допомогою захисника шаблона, як показано в Лістингу 15.14:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="n">simplifyAdd</span><span class="k">:</span> <span class="o">(</span><span class="kt">e:</span> <span class="kt">Expr</span><span class="o">)</span><span class="kt">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.14 - Вираз <code>match</code> з захисником шаблону.</p></div>
<div class="paragraph"><p>Захисник шаблону іде після шаблону, та починається з <code>if</code>. Захисник може бути довільним логічним виразом, що звичайно посилається на змінні в шаблоні. Якщо захисник шаблону присутній, <code>match</code> буде успішним тільки якщо захисник обчислюється до <code>true</code>. Таким чином, перший <code>case</code> вище буде співпадати тільки з двомісними операціями з двома однаковими операндами.</p></div>
<div class="paragraph"><p>Деякі інші приклади захищених шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// співпадає тільки з додатними цілими</span>
<span class="k">case</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="err">0</span> <span class="kt">&lt;</span> <span class="kt">n</span> <span class="o">=&gt;</span> <span class="o">...</span>

<span class="c1">// співпадає тільки з рядками, що починаються на літеру &#39;a&#39;</span>
<span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">if</span> <span class="kt">s</span><span class="o">(</span><span class="err">0</span><span class="o">)</span> <span class="o">=</span><span class="k">=</span> <span class="sc">&#39;a&#39;</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_4__">15.4 Перекриття шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Шаблони випробовуються в порядку, в якому вони записані. Версія <code>simplify</code>, показана в Лістингу 15.15, представляє приклад, де порядок <code>case</code> має значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;-&#39; подвійна інверсія</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span>
   <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;0&#39; є нейтральним елементом для &#39;+&#39;</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;1&#39; є нейтральним елементом для `*&#39;</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.15 - Вираз <code>match</code>, в якому порядок <code>case</code> має значення.</p></div>
<div class="paragraph"><p>Версія <code>simplify</code>, показана в Лістингу 15.15, буде застосовувати правила спрощення будь-де в виразі, не тільки на вищому рівні, як робив <code>simplifyTop</code>. Він може походити від <code>simplifyTop</code> через додавання ще двох випадків для узагальнених одно- та дво-місних виразів (випадки чотири та п'ять в Лістингу 15.15).</p></div>
<div class="paragraph"><p>Четвертий випадок має шаблон <code>UnOp(op, e)</code>; тобто, від співпадає з кожною одномісною операцією. Оператор та операнд одномісної операції можуть бути довільними. Вони прив'язуються до змінних шаблону, <code>op</code> и <code>e</code>, відповідно. Альтернатива в цьому <code>case</code> застосовує <code>simplifyAll</code> рекурсивно до операнда <code>e</code>, та потім перебудовує ту саму одномісну операцію з (можливо) спрощеним операндом. П'ятий <code>case</code> для <code>BinOp</code> є аналогічним: це випадок "спіймати-все" <code>case</code> для довільних двомісних операцій, що рекурсивно застосовує метод спрощення до своїх двох операндів.</p></div>
<div class="paragraph"><p>В цьому прикладі є важливим, що випадкі спіймати-всі ідуть після більш специфічних правил спрощення. Якщо ви запишете їх в іншому порядку, тоді випадок спіймати-всі мав би виконуватись раніше, ніж специфічні випадки. В багатьох випадках компілятор навіть буде скаржитись, якщо ви спробуєте. Наприклад, ось вираз <code>match</code>, що не компілюється, оскілький перший <code>case</code> буде співпадати з усім, з чим може співпасти другий <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
       <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
      <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
                                      <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_5__">15.5 Закорковані класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли б ви не писали порівняння шаблонів, вам треба переконатись, що ви розглянули всі можливі випадки. Іноді ви можете зробити це через додавання випадку за замовчанням до кінця <code>match</code>, але це має сенс, якщо існує доцільна поведінка за замовчанням. Що ви робитимете, якщо немає такого замовчання? Як ви будете почуватись впевнено, що покрили всі випадки?</p></div>
<div class="paragraph"><p>Ви можете отримати допомогу від Scala компілятора в визначенні пропущених комбінацій шаблонів в виразі <code>match</code>. Щоб зробити це, компілятор має бути в змозі сказати, які випадки є можливими. Загалом це неможливо в Scala, оскільки нові кейс класи можуть бути визначені в любий момент, та в довільних одиниціх компіляції. Наприклад, ніщо не завадить вам додати п'ятий кейс клас до ієрархії класу <code>Expr</code> в іншій одиниці компіляції, ніж та, де були визначені інші чотири випадки.</p></div>
<div class="paragraph"><p>Альтернативою є зробити суперклас вашого кейс класу закоркованим. Закоркований клас не може мати жодних субкласів, ніж ті, що знаходяться з мим в одному файлі. Це дуже корисно для порівняння шаблонів, оскільки це означає, що вам треба турбуватись тілкьи про субкласи, про які ви вже знаєте. Ще більше, ви також маєте більше підтримки з боку компілятора. Якщо ви порівнюєте кейс класи, що походять від закоркованого класу, компілятор буде помічати відсутні комбінації шаблонів повідомленнями попереджень.</p></div>
<div class="paragraph"><p>Якщо ви пишете ієрархію класів, призначених для порівняння шаблонів, ви маєте зробити їх закоркованими. Просто покладіть ключове слово <code>sealed</code> перед <code>class</code> зверху ієрархії. Програмісти, що використовують вашу ієрархію класів, після цього будуть почуватись зручно з порівнянням шаблонів. Таким чином, ключове слово <code>sealed</code> часто є ліцензією для порівняння шаблонів. Лістинг 15.16 показує приклад, в якому <code>Expr</code> перетворено на закоркований клас.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><spa