<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__15">Глава 15</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____">Кейс класи та порівняння шаблонів</h1>
<div class="paragraph"><p>Ця глава вводить <em>кейс класи</em> та <em>порівняння шаблонів</em>, споріднені конструкції, що підтримують вас коли ви пишете регулярні, не-інкапсульовані структури даних. Ці дві конструкції зокрема корисні для дерево-подібних рекурсивних даних.</p></div>
<div class="paragraph"><p>Якщо ви до цього програмували на функціональній мові, тоді ви, можливо, розпізнали порівняння шаблонів. Але кейс класи будуть новими для вас. Кейс класи це шлях Scala, щоб дозволити порівняння шаблонів на об'єктах, не потребуючи великої кількості кліше. Загалом, все що вам треба робити, це додати одне ключове слово case до кожного класу, що би бажаємо зробити придатним для порівняння.</p></div>
<div class="paragraph"><p>Ця глава починається з простого прикладу кейс класу та порівняння шаблонів. Потім вона проходить по всіх підтримуваних шаблонах, каже про роль закоркованих класів, дискутує тип <code>Option</code>, та показує деякі не-очевидні місця в мові, де використовується порівняння шаблонів. Нарешті, показаний більший, більш реалістичний приклад порівняння шаблонів.</p></div>
<div class="sect1">
<h2 id="_15_1__">15.1 Простий приклад</h2>
<div class="sectionbody">
<div class="paragraph"><p>Перед зануренням в усі правила та нюанси порівняння шаблонів, варто подивитись на простий приклад, щоб зрозуміти головну ідею. Скажімо, вам треба написати бібліотеку, що маніпулює арифметичними виразами, можливо як частину домен-специфічної мови, яку ви розробляєте.</p></div>
<div class="paragraph"><p>Перший крок подолання цієї проблеми є визначення вхідних даних. Щоб утримувати речі простими, ми сконцентруємось на арифметичних виразах, що складаються зі змінних, чисел, та одно- і дво-місних операціях. Це виражається через ієрархію Scala класів, показану в Лістингу 15.1.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.1 - Визначення кейс класів.</p></div>
<div class="paragraph"><p>Ієрархія включає абстрактний базовий клас <code>Expr</code> з чотирма субкласами, по одному для кожного типу виразу, що розглядається.<span class="footnote"><br />[Замість абстрактного класу, ми також можемо обрати змоделювати корінь ієрархії класів як трейт. Моделювання його як абстрактного класу може бути трохі більш ефективним.]<br /></span> Тіла всіх п'яти класів порожні. Як зазначалось раніше, в Scala ви можете відкинути фігурні дужки коло порожніх класів, якщо бажаєте, та що <code>class C</code> те саме, що і <code>class C {}</code>.</p></div>
<div class="sect2">
<h3 id="__">Кейс класи</h3>
<div class="paragraph"><p>Інша варта уваги річ щодо декларацій на Лістингу 15.1 є те, що кожний клас має модифікатор <code>case</code>. Класи з таким модифікатором називаються кейс класами. Використання модифікатора змушує Scala компілятор додати деякі синтаксичні зручності до вашого класу.</p></div>
<div class="paragraph"><p>Перше, він додає метод фабрику з ім'ям класу. Це означає, наприклад, що ви можете писати <code>Var("x")</code> для конструювання об'єкту <code>Var</code>, замість трохи довшого <code>new Var("x")</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">v</span><span class="k">:</span> <span class="kt">Var</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Методи фабрик зокрема гарні, коли ви вкладаєте їх. Оскільки не існує шумлячих ключових слів <code>new</code>, розкиданих по коду, ви можете збагнути структуру вираза з одного погляду:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">op</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">v</span><span class="o">)</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Друга синтаксична зручність в тому, що всі ці аргументи в списку параметрів кейс класів неявно отримують префікс <code>val</code>, так що вони обробляються як поля:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">name</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">left</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Третє, компілятор додає "природні" реалізації методів <code>toString</code>, <code>hashCode</code> та <code>equals</code> до вашого класу. Вони будуть друкувати, хешувати, та порівнювати цілі дерева, що складається з вашого класу, та (рекурсивно), всіх його аргументів. Оскільки <code>==</code> в Scala завжди делегує до <code>equals</code>, це означає, що елементи кейс класів завжди порівнюються структурно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
<span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Нарешті, компілятор додає метод <code>copy</code> до вашого класу, щоб робити модифіковані копії. Цей метод корисний для створення нових примірників класу, що такі самі, як і інший, за винятком того, що один або два аргументи відрізняються. Метод робить через використання іменованих та параметрів за замовчанням (дивіться Розділ 8.8). Ви вказуєте зміни, що ви б хотіли зробити, використовуючи іменовані параметри. Для любих параметрів, які ви не вказуєте, буде використано значення зі старого об'єкту. Як приклад, ось як ви можете зробити операцію, таку саму як <code>op</code>, за винятком того, що оператор змінений:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">operator</span> <span class="k">=</span> <span class="s">&quot;-&quot;</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(-,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі ці домовленості додають великі зручності за малу ціну. Ви мали написати лише модифікатор <code>case</code>, та ваші класи і об'єкти стають трохи більшими. Вони більші, оскільки згенеровані додаткові методи та додані неявні поля для кожного параметру конструктора. Однак найбільша вигода від кейс класів є те, що вони підтримують порівняння шаблонів.</p></div>
</div>
<div class="sect2">
<h3 id="___2">Порівняння шаблонів</h3>
<div class="paragraph"><p>Скажімо, ви бажаєте спростити арифметичні вирази тільки що представлених типів. Є багато можливих правил спрощення. Наступні три правила служать тільки для ілюстрації
:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span>  <span class="c1">// Подвійна зміна знаку</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Додавання нуля</span>
<span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="kc">null</span> <span class="c1">// Множення на одинницю</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи порівняння шаблонів, ці правила можуть розгядатись майже так, якби вони формували основу функції спрощення в Scala, як показано на Лістингу 15.2. Функція <code>simplifyTop</code>, може використовуватись таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))))</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>  <span class="c1">// Подвійна зміна знаку</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Додавання нуля</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span> <span class="c1">// Множення на одинницю</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.2 - Функція <code>simplifyTop</code>, що робить порівняння шаблонів.</p></div>
<div class="paragraph"><p>Права сторона <code>simplifyTop</code> складається з вираза <code>match</code>. <code>match</code> відповідає до <code>switch</code> в Java, але він записаний після вираза селектора. Іншими словами, це:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">selector</span> <span class="k">match</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>замість:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">switch</span> <span class="o">(</span><span class="n">selector</span><span class="o">)</span> <span class="o">{</span> <span class="n">alternatives</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Порівняння шаблонів включає послідовність альтернатив, кожне починається з ключового слова <code>case</code>. Кожна альтернатива включає шаблон, та один або більше виразів, що будуть обчислені, якщо шаблон співпадає. Символ стрілки <code>=&gt;</code> відділяє шаблон від виразів.</p></div>
<div class="paragraph"><p>Вираз <code>match</code> обчислюється через спробу кожного з шаблонів по порядку, як вони записані. Перший шаблон, що співпаде, буде обраний, та частина, що стоїть за стрілкою, обирається та виконується.</p></div>
<div class="paragraph"><p><em>Шаблон константи</em> як <code>"+"</code> або <code>1</code> співпадає зі значеннями, що дорівнюють константі з точки зору <code>==</code>.</p></div>
<div class="paragraph"><p><em>Шаблон змінної</em> як <code>e</code> співпадає з любим значенням. Змінна після цього посилається на це значення в правій частині твердження <code>case</code>. В цьому прикладі зауважте, що перші три альтернативи обчислюються до <code>e</code>, змінної, що прив'язана в асоційованому шаблоні. Підстановочний шаблон <code>_</code> також співпадає з кожним значенням, але він не вводить ім'я змінної, що посилається на це значення. В Лістингу 15.2 зауважте, як <code>match</code> закінчується на випадок за замовчаню, що нічого не робить з виразом. Замість цього, він просто має результат <code>expr</code>, вираз, якій порівнюється.</p></div>
<div class="paragraph"><p><em>Шаблон конструктора</em> виглядає <code>UnOp("-", e)</code>. Цей шаблон співпадає з усіма значеннями типу <code>UnOpwhose</code>, чий перший аргумент співпадає з <code>"-"</code>, та чий другий аргумент співпадає з <code>e</code>. Зауважте, що аргументи до конструктора самі є шаблонами. Це дозволяє вам писати глибокі шаблони, використовуючи стислу нотацію.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Уявіть реалізцію тієї самої функціональності з використанням дизайну шаблону візитора!<span class="footnote"><br />[Gamma, et. al., Design Patterns [Gam95]]<br /></span>Майже так само незручно, уявіть його реалізацію як довгої послідовності тверджень <code>if</code>, перевірок та перетворень типів.</p></div>
</div>
<div class="sect2">
<h3 id="__code_match_code__code_switch_code">Порівняння <code>match</code> та <code>switch</code></h3>
<div class="paragraph"><p>Вирази <code>match</code> можуть розглядатись як узагальнення <code>switch</code> в стилі Java. Перемикачі в стилі Java можуть бути природно виражені як вирази <code>match</code>, де кожний шаблон є константою, та останній шаблон може бути підстановочним (що презентує випадок <code>default</code> в <code>switch</code>).</p></div>
<div class="paragraph"><p>Однак існує три відмінності, що треба мати на увазі: перше - <code>match</code> є виразом в Scala (тобто, він завжди повертає значення). Друге, вирази альтернатив в Scala ніколи не "провалюються" в наступний випадок. Третє, як жодний з шаблонів не співпадає, закидається виключення <code>MatchError</code>. Це означає, що ви завжди маєте переконатись, що покриті всі випадки, навіть якщо це означає додавання випадку за замовчанням, якій нічого не робить.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.3 - Шаблон <code>match</code> з порожнім випадком <code>"default"</code>.</p></div>
<div class="paragraph"><p>Лістинг 15.3 показує приклад. Другий випадок є необхідним, оскільки без нього вираз <code>match</code> буде викликати <code>MatchError</code> для кожного аргументу <code>expr</code>, що не є <code>BinOp</code>. В цьому прикладі для другого випадка немає коду, так що при виконанні випадка нічого не виконується. В любому випадку результат є одиничне значенню <code>()</code>, що також є результатом всього виразу <code>match</code>.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_2__">15.2 Різновиди шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередній приклад показує декілька типів шаблонів в швидкій послідовності. Тепер затратимо хвилину, та детально поглянемо на кожний шаблон.</p></div>
<div class="paragraph"><p>Синтаксис шаблонів простий, так що не турбуйтесь щодо цього дуже сильно. Всі шаблони виглядають точно так, як відповідні вирази. Наприклад, маючи ієрархію з Лістингу 15.1, шаблон <code>Var(x)</code> співпадає з любим виразом змінної, пов'язуючи <code>x</code> з ім'ям змінної. Використовуючи вираз <code>Var(x)</code> — точно такий же синтаксис — перестворює еквівалентний об'єкт, вважаючи, що <code>x</code> вже прикріалений до імені змінної. Оскільки синтаксис шаблонів такий прозорий, головна річ, на яку варто звертати увагу, це тільки те, які шаблони взагалі можливі.</p></div>
<div class="sect2">
<h3 id="___3">Підстановочні шаблони</h3>
<div class="paragraph"><p>Підстановочний шаблон (<code>_</code>) співпадає взагалі з любим об'єктом. Ми вже бачили, як це використовується по замовчанню, в альтернативі спіймати-всіє:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="c1">// обробляє випадок за замовчанням</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Підстановки можуть також бути використані для ігнорування частини об'єкта, яка нас не цікавить. Наприклад, попередній приклад насправді не переймається, які елементи є в двомісній операції; він тільки перевіряє, чи це є це двомісною операцією, чи ні. Таким чином, код так само може використовувати підстановочний шаблон для елементів <code>BinOp</code>, як показано в Лістингу 15.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">&quot; is a binary operation&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;It&#39;s something else&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.4 - Порівняння шаблонів з підстановочними шаблонами.</p></div>
</div>
<div class="sect2">
<h3 id="___4">Шаблони констант</h3>
<div class="paragraph"><p>Шаблон константи співпадає тільки сам з собою. В якості константи може бути використаний любий літерал. Наприклад, <code>5</code>, <code>true</code>, <code>"hello"</code> всі є шаблонами константами. Також в якості константи може використовуватись любий val або об'єкт синглтон. Наприклад, об'єкт синглтон <code>Nil</code> є шаблоном, що співпадає тільки з порожнім списком. Лістинг 15.5 показує деякі приклади шаблонів констант:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="s">&quot;five&quot;</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="s">&quot;truth&quot;</span>
  <span class="k">case</span> <span class="s">&quot;hello&quot;</span> <span class="k">=&gt;</span> <span class="s">&quot;hi!&quot;</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">&quot;the empty list&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;something else&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.5 - Порівняння шаблонів з шаблонами константами.</p></div>
<div class="paragraph"><p>Ось як порівняння шаблонів, показане в Лістингу 15.5, виглядає в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">five</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">truth</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="s">&quot;hello&quot;</span><span class="o">)</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">hi</span><span class="o">!</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">Nil</span><span class="o">)</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">the</span> <span class="n">empty</span> <span class="n">list</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">describe</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">something</span> <span class="k">else</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___5">Шаблони змінні</h3>
<div class="paragraph"><p>Шаблон змінна співпадає з любим об'єктом, так само як підстановка. Але на відміну від підстановки, Scala прив'язує змінну до цього об'єкту. Потім ви можете використовувати цю змінну, щоб діяти на цьому об'єкті. Наприклад, Лістинг 15.6 показує порівняння шаблонів, що має особливий випадок для нуля, та випадок за замовчанням для всіх інших значень. Випадок за замовченням використовує шаблон змінної, яка надає ім'я значенню, не важливо що це є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="s">&quot;zero&quot;</span>
  <span class="k">case</span> <span class="n">somethingElse</span> <span class="k">=&gt;</span> <span class="s">&quot;not zero: &quot;</span> <span class="o">+</span> <span class="n">somethingElse</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.6 - Порівняння шаблонів з шаблоном змінної.</p></div>
</div>
<div class="sect2">
<h3 id="___">Змінна або константа?</h3>
<div class="paragraph"><p>Шаблони констант можуть мати символічні імена. Ви вже бачили це, коли ми використовували  <code>Nil</code> як шаблон. Ось пов'язаний приклад, де порівняння шаблонів задіє константи <code>E</code>(2.71828&#8230;) та <code>Pi</code> (3.14159&#8230;):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Pi</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="nc">Pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як і очікувалось, <code>E</code> не дорівнює <code>Pi</code>, так що варіант "дивна математика" не використовується.</p></div>
<div class="paragraph"><p>Як компілятор Scala знає, що <code>Pi</code> є константою, імпортаваною з <code>scala.math</code>, а не змінна, що сама складає значення селектора? Scala використовує просте лексичне правило для вирішення неоднозначностей: просте ім'я, що починається з літери в нижньому реєстрі приймається як змінна шаблона; Всі інші посилання розглядаються як константи. Щоб побачити різницю, створіть псевдоним в нижньому реєстрі для <code>pi</code>, та спробуте виконати таке:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="nc">Pi</span>
<span class="n">pi</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">3.141592653589793</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
<span class="o">}</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">strange</span> <span class="n">math</span><span class="o">?</span> <span class="nc">Pi</span> <span class="k">=</span> <span class="mf">2.718281828459045</span>
</pre></div></div></div>
<div class="paragraph"><p>Тут компілятор навіть взагалі не дозволить вам додати випадок за замовчанням. Оскільки  <code>pi</code> є шаблоном змінної, вона буде співпадати з усіма входами, так що за нею жодний <code>case</code> не буде досяжний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
<span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">&quot;strange math? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">12</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
          <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви все ще можете використовувати ім'я в нижньому реєстрі для шаблогів констант, якщо вам так треба, але використовуючи один або два трюки. Перше, якщо константа є полем деякого об'єкта, ви можете поставити перед нею кваліфікатор. Наприклад, <code>pi</code> буде шаблоном змінної, але <code>this.pi</code> або <code>obj.pi</code> будуть константами, навіть якщо вони починаються з літер в нижньому реєстрі. Якщо це не робить (скажімо, тому що <code>pi</code> є локальною змінною), альтернативно ви можете оточити ім'я змінної в зворотні дефіси. Наприклад,</p></div>
<div class="listingblock">
<div class="content">
<pre><code>`pi`</code></pre>
</div></div>
<div class="paragraph"><p>знову буде інтерпретовано як константа, не як змінна:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">`pi`</span> <span class="k">=&gt;</span> <span class="s">&quot;дивна математика? Pi = &quot;</span> <span class="o">+</span> <span class="n">pi</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;OK&quot;</span>
<span class="o">}</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">OK</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви можете бачити, синтаксис з дефісами для ідентифікаторів використовуються в Scala для двох різних призначень, щоб допомогти вам кодувати у ваш спосіб за незвичних обставин. Тут ви бачили, як це використовується для трактування ідентифікатора в нижньому реєстрі як константи в порівнянні шаблонів. Раніше, в Розділі 6.10, ви бачили, що це також може бути використано для трактування ключового слова як звичайного ідентифікатора, тобто, коли ви пишете</p></div>
<div class="listingblock">
<div class="content">
<pre><code>Thread.`yield`()</code></pre>
</div></div>
<div class="paragraph"><p><code>yield</code> буде розглядатись як ідентифікатор, не як ключове слово.</p></div>
</div>
<div class="sect2">
<h3 id="___6">Шаблони конструктори</h3>
<div class="paragraph"><p>Конструктори є те, де порівняння шаблонів стає дійсно потужним. Шаблоне конструктора виглядє як <code>BinOp("+", e, Number(0))</code>. Це складається з імені (<code>BinOp</code>), та потім з декількох шаблонів в дужках: <code>"+"</code>, <code>e</code> та <code>Number(0)</code>. Вважаючи, що ім'я означає кейс клас, такий шаблон означає, що спочатку перевіряється, що об'єкт є членом названого кейс класу, та потім перевіряє, що параметри конструктора об'єкта співпадають з наданими додатковими шаблонами.</p></div>
<div class="paragraph"><p>Ці додаткові шаблони означають, що шаблони Scala підтримують <em>глибоке порівняння</em>. Такі шаблони не тільки перевіряють наданий об'єкт високого рівня, але також вміст цього об'єкту щодо подальших шаблонів. Оскільки додаткові шаблони самі можуть бути шаблонами конструкторів, ви можете використовувати їх для перевірки довільної глибини вкладених об'єктів. Наприклад, шаблон, показаний в Лістингу 15.7, перевіряє, що об'єкт вищого рівня є <code>BinOp</code>, що його третій параметр конструктора є <code>Number</code>, та що значення поля цього числа є <code>0</code>. Цей шаблон довжиною в один рядок перевіряє на три рівня в глибину.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;a deep match&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.7 - Порівняння шаблонів з шаблоном конструктора.</p></div>
</div>
<div class="sect2">
<h3 id="___7">Шаблони послідовностей</h3>
<div class="paragraph"><p>Ви можете порівнювати з типами послідовностей, як <code>List</code> або <code>Array</code>, так само, як ви порівнюєте з кейс класами. Використовується той самий синтаксис, але тепер ви можете вказати число елементів в шаблоні. Лістинг 15.8 показує шаблон, що перевіряє в пошуках три-елементних списків, що починаються з нуля.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="o">=&gt;}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.8 - Шаблон послідовності фіксованої довжини.</p></div>
<div class="paragraph"><p>Якщо ви бажаєте порівняти з послідовністю, не вказуючи наскільки довгі вони є, ви можете вказати <code>_*</code> як останній елемент шаблону. Цей цікаво-виглядаючий шаблон співпадає з любим числом елементів в послідовності, включаючи нуль елементів. Лістинг 15.9 показує приклад, що співпадає з любим списком, що починається з нуля, не важливо які вони за довжиною.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;found it&quot;</span><span class="o">)</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.9 - Шаблон послідовності довільної довжини.</p></div>
</div>
<div class="sect2">
<h3 id="___8">Шаблони таплів</h3>
<div class="paragraph"><p>Ви можете також порівнювати з таплами. Шаблон як <code>(a, b, c)</code> співпадає з довільним 3-таплом. Приклад показаний в Лістингу 15.10.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">tupleDemo</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;matched &quot;</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.10 - Порівняння шаблонів з шаблоном тапла.</p></div>
<div class="paragraph"><p>Якщо ви завантажите в інтерпретатор метод <code>tupleDemo</code>, показаний в Лістингу 15.10, та передасте до нього тапл з трьох елементів, ви побачите:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">tupleDemo</span><span class="o">((</span><span class="s">&quot;a &quot;</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">&quot;-tuple&quot;</span><span class="o">))</span>
<span class="n">matched</span> <span class="n">a</span> <span class="mi">3</span><span class="o">-</span><span class="n">tuple</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="___9">Шаблони типів</h3>
<div class="paragraph"><p>Ви можете використовувати <em>шаблон типу</em> як зручну заміну для перевірки типу та приведення типів. Лістинг 15.11 показує приклад.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.11 - Порівняння шаблонів з шаблоном типу.</p></div>
<div class="paragraph"><p>Ось декілька прикладів виконання <code>generalSize</code> в інтерпретаторі Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="sc">&#39;a&#39;</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="sc">&#39;b&#39;</span><span class="o">))</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="o">)</span>
<span class="n">res18</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div></div></div>
<div class="paragraph"><p>Метод <code>generalSize</code> повертає розмір або довжину об'єктів різних типів. Його аргумент має тип <code>Any</code>, так що він може мати любе значення. Якщо аргументом є <code>String</code>, метод повертає довжину рядка. Шаблон <code>s: String</code> є шаблоном типу; він співпадає з кожним (не-null) примірником <code>String</code>. Шаблон змінної <code>s</code> після співпадіння посилається на цей рядок.</p></div>
<div class="paragraph"><p>Зауважте, що навіть якщо <code>s</code> та <code>x</code> посилаються на те саме значення, типом <code>x</code> є <code>Any</code>, тоді як типом <code>s</code> є <code>String</code>. Так що ви можете записати <code>s.length</code> в виразі альтернативи, що відповідає шаблону, але ви не можете написати <code>x.length</code>, оскільки тип <code>Any</code> не має члена <code>length</code>. Еквівалентний, але більш довготривалий шлях досягти такий самий ефект порівняння з шаблоном типу, включає перевірку типу, за яким слідує перетворення типу. Scala використовує інший синтаксис для цього, ніж Java. Скажімо, щоб протестувати, чи вираз <code>expr</code> має тип <code>String</code>, ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Щоб привести той самий вираз до типу <code>String</code>, ви використовуєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи перевірку та приведення типів, ви можете переписати перший <code>case</code> попереднього виразу <code>match</code>, як показано в Лістингу 15.12.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
  <span class="n">s</span><span class="o">.</span><span class="n">length</span>
<span class="o">}</span> <span class="k">else</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.12 - Використання <code>isInstanceOf</code> та <code>asInstanceOf</code> (слабкий стиль).</p></div>
<div class="paragraph"><p>Оператори <code>isInstanceOf</code> та <code>asInstanceOf</code> розглядаються як передвизначені методи класу <code>Any</code>, що приймає параметр типу в прямокутних дужках. Фактично, <code>x.asInstanceOf[String]</code> є особливим випадком виклику метода з явним параметром типу <code>String</code>.</p></div>
<div class="paragraph"><p>Як ви, сподіваємось, вже зауважили, написання перевірки та приведення типів є скоріше балакучим в  Scala. Це зроблене навмисно, оскільки ця практика не заохочується. Звичайно ви зробите краще, якщо використаєте порівняння шаблонів з шаблоном типу. Це зокрема вірно, якщо вам треба зробити одночасно перевірку та приведення типу, оскільки обидві операції можна закатати в одне порівняння шаблону.</p></div>
<div class="paragraph"><p>Другий <code>case</code> виразу <code>match</code> в Лістингу 15.11 містить шаблон типу <code>m: Map[_, _]</code>. Цей шаблон співпадає з любим значенням, що є <code>Map</code> деякого довільного типу ключа та значення, да встановлює <code>m</code> як посилання на цю мапу. Таким чином, <code>m.size</code> гарно типізоване і повертає розмір мапи. Підкреслення в шаблоні типу, <span class="footnote"><br />[В шаблоні типу <code>m: Map[_, _]</code>, частина <code>Map[_, _]</code> називається шаблоном типу.]<br /></span> є подібними до замінників в інших шаблонах. Ви також можете використовувати замість цього змінні типів (в нижньому реєстрі).</p></div>
</div>
<div class="sect2">
<h3 id="___10">Затирання типів</h3>
<div class="paragraph"><p>Чи ви можете також перевірити мапу щодо певних типів елементів? Це може стати в нагоді, скажімо, для перевірки, чи певне значення є мапа з типу <code>Int</code> до типу <code>Int</code>. Давайте спробуємо:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">9</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">non-variable</span> <span class="k">type</span> <span class="kt">argument</span> <span class="kt">Int</span> <span class="kt">in</span> <span class="k">type</span>
<span class="kt">pattern</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">]</span> <span class="o">(</span><span class="n">the</span>
<span class="n">underlying</span> <span class="n">of</span> <span class="nc">Map</span><span class="o">[</span><span class="kt">Int</span>,<span class="kt">Int</span><span class="o">])</span> <span class="n">is</span> <span class="n">unchecked</span> <span class="n">since</span> <span class="n">it</span> <span class="n">is</span>
<span class="n">eliminated</span> <span class="n">by</span> <span class="n">erasure</span>
<span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
        <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Scala використовує модель затирання дженериків, так само як робить Java. Це означає, що під час виконання немає інформації щодо типів аргументів. Відповідно немає шляху визначити під час виконання, чи об'єкт <code>Map</code> був створений з двома аргументами <code>Int</code>, скоріше, ніж з двома аргументами інших типів. Все, що може зробити система, це визначити, що значення є Map з довільними типами параметрів. Ви можете перевірити цю поведінку, через застосування <code>isIntIntMap</code> до аргументів різних примірників класу <code>Map</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">))</span>
<span class="n">res19</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isIntIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">&quot;abc&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;abc&quot;</span><span class="o">))</span>
<span class="n">res20</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Перше застосування повертає <code>true</code>, що виглядає коректним, але друге застосування також повертає <code>true</code>, що може бути сюрпризом. Щоб попередити вас щодо можливої не-інтуітивної поведінки в рантаймі, компілятор видає попередження, як таке, що ви бачили перед цім.</p></div>
<div class="paragraph"><p>Одне виключення до правила затирання є масиви, тому що вони обробляються окремо в Java, так само як в Scala. Тип елементів масива зберігається зі значенням масиву, так що ви можете порівнювати шаблони завдяки цьому.</p></div>
<div class="paragraph"><p>Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">a</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="s">&quot;yes&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;no&quot;</span>
<span class="o">}</span>
<span class="n">isStringArray</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Any</span><span class="o">)</span><span class="kt">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">as</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">as</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">as</span><span class="o">)</span>
<span class="n">res21</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">yes</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">ai</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">ai</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isStringArray</span><span class="o">(</span><span class="n">ai</span><span class="o">)</span>
<span class="n">res22</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="____2">Прив'язування змінних</h3>
<div class="paragraph"><p>На додаток до окремих шаблонів змінних, ви також можете додати змінну до любого іншого шаблону. Ви просто пишете ім'я змінної, знак <code>@</code>, та потім шаблон. Це дає вам шаблон з прив'язуванням змінної, що означає, що шаблон порівнюється як звичайно, і якщо співпадіння успішне, встановлює змінну в співпадаючий об'єкт, так само, як при звичайному шаблоні змінної.</p></div>
<div class="paragraph"><p>Як приклад, Лістинг 15.13 показує порівняння шаблонів, що шукає операцію абсолютного значення, яке застосоване два рази поспіль. Такі вирази можуть бути спрощені, щоб брати абсолютне значення тільки один раз.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="n">e</span> <span class="k">@</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;abs&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.13 - Шаблон з прив'язуванням змінної (через знак @).</p></div>
<div class="paragraph"><p>Приклад, показаний в Лістингу 15.13, включає шаблон  прив'язування змінної, з <code>e</code> в якості змінної, та <code>UnOp("abs", _)</code> в якості шаблону. Якщо співпадіння цілого шаблону буде успішним, тоді частина, що співпадає з <code>UnOp("abs", _)</code>, буде доступна як змінна <code>e</code>. Результатом <code>case</code> є сама <code>e</code>, оскільки <code>e</code> має те саме значення, що і <code>expr</code>, але меньше на одну операцію абсолютного значення.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_3__">15.3 Захисники шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Іноді синтаксичне порівняння шаблонів не є достатеьо точним. Скажімо, наприклад, ви має завдання сформулювати правило спрощення, що представляє вирази суми з двома однаковими операндами, такі як <code>e + e</code>, як множення на два (тобто, <code>e * 2</code>). В мові дерев <code>Expr</code> вираз як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>може бути трансформована цім правилом до:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви можете спробувати виразити це правило таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">14</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">x</span> <span class="kt">is</span> <span class="kt">already</span> <span class="kt">defined</span> <span class="kt">as</span> <span class="kt">value</span> <span class="kt">x</span>
<span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
                   <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Це схибить, оскільки Scala обмежує шаблони до лінійності: змінна шаблона може з'являтись в шаблоні тільки один раз. Однак, ви можете пере-формулювати <code>match</code> за допомогою захисника шаблона, як показано в Лістингу 15.14:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>
<span class="n">simplifyAdd</span><span class="k">:</span> <span class="o">(</span><span class="kt">e:</span> <span class="kt">Expr</span><span class="o">)</span><span class="kt">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.14 - Вираз <code>match</code> з захисником шаблону.</p></div>
<div class="paragraph"><p>Захисник шаблону іде після шаблону, та починається з <code>if</code>. Захисник може бути довільним логічним виразом, що звичайно посилається на змінні в шаблоні. Якщо захисник шаблону присутній, <code>match</code> буде успішним тільки якщо захисник обчислюється до <code>true</code>. Таким чином, перший <code>case</code> вище буде співпадати тільки з двомісними операціями з двома однаковими операндами.</p></div>
<div class="paragraph"><p>Деякі інші приклади захищених шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// співпадає тільки з додатними цілими</span>
<span class="k">case</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="err">0</span> <span class="kt">&lt;</span> <span class="kt">n</span> <span class="o">=&gt;</span> <span class="o">...</span>

<span class="c1">// співпадає тільки з рядками, що починаються на літеру &#39;a&#39;</span>
<span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">if</span> <span class="kt">s</span><span class="o">(</span><span class="err">0</span><span class="o">)</span> <span class="o">=</span><span class="k">=</span> <span class="sc">&#39;a&#39;</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_4__">15.4 Перекриття шаблонів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Шаблони випробовуються в порядку, в якому вони записані. Версія <code>simplify</code>, показана в Лістингу 15.15, представляє приклад, де порядок <code>case</code> має значення.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;-&#39; подвійна інверсія</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span>
   <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;0&#39; є нейтральним елементом для &#39;+&#39;</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// &#39;1&#39; є нейтральним елементом для `*&#39;</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.15 - Вираз <code>match</code>, в якому порядок <code>case</code> має значення.</p></div>
<div class="paragraph"><p>Версія <code>simplify</code>, показана в Лістингу 15.15, буде застосовувати правила спрощення будь-де в виразі, не тільки на вищому рівні, як робив <code>simplifyTop</code>. Він може походити від <code>simplifyTop</code> через додавання ще двох випадків для узагальнених одно- та дво-місних виразів (випадки чотири та п'ять в Лістингу 15.15).</p></div>
<div class="paragraph"><p>Четвертий випадок має шаблон <code>UnOp(op, e)</code>; тобто, від співпадає з кожною одномісною операцією. Оператор та операнд одномісної операції можуть бути довільними. Вони прив'язуються до змінних шаблону, <code>op</code> и <code>e</code>, відповідно. Альтернатива в цьому <code>case</code> застосовує <code>simplifyAll</code> рекурсивно до операнда <code>e</code>, та потім перебудовує ту саму одномісну операцію з (можливо) спрощеним операндом. П'ятий <code>case</code> для <code>BinOp</code> є аналогічним: це випадок "спіймати-все" <code>case</code> для довільних двомісних операцій, що рекурсивно застосовує метод спрощення до своїх двох операндів.</p></div>
<div class="paragraph"><p>В цьому прикладі є важливим, що випадкі спіймати-всі ідуть після більш специфічних правил спрощення. Якщо ви запишете їх в іншому порядку, тоді випадок спіймати-всі мав би виконуватись раніше, ніж специфічні випадки. В багатьох випадках компілятор навіть буде скаржитись, якщо ви спробуєте. Наприклад, ось вираз <code>match</code>, що не компілюється, оскілький перший <code>case</code> буде співпадати з усім, з чим може співпасти другий <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyBad</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
         <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
       <span class="o">}</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">21</span><span class="k">:</span> <span class="kt">warning:</span> <span class="kt">unreachable</span> <span class="kt">code</span>
      <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
                                      <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_5__">15.5 Закорковані класи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Коли б ви не писали порівняння шаблонів, вам треба переконатись, що ви розглянули всі можливі випадки. Іноді ви можете зробити це через додавання випадку за замовчанням до кінця <code>match</code>, але це має сенс, якщо існує доцільна поведінка за замовчанням. Що ви робитимете, якщо немає такого замовчання? Як ви будете почуватись впевнено, що покрили всі випадки?</p></div>
<div class="paragraph"><p>Ви можете отримати допомогу від Scala компілятора в визначенні пропущених комбінацій шаблонів в виразі <code>match</code>. Щоб зробити це, компілятор має бути в змозі сказати, які випадки є можливими. Загалом це неможливо в Scala, оскільки нові кейс класи можуть бути визначені в любий момент, та в довільних одиниціх компіляції. Наприклад, ніщо не завадить вам додати п'ятий кейс клас до ієрархії класу <code>Expr</code> в іншій одиниці компіляції, ніж та, де були визначені інші чотири випадки.</p></div>
<div class="paragraph"><p>Альтернативою є зробити суперклас вашого кейс класу закоркованим. Закоркований клас не може мати жодних субкласів, ніж ті, що знаходяться з мим в одному файлі. Це дуже корисно для порівняння шаблонів, оскільки це означає, що вам треба турбуватись тілкьи про субкласи, про які ви вже знаєте. Ще більше, ви також маєте більше підтримки з боку компілятора. Якщо ви порівнюєте кейс класи, що походять від закоркованого класу, компілятор буде помічати відсутні комбінації шаблонів повідомленнями попереджень.</p></div>
<div class="paragraph"><p>Якщо ви пишете ієрархію класів, призначених для порівняння шаблонів, ви маєте зробити їх закоркованими. Просто покладіть ключове слово <code>sealed</code> перед <code>class</code> зверху ієрархії. Програмісти, що використовують вашу ієрархію класів, після цього будуть почуватись зручно з порівнянням шаблонів. Таким чином, ключове слово <code>sealed</code> часто є ліцензією для порівняння шаблонів. Лістинг 15.16 показує приклад, в якому <code>Expr</code> перетворено на закоркований клас.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
  <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.16 - Закоркована ієрархія кейс класів.</p></div>
<div class="paragraph"><p>Тепер визначимо порівняння шаблонів, де пропущені деякі можливі варіанти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви отримаєте попередження компілятора, подібне до наступного:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>warning: match is not exhaustive!
missing combination           UnOp
missing combination          BinOp</code></pre>
</div></div>
<div class="paragraph"><p>Паке попередження каже вам, що існує ризик що ваш код може продукувати виключення <code>MatchError</code>, оскільки деякі можливі шаблони (<code>UnOp</code>, <code>BinOp</code>) не оброблені. Попередження вказує на потенційне джерело збоїв під час виконання, так що це звичайно гарна допомога, щоб зробити ваш код вірним.</p></div>
<div class="paragraph"><p>Однак, часом ви можете натрапити на ситуацію, коли компілятор дуже прискіпливий, видаючи попередження. Наприклад, ви можете знати з контексту, що ви будете застосовувати описаний вище метод до виразів, що є або <code>Numbers</code> або <code>Vars</code>, так що ви знаєте, що він не спродукує <code>MatchError</code>. Щоб повідомлення пішло, ви можете додати третій випадок спіймати-всі до цього метода, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span> <span class="c1">// Не має трапитись</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, але це не ідеальне. Ви, можливо, не будете дуже щасливі, коли будете змушені додати код, якій ніколи не буде виконуватись (або ви так думаєте), просто попросивши компілятор помовчати.</p></div>
<div class="paragraph"><p>Більш полегшена альтернатива є додати анотацію <code>@unchecked</code> до вираза селектора в <code>match</code>. Це робиться таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a number&quot;</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">&quot;a variable&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Анотації описані в Главі 27. Загалом, ви можете додати анотацію до виразу в той самий спосіб, як ви додаєте тип: за виразом слідують дві крапки і ім'я анотації (зі знаком <em>@</em>). Наприклад, в цьому випадку ви додаєте анотацію <code>@unchecked</code> до змінної <code>e</code> за допомогою <code>e: @unchecked</code>. Анотація <code>@unchecked</code> має особливе значення для порівняння шаблонів. Якщо селектор `match`має цю анотацію, всебічна перевірка шаблону, що слідує, буде придушена.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_6__option">15.6 Тип Option</h2>
<div class="sectionbody">
<div class="paragraph"><p>Scala має стандартний тип на ім'я <code>Option</code> для опціональних значень. Таке значення може бути в двох формах: <code>Some(x)</code>, де <code>x</code> є дійсним значенням, або об'єкт <code>None</code>, що представляє відсутність значення.</p></div>
<div class="paragraph"><p>Опціональні значення продукуються деякими зі стандартних операцій для колекцій Scala. Наприклад, метод <code>get</code> зі Scala <code>Map</code> продукує <code>Some(value)</code>, якщо значення, відповідне до наданого ключа, було знайдене, або <code>None</code>, якщо наданий ключ не визначений в <code>Map</code>. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">capitals</span> <span class="k">=</span>
          <span class="nc">Map</span><span class="o">(</span><span class="s">&quot;France&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Paris&quot;</span><span class="o">,</span> <span class="s">&quot;Japan&quot;</span> <span class="o">-&gt;</span> <span class="s">&quot;Tokyo&quot;</span><span class="o">)</span>
<span class="n">capitals</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Map</span><span class="o">[</span><span class="kt">String</span>,<span class="kt">String</span><span class="o">]</span> <span class="k">=</span>
<span class="nc">Map</span><span class="o">(</span><span class="nc">France</span> <span class="o">-&gt;</span> <span class="nc">Paris</span><span class="o">,</span> <span class="nc">Japan</span> <span class="o">-&gt;</span> <span class="nc">Tokyo</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;France&quot;</span>
<span class="n">res23</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="nc">Paris</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;North Pole&quot;</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Найбільш загальний шлях прийняти опціональні значення окремо - через порівняння шаблонів. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
         <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span>
         <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">&quot;?&quot;</span>
       <span class="o">}</span>
<span class="n">show</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="nc">String</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;Japan&quot;</span><span class="o">)</span>
<span class="n">res25</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Tokyo</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;France&quot;</span><span class="o">)</span>
<span class="n">res26</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="nc">Paris</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">show</span><span class="o">(</span><span class="n">capitals</span> <span class="n">get</span> <span class="s">&quot;North Pole&quot;</span><span class="o">)</span>
<span class="n">res27</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">?</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>Option</code> часто використовується в програмах Scala. Порівняйте це з домінуючою ідіомою Java, використовувати <code>null</code> для вказання відсутності значення. Наприклад, метод <code>get</code> в <code>java.util.HashMapreturns</code> повертає або значення, що зберігається в <code>HashMap</code>, або <code>null</code>, якщо значення не знайдене. Цей підхід робить для Java, але схильний до помилок, оскільки на практиці складно відстежувати, які змінні в програмі можуть приймати значення <code>null</code>.</p></div>
<div class="paragraph"><p>Якщо змінній дозволено бути <code>null</code>, тоді ви маєте пам'ятати перевіряти її на <code>null</code> кожного разу, коли ви використосуєте її. Якщо ви забудете перевірити, ви відкриєте можливість, щоб під час виконання отримати <code>NullPointerException</code>. Оскільки такі виключення не можуть траплятись дуже часто, може бути складно визначити помилку під час тестування. Для Scala цей підхід не робить взагалі, оскільки можливо зберігати значення типів в хеш мапах, але <code>null</code> не є легальним елементом для типу значення. Наприклад, <code>HashMap[Int, Int]</code> не може повертати <code>null</code> для позначення "нема елементу".</p></div>
<div class="paragraph"><p>Для контрасту Scala заохочує використання <code>Option</code> для індикації опціонального значення. Цей підхід до опціональних значень має декілька переваг над Java. Перше, це значно більш очевидне для читачів коду, що змінна, чий тип <code>Option[String]</code> є опціональний <code>String</code>, ніж змінна типу <code>String</code>, що може інколи бути <code>null</code>. Але більш важливо, що описана раніше помилка програмування, щодо використання змінної, що може бути <code>null</code> без попередньої перевірки її на <code>null</code>, в Scala стає помилкою типу. Якщо змінна має тип <code>Option[String]</code>, і ви намагаєтесь використовувати її як <code>String</code>, ваша Scala програма не буде компілюватись.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_7__">15.7 Шаблони кругом</h2>
<div class="sectionbody">
<div class="paragraph"><p>Шаблони дозволені в багатьох частинах Scala, не тільки в окремих виразах <code>match</code>. Погляньте на деякі інші місця, де ви можете використовувати шаблони.</p></div>
<div class="sect2">
<h3 id="____">Шаблони в присвоєнні змінних</h3>
<div class="paragraph"><p>Кожного разу, коли ви визначаєте <code>val</code> або <code>var</code>, ви можете використовувати шаблон замість простого ідентифікатора. Наприклад, ви можете розібрати тапл на частини, та присвоїти кожній з частин свою власну змінну, як показане в Лістингу 15.17:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">myTuple</span> <span class="k">=</span> <span class="o">(</span><span class="mi">123</span><span class="o">,</span> <span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">myTuple</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="mi">123</span><span class="o">,</span><span class="n">abc</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">string</span><span class="o">)</span> <span class="k">=</span> <span class="n">myTuple</span>
<span class="n">number</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">123</span>
<span class="n">string</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.17 - Визначення декількох змінних одним присвоєнням.</p></div>
<div class="paragraph"><p>Ця конструкція досить корисна, коли робите з кейс класами. Якщо ви точно знаєте кейс клас, з яким ви працюєте, тоді ви можете деконструювати його в шаблоні. Ось приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">exp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span>
<span class="n">exp</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(*,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">5.0</span><span class="o">),</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=</span> <span class="n">exp</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">*</span>
<span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">5.0</span><span class="o">)</span>
<span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__code_ase_code___">Послідовності <code>сase</code> як часткові функції</h3>
<div class="paragraph"><p>Послідовність випадків (тобто альтернативи) в фігурних дужках можуть бути використані будь-де, де може бути використаний функціональний літерал. В основному послідовність <code>case</code> є функціональним літералом. Змість мати одну точку входу та список параметрів, <code>case</code> послідовність має декілька точок входу, кожна зі своїм списком параметрів. Кожний <code>case</code> є точкою входу до функції, та параметри задаються шаблоном. Тіло кожної точки входу є правою стороною <code>case</code>.</p></div>
<div class="paragraph"><p>Ось простий приклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">withDefault</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Тіло цієї функції має два <code>case</code> випадки. Перший <code>case</code> співпадає з <code>Some</code>, та повертає число в <code>Some</code>. Другий <code>case</code> співпадає з <code>None</code>, та повертає значення за замовчанням, нуль. Ось ця функція в дії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">withDefault</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
<span class="n">res28</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">10</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">withDefault</span><span class="o">(</span><span class="nc">None</span><span class="o">)</span>
<span class="n">res29</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця можливість досить корисна для бібліотеки акторів Akka, оскільки вона дозволяє її методу <code>receive</code> бути визначеним як послідовність <code>cases</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Data</span><span class="o">(</span><span class="n">byte</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">byte</span>
  <span class="k">case</span> <span class="nc">GetChecksum</span><span class="o">(</span><span class="n">requester</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">checksum</span> <span class="k">=</span> <span class="o">~(</span><span class="n">sum</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">requester</span> <span class="o">!</span> <span class="n">checksum</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ще одне узагальнення нічого не коштує: послідовність випадків дає вам <em>часткову функцію</em>. Якщо ви застосуєте таку функцію до значення, яке вона не підтримує, вона згенерує виключення часу виконання. Наприклад, ось часткова функція, що повертає другий елемент зі списку цілих:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Коли ви компілюєте це, компілятор буде коректно попереджати, що порівняння не є вичерпним:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>&lt;console&gt;:17: warning: match is not exhaustive!
missing combination
Nil</code></pre>
</div></div>
<div class="paragraph"><p>Ця функція буде успішною, якщо ви передасте список з трьох елементів, але ні, якщо ви передасте порожній список:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">))</span>
<span class="n">res24</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="n">scala</span><span class="o">.</span><span class="nc">MatchError</span><span class="k">:</span> <span class="kt">List</span><span class="o">()</span>
      <span class="kt">at</span> <span class="kt">$anonfun$1.apply</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">17</span><span class="o">)</span>
      <span class="kt">at</span> <span class="kt">$anonfun$1.apply</span><span class="o">(</span><span class="kt">&lt;console</span><span class="k">&gt;:</span><span class="err">17</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви бажаєте перевірити, чи часткова функція визначена, ви повинні спочатку сказати компілятору, що ви знаєте, що робите з частковими функціями. Тип <code>List[Int] =&gt; Int</code> включають всі функції зі списків цілих до цілих, чи є вони частковими, чи ні. Тип, що включає тільки часткові функції з масива цілих до цілих, записується <code>PartialFunction[List[Int],Int]</code>. Ось знову друга функція, на цей раз написана як тип часткової функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>,<span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Часткові функції мають метод <code>isDefinedAt</code>, що може бути використана для тестування, чи функція визначена на певному значенні. В цьому випадку функція визначена для кожного списку, що мають щонайменше два елементу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">,</span><span class="mi">7</span><span class="o">))</span>
<span class="n">res30</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
<span class="n">res31</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Типовий приклад часткової функції є функціональний літерал порівняння шаблону, як той з попереднього прикладу. Фактично, такий вираз транслюється компілятором Scala на часткову функцію, через транслювання шаблону двічі — один раз для реалізації справжньої функції, та ще раз, щоб перевірити, чи функція визначена, чи ні.</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
Наприклад, функціональний літерал `{ case x :: y 
</dt>
<dd>
<p>
_ &#8658; y }` буде трансльований до наступного значення часткової функції:
</p>
</dd>
</dl></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">isDefinedAt</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця трансляція набуває ефекту, кожного разу, коли декларований тип функціонального літералу є <code>PartialFunction</code>. Якщо декларований тип є тільки <code>Function1</code>, або він відсутній, функціональний літерал замість цього транслюється до повної функції.</p></div>
<div class="paragraph"><p>Загалом, ви повинні намагатись робити з повними функціями, коли це можливо, оскільки використання часткових функцій дозволяє помилки часу виконання, з якими компілятор не може вам допомогти. З іншого боку, часткові функції часом дійсно корисні. Ви можете бути впевнені, що необроблене значення ніколи не буде надане. Альтернативно, ви можете використовувати фреймворк, що отримує часткові функції, і, таким чином, завжди буде перевіряти <code>isDefinedAt</code> перед викликом функції. Приклад останнього є приклад <code>receive</code>, наданий вище, де аргумент є частково визначеною функцією, визначена в точності для тих повідомлень, що викликаючий бажає обробити.</p></div>
</div>
<div class="sect2">
<h3 id="___code_for_code_">Шаблони в <code>for</code> виразах</h3>
<div class="paragraph"><p>Ви також можете використовувати шаблон в <code>for</code> виразі, як показано в Лістингу 15.18. Цей <code>for</code> вираз отримує пари ключ/значення мапи <code>capitals</code>. Кожна пара порівнюється з шаблоном <code>(country, city)</code>, що визначає дві змінні, <code>country</code> та <code>city</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">((</span><span class="n">country</span><span class="o">,</span> <span class="n">city</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">capitals</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="s">&quot;The capital of &quot;</span> <span class="o">+</span> <span class="n">country</span> <span class="o">+</span> <span class="s">&quot; is &quot;</span> <span class="o">+</span> <span class="n">city</span><span class="o">)</span>
<span class="nc">The</span> <span class="n">capital</span> <span class="n">of</span> <span class="nc">France</span> <span class="n">is</span> <span class="nc">Paris</span>
<span class="nc">The</span> <span class="n">capital</span> <span class="n">of</span> <span class="nc">Japan</span> <span class="n">is</span> <span class="nc">Tokyo</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.18 - Вираз <code>for</code> з шаблоном таплом.</p></div>
<div class="paragraph"><p>Шаблон пари, показаний в Лістингу 15.18 був особливий, оскільки порівняння з ним ніколи не може схибити. Зрозуміло, що <code>capitals</code> видає послідовність пар, так що ви можете бути певні, що кожна згенерована пара може бути порівняна з шаблоном пари. Але так само можливо, що шаблон може не співпасти зі згенерованим значенням. Лістинг 15.19 показує приклад, де відбувається саме це.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="s">&quot;apple&quot;</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;orange&quot;</span><span class="o">))</span>
<span class="n">results</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">apple</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="n">orange</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">results</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span>
<span class="n">apple</span>
<span class="n">orange</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.19 - Обирання елементів списку, що співпадають з шаблоном.</p></div>
<div class="paragraph"><p>Як ви можете бачити з цього прикладу, згенеровані значення, що не співпадають з шаблоном, будуть відкинуті. Наприклад, другий елемент <code>None</code> є результатом списку, що не співпадає з шаблоном <code>Some(fruit)</code>; таким чином, він не показаний на виході.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_15_8__">15.8 Більший приклад</h2>
<div class="sectionbody">
<div class="paragraph"><p>Після навчання різним формам шаблонів, ви можете бути зацікавлені побачити їх застосування в більшому прикладі. Запропоноване завдання є написати клас форматування виразів, що відображує арифметичні вирази в двомірному розташуванні. Ділення, такі як <code>x / (x + 1)</code> має друкуватись вертикально, через розташування чисельника зверху займенника, ось так:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   x
 -----
 x + 1</code></pre>
</div></div>
<div class="paragraph"><p>Як інший приклад, ось приклад <code>((a / (b * c) + 1 / n) / 3)</code> в двовимірному розташуванні:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>   a     1
 ----- + -
 b * c   n
 ---------
     3</code></pre>
</div></div>
<div class="paragraph"><p>З ціх прикладів виглядає, що клас (назвемо його <code>ExprFormatter</code>) буде мати справу з жонглюванням розміткою, так що має сенс використовувати бібліотеку розташування, розроблену в Главі 10. Ми також будемо використовувати сімейство кейс класів <code>Expr</code>, який ми бачили раніше в цій главі, та покладемо обоє, бібліотеку розташування з Глави 10 та форматування виразів з цієї глави в іменовані пакунки. Повний код приклада буде показаний в Лістингу 15.20 та 15.21.</p></div>
<div class="paragraph"><p>Корисний перший крок є концентрація на горизонтальному розташуванні. Стуруктурований вираз, як:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>BinOp("+",
  BinOp("*",
    BinOp("+", Var("x"), Var("y")),
      Var("z")),
  Number(1))</code></pre>
</div></div>
<div class="paragraph"><p>має друкувати <code>(x + y) * z + 1</code>. Зауважте, що дужки необхідні навколо <code>x + y</code>, але можуть бути опціональними навколо <code>(x + y) * z</code>. Щоб утримувати розташування як можливо стислішим, вашею ціллю має бути уникати дужок, коли вони надлишкові, при цьому переконавшись, що всі потрібні дужки присутні.</p></div>
<div class="paragraph"><p>Щоб знати, де треба поставити дужки, код має знати щодо відносних преоритетов кожного оператора, так що є гарною ідеєю спочатку поладнати це. Ви можете виразити відносні преоритети напряму, як літеральна мапа наступної форми:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Map</span><span class="o">(</span>
  <span class="s">&quot;|&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="s">&quot;||&quot;</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span>
  <span class="s">&quot;&amp;&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">&quot;&amp;&amp;&quot;</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="o">...</span>
<span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Однак це може включати деяку кількість обчислень преоритетов з вашого боку. Більш зручний підхід є просте визначення груп операторів зі збільшенням преоритетів, та потім обчислювати преоритети кожного оператора на цій основі. Лістинг 15.20 показує код.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">org.stairwaybook.expr</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.layout.Element.elem</span>

<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span>
    <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>

<span class="k">class</span> <span class="nc">ExprFormatter</span> <span class="o">{</span>
<span class="c1">// Містить оператори в групах за збільшенням преоритету</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">opGroups</span> <span class="k">=</span>
    <span class="nc">Array</span><span class="o">(</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;|&quot;</span><span class="o">,</span> <span class="s">&quot;||&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;&amp;&quot;</span><span class="o">,</span> <span class="s">&quot;&amp;&amp;&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;^&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;==&quot;</span><span class="o">,</span> <span class="s">&quot;!=&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;&lt;&quot;</span><span class="o">,</span> <span class="s">&quot;&lt;=&quot;</span><span class="o">,</span> <span class="s">&quot;&gt;&quot;</span><span class="o">,</span> <span class="s">&quot;&gt;=&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="s">&quot;-&quot;</span><span class="o">),</span>
      <span class="nc">Set</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="s">&quot;%&quot;</span><span class="o">)</span>
    <span class="o">)</span>
<span class="c1">// Відзеркалення операторів на їх преоритети</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">precedence</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">assocs</span> <span class="k">=</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">opGroups</span><span class="o">.</span><span class="n">length</span>
        <span class="n">op</span> <span class="k">&lt;-</span> <span class="n">opGroups</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">op</span> <span class="o">-&gt;</span> <span class="n">i</span>
    <span class="n">assocs</span><span class="o">.</span><span class="n">toMap</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">val</span> <span class="n">unaryPrecedence</span> <span class="k">=</span> <span class="n">opGroups</span><span class="o">.</span><span class="n">length</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">fractionPrecedence</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">// продовження в Лістингу 15.21...</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.20 - Верхня частина форматувальника виразів.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// ...продовження Лістингу 15.20</span>
<span class="k">import</span> <span class="nn">org.stairwaybook.layout.Element</span>

<span class="k">private</span> <span class="k">def</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">enclPrec</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">def</span> <span class="n">stripDot</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="n">endsWith</span> <span class="s">&quot;.0&quot;</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">s</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">stripDot</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>

    <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="n">elem</span><span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="n">beside</span> <span class="n">format</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">unaryPrecedence</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">top</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">bot</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">frac</span> <span class="k">=</span> <span class="n">top</span> <span class="n">above</span> <span class="n">line</span> <span class="n">above</span> <span class="n">bot</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">!=</span> <span class="n">fractionPrecedence</span><span class="o">)</span> <span class="n">frac</span>
      <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">frac</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>

    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">opPrec</span> <span class="k">=</span> <span class="n">precedence</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">opPrec</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">opPrec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
      <span class="k">val</span> <span class="n">oper</span> <span class="k">=</span> <span class="n">l</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">r</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">&lt;=</span> <span class="n">opPrec</span><span class="o">)</span> <span class="n">oper</span>
      <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">oper</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;)&quot;</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span> <span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.21 - Нижня частина форматувальника виразів.</p></div>
<div class="paragraph"><p>Змінна <code>precedence</code> є мапою від операторів на їх преоритети, що є цілими, починаючи з 0. Вони обчислюються в виразі <code>for</code> з двома генераторами. Перший генератор продукує кожний індекс <code>i</code> для масиву <code>opGroups</code>. Другий генератор продукує кожний оператор <code>op</code> в <code>opGroups(i)</code>. Для кожного такого оператора вираз <code>for`видає асоціацію від оператора `op</code> на його індекс <code>i</code>. Таким чином, відносна позиція оператора в масиві береться як його преоритет.</p></div>
<div class="paragraph"><p>Асоціації записані як інфіксна стрілка, <code>op -&gt; i</code>. Так що ви бачите асоціації тільки як частину конструкції мапи, але вони також є значеннями сами по собі. Фактично, асоціація <code>op -&gt; i</code> є нічим іншим, ніж парою <code>(op, i)</code>.</p></div>
<div class="paragraph"><p>Тепер, коли ви поладнали преоритети всіх двомісних операторів, крім <code>/</code>, має сенс узагальнити цю концепцію, що також покриває одномісні оператори. Преоритети одномісних операторів вищі, ніж преоритет кожного двомісного оператора. Таким чином ми можете встановити <code>unaryPrecedence</code> (показане в Лістингу 15.20) в довжину масива <code>opGroups</code>,що на один більше, ніж преоритет операторів <code>*</code> та <code>%</code>. Преоритет дробі трактується інакше від інших операторів, оскількі дріб використовує вертикальне розташування. Однак, це буде зручним, присвоїти оператору ділення особливий преоритет зі значенням -1, так що ми будемо ініціалізувати <code>fractionPrecedence</code> в -1 (показане в Лістингу 15.20).</p></div>
<div class="paragraph"><p>Після ціх підготувань ви готові написати головний метод форматування. Цей метод приймає два аргумента: вираз <code>e</code>, типу <code>Expr</code>, та преоритет <code>enclPrec</code> оператора напряму оточуючого виразу <code>e</code>. (Якщо нема оточуючого оператора, <code>enclPrec</code> повинне бути нулем). Метод видає елемент розташування, що представляє двомірний масив символів.</p></div>
<div class="paragraph"><p>Лістинг 15.21 показує залишок класу <code>ExprFormatter</code>, що включає три метода. Перший метод, <code>stripDot</code>, є допоміжним методом. Наступний метод, приватний метод <code>format</code>, робить більшість роботи по форматуванню виразів. Останній метод, також названий <code>format</code>, є єдиним публічним методом в бібліотеці, що приймає вираз, який треба форматувати. Приватний метод <code>format</code> робить свою роботу, виконуючи порівняння шаблонів на різновиді виразу. Вираз <code>match</code> має п'ять випадків <code>case</code>. Ми обговоримо кожний <code>case</code> окремо.</p></div>
<div class="paragraph"><p>Перший case є:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є змінна, результат є елементом, сформованим з імені змінної.</p></div>
<div class="paragraph"><p>Другмй вираз є:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">def</span> <span class="n">stripDot</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="n">endsWith</span> <span class="s">&quot;.0&quot;</span><span class="o">)</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">2</span><span class="o">)</span>
    <span class="k">else</span> <span class="n">s</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">stripDot</span><span class="o">(</span><span class="n">num</span><span class="o">.</span><span class="n">toString</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є числом, результат є елементом, сформованим зі значення числа. Функція <code>stripDot</code> очищує вигляд чисел з плаваючою крапкою, відкидаючи любі суфікси <code>".0"</code> з рядка.</p></div>
<div class="paragraph"><p>Третій випадок наступний:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">arg</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="n">elem</span><span class="o">(</span><span class="n">op</span><span class="o">)</span> <span class="n">beside</span> <span class="n">format</span><span class="o">(</span><span class="n">arg</span><span class="o">,</span> <span class="n">unaryPrecedence</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є одномісною операцією <code>UnOp(op, arg)</code>, результатом буде сформований з операнда <code>op</code> та результата форматування аргумента <code>arg</code> з найвищим-можливим преоритетом оточення.<span class="footnote"><br />[Значення <code>unaryPrecedence</code> є найвищим можливим преоритетом, оскільки він ініціалізований на один більше, ніж преоритет операторів <code>*</code> та <code>%</code>.]<br /></span></p></div>
<div class="paragraph"><p>Це означає, що якщо <code>arg</code> є двомісною операцією (але не дрібом), вона завжди буде відображатись в дужках.</p></div>
<div class="paragraph"><p>Четвертий випадок <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">top</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">bot</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">fractionPrecedence</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">line</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">&#39;-&#39;</span><span class="o">,</span> <span class="n">top</span><span class="o">.</span><span class="n">width</span> <span class="n">max</span> <span class="n">bot</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">frac</span> <span class="k">=</span> <span class="n">top</span> <span class="n">above</span> <span class="n">line</span> <span class="n">above</span> <span class="n">bot</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">!=</span> <span class="n">fractionPrecedence</span><span class="o">)</span> <span class="n">frac</span>
  <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">frac</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо вираз є дробом, проміжний результат <code>frac</code> формується через розміщення форматованих операндів <code>left</code> та <code>right</code> зверху один одного, розділені елементом горизонтальної лінії. Ширина <code>width</code> горизонтальної лінії є максимум з ширин форматованих операндів. Цей проміжний результат є також фінальним результатом, тільки якщо дріб сам не з'являється як аргумент в іншій дробі. В останньому випадку з кожного боку <code>frac</code> додаються проміжки. Щоб зрозуміти чому, розглянемо вираз <code>(a / b) / c</code>.</p></div>
<div class="paragraph"><p>Без корекції ширини форматування цього виразу буде давати:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> a
 -
 b
 -
 c</code></pre>
</div></div>
<div class="paragraph"><p>Пробелма з таким форматуванням є доказ — незрозуміло, де є риска вищого рівня. Вираз вище може означати або <code>(a / b) / c</code>, або <code>a / (b / c)</code>. Щоб вирішити неоднозначність, треба додати проміжки до кожної сторони розташування вкладеного дробу <code>a / b</code>. Тоді розташування стає однозначним:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>  a
  -
  b
 ---
  c</code></pre>
</div></div>
<div class="paragraph"><p>П'ятий, та останній, <code>case</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span>
  <span class="k">val</span> <span class="n">opPrec</span> <span class="k">=</span> <span class="n">precedence</span><span class="o">(</span><span class="n">op</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">opPrec</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">r</span> <span class="k">=</span> <span class="n">format</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">opPrec</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">oper</span> <span class="k">=</span> <span class="n">l</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot; &quot;</span> <span class="o">+</span> <span class="n">op</span> <span class="o">+</span> <span class="s">&quot; &quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">r</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">enclPrec</span> <span class="o">&lt;=</span> <span class="n">opPrec</span><span class="o">)</span> <span class="n">oper</span>
  <span class="k">else</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;(&quot;</span><span class="o">)</span> <span class="n">beside</span> <span class="n">oper</span> <span class="n">beside</span> <span class="n">elem</span><span class="o">(</span><span class="s">&quot;)&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей випадок стосується всіх інших двомісних операндів. Оскільки він іде після випадку, що починається як:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>ви знаєте, що оператор <code>op</code> в шаблоні <code>BinOp(op, left, right)</code> не може бути діленням. Щоб форматувати таку двомісну операцію, вам знадобиться спочатку форматувати її операнди <code>left</code> та <code>right</code>. Параметр преоритету для форматування лівого операнда є преоритет <code>opPrec</code> оператора <code>op</code>, тоді як для правого операнда він на один більше. Така схема гарантує, що дужки також відображають коректну асоциативність.</p></div>
<div class="paragraph"><p>Наприклад, операція:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">),</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;-&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">)))</span>
</pre></div></div></div>
<div class="paragraph"><p>буде коректно оточена дужками, як "a - (b - c)". Проміжний результат <code>oper</code> потім формується через розміщення форматованих операндів <code>left</code> та <code>right</code> поряд, розділених оператором. Якщо преоритет поточного оператора менше, ніж преоритет оточуючого оператора, <code>oper</code> покладається між дужками; інакше він повертається як є.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">org.stairwaybook.expr._</span>

<span class="k">object</span> <span class="nc">Express</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>

  <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ExprFormatter</span>

  <span class="k">val</span> <span class="n">e1</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;*&quot;</span><span class="o">,</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span>
                      <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">)))</span>

  <span class="k">val</span> <span class="n">e2</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;+&quot;</span><span class="o">,</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">)),</span>
                      <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mf">1.5</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)))</span>

  <span class="k">val</span> <span class="n">e3</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">&quot;/&quot;</span><span class="o">,</span> <span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">println</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">format</span><span class="o">(</span><span class="n">e</span><span class="o">)+</span> <span class="s">&quot;\n\n&quot;</span><span class="o">)</span>

  <span class="k">for</span> <span class="o">(</span><span class="n">e</span> <span class="k">&lt;-</span> <span class="nc">Array</span><span class="o">(</span><span class="n">e1</span><span class="o">,</span> <span class="n">e2</span><span class="o">,</span> <span class="n">e3</span><span class="o">))</span> <span class="n">show</span><span class="o">(</span><span class="n">e</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 15.22 - Застосування, що друкує форматовані вирази.</p></div>
<div class="paragraph"><p>Це завершує розробку приватної функції <code>format</code>. Єдиний залишений метод є публічний метод <code>format</code>, що дозволяє програмістам клієнтів форматувати високорівневі вирази, не передаючи аргумент преоритетів. Лістинг 15.22 показує демо програму, що випробовує <code>ExprFormatter</code>.</p></div>
<div class="paragraph"><p>Зауважте, що навіть хоча ця програма не містить метод, вона все ще виконується, оскільки вона наслідує від трейту App. Ви можете виконувати програму <code>Express</code> такою командою:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span> <span class="nc">Express</span>
</pre></div></div></div>
<div class="paragraph"><p>Це буде тавати наступний вивід:</p></div>
<div class="listingblock">
<div class="content">
<pre><code> 1
 - * (x + 1)
 2

 x   1.5
 - + ---
 2    x

  1
  - * (x + 1)
  2
 -----------
   x   1.5
   - + ---
   2    x</code></pre>
</div></div>
</div>
</div>
<div class="sect1">
<h2 id="_15_9_">15.9 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви детально навчились щодо кейс класів та порівняння шаблонів. Використовуючи це, ви можете отримати переваги від декількох стислих ідіом, звичайно недоступних в об'єктно-орієнтовних мовах. Однак порівняння шаблонів в Scala іде далі, ніж описане в цій главі. Якщо ви бажаєте використати порівняння шаблонів на одному з ваших класів, але ви не бажаєте відкривати доступ до ваших класів в спосіб, як це роблять кейс класи, ви можете використовувати екстрактори, описані в Главі 26. В наступній главі ми звернемо нашу увагу на списки.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-24 05:34:52 EET
</div>
</div>
</body>
</html>
