<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__15">Глава 15</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_____">Кейс класи та співпадіння шаблонів</h1>
<div class="paragraph"><p>This chapter introduces case classes and pattern matching, twin constructs that support you when
writing regular, non-encapsulated data structures. These two constructs are particularly helpful for tree-
like recursive data.
If you have programmed in a functional language before, then you will probably recognize pattern
matching. But case classes will be new to you. Case classes are Scala&#8217;s way to allow pattern matching
on objects without requiring a large amount of boilerplate. Generally, all you need to do is add a
single case keyword to each class that you want to be pattern matchable.
This chapter starts with a simple example of case classes and pattern matching. It then goes through all
of the kinds of patterns that are supported, talks about the role of sealed classes, discusses
the Option type, and shows some non-obvious places in the language where pattern matching is used.
Finally, a larger, more realistic example of pattern matching is shown.
15.1 A SIMPLE EXAMPLE
Before delving into all the rules and nuances of pattern matching, it is worth looking at a simple
example to get the general idea. Let&#8217;s say you need to write a library that manipulates arithmetic
expressions, perhaps as part of a domain-specific language you are designing.
A first step to tackling this problem is the definition of the input data. To keep things simple, we&#8217;ll
concentrate on arithmetic expressions consisting of variables, numbers, and unary and binary
operations. This is expressed by the hierarchy of Scala classes shown in Listing 15.1.
abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
left: Expr, right: Expr) extends Expr
Listing 15.1 - Defining case classes.
The hierarchy includes an abstract base class Expr with four subclasses, one for each kind of
expression being considered.<span class="footnote"><br />[Instead of an abstract class, we could have also chosen to model the root of that class hierarchy as a
trait. Modeling it as an abstract class may be slightly more efficient.]<br /></span> The bodies of all five classes are empty. As mentioned previously, in
Scala you can leave out the braces around an empty class body if you wish, soclass C is the same
as class C {}.
Case classes
The other noteworthy thing about the declarations of Listing 15.1 is that each subclass
has acase modifier. Classes with such a modifier are called case classes. Using the modifier makes the
Scala compiler add some syntactic conveniences to your class.First, it adds a factory method with the name of the class. This means that, for instance, you can
write Var("x") to construct a Var object, instead of the slightly longer new Var("x"):
scala&gt; val v = Var("x")
v: Var = Var(x)
The factory methods are particularly nice when you nest them. Because there are no
noisy newkeywords sprinkled throughout the code, you can take in the expression&#8217;s structure at a
glance:
scala&gt; val op = BinOp("<code>", Number(1), v)
op: BinOp = BinOp(</code>,Number(1.0),Var(x))
The second syntactic convenience is that all arguments in the parameter list of a case class implicitly
get a val prefix, so they are maintained as fields:
scala&gt; v.name
res0: String = x
scala&gt; op.left
res1: Expr = Number(1.0)
Third, the compiler adds "natural" implementations of methods toString, hashCode, and equalsto your
class. They will print, hash, and compare a whole tree consisting of the class and (recursively) all its
arguments. Since == in Scala always delegates to equals, this means that elements of case classes are
always compared structurally:
scala&gt; println(op)
BinOp(<code>,Number(1.0),Var(x))
scala&gt; op.right == Var("x")
res3: Boolean = true
Finally, the compiler adds a copy method to your class for making modified copies. This method is
useful for making a new instance of the class that is the same as another one except that one or two
attributes are different. The method works by using named and default parameters (see Section 8.8).
You specify the changes you&#8217;d like to make by using named parameters. For any parameter you don&#8217;t
specify, the value from the old object is used. As an example, here is how you can make an operation
just like op except that the operator has changed:
scala&gt; op.copy(operator = "-")
res4: BinOp = BinOp(-,Number(1.0),Var(x))
All these conventions add a lot of convenience—at a small price. You have to write the case modifier,
and your classes and objects become a bit larger. They are larger because additional methods are
generated and an implicit field is added for each constructor parameter. However, the biggest advantage
of case classes is that they support pattern matching.Pattern matching
Say you want to simplify arithmetic expressions of the kinds just presented. There is a multitude of
possible simplification rules. The following three rules just serve as an illustration:
UnOp("-", UnOp("-", null)) &#8658; null
BinOp("</code>", null, Number(0)) &#8658; null
BinOp("<strong>", null, Number(1)) &#8658; null



Using pattern matching, these rules can be taken almost as they are to form the core of a simplification
function in Scala, as shown in Listing 15.2. The function, simplifyTop, can be used like this:
scala&gt; simplifyTop(UnOp("-", UnOp("-", Var("x"))))
res4: Expr = Var(x)
def simplifyTop(expr: Expr): Expr = expr match {
case UnOp("-", UnOp("-", e)) &#8658; e

case BinOp("<code>", e, Number(0)) &#8658; e

case BinOp("</strong>", e, Number(1)) &#8658; e

case _ &#8658; expr
}
Listing 15.2 - The simplifyTop function, which does a pattern match.
The right-hand side of simplifyTop consists of a match expression. match corresponds to switch in
Java, but it&#8217;s written after the selector expression. In other words, it&#8217;s:
selector match { alternatives }
instead of:
switch (selector) { alternatives }
A pattern match includes a sequence of alternatives, each starting with the keyword case. Each
alternative includes a pattern and one or more expressions, which will be evaluated if the pattern
matches. An arrow symbol &#8658; separates the pattern from the expressions.
A match expression is evaluated by trying each of the patterns in the order they are written. The first
pattern that matches is selected, and the part following the arrow is selected and executed.
A constant pattern like "</code>" or 1 matches values that are equal to the constant with respect to==.
A variable pattern like e matches every value. The variable then refers to that value in the right hand
side of the case clause. In this example, note that the first three alternatives evaluate to e, a variable that
is bound within the associated pattern. The wildcard pattern (<em>) also matches every value, but it does
not introduce a variable name to refer to that value. InListing 15.2, notice how the match ends with a
default case that does nothing to the expression. Instead, it just results in expr, the expression matched
upon.
A constructor pattern looks like UnOp("-", e). This pattern matches all values of type UnOpwhose first
argument matches "-" and whose second argument matches e. Note that the arguments to theconstructor are themselves patterns. This allows you to write deep patterns using a concise notation.
Here&#8217;s an example:
UnOp("-", UnOp("-", e))
Imagine trying to implement this same functionality using the visitor design pattern!<span class="footnote"><br />[Gamma, et. al., Design Patterns [Gam95]]<br /></span>Almost as
awkward, imagine implementing it as a long sequence of if statements, type tests, and type casts.
match compared to switch
Match expressions can be seen as a generalization of Java-style switches. A Java-style switchcan be
naturally expressed as a match expression, where each pattern is a constant and the last pattern may be
a wildcard (which represents the default case of the switch).
However, there are three differences to keep in mind: First, match is an expression in Scala (i.e., it
always results in a value). Second, Scala&#8217;s alternative expressions never "fall through" into the next
case. Third, if none of the patterns match, an exception named MatchError is thrown. This means you
always have to make sure that all cases are covered, even if it means adding a default case where there&#8217;s
nothing to do.
expr match {
case BinOp(op, left, right) &#8658;
println(expr + " is a binary operation")
case _ &#8658;
}
Listing 15.3 - A pattern match with an empty "default" case.
Listing 15.3 shows an example. The second case is necessary because without it, the matchexpression
would throw a MatchError for every expr argument that is not a BinOp. In this example, no code is
specified for that second case, so if that case runs it does nothing. The result of either case is the unit
value <code>()', which is also the result of the entire matchexpression.
15.2 KINDS OF PATTERNS
The previous example showed several kinds of patterns in quick succession. Now take a minute to look
at each pattern in detail.
The syntax of patterns is easy, so do not worry about that too much. All patterns look exactly like the
corresponding expression. For instance, given the hierarchy of Listing 15.1, the pattern Var(x) matches
any variable expression, binding x to the name of the variable. Used as an expression, Var(x)—exactly
the same syntax—recreates an equivalent object, assuming x is already bound to the variable's name.
Since the syntax of patterns is so transparent, the main thing to pay attention to is just what kinds of
patterns are possible.
Wildcard patterns
The wildcard pattern (_) matches any object whatsoever. You have already seen it used as a default,
catch-all alternative, like this:expr match {
case BinOp(op, left, right) =&gt;
println(expr + " is a binary operation")
case _ =&gt; // handle the default case
}
Wildcards can also be used to ignore parts of an object that you do not care about. For example, the
previous example does not actually care what the elements of a binary operation are; it just checks
whether or not it is a binary operation. Thus, the code can just as well use the wildcard pattern for the
elements of the BinOp, as shown in Listing 15.4.
expr match {
case BinOp(_, _, _) =&gt; println(expr + " is a binary operation")
case _ =&gt; println("It's something else")
}
Listing 15.4 - A pattern match with wildcard patterns.
Constant patterns
A constant pattern matches only itself. Any literal may be used as a constant. For example, 5,true,
and "hello" are all constant patterns. Also, any val or singleton object can be used as a constant. For
example, Nil, a singleton object, is a pattern that matches only the empty list.Listing 15.5 shows some
examples of constant patterns:
def describe(x: Any) = x match {
case 5 =&gt; "five"
case true =&gt; "truth"
case "hello" =&gt; "hi!"
case Nil =&gt; "the empty list"
case _ =&gt; "something else"
}
Listing 15.5 - A pattern match with constant patterns.
Here is how the pattern match shown in Listing 15.5 looks in action:
scala&gt; describe(5)
res6: String = five
scala&gt; describe(true)
res7: String = truth
scala&gt; describe("hello")
res8: String = hi!
scala&gt; describe(Nil)
res9: String = the empty list
scala&gt; describe(List(1,2,3))
res10: String = something elseVariable patterns
A variable pattern matches any object, just like a wildcard. But unlike a wildcard, Scala binds the
variable to whatever the object is. You can then use this variable to act on the object further. For
example, Listing 15.6 shows a pattern match that has a special case for zero, and a default case for all
other values. The default case uses a variable pattern so that it has a name for the value, no matter what
it is.
expr match {
case 0 =&gt; "zero"
case somethingElse =&gt; "not zero: " + somethingElse
}
Listing 15.6 - A pattern match with a variable pattern.
Variable or constant?
Constant patterns can have symbolic names. You saw this already when we used Nil as a pattern. Here
is a related example, where a pattern match involves the constants E(2.71828...) and Pi (3.14159...):
scala&gt; import math.{E, Pi}
import math.{E, Pi}
scala&gt; E match {
case Pi =&gt; "strange math? Pi = " + Pi
case _ =&gt; "OK"
}
res11: String = OK
As expected, E does not match Pi, so the "strange math" case is not used.
How does the Scala compiler know that Pi is a constant imported from scala.math, and not a variable
that stands for the selector value itself? Scala uses a simple lexical rule for disambiguation: a simple
name starting with a lowercase letter is taken to be a pattern variable; all other references are taken to
be constants. To see the difference, create a lowercase alias for pi and try with that:
scala&gt; val pi = math.Pi
pi: Double = 3.141592653589793
scala&gt; E match {
case pi =&gt; "strange math? Pi = " + pi
}
res12: String = strange math? Pi = 2.718281828459045
Here the compiler will not even let you add a default case at all. Since pi is a variable pattern, it will
match all inputs, and so no cases following it can be reached:
scala&gt; E match {
case pi =&gt; "strange math? Pi = " + pi
case _ =&gt; "OK"
}
&lt;console&gt;:12: warning: unreachable code
case _ =&gt; "OK"
^You can still use a lowercase name for a pattern constant, if you need to, by using one of two tricks.
First, if the constant is a field of some object, you can prefix it with a qualifier. For instance, pi is a
variable pattern, but this.pi or obj.pi are constants even though they start with lowercase letters. If that
does not work (because pi is a local variable, say), you can alternatively enclose the variable name in
back ticks. For instance, `pi</code> would again be interpreted as a constant, not as a variable:
scala&gt; E match {
case <code>pi</code> &#8658; "strange math? Pi = " + pi
case _ &#8658; "OK"
}
res14: String = OK
As you can see, the back-tick syntax for identifiers is used for two different purposes in Scala to help
you code your way out of unusual circumstances. Here you see that it can be used to treat a lowercase
identifier as a constant in a pattern match. Earlier on, in Section 6.10, you saw that it can also be used
to treat a keyword as an ordinary identifier, e.g., writingThread.<code>yield</code>() treats yield as an identifier
rather than a keyword.
Constructor patterns
Constructors are where pattern matching becomes really powerful. A constructor pattern looks like
"BinOp("<code>", e, Number(0))". It consists of a name (BinOp) and then a number of patterns within
parentheses: "</code>", e, and Number(0). Assuming the name designates a case class, such a pattern means
to first check that the object is a member of the named case class, and then to check that the constructor
parameters of the object match the extra patterns supplied.
These extra patterns mean that Scala patterns support deep matches. Such patterns not only check the
top-level object supplied, but also the contents of the object against further patterns. Since the extra
patterns can themselves be constructor patterns, you can use them to check arbitrarily deep into an
object. For example, the pattern shown in Listing 15.7 checks that the top-level object is a BinOp, that
its third constructor parameter is a Number, and that the value field of that number is 0. This pattern is
one line long yet checks three levels deep.
expr match {
case BinOp("<code>", e, Number(0)) &#8658; println("a deep match")
case _ &#8658;
}
Listing 15.7 - A pattern match with a constructor pattern.
Sequence patterns
You can match against sequence types, like List or Array, just like you match against case classes. Use
the same syntax, but now you can specify any number of elements within the pattern. Listing
15.8 shows a pattern that checks for a three-element list starting with zero.
expr match {
case List(0, _, _) &#8658; println("found it")
case _ &#8658;}
Listing 15.8 - A sequence pattern with a fixed length.
If you want to match against a sequence without specifying how long it can be, you can specify _* as
the last element of the pattern. This funny-looking pattern matches any number of elements within a
sequence, including zero elements. Listing 15.9 shows an example that matches any list that starts with
zero, regardless of how long the list is.
expr match {
case List(0, _*) &#8658; println("found it")
case _ &#8658;
}
Listing 15.9 - A sequence pattern with an arbitrary length.
Tuple patterns
You can match against tuples too. A pattern like (a, b, c) matches an arbitrary 3-tuple. An example is
shown in Listing 15.10.
def tupleDemo(expr: Any) =
expr match {
case (a, b, c) &#8658; println("matched " + a + b + c)
case _ &#8658;
}
Listing 15.10 - A pattern match with a tuple pattern.
If you load the tupleDemo method shown in Listing 15.10 into the interpreter, and pass to it a tuple
with three elements, you&#8217;ll see:
scala&gt; tupleDemoa 
matched a 3-tuple
Typed patterns
You can use a typed pattern as a convenient replacement for type tests and type casts. Listing
15.11 shows an example.
def generalSize(x: Any) = x match {
case s: String &#8658; s.length
case m: Map[</em>, <em>] &#8658; m.size
case _ &#8658; -1
}
Listing 15.11 - A pattern match with typed patterns.
Here are a few examples of using generalSize in the Scala interpreter:
scala&gt; generalSize("abc")
res16: Int = 3
scala&gt; generalSize(Map(1 &#8594; <em>a</em>, 2 &#8594; <em>b</em>))
res17: Int = 2scala&gt; generalSize(math.Pi)
res18: Int = -1
The generalSize method returns the size or length of objects of various types. Its argument is of
type Any, so it could be any value. If the argument is a String, the method returns the string&#8217;s length.
The pattern "s: String" is a typed pattern; it matches every (non-null) instance ofString. The pattern
variable s then refers to that string.
Note that even though s and x refer to the same value, the type of x is Any, while the type of s isString.
So you can write s.length in the alternative expression that corresponds to the pattern, but you could not
write x.length, because the type Any does not have a length member. An equivalent but more long-
winded way that achieves the effect of a match against a typed pattern employs a type test followed by
a type cast. Scala uses a different syntax than Java for these. To test whether an expression expr has
type String, say, you write:
expr.isInstanceOf[String]
To cast the same expression to type String, you use:
expr.asInstanceOf[String]
Using a type test and cast, you could rewrite the first case of the previous match expression as shown
in Listing 15.12.
if (x.isInstanceOf[String]) {
val s = x.asInstanceOf[String]
s.length
} else &#8230;
Listing 15.12 - Using isInstanceOf and asInstanceOf (poor style).
The operators isInstanceOf and asInstanceOf are treated as predefined methods of class Any that take a
type parameter in square brackets. In fact, x.asInstanceOf[String] is a special case of a method
invocation with an explicit type parameter String.
As you will have noted by now, writing type tests and casts is rather verbose in Scala. That&#8217;s intentional
because it is not encouraged practice. You are usually better off using a pattern match with a typed
pattern. That&#8217;s particularly true if you need to do both a type test and a type cast, because both
operations are then rolled into a single pattern match.
The second case of the match expression in Listing 15.11 contains the typed pattern "m: Map[</em>, <em>]".
This pattern matches any value that is a Map of some arbitrary key and value types, and lets m refer to
that value. Therefore, m.size is well typed and returns the size of the map. The underscores in the type
pattern, <span class="footnote"><br />[In the typed pattern, m: Map[</em>, <em>]<br /></span>, the "Map[</em>, <em>]" portion is called a type pattern.] are like wildcards in other patterns. You could have also used (lowercase) type variables
instead.Type erasure
Can you also test for a map with specific element types? This would be handy, say, for testing whether
a given value is a map from type Int to type Int. Let&#8217;s try:
scala&gt; def isIntIntMap(x: Any) = x match {
case m: Map[Int, Int] &#8658; true
case _ &#8658; false
}
&lt;console&gt;:9: warning: non-variable type argument Int in type
pattern scala.collection.immutable.Map[Int,Int] (the
underlying of Map[Int,Int]) is unchecked since it is
eliminated by erasure
case m: Map[Int, Int] &#8658; true
<sup>
Scala uses the erasure model of generics, just like Java does. This means that no information about type
arguments is maintained at runtime. Consequently, there is no way to determine at runtime whether a
given Map object has been created with two Int arguments, rather than with arguments of different
types. All the system can do is determine that a value is a Map of some arbitrary type parameters. You
can verify this behavior by applying isIntIntMap to arguments of different instances of class Map:
scala&gt; isIntIntMap(Map(1 &#8594; 1))
res19: Boolean = true
scala&gt; isIntIntMap(Map("abc" &#8594; "abc"))
res20: Boolean = true
The first application returns true, which looks correct, but the second application also returnstrue,
which might be a surprise. To alert you to the possibly non-intuitive runtime behavior, the compiler
emits unchecked warnings like the one shown previously.
The only exception to the erasure rule is arrays, because they are handled specially in Java as well as in
Scala. The element type of an array is stored with the array value, so you can pattern match on it.
Here&#8217;s an example:
scala&gt; def isStringArray(x: Any) = x match {
case a: Array[String] &#8658; "yes"
case _ &#8658; "no"
}
isStringArray: (x: Any)String
scala&gt; val as = Array("abc")
as: Array[String] = Array(abc)
scala&gt; isStringArray(as)
res21: String = yes
scala&gt; val ai = Array(1, 2, 3)
ai: Array[Int] = Array(1, 2, 3)
scala&gt; isStringArray(ai)
res22: String = noVariable binding
In addition to the standalone variable patterns, you can also add a variable to any other pattern. You
simply write the variable name, an at sign (@), and then the pattern. This gives you a variable-binding
pattern, which means the pattern is to perform the pattern match as normal, and if the pattern succeeds,
set the variable to the matched object just as with a simple variable pattern.
As an example, Listing 15.13 shows a pattern match that looks for the absolute value operation being
applied twice in a row. Such an expression can be simplified to only take the absolute value one time.
expr match {
case UnOp("abs", e @ UnOp("abs", _)) &#8658; e
case _ &#8658;
}
Listing 15.13 - A pattern with a variable binding (via the @ sign).
The example shown in Listing 15.13 includes a variable-binding pattern with e as the variable
and UnOp("abs", _) as the pattern. If the entire pattern match succeeds, then the portion that matched
the UnOp("abs", _) part is made available as variable e. The result of the case is just e, because e has
the same value as expr but with one less absolute value operation.
15.3 PATTERN GUARDS
Sometimes, syntactic pattern matching is not precise enough. For instance, say you are given the task
of formulating a simplification rule that replaces sum expressions with two identical operands, such
as e + e, by multiplications of two (e.g., e * 2). In the language of Expr trees, an expression like:
BinOp("</code>", Var("x"), Var("x"))
would be transformed by this rule to:
BinOp("<strong>", Var("x"), Number(2))
You might try to define this rule as follows:
scala&gt; def simplifyAdd(e: Expr) =
case BinOp("<code>", x, x) &#8658;
case _ &#8658; e
}
&lt;console&gt;:14: error: x is already
case BinOp("</code>", x, x) &#8658;
</sup>
e match {
BinOp("</strong>", x, Number(2))
defined as value x
BinOp("<strong>", x, Number(2))
This fails because Scala restricts patterns to be linear: a pattern variable may only appear once in a
pattern. However, you can re-formulate the match with a pattern guard, as shown in Listing 15.14:
scala&gt; def simplifyAdd(e: Expr) = e match {
case BinOp("<code>", x, y) if x == y &#8658;
BinOp("</strong>", x, Number(2))
case _ &#8658; e
}
simplifyAdd: (e: Expr)ExprListing 15.14 - A match expression with a pattern guard.
A pattern guard comes after a pattern and starts with an if. The guard can be an arbitrary boolean
expression, which typically refers to variables in the pattern. If a pattern guard is present, the match
succeeds only if the guard evaluates to true. Hence, the first case above would only match binary
operations with two equal operands.
Some other examples of guarded patterns are:

case n: Int if 0 &lt; n &#8658; &#8230;

case s: String if s(0) == <em>a</em> &#8658; &#8230;
15.4 PATTERN OVERLAPS
Patterns are tried in the order in which they are written. The version of simplify shown inListing
15.15 presents an example where the order of the cases matters.
def simplifyAll(expr: Expr): Expr = expr match {
case UnOp("-", UnOp("-", e)) &#8658;
simplifyAll(e)

case BinOp("</code>", e, Number(0)) &#8658;
simplifyAll(e)

case BinOp("<strong>", e, Number(1)) &#8658;
simplifyAll(e)

case UnOp(op, e) &#8658;
UnOp(op, simplifyAll(e))
case BinOp(op, l, r) &#8658;
BinOp(op, simplifyAll(l), simplifyAll(r))
case _ &#8658; expr
}
Listing 15.15 - Match expression in which case order matters.
The version of simplify shown in Listing 15.15 will apply simplification rules everywhere in an
expression, not just at the top, as simplifyTop did. It can be derived from simplifyTop by adding two
more cases for general unary and binary expressions (cases four and five in Listing 15.15).
The fourth case has the pattern UnOp(op, e); i.e., it matches every unary operation. The operator and
operand of the unary operation can be arbitrary. They are bound to the pattern variables op and e,
respectively. The alternative in this case applies simplifyAll recursively to the operand e and then
rebuilds the same unary operation with the (possibly) simplified operand. The fifth case for BinOp is
analogous: it is a "catch-all" case for arbitrary binary operations, which recursively applies the
simplification method to its two operands.
In this example, it is important that the catch-all cases come after the more specific simplification rules.
If you wrote them in the other order, then the catch-all case would be run in favor of the more specific
rules. In many cases, the compiler will even complain if you try. For example, here&#8217;s
a match expression that won&#8217;t compile because the first case will match anything that would be
matched by the second case:scala&gt; def simplifyBad(expr: Expr): Expr = expr match {
case UnOp(op, e) &#8658; UnOp(op, simplifyBad(e))
case UnOp("-", UnOp("-", e)) &#8658; e
}
&lt;console&gt;:21: warning: unreachable code
case UnOp("-", UnOp("-", e)) &#8658; e
^
15.5 SEALED CLASSES
Whenever you write a pattern match, you need to make sure you have covered all of the possible cases.
Sometimes you can do this by adding a default case at the end of the match, but that only applies if
there is a sensible default behavior. What do you do if there is no default? How can you ever feel safe
that you covered all the cases?
You can enlist the help of the Scala compiler in detecting missing combinations of patterns in
a match expression. To do this, the compiler needs to be able to tell which are the possible cases. In
general, this is impossible in Scala because new case classes can be defined at any time and in arbitrary
compilation units. For instance, nothing would prevent you from adding a fifth case class to
the Expr class hierarchy in a different compilation unit from the one where the other four cases are
defined.
The alternative is to make the superclass of your case classes sealed. A sealed class cannot have any
new subclasses added except the ones in the same file. This is very useful for pattern matching because
it means you only need to worry about the subclasses you already know about. What&#8217;s more, you get
better compiler support as well. If you match against case classes that inherit from a sealed class, the
compiler will flag missing combinations of patterns with a warning message.
If you write a hierarchy of classes intended to be pattern matched, you should consider sealing them.
Simply put the sealed keyword in front of the class at the top of the hierarchy. Programmers using your
class hierarchy will then feel confident in pattern matching against it. The sealed keyword, therefore, is
often a license to pattern match. Listing 15.16 shows an example in which Expr is turned into a sealed
class.
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
left: Expr, right: Expr) extends Expr
Listing 15.16 - A sealed hierarchy of case classes.
Now define a pattern match where some of the possible cases are left out:
def describe(e: Expr): String = e match {
case Number(</em>) &#8658; "a number"
case Var(<em>)
&#8658; "a variable"
}You will get a compiler warning like the following:
warning: match is not exhaustive!
missing combination
UnOp
missing combination
BinOp
Such a warning tells you that there&#8217;s a risk your code might produce a MatchError exception because
some possible patterns (UnOp, BinOp) are not handled. The warning points to a potential source of
runtime faults, so it is usually a welcome help in getting your program right.
However, at times you might encounter a situation where the compiler is too picky in emitting the
warning. For instance, you might know from the context that you will only ever apply
the describe method above to expressions that are either Numbers or Vars, so you know that
no MatchError will be produced. To make the warning go away, you could add a third catch-all case to
the method, like this:
def describe(e: Expr): String = e match {
case Number(</em>) &#8658; "a number"
case Var(<em>) &#8658; "a variable"
case _ &#8658; throw new RuntimeException // Should not happen
}
That works, but it is not ideal. You will probably not be very happy that you were forced to add code
that will never be executed (or so you think), just to make the compiler shut up.
A more lightweight alternative is to add an @unchecked annotation to the selector expression of the
match. This is done as follows:
def describe(e: Expr): String = (e: @unchecked) match {
case Number(</em>) &#8658; "a number"
case Var(_)
&#8658; "a variable"
}
Annotations are described in Chapter 27. In general, you can add an annotation to an expression in the
same way you add a type: follow the expression with a colon and the name of the annotation (preceded
by an at sign). For example, in this case you add an @uncheckedannotation to the variable e, with
"e: @unchecked". The @unchecked annotation has a special meaning for pattern matching. If a match&#8217;s
selector expression carries this annotation, exhaustivity checking for the patterns that follow will be
suppressed.
15.6 THE OPTION TYPE
Scala has a standard type named Option for optional values. Such a value can be of two
forms:Some(x), where x is the actual value, or the None object, which represents a missing value.
Optional values are produced by some of the standard operations on Scala&#8217;s collections. For instance,
the get method of Scala&#8217;s Map produces Some(value) if a value corresponding to a given key has been
found, or None if the given key is not defined in the Map. Here&#8217;s an example:
scala&gt; val capitals =Map("France" &#8594; "Paris", "Japan" &#8594; "Tokyo")
capitals: scala.collection.immutable.Map[String,String] =
Map(France &#8594; Paris, Japan &#8594; Tokyo)
scala&gt; capitals get "France"
res23: Option[String] = Some(Paris)
scala&gt; capitals get "North Pole"
res24: Option[String] = None
The most common way to take optional values apart is through a pattern match. For instance:
scala&gt; def show(x: Option[String]) = x match {
case Some(s) &#8658; s
case None &#8658; "?"
}
show: (x: Option[String])String
scala&gt; show(capitals get "Japan")
res25: String = Tokyo
scala&gt; show(capitals get "France")
res26: String = Paris
scala&gt; show(capitals get "North Pole")
res27: String = ?
The Option type is used frequently in Scala programs. Compare this to the dominant idiom in Java of
using null to indicate no value. For example, the get method of java.util.HashMapreturns either a value
stored in the HashMap or null if no value was found. This approach works for Java but is error prone
because it is difficult in practice to keep track of which variables in a program are allowed to be null.
If a variable is allowed to be null, then you must remember to check it for null every time you use it.
When you forget to check, you open the possibility that a NullPointerException may result at runtime.
Because such exceptions may not happen very often, it can be difficult to discover the bug during
testing. For Scala, the approach would not work at all because it is possible to store value types in hash
maps, and null is not a legal element for a value type. For instance, aHashMap[Int, Int] cannot
return null to signify "no element."
By contrast, Scala encourages the use of Option to indicate an optional value. This approach to optional
values has several advantages over Java&#8217;s. First, it is far more obvious to readers of code that a variable
whose type is Option[String] is an optional String than a variable of typeString, which may sometimes
be null. But most importantly, that programming error described earlier of using a variable that may
be null without first checking it for null becomes a type error in Scala. If a variable is of
type Option[String] and you try to use it as a String, your Scala program will not compile.
15.7 PATTERNS EVERYWHERE
Patterns are allowed in many parts of Scala, not just in standalone match expressions. Take a look at
some other places you can use patterns.Patterns in variable definitions
Anytime you define a val or a var, you can use a pattern instead of a simple identifier. For example, you
can take apart a tuple and assign each of its parts to its own variable, as shown in Listing 15.17:
scala&gt; val myTuple = (123, "abc")
myTuple: (Int, String) = (123,abc)
scala&gt; val (number, string) = myTuple
number: Int = 123
string: String = abc
Listing 15.17 - Defining multiple variables with one assignment.
This construct is quite useful when working with case classes. If you know the precise case class you
are working with, then you can deconstruct it with a pattern. Here&#8217;s an example:
scala&gt; val exp = new BinOp("</strong>", Number(5), Number(1))
exp: BinOp = BinOp(*,Number(5.0),Number(1.0))
scala&gt; val BinOp(op, left, right) = exp
op: String = *
left: Expr = Number(5.0)
right: Expr = Number(1.0)
Case sequences as partial functions
A sequence of cases (i.e., alternatives) in curly braces can be used anywhere a function literal can be
used. Essentially, a case sequence is a function literal, only more general. Instead of having a single
entry point and list of parameters, a case sequence has multiple entry points, each with their own list of
parameters. Each case is an entry point to the function, and the parameters are specified with the
pattern. The body of each entry point is the right-hand side of the case.
Here is a simple example:
val withDefault: Option[Int] &#8658; Int = {
case Some(x) &#8658; x
case None &#8658; 0
}
The body of this function has two cases. The first case matches a Some, and returns the number inside
the Some. The second case matches a None, and returns a default value of zero. Here is this function in
use:
scala&gt; withDefault(Some(10))
res28: Int = 10
scala&gt; withDefault(None)
res29: Int = 0
This facility is quite useful for the Akka actors library, because it allows its receive method to be
defined as a series of cases:
var sum = 0def receive = {
case Data(byte) &#8658;
sum += byte
}
case GetChecksum(requester) &#8658;
val checksum = ~(sum &amp; 0xFF) + 1
requester ! checksum
One other generalization is worth noting: a sequence of cases gives you a partial function. If you apply
such a function on a value it does not support, it will generate a run-time exception. For example, here
is a partial function that returns the second element of a list of integers:
val second: List[Int] &#8658; Int = {
case x :: y :: _ &#8658; y
}
When you compile this, the compiler will correctly warn that the match is not exhaustive:
&lt;console&gt;:17: warning: match is not exhaustive!
missing combination
Nil
This function will succeed if you pass it a three-element list, but not if you pass it an empty list:
scala&gt; second(List(5, 6, 7))
res24: Int = 6
scala&gt; second(List())
scala.MatchError: List()
at $anonfun$1.apply(&lt;console&gt;:17)
at $anonfun$1.apply(&lt;console&gt;:17)
If you want to check whether a partial function is defined, you must first tell the compiler that you
know you are working with partial functions. The type List[Int] &#8658; Int includes all functions from lists
of integers to integers, whether or not the functions are partial. The type that only
includes partial functions from lists of integers to integers is writtenPartialFunction[List[Int],Int]. Here
is the second function again, this time written with a partial function type:
val second: PartialFunction[List[Int],Int] = {
case x :: y :: _ &#8658; y
}
Partial functions have a method isDefinedAt, which can be used to test whether the function is defined
at a particular value. In this case, the function is defined for any list that has at least two elements:
scala&gt; second.isDefinedAt(List(5,6,7))
res30: Boolean = true
scala&gt; second.isDefinedAt(List())
res31: Boolean = falseThe typical example of a partial function is a pattern matching function literal like the one in the
previous example. In fact, such an expression gets translated by the Scala compiler to a partial function
by translating the patterns twice—once for the implementation of the real function, and once to test
whether the function is defined or not.
For instance, the function literal { case x :: y :: _ &#8658; y } gets translated to the following partial function
value:
new PartialFunction[List[Int], Int] {
def apply(xs: List[Int]) = xs match {
case x :: y :: _ &#8658; y
}
def isDefinedAt(xs: List[Int]) = xs match {
case x :: y :: _ &#8658; true
case _ &#8658; false
}
}
This translation takes effect whenever the declared type of a function literal is PartialFunction. If the
declared type is just Function1, or is missing, the function literal is instead translated to acomplete
function.
In general, you should try to work with complete functions whenever possible, because using partial
functions allows for runtime errors that the compiler cannot help you with. Sometimes partial functions
are really helpful though. You might be sure that an unhandled value will never be supplied.
Alternatively, you might be using a framework that expects partial functions and so will always
check isDefinedAt before calling the function. An example of the latter is the react example given
above, where the argument is a partially defined function, defined precisely for those messages that the
caller wants to handle.
Patterns in for expressions
You can also use a pattern in a for expression, as shown in Listing 15.18. This for expression retrieves
all key/value pairs from the capitals map. Each pair is matched against the pattern(country, city), which
defines the two variables country and city.
scala&gt; for ((country, city) &#8592; capitals)
println("The capital of " + country + " is " + city)
The capital of France is Paris
The capital of Japan is Tokyo
Listing 15.18 - A for expression with a tuple pattern.
The pair pattern shown in Listing 15.18 was special because the match against it can never fail.
Indeed, capitals yields a sequence of pairs, so you can be sure that every generated pair can be matched
against a pair pattern. But it is equally possible that a pattern might not match a generated
value. Listing 15.19 shows an example where that is the case.
scala&gt; val results = List(Some("apple"), None,
Some("orange"))results: List[Option[String]] = List(Some(apple), None,
Some(orange))
scala&gt; for (Some(fruit) &#8592; results) println(fruit)
apple
orange
Listing 15.19 - Picking elements of a list that match a pattern.
As you can see from this example, generated values that do not match the pattern are discarded. For
instance, the second element None in the results list does not match the patternSome(fruit); therefore it
does not show up in the output.
15.8 A LARGER EXAMPLE
After having learned the different forms of patterns, you might be interested in seeing them applied in a
larger example. The proposed task is to write an expression formatter class that displays an arithmetic
expression in a two-dimensional layout. Divisions such as "x / (x + 1)" should be printed vertically, by
placing the numerator on top of the denominator, like this:
x</p></div>
<div class="listingblock">
<div class="content">
<pre><code>x + 1
As another example, here's the expression ((a / (b * c) + 1 / n) / 3) in two dimensional layout:
a 1
----- + -
b * c n</code></pre>
</div></div>
<div class="paragraph"><p>3
From these examples it looks like the class (we&#8217;ll call it ExprFormatter) will have to do a fair bit of
layout juggling, so it makes sense to use the layout library developed in Chapter 10. We&#8217;ll also use
the Expr family of case classes you saw previously in this chapter, and place bothChapter 10&#8217;s layout
library and this chapter&#8217;s expression formatter into named packages. The full code for the example will
be shown in Listings 15.20 and 15.21.
A useful first step is to concentrate on horizontal layout. A structured expression like:
BinOp("<code>",
BinOp("<strong>",
BinOp("</code>", Var("x"), Var("y")),
Var("z")),
Number(1))
should print (x + y) * z + 1. Note that parentheses are mandatory around x + y, but would be optional
around (x + y) * z. To keep the layout as legible as possible, your goal should be to omit parentheses
wherever they are redundant, while ensuring that all necessary parentheses are present.To know where to put parentheses, the code needs to know about the relative precedence of each
operator, so it&#8217;s a good idea to tackle this first. You could express the relative precedence directly as a
map literal of the following form:
Map(
"|" &#8594; 0, "||" &#8594; 0,
"&amp;" &#8594; 1, "&amp;&amp;" &#8594; 1, &#8230;
)
However, this would involve some amount of pre-computation of precedences on your part. A more
convenient approach is to just define groups of operators of increasing precedence and then calculate
the precedence of each operator from that. Listing 15.20 shows the code.
package org.stairwaybook.expr
import org.stairwaybook.layout.Element.elem
sealed abstract class Expr
case class Var(name: String) extends Expr
case class Number(num: Double) extends Expr
case class UnOp(operator: String, arg: Expr) extends Expr
case class BinOp(operator: String,
left: Expr, right: Expr) extends Expr
class ExprFormatter {

private val opGroups =
Array(
Set("|", "||"),
Set("&amp;", "&amp;&amp;"),
Set("^"),
Set("==", "!="),
Set("&lt;", "&#8656;", "&gt;", "&gt;="),
Set("<code>", "-"),
Set("</strong>", "%")
)

private val precedence = {
val assocs =
for {
i &#8592; 0 until opGroups.length
op &#8592; opGroups(i)
} yield op &#8594; i
assocs.toMap
}
private val unaryPrecedence = opGroups.length
private val fractionPrecedence = -1

Listing 15.20 - The top half of the expression formatter.

import org.stairwaybook.layout.Elementprivate def format(e: Expr, enclPrec: Int): Element =
e match {
case Var(name) &#8658;
elem(name)
case Number(num) &#8658;
def stripDot(s: String) =
if (s endsWith ".0") s.substring(0, s.length - 2)
else s
elem(stripDot(num.toString))
case UnOp(op, arg) &#8658;
elem(op) beside format(arg, unaryPrecedence)
case BinOp("/", left, right) &#8658;
val top = format(left, fractionPrecedence)
val bot = format(right, fractionPrecedence)
val line = elem(<em>-</em>, top.width max bot.width, 1)
val frac = top above line above bot
if (enclPrec != fractionPrecedence) frac
else elem(" ") beside frac beside elem(" ")
case BinOp(op, left, right) &#8658;
val opPrec = precedence(op)
val l = format(left, opPrec)
val r = format(right, opPrec + 1)
val oper = l beside elem(" " + op + " ") beside r
if (enclPrec &#8656; opPrec) oper
else elem("(") beside oper beside elem(")")
}
}
def format(e: Expr): Element = format(e, 0)
Listing 15.21 - The bottom half of the expression formatter.
The precedence variable is a map from operators to their precedences, which are integers starting
with 0. It is calculated using a for expression with two generators. The first generator produces every
index i of the opGroups array. The second generator produces every operator opin opGroups(i). For
each such operator the for expression yields an association from the operator op to its index i. Hence,
the relative position of an operator in the array is taken to be its precedence.
Associations are written with an infix arrow, e.g., op &#8594; i. So far you have seen associations only as part
of map constructions, but they are also values in their own right. In fact, the association op &#8594; i is
nothing else but the pair (op, i).
Now that you have fixed the precedence of all binary operators except /, it makes sense to generalize
this concept to also cover unary operators. The precedence of a unary operator is higher than the
precedence of every binary operator. Thus we can set unaryPrecedence (shown in Listing 15.20) to the
length of the opGroups array, which is one more than the precedence of the * and % operators. The
precedence of a fraction is treated differently from the other operators because fractions use verticallayout. However, it will prove convenient to assign to the division operator the special precedence
value -1, so we&#8217;ll initialize fractionPrecedence to -1 (shown in Listing 15.20).
After these preparations, you are ready to write the main format method. This method takes two
arguments: an expression e, of type Expr, and the precedence enclPrec of the operator directly
enclosing the expression e. (If there&#8217;s no enclosing operator, enclPrec should be zero.) The method
yields a layout element that represents a two-dimensional array of characters.
Listing 15.21 shows the remainder of class ExprFormatter, which includes three methods. The first
method, stripDot, is a helper method. The next method, the private format method, does most of the
work to format expressions. The last method, also named format, is the lone public method in the
library, which takes an expression to format. The private format method does its work by performing a
pattern match on the kind of expression. The match expression has five cases. We&#8217;ll discuss each case
individually.
The first case is:
case Var(name) &#8658;
elem(name)
If the expression is a variable, the result is an element formed from the variable&#8217;s name.
The second case is:
case Number(num) &#8658;
def stripDot(s: String) =
if (s endsWith ".0") s.substring(0, s.length - 2)
else s
elem(stripDot(num.toString))
If the expression is a number, the result is an element formed from the number&#8217;s value.
ThestripDot function cleans up the display of a floating-point number by stripping any ".0" suffix from
a string.
The third case is:
case UnOp(op, arg) &#8658;
elem(op) beside format(arg, unaryPrecedence)
If the expression is a unary operation UnOp(op, arg) the result is formed from the operation opand the
result of formatting the argument arg with the highest-possible environment precedence.<span class="footnote"><br />[The value of unaryPrecedence is the highest possible precedence, because it was initialized to one more than the precedence of the * and % operators.]<br /></span> This means
that if arg is a binary operation (but not a fraction) it will always be displayed in parentheses.
The fourth case is:
case BinOp("/", left, right) &#8658;
val top = format(left, fractionPrecedence)
val bot = format(right, fractionPrecedence)
val line = elem(<em>-</em>, top.width max bot.width, 1)
val frac = top above line above bot
if (enclPrec != fractionPrecedence) frac
else elem(" ") beside frac beside elem(" ")If the expression is a fraction, an intermediate result frac is formed by placing the formatted
operands left and right on top of each other, separated by an horizontal line element. The width of the
horizontal line is the maximum of the widths of the formatted operands. This intermediate result is also
the final result unless the fraction appears itself as an argument of another fraction. In the latter case, a
space is added on each side of frac. To see the reason why, consider the expression "(a / b) / c".
Without the widening correction, formatting this expression would give:
a
-
b
-
c
The problem with this layout is evident—it&#8217;s not clear where the top-level fractional bar is. The
expression above could mean either "(a / b) / c" or "a / (b / c)". To disambiguate, a space should be
added on each side to the layout of the nested fraction "a / b". Then the layout becomes unambiguous:
a
-
b
---
c
The fifth and last case is:
case BinOp(op, left, right) &#8658;
val opPrec = precedence(op)
val l = format(left, opPrec)
val r = format(right, opPrec + 1)
val oper = l beside elem(" " + op + " ") beside r
if (enclPrec &#8656; opPrec) oper
else elem("(") beside oper beside elem(")")
This case applies for all other binary operations. Since it comes after the case starting with:
case BinOp("/", left, right) &#8658; &#8230;
you know that the operator op in the pattern BinOp(op, left, right) cannot be a division. To format such
a binary operation, one needs to format first its operands left and right. The precedence parameter for
formatting the left operand is the precedence opPrec of the operatorop, while for the right operand it is
one more than that. This scheme ensures that parentheses also reflect the correct associativity.
For instance, the operation:
BinOp("-", Var("a"), BinOp("-", Var("b"), Var("c")))
would be correctly parenthesized as "a - (b - c)". The intermediate result oper is then formed by placing
the formatted left and right operands side-by-side, separated by the operator. If the precedence of thecurrent operator is smaller than the precedence of the enclosing operator, oper is placed between
parentheses; otherwise, it is returned as is.
import org.stairwaybook.expr._
object Express extends App {
val f = new ExprFormatter
val e1 = BinOp("*", BinOp("/", Number(1), Number(2)),
BinOp("</code>", Var("x"), Number(1)))
val e2 = BinOp("<code>", BinOp("/", Var("x"), Number(2)),
BinOp("/", Number(1.5), Var("x")))
val e3 = BinOp("/", e1, e2)
def show(e: Expr) = println(f.format(e)</code> "\n\n")
}
for (e &#8592; Array(e1, e2, e3)) show(e)
Listing 15.22 - An application that prints formatted expressions.
This finishes the design of the private format function. The only remaining method is the
public format method, which allows client programmers to format a top-level expression without
passing a precedence argument. Listing 15.22 shows a demo program that exercisesExprFormatter.
Note that, even though this program does not define a main method, it is still a runnable application
because it inherits from the App trait. You can run the Express program with the command:
scala Express
This will give the following output:
1
- * (x + 1)
2
x 1.5
- + ---
2 x
1
- * (x + 1)
2</p></div>
<div class="listingblock">
<div class="content">
<pre><code>x 1.5- + ---
2 x
15.9 CONCLUSION
In this chapter, you learned about Scala's case classes and pattern matching in detail. By using them,
you can take advantage of several concise idioms not normally available in object-oriented languages.
However, Scala's pattern matching goes further than this chapter describes. If you want to use pattern
matching on one of your classes, but you do not want to open access to your classes the way case
classes do, you can use the extractors described inChapter 26. In the next chapter, we'll turn our
attention to lists.</code></pre>
</div></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 22:57:17 EET
</div>
</div>
</body>
</html>
