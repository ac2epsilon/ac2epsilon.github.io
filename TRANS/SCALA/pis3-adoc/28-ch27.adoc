include::headers.adoc[]

Глава 27
--------

Анотації
========

27.1 Для чого потрібні анотації?
--------------------------------

Є багато речей, які ви можете робити з програмою, крім компіляції та виконання. Ось деякі приклади:

1. Автоматична генерація документації з Scaladoc.

2. Форматування коду, так щоб він співпадав з вашим стилем.

3. Перевірка коду на загальні помилки, як відкриття файлу, та за деяких шляхів виконання відсутність його закриття.

4. Експериментальна перевірка типів, наприклад, щоб керувати побічними ефектами або для гарантії властивостей власності.

Такі інструменти називаються інструментами мета-програмування, оскількі вони є програмами, що приймають інші програми на вході. Анотації підтримують ці інструменти, дозволяючи програмісту  включати директиви для таких інструментів через джерельний код. Такі директиви дозволяють інструментам бути більш ефективними, порівняно з тим, якщо вони не мали б користувацького вводу. Наприклад, анотації можуть покращити попередньо перелічені інструменти наступним чином:

1. Генератор документації може бути проінструктований, що певний метод треба документувати як застарілий.

2. Форматувальник може бути проінструктований перестрибнути через частини програми, що були дбайливо відформатовані вручну.

3. Перевіряч незачинених файлів може бути поінструктований ігнорувати певний файл, що перевіряється на зачиненість вручну.

4. Перевіряч побічних ефектів може бути поінструктований перевірити, що вказаний метод не має побічних ефектів.

У всіх ціх випадках теоретично має бути можливим для програмної мови провадити способи вставити додаткову інформацію. Фактично, більшість з цього напряму підтримується в тій чи іншій мові. Однак для кожної мови існує дуже багато таких інструментів, щоб напряму підтримувати їх всі. Більше того, вся ця інформація повністю ігнорується компілятором, який кінець кінцем лише бажає зробити код робочим.

Філософія Scala в випадках як цей є включати мінімальну, ортогональну підтримку в основній мові, так що потім може бути написаний широкий загал інструмнтів мета програмування. В цьому випадку ця мінімальна підтримка є система анотацій. Компілятор розуміє тільки одну можливість, анотації, але він не додає жодного значення до окремих анотацій. Кожний інструмент мета програмування може визначати та використовувати свої особливі анотації.

27.2 Синтаксис анотацій
-----------------------
Типове визначення анотації виглядає ось так:
[source,scala]
----
@deprecated def bigMistake() = //...
----
Анотацією є частина `@deprecated`, і вона стосується повністю до метода `bigMistake` (не показаний — він дуже жахливий). В цьому випадку метод помічений як дещо, що автор `bigMistake` бажав би, щоб ви не використовували. Можливо `bigMistake` буде повністю видалений з наступної версії коду.

В попередньому прикладі метод анотований як `@deprecated`. Анотації дозволяються також в інших місцях. Анотації дозволяються на любому різновиді анотації або визначення, включаючи `val`, `var`, `def`, `class`, `object`, `trait` та `type`. Анотація стосується повністю до декларації або визначення, що слідує за ним:
[source,scala]
----
@deprecated class QuickAndDirty {
//...
}
----
Анотації також можуть бути застосовані до виразу, як з анотацією `@unchecked` для порівняння шаблонів (див. Главу 15). Щоб зробити це, поставьте дві крапки (`:`) після виразу, та потім напишіть анотацію. Синтаксично це виглядає так, якби анотація була використаною як тип:
[source,scala]
----
(e: @unchecked) match {
// non-exhaustive cases...
}
----
Нарешті, анотації можуть бути розташовані на типах. Анотовані типи описані далі в цій главі.

Досі показані анотації були просто символом `@`, за яким слідує склас анотації. Така проста анотація загальна та корисна, але анотації мають багатшу загальну форму:
[source,scala]
----
@annot(exp_{1}, exp_{2}, ...)
----
`annot` вказує клас анотації. Всі анотації мають включати цю частину. Частини `exp` є аргументами анотації. Для анотацій як `@deprecated`, що не потребує жодних елементів, ви звичайно можете полишити дужки, але ви можете записати `@deprecated()`, якщо бажаєте. Для анотацій, що мають аргументи, покладайте аргументи в дужки, наприклад, `@serial(1234)`.

Точна форма аргументів, які ви можете надати до анотації, залежить від окремого класу анотації. Більшість процесорів дозволяють вам надавати безпосередні константи, як `123` або `"hello"`. Сам компілятор, однак, підтримує довільні вирази, доки вони проходять перевірку типів. Деякі анотації класів можуть це використовувати, наприклад, щоб дозволити вам посилатись на інші змінні, крім таких з поля зору:
[source,scala]
----
@cool val normal = "Hello"
@coolerThan(normal) val fonzy = "Heeyyy"
----
Внутрішньо Scala представляє анотації як просто виклик конструктора на класі анотатора — замініть `@` на `new`, і ви матимете валідний вираз створення примірника. Це означає, що іменовані та аргументи по замовчанню  підтримуються природно, оскільки Scala вже має іменовані та аргументи по замовчанню для викликів методів та конструкторів. Одне з доволі заплутаних питань щодо анотацій, що концептуально приймають інші анотації як аргументи, чого потребують деякі фреймворки. Ви не можете писати анотації напряму як аргументи до анотацій, оскільки анотації не є валідними виразами. В таких випадках ви маєте використовувати `new` замість `@`, як проілюстровано тут:
[source,scala]
----
scala> import annotation._
import annotation._

scala> class strategy(arg: Annotation) extends Annotation
defined class strategy

scala> class delayed extends Annotation
defined class delayed

scala> @strategy(@delayed) def f() = {}
<console>:1: error: illegal start of simple expression
      @strategy(@delayed) def f() = {}
                ^
scala> @strategy(new delayed) def f() = {}
f: ()Unit
----

27.3 Стандартні анотації
------------------------
Scala включає декілька стандартних анотацій. Вони призначені для можливостей, що використовуються досі загально, щоб заслужити розташування в специфікації мови, але не досить фундаментальні, щоб отримати свій власний синтаксис. З часом буде тонка струмка нових анотацій, що будуть додані до стандарту в такий самий спосіб.

Застаріння
~~~~~~~~~~
Іноді ви пишете клас або метод, про який потім бажаєте, щоб його не було. Однак коли він вже доступний, код, написаний іншими людьми може викликати цей метод. Таким чином ви не можете просто видалити цей метод, оскільки після цього код інших людей перестане компілюватись.

Застаріння дозволяє вам елегантно видалити метод або клас, що виявився помилкою. Ви помічаєте метод або клас як застарілий, та потім будь хто при виклику цього методу або класу буде отримувати попередження про застарілість. Їм краще дослухатись до цього попередження та оновити їхній код! Ідея в тому, що після спливання віповідного проміжку часу ви відчуватимете безпечним в припущенні, що всі помірковані клієнти припинять доступатись до застарілого класу або методу, і, таким чином, що ви можете безпечно видалити його.

Ви відмічаєте метод як застарілий просто написавши перед ним `@deprecated`. Наприклад:
[source,scala]
----
@deprecated def bigMistake() =
//...
----
Така анотація призведе до того, що Scala компілятор додасть повідомлення про застарілість кожного разу, коли код Scala отримує доступ до метода.

Якщо ви надасте рядок як аргумент до `@deprecated`, цей рядок буде виданий разом з повідомленням про помилку. Використовуйте це повідомлення для пояснення розробникам, що вони повинні використовувати замість застарілого метода.
[source,scala]
----
@deprecated("use newShinyMethod() instead")
def bigMistake() = //...
----
Тепер викликачі будуть отримувати таке повідомлення:
[source,scala]
----
$ scalac -deprecation Deprecation2.scala
Deprecation2.scala:33: warning: method bigMistake in objectDeprecation2 is deprecated: use newShinyMethod() instead
    bigMistake()
    ^
one warning found
----

Мінливі поля
~~~~~~~~~~~~~~
Конкурентно програмування негарно міксується з загальним змінним станом. З цієї причини фокус підтримки конкурентності Scala є передача повідомлень, та мінімум загального змінного стану. Дивіться Главу 32 щодо деталей.

Тим не менш, іноді програмісти бажають використати змінний стан в їх конкурентних програмах. Анотація `@volatile` допомагає в таких випадках. Вона інформує компілятор, що розглядувана змінна буде використана в декількох потоках. Такі змінні реалізовані так, що читання та запис до них повільнішій, але доступ з декількох потоків поводиться більш передбачувано.

Ключове слово `@volatile` дає різні гарантії на різних платформах. Однак на Java платформі ви отримаєте ту саму поведінку, якби ви написали поле в Java коді, і помітили його за допомогою модифікатора Java `volatile`.

Бінарна сериалізація
~~~~~~~~~~~~~~~~~~~~
Багато мов включають фреймворк для бінарної сериалізації. Фреймворк сериалізації допомагає вам конвертувати об'єкти в потоки байтів і навпаки. Це корисно, якщо ви бажаєте зберігти об'єкти на диску, або надіслати їх по мережі. XML може допомогти для тих же цілей (дивіться Главу 28), але він має інші недоліки відносно швидкості, використання простору, гнучкості та портабельності.

Scala не має власного фреймворку сериалізації. Замість цього вам слідує використовувати фреймворк для вашої підлеглої платформи. Що робить Scala, це провадить три анотації, що корисні для різних фреймворків. Також компілятор Scala для платформи Java інтерпретує ці анотації в Java спосіб (дивіться Главу 31).

Перша анотація вказує, чи клас взагалі серіалізується. Більшість класів сериалізуються, але не всі. Вказівник на сокет або GUI вікно, наприклад, не можуть бути серіалізовані. По замовчанню клас не розглядається як серіалізуємий. Вам слідує додати анотацію @`serializable` до любого класу, що буде серіалізуватись.

Друга анотація допомагає мати справу зі змінами серіалізованих класів з плином часу. Ви можете додати серійний номер до поточної версії класу, через додавання анотації, як `@SerialVersionUID(1234)`, де `1234` має бути замінено на ваш серійний номер. Фреймворк повинен зберігати це число в згенерованому байтовому потоці. Коли потім ви перезавантажите байтовий потік, та спробуєте конвертувати його на об'єкт, фреймворк може перевірити, що поточна версія класу має той самий номер версії, що і версія в байтовому потоці. Якщо ви бажаєте зробити сериалізація-несумісні зміни до вашого класу, тоді ви можете змінити номер версії. Тоді фреймворк буде автоматично відхиляти завантаження старих примірників класу.

Нарешті, Scala провадить анотацію `@transient` для полів, що взагалі не мають бути серіалізовані. Якщо ви помітите поле як `@transient`, тоді фреймворк не повинен зберігати поле, навіть коли оточуючий об'єкт серіалізується. Коли об'єкт завантажується, поле буде відновлене в значення по замовчанню для типу поля, анотованого як `@transient`.

Автоматичні методи `get` та `set`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Scala код звичайно не потребує явних методів `get` та `set` для полів, оскілько Scala змішує синтаксис для доступу до полів та виклик методів. Однак, деякі платформ-специфічні фреймворки очікують методи `get` та `set`. Для ціх цілей Scala провадить анотацію `@scala.reflect.BeanProperty`. Якщо ви додаєте цю анотацію до поля, компілятор буде автоматично генерувати `get` та `set` для вас. Якщо ви анотуєте поле на ім'я `crazy`, `get` метод буде названий `getCrazy`, та `set` метод буде названий `setCrazy`.

Згенеровані методи `get` та `set` доступні тільки після того, як прохід компілятора буде завершено. Таким чином ви не можете викликати ці методи `get` та `set` з кода, що ви компілюєте, разом з анотованим полем. Це не має бути проблемою на практиці, оскільки в Scala коді ви можете отримувати доступ до полів напряму. Ця можливість призначеня для підтримкм фреймворків, що очікують звичайних методів `get` та `set`, та типово ви не компілюєте фреймворк, та код, що його використовує, одночасно.

Tailrec
~~~~~~~
Ви будете типово додавати анотацію `@tailrec` до метода, що має хвостову рекурсію, наприклад тому, що ви очікуєте, що інакше рекурсія буде занадто глибокою. Щоб переконатись, що компілятор Scala виконує хвостову рекурсію метода з оптимізацією, описаною в Розділі 8.9, ви можете додати `@tailrec` перед визначенням метода. Якщо оптимізація не може бути виконана, ви будете отримувати попередження, разом з поясненням причини.

Unchecked
~~~~~~~~~
Анотація `@unchecked` інтерпретується компілятором під час порівняння шаблонів. Вона каже компілятору не турбуватись, якщо вираз `match` здається не враховує деякі випадки. Дивіться Розділ 15.5 для деталей.

Природні методи
~~~~~~~~~~~~~~~
Анотація `@native` інформує компілятор, що реалізація метода надається скоріше середовищем виконання, ніж кодом Scala. Компілятор буде перемикати відповідний флаг на виході, і покладається на розробника надати реалізацію, використовуючі механізми, такі як Java Native Interface (JNI).

При використанні анотації `@native` тіло метода має бути надане, але воно не потрапить на вихід. Наприклад, ось як декларується метод `beginCountdown`, що буде наданий під час виконання:
[source,scala]
----
@native
def beginCountdown() = {}
----

27.4 Висновок
-------------
Ця глава описує платформ-незалежні аспекти анотацій, про які вам скоріше всього треба знати. Перед усім вона розповідає про синтаксис анотацій, оскіль використання анотацій є значно більш загальним, ніж використання нових. Друге, вона показує, як використовувати декілька анотацій, що підтримуються стандартним компілятором Scala, включаючи `@deprecated`, `@volatile`, `@serializable`, `@BeanProperty`, `@tailrec` та `@unchecked`.

Глава 31 дає додаткову, Java-специфічну інформацію по анотаціях. Це покриває анотації, доступні тільки при цілі на Java, додаткове значення стандартних анотацій при цілі на Java, як взаємодіяти з Java-базованими анотаціями, і як використовувати Java-базовані механізми для визначення та обробки анотацій вScala.

Анотації є структурованою інформацією, доданою до програмного джерельного коду. Як коментарі, вони можуть бути розпорошені по програмі та приєднані до кожної змінної, методу, виразу або іншому елементу програми. На відміну від коментарів, вони мають структуру,  таким чином спрощуючи машинну обробку.

Ця глава показує, як використовувати анотації в Scala. Вона також показує їх загальний синтаксис, та як використовувати декілька стандартних анотацій.

Ця глава не показує, як писати нові інструменти обробки анотацій, оскільки це за межами цієї книги. Глава 31 показує один прийом, але він не поодинокий. Замість цього, ця глава фокусується на тому, як використовувати анотації, оскільки більш загально використовувати анотації, ніж визначати нові процесори анотацій.