<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="paragraph"><p>Chapter 11
Scala&#8217;s Hierarchy
Now that you&#8217;ve seen the details of class inheritance in the previous chapter, it is a good time to take a
step back and look at Scala&#8217;s class hierarchy as a whole. In Scala, every class inherits from a common
superclass named Any. Because every class is a subclass of Any, the methods defined in Any are
"universal" methods: they may be invoked on any object. Scala also defines some interesting classes at
the bottom of the hierarchy, Null and Nothing, which essentially act as common subclasses. For
example, just as Any is a superclass of every other class, Nothing is a subclass of every other class. In
this chapter, we&#8217;ll give you a tour of Scala&#8217;s class hierarchy.
11.1 SCALA&#8217;S CLASS HIERARCHY
Figure 11.1 shows an outline of Scala&#8217;s class hierarchy. At the top of the hierarchy is class Any, which
defines methods that include the following:
final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def : Int
def hashCode: Int
def toString: String
Because every class inherits from Any, every object in a Scala program can be compared using==, !=,
or equals; hashed using  or hashCode; and formatted using toString. The equality and inequality
methods, == and !=, are declared final in class Any, so they cannot be overridden in subclasses.
The == method is essentially the same as equals and != is always the negation ofequals.<span class="footnote"><br />[The only case where == does not directly call equals is for Java&#8217;s boxed numeric classes, such as Integer or Long. In Java, a new Integer(1) does not equal a new Long(1) even though for primitivevalues 1 == 1L. Since Scala is a more regular language than Java, it was necessary to correct this discrepancy by special-casing the == method for these classes. Likewise, the method provides a Scala version of hashing that is the same as Java&#8217;s hashCode, except for boxed numeric types, where it works consistently with ==. For instance new Integer(1) andnew Long(1) hash the same with  even though their Java hashCodes are different.]<br /></span> So
individual classes can tailor what == or != means by overriding the equals method. We&#8217;ll show an
example later in this chapter.Class hierarchy of Scala.
The root class Any has two subclasses: AnyVal and AnyRef. AnyVal is the parent class of value
classes in Scala. While you can define your own value classes (see Section 11.4), there are nine value
classes built into Scala: Byte, Short, Char, Int, Long, Float, Double, Boolean, and Unit. The first eight
of these correspond to Java&#8217;s primitive types, and their values are represented at run time as Java&#8217;s
primitive values. The instances of these classes are all written as literals in Scala. For example, 42 is an
instance of Int, <em>x</em> is an instance of Char, and false an instance ofBoolean. You cannot create instances
of these classes using new. This is enforced by the "trick" that value classes are all defined to be both
abstract and final.
So if you were to write:
scala&gt; new Int
you would get:
&lt;console&gt;:5: error: class Int is abstract; cannot be
instantiated
new Int
<sup>The other value class, Unit, corresponds roughly to Java&#8217;s void type; it is used as the result type of a
method that does not otherwise return an interesting result. Unit has a single instance value, which is
written (), as discussed in Section 7.2.
As explained in Chapter 5, the value classes support the usual arithmetic and boolean operators as
methods. For instance, Int has methods named + and *, and Boolean has methods named || and &amp;&amp;.
Value classes also inherit all methods from class Any. You can test this in the interpreter:
scala&gt; 42.toString
res1: String = 42
scala&gt; 42.hashCode
res2: Int = 42
scala&gt; 42 equals 42
res3: Boolean = true
Note that the value class space is flat; all value classes are subtypes of scala.AnyVal, but they do not
subclass each other. Instead there are implicit conversions between different value class types. For
example, an instance of class scala.Int is automatically widened (by an implicit conversion) to an
instance of class scala.Long when required.
As mentioned in Section 5.10, implicit conversions are also used to add more functionality to value
types. For instance, the type Int supports all of the operations below:
scala&gt; 42 max 43
res4: Int = 43
scala&gt; 42 min 43
res5: Int = 42
scala&gt; 1 until 5
res6: scala.collection.immutable.Range = Range(1, 2, 3, 4)
scala&gt; 1 to 5
res7: scala.collection.immutable.Range.Inclusive
= Range(1, 2, 3, 4, 5)
scala&gt; 3.abs
res8: Int = 3
scala&gt; (-3).abs
res9: Int = 3
Here&#8217;s how this works: The methods min, max, until, to, and abs are all defined in a
classscala.runtime.RichInt, and there is an implicit conversion from class Int to RichInt. The
conversion is applied whenever a method is invoked on an Int that is undefined in Int but defined
in RichInt. Similar "booster classes" and implicit conversions exist for the other value classes. Implicit
conversions will be discussed in detail in Chapter 21.
The other subclass of the root class Any is class AnyRef. This is the base class of all reference
classes in Scala. As mentioned previously, on the Java platform AnyRef is in fact just an alias forclass java.lang.Object. So classes written in Java, as well as classes written in Scala, all inherit
from AnyRef.<span class="footnote"><br />[The reason AnyRef alias exists, instead of just using the name java.lang.Object, is because Scala was originally designed to work on both the Java and .NET platforms. On .NET, AnyRefwas an alias for System.Object.]<br /></span> One way to think of java.lang.Object, therefore, is as the way AnyRef is implemented
on the Java platform. Thus, although you can use Object and AnyRefinterchangeably in Scala programs
on the Java platform, the recommended style is to useAnyRef everywhere.
11.2 HOW PRIMITIVES ARE IMPLEMENTED
How is all this implemented? In fact, Scala stores integers in the same way as Javaâ€”as 32-bit words.
This is important for efficiency on the JVM and also for interoperability with Java libraries. Standard
operations like addition or multiplication are implemented as primitive operations. However, Scala uses
the "backup" class java.lang.Integer whenever an integer needs to be seen as a (Java) object. This
happens for instance when invoking the toStringmethod on an integer number or when assigning an
integer to a variable of type Any. Integers of type Int are converted transparently to "boxed integers" of
type java.lang.Integer whenever necessary.
All this sounds a lot like auto-boxing in Java 5 and it is indeed quite similar. There&#8217;s one crucial
difference though: Boxing in Scala is much less visible than boxing in Java. Try the following in Java:

boolean isEqual(int x, int y) {
return x == y;
}
System.out.println(isEqual(421, 421));
You will surely get true. Now, change the argument types of isEqual to java.lang.Integer (orObject, the
result will be the same):

boolean isEqual(Integer x, Integer y) {
return x == y;
}
System.out.println(isEqual(421, 421));
You will find that you get false! What happens is that the number 421 gets boxed twice, so that the
arguments for x and y are two different objects. Because == means reference equality on reference
types, and Integer is a reference type, the result is false. This is one aspect where it shows that Java is
not a pure object-oriented language. There is a difference between primitive types and reference types
that can be clearly observed.
Now try the same experiment in Scala:
scala&gt; def isEqual(x: Int, y: Int) = x == y
isEqual: (x: Int, y: Int)Boolean
scala&gt; isEqual(421, 421)
res10: Boolean = true
scala&gt; def isEqual(x: Any, y: Any) = x == y
isEqual: (x: Any, y: Any)Boolean
scala&gt; isEqual(421, 421)res11: Boolean = true
The equality operation == in Scala is designed to be transparent with respect to the type&#8217;s
representation. For value types, it is the natural (numeric or boolean) equality. For reference types other
than Java&#8217;s boxed numeric types, == is treated as an alias of the equals method inherited from Object.
That method is originally defined as reference equality, but is overridden by many subclasses to
implement their natural notion of equality. This also means that in Scala you never fall into Java&#8217;s well-
known trap concerning string comparisons. In Scala, string comparison works as it should:
scala&gt; val x = "abcd".substring(2)
x: String = cd
scala&gt; val y = "abcd".substring(2)
y: String = cd
scala&gt; x == y
res12: Boolean = true
In Java, the result of comparing x with y would be false. The programmer should have usedequals in
this case, but it is easy to forget.
However, there are situations where you need reference equality instead of user-defined equality. For
example, in some situations where efficiency is paramount, you would like tohash cons with some
classes and compare their instances with reference equality.<span class="footnote"><br />[You hash cons instances of a class by caching all instances you have created in a weak collection. Then, any time you want a new instance of the class, you first check the cache. If the cache already has an element equal to the one you are about to create, you can reuse the existing instance. As a result of this arrangement, any two instances that are equal withequals() are also equal with reference equality.]<br /></span> For these cases, class AnyRef defines an
additional eq method, which cannot be overridden and is implemented as reference equality (i.e., it
behaves like == in Java for reference types). There&#8217;s also the negation of eq, which is called ne. For
example:
scala&gt; val x = new String("abc")
x: String = abc
scala&gt; val y = new String("abc")
y: String = abc
scala&gt; x == y
res13: Boolean = true
scala&gt; x eq y
res14: Boolean = false
scala&gt; x ne y
res15: Boolean = true
Equality in Scala is discussed further in Chapter 30.
11.3 BOTTOM TYPES
At the bottom of the type hierarchy in Figure 11.1 you see the two classes scala.Null andscala.Nothing.
These are special types that handle some "corner cases" of Scala&#8217;s object-oriented type system in a
uniform way.Class Null is the type of the null reference; it is a subclass of every reference class (i.e., every class that
itself inherits from AnyRef). Null is not compatible with value types. You cannot, for example, assign
a null value to an integer variable:
scala&gt; val i: Int = null
&lt;console&gt;:7: error: an expression of type Null is ineligible
for implicit conversion
val i: Int = null
</sup>
Type Nothing is at the very bottom of Scala&#8217;s class hierarchy; it is a subtype of every other type.
However, there exist no values of this type whatsoever. Why does it make sense to have a type without
values? As discussed in Section 7.4, one use of Nothing is that it signals abnormal termination.
For instance there&#8217;s the error method in the Predef object of Scala&#8217;s standard library, which is defined
like this:
def error(message: String): Nothing =
throw new RuntimeException(message)
The return type of error is Nothing, which tells users that the method will not return normally (it throws
an exception instead). Because Nothing is a subtype of every other type, you can use methods
like error in very flexible ways. For instance:
def divide(x: Int, y: Int): Int =
if (y != 0) x / y
else error("can&#8217;t divide by zero")
The "then" branch of the conditional, x / y, has type Int, whereas the else branch, the call toerror, has
type Nothing. Because Nothing is a subtype of Int, the type of the whole conditional isInt, as required.
11.4 DEFINING YOUR OWN VALUE CLASSES
As mentioned in Section 11.1, you can define your own value classes to augment the ones that are built
in. Like the built-in value classes, an instance of your value class will usually compile to Java bytecode
that does not use the wrapper class. In contexts where a wrapper is needed, such as with generic code,
the value will get boxed and unboxed automatically.
Only certain classes can be made into value classes. For a class to be a value class, it must have exactly
one parameter and it must have nothing inside it except defs. Furthermore, no other class can extend a
value class, and a value class cannot redefine equals or hashCode.
To define a value class, make it a subclass of AnyVal, and put val before the one parameter. Here is an
example value class:
class Dollars(val amount: Int) extends AnyVal {
override def toString() = "$" + amount
}As described in Section 10.6, the val prefix allows the amount parameter to be accessed as a field. For
example, the following code creates an instance of the value class, then retrieves the amount from it:
scala&gt;
money:
scala&gt;
res16:
val money = new Dollars(1000000)
Dollars = $1000000
money.amount
Int = 1000000
In this example, money refers to an instance of the value class. It is of type Dollars in Scala source
code, but the compiled Java bytecode will use type Int directly.
This example defines a toString method, and the compiler figures out when to use it. That&#8217;s why
printing money gives $1000000, with a dollar sign, but printing money.amount gives 1000000. You can
even define multiple value types that are all backed by the same Int value. For example:
class SwissFrancs(val amount: Int) extends AnyVal {
override def toString() = amount + " CHF"
}
Even though both Dollars and SwissFrancs are represented as integers, it works fine to use them in the
same scope:
scala&gt; val dollars = new Dollars(1000)
dollars: Dollars = $1000
scala&gt; val francs = new SwissFrancs(1000)
francs: SwissFrancs = 1000 CHF
Avoiding a types monoculture
To get the most benefit from the Scala class hierarchy, try to define a new class for each domain
concept, even when it would be possible to reuse the same class for different purposes. Even if such a
class is a so-called tiny type with no methods or fields, defining the additional class is a way to help the
compiler be helpful to you.
For example, suppose you are writing some code to generate HTML. In HTML, a style name is
represented as a string. So are anchor identifiers. HTML itself is also a string, so if you wanted, you
could define helper code using strings to represent all of these things, like this:
def title(text: String, anchor: String, style: String): String =
s"&lt;a id=<em>$anchor</em>&gt;&lt;h1 class=<em>$style</em>&gt;$text&lt;/h1&gt;&lt;/a&gt;"
That type signature has four strings in it! Such stringly typed code is technically strongly typed, but
since everything in sight is of type String, the compiler cannot help you detect the use of one when you
meant to write the other. For example, it won&#8217;t stop you from this travesty:
scala&gt; title("chap:vcls", "bold", "Value Classes")
res17: String = &lt;a id=<em>bold</em>&gt;&lt;h1 class=<em>Value
Classes</em>&gt;chap:vcls&lt;/h1&gt;&lt;/a&gt;
This HTML is mangled. The intended display text "Value Classes" is being used as a style class, and
the text being displayed is "chap.vcls," which was supposed to be an anchor. To top it off, the actualanchor identifier is "bold," which is supposed to be a style class. Despite this comedy of errors, the
compiler utters not a peep.
The compiler can be more helpful if you define a tiny type for each domain concept. For example, you
could define a small class for styles, anchor identifiers, display text, and HTML. Since these classes
have one parameter and no members, they can be defined as value classes:
class
class
class
class
Anchor(val value: String) extends AnyVal
Style(val value: String) extends AnyVal
Text(val value: String) extends AnyVal
Html(val value: String) extends AnyVal
Given these classes, it is possible to write a version of title that has a less trivial type signature:
def title(text: Text, anchor: Anchor, style: Style): Html =
new Html(
s"&lt;a id=<em>${anchor.value}</em>&gt;"<br />
s"&lt;h1 class=<em>${style.value}</em>&gt;"<br />
text.value<br />
"&lt;/h1&gt;&lt;/a&gt;"
)
If you try to use this version with the arguments in the wrong order, the compiler can now detect the
error. For example:
scala&gt; title(new Anchor("chap:vcls"), new Style("bold"),
new Text("Value Classes"))
&lt;console&gt;:18: error: type mismatch;
found
: Anchor
required: Text
new Anchor("chap:vcls"),
<sup>
&lt;console&gt;:19: error: type mismatch;
found
: Style
required: Anchor
new Style("bold"),
</sup>
&lt;console&gt;:20: error: type mismatch;
found
: Text
required: Style
new Text("Value Classes"))
^
11.5 CONCLUSION
In this chapter we showed you the classes at the top and bottom of Scala&#8217;s class hierarchy. Now that
you&#8217;ve gotten a good foundation on class inheritance in Scala, you&#8217;re ready to understand mixin
composition. In the next chapter, you&#8217;ll learn about traits.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-01-28 00:29:34 EET
</div>
</div>
</body>
</html>
