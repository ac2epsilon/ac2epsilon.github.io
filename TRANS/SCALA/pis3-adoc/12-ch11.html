<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__11">Глава 11</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__scala">Ієрархія Scala</h1>
<div class="paragraph"><p>Тепер, коли ви бачили деталі наслідування класів в попередньому розділі, настав гарний час зробити крок назад, та подивитись на ієрархію класів в цілому. В Scala кожний клас наслідує від загального суперкласа на ім'я <code>Any</code>. Оскільки кожний клас є субкласом <code>Any</code>, методи, визначені в <code>Any</code> є "універсальними" методами: вони можуть бути викликані на любих об'єктах. Scala також визначає деякі цікаві класи знизу ієрархії, <code>Null</code> та <code>Nothing</code>, що, загалом, діють як загальні субкласи. Наприклад, так само, як <code>Any</code> є суперкласом для кожного іншого класу, <code>Nothing</code> є субкласом кожного іншого класа. В цій главі ми надамо вам тур по ієрархії класів Scala.</p></div>
<div class="sect1">
<h2 id="_11_1___scala">11.1 Ієрархія класів Scala</h2>
<div class="sectionbody">
<div class="paragraph"><p>Малюнок 11.1 показує контур ієрархії класів Scala. Нагорі ієрархії класів знаходиться клас <code>Any</code>, що визначає методи, включаючі наступні:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">def</span> <span class="o">==(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">final</span> <span class="k">def</span> <span class="o">!=(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="o">##</span><span class="k">:</span> <span class="kt">Int</span>
<span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span>
<span class="k">def</span> <span class="n">toString</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>Оскільки кожний клас наслідує від <code>Any</code>, кожний об'єкт в програмі Scala може бути порівняні з використанням <code>==</code>, <code>!=</code>, або <code>equals</code>; хешовані з використанням <code>##</code> або <code>hashCode</code>; та форматовані з використанням <code>toString</code>. Методи рівності або нерівності, <code>==</code> та <code>!=</code> декларовані як фінальні в класі <code>Any</code>, так що вони не можуть бути перекриті в субкласах. Метод <code>==</code> загалом те саме, що і <code>equals</code>, та <code>!=</code> завжди протилежність до <code>equals</code>.<span class="footnote"><br />[Один випадок, коли <code>==</code> напряму не викликає <code>equals</code>, це для боксованих числових класів Java, такіх, як <code>Integer</code> або <code>Long</code>. В Java <code>new Integer(1)</code> не еквівалентне як <code>equal</code> до <code>new Long(1)</code>, навіть не зважаючи, що для примітивів <code>1 == 1L</code>. Оскільки Scala є більш регулярною мовою, ніж Java, було необхідним скорегувати цю невідповідність через особливий метод == для ціх класів. Подібно, метод <code>##</code> провадить Scala версію хешування, що така сама, як і Java <code>hashCode</code>, за винятко боксованих числових типів, де він робить узгоджено з <code>==</code>. Наприклад, <code>new Integer(1)</code> та <code>new Long(1)</code> хешуються <code>##</code> однаково, не зважаючи на те, що в Java їх <code>hashCode</code> різні.]<br /></span> Так що індивідуальні класи можуть вирішувати, що означає <code>==</code> або <code>!=</code> через перекриття метода <code>equals</code>. Ми покажемо приклад пізніше в цій главі.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="____scala">Ієрархія класів в Scala.</h2>
<div class="sectionbody">
<div class="paragraph"><p>Кореневий клас <code>Any</code> має два субкласи: <code>AnyVal</code> та <code>AnyRef</code>. <code>AnyVal</code> є батьківським класом для класів значень в Scala. Хоча ви можете визначити ваші власні класи значень (дивіться Розділ 11.4), існують дев'ять класів значень, вбудованих в Scala: <code>Byte</code>, <code>Short</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, <code>Unit</code>. Перші вісім з них відповідають примітивним класам Java, та їх значення представлені під час виконання як примітивні значення Java. Примірники ціх класів всі написані як літерали в Scala. Наприклад, <code>42</code> є примірником of <code>Int</code>, <code>'x'</code> є примірником <code>Char</code>, та <code>false</code> примірник <code>Boolean</code>. Ви не можете створити примірники ціх класів використовуючи <code>new</code>. Це досягається "трюком", так що класи значень всі визначені одночасно абстрактними та фінальними.</p></div>
<div class="paragraph"><p>Так що якщо ви запишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">new</span> <span class="nc">Int</span>
</pre></div></div></div>
<div class="paragraph"><p>ви отримаєте:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">5</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">class</span> <span class="kt">Int</span> <span class="kt">is</span> <span class="kt">abstract</span><span class="o">;</span> <span class="n">cannot</span> <span class="n">be</span>
<span class="n">instantiated</span>
       <span class="k">new</span> <span class="nc">Int</span>
       <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Інший клас значення, <code>Unit</code>, грубо відповідає до типу Java <code>void</code>; він використовується як тип результате метода, що інакше не повертає цікавого результата. <code>Unit</code> має єдине значення примірника, що записується <code>()</code>, як обговорюється в Розділі 7.2.</p></div>
<div class="paragraph"><p>Як пояснюється в Главі 5, класи значення підтримують звичайні арифметичні та логічні оператори, як методи. Наприклад, <code>Int</code> має методи на ім'я <code>+</code> та <code>*</code>, та <code>Boolean</code> має методи на ім'я <code>||</code> та <code>&amp;&amp;</code>. Класи значень також наслідують всі методи від класу <code>Any</code>. Ви можете протестувати це в інтерпретаторі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mf">42.</span><span class="n">toString</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">42.</span><span class="n">hashCode</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">equals</span> <span class="mi">42</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що простір класів значень плаский; всі класи значень є субтипами <code>scala.AnyVal</code>,але вони не є субкласами один одного. Замість цього, існують неявні перетворення між різними типами класів значень. Наприклад, примірник класу <code>scala.Int</code> за потреби автоматично розширюється (через неявне перетворення) на примірник класу <code>scala.Long</code>.</p></div>
<div class="paragraph"><p>Як зазначається в Розділі 5.10, неявні перетворення також використовуються для додавання більшої функціональності до типів значень. Наприклад, тип <code>Int</code> підтримує всі з операторів нижче:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">max</span> <span class="mi">43</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">43</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">42</span> <span class="n">min</span> <span class="mi">43</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">42</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">until</span> <span class="mi">5</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range</span> <span class="o">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">scala.collection.immutable.Range.Inclusive</span>
<span class="k">=</span> <span class="nc">Range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="mf">3.</span><span class="n">abs</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="o">(-</span><span class="mi">3</span><span class="o">).</span><span class="n">abs</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</pre></div></div></div>
<div class="paragraph"><p>Ось як це робить: методи <code>min</code>, <code>max</code>, <code>until</code>, <code>to</code> та <code>abs</code> всі визначені в класі <code>scala.runtime.RichInt</code>, та існує неявне перетворення від класа <code>Int</code> на <code>RichInt</code>. Перетворення набирає чинності, коли на <code>Int</code> викликається метод, що невизначений в <code>Int</code>, але визначений в <code>RichInt</code>. Подібні "бустерні класи" та неявні перетворення існують також для інших класах значень. Неявні перетворення будуть дискутуватись детально в Главі 21.</p></div>
<div class="paragraph"><p>Інший субклас кореневого класа <code>Any</code> є клас <code>AnyRef</code>. Це базовий клас всіх класів посилань в Scala. Як зазначалось раніше, на Java платформі <code>AnyRef</code> фактично є псевдонімом для класа <code>java.lang.Object</code>. Так що класи, написані на Java, так само, як класи, написані на Scala, всі наслідують від <code>AnyRef</code>.<span class="footnote"><br />[Причина, з якої існує псевдонім <code>AnyRef</code>, замість простого використання імені <code>java.lang.Object</code>, є факт, що  Scala була початково розроблена для роботи на обох платформах Java та .NET. На .NET  <code>AnyRefwas</code> є псевдонімом до <code>System.Object</code>.]<br /></span> Таким чином, один зі способів думати про <code>java.lang.Object</code>, є спосіб, як <code>AnyRef</code> реалізований на платформі Java. Так що, хоча ви можете використовувати <code>Object</code> та <code>AnyRef</code> взаємозамінно в програмах Scala на Java платформі, рекомендованим стилем є повсякчасне використання <code>AnyRef</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_2___">11.2 Як реалізовані примітиви</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як це все реалізоване? Фактично, Scala зберігає цілі в той самий спосіб, що і Java — як 32-бітні слова. Це важливо для ефективності на JVM, і також для взаємодії з бібліотеками Java. Стандартні операції, як додавання або множення, реалізовані як примітивні операції. Однак Scala використовує "дублюючий" клас <code>java.lang.Integer</code>, коли ціле має виглядати як (Java) об'єкт. Це трапляється, наприклад, коли викликається метод <code>toString</code> на цілому числі, або коли присвоюються ціле до змінної типу <code>Any</code>. Цілі типу <code>Int</code> при необхідності прозоро конвертуються до "боксованих цілих" типу <code>java.lang.Integer</code>.</p></div>
<div class="paragraph"><p>Все це виглядає як авто-боксування в Java 5, і насправді досить подібно. Однак є одна значна різниця: боксування в Scala значно менш помітне, ніж боксування в Java. Спробуйте наступне в Java:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="n">boolean</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">int</span> <span class="n">x</span><span class="o">,</span> <span class="n">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">));</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви, звичайно, отримаєте <code>true</code>. Тепер змініть типи аргументів <code>isEqual</code> на <code>java.lang.Integer</code> (або <code>Object</code>, результат буде той самий):</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Це Java</span>
<span class="n">boolean</span> <span class="n">isEqual</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Integer</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
<span class="nc">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">));</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви знайдете, що тепер ви отримуєте <code>false</code>! Що відбувається, це число <code>421`боксується  двічі, так що аргументи для `x</code> та <code>y</code> є двома різними об'єктами. Оскільки <code>==</code> означає рівність посилань, та <code>Integer</code> є типом посилання, та результат буде <code>false</code>. Це один з аспектів, який показує, що Java не є чистою об'єктно-орієнтовною мовою. Існує різниця між примітивними типами, та типами посилань, що можливо ясно спостерігати.</p></div>
<div class="paragraph"><p>Тепер спробуємо той самий експеримент в Scala:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">isEqual</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Int</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Int</span><span class="o">)</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">)</span>
<span class="n">res10</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">def</span> <span class="n">isEqual</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">isEqual</span><span class="k">:</span> <span class="o">(</span><span class="kt">x:</span> <span class="kt">Any</span><span class="o">,</span> <span class="kt">y:</span> <span class="kt">Any</span><span class="o">)</span><span class="nc">Boolean</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isEqual</span><span class="o">(</span><span class="mi">421</span><span class="o">,</span> <span class="mi">421</span><span class="o">)</span>
<span class="n">res11</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Операція еквівалентності <code>==</code> в Scala розроблений бути прозорим з точки зору представлення типу. Для типів значень це природна (числова та логічна) рівність. Для типів посилань, інших ніж боксовані числові типи Java, <code>==</code> трактується як псевдоним для метода <code>equals</code>, наслідуваного від <code>Object</code>. Цей метод в оригіналі визначений як референсна еквівалентність, але перекритий багатьма субкласами для реалізації їх природної нотації рівності. Це також означає, що в Scala ви ніколи не попадете в гарно відому ловушку Java, що стосується порівняння рядків. В Scala порівняння рідків робить як повинно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="s">&quot;abcd&quot;</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cd</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="s">&quot;abcd&quot;</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">cd</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">res12</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>В Java результат порівняння <code>x</code> з <code>y</code> буде <code>false</code>. Програміст має використовувати <code>equals</code> в цьому випадку, але про це легко забути.</p></div>
<div class="paragraph"><p>Однак є ситуації, коли вам потрібна рівність посилань, замість визначеної користувачем рівності. Наприклад, в деяких ситуаціях, де ефективність є понад усе, ви, можливо, вирішите хешувати класи, та порівнювати їх примірники на рівність посилань.<span class="footnote"><br />[Ви хешуєте примірники класу, кешуючи всі примірники, які ви створюєте в слабкій колекції. Потім, кожного разу, коли вам треба новий примірник класу, ви спочатку перевіряєте кеш. Якщо кеш вже має елемент, еквівалентний до того, що ви збираєтесь створити, ви можете повторно використати існуючий примірник. Як результат цього механізму, любі два примірника, що еквівалентні згідно <code>equals()</code>, також є еквівалентні згідно рівності посилань.]<br /></span> Для ціх випадків клас <code>AnyRef</code> визначає додатковий метод <code>eq</code>, що не може бути перекритий, та реалізований як рівність посилання (тобто, він поводиться як <code>==</code> в Java для типів посилань). Також є доповнення до <code>eq</code>, що називається <code>ne</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">x</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">&quot;abc&quot;</span><span class="o">)</span>
<span class="n">y</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">abc</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="n">res13</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">eq</span> <span class="n">y</span>
<span class="n">res14</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="n">ne</span> <span class="n">y</span>
<span class="n">res15</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>
</pre></div></div></div>
<div class="paragraph"><p>Еквівалентність в Scala обговорюється далі в Главі 30.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_3__">11.3 Нижні типи</h2>
<div class="sectionbody">
<div class="paragraph"><p>Знизу ієрархії типів на Малюнку 11.1 ви бачите два класи, <code>scala.Null</code> та <code>scala.Nothing</code>. Це особливі типи, що обробляють деякі "пограничні випадки" об'єктно-орієнтовної системи типів Scala в уніформний спосіб.</p></div>
<div class="paragraph"><p>Клас <code>Null</code> є типом посилання <code>null</code>; це субклас кожного класу посилань (тобто, кожного класу, що сам наслідує від <code>AnyRef</code>). <code>Null</code> не сумісний з типами значень. Наприклад, ви не можете присвоїти значення <code>null</code> до цілого значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="kc">null</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">7</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">an</span> <span class="kt">expression</span> <span class="kt">of</span> <span class="k">type</span> <span class="kt">Null</span> <span class="kt">is</span> <span class="kt">ineligible</span>
<span class="k">for</span> <span class="k">implicit</span> <span class="n">conversion</span>
       <span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="kc">null</span>
                    <span class="o">^</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип <code>Nothing</code> є на самому дні ієрархії класів Scala; це субтип кожного іншого типу. Однак не існує жодного примірника цього типу. Чому може бути сенс мати тип без значень? Як обговорюється в Розділі 7.4, одне використання <code>Nothing</code> є сигналювання щодо ненормального завершення.</p></div>
<div class="paragraph"><p>Наприклад, існує метод <code>error</code> в об'єкті <code>Predef</code> стандартної бібліотеки Scala, що визначений таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">error</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Тип повернення <code>error</code> є <code>Nothing</code>, що каже користувачам, що метод не буде повертати значення звичайним чином (замість цього він закидає виключення). Оскільки <code>Nothing</code> є субтипом кожного іншого типу, ви можете використовувати методи, як <code>error</code>, в дуже гнучкі способи. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">divide</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>
  <span class="k">else</span> <span class="n">error</span><span class="o">(</span><span class="s">&quot;can&#39;t divide by zero&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Гілка <code>then`умовного виразу, `x / y</code>, має тип <code>Int</code>, тоді як гілка <code>else</code> викликає <code>error</code>, та має тип <code>Nothing</code>. Оскільки <code>Nothing</code> є субтипом <code>Int</code>, тип цілого виразу є <code>Int</code>, як це і вимагається.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_11_4_____">11.4 Визначення ваших власних класів значення</h2>
<div class="sectionbody">
<div class="paragraph"><p>Як зазначалось в Розділі 11.1, ви можете визначити ваші власні класи значень, щоб покращити ті, що вже є вбудовані. Як і вбудовані класи значень, примірник вашого класу значення буде звичайно компілюватись в Java бійткод, що не використовує клас огортки. В контекстах, коли огортка потрібна, як в коді дженериків, значення буде боксоване та розбоксоване автоматично.</p></div>
<div class="paragraph"><p>Тільки певні класи можуть бути перетворені в класи значень. Щоб клас був класом значення, він повинен мати рівно один параметр, і він не повинен містити всередині нічого, за винятком <code>def</code>. Більше того, жодний інший клас не може розширяти клас значення, та клас значення не може перевизначати <code>equals</code> або <code>hashCode</code>.</p></div>
<div class="paragraph"><p>Щоб визначити клас значення, зробіть його субкласом <code>AnyVal</code>, та покладіть <code>val</code> перед одним параметром. Ось приклад класу значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Dollars</span><span class="o">(</span><span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="s">&quot;$&quot;</span> <span class="o">+</span> <span class="n">amount</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Як описано в Розділі 10.6, префікс <code>val</code> дозволяє параметру <code>amount</code> бути досяжним як поле. Наприклад, наступний код створює примірник класу значення, що отримує значення з поля:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span><span class="k">val</span> <span class="n">money</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollars</span><span class="o">(</span><span class="mi">1000000</span><span class="o">)</span>
<span class="n">money</span><span class="k">:</span> <span class="kt">Dollars</span> <span class="o">=</span> <span class="n">$1000000</span>

<span class="n">scala</span><span class="o">&gt;</span><span class="n">money</span><span class="o">.</span><span class="n">amount</span>
<span class="n">res16</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">1000000</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі <code>money</code> посилається на примірник класу значення. Його тип в джерельному коді Scala буде <code>Dollars</code>, але скомпільований байткод Java буде напряму використовувати тип  <code>Int</code>.</p></div>
<div class="paragraph"><p>Цей приклад визначає метод <code>toString</code>, і компілятор здогадується, коли його використовувати. Ось чому друк <code>money</code> дає <code>$1000000</code> зі знаком долара, але друк <code>money.amount</code> дає <code>1000000</code>. Ви навіть можете визначити декілька типів значень, що одночасно підтримуються тим самим значенням <code>Int</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">SwissFrancs</span><span class="o">(</span><span class="k">val</span> <span class="n">amount</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span><span class="o">()</span> <span class="k">=</span> <span class="n">amount</span> <span class="o">+</span> <span class="s">&quot; CHF&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Навіть не зважаючи, що обоє, <code>Dollars</code> та <code>SwissFrancs</code> представлені як цілі, це робить добре, коли вони використовуються разом в полі зору:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">dollars</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dollars</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="n">dollars</span><span class="k">:</span> <span class="kt">Dollars</span> <span class="o">=</span> <span class="n">$1000</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">francs</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">SwissFrancs</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
<span class="n">francs</span><span class="k">:</span> <span class="kt">SwissFrancs</span> <span class="o">=</span> <span class="mi">1000</span> <span class="nc">CHF</span>
</pre></div></div></div>
<div class="sect2">
<h3 id="___">Уникнення монокультури типів</h3>
<div class="paragraph"><p>Щоб отримати найбільшу вигоду від ієрархії класів Scala, намагайтесь визначати нові класи для кожної галузевої концепції, навіть коли можливо використати той самий клас для різних призначень. Навіть, якщо такий клас є так званим <em>крихітним типом</em> без методів або полів, визначення додаткових класів є шляхом допомогти компілятору бути корисним для вас.</p></div>
<div class="paragraph"><p>Наприклад, уявімо, що ви пишете деякий код для генерації HTML. В HTML ім'я стиля представлений як рядок. Так само як ідентифікатори якорів. Сам HTML також є рядком, так що, якщо ви бажаєте, ви можете визначити допоміжний код з використанням рядків, щоб представляти все це, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">title</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">anchor</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">style</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="s">s&quot;&lt;a id=&#39;</span><span class="si">$anchor</span><span class="s">&#39;&gt;&lt;h1 class=&#39;</span><span class="si">$style</span><span class="s">&#39;&gt;</span><span class="si">$text</span><span class="s">&lt;/h1&gt;&lt;/a&gt;&quot;</span>
</pre></div></div></div>
<div class="paragraph"><p>Ця сигнатура типу має чотири рядки в собі! Такий за-рядковано типізований код технічно строго типізований, але оскільки все в полі зору має тип <code>String</code>, компілятор не може допомогти вам детектувати використання одного, коли ви мали на увазі написати інше. Наприклад, він не зупинить вас від цієї пародії:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">title</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">,</span> <span class="s">&quot;bold&quot;</span><span class="o">,</span> <span class="s">&quot;Value Classes&quot;</span><span class="o">)</span>
<span class="n">res17</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">a</span> <span class="n">id</span><span class="o">=</span><span class=" -Symbol">&#39;bold</span><span class="err">&#39;</span><span class="o">&gt;&lt;</span><span class="n">h1</span> <span class="n">class</span><span class="o">=</span><span class=" -Symbol">&#39;Value</span>
    <span class="nc">Classes</span><span class="err">&#39;</span><span class="o">&gt;</span><span class="n">chap</span><span class="k">:</span><span class="kt">vcls&lt;/h1&gt;&lt;/a&gt;</span>
</pre></div></div></div>
<div class="paragraph"><p>Цей HTML геть перекручений. Призначений для відображення текст <code>"Value Classes"</code> був використаний як клас стилю, та відображений текст є <code>"chap.vcls"</code>, що був задуманий як якір. Щоб довершити все, насправді ідентифікатор якоря є <code>"bold"</code>, що мав бути класом стилю. Не зважаючи на цю комедію помилок, компілятор не вимовив ані слова.</p></div>
<div class="paragraph"><p>Компілятор міг бути більш корисним, якщо ви визначите крихітні типи для кожної доменної концепції. Наприклад, ви можете визначити малий клас для стилю, ідентифікатора якоря, тексту для відображення та HTML. Оскільки ці класи мають один параметр, і не мають членів, вони можуть бути визначені як класи значення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Anchor</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Style</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Text</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
<span class="k">class</span> <span class="nc">Html</span><span class="o">(</span><span class="k">val</span> <span class="n">value</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">AnyVal</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи ці класи можливо написати версію <code>title</code>, що має менш тривіальну сигнатуру типів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">title</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">Text</span><span class="o">,</span> <span class="n">anchor</span><span class="k">:</span> <span class="kt">Anchor</span><span class="o">,</span> <span class="n">style</span><span class="k">:</span> <span class="kt">Style</span><span class="o">)</span><span class="k">:</span> <span class="kt">Html</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">Html</span><span class="o">(</span>
    <span class="s">s&quot;&lt;a id=&#39;</span><span class="si">${</span><span class="n">anchor</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s">&#39;&gt;&quot;</span> <span class="o">+</span>
    <span class="s">s&quot;&lt;h1 class=&#39;</span><span class="si">${</span><span class="n">style</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s">&#39;&gt;&quot;</span> <span class="o">+</span>
    <span class="n">text</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span>
    <span class="s">&quot;&lt;/h1&gt;&lt;/a&gt;&quot;</span>
  <span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Якщо ви спробуєте використати цю версію з аргументами в невірному порядку, компілятор тепер може детектувати помилку. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">title</span><span class="o">(</span><span class="k">new</span> <span class="nc">Anchor</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Style</span><span class="o">(</span><span class="s">&quot;bold&quot;</span><span class="o">),</span>
           <span class="k">new</span> <span class="nc">Text</span><span class="o">(</span><span class="s">&quot;Value Classes&quot;</span><span class="o">))</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">18</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Anchor</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Text</span>
                <span class="k">new</span> <span class="nc">Anchor</span><span class="o">(</span><span class="s">&quot;chap:vcls&quot;</span><span class="o">),</span>
                <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">19</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Style</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Anchor</span>
                <span class="k">new</span> <span class="nc">Style</span><span class="o">(</span><span class="s">&quot;bold&quot;</span><span class="o">),</span>
                <span class="o">^</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">20</span><span class="k">:</span> <span class="kt">error:</span> <span class="k">type</span> <span class="kt">mismatch</span><span class="o">;</span>
 <span class="n">found</span>   <span class="k">:</span> <span class="kt">Text</span>
 <span class="n">required</span><span class="k">:</span> <span class="kt">Style</span>
                <span class="k">new</span> <span class="nc">Text</span><span class="o">(</span><span class="s">&quot;Value Classes&quot;</span><span class="o">))</span>
                <span class="o">^</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_11_5_">11.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ми показали вам класи нагорі та знизу ієрархії класів Scala. Тепер, коли ви отримали гарне підгрунтя щодо наслідування класів в Scala, ви готові для розуміння композиції міксінів. В наступній главі ви навчитесь щодо трейтів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-12 20:20:33 EET
</div>
</div>
</body>
</html>
