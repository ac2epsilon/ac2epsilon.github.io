<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__22">Глава 22</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Реалізація списків</h1>
<div class="paragraph"><p>Lists have been ubiquitous in this book. Class List is probably the most commonly used structured data
type in Scala. Chapter 16 showed you how to use lists. This chapter "opens up the covers" and explains
a bit about how lists are implemented in Scala.
Knowing the internal workings of the List class is useful for several reasons. You gain a better idea of
the relative efficiency of list operations, which will help you in writing fast and compact code using
lists. You also gain a toolbox of techniques that you can apply in the design of your own libraries.
Finally, the List class is a sophisticated application of Scala&#8217;s type system in general and its genericity
concepts in particular. So studying class List will deepen your knowledge in these areas.
22.1 THE LIST CLASS IN PRINCIPLE
Lists are not "built-in" as a language construct in Scala; they are defined by an abstract classList in
the scala package, which comes with two subclasses for :: and Nil. In this chapter we will present a
quick tour through class List. This section presents a somewhat simplified account of the class,
compared to its real implementation in the Scala standard library, which is covered in Section 22.3.
package scala
abstract class List[<code>T] {
List is an abstract class, so you cannot define elements by calling the empty List constructor. For
instance the expression "new List" would be illegal. The class has a type parameter T. The +in front of
this type parameter specifies that lists are covariant, as discussed in Chapter 19.
Figure 22.1 - Class hierarchy for Scala lists.
Because of this property, you can assign a value of type List[Int] to a variable of typeList[Any]:
scala&gt; val xs = List(1, 2, 3)
xs: List[Int] = List(1, 2, 3)
scala&gt; var ys: List[Any] = xs
ys: List[Any] = List(1, 2, 3)All list operations can be defined in terms of three basic methods:
def isEmpty: Boolean
def head: T
def tail: List[T]
These three methods are all abstract in class List. They are defined in the subobject Nil and the
subclass ::. The hierarchy for List is shown in Figure 22.1.
The Nil object
The Nil object defines an empty list. Its definition is shown in Listing 22.1. The Nil object inherits
from type List[Nothing]. Because of covariance, this means that Nil is compatible with every instance
of the List type.
case object Nil extends List[Nothing] {
override def isEmpty = true
def head: Nothing =
throw new NoSuchElementException("head of empty list")
def tail: List[Nothing] =
throw new NoSuchElementException("tail of empty list")
}
Listing 22.1 - The definition of the Nil singleton object.
The three abstract methods of class List are implemented in the Nil object in a straightforward way:
The isEmpty method returns true, and the head and tail methods both throw an exception. Note that
throwing an exception is not only reasonable, but practically the only possible thing to do for head:
Because Nil is a List of Nothing, the result type of headmust be Nothing. Since there is no value of this
type, this means that head cannot return a normal value. It has to return abnormally by throwing an
exception.<span class="footnote"><br />[To be precise, the types would also permit for head to always go into an infinite loop instead of throwing an exception, but this is clearly not what&#8217;s wanted.]<br /></span>
The :: class
Class ::, pronounced "cons" for "construct," represents non-empty lists. It&#8217;s named that way in order to
support pattern matching with the infix ::. You have seen in Section 16.5 that every infix operation in a
pattern is treated as a constructor application of the infix operator to its arguments. So the
pattern x :: xs is treated as ::(x, xs) where :: is a case class.
Here is the definition of the :: class:
final case
def head
def tail
override
}
class ::[T](hd: T, tl: List[T]) extends List[T] {
= hd
= tl
def isEmpty: Boolean = false
The implementation of the :: class is straightforward. It takes two parameters hd and tl, representing the
head and the tail of the list to be constructed. The definitions of the head andtail method simply return
the corresponding parameter. In fact, this pattern can be abbreviated by letting the parameters directlyimplement the head and tail methods of the superclass List, as in the following equivalent but shorter
definition of the :: class:
final case class ::[T](head: T, tail: List[T])
extends List[T] {
override def isEmpty: Boolean = false
}
This works because every case class parameter is implicitly also a field of the class (it&#8217;s like the
parameter declaration was prefixed with val). Recall from Section 20.3 that Scala allows you to
implement an abstract parameterless method such as head or tail with a field. So the code above
directly uses the parameters head and tail as implementations of the abstract methods head and tail that
were inherited from class List.
Some more methods
All other List methods can be written using the basic three. For instance:
def length: Int =
if (isEmpty) 0 else 1 + tail.length
or:
def drop(n: Int): List[T] =
if (isEmpty) Nil
else if (n &#8656; 0) this
else tail.drop(n - 1)
or:
def map[U](f: T &#8658; U): List[U] =
if (isEmpty) Nil
else f(head) :: tail.map(f)
List construction
The list construction methods :: and ::: are special. Because they end in a colon, they are bound to their
right operand. That is, an operation such as x :: xs is treated as the method callxs.::(x), not x.::(xs). In
fact, x.::(xs) would not make sense, as x is of the list element type, which can be arbitrary, so we cannot
assume that this type would have a :: method.
For this reason, the :: method should take an element value and yield a new list. What is the required
type of the element value? You might be tempted to say it should be the same as the list&#8217;s element type,
but in fact this is more restrictive than necessary.
To see why, consider this class hierarchy:
abstract class Fruit
class Apple extends Fruit
class Orange extends FruitListing 22.2 shows what happens when you construct lists of fruit:
scala&gt; val apples = new Apple :: Nil
apples: List[Apple] = List(<a href="mailto:Apple@e885c6a">Apple@e885c6a</a>)
scala&gt; val fruits = new Orange :: apples
fruits: List[Fruit] = List(<a href="mailto:Orange@3f51b349">Orange@3f51b349</a>, <a href="mailto:Apple@e885c6a">Apple@e885c6a</a>)
Listing 22.2 - Prepending a supertype element to a subtype list.
The apples value is treated as a List of Apples, as expected. However, the definition of fruitsshows that
it&#8217;s still possible to add an element of a different type to that list. The element type of the resulting list
is Fruit, which is the most precise common supertype of the original list element type (i.e., Apple) and
the type of the element to be added (i.e., Orange). This flexibility is obtained by defining the :: method
(cons) as shown in Listing 22.3:
def ::[U &gt;: T](x: U): List[U] = new scala.::(x, this)
Listing 22.3 - The definition of method :: (cons) in class List.
Note that the method is itself polymorphic—it takes a type parameter named U. Furthermore,U is
constrained in [U &gt;: T] to be a supertype of the list element type T. The element to be added is required
to be of type U and the result is a List[U].
With the formulation of :: shown in Listing 22.3, you can check how the definition of fruitsshown
in Listing 22.2 works out type-wise: In that definition, the type parameter U of :: is instantiated to Fruit.
The lower-bound constraint of U is satisfied because the list apples has type List[Apple] and Fruit is a
supertype of Apple. The argument to the :: is new Orange, which conforms to type Fruit. Therefore, the
method application is type-correct with result typeList[Fruit]. Figure 22.2 illustrates the structure of the
lists that result from executing the code shown in Listing 22.2.
Figure 22.2 - The structure of the Scala lists shown in Listing 22.2.
In fact, the polymorphic definition of :: with the lower bound T is not only convenient, it is also
necessary to render the definition of class List type-correct. This is because Lists are defined to be
covariant.
Assume for a moment that we had defined :: like this:// A thought experiment (which wouldn&#8217;t work)
def ::(x: T): List[T] = new scala.::(x, this)
You saw in Chapter 19 that method parameters count as contravariant positions, so the list element
type T is in contravariant position in the definition above. But then List cannot be declared covariant
in T. The lower bound [U &gt;: T] thus kills two birds with one stone: It removes a typing problem and
leads to a :: method that&#8217;s more flexible to use. The list concatenation method ::: is defined in a similar
way to ::, as shown in Listing 22.4.
def :::[U &gt;: T](prefix: List[U]): List[U] =
if (prefix.isEmpty) this
else prefix.head :: prefix.tail ::: this
Listing 22.4 - The definition of method ::: in class List.
Like cons, concatenation is polymorphic. The result type is "widened" as necessary to include the types
of all list elements. Note again that the order of the arguments is swapped between an infix operation
and an explicit method call. Because both ::: and :: end in a colon, they both bind to the right and are
both right associative. For instance, the else part of the definition of ::: shown in Listing 22.4 contains
infix operations of both :: and :::.
These infix operations can be expanded to equivalent method calls as follows:
prefix.head :: prefix.tail ::: this
equals (because :: and ::: are right-associative)
prefix.head :: (prefix.tail ::: this)
equals (because :: binds to the right)
(prefix.tail ::: this).::(prefix.head)
equals (because ::: binds to the right)
this.:::(prefix.tail).::(prefix.head)
22.2 THE LISTBUFFER CLASS
The typical access pattern for a list is recursive. For instance, to increment every element of a list
without using map you could write:
def incAll(xs: List[Int]): List[Int] = xs match {
case List() &#8658; List()
case x :: xs1 &#8658; x + 1 :: incAll(xs1)
}
One shortcoming of this program pattern is that it is not tail recursive. Note that the recursive call
to incAll above occurs inside a :: operation. Therefore each recursive call requires a new stack frame.
On today&#8217;s virtual machines this means that you cannot apply incAll to lists of much more than about
30,000 to 50,000 elements. This is a pity. How do you write a version of incAllthat can work on lists of
arbitrary size (as much as heap-capacity allows)?
One approach is to use a loop:for (x &#8592; xs) // ??
But what should go in the loop body? Note that where incAll constructs the list by prepending elements
to the result of the recursive call, the loop needs to append new elements at the end of the result list. A
very inefficient possibility is to use :::, the list append operator:
var result = List[Int]()

for (x &#8592; xs) result = result ::: List(x + 1)
result
This is terribly inefficient. Because ::: takes time proportional to the length of its first operand, the
whole operation takes time proportional to the square of the length of the list. This is clearly
unacceptable.
A better alternative is to use a list buffer. List buffers let you accumulate the elements of a list. To do
this, you use an operation such as "buf += elem", which appends the element elem at the end of the list
buffer buf. Once you are done appending elements, you can turn the buffer into a list using
the toList operation.
ListBuffer is a class in package scala.collection.mutable. To use the simple name only, you can
import ListBuffer from its package:
import scala.collection.mutable.ListBuffer
Using a list buffer, the body of incAll can now be written as follows:
val buf = new ListBuffer[Int]
for (x &#8592; xs) buf += x + 1
buf.toList
This is a very efficient way to build lists. In fact, the list buffer implementation is organized so that
both the append operation (</code>=) and the toList operation take (very short) constant time.
22.3 THE LIST CLASS IN PRACTICE
The implementations of list methods given in Section 22.1 are concise and clear, but suffer from the
same stack overflow problem as the non-tail recursive implementation of incAll. Therefore, most
methods in the real implementation of class List avoid recursion and use loops with list buffers instead.
For example, Listing 22.5 shows the real implementation of mapin class List:
final override def map[U](f: T &#8658; U): List[U] = {
val b = new ListBuffer[U]
var these = this
while (!these.isEmpty) {
b += f(these.head)
these = these.tail
}
b.toList
}Listing 22.5 - The definition of method map in class List.
This revised implementation traverses the list with a simple loop, which is highly efficient. A tail
recursive implementation would be similarly efficient, but a general recursive implementation would be
slower and less scalable. But what about the operation b.toList at the end? What is its complexity? In
fact, the call to the toList method takes only a small number of cycles, which is independent of the
length of the list.
To understand why, take a second look at class ::, which constructs non-empty lists. In practice, this
class does not quite correspond to its idealized definition given previously inSection 22.1. The real
definition is shown in Listing 22.6. As you can see, there&#8217;s one peculiarity: the tl argument is a var!
This means that it is possible to modify the tail of a list after the list is constructed. However, because
the variable tl has the modifier private[scala], it can be accessed only from within package scala. Client
code outside this package can neither read nor write tl.
final case class ::[U](hd: U,
private[scala] var tl: List[U]) extends List[U] {
def head = hd
def tail = tl
override def isEmpty: Boolean = false
}
Listing 22.6 - The definition of the :: subclass of List.
Since the ListBuffer class is contained in a subpackage of
package scala,scala.collection.mutable, ListBuffer can access the tl field of a cons cell. In fact the
elements of a list buffer are represented as a list and appending new elements involves a modification
of the tl field of the last :: cell in that list. Here&#8217;s the start of class ListBuffer:
package scala.collection.immutable
final class ListBuffer[T] extends Buffer[T] {
private var start: List[T] = Nil
private var last0: ::[T] = _
private var exported: Boolean = false
&#8230;
You see three private fields that characterize a ListBuffer:
start
points to the list of all elements stored in the buffer
last0
points to the last :: cell in that list
exported indicates whether the buffer has been turned into
a list using a toList operation
The toList operation is very simple:
override def toList: List[T] = {
exported = !start.isEmpty
start
}It returns the list of elements referred to by start and also sets exported to true if that list is nonempty.
So toList is very efficient because it does not copy the list which is stored in aListBuffer. But what
happens if the list is further extended after the toList operation? Of course, once a list is returned
from toList, it must be immutable. However, appending to thelast0 element will modify the list which
is referred to by start.
To maintain the correctness of the list buffer operations, you need to work on a fresh list instead. This is
achieved by the first line in the implementation of the += operation:
override def += (x: T) = {
if (exported) copy()
if (start.isEmpty) {
last0 = new scala.::(x, Nil)
start = last0
} else {
val last1 = last0
last0 = new scala.::(x, Nil)
last1.tl = last0
}
}
You see that += copies the list pointed to by start if exported is true. So, in the end, there is no free
lunch. If you want to go from lists which can be extended at the end to immutable lists, there needs to
be some copying. However, the implementation of ListBuffer is such that copying is necessary only for
list buffers that are further extended after they have been turned into lists. This case is quite rare in
practice. Most use cases of list buffers add elements incrementally and then do one toList operation at
the end. In such cases, no copying is necessary.
22.4 FUNCTIONAL ON THE OUTSIDE
In the previous section, we showed key elements of the implementation of
Scala&#8217;s List andListBuffer classes. You saw that lists are purely functional on the "outside" but have an
imperative implementation using list buffers on the "inside." This is a typical strategy in Scala
programming—trying to combine purity with efficiency by carefully delimiting the effects of impure
operations.
But you might ask, Why insist on purity? Why not just open up the definition of lists, making
the tail field, and maybe also the head field, mutable? The disadvantage of such an approach is that it
would make programs much more fragile. Note that constructing lists with :: re-uses the tail of the
constructed list.
So when you write:
val ys = 1 :: xs
val zs = 2 :: xs
the tails of lists ys and zs are shared; they point to the same data structure. This is essential for
efficiency; if the list xs was copied every time you added a new element onto it, this would be much
slower. Because sharing is pervasive, changing list elements, if it were possible, would be quitedangerous. For instance, taking the code above, if you wanted to truncate listys to its first two elements
by writing:
ys.drop(2).tail = Nil

you would also truncate lists zs and xs as a side effect.
Clearly, it would be quite difficult to keep track of what gets changed. That&#8217;s why Scala opts for
pervasive sharing and no mutation for lists. The ListBuffer class still allows you to build up lists
imperatively and incrementally, if you wish. But since list buffers are not lists, the types keep mutable
buffers and immutable lists separate.
The design of Scala&#8217;s List and ListBuffer is quite similar to what&#8217;s done in Java&#8217;s pair of
classesString and StringBuffer. This is no coincidence. In both situations the designers wanted to
maintain a pure immutable data structure but also provide an efficient way to construct this structure
incrementally. For Java and Scala strings, StringBuffers (or, in Java 5, StringBuilders) provide a way to
construct a string incrementally. For Scala&#8217;s lists, you have a choice: You can either construct lists
incrementally by adding elements to the beginning of a list using ::, or you use a list buffer for adding
elements to the end. Which one is preferable depends on the situation. Usually, :: lends itself well to
recursive algorithms in the divide-and-conquer style. List buffers are often used in a more traditional
loop-based style.
22.5 CONCLUSION
In this chapter, you saw how lists are implemented in Scala. List is one of the most heavily used data
structures in Scala, and it has a refined implementation. List&#8217;s two subclasses, Niland ::, are both case
classes. Instead of recursing through this structure, however, many core list methods are implemented
using a ListBuffer. ListBuffer, in turn, is carefully implemented so that it can efficiently build lists
without allocating extraneous memory. It is functional on the outside, but uses mutation internally to
speed up the common case where a buffer is discarded after toList has been called. After studying all of
this, you now know the list classes inside and out, and you might have learned an implementation trick
or two.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-17 23:52:21 EET
</div>
</div>
</body>
</html>
