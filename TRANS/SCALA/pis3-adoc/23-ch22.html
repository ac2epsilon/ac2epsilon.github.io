<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__22">Глава 22</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="__">Реалізація списків</h1>
<div class="paragraph"><p>Списки стали повсюдними в цій книзі. Клас <code>List</code>, можливо, є найбільш загально уживаний тип структурованих даних в Scala. Глава 16 показала вам, як використовувати списки. Ця глава "зриває покривадла", та трохи пояснює щодо того, як списки реалізовані в Scala.</p></div>
<div class="paragraph"><p>Знаючи внутрішню роботу класу <code>List</code> корисне з деяких причин. Ви набудете кращу ідею щодо відносної ефективності операцій списків, що допоможе вам писати швидкий та компактний код з використанням списків. Ви також набудете інструментарій з прийомів, що ви можете застосувати в розробці ваших власних бібліотек. Нарешті, клас <code>List</code> є витонченим застосуванням системи типів Scala загалом, та зокрема її узагальнених концепцій. Так що вивчання класу <code>List</code> поглибить ваше знання ціх областях.</p></div>
<div class="sect1">
<h2 id="_22_1__list_">22.1 Клас List, принципово</h2>
<div class="sectionbody">
<div class="paragraph"><p><code>List</code> не є "вбудований" як конструкція мови в Scala; списки визначені як абстрактний клас <code>List</code> в пакунку <code>scala</code>, що іде з двома субкласами, <code>::</code> та <code>Nil</code>. В цій главі ми презентуємо швидкий тур по класу <code>List</code>. Цей розділ представляє дещо спрощене пояснення цього класу, порівняно з його справжньою реалізацією в стандартній бібліотеці Scala, що розкривається в Розділі 22.3.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
</pre></div></div></div>
<div class="paragraph"><p>List є абстрактним класом, так що ви не можете визначити елементи через виклик порожнього конструктора <code>List</code>. Наприклад, вираз <code>new List</code> буде нелегальним. Клас має параметр типу <code>T</code>. Знак <code>+</code> перед цім параметром типу вказує, що списки є коваріантними, як обговорюється в Главі 19.</p></div>
<div class="paragraph"><p>Малюнок 22.1 - Ієрархія класів для списків Scala.</p></div>
<div class="paragraph"><p>Завдяки цій властивості ви можете присвоїти значення типу <code>List[Int]</code> до змінної типу <code>List[Any]</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span>
<span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Всі операції списків можуть бути виражені в термінах трьох базових методів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
<span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</pre></div></div></div>
<div class="paragraph"><p>Ці три методи всі абстрактні в класі <code>List</code>. Вони визначені в субоб'єкті <code>Nil</code> і субкласі <code>::</code>. Ієрархія для <code>List</code> показана на Малюнку 22.1.</p></div>
<div class="sect2">
<h3 id="___code_nil_code">Об'єкт <code>Nil</code></h3>
<div class="paragraph"><p>Об'єкт <code>Nil</code> визначає порожній список. Його визначення показане в Лістингу 22.1. Об'єкт <code>Nil</code> наслідує від типу <code>List[Nothing]</code>. Завдяки коваріантності це означає, що <code>Nil</code> сумісний з кожним примірником типу <code>List</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;head of empty list&quot;</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">&quot;tail of empty list&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.1 - Визначення об'єкта синглтона <code>Nil</code>.</p></div>
<div class="paragraph"><p>Три абстрактні метода класу <code>List</code> реалізовані в об'єкті <code>Nil</code> в прямолінійний спосіб: метод <code>isEmpty</code> повертає <code>true</code>, та методи <code>head</code> та <code>tail</code> обоє закидають виключення. Зауважте, що закидання виключення не тільки має сенс, але практично є єдиною можливою річчю, що можна робити для <code>head</code>: оскільки <code>Nil</code> є <code>List</code> з <code>Nothing</code>, тип результату <code>head</code> має бути <code>Nothing</code>. Оскільки немає значення цього типу, це означає, що <code>head</code> не може повернути звичайне значення. Він має повертатись ненормально, через закидання виключення.<span class="footnote"><br />[Щоб бути точним, типи також дозволяють <code>head</code> назавжди пійти в безкінечний цикл, замість закидання виключення, але це очевидно не те, що ми бажаємо.]<br /></span></p></div>
</div>
<div class="sect2">
<h3 id="__code_code">Клас <code>::</code></h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Клас <code>::</code>, вимовляється <code>"cons"</code> скорочено від <code>"construct"</code>, представляє непорожній список. Він названий в такий спосіб, щоб підтримувати співпадіння шаблонів з інфіксним <code>::</code>. Ви вже бачили в Розділі 16.5, що кожна інфіксна операція в шаблоні трактується як застосування конструктора інфіксного оператора до його аргументів. Так що шаблон `x 
</dt>
<dd>
<p>
xs` трактується як <code>::(x, xs)</code>, де <code>::</code> є кейс класом.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Ось визначення класу <code>::</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Реалізація класу <code>::</code> є прямолінійним. Він приймає два параметри, <code>hd</code> та <code>tl</code>, які представляють голову та хвіст списку, що має бути створений. Визначення методів <code>head</code> та <code>tail</code> просто повертають відповідний параметр. Фактично, цей шаблон може бути скорочений, дозволяючи параметрам напряму реалізувати методи <code>head</code> та <code>tail</code> суперкласу <code>List</code>, як в наступному еквівалентному, але коротшому визначенні класу <code>::</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span>
    <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, бо кожний параметр кейс класу неявно також є полем класу (це як декларація параметру, перед яким стоїть <code>val</code>). Згадайте з Розділу 20.3, що Scala дозволяє вам реалізовати абстрактний безпараметрний метод, як <code>head</code> або <code>tail</code>, за допомогою поля. Так що код вище напряму використовує параметри <code>head</code> та <code>tail</code> як реалізації абстрактних методів <code>head</code> та <code>tail</code>, що були наслідувані від класу <code>List</code>.</p></div>
</div>
<div class="sect2">
<h3 id="___">Ще декілька методів</h3>
<div class="paragraph"><p>Всі інші методи <code>List</code> можуть бути записані з використанням троьх базових методів. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">length</span>
</pre></div></div></div>
<div class="paragraph"><p>або:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">tail</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>або:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="o">::</span> <span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="__list">Конструювання List</h3>
<div class="dlist"><dl>
<dt class="hdlist1">
Методи конструювання списків, <code>::</code> та <code>:::</code>, є особливими. Оскільки вони закінчуються на двокрапку, вони прикріплені до свого правого операнду. Тобто, операція, така як `x 
</dt>
<dd>
<p>
xs` розглядається як виклик метода <code>xs.::(x)</code>, не <code>x.::(xs)</code>. Фактично, <code>x.::(xs)</code> не мало б сенсу, оскільки <code>x</code> має тип елементу списку, що може бути довільним, так що ми не можемо очікувати, що цей тип має метод <code>::</code>.
</p>
</dd>
</dl></div>
<div class="paragraph"><p>З цієї причини метод <code>::</code> має приймати значення елементу та видавати новий список. Який тип має бути в значень елементів? Ви можете спокуситись і сказати, що він має бути такий самий, що і тип елементів списку, але фактично це більш обмежливе, ніж треба.</p></div>
<div class="paragraph"><p>Щоб бачити чого, розглянемо таку ієрархію класів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.2 показує, що трапляється, коли ви конструююте списки фруктів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">apples</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Apple</span> <span class="o">::</span> <span class="nc">Nil</span>
<span class="n">apples</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Apple</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="nd">@e885c6a</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">fruits</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Orange</span> <span class="o">::</span> <span class="n">apples</span>
<span class="n">fruits</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Fruit</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Orange</span><span class="k">@</span><span class="mi">3</span><span class="n">f51b349</span><span class="o">,</span> <span class="nc">Apple</span><span class="nd">@e885c6a</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.2 - Підставлення елементу супертипа до списку субтипа.</p></div>
<div class="paragraph"><p>Значення <code>apples</code> трактується як <code>List</code> з <code>Apples</code>, як і очікувалось. Але визначення <code>fruits</code> показує, що все ще можливо додати елемент іншого типу до цього списку. Тип елементу отриманого списку буде <code>Fruit</code>, що є більш точним загальним супертипом елементів оригінального списку (<code>Apple</code>), і типу доданого елементу (<code>Orange</code>). Ця гнучкість отримана через визначення метода <code>::</code> (<code>cons</code>), як показано в Лістингу 22.3:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.3 - Визначення метода <code>::</code> (<code>cons</code>) в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Зауважте, що метод сам по собі поліморфний — він приймає параметр типу на ім'я U. Більше того, <code>U</code> обмежений в <code>[U &gt;: T]</code>, щоб він був супертипом типу елемента списку <code>T</code>. Елемент, що додається, має бути типу <code>U</code>, і результатом буде <code>List[U]</code>.</p></div>
<div class="paragraph"><p>С формулюванням <code>::</code>, показаним на Лістингу 22.3, ви можете перевірити, як визначення <code>fruits</code>, показана в Лістингу 22.2 робить с точки зору типів: в цьому визначенні параметр типу <code>U</code> в <code>::</code> виступає як примірник <code>Fruit</code>. Обмеження нижньої межі для <code>U</code> задовільняється, оскільки список <code>apples</code> має тип <code>List[Apple]</code>, і <code>Fruit</code> є супертипом для <code>Apple</code>. Аргументом <code>::</code> є <code>new Orange</code>, що відповідає типу <code>Fruit</code>. Таким чином, застосування метода є типо-коректним, з типом результату <code>List[Fruit]</code>. Малюнок 22.2 ілюструє структуру списків, що отримуються від виконання коду, показаного в Лістингу 22.2.</p></div>
<div class="paragraph"><p>Малюнок 22.2 - Структура списків Scala, показаного в Лістингу 22.2.</p></div>
<div class="paragraph"><p>Фактично, поліморфне визначення <code>::</code> з нижньою межею <code>T</code> не тільки зручне, але також потрібне щоб зробить визначення класу <code>List</code> типо-коректним. Це так, тому що <code>List</code> визначений як коваріантний.</p></div>
<div class="paragraph"><p>Уявімо на мить, що ми визначили <code>::</code> таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="c1">// Розумовий експеримент (що не буде робити)</span>
<span class="k">def</span> <span class="o">::(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачили в Главі 19, що параметри метода рахуються як контрваріантні позиції, так що тип елементів списку <code>T</code> є контрваріантної позицією в визначенні вище. Але тоді <code>List</code> не може бути декларований як коваріантний по <code>T</code>. Таким чином, нижня межа, <code>[U &gt;: T]</code>, убиває двох зайців з одного пострілу: вона прибирає проблему типізації, та призводить до того, що метод <code>::</code> стає більш гнучким в використанні. Метод конкатенації <code>:::</code> визначений в подібний до <code>::</code> спосіб, як показано в Лістингу 22.4.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="o">:::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">prefix</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.4 - Визначення метода <code>:::</code> в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Як і <code>cons</code>, конкатенація є поліморфною. Тип результату "поширений" як треба, щоб включати типи всіх елементів списку. Знову зауважте, що порядок аргументів переставлений в інфіксній операції та явному виклику метода. Оскільки обоє, <code>:::</code> та <code>::</code>, завершуються на дві крапки, вони обоє прив'язуються до правої сторони, та обоє право асоціативні. Наприклад, частина <code>else</code> визначення <code>:::</code>, показаний в Лістингу 22.4, містить інфіксні операції обох, <code>::</code> та <code>:::</code>.</p></div>
<div class="paragraph"><p>Ці інфіксні операції можуть бути розширені до еквівалентних методів, що викликаються таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскільки</span> <span class="o">::</span> <span class="n">та</span> <span class="o">:::</span> <span class="n">право</span> <span class="n">асоциативні</span><span class="o">)</span>

<span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">)</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскільки</span> <span class="o">::</span> <span class="n">прикріплюється</span> <span class="n">зправа</span><span class="o">)</span>

<span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
  <span class="n">дорівнює</span> <span class="o">(</span><span class="n">оскількі</span> <span class="o">:::</span> <span class="n">прикріплюється</span> <span class="n">зправа</span><span class="o">)</span>

<span class="k">this</span><span class="o">.:::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_22_2__listbuffer">22.2 Клас ListBuffer</h2>
<div class="sectionbody">
<div class="paragraph"><p>Типовий шаблон доступа до списків є рекурсивний. Наприклад, для інкрементації кожного елемента без використовування мапи, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs1</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Один з недоліків цього програмного шаблону є те, що вона не має хвостової рекурсії. Зауважте, що рекурсивний виклик до <code>incAll</code> вище, відбувається в операції <code>::</code>. Таким чином, кожний рекурсивний виклик потребує новий фрейм стеку.</p></div>
<div class="paragraph"><p>На сьогоднішніх віртуальних машинах це означає, що ви не можете застосувати <code>incAll</code> до списків з більше ніж <code>30000</code> або <code>50000</code> елементів. Це шкода. Як ви пишете версію <code>incAll</code>, що може робити зі списками довільного розміру (доки дозволяє місткість купи)?</p></div>
<div class="paragraph"><p>Один з підходів є використання циклу:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="c1">// ??</span>
</pre></div></div></div>
<div class="paragraph"><p>Але що має піти в тілі циклу? Зауважте, що тут <code>incAll</code> конструює список через перед-ставлення елементів до результату рекрсивного виклику, цикл потребує додавати нові елементи до кінця результуючого списку. Дуже неефективна можливість є використання <code>:::</code>, оператора додавання списку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">var</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span> <span class="c1">// дуже неефективний підхід</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">result</span> <span class="k">=</span> <span class="n">result</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">result</span>
</pre></div></div></div>
<div class="paragraph"><p>Це жахливо неефективне. Оскільки <code>:::</code> займає час, пропорційний до довжини його першого операнда, повна операція займає час, пропорційний до квадрату довжини списку. Зрозуміло, що це неприйнятне.</p></div>
<div class="paragraph"><p>Кращою альтернативою є використання спискового буфера. Списковий буфер дозволяє вам акумулювати елементи в списку. Щоб зробити це, ви використовуєте операцію, таку як <code>buf += elem</code>, що додає елемент <code>elem</code> в кінець спискового буфера <code>buf</code>. Коли ви скінчите додавати елементи, ви можете перетворити буфер на список, використовуючи операцію <code>toList</code>.</p></div>
<div class="paragraph"><p><code>ListBuffer</code> є класом в пакунку <code>scala.collection.mutable</code>. Щоб використовувати тільки просте ім'я, ви можете імпортувати <code>ListBuffer</code> з його пакунку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
</pre></div></div></div>
<div class="paragraph"><p>Використовуючи списковий буфер, тіло <code>incAll</code> тепер може бути записане таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дуже ефективний спосіб будувати списки. Фактично, реалізація спискового буфера організована таким чином, що обоє операції, додавання (<code>+=</code>) та <code>toList</code> займають (дуже короткий) сталий час.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_3__list__">22.3 Клас List на практиці</h2>
<div class="sectionbody">
<div class="paragraph"><p>Реалізація спискових методів, надане в Розділі 22.1, є стислі та зрозумілі, але потерпають від деяких проблем переповнення, як не-хвосто-рекурсивна реалізація <code>incAll</code>. Таким чином, більшість методів в реальних реалізаціях класу <code>List</code> уникають рекурсії, та замість цього використовують цикли з списковими буферами. Наприклад, Лістинг 22.5 показує справжню реалізацію <code>map</code> в класі <code>List</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
  <span class="k">var</span> <span class="n">these</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">these</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">these</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
    <span class="n">these</span> <span class="k">=</span> <span class="n">these</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
  <span class="n">b</span><span class="o">.</span><span class="n">toList</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.5 - Визначення метода <code>map</code> в класі <code>List</code>.</p></div>
<div class="paragraph"><p>Ця переглянута реалізація проходить по списку за допомогою простого циклу, що є дуже ефективним. Реалізація з хвостовою рекурсією може мати подібну ефективність, але загальна рекурсивна реалізація буде повільніша та менш маштабована. Але що до операції <code>b.toList</code> в кінці? Яка її складність? Фактично, виклик метода <code>toList</code> забирає тільки невелику кількість циклів, що не залежить від довжини списку.</p></div>
<div class="paragraph"><p>Щоб зрозуміти чому, накиньте другий погляд на клас <code>::</code>, що конструює непорожні списки. На практиці цей клас не повністю відповідає до його ідеалізованого визначення, попередньо наданому в Розділі 22.1. Справжнє визначення показане на Лістингу 22.6. Як ви можете бачити, є одна особливість: аргумент <code>tl</code> є <code>var</code>! Це означає, що можливо модифікувати хвіст списку після того, як цей список побудований. Однак, оскільки змінна <code>tl</code> має модифікатор <code>private[scala]</code>, він може бути доступний тільки в пакунку <code>scala</code>. Клієнтський код за межами цього пакунка ніколи не може ані читати, ні писати <code>tl</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">U</span><span class="o">,</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">scala</span><span class="o">]</span> <span class="k">var</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 22.6 - Визначення субкласа <code>::</code> в <code>List</code>.</p></div>
<div class="paragraph"><p>Оскільки клас <code>ListBuffer</code> міститься в субпакунку пакунка <code>scala</code>, <code>scala.collection.mutable</code>, <code>ListBuffer</code> може отримувати доступ до поля <code>tl</code> клітинки <code>cons</code>. Фактично, елементи спискового буфера представлени як список, та додавання нових елементів включає модифікацію поля <code>tl</code> останньої клітинки <code>::</code> цього списку. Ось початок класу <code>ListBuffer</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.collection.immutable</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Buffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">start</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">last0</span><span class="k">:</span> <span class="kt">::</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">exported</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">...</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите три приватні поля, що характерізують <code>ListBuffer</code>:</p></div>
<div class="paragraph"><p><code>start</code>     вказує на список з усіх елементів, що зберігаються в буфері
<code>last0</code>     вказує на останню клітину <code>::</code> в цьому списку
<code>exported</code>  вказує, чи буфер був перетворений на список за допомогою <code>toList</code></p></div>
<div class="paragraph"><p>Операція <code>toList</code> дуже проста:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">exported</span> <span class="k">=</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span>
  <span class="n">start</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Він повертає список елементів, на який посилається <code>start</code>, а також встановлює <code>true</code>, якщо цей список непорожній. Так що <code>toList</code> дуже ефективний, оскільки він не копіює список, що зберігається в <code>ListBuffer</code>. Але що відбувається, якщо список продовжує далі розширятись після операції <code>toList</code>? Звичайно, коли список повертається з <code>toList</code>, він має бути незмінним. Однак, додавання елемента <code>last0</code> буде модифікувати список, на який посилається <code>start</code>.</p></div>
<div class="paragraph"><p>Щоб підтримувати коректність операцій спискового буфера, вам треба робити замість цього на новому списку. Це досягається першим рядком в реалізації операції <code>+=</code>:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">override</span> <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">exported</span><span class="o">)</span> <span class="n">copy</span><span class="o">()</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">start</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">last1</span> <span class="k">=</span> <span class="n">last0</span>
    <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">last1</span><span class="o">.</span><span class="n">tl</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Ви бачите, що <code>+=</code> копіює список, на який вказує <code>start</code>, якщо <code>exported</code> є <code>true</code>. Так що, кінець кінцем, нічого не дається надурно. Якщо ви бажаєте перейти від списків, що можуть розширятись з кінця, до незмінних списків, тоді це потребуватиме деякого копіювання. Однак реалізація <code>ListBuffer</code> є такою, що копіювання необхідне тільки для спискових буферів, що продовжують розширюватись після того, як вони були перетворені на списки. Цей випадок досить рідкий на практиці. Більшість випадків використання для спискових буферів додають елементи послідовно, і потім роблять одну операцію <code>toList</code> в кінці. В таких випадках копіювання непотрібне.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_4__">22.4 Функціональність назовні</h2>
<div class="sectionbody">
<div class="paragraph"><p>В попередньому розділі ми показали ключові елементи реалізації Scala класів <code>List</code> та <code>ListBuffer</code>. Ви побачили, що списки повністю функціональні "назовні", але мають імперативну реалізацію з використанням спискових буферів "всередині". Це типова стратегія в Scala програмуванні — спроба комбінувати чистоту з ефективністю, через уважне розмежування впливу нечистих операцій.</p></div>
<div class="paragraph"><p>Але ви можете спитати, чому треба наполягати на чистоті? Чому просто не відкрити визначення списків, зробивши поле <code>tail</code>, а можливо і поле <code>head</code>, змінними? Недолік такого підходу в тому, що таким чином ви зробите програми значно більш крихкими. Зауважте, що конструювання списків за допомогою <code>::</code> повторно використовує <code>tail</code> конструйованого списку.</p></div>
<div class="paragraph"><p>Так що коли ви пишете:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">xs</span>
<span class="k">val</span> <span class="n">zs</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">::</span> <span class="n">xs</span>
</pre></div></div></div>
<div class="paragraph"><p>хвости списків <code>ys</code> та <code>zs</code> поділяються; вони вказують на ту саму структуру даних. Це основа для ефективності; якщо список <code>xs</code> копіювався б кожного разу, коли ви додаєте новий елемент до нього, це було б значно повільніше. Оскільки спільне використання є поширеним, зміна елементів списку, якщо б це було можливо, було б досить небезпечним. Наприклад, беручи код вище, якщо ви бажали б вкоротити список <code>ys</code> до двох перших елементів, і записали б це так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ys</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">tail</span> <span class="k">=</span> <span class="nc">Nil</span> <span class="c1">// цього не можна робити в Scala!</span>
</pre></div></div></div>
<div class="paragraph"><p>ви б також вкоротили списки <code>zs</code> та <code>xs</code> в якості побічного ефекту.</p></div>
<div class="paragraph"><p>Зрозуміло, що було б досить складно відстежити, що було змінено. Ось чому Scala обирає поширене поділення даних, та заборону на зміну списків. Клас <code>ListBuffer</code> все ще дозволяє вам будувати списки імперативно та інкрементально, якщо побажаєте. Але оскільки спискові буфери не є списками, типи, що містять змінні буфери та незмінні списки, тримаються окремо.</p></div>
<div class="paragraph"><p>Дизайн Scala <code>List</code> та <code>ListBuffer</code> досить подібні до того, що зроблене в Java з парою класів, <code>String</code> та <code>StringBuffer</code>. Це не випадковість. В обох ситуаціях розробники бажали підтримувати чисті незмінні структури даних, але також провадити ефективний спосіб сконструювати ці структури інкрементально. Для Java і Scala рядків, <code>StringBuffer</code> (або в Java 5 <code>StringBuilder</code>) провадять шлях конструювання рядка інкрементально. Для списків Scala ви маєте вибір: ви можете або конструювати списки інкрементально, через додавання елементів до початку списку з використанням <code>::</code>, або ви використовуєте списковий буфер для додавання елементів в кінець. Який має перевагу залежить від ситуації. Звичайно, <code>::</code> гарно проявляє себе в рекурсивних алгоритмах, в стилі поділяй-та-володій. Спискові буфери часто використовуються в більш традиційному стилі на основі циклів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_22_5_">22.5 Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили, як в Scala реалізовані списки. <code>List</code> є однією з найбільш тяжко використовуваних структур в Scala, і він має доопрацьовану реалізацію. Два субкласи <code>List</code>, <code>Nil</code> та <code>::</code>, обоє є кейс класами. Однак замість рекурсії по цій структурі, багато основних методів реалізовані з використанням <code>ListBuffer</code>. <code>ListBuffer</code>, в свою чергу, ретельно реалізований, так, щоб він міг ефективно будувати списки без розміщення додаткової пам'яті. Він зовні функціональний, але внутрішньо використовує змінність для прискорення загального випадку, коли буфер відкидаєть після виклику <code>toList</code>. Після вивчення всього цього, тепер ви знаєте класи списків ззовні та зсередини, і також ви вивчили один або два трюки реалізації.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-03-15 11:50:26 EET
</div>
</div>
</body>
</html>
