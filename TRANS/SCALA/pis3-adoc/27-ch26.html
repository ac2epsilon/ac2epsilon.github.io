<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__26">Глава 26</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_">Екстрактори</h1>
<div class="paragraph"><p>Тепер ви, можливо, зростили бажання мати стислий спосіб, яким дані можуть бути декомпоновані і проаналізовані з використанням співпадіння шаблонів. Ця глава показує вам,як надалі узагальнити цю концепцію. До цього часу шаблони конструкторів були пов'язані з кейс класами. Наприклад, <code>Some(x)</code> є валідним шаблоном, оскільки <code>Some</code> є кейс класом. Іноді ви будете бажати створити шаблон як цей,  без створення асоційованого кейс класу. Фактично, ви можете побажати створити власний різновид шаблону. Екстрактори дають вам спосіб зробити це. Ця глава пояснює, що таке екстрактори, і як ви їх можете використовувати для визначення шаблонів, що відділені від репрезентації об'єкта.</p></div>
<div class="sect1">
<h2 id="_26_1_____">26.1 Приклад: отриманння адреси електронної пошти</h2>
<div class="sectionbody">
<div class="paragraph"><p>Щоб проілюструвати проблему, яку використовує екстрактор, уявімо, що вам треба проаналізувати рядкі, що представляють адреси електронної пошти. Беручи рядок, ви бажаєте вирішити, чи є це адреса електронної пошти, або ні, та, якщо це так, ви бажаєте отримати доступ до частин користувача та домена цієї адреси. Традиційний спосіб зробити це задіє три допоміжні функції:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="k">def</span> <span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
</pre></div></div></div>
<div class="paragraph"><p>З ціма функціями ви можете розібрати наданий рядок таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span><span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">+</span> <span class="s">&quot; AT &quot;</span> <span class="o">+</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="k">else</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;not an email address&quot;</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Це робить, але дещо неоковирно. Що більше, речі ставатимуть складнішими, якщо вам треба зробити декілька такіх перевірок. Наприклад, ви можете побажати знайти дві послідовні рядки в списку, що обоє є адресами електрнної пошти з тим самим користувачем. Ви можете спробувати це самотужки, за допомогою попередньо визначених функцій доступу, щоб побачити, що для цього знадобиться.</p></div>
<div class="paragraph"><p>Ви вже бачили в Главі 15, що порівняння шаблонів є ідеальним для атак на проблеми як ця. Давайте на мить уявімо, що ви можете порівняти рядок з шаблоном:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Шаблон співпадатиме, якщо рядок містить символ <code>at</code> (<code>@</code>). В цьому випадку він може прикріпляти змінну <code>user</code> до частини рядка до <code>@</code>, та змінну <code>domain</code> до частини після нього. Постулюючи шаблон такого вигляду, попередній вираз може бути записаний більш ясно, ось так:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span> <span class="o">+</span> <span class="s">&quot; AT &quot;</span> <span class="o">+</span> <span class="n">domain</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;not an email address&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Більш складна проблема пошуку двох послідовних адрес з тим же користувачем буде транслюватись в наступний шаблон:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">ss</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u1</span><span class="o">,</span> <span class="n">d1</span><span class="o">)</span> <span class="o">::</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u2</span><span class="o">,</span> <span class="n">d2</span><span class="o">)</span> <span class="o">::</span> <span class="k">_</span> <span class="k">if</span> <span class="o">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це значно більш прийнятно, ніж будь-що, що може бути написане за допомогою функцій доступу. Однак проблема в тому, що рядкі не кейс класи; вони не мають репрезентації, що відповідає до <code>EMail(user, domain)</code>. Ось де з'являються екстрактори Scala: вони дозволяють вам визначити нові шаблони для вже визначених типів, де шаблон не має слідувати внутрішній репрезентації типу.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_2_">26.2 Екстрактори</h2>
<div class="sectionbody">
<div class="paragraph"><p>Екстрактором в Scala є об'єкт, що має метод з назвою <code>unapply`в якості свого члена. Призначення метода `unapply</code> є порівнювати значення та розбивати його на частини. Часто об'єкт екстрактора також визначає парний метод <code>apply</code> для побудови значень, але це не вимагається. Як приклад, Лістинг 26.1 показує об'єкт екстрактора для адрес електронної пошти:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">EMail</span> <span class="o">{</span>
  <span class="c1">// Метод ін&#39;єкції (опціональний)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">user</span> <span class="o">+</span> <span class="s">&quot;@&quot;</span> <span class="o">+</span> <span class="n">domain</span>

<span class="c1">// Метод екстракції (обов&#39;язковий)</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">str</span> <span class="n">split</span> <span class="s">&quot;@&quot;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.1 - Рядковий об'єкт <code>EMail</code> екстрактора.</p></div>
<div class="paragraph"><p>Цей об'єкт визначає одночасно методи <code>apply</code> та <code>unapply</code>. Метод <code>apply</code> має таке значення, як і завжди: він перетворює <code>EMail</code> в об'єкт, що може бути застосований до аргументів в дужках, в той же спосіб, як застосовуються методи. Так що ви можете написати <code>EMail("John", "epfl.ch")</code> для конструювання рядка <code>"John@epfl.ch"</code>. Щоб зробити це більш явним, ви можете також дозволити <code>EMail</code> наслідувати функціональний тип Scala, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">EMail</span> <span class="k">extends</span> <span class="o">((</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img src="./images/icons/note.png" alt="Note" />
</td>
<td class="content">Частина <code>(String, String) =&gt; String</code> декларації попереднього об'єкта означає те саме, що і <code>Function2[String, String, String]</code>, що декларує абстрактний метод <code>apply</code>, що реалізує <code>EMail</code>. Як результат цієї декларації ви можете, наприклад, передати <code>EMail</code> до метода, що очікує <code>Function2[String, String, String]</code>.</td>
</tr></table>
</div>
<div class="paragraph"><p>Метод <code>unapply</code> це те, що перетворює <code>EMail</code> в екстрактор. В деякому сенсі він обератє процес конструктора в <code>apply</code>. Коли <code>apply</code> приймає два рядки, та формує на їх основі рядок адреси, <code>unapply</code> приймає рядок адреси, та потенційно повертає два рядка: <code>user</code> та <code>domain</code> цієї адреси. Але <code>unapply</code> має також обробляти випадок, коли наданий рядок не є електронною адресою. Ось чому <code>unapply</code> повертає тип <code>Option</code> для пари рядків. Його результат є або <code>Some(user, domain)</code>, якщо рядок <code>str</code> є адресою з певними частинами <code>user</code> та <code>domain</code>,<span class="footnote"><br />[Як тут демонструється, де <code>Some</code> застосовується до тапла <code>(user, domain)</code>, ви можете полишити пару дужок, коли передаєте тапл до функції, що приймає один аргумент. Таким чином, <code>Some(user, domain)</code> означає те саме, що і <code>Some((user, domain))</code>.]<br /></span> або <code>None</code>, якщо <code>str</code> не є адресою електронної пошти. Ось деякі приклади:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">unapply</span><span class="o">(</span><span class="s">&quot;John@epfl.ch&quot;</span><span class="o">)</span> <span class="n">equals</span> <span class="nc">Some</span><span class="o">(</span><span class="s">&quot;John&quot;</span><span class="o">,</span> <span class="s">&quot;epfl.ch&quot;</span><span class="o">)</span>
<span class="n">unapply</span><span class="o">(</span><span class="s">&quot;John Doe&quot;</span><span class="o">)</span> <span class="n">equals</span> <span class="nc">None</span>
</pre></div></div></div>
<div class="paragraph"><p>Тепер, коли порівняння шаблонів натрапляє на шаблон, що посилається на об'єкт екстрактора, він викликає метод екстрактора <code>unapply</code> на виразі селектора. Наприклад, виконання кода:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">selectorString</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>буде призводити до виклика:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">selectorString</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачили до цього, цей виклик до <code>EMail.unapply</code> буде повертати або <code>None</code> або <code>Some(u, d)</code> для деяких значень, <code>u</code> для частини адреси <code>user</code>, та <code>d</code> для чистини <code>domain</code>. В випадку <code>None</code> шаблоне на співпадає, і система намагається порівняти інший шаблон, або схибить з виключенням <code>MatchError</code>. В випадку <code>Some(u, d)</code> шаблон співпадає, та його змінні прикріплюються до елементів повернутого значення. В попередньому порівнянні <code>user</code> буде зв'язано з <code>u</code>, та <code>domain</code> буде прив'язаний до <code>d</code>.</p></div>
<div class="paragraph"><p>В прикладі з шаблоном порівняння <code>EMail</code> тип <code>String</code> виразу селектора, <code>selectorString</code>, відповідає до типу аргумента <code>unapply</code> (що в прикладі також був <code>String</code>). Це досить загальне, але не обов'язкове. Також можливо використовувати екстрактор <code>EMail</code> для порівняння <code>match</code> виразів для більш загальних типів. Наприклад, щоб знайти, чи довільне значення <code>x</code> є рядком адреси електронної пошти, ви можете записати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Маючи цей код, порівнювач шаблонів зпочатку перевірить, чи надане значення <code>x</code> відповідає до <code>String</code>, тип параметру метода <code>EMail</code> <code>unapply</code>. Якщо він відповідає, значення приводиться до <code>String</code>, та співпадіння шаблонів продовжується як звичайно. Якщо він не відповідає, шаблон безпосередньо зазнає невдачі.</p></div>
<div class="paragraph"><p>В об'єкті <code>EMail</code> метод <code>apply</code> називається ін'єкцією, оскільки він приймає деякі аргументи, та отримує елемент наданої множини (в нашому випадку множину рядків, що є інтернет адресами). Метод <code>unapply</code> називається екстракцією, оскільки він бере елемент з тієї ж множини, та екстрагує деякі з його частин (в нашому випадку субрядки <code>user</code> та <code>domain</code>). Ін'єкції та екстракції часто групіюються разом в одному об'єкті, оскільки ви можете використовувати ім'я об'єкта для обох, конструктора та шаблона, що симулює домовленість про порівняння шаблонів для кейс класів. Однак також можливо визначити екстракцію в об'єкті без відповідної ін'єкції. Сам об'єкт називається екстрактором, безвідносно, чи має чи ні метод <code>apply</code>.</p></div>
<div class="paragraph"><p>Якщо метод ін'єкції включений, він має доповнювати метод екстракції. Наприклад, виклик:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">))</span>
</pre></div></div></div>
<div class="paragraph"><p>повинен повертати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>тобто та сама послідовність аргументів, огорнена в <code>Some</code>. Ідучи в іншому напрямку означає спочатку викликати метод <code>unapply</code>, та потім <code>apply</code>, як показано в наступному коді:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В уьому коді, якщо <code>match</code> на <code>obj</code> матиме успіх, ви очікуєте отримати той самий об'єкт від <code>apply</code>. Ці дві умови для дуальності <code>apply</code> та <code>unapply</code> є гарним принципом дизайну. Вони не примушуються Scala, але їх рекомендовано дотримуватись, коли розробляєте ваші екстрактори.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_3______">26.3 Шаблони з нулем або однією змінною</h2>
<div class="sectionbody">
<div class="paragraph"><p>Метод <code>unapply</code> в попередньому прикладі повертає пару значень елемента в разі успіху. Це легко узагальнити до шаблонів з більш ніж двома змінними. Щоб прікрипити <code>N</code> змінних, <code>unapply</code> має повертати тапл з N елементів, огорнутий в <code>Some</code>.</p></div>
<div class="paragraph"><p>Однак випадок, коли шаблон прикріплює лише одну змінну, трактується по-іншому. В Scala немає тапла з одним елементом. Щоб повернути тільки один елемент шаблону метод <code>unapply</code> просто огортає сам елемент в <code>Some</code>. Наприклад, об'єкт екстрактор, показаний на Лістингу 26.2, визначає <code>unapply</code> для рідків, що складається з деяких субрядків, з'являючись два рази поспіль:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Twice</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">s</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">half</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="n">length</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="n">half</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.2 - Об'єкт екстрактора рядків <code>Twice</code>.</p></div>
<div class="paragraph"><p>Також можливо, щоб шаблон екстрактора взагалі не прикріпляв жодних змінних. В цьому випадку відповідний метод <code>unapply</code> повертає логічне <code>true</code> для успіха, та <code>false</code> для невдачі. Наприклад, об'єкт екстрактора, показаний в Лістингу 26.3, характеризує рядкі, що складаються лише з великих літер:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">UpperCase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">toUpperCase</span> <span class="o">==</span> <span class="n">s</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.3 - Об'єкт екстрактора рядків <code>UpperCase</code>.</p></div>
<div class="paragraph"><p>На це раз екстрактор тільки визначає <code>unapply</code>, але не <code>apply</code>. Не буде сенсу з визначення <code>apply</code>, бо нічого конструювати. Наступна функція <code>userTwiceUpper</code> застосовує всі попередньо визначені екстрактори разом в своєму коді співпадіння шаблонів:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="nc">Twice</span><span class="o">(</span><span class="n">x</span> <span class="k">@</span> <span class="nc">UpperCase</span><span class="o">()),</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="s">&quot;match: &quot;</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">&quot; in domain &quot;</span> <span class="o">+</span> <span class="n">domain</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
    <span class="s">&quot;no match&quot;</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Перший шаблон цієї функції співпадає з рядками, що є адресами електронної пошти, чия частина <code>user</code> складається з двох входжень того самого рядка великими літерами. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;DIDI@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">match:</span> <span class="kt">DI</span> <span class="kt">in</span> <span class="kt">domain</span> <span class="kt">hotmail.com</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;DIDO@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span> <span class="k">match</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">&quot;didi@hotmail.com&quot;</span><span class="o">)</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">no</span> <span class="k">match</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що <code>UpperCase</code> в функції <code>userTwiceUpper</code> приймає порожній список параметрів. Цього неможливо оминути, бо тоді <code>match</code> буде тестувати на рівність з об'єктом <code>UpperCase</code>! Зауважте також, що хоча <code>UpperCase()</code> сам не прикріплює жодних змінних, все ще можливо асоціювати змінну з цілим шаблоном, що співпав. Щоб зробити це, ви використовуєте стантартну схему прикріплення змінних, пояснену в Розділі 15.2: форма <code>x @ UpperCase()</code> асоціює змінну з <code>x</code> шаблоном, співпавшим з <code>UpperCase()</code>. Наприклад, в першому виклику <code>userTwiceUpper</code> вище, <code>x</code> був прив'язаний до <code>"DI"</code>, оскільки це було значення, з яким порівнювався шаблон <code>UpperCase()</code>.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_4____">26.4 Екстрактори зі змінними аргументами</h2>
<div class="sectionbody">
<div class="paragraph"><p>Попередні методи екстракторів для електронної пошти всі повертали фіксоване число значень елеменів. Іноді це недостатньо гнучко. Наприклад, ви можете бажати порівняти на рядку, що містить ім'я домені, так щоб кожна частина домену зберігалась в іншому субшаблоні. Це дозволить вам виразити такі шаблони:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">dom</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;org&quot;</span><span class="o">,</span> <span class="s">&quot;acm&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;acm.org&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;com&quot;</span><span class="o">,</span> <span class="s">&quot;sun&quot;</span><span class="o">,</span> <span class="s">&quot;java&quot;</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;java.sun.com&quot;</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;net&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">&quot;a .net domain&quot;</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі речі аранжовані так, щоб домени витрачались в зворотньому порядку — від вищого рівня до субдоменів. Це зроблене так, щоб отримати більше вигод від шаблонів послідовностей. Ви бачили в Розділі 15.2, що шаблон підстановки послідовностей, <code>_*</code>, в кінці списку аргументів співпадає з любим залишком елементів в послідовності. Ця можливість більш корисна, якщо домени вищого рівня ідуть першими, оскільки тоді ви можете використовувати підстановки послідовностей для співпадіння субдоменів на довільну глибину.</p></div>
<div class="paragraph"><p>Залишається питання, як екстрактор може підтримувати співпадіння <code>vararg</code>, як показано в попередньому прикладі, де шаблони можуть мати змінне число субшаблонів. Методи <code>unapply</code>, що ми зустрічали до цього, недостатні, оскільки кожний з них повертає фіксоване число субелементів в випадку успіху. Щоб обробити цей випадок, Scala дозволяє визначити інший метод екстрактора спеціально для vararg співпадіння. Цей метод має назву <code>unapplySeq</code>. Щоб побачити, як це записується, подивіться на екстрактор <code>Domain</code>, показаний в Лістингу 26.4:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">Domain</span> <span class="o">{</span>
  <span class="c1">// Метод ін&#39;єкції (опціональний)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">parts</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="n">parts</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;.&quot;</span><span class="o">)</span>

  <span class="c1">// Метод екстракції (обов&#39;язковий)</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">whole</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">whole</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.4 - Об'єкт екстрактора рядків <code>Domain</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>Domain</code> визначає метод <code>unapplySeq</code>, що зпочатку розбиває рядок на частини, розділені крапками. Це робиться за допомогою Java метода <code>split</code> на рядках, що приймає регулярний вираз в якості аргумента. Цей результат <code>split</code> є масивом субрядків. Результат <code>unapplySeq</code> є цей масив з усіма елементами, також огорнутий в <code>Some</code>.</p></div>
<div class="paragraph"><p>Тип результату <code>unapplySeq</code> має відповідати до <code>Option[Seq[T]]</code>, де тип елемента <code>T</code> є довільним. Як ви бачили в Розділі 17.1, <code>Seq</code> є важливим класом в ієрархії колекцій Scala. Це загальний суперклас декількох класів, що описують різні типи послідовностей: <code>List</code>,<code>Array</code>, <code>WrappedString</code> та декілька інших.</p></div>
<div class="paragraph"><p>Для симетрії <code>Domain</code> також має метод <code>apply</code>, що будує рядок домену зі списку параметрів частин домена, що починається з домену вищого рівня. Як завжди, метод <code>apply</code> є опціональним.</p></div>
<div class="paragraph"><p>Ви можете використовувати естрактор <code>Domain</code> для отримання більш детальної інформації від адрес електронної пошти. Наприклад, щоб знайти всі адреси з ім'ям <code>"tom"</code> в деякому домені <code>".com"</code>, ви можете написати наступну функцію:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="s">&quot;tom&quot;</span><span class="o">,</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">&quot;com&quot;</span><span class="o">,</span> <span class="k">_</span><span class="o">*))</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Це дає очікувані результати:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;tom@sun.com&quot;</span><span class="o">)</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">true</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;peter@sun.com&quot;</span><span class="o">)</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">isTomInDotCom</span><span class="o">(</span><span class="s">&quot;tom@acm.org&quot;</span><span class="o">)</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо повернути деякі фіксовані елементи від <code>unapplySeq</code> разом зі змінною частиною. Це виражається через повернення всіх елементів в таплі, де змінна частина іде, як звичайно, останньою. Як приклад, Лістинг 26.5 показує новий екстрактор для адрес, де частина домена вже розширена в послідовність:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">object</span> <span class="nc">ExpandedEMail</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">email</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
      <span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">email</span> <span class="n">split</span> <span class="s">&quot;@&quot;</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\.&quot;</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.5 - Об'єкт екстрактора <code>ExpandedEMail</code>.</p></div>
<div class="paragraph"><p>Метод <code>unapplySeq</code> в <code>ExpandedEMail</code> повертає опціональне значення пари (<code>Tuple2</code>). Перший елемент в парі є частина <code>user</code>. Другий елемент є послідовність імен, що представляють домен. Ви можете зробити співпадіння на них, як звичайно:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">&quot;tom@support.epfl.ch&quot;</span>
<span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">tom</span><span class="nd">@support</span><span class="o">.</span><span class="n">epfl</span><span class="o">.</span><span class="n">ch</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">ExpandedEMail</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">topdom</span><span class="o">,</span> <span class="n">subdoms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=</span> <span class="n">s</span>
<span class="n">name</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">tom</span>
<span class="n">topdom</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">ch</span>
<span class="n">subdoms</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">WrappedArray</span><span class="o">(</span><span class="n">epfl</span><span class="o">,</span> <span class="n">support</span><span class="o">)</span>
</pre></div></div></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_5____">26.5 Екстрактори та шаблони послідовностей</h2>
<div class="sectionbody">
<div class="paragraph"><p>Ви бачили в Розділі 15.2, що ви можете отримати доступ до елементів списку або масива, використовуючи шаблони послідовностей, як тут:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span>
<span class="nc">Array</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Фактично, ці шаблони послідовностей всі реалізовані з використанням екстракторів в стандартній бібліотеці Scala. Наприклад, шаблони в формі <code>List(...)</code> стали можливі, оскільки об'єкт компанйон <code>scala.List</code> є екстрактором, що визначає метод <code>unapplySeq</code>. Лістинг 26.6 показує маючі відношення визначення:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">List</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">toList</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.6 - Екстрактор, що визначає метод <code>unapplySeq</code>.</p></div>
<div class="paragraph"><p>Об'єкт <code>List</code> містить метод <code>apply</code>, що приймає змінне число аргументів. Це те, що дозволяє вам писати вирази як цей:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="nc">List</span><span class="o">()</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
</pre></div></div></div>
<div class="paragraph"><p>Він також містить метод <code>unapplySeq</code>, що повертає всі елементи зі списка як послідовність. Ось що підтримує шаблони <code>List(...)</code>. Дуже подібні визначення існують в об'єкті <code>scala.Array</code>. Вони підтримують ін'єкції та екстрактори для масивів.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_6____">26.6 Екстрактори проти кейс класів</h2>
<div class="sectionbody">
<div class="paragraph"><p>Навіть якщо вони і дуже корисні, кейс класи мають одне обмеження: вони демонструють дійсну репрезентацію даних. Це означає, що імя класу в шаблоні конструктора відповідає конкретній репрезентації типу об'єкта селектора. Якщо співпадіння з:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">case</span> <span class="n">C</span><span class="o">(...)</span>
</pre></div></div></div>
<div class="paragraph"><p>успішне, ви знаєте, що вираз селектора є примірником класу <code>C</code>.</p></div>
<div class="paragraph"><p>Екстрактори руйнують цей зв'язок між репрезентацією даних та шаблонами. Ви бачили в прикладах в цьому розділі, що вони дозволяють шаблони, що не мають нічого загального з типом даних об'єкта, що вибирається. Ця властивість називається незалежністю від репрезентації. В відкритих системах великого розміру незалежність від репрезентації дуже важлива, оскільки вона дозволяє вам змінити тип реалізації, що використовується в множині компонент, без впливу на клієнтів ціх компонент.</p></div>
<div class="paragraph"><p>Якщо ваш компонент був визначений та експортований як набір кейс класів, ви будете прив'язані до них, оскільки клієнтській код завжди може містити порівняння шаблонів на ці кейс класи. Переіменування деяких кейс класів або змінення ієрархії класів буде впливати на клієнтський код. Екстрактори не поділяють цю проблему, оскільки вони представляють прошарок перенаправлення між репрезентацією даних та способом, як їх бачать клієнти. Ви все ще можете змінити конкретну репрезентацію типу, доки ви оновлюєте всі ваші екстрактори разом з цім.</p></div>
<div class="paragraph"><p>Незалежність від репрезентації є важливою перевагою екстракторів над кейс класами. З іншого боку кейс класи також мають деякі переваги над екстракторами. Перше, вони значно простіші для встановлення та визначення, та вони потребують меньше коду. Друге, вони звичайно призводять до більш ефективного порівняння шаблонів, ніж екстрактори, оскільки компілятор Scala може оптимізувати шаблони по кейс класам значно краще, ніж по екстракторам. Це так тому, що механізми кейс класів фіксовані, тоді як методи <code>unapply</code> або <code>unapplySeq</code> в екстракторі можуть робити майже все. Третє, якщо ваші кейс класи наслідують від закоркованого базового класа, компілятор Scala буде перевіряти ваше співпадіння шаблонів на вичерпність, та буде скаржитись, якщо деяка комбінація можливих значень не покрита шаблоном. Для екстракторів така перевірка на вичерпність не доступна.</p></div>
<div class="paragraph"><p>То який з двох методів ви маєте обрати для ваших порівнянь шаблонів? Це залежить від декількох факторів. Якщо ви пишете код для закритого застосування, кейс класи звичайно мають перевагу, завдяки їх стислості, швидкості та статичній перевірці. Якщо ви потім вирішите змінити вашу ієрархію класів, застосування буде вимагати рефакторингу, але це звичайно не проблема. З іншого боку, якщо вам треба показати клас невідомим клієнтам, екстрактори можуть переважити, оскільки вони підтримують незалежність від репрезентації.</p></div>
<div class="paragraph"><p>Нащастя, вам не треба вирішувати прямо зараз. Ви можете в любому випадку почати з кейс класів, і потім, коли постане потреба, змінити їх на екстрактори. Оскільки шаблони по екстракторам та шаблони по кейс класах виглядають так само в Scala, порівняння шаблонів в ваших клієнтах буде продовжувати робити.</p></div>
<div class="paragraph"><p>Звичайно, також існують ситуації, коли ясно з самого початку, що структура ваших шаблонів не співпадає з репрезентацією типу ваших даних. Обговорена адреса електронної пошти в цій главі є одним з таких прикладів. В такому випадку екстрактори є єдиним можливим вибором.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_26_7__">26.7 Регулярні вирази</h2>
<div class="sectionbody">
<div class="paragraph"><p>Одна виключено корисна оболасть застосування екстракторів є регулярні вирази. Як і Java, Scala провадить регулярні вирази через бібліотеку, але екстрактори роблять більш приємною взаємодію з ними.</p></div>
<div class="sect2">
<h3 id="___">Формування регулярних виразів</h3>
<div class="paragraph"><p>Scala наслідує синтаксис своїх регулярних виразів від Java, що, в свою чергу, наслідує більшість з можливостей від Perl. Ми вважатимемо, що ви вже знаєте синтаксис; якщо ні, існує багато доступних інструкцій, починаючи з документації Javadoc для класа <code>java.util.regex.Pattern</code>. Ось тільки деякі приклади, що повинні бути достатні для нагадування:</p></div>
<div class="tableblock">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">ab?</p></td>
<td align="left" valign="top"><p class="table"><code>'a'</code>, за яким можливо іде <code>'b'</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[1em] \d+</p></td>
<td align="left" valign="top"><p class="table">Число, що складається з одної або більше цифр, представлених <code>\d</code>.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[a-dA-D]\w*</p></td>
<td align="left" valign="top"><p class="table">Слово, що починається з літери між <code>a</code> та <code>d</code> в верхньому або нижньому реєстрі, за яким іде послідовність з нуля або більше "слівних  символів", позначених <code>\w</code>. (Слівні символи це літери, цифри та підкреслення.)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">[1em](-)?(\d+)(\.\d*)?</p></td>
<td align="left" valign="top"><p class="table">Число, що складається з опціонального знаку мінуса, за яким слідує одна або більше цифр, за якими опціонально слідує крапка, та нуль або більше цифр. Число складається з трьох груп, тобто знаку мінусу, частини до десятичної крапки, та дрібної частини. Групи оточені дужками.</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Клас регулярних виразів Scala знаходиться в пакунку <code>scala.util.matching</code>.</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.util.matching.Regex</span>
</pre></div></div></div>
<div class="paragraph"><p>Значення нового регулярного виразу створено через передачу рядка до конструктора <code>Regex</code>. Наприклад:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">&quot;(-)?(\\d+)(\\.\\d*)?&quot;</span><span class="o">)</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Зауважте, що порівняно з регулярним виразом для десятичних чисел, наданого перед цім, кожна зворотня коса надаєтся двічі в рядку вище. Це через те, що в Java та Scala поодинока зворотня коса є символом виключення в рядковому літералі, а не звичайним символом, що показується в рядку. Так що замість <code>'\'</code> вам треба писати <code>'\\'</code> щоб отримати поодиноку зворотню косу в рядку.</p></div>
<div class="paragraph"><p>Якщо регулярний вираз містить багато зворотніх косих, це може бути болісним для написання та читання. Сирі рядки Scala провадять альтернативу. Як ви бачили в Розділі 5.2, сирий рядок є послідовність символів між потроєними лапками. Різниця між сиром та звичайним рядком в тому, що всі символи в сирому рядку з'являються саме так, як вони надрукувані. Це включає зворотні косі, що не трактуються як символи виключення. Так що ви можете і дещо більш зрозуміле:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">)</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Як ви бачите з виводу інтерпретатора, згенерований значення результату для <code>Decimal</code> точно таке, як і раніше. Інший, навіть коротший шлях написати регулярний вираз в Scala, є такий:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>
</pre></div></div></div>
<div class="paragraph"><p>Іншими словами, просто додайте <code>.r</code> до рядка для отримання регулярного виразу. Це можливо, оскільки існує метод на ім'я <code>r</code> в класі <code>StringOps</code>, що конвертує рядок на регулярний вираз. Метод визначений як показано в Лістингу 26.7:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="k">package</span> <span class="nn">scala.runtime</span>
<span class="k">import</span> <span class="nn">scala.util.matching.Regex</span>

<span class="k">class</span> <span class="nc">StringOps</span><span class="o">(</span><span class="n">self</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">...</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="k">def</span> <span class="n">r</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
<span class="o">}</span>
</pre></div></div></div>
<div class="paragraph"><p>Лістинг 26.7 - Як метод <code>r</code> визначений в <code>StringOps</code>.</p></div>
</div>
<div class="sect2">
<h3 id="____2">Пошук регулярних виразів</h3>
<div class="paragraph"><p>Ви можете пошукати появи регулярного виразу в рядку, використовуючи різні оператори:</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findFirstIn str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить першу появу регулярного виразу <code>regex</code> в рядку <code>str</code>, повертаючи результат в типі <code>Option</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findAllIn str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить всі появи регулярного виразу <code>regex</code> в рядку <code>str</code>, повертаючи результат як <code>Iterator</code>.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>regex findPrefixOf str</code></pre>
</div></div>
<div class="paragraph"><p>Знаходить появу регулярного виразу <code>regex</code> на початку рядка <code>str</code>, повертаючи результат в типі <code>Option</code>. Наприклад, ви можете визначити вхідну послідовність нижче, та пошукати в ній десятичні числа:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">&quot;&quot;&quot;(-)?(\d+)(\.\d*)?&quot;&quot;&quot;</span><span class="o">.</span><span class="n">r</span>
<span class="nc">Decimal</span><span class="k">:</span> <span class="kt">scala.util.matching.Regex</span> <span class="o">=</span> <span class="o">(-)?(\</span><span class="n">d</span><span class="o">+)(\.\</span><span class="n">d</span><span class="o">*)?</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">input</span> <span class="k">=</span> <span class="s">&quot;for -1.0 to 99 by 3&quot;</span>
<span class="n">input</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="k">for</span> <span class="o">-</span><span class="mf">1.0</span> <span class="n">to</span> <span class="mi">99</span> <span class="n">by</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
<span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
<span class="o">-</span><span class="mf">1.0</span>
<span class="mi">99</span>
<span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Decimal</span> <span class="n">findFirstIn</span> <span class="n">input</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(-</span><span class="mf">1.0</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Decimal</span> <span class="n">findPrefixOf</span> <span class="n">input</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>
</pre></div></div></div>
</div>
<div class="sect2">
<h3 id="_____">Екстракція за допомогою регулярних виразів</h3>
<div class="paragraph"><p>Більше того, кожний регулярний вираз в Scala визначає екстрактор. Екстрактор використовується для ідентифкації субрядків, що співпадають з групами регулярного виразу. Наприклад, ви можете декомпонувати рядок числа таким чином:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;-1.23&quot;</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">-</span>
<span class="n">integerpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">decimalpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">.</span><span class="mi">23</span>
</pre></div></div></div>
<div class="paragraph"><p>В цьому прикладі шаблон <code>Decimal(...)</code> використовується в визначенні <code>val</code>, як описано в Розділі 15.7. Що тут відбувається, це значення регулярного виразу <code>Decimal</code> визначає метод <code>unapplySeq</code>. Цей метод співпадає з кожним рядком, що відповідає до синтаксису регулярного виразу для десятичних чисел. Якщо рядок співпадає, частини відповідно до трьох груп в регулярному виразі <code>(-)?(\d+) (\.\d*)?</code> повертаються як елементи шаблону, та потім співпадають з трома змінними шаблону: <code>sign</code>, <code>integerpart</code> та <code>decimalpart</code>. Якщо група відсутня, значення встановлюється в <code>null</code>, як можна бачити в наступному прикладі:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">&quot;1.0&quot;</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="kc">null</span>
<span class="n">integerpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">decimalpart</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">.</span><span class="mi">0</span>
</pre></div></div></div>
<div class="paragraph"><p>Також можливо міксувати екстрактори з пошуком регулярних виразів в  <code>for</code> виразах. Наприклад, наступний вираз декомпонує всі десятичні числа, що він знайде у вхідному рядку:</p></div>
<div class="listingblock">
<div class="content"><div class="highlight"><pre><span></span><span class="n">scala</span><span class="o">&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="nc">Decimal</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
          <span class="n">println</span><span class="o">(</span><span class="s">&quot;sign: &quot;</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">&quot;, integer: &quot;</span> <span class="o">+</span>
              <span class="n">i</span> <span class="o">+</span> <span class="s">&quot;, decimal: &quot;</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">-</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">1</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">.</span><span class="err">0</span>
<span class="kt">sign:</span> <span class="kt">null</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">99</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">null</span>
<span class="n">sign</span><span class="k">:</span> <span class="kt">null</span><span class="o">,</span> <span class="n">integer</span><span class="k">:</span> <span class="err">3</span><span class="o">,</span> <span class="n">decimal</span><span class="k">:</span> <span class="kt">null</span>
</pre></div></div></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="__2">Висновок</h2>
<div class="sectionbody">
<div class="paragraph"><p>В цій главі ви бачили, як узагальнити співпадіння шаблонів за допомогою екстракторів. Екстрактори дозволяють вам визначити ваші власні типи шаблонів, що не мають відповідати типу виразів, по яких ви робите вибірку. Це дає вам більше гнучкості в типах шаблонів, що ви можете використовувати для співпадіння. Ефективно це як мати різні можливі погляди на ті самі дані. Це також дає вам прошарок між репрезентацією типа, та тим, як клієнт бачить його. Це дозволяє вам робити порівняння шаблонів, при цьому підтримуючи незалежність репрезентації, властивість, що дуже корисна в великих програмних системах.</p></div>
<div class="paragraph"><p>Екстрактори - це ще один елемент серед ваших інструментів, що дозволяє вам визначити гнучкі абстракції бібліотеки. Вони потужно використовуються в бібліотеках Scala, наприклад, для зручного порівняння регулярних виразів.</p></div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-04-12 02:42:46 EEST
</div>
</div>
</body>
</html>
