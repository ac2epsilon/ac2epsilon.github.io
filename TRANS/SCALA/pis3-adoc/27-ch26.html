<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.10" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}
pre {
  white-space: pre-wrap;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; vertical-align: text-bottom; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
.highlight .hll { background-color: #ffffcc }
.highlight  { background: #f8f8f8; }
.highlight .c { color: #408080; font-style: italic } /* Comment */
.highlight .err { border: 1px solid #FF0000 } /* Error */
.highlight .k { color: #008000; font-weight: bold } /* Keyword */
.highlight .o { color: #666666 } /* Operator */
.highlight .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #BC7A00 } /* Comment.Preproc */
.highlight .c1 { color: #408080; font-style: italic } /* Comment.Single */
.highlight .cs { color: #408080; font-style: italic } /* Comment.Special */
.highlight .gd { color: #A00000 } /* Generic.Deleted */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #FF0000 } /* Generic.Error */
.highlight .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.highlight .gi { color: #00A000 } /* Generic.Inserted */
.highlight .go { color: #808080 } /* Generic.Output */
.highlight .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.highlight .gt { color: #0040D0 } /* Generic.Traceback */
.highlight .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.highlight .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.highlight .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.highlight .kp { color: #008000 } /* Keyword.Pseudo */
.highlight .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #B00040 } /* Keyword.Type */
.highlight .m { color: #666666 } /* Literal.Number */
.highlight .s { color: #BA2121 } /* Literal.String */
.highlight .na { color: #7D9029 } /* Name.Attribute */
.highlight .nb { color: #008000 } /* Name.Builtin */
.highlight .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.highlight .no { color: #880000 } /* Name.Constant */
.highlight .nd { color: #AA22FF } /* Name.Decorator */
.highlight .ni { color: #999999; font-weight: bold } /* Name.Entity */
.highlight .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #0000FF } /* Name.Function */
.highlight .nl { color: #A0A000 } /* Name.Label */
.highlight .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.highlight .nt { color: #008000; font-weight: bold } /* Name.Tag */
.highlight .nv { color: #19177C } /* Name.Variable */
.highlight .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #666666 } /* Literal.Number.Float */
.highlight .mh { color: #666666 } /* Literal.Number.Hex */
.highlight .mi { color: #666666 } /* Literal.Number.Integer */
.highlight .mo { color: #666666 } /* Literal.Number.Oct */
.highlight .sb { color: #BA2121 } /* Literal.String.Backtick */
.highlight .sc { color: #BA2121 } /* Literal.String.Char */
.highlight .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.highlight .s2 { color: #BA2121 } /* Literal.String.Double */
.highlight .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.highlight .sh { color: #BA2121 } /* Literal.String.Heredoc */
.highlight .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.highlight .sx { color: #008000 } /* Literal.String.Other */
.highlight .sr { color: #BB6688 } /* Literal.String.Regex */
.highlight .s1 { color: #BA2121 } /* Literal.String.Single */
.highlight .ss { color: #19177C } /* Literal.String.Symbol */
.highlight .bp { color: #008000 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #19177C } /* Name.Variable.Class */
.highlight .vg { color: #19177C } /* Name.Variable.Global */
.highlight .vi { color: #19177C } /* Name.Variable.Instance */
.highlight .il { color: #666666 } /* Literal.Number.Integer.Long */


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="book">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="__26">Глава 26</h2>
<div class="sectionbody">
</div>
</div>
<h1 id="_">Екстрактори</h1>
<div class="paragraph"><p>By now you have probably grown accustomed to the concise way data can be decomposed and
analyzed using pattern matching. This chapter shows you how to generalize this concept further. Until
now, constructor patterns were linked to case classes. For instance, Some(x) is a valid pattern
because Some is a case class. Sometimes you might wish that you could write patterns like this without
creating an associated case class. In fact, you might wish to be able to create your own kinds of
patterns. Extractors give you a way to do so. This chapter explains what extractors are and how you can
use them to define patterns that are decoupled from an object&#8217;s representation.
26.1 AN EXAMPLE: EXTRACTING EMAIL ADDRESSES
To illustrate the problem extractors solve, imagine that you need to analyze strings that represent email
addresses. Given a string, you want to decide whether it is an email address or not, and, if it is, you
want to access the user and domain parts of the address. The traditional way to do this uses three helper
functions:
def isEMail(s: String): Boolean
def domain(s: String): String
def user(s: String): String
With these functions, you could parse a given string s as follows:
if (isEMail(s)) println(user(s) + " AT " + domain(s))
else println("not an email address")
This works, but is kind of clumsy. What&#8217;s more, things would become more complicated if you
combined several such tests. For instance you might want to find two successive strings in a list that are
both email addresses with the same user. You can try this yourself with the access functions defined
previously to see what would be involved.
You saw already in Chapter 15 that pattern matching is ideal for attacking problems like this. Let&#8217;s
assume for the moment that you could match a string with a pattern:
EMail(user, domain)
The pattern would match if the string contained an embedded at sign (@). In that case it would bind
variable user to the part of the string before the @ and variable domain to the part after it. Postulating a
pattern like this, the previous expression could be written more clearly like this:
s match {
case EMail(user, domain) &#8658; println(user + " AT " + domain)
case _ &#8658; println("not an email address")
}The more complicated problem of finding two successive email addresses with the same user part
would translate to the following pattern:
ss match {
case EMail(u1, d1) :: EMail(u2, d2) :: _ if (u1 == u2) &#8658; &#8230;
&#8230;
}
This is much more legible than anything that could be written with access functions. However, the
problem is that strings are not case classes; they do not have a representation that conforms
to EMail(user, domain). This is where Scala&#8217;s extractors come in: they let you define new patterns for
pre-existing types, where the pattern need not follow the internal representation of the type.
26.2 EXTRACTORS
An extractor in Scala is an object that has a method called unapply as one of its members. The purpose
of that unapply method is to match a value and take it apart. Often, the extractor object also defines a
dual method apply for building values, but this is not required. As an example, Listing 26.1 shows an
extractor object for email addresses:
object EMail {

def apply(user: String, domain: String) = user + "@" + domain
}

def unapply(str: String): Option[(String, String)] = {
val parts = str split "@"
if (parts.length == 2) Some(parts(0), parts(1)) else None
}
Listing 26.1 - The EMail string extractor object.
This object defines both apply and unapply methods. The apply method has the same meaning as
always: it turns EMail into an object that can be applied to arguments in parentheses in the same way a
method is applied. So you can write EMail("John", "epfl.ch") to construct the string"John@epfl.ch". To
make this more explicit, you could also let EMail inherit from Scala&#8217;s function type, like this:
object EMail extends ((String, String) &#8658; String) { &#8230; }
Note
The "(String, String) &#8658; String" portion of the previous object declaration means the same
as Function2[String, String, String], which declares an abstract apply method that EMail implements.
As a result of this declaration, you could, for example, passEMail to a method expecting
a Function2[String, String, String].
The unapply method is what turns EMail into an extractor. In a sense, it reverses the construction
process of apply. Where apply takes two strings and forms an email address string out ofthem, unapply takes an email address and returns potentially two strings: the user and the domain of the
address. But unapply must also handle the case where the given string is not an email address. That&#8217;s
why unapply returns an Option-type over pairs of strings. Its result is either Some(user, domain) if the
string str is an email address with the given user and domainparts,<span class="footnote"><br />[As demonstrated here, where Some is applied to the tuple, (user, domain), you can leave off one pair of parentheses when passing a tuple to a function that takes a single argument. Thus,Some(user, domain) means the same as Someuser.]<br /></span> or None, if str is not an email
address. Here are some examples:
unapply("John@epfl.ch") equals Some("John", "epfl.ch")
unapply("John Doe") equals None
Now, whenever pattern matching encounters a pattern referring to an extractor object, it invokes the
extractor&#8217;s unapply method on the selector expression. For instance, executing the code:
selectorString match { case EMail(user, domain) &#8658; &#8230; }
would lead to the call:
EMail.unapply(selectorString)
As you saw previously, this call to EMail.unapply will return either None or Some(u, d), for some
values u for the user part of the address and d for the domain part. In the None case, the pattern does
not match, and the system tries another pattern or fails with a MatchError exception. In
the Some(u, d) case, the pattern matches and its variables are bound to the elements of the returned
value. In the previous match, user would be bound to u and domain would be bound tod.
In the EMail pattern matching example, the type String of the selector expression,selectorString,
conformed to unapply&#8217;s argument type (which in the example was also String). This is quite common,
but not necessary. It would also be possible to use the EMail extractor to match selector expressions for
more general types. For instance, to find out whether an arbitrary value x was an email address string,
you could write:
val x: Any = &#8230;
x match { case EMail(user, domain) &#8658; &#8230; }
Given this code, the pattern matcher will first check whether the given value x conforms toString, the
parameter type of EMail&#8217;s unapply method. If it does conform, the value is cast toString and pattern
matching proceeds as before. If it does not conform, the pattern fails immediately.
In object EMail, the apply method is called an injection, because it takes some arguments and yields an
element of a given set (in our case: the set of strings that are email addresses). Theunapply method is
called an extraction, because it takes an element of the same set and extracts some of its parts (in our
case: the user and domain substrings). Injections and extractions are often grouped together in one
object, because then you can use the object&#8217;s name for both a constructor and a pattern, which simulates
the convention for pattern matching with case classes. However, it is also possible to define an
extraction in an object without a corresponding injection. The object itself is called an extractor,
regardless of whether or not it has an apply method.
If an injection method is included, it should be the dual to the extraction method. For instance, a call of:EMail.unapply(EMail.apply(user, domain))
should return:
Some(user, domain)
i.e., the same sequence of arguments wrapped in a Some. Going in the other direction means running
first the unapply and then the apply, as shown in the following code:
EMail.unapply(obj) match {
case Some(u, d) &#8658; EMail.apply(u, d)
}
In that code, if the match on obj succeeds, you&#8217;d expect to get back that same object from theapply.
These two conditions for the duality of apply and unapply are good design principles. They are not
enforced by Scala, but it&#8217;s recommended to keep to them when designing your extractors.
26.3 PATTERNS WITH ZERO OR ONE VARIABLES
The unapply method of the previous example returned a pair of element values in the success case. This
is easily generalized to patterns of more than two variables. To bind N variables, anunapply would
return an N-element tuple, wrapped in a Some.
The case where a pattern binds just one variable is treated differently, however. There is no one-tuple in
Scala. To return just one pattern element, the unapply method simply wraps the element itself in
a Some. For example, the extractor object shown in Listing 26.2 defines applyand unapply for strings
that consist of the same substring appearing twice in a row:
object Twice {
def apply(s: String): String = s + s
def unapply(s: String): Option[String] = {
val length = s.length / 2
val half = s.substring(0, length)
if (half == s.substring(length)) Some(half) else None
}
}
Listing 26.2 - The Twice string extractor object.
It&#8217;s also possible that an extractor pattern does not bind any variables. In that case the
corresponding unapply method returns a boolean—true for success and false for failure. For instance,
the extractor object shown in Listing 26.3 characterizes strings consisting of all uppercase characters:
object UpperCase {
def unapply(s: String): Boolean = s.toUpperCase == s
}
Listing 26.3 - The UpperCase string extractor object.
This time, the extractor only defines an unapply, but not an apply. It would make no sense to define
an apply, as there&#8217;s nothing to construct.The following userTwiceUpper function applies all previously defined extractors together in its pattern
matching code:
def userTwiceUpper(s: String) = s match {
case EMail(Twice(x @ UpperCase()), domain) &#8658;
"match: " + x + " in domain " + domain
case _ &#8658;
"no match"
}
The first pattern of this function matches strings that are email addresses whose user part consists of
two occurrences of the same string in uppercase letters. For instance:
scala&gt; userTwiceUpper("DIDI@hotmail.com")
res0: String = match: DI in domain hotmail.com
scala&gt; userTwiceUpper("DIDO@hotmail.com")
res1: String = no match
scala&gt; userTwiceUpper("didi@hotmail.com")
res2: String = no match
Note that UpperCase in function userTwiceUpper takes an empty parameter list. This cannot be omitted
as otherwise the match would test for equality with the object UpperCase! Note also that, even
though UpperCase() itself does not bind any variables, it is still possible to associate a variable with the
whole pattern matched by it. To do this, you use the standard scheme of variable binding explained
in Section 15.2: the form x @ UpperCase() associates the variable xwith the pattern matched
by UpperCase(). For instance, in the first userTwiceUpper invocation above, x was bound to "DI",
because that was the value against which the UpperCase() pattern was matched.
26.4 VARIABLE ARGUMENT EXTRACTORS
The previous extraction methods for email addresses all returned a fixed number of element values.
Sometimes, this is not flexible enough. For example, you might want to match on a string representing
a domain name, so that every part of the domain is kept in a different sub-pattern. This would let you
express patterns such as the following:
dom match {
case Domain("org", "acm") &#8658; println("acm.org")
case Domain("com", "sun", "java") &#8658; println("java.sun.com")
case Domain("net", _*) &#8658; println("a .net domain")
}
In this example things were arranged so that domains are expanded in reverse order—from the top-
level domain down to the sub-domains. This was done so that you could better profit from sequence
patterns. You saw in Section 15.2 that a sequence wildcard pattern, _*, at the end of an argument list
matches any remaining elements in a sequence. This feature is more useful if the top-level domain
comes first, because then you can use sequence wildcards to match sub-domains of arbitrary depth.The question remains how an extractor can support vararg matching as shown in the previous example,
where patterns can have a varying number of sub-patterns. The unapplymethods encountered so far are
not sufficient, because they each return a fixed number of sub-elements in the success case. To handle
this case, Scala lets you define a different extraction method specifically for vararg matching. This
method is called unapplySeq. To see how it is written, have a look at the Domain extractor, shown
in Listing 26.4:
object Domain {

def apply(parts: String*): String =
parts.reverse.mkString(".")
}

def unapplySeq(whole: String): Option[Seq[String]] =
Some(whole.split("\\.").reverse)
Listing 26.4 - The Domain string extractor object.
The Domain object defines an unapplySeq method that first splits the string into parts separated by
periods. This is done using Java&#8217;s split method on strings, which takes a regular expression as its
argument. The result of split is an array of substrings. The result ofunapplySeq is then that array with
all elements reversed and wrapped in a Some.
The result type of an unapplySeq must conform to Option[Seq[T]], where the element type T is
arbitrary. As you saw in Section 17.1, Seq is an important class in Scala&#8217;s collection hierarchy. It&#8217;s a
common superclass of several classes describing different kinds of
sequences: Lists,Arrays, WrappedString, and several others.
For symmetry, Domain also has an apply method that builds a domain string from a variable argument
parameter of domain parts starting with the top-level domain. As always, the applymethod is optional.
You can use the Domain extractor to get more detailed information out of email strings. For instance, to
search for an email address named "tom" in some ".com" domain, you could write the following
function:
def isTomInDotCom(s: String): Boolean = s match {
case EMail("tom", Domain("com", _*)) &#8658; true
case _ &#8658; false
}
This gives the expected results:
scala&gt; isTomInDotCom("tom@sun.com")
res3: Boolean = true
scala&gt; isTomInDotCom("peter@sun.com")
res4: Boolean = false
scala&gt; isTomInDotCom("tom@acm.org")
res5: Boolean = falseIt&#8217;s also possible to return some fixed elements from an unapplySeq together with the variable part.
This is expressed by returning all elements in a tuple, where the variable part comes last, as usual. As
an example, Listing 26.5 shows a new extractor for emails where the domain part is already expanded
into a sequence:
object ExpandedEMail {
def unapplySeq(email: String)
: Option[(String, Seq[String])] = {
val parts = email split "@"
if (parts.length == 2)
Some(parts(0), parts(1).split("\\.").reverse)
else
None
}
}
Listing 26.5 - The ExpandedEMail extractor object.
The unapplySeq method in ExpandedEMail returns an optional value of a pair (a Tuple2). The first
element of the pair is the user part. The second element is a sequence of names representing the
domain. You can match on this as usual:
scala&gt; val s = "tom@support.epfl.ch"
s: String = <a href="mailto:tom@support.epfl.ch">tom@support.epfl.ch</a>
scala&gt; val ExpandedEMail(name, topdom, subdoms @ _*) = s
name: String = tom
topdom: String = ch
subdoms: Seq[String] = WrappedArray(epfl, support)
26.5 EXTRACTORS AND SEQUENCE PATTERNS
You saw in Section 15.2 that you can access the elements of a list or an array using sequence patterns
such as:
List()
List(x, y, _*)
Array(x, 0, 0, _)
In fact, these sequence patterns are all implemented using extractors in the standard Scala library. For
instance, patterns of the form List(&#8230;) are possible because the scala.Listcompanion object is an
extractor that defines an unapplySeq method. Listing 26.6 shows the relevant definitions:
package scala
object List {
def apply[T](elems: T*) = elems.toList
def unapplySeq[T](x: List[T]): Option[Seq[T]] = Some(x)
&#8230;
}Listing 26.6 - An extractor that defines an unapplySeq method.
The List object contains an apply method that takes a variable number of arguments. That&#8217;s what lets
you write expressions such as:
List()
List(1, 2, 3)
It also contains an unapplySeq method that returns all elements of the list as a sequence. That&#8217;s what
supports List(&#8230;) patterns. Very similar definitions exist in the object scala.Array. These support
analogous injections and extractions for arrays.
26.6 EXTRACTORS VERSUS CASE CLASSES
Even though they are very useful, case classes have one shortcoming: they expose the concrete
representation of data. This means that the name of the class in a constructor pattern corresponds to the
concrete representation type of the selector object. If a match against:
case C(&#8230;)
succeeds, you know that the selector expression is an instance of class C.
Extractors break this link between data representations and patterns. You have seen in the examples in
this section that they enable patterns that have nothing to do with the data type of the object that&#8217;s
selected on. This property is called representation independence. In open systems of large size,
representation independence is very important because it allows you to change an implementation type
used in a set of components without affecting clients of these components.
If your component had defined and exported a set of case classes, you&#8217;d be stuck with them because
client code could already contain pattern matches against these case classes. Renaming some case
classes or changing the class hierarchy would affect client code. Extractors do not share this problem,
because they represent a layer of indirection between a data representation and the way it is viewed by
clients. You could still change a concrete representation of a type, as long as you update all your
extractors with it.
Representation independence is an important advantage of extractors over case classes. On the other
hand, case classes also have some advantages of their own over extractors. First, they are much easier
to set up and to define, and they require less code. Second, they usually lead to more efficient pattern
matches than extractors, because the Scala compiler can optimize patterns over case classes much
better than patterns over extractors. This is because the mechanisms of case classes are fixed, whereas
an unapply or unapplySeq method in an extractor could do almost anything. Third, if your case classes
inherit from a sealed base class, the Scala compiler will check your pattern matches for exhaustiveness
and will complain if some combination of possible values is not covered by a pattern. No such
exhaustiveness checks are available for extractors.
So which of the two methods should you prefer for your pattern matches? It depends. If you write code
for a closed application, case classes are usually preferable because of their advantages in conciseness,speed and static checking. If you decide to change your class hierarchy later, the application needs to be
refactored, but this is usually not a problem. On the other hand, if you need to expose a type to
unknown clients, extractors might be preferable because they maintain representation independence.
Fortunately, you need not decide right away. You could always start with case classes and then, if the
need arises, change to extractors. Because patterns over extractors and patterns over case classes look
exactly the same in Scala, pattern matches in your clients will continue to work.
Of course, there are also situations where it&#8217;s clear from the start that the structure of your patterns does
not match the representation type of your data. The email addresses discussed in this chapter were one
such example. In that case, extractors are the only possible choice.
26.7 REGULAR EXPRESSIONS
One particularly useful application area of extractors are regular expressions. Like Java, Scala provides
regular expressions through a library, but extractors make it much nicer to interact with them.
Forming regular expressions
Scala inherits its regular expression syntax from Java, which in turn inherits most of the features of
Perl. We assume you know that syntax already; if not, there are many accessible tutorials, starting with
the Javadoc documentation of class java.util.regex.Pattern. Here are just some examples that should be
enough as refreshers:
ab?
An &#8216;a&#8217;, possibly followed by a &#8216;b&#8217;.
[1em] \d+ A number consisting of one or more digits represented by \d.
A word starting with a letter between a and d in lower or upper case, followed by a
[a-dA-D]\w* sequence of zero or more "word characters" denoted by \w. (A word character is a letter,
digit, or underscore.)
A number consisting of an optional minus sign, followed by one or more digits,
[1em](-)?
optionally followed by a period and zero or more digits. The number contains
(\d+)(\.\d*)? three groups, i.e., the minus sign, the part before the decimal point, and the fractional
part including the decimal point. Groups are enclosed in parentheses.
Scala&#8217;s regular expression class resides in package scala.util.matching.
scala&gt; import scala.util.matching.Regex
A new regular expression value is created by passing a string to the Regex constructor. For instance:
scala&gt; val Decimal = new Regex("(-)?(\\d+)(\\.\\d*)?")
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
Note that, compared to the regular expression for decimal numbers given previously, every backslash
appears twice in the string above. This is because in Java and Scala a single backslash is an escape
character in a string literal, not a regular character that shows up in the string. So instead of &#8216;\&#8217; you need
to write &#8216;\\&#8217; to get a single backslash in the string.If a regular expression contains many backslashes this might be a bit painful to write and to read.
Scala&#8217;s raw strings provide an alternative. As you saw in Section 5.2, a raw string is a sequence of
characters between triple quotes. The difference between a raw and a normal string is that all characters
in a raw string appear exactly as they are typed. This includes backslashes, which are not treated as
escape characters. So you could write equivalently and somewhat more legibly:
scala&gt; val Decimal = new Regex("""(-)?(\d+)(\.\d*)?""")
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
As you can see from the interpreter&#8217;s output, the generated result value for Decimal is exactly the same
as before.
Another, even shorter way to write a regular expression in Scala is this:
scala&gt; val Decimal = """(-)?(\d+)(\.\d*)?""".r
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
In other words, simply append a .r to a string to obtain a regular expression. This is possible because
there is a method named r in class StringOps, which converts a string to a regular expression. The
method is defined as shown in Listing 26.7:
package scala.runtime
import scala.util.matching.Regex
class StringOps(self: String) &#8230; {
&#8230;
def r = new Regex(self)
}
Listing 26.7 - How the r method is defined in StringOps.
Searching for regular expressions
You can search for occurrences of a regular expression in a string using several different operators:
regex findFirstIn str
Finds first occurrence of regular expression regex in string str, returning the result in an Optiontype.
regex findAllIn str
Finds all occurrences of regular expression regex in string str, returning the results in anIterator.
regex findPrefixOf str
Finds an occurrence of regular expression regex at the start of string str, returning the result in
an Option type.For instance, you could define the input sequence below and then search decimal numbers in it:
scala&gt; val Decimal = """(-)?(\d+)(\.\d*)?""".r
Decimal: scala.util.matching.Regex = (-)?(\d+)(\.\d*)?
scala&gt; val input = "for -1.0 to 99 by 3"
input: String = for -1.0 to 99 by 3
scala&gt; for (s &#8592; Decimal findAllIn input)
println(s)
-1.0
99
3
scala&gt; Decimal findFirstIn input
res7: Option[String] = Some(-1.0)
scala&gt; Decimal findPrefixOf input
res8: Option[String] = None
Extracting with regular expressions
What&#8217;s more, every regular expression in Scala defines an extractor. The extractor is used to identify
substrings that are matched by the groups of the regular expression. For instance, you could decompose
a decimal number string as follows:
scala&gt; val Decimal(sign, integerpart, decimalpart) = "-1.23"
sign: String = -
integerpart: String = 1
decimalpart: String = .23
In this example, the pattern, Decimal(&#8230;), is used in a val definition, as described in Section 15.7. What
happens here is that the Decimal regular expression value defines an unapplySeqmethod. That method
matches every string that corresponds to the regular expression syntax for decimal numbers. If the
string matches, the parts that correspond to the three groups in the regular expression (-)?(\d+)
(\.\d*)? are returned as elements of the pattern and are then matched by the three pattern
variables sign, integerpart, and decimalpart. If a group is missing, the element value is set to null, as
can be seen in the following example:
scala&gt; val Decimal(sign, integerpart, decimalpart) = "1.0"
sign: String = null
integerpart: String = 1
decimalpart: String = .0
It&#8217;s also possible to mix extractors with regular expression searches in a for expression. For instance,
the following expression decomposes all decimal numbers it finds in the inputstring:
scala&gt; for (Decimal(s, i, d) &#8592; Decimal findAllIn input)
println("sign: " + s + ", integer: "<br />
i + ", decimal: " + d)
sign: -, integer: 1, decimal: .0
sign: null, integer: 99, decimal: nullsign: null, integer: 3, decimal: null
26.8 CONCLUSION
In this chapter you saw how to generalize pattern matching with extractors. Extractors let you define
your own kinds of patterns, which need not correspond to the type of the expressions you select on.
This gives you more flexibility in the kinds of patterns you can use for matching. In effect it&#8217;s like
having different possible views on the same data. It also gives you a layer between a type&#8217;s
representation and the way clients view it. This lets you do pattern matching while maintaining
representation independence, a property which is very useful in large software systems.
Extractors are one more element in your tool box that let you define flexible library abstractions. They
are used heavily in Scala&#8217;s libraries, for instance, to enable convenient regular expression matching.</p></div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated
 2019-02-18 00:09:52 EET
</div>
</div>
</body>
</html>
